標準モジュールにコードを置く場合は、対象のシートの全てのシートモジュールに以下のコードを記入しないとダメです。 --------------------------------------------------------------------------- Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Call ○○(Target) End Sub ---------------------------------------------------------------------------
No.1です。 条件付き書式で色付けされているというコトですので・・・ お使いのバージョンがExcel2010以降であれば、DisplayFormatオブジェクトが使えます。 ↓のコードにしてみてください。 Sub Sample2() Dim k As Long, c As Range, myFlg As Boolean For k = 1 To Worksheets.Count For Each c In Worksheets(k).UsedRange If c.DisplayFormat.Interior.ColorIndex = 3 Then myFlg = True Exit For End If Next c If myFlg = True Then Worksheets(k).Tab.ColorIndex = 3 myFlg = False End If Next k End Sub ※　バージョンが2007までの場合は使えません。 条件付き書式の条件をそのままコード内に入れてやる必要があると思います。 補足を拝見すると ＞１つ上の行と比較して一致しない場合は赤塗りつぶし・・・ というコトですので、 上記コードの ＞If c.DisplayFormat.Interior.ColorIndex = 3 Then の行を ＞If c.Row > 1 And c <> c.Offset(-1) Then に変更してみてください。m(_ _)m
一旦、フィルタをクリアした後、値の設定されているコンボボックスのみを対象に、フィルタを設定します。こんな感じです。 Private Sub CommandButton1_Click() ActiveSheet.ShowAllData With ActiveSheet.Range("$A$3:$S$3") If ComboBox1.Value <> "" Then .AutoFilter Field:=1, Criteria1:=ComboBox1.Value If ComboBox2.Value <> "" Then .AutoFilter Field:=7, Criteria1:=ComboBox2.Value If ComboBox3.Value <> "" Then .AutoFilter Field:=8, Criteria1:=ComboBox3.Value End With End Sub
答えを表示するためのテキストボックス、値を入力するためのテキストボックスなどがあり、入力操作中も随時書式を適用したいってことでしょうか？ たしかこれは標準状態のテキストボックスでは無理だったと思います。 技術のある方が自作して公開してくださっているカスタム コントロールを導入するか、有料で販売されているコントロールを購入するか、自分で作成するかのどれかでしょうね。 これを自力でやろうとすると非常に面倒だということがすぐにわかります。 ・ 大前提 Type-A 入力中もカンマが数字の間に割って入る。 Type-B 入力中は数字だけになり、入力が終わるとカンマが割って入る。 どちらなのかによって中身が違ってくる。 ・ Type-A の場合 入力の最中にもカンマの位置が次々に変化したり現れたり消えたりする処理が必要。 一文字変化するたびにこれらを処理し、且つ入力中のカーソルの位置も調整する必要がある。 ・ Type-B の場合 テキストボックスにカーソルが入った時にカンマを抜き取り、カーソルが出て行ったときに整形する。 ユーザーが入力した値が数値として評価できない場合はテキストボックスの検証機能を使ってユーザーに注意を促すようにすれば、結果的にテキストボックスの値は数値として評価できる値になるので、テキストボックスにカーソルが入ってきたときの処理が楽になる。（「空白または数値である」という前提で行ける） ・ その他 入力できる文字種を制限するのか。 + や - は入力可能なのか。 + や - だけでやめた場合はどう評価するのか。 00001 のような入力も可能とするのか、電卓のように無反応とするのか。 などなど考慮するべき点はたくさんあります。 まずはどんなテキストボックスにするのかをじっくり考えてみて、必要な処理を割り出してみる必要がありますね。 「初心者です」というのであればここで一発、自力で開発してみてはどうでしょうか。 自力はギブだけど要件は満たしたいという場合は先人の力作を使ってみてはどうでしょう。 http://jeanne.wankuma.com/library/ http://www.ailight.jp/Content/Read/AIControls
#1の回答者です。 もう一度読みなおしてみました。 >１行のなかに0000から0020までのコントロールコード なぜ、バイナリか、よく読んでいなかったけれど、通称、エスケープシーケンスではありませんか？その中でCRLF だけを残すわけでしょう？昔は、よくあった話ですが、今は、ほとんど聞かれなくなってしまいましたね。 実務的なことなのですが、私の場合は、いつだったか、あまり頭を使ってもうまくいかないので、NotePad++ で、処理したことを思い出しました。これって、目からうろこです。 巨大なファイルだったので、コマンドライン系のツールでも、できないものも出てきました。 >読み込むファイルは何千行もあるのですが いろいろあれこれやっていたのに、あっという間です。NotePad++ の正規表現置換で、たぶん希望通りのことは可能です。 [\x00-\x20] これでなぜ、CRLF が残るのかはよく分かりません。含まれているはずなのですが、素通りしていくようです。急ぎなら、こうしたほうがよいと思います。 ちなみに、先ほど、nkf でできると思ってやってみましたが、nkf やnkfwin でも、うまくいく様子がありません。もし、nkf でできれば、VB6 に組み込めばよいのですが。何が原因か、まだ分かりません。
対象機種: WINDOWS 95/WINDOWS 98となっていますから無理でしょう。 http://qpon.quu.cc/basic/winbas95.htm 互換性でインストールできませんか？ Windows 10に対応していないアプリは、従来のOSの「互換モード」で実行することができることがあります。すべてのアプリが動くわけではありませんが・・・アプリのプログラム本体(.exeファイル）の保存場所を開き、「スタート」メニューの「すべてのアプリ」や、デスクトップのショートカットからアプリの保存先を開くには、アイコンを右クリック「ファイルの場所を開く」を選び、「ショートカット」タブの画面で「ファイルの場所を開く」を選ぶと、アプリ本体の保存先を開けます。 プログラム本体(.exeファイル）のアイコン右クリック「プロパティ」「互換性」タブに切り替え、「互換モード」の「互換モードでこのプログラムを実行する」にチェックをつけて、動作可能なOS（例：Windows7）を選択、アプリを実行 http://pcfan.121ware.com/useful/787/
こんにちは ＞貼り付けたパスのファイルをSheet1とSheet2に貼り付けるにはどう～ 通常ファイルには複数（または1つ）のシートがあり、シート名も自由につけることができますので、どのシートをどこに張り付けるかを特定する必要があります。 ファイルパスがどこに記してあるのかなど不明点が多いので、以下はあくまでも要領のみのサンプルですが・・・ 最低限で記述するなら、 ファイルをオープンして、コピー、ファイルを閉じるといった手順で、 （要領を示すものなので、シートのコピーは1シートのみにしてあります） Sub Sample1() Dim wb As Workbook, fPath As String Const kSheet = "hoge" '起動用シート名 Const cellName = "A1" 'パスが記述してあるセル名 '指定ファイルを開く fPath = ThisWorkbook.Worksheets(kSheet).Range(cellName).Text Set wb = Workbooks.Open(fPath) 'シートをコピー wb.Worksheets("Sheet1").Cells.Copy _ 　　Destination:=ThisWorkbook.Worksheets("Sheet1").Range("A1") 'ファイルを閉じる wb.Close SaveChanges:=False End Sub のような要領で可能かと思います。 でも、このままだと、パスが間違っていたり対象ファイルがすでに開いていたりするとうまく動作しません。 そのあたりのチェックもすると、手順は同じですが、概ね以下のような要領になるでしょうか。 Sub Sample2() Dim wb As Workbook Dim fPath As String, fName As String Dim i As Integer, flag As Boolean Const kSheet = "hoge" '起動用シート名 Const cellName = "A1" 'パスが記述してあるセル名 '指定パスからファイル名を取得 fPath = ThisWorkbook.Worksheets(kSheet).Range(cellName).Text i = InStrRev(fPath, "\") fName = fPath If i > 0 Then fName = (Mid(fPath, i + 1)) '指定ファイルが既に開いているかをチェック flag = False For i = 1 To Workbooks.Count 　If Workbooks(i).Name = fName Then 　　Set wb = Workbooks(i) 　　flag = True 　　Exit For 　End If Next i '開いていなければ新たにOPENする If Not flag Then 　On Error Resume Next 　Set wb = Workbooks.Open(fPath) 　If Err.Number = 1004 Then 　　MsgBox "指定のファイルが存在しません" 　　Exit Sub 　Else 　　On Error GoTo 0 　End If End If '開いたファイルのSheet1をコピー wb.Worksheets("Sheet1").Cells.Copy _ 　Destination:=ThisWorkbook.Worksheets("Sheet1").Range("A1") '対象ファイルを開いた場合は閉じる '既に開いていた場合はそのまま If Not flag Then wb.Close SaveChanges:=False End Sub ※ 対象のファイル名が同じでパス違いのものが数多く存在する場合は、上記のチェックでは（開いているファイルのチェックが少し甘いので）区別できない場合があります。
新規作成のブックを空白のまま作り適当なところに保存して、今のコードでそのブックを指定して動かしたらエラーは出るかもしれませんが先に進みますか？
#2の私の質問には答えられていませんので、こちらとしては、もう深追いなどはしませんが、あえて、回答のひとつとしてつけておくと、もし、Max 関数で取るなら、 Private Sub Worksheet_Change(ByVal Target As Range) Dim num As Variant 　On Error GoTo ErrHandler 　If Target.Column <> 1 Then Exit Sub 　If Target.Count > 1 Then Exit Sub 　If Target.Value = "" Then Exit Sub 　If Target.Offset(, 2).Value <> "" Then Exit Sub　 'すでに番号がある場合 　Application.EnableEvents = False 　num = Application.Max(Columns(3), Worksheets("Sheet2").Columns(3)) + 1 　If IsNumeric(num) Then 　　Target.Offset(, 2).Value = num 　End If ErrHandler: 　If Err() <> 0 Then 　　MsgBox "エラーが発生しています。調べてください。", vbCritical 　End If 　Application.EnableEvents = True End Sub ワークシート関数は、全行・全列を指定すると、メモリ範囲の所までしか読みませんので、実際は、セルの範囲しか読まないのです。また、文字列は読みません。 ただ、これは、ご質問の趣旨とは違っていますし、こちらの思惑だけで進めてよいものかは疑問に残るところです。
すいません。回答ではないのですが、2点、確認させてください。 まず、「出だしは快調で…だんだん遅くなり…」とのことですが、この時間の測定は、どのように行っているのでしょうか？ 次に、「固まる」とは、何をもって固まったと判断されていますか？ 何が気になっているのかと云うと、Excelって、”（応答なし）”と表示していても裏で一生懸命処理していて、いつの間にか正常終了していたことがあったので…。 だんだん遅くなるということが正確に測定されているのであれば、疑う余地はないのですが…。
こんにちは！ 人様がお考えになったコードに手を加えるのは好みではないので・・・ Sub Sample1() Dim i As Long, c As Range, wS As Worksheet Set wS = Worksheets("Sheet1") With Worksheets("Sheet2") For i = 3 To .Cells(Rows.Count, "A").End(xlUp).Row Set c = wS.Range("G:G").Find(what:=.Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then With .Cells(i, "I") .Value = wS.Cells(c.Row, "B") .Offset(, 1) = wS.Cells(c.Row, "K") .Offset(, 2) = wS.Cells(c.Row, "M") .Offset(, 3) = wS.Cells(c.Row, "S") End With End If Next i End With MsgBox "完了" End Sub ※　Sheet1のG列に重複データがある場合、 最初にヒットした行のデータが表示されます。 こんな感じをご希望をご希望なのでしょうか？m(_ _)m
こんばんは。 #1の回答者です。 >「実行時エラー　1004 >ドキュメントを保存できませんでした。ドキュメントを開いているか、保存時にエラーが発生した可能性があります。」 なるほど、コードの問題ではありませんね。 office2010のPDF保存機能で 「ドキュメントが開いているかエラーが発生しています」 のエラーが発生する http://answers.microsoft.com/ja-jp/office/forum/ … 「通常モードでPDFを保存オプションを開き「ISO19005-1に準拠（PDF/A）」のチェックを外したところ、正常に保存することができるようになりました」 とあります。一度、手動で直してみてから、試したらどうなるでしょうか。
#1の回答者です。 私は、Excel VBAでは、配列で処理することが多いのですが、もう何年もやっているはずなのに、まだ、新しいやり方をみて、それを使ったりします。 #1のお礼欄のご質問、さすがに鋭いですね。#1で省略した部分です。微妙な所もあって、書き渋ってしまいました。 人には人のスタイルがある、という所をわきまえていただければ十分なのですが、人によっては、白を黒と言いくるめられるぐらいの技量のある人から、私の書いた内容を、うやむやにするか、あえて、間違っているかのように、例をつけて説明する人がいます。 お急ぎなら、最後のまとめがありますので、それで読んだほうがはやいです。 それで、まず、ここから。 >セルと配列のインデックスを分けて管理しやすく？しているのだと思いますが、 >他になにか理由はありますか。 >> こうしたFor Each スタイルを取るというのはレアケースだと思います。 かつて、九天社というところで、『VBA デバッグ　実践のツボ』には、 以下のコードとともに、「For Each ～ Next では、検査はできても代入はできない」として、紹介していました。 Sub Sample12Kten() 　　Dim ary_num() As Variant　　'配列要素を格納 　　Dim i As Variant　　'個々の配列要素を格納 　　ary_num = Array(123, 234, 345, 456)　　'初期値を格納 　　'特定の配列要素の場合、配列の内容を変更 　　For i = LBound(ary_num) To UBound(ary_num) 　　　　If ary_num(i) = 234 Then 　　　　　　 ary_num = Array(567, 678, 789, 890) 　　　　End If 　　Next i 　　'配列要素を表示 　　MsgBox "ary_num(0) = " & ary_num(0) & vbCrLf & _ 　　　　　 "ary_num(1) = " & ary_num(1) & vbCrLf & _ 　　　　　 "ary_num(2) = " & ary_num(2) & vbCrLf & _ 　　　　　 "ary_num(3) = " & ary_num(3) End Sub また、例えば、２次元の時どうするか、ということも含まれています。For Each で取ると、縦横が逆転してしまったります。Index(添字）の管理のほうがずっと優れていると思うのです。 Sub maKingArray() 'こちらはどうでもよいです。２次元変数をつくるためのコード Dim i, j Dim a, ar 　ReDim ar(10, 2)　　'元になる方を2次側に置くのが一般(変更可能） 　a = Array("A", "B", "C") 　For j = 0 To 2 　　For i = 0 To 10 　　　If i = 0 Then 　　　　ar(i, j) = a(j) 　　　Else 　　　　ar(i, j) = a(j) & i 　　　End If 　　Next i 　Next j 　Call ArrayTest(ar) End Sub Sub Sample3(arg As Variant) '大事なのはこちら。セルの構造と同じになります。 Dim x, y, i, j y = UBound(arg)　　　'xは横 x = UBound(arg, 2)　　'yは縦　(1次元か2次元か分からない時は、On Error トラップが必要ですょ For j = 0 To x For i = 0 To y 　Cells(i + 1, j + 1).Value = arg(i, j) Next i Next j End Sub '// 配列というのは、要素にオブジェクトを取り込むことはめったにありません。だいたい文字列か数値か、そのどちらかです。配列の構造も、End of File でも、End of Data でもなく、計数で終わることが可能なのです。 さて本題です。 >> ReDim ary(j)　　'ここでは、LastRowは反映させないことにする。 動的に作るためにはそこでは、配列を作らないようにしました。 Redim ary(LastRow -1 ) で可能だからです。 #1のコードを、 　　LastRow = Cells(Rows.Count, 1).End(xlUp).Row 　　ReDim ary(LastRow -1)　　'ReDim ary(0 To LastRow -1) とすることができます。 >変数jの初期設定を行っておりませんが、宣言時にゼロ値（Longなら0）に自動で>初期化されることが保証されるのでしょうか？ 私は、その話は、一度書きかけたのですが、#1では、やめたのでした。世の中、いろんな人がいますから、そういう中のひとりが「自分はこうだ」と主張して、こちらの話をうやむやにする人がいます。 「宣言時にゼロ値に自動で初期化される」 デフォルト状態なら、Index(添字）は、必ずゼロからです。 それがすべてなら、なんの問題ももないのですが、そうではないというのは、 配列のIndexの初期値を 1 に設定する、「Option Base 1 」があるという話に発展してきます。 Option Base 1 で、配列のIndexの初期値は、1になります。 個別のコーディングルールを持ち出すのはおこがましいのですが、少なくとも、私の中のルールでは、Option Base 1 や、Option Compare Text も使わないというルールを設けているからです。 http://officetanaka.net/excel/vba/variable/07.htm 田中氏は、相変わらず、すっきりとした説明ではありませんが、、 「配列を返すVBAの命令には、最小の要素が1から始まる配列を返すものもあります」これは、単にオブジェクトを配列として受ける側になれば、配列のように見えるものでも、1から始まるものは、それは配列とは考えない方がよいのではないか、と私は考えています。そして、それはCollectionだと考えます。 Excelで言えば、Sheets, Range は、1からですが、これらは配列ではなく、Collection です。 もうひとつは、私の中では、いつまでも、VBA/VB6の環境が続くのか、という根本的な懸念が含まれているからなのです。他の環境で、Option Base 1 が許されるのか、と考えます。つまり、それは移植性が高いか低いのではないかということです。Option Base 1とかで作られたものを0ベースに直すのは、意外に面倒なものなのです。 どこかのサイトでは、Indexは、0なら、0、1なら1と明示的に宣言してあげなくてはいけないと言っている人がいます。それは、ごもっともだと思います。 でも、それは、つまり、動的配列で一般的にそんなことができるのか、という疑問もあります。 動的配列に、以下のように書く人がいるのかな？ (なんとも不格好なコードだと思います） Sub Sample2() 　Dim ary() As Variant, i As Long, j As Long 　Dim LastRow As Long 　ReDim ary(1 To 1) 　 　LastRow = Cells(Rows.Count, 1).End(xlUp).Row 　j = 1 　For i = 1 To LastRow 　　ary(j) = Cells(i, 1).Value 　　j = j + 1 　　If j >= LastRow Then Exit For 　　ReDim Preserve ary(1 To j) 　Next i For i = LBound(ary) To UBound(ary)　　'1からですが。 　 MsgBox TypeName(ary(i)) & ": " & ary(i) Next i End Sub 私の話をまとめますと、 ・配列の管理は、Index（添字）のほうがやりやすいです。 ・動的配列では、最初は、基本的には必ずゼロ・スタートです。 ・Option Base は、つかないほうがよい、 ということです。 なお、他には、パラメータ配列やコントロール配列という言葉がありますが、これらは別ものですから、今回には加えません。
こんばんは！ どののセルをダブルクリックしてもその行をSheet2の最終行の下にコピー＆ペーストするようにしてみました。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Cancel = True With Target Cells(.Row, .Column).EntireRow.Copy Worksheets("Sheet2").Cells(Rows.Count, "A").End(xlUp).Offset(1) End With End Sub こんな感じではどうでしょうか？m(_ _)m
すみません。質問の細かい所無視ですが、 埋込み型グラフ(シート上)に、ひとつ置いて、実行すれば、図の中にチャートが入ります。この操作というのは、簡単だけれども、古い技術なのです。 ただ、私のほうでは、絵がボケていますね。やはり専用ツールのほうがよいかもしれません。 Sub Test1() Const TEMP As String = "$Temp.gif" Dim Shp As Shape With ActiveSheet 　.ChartObjects(1).Chart.Export Filename:=TEMP, FilterName:="GIF" 　Set Shp = .Shapes.AddShape(msoShapeRectangle, 250, 250, 360, 200) 　Shp.Fill.UserPicture PictureFile:=ThisWorkbook.Path & TEMP 　Shp.Visible = msoTrue 　Kill ThisWorkbook.Path & TEMP 'TEMPファイルの削除 　Set Shp = Nothing End With End Sub >ActiveSheet.Shapes("Rectangle 14") 既存のオートシェイプに貼り付けるのは、面倒ですね。 いっそ、Selection にしてしまったほうが速いと思います。 なお、クリップボードから取り出す話は、一応なしにしてください。かなり面倒だからです。クリップボードの中身を1つずつ調べて、必要なものを取り出さないといけないのです。 そういうメソッドが、Excel側にVBAには用意されていないので、一から、取り出すプログラムを作らなくてはなりません。クリップボードの蓋を開けて取り出して蓋を閉めるという作業なのです。（^^;
試しに作って、動かして出るエラーも含めて投稿し、 添削してもらうのがよいかも、です。
もし E:\Exceclデータ\vbaにあるtest.xlsx　が、VBAを実行しているファイルと同じフォルダーなら .Attachments.Add ThisWorkbook.Path & "\test.xlsx" でも良いかも
> 201606 175 > . 1 上のデータから、どれがA列,B列,C列なのかが読み取れません。 補足されたほうが良いですね。 この掲示板は連続する半角スペースは、一個にまとめられてしまいます。 確認画面で確認されなかったのでしょうか？ > 丸投げになってしまい恐縮ですが と仰られるのであれば、最低限わかり易い情報提示はされるべきかと思います。
こんにちは。 MsgBox "エラーコードNo." & Err.Number & vbCrLf & Err.Description このようにするのが正式な書き方どは思いますが、検索して得られなかったら、「見つかりません」でもよいかなって思いました。 以下は、日付はシリアル値がセルで書かれているという条件で、シリアル値で探すということにました。(書式: yyyymmdd) '// Sub 検索2() 　Dim a As Variant, b As Variant, c As Variant, d As Variant 　Dim Data As Variant 　 　Worksheets("Dt").Activate 　a = Application.InputBox("日付を入力してください。例 20160810", Type:=1) 　If VarType(a) = vbBoolean Then Exit Sub 　 　a = Format(a, "##/##/##") 　If Not IsDate(a) Then 　　MsgBox "日付として認識できませんでした。", vbExclamation 　　Exit Sub 　Else 　　a = CDate(a) 　End If 　 　b = Application.InputBox("社員番号を入力してください。", Type:=1) 　If VarType(a) = vbBoolean Then Exit Sub 　 　Data = Columns("B").Value2　'バージョンによっては問題が発生するかもしれません。その場合は、 　'Data = Range(Cells(1, 2), Cells(Rows.Count, 2).End(xlUp)).Value2 　 　c = Application.Match(CLng(a), Data, 0) 　If IsNumeric(c) Then 　　c = c & "行目" 　Else 　　c = "見つかりません。" 　End If 　 　d = Application.Match(b, Columns("C"), 0) 　If IsNumeric(d) Then 　　d = d & "行目" 　Else 　　d = "は見つかりません。" 　End If 　 　MsgBox "日付は" & c & vbCrLf & _ 　"社員番号は" & d End Sub '解説： Application.Match と、WorksheetFunction.Match との違い。 Application.Match の場合は、エラーをワークシートと同様のエラー値として返します。だから、IsError 関数などで認識できますが、しかし、WorksheetFuncion.Matchは、VBAとしてのエラーになってしまいます。 文字列日付値は、CDate や DateValue などを使って、日付値に変換します。
以下の５か所に追加・変更してみてください。 「＊＊追加＊＊」とコメントしてある部分です。 '---- 結果表の列位置 Private Enum ColumnPosEnum 　　ObjectName = 0 '名称(フォルダまたはファイルの) 　　FullPath = 1 'フルパス 　　ObjectTypeName = 2 '形式(フォルダ/ファイル) 　　TotalSize = 3 'サイズ (フォルダは内容のサイズ) ' 　　LastModified = 4 ' ＊＊追加＊＊（以降の数字を＋１すること） ' 　　CountOfFolder = 5 '下位フォルダ(サブフォルダ含む)の個数。 　　CountOfFile = 6 '下位ファイル(サブフォルダ内を含む)の個数。 　　HierarchyLevel = 7 '開始フォルダを0とした階層レベル 　　HierarchyInfo = 8 '階層形式の表示 End Enum ----- 　　'列見出し 　　csListBaseCell.Offset(-1, ColumnPosEnum.ObjectName).Value = "名称" 　　csListBaseCell.Offset(-1, ColumnPosEnum.FullPath).Value = "フルパス" 　　csListBaseCell.Offset(-1, ColumnPosEnum.ObjectTypeName).Value = "形式" 　　csListBaseCell.Offset(-1, ColumnPosEnum.TotalSize).Value = "サイズ" ' 　　csListBaseCell.Offset(-1, ColumnPosEnum.LastModified).Value = "最終更新日時" ' ＊＊追加＊＊ ' 　　csListBaseCell.Offset(-1, ColumnPosEnum.CountOfFolder).Value = "フォルダ数" 　　csListBaseCell.Offset(-1, ColumnPosEnum.CountOfFile).Value = "ファイル数" 　　csListBaseCell.Offset(-1, ColumnPosEnum.HierarchyLevel).Value = "階層番号" ----- 　　'(*) ファイルのとき、個数欄は空のセルにする 　　'(*) フォルダのとき、全個数集計時 … 後で集計値を上書きするので仮に0をセルに記入 　　'(*) フォルダのとき、直下個数のみ表示 … 直下個数を表示、サイズは省略 　　Select Case pObjectTypeName 　　　　Case csObjectTypeName_Folder 　　　　　　Set wDir = pObject 　　　　　　If mIsFullScan Then 　　　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.TotalSize).Value = 0 　　　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.CountOfFolder).Value = 0 　　　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.CountOfFile).Value = 0 ' 　　　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.LastModified).Value = 0 ' ＊＊追加＊＊ ' 　　　　　　Else 　　　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.TotalSize).Value = "" 　　　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.CountOfFolder).Value = wDir.SubFolders.Count 　　　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.CountOfFile).Value = wDir.Files.Count ' 　　　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.LastModified).Value = wDir.DateLastModified ' ＊＊追加＊＊ ' 　　 End If 　　　　Case csObjectTypeName_File 　　　　　　Set wFile = pObject 　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.TotalSize).Value = wFile.Size ' 　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.LastModified).Value = wFile.DateLastModified' ＊＊追加＊＊ ' 　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.CountOfFolder).Value = "" 　　　　　　csListBaseCell.Offset(Y, ColumnPosEnum.CountOfFile).Value = "" 　　End Select
こんばんは。 すでに回答がついていますが、もう一度、考えなおしてみてください。 >シート2の同じ文字列へジャンプさせる方法についてご教示お願いします。 VBAだったら、ハイパーリンクを設定しなくても飛べますが・・・。 ジャンプさせる方法。 'シートタブを右クリックして、コードの表示で貼り付ける Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Dim i As Variant Dim sh2 As Worksheet Set sh2 = Worksheets("Sheet2") Cancel = True If Target.Column <> 1 Then Exit Sub If Target.Value = "" Then Exit Sub i = Application.Match(Target.Value, sh2.Columns(2), 0) If IsNumeric(i) Then 　　Application.Goto sh2.Cells(i, 2) Else 　　MsgBox "該当するセルは見つかりません。", vbExclamation End If End Sub '// ------------------------- 'ハイパーリンクを取り付ける Sub Main() Dim sh1 As Worksheet Dim rng As Range Dim r1 As Range Set sh1 = Worksheets("Sheet1") With sh1 Set r1 = .Range(.Cells(1, 1), .Cells(Rows.Count, 1).End(xlUp)) End With For Each rng In r1 　If rng.Value <> "" Then 　　 Call makeHyperLinks(rng, sh1) 　End If Next rng End Sub Sub makeHyperLinks(rng As Range, sh As Worksheet) 　Dim sh2 As Worksheet 　Dim c As Variant 　Set sh2 = Worksheets("Sheet2") 　Set c = sh2.Columns(2).Find(rng.Value, , xlValues, xlWhole, , False) 　If Not c Is Nothing Then 　　sh.Hyperlinks.Add rng, "", sh2.Name & "!" & c.Address(0, 0) 　End If End Sub '//
先ほど、本当の意味でのクリックイベントを作ってみましたが、おすすめできるようなものではありませんでした。 ご存知かもしれませんが、API関数の「GetAsyncKeyState」を使う方法です。 実際、私の方では、考えられるものは全部お話しました。 >CANCEL=TRUE Cancel =True というのは、ダブルクリックしたままだと、入力待ち状態になって、マクロが動かなるのを防ぐためです。しかし、それは、ファイル上のトラブルとは関係がありません。そういう状態が起これば別ですが。 つまり、フリーズ状態というものも、タスクマネージャで、リセットをしなければならないのか、ESCやVBEditor 上の「　|>, ||, ■　」ボタンの■で止められるものもあります。 ところで、同じ上記になった時に、私ならどうするか、デバックの手順だけお書きしておきます。 まず、問題になっているのは、SelctionChange側だと仮に特定化します。 (仮にそうでなくても） 今回は、特別に 　'Application.EnableEvents = False 　'Application.EnableEvents = True 　は、コメントブロック「'」を入れておいてもよいと思います。 　途中で止めることになるかもしれませんから。 1. ● Sub Worksheet_SelectionChange(ByVal Target As Range) VBEditor の左端をクリックすると●が入ります。 ワークシートで入力すると、ここで止まりますから、F8を押して進めていきます。 以下の行まで来ていて、それで終わってしまうでしょうか。 ActiveSheet.Range("J1") = ActiveSheet.Cells(Target.Row, 3) 2. もし、ここでF8を押すとフリーズするようなら、 3列目のどこかをクリックした値のはずですが、 ActiveSheet.Cells(Target.Row, 3) ただしく、値がきているか調べます。 a =ActiveSheet.Cells(Target.Row, 3) で、ローカルウィンドウを見ます。 ActiveSheet.Range("M1") = ActiveSheet.Cells(Target.Row, 3) --------------------------- If Target.Value <> "" Then 　On Error Resume Next 　　 Range("M1").Value = Target.Value 　On Error GoTo 0 End If ---------------------------- 次に、 ActiveSheet.Range("J1").Value J1のセルがどうなっているか、書き込める状態か、 別のマクロで試験してみるとよいでしょう。 ActiveSheet.Range("J1").Value =123 とか。 さて、本来、ここまでで終わるはずです。 3.しかし、 >EXCEL2003(.XLS)ファイルをEXCEL2010環境（互換モード）で実行しています。 拡張子が、"xls"のバイナリ状態ですから、Excel2010環境と旧環境とを分けるために、Excel 2010 では、xlsm にしてみて、様子を図るのがよいのではないかと思います。下位バージョンで作ったものを上バージョンに上げて作り直し、直したものは、上位バージョン専用にするわけです。 ワークシートに問題ある可能性がないともかぎりません。
図形の塗りつぶしで画像を使用する場合には、外部ファイルから読み込む方法しかないみたいですね。 https://msdn.microsoft.com/ja-jp/library/office/ … なので、グラフを画像ファイルとして一時的に保存して利用するしかなさそうです。 https://msdn.microsoft.com/ja-jp/library/office/ …
vb vba mouse などで検索すると、たくさん出てきませんか？ 道場、サンプル集みたいなサイトもあったような。 優しくて、気に効いたUIができるといいですね。
質問内容がよく分かりません。 入力方法とは？ リストボックスの選択リストのこと言ってます？ レコードソースを可変にしたいの？ 値集合タイプを変えたい？ とりあえず、ここ見て http://www.geocities.jp/cbc_vbnet/cnntrol/cbo.html
ここの掲示板で常連のある方の回答なら、ある程度決まったパターンで回答します。 単なる想像ですが、もしかしたら、質問の要素の肝心な説明が抜けていませんか? これは、私の回答者としての想像ですが、抜けているのは、 「上の画像は、月次報告のデータ」 「下の画像は、年次データリスト」 この年次リストの月次報告データのそれぞれのスタッフのデータを年次データ・リストに転記する (回答者としても、10数年も経理や総務で、表を作ってきた人間もいますから、なんとなくわかるものはわかります。） >マクロでsheet1のBの名前をsheet2のA列から検索してsheet2のF列をsheet1で選 >択したセルへ貼り付けたいです。 この文章そのものは、Sheet1 もSheet2 も間違っていないのではありませんか?画像の表示が間違えたということだと思うのです。 本来順序が同じなら、そのままコピー＆ペーストで行けるはずですが、そうとはなっていないのでしょう。やめた社員などあると順序が狂うわけですね。 コードは汚いのですが、一応、考えてみました。 '// Sub FilledNumbers() Dim sh1 As Worksheet Dim sh2 As Worksheet Dim rng1 As Range Dim rng2 As Range Dim cls As Long, cld As Long 'cls=ソース側, cld =目的側 destine Dim i As Variant, j As Long Set sh1 = Worksheets("Sheet1") Set sh2 = Worksheets("Sheet2") With sh1 　Set rng1 = .Range("B1", .Cells(Rows.Count, 2).End(xlUp)) 　'データ1行目からのほうが特定しやすい、B列名前欄 　cls = .Cells(1, Columns.Count).End(xlToLeft).Column 　'Sheet1 の最後の列を探している 　cls = cls - 1 '名前欄が、2列目だから、1列減る End With With sh2 　Set rng2 = .Range("A1", .Cells(Rows.Count, 1).End(xlUp)) 　cld = .Cells(1, Columns.Count).End(xlToLeft).Column 　'月次だから、月によって変わる。必ず7月なら7月というタイトルが必要 　If cld < 2 Then cld = 2　　'使うことはないはず End With For j = 2 To rng1.Rows.Count If rng1.Cells(j, cls).Value <> "" Then 　 i = Application.Match(rng1.Cells(j, 1).Value, rng2, False) 　 If IsNumeric(i) Then 　　 rng2.Cells(i, cld).Value = rng1.Cells(j, cls).Value 　 Else 　　 rng1.Cells(j, cls).Offset(, 1).Value = "x" 　　 '見つからなかった場合に x をつける 　 End If End If Next End Sub
こんばんは マクロの記録が、いいサンプルプログラムになるのはExcelの強みです。 しかし、記録されたマクロを編集しても上手くいかないこともあります。 まず、②～④です。 ファイルごとコピーするのではなく、シートだけコピーしてみてください。 ・シートのタブを右クリック ・移動先ブック名→（新しいブック） ・「コピーを作成する」にチェック で、「OK」 これを、記録してみてください。
Multiplyかな？ http://www.weblio.jp/content/Keys+%E5%88%97%E6%8 …
Captionならともかく、いわゆるオブジェクト・ネームというものは、UserFormを含めて、すべてのオブジェクトの名前は、VBAでは変更できません。外部からキーボードマクロなら可能だとは思いますが、それをするほどのこともないと思います。
こんなのいかがでしょうか？ ----------------------------------------------------------------------- Sub Sample() Dim シート名 As String Dim 行 As Long Dim シート有 As Boolean Dim パス名 As String Dim ファイル名 As String Dim 元シート As String Dim シート As Long パス名 = ThisWorkbook.Path & "\" 元シート = "Sheet1" ファイル名 = "B.xlsx" Workbooks.Open Filename:=パス名 & ファイル名 Windows(ThisWorkbook.Name).Activate Sheets(元シート).Select For 行 = 1 To Cells(Rows.Count, 1).End(xlUp).Row シート名 = Cells(行, 1).Text Windows(ファイル名).Activate シート有 = False For シート = 1 To Sheets.Count If シート名 = Sheets(シート).Name Then シート有 = True Exit For End If Next If シート有 Then Sheets(シート).Select MsgBox ("処理してください") End If Windows(ThisWorkbook.Name).Activate Next Windows(ファイル名).Activate ActiveWindow.Close End Sub ----------------------------------------------------------------------- ※1「Sheet1」は、実際のブックAのシートAの名前に変えて下さい。 ※2「B.xlsx」は、実際のブックBの名前に変えて下さい。 ※3 ブックAのシートAのA列に抜けがあっても問題ないようにしています。 ※4 ブックAのシートAのA列に有って、実際にシートが無いものはエラーを出さず飛ばします。 ※5 実際の処理は「MsgBox ("処理してください")」と入れ替えてください。
>この部分をマウスで選択した図形全てに…という形にしたいのです。 ふつうは、#1さんの方法で十分だと思うのですが、全体ということになれば、こんな風に変えます。（#1さんのコードをお借りします） Sub Sample2() Dim shps As DrawingObjects Set shps = Selection　'別に置き換える必要はないけれど、インテリセンスのため。 With shps.ShapeRange　' 　 .IncrementTop -10 End With End Sub
No.1 の訂正です。 少し誤解を与えてしまったようです。以下に直してみて下さい。 ---------------------------------------------------------------------------- 「With ActiveSheet」のすぐ後の行に「.Unprotect Password:="PW"」 「End With」のすぐ前の行に「.Protect Password:="PW"」 それぞれを挿入してください。 なお「PW」は実際のパスワードに変更してください。 ---------------------------------------------------------------------------- Private Sub Workbook_BeforePrint(Cancel As Boolean) Dim MyLocal() As Variant, i As Long, MyCount As Long With ActiveSheet .Unprotect Password:="PW" MyCount = .Range("D3:D4").Cells.Count ReDim MyLocal(MyCount - 1) For i = 1 To MyCount MyLocal(i - 1) = .Range("D3:D4").Cells(i).NumberFormatLocal Next i .Range("D3:D4").NumberFormatLocal = ";;;" Application.EnableEvents = False .PrintOut Application.EnableEvents = True Cancel = True For i = 1 To MyCount .Range("D3:D4").Cells(i).NumberFormatLocal = MyLocal(i - 1) Next i . Protect Password:="PW" End With End Sub
私のところでもエラーが出ます。理由はよくわかりませんが、セキュリティ関連のようです。このようにすれば、問題はないはずですが。 '----------------- Dim mPath FolderName ="\結果" Set objFS = CreateObject("Scripting.FileSystemObject") mPath =objfs.GetFolder(".") & FolderName If objFS.FolderExists(mPath)= False Then objFS.CreateFolder(mPath) End If '------------ --
ANo2です。 失礼しました。VBAの質問だったようで。 すでに回答があるようですが、FOR　～　NEXTなどのループを利用することで比較的簡単にできると思います。
No.5です。 前回のコードは消去して↓のコードに変更してください。 1セル内に該当文字列が複数ある場合に対処できていませんでした。 Sub Sample3() Dim i As Long, k As Long, myStr As String Dim myFound As Range, myFirst As Range For i = 1 To Cells(Rows.Count, "B").End(xlUp).Row myStr = Cells(i, "B") Set myFound = Range("A:A").Find(What:=myStr, LookIn:=xlValues, LookAt:=xlPart) If Not myFound Is Nothing Then Set myFirst = myFound GoTo 処理 Do Set myFound = Range("A:A").FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do GoTo 処理 処理: For k = 1 To Len(myFound) If Mid(myFound, k, Len(myStr)) = myStr Then myFound.Characters(Start:=k, Length:=Len(myStr)).Font.ColorIndex = 3 End If Next k Loop End If Next i End Sub どうも失礼しました。m(_ _)m
>エクセルで作ったデータ(数値でけでなく、文書も含みます)を秀丸エディタにコピーして、保存する事はできますか？ それは特別な事情があるか、VBAを知らない人がすることです。そういう私は、秀丸ではありませんが、そんなことをしていますが、他人には、公開する気がありません。 きちんとした理由がなければ、エディタにデータを送るのはやめたほうがよいです。非常にレアケースだということです。データの保存が目的なら、そのような必要性はありません。エディタに貼り付けるというのは、超がつくほど面倒な手続きが必要です。一般的なマクロが1から2ぐらいの難易度ですが、後者は6ぐらいの難易度です。むろん、秀丸を動かそうと思えば、VBAでも可能ですが、それをするぐらいなら、うみうみさんのUWSC (Windowsマクロ）を利用すればよいことです。 >今は手作業でシートごとにコピーして、タブを消して、その後一つづつ保存しついるのですが、その作業が毎日50シートごとにあり、なんとかならないかと思っていますが、VBAでは秀丸のタブを消していくのは難しいですか？ テキストファイルから、タブを消すためなら、正規表現でも、Replace関数でもTab を、抜くか、置換するかのどちらかです。しかし、シートからなら、一般的には、テキスト出力がありますから、それを利用すると良いです。 'これにはTab など入りません。ファイル名の工夫が必要です。 Sub Test1() Dim fn As String 　fn = Format$(Now, "mmddhh") 　ActiveSheet.Copy　'新しいブックに移して処理する With ActiveWorkbook 　 .SaveAs fn & ".txt", xlUnicodeText　'試しにUnicodeにした、 　 .Close False End With Shell "notepad.exe " & fn End Sub --------------- >VBAでのIE自動制御をしていこうと思っていたので、なんとかVBAで完結しないかなと思っていました。 意味がわからないですね。テキストファイルと、IEの制御とのどんな関係があるのでしょうか。別な意味では、ご自身がマクロをどこまで達成されているか、ということなんでしょうね。質問内容自体は、#1さんは、決して無理だなんていう話をしているわけではないし、私から言わせれば、VBAを扱う人間が、テキストのタブ抜きにエディタをVBAで利用するなど、常識的にはありえません。 >秀丸のマクロではIE自動制御 私は、秀丸のマクロは知りませんが、確か、Basic ライクとは聞いています。InternetExplorer のオートメーション・オブジェクトを取得できるものなら何でもよいと思います。だいたい、秀丸からなら、VBScript やBatch を呼び出して使うことになるだろうと思います。 今、もう少し具体的な話をしていただかないと、可能なものもダメだということになりかねません。つまり、基本的なところの情報は公開してもらわないと、話は進まない、ということです。いつもの掲示板では同じようなパターンになって、話がうやむやの中で、時間が過ぎてしまいます。
こんにちは。 確かに、テキストファイルをバイナリで扱うことはありますね。どうも何のためにしているか分からないので思ったように、回答が付けられません。あくまでも、一般的な使い方を示します。 私も、テキストファイルでバイナリにすることは良くありますが、それを保存というのはまた別問題です。 例えば、Unicode(UTF-16) BOM の場合に、バイナリで扱います。 Sub BinaryInput() 　　Dim Fno As Integer 　　Dim Fname As String 　　Dim bufbyt() As Byte 　　Dim i As Long 　　Fname = "UTF16LE.txt"　　　　'ファイル名" 　　Fno = FreeFile() 　　If FileLen(Fname) = 0 Then Exit Sub 　　Open Fname For Binary Access Read As #Fno 　　bufbyt = InputB(LOF(Fno), #Fno) 　　 　　For i = 0 To 3 　　 buf = buf & Hex(bufbyt(i)) 　　Next i 　　If buf Like "FFFE*" Then 　　　　MsgBox "Unicode BOM付き", vbInformation 　　End If End Sub 以下は、ZIP圧縮の場合 Sub TestZip() 　　Dim Fname As String 　　Dim Fno As Integer 　　Dim buf As String 　　Dim bufbyt() As Byte 　　Dim i As Long 　　Fname = "EDE1D300"　'←Excelの残骸ファイル 　　Fno = FreeFile() 　　Open Fname For Binary Access Read As #Fno 　　bufbyt = InputB(LOF(Fno), #Fno) 　　Close #Fno 　　For i = 0 To 10 Step 1 　　　　buf = buf & Chr(Val(bufbyt(i))) 　　　　If buf = "PK" Then MsgBox "圧縮ファイルです。", vbInfomation: Exit For 　　Next End Sub 逆に Open Fname For Binary Access Write As #FNo というものもありますが、セットで使ったことはありません。
よく見てませんが 「MsgBox "『顧客管理』シートを" & vbCrLf & "削除してから保存して下さい", 48」と「Exit Sub」の間に「Cancel = True」が必要だと思います。
こんばんは。 まず、失礼ですが、用語で、「統合(Consolidate)」というのは、Excelのメソッドのひとつですから、今回は、単に、データが合わさっただけのようですね。 それと、Null というのは、VBAでは、Null値といって、Variant型に入れる特別な値のことで、ワークシートで、Nullという言葉は使われているようですが、VBA側からは、単にEmptyのことを言うようです。(いわゆる完全な空の状態) >空白セルの一部が長さ0の文字列のまま残ってしまうため、一気にNullに変換したいと思っています。 長さ0の文字列を取るための方法は、範囲をClearContents で行うか、 細かい選別をする場合は、 範囲.SpecailCells(xlCellTypeConstants,xlTextValues)　を使い、その個々のセルの内容をループして、Len 等で調べてClearContents を使うか、 With 範囲 　.Value = .Value End With とすれば、長さ0の文字列は消えます。 試してみてください。ダメだったら、もう少し詳しい情報が必要になるかもしれません。
こんにちは 利用なさる環境がよくわかってませんが、アイデアとして。 「表示されたらマクロを実行」とは少し異なりますが・・・ Worksheet_CalculateやWorksheet_Changeなどでシートを監視しておいて、 　If Range("A1").Value = CVErr(xlErrNum) Then などで分岐処理してあげればよろしいのでは？
このサイトは先行するブランクは詰められてしまう為、_を使います。 ＿の部分は半角スペースに置き換えてください。 Sub WK() Dim Cnt1 As Long Dim Cnt2 As Long Dim PNT As Long Dim END1 As Long Dim Sh1 As Worksheet Dim Sh2 As Worksheet Set Sh2 = Worksheets("sheet4") PNT=0 For Cnt2 = 1 To 3 _If Cnt2=1 Then __Set Sh1 = Worksheets("sheet1") _ElseIf Cnt2 = 2 Then __Set Sh1 = Worksheets("sheet2") _Else __Set Sh1 = Worksheets("sheet3") _EndIf _END1 = Sh1.Range("D65536").End(xlUp).Row'全体行数取得 __For Cnt1=3 To END1 ___If Sh1.Range("A"&Cnt1).Value= "○" Then ____PNT=PNT+1 ____Sh2.Range("A"&PNT).Value = Sh1.Range("A"&Cnt1).Value ____Sh2.Range("B"&PNT).Value = Sh1.Range("B"&Cnt1).Value ____Sh2.Range("C"&PNT).Value = Sh1.Range("C"&Cnt1).Value ____Sh2.Range("D"&PNT).Value = Sh1.Range("D"&Cnt1).Value ____Sh2.Range("E"&PNT).Value = Sh1.Range("E"&Cnt1).Value ____Sh2.Range("F"&PNT).Value = Sh1.Range("F"&Cnt1).Value ___EndIf __Next Cnt1 Next Cnt2 Application.StatusBar = False End Sub
＃５です せっかくなので、 > SpecialCells を如何しても使いたいのであれば、 > 作業列で消したい行は空白、残したいものは行番号 > これでソートして････ > 空白は後ろ１か所にまとまるので　SpecialCells　での領域数は１つ･･･ ★ 部分が Samp1 からの変更点です 作業列内、消す行を空白にして、１行目は消しちゃいけないので 1 を設定 その後、全体を対象に作業列で昇順ソートして、 １個の領域になった空白部分を SpecialCells にて･･･ 念のため、空白がない時用に On Error Resume Next ※ SpecialCells も対象が連続しているので速い･･･ Samp1 とあまり変わらない処理時間かと･･･ 今回の様に、対象が飛びとびの状態で SpecialCells します？ 実際に体感してみてください･･･ Public Sub Samp2() 　　Dim i As Long, j As Long 　　Const CF As String = "=IF(MOD(ROW(),2)=0,ROW(),"""")" 　　Application.ScreenUpdating = False 　　With ActiveSheet.UsedRange 　　　　Debug.Print .Cells.Address 　　　　i = 1 - .Cells(1).Row 　　　　j = .Columns.Count + 1 　　　　With .Offset(i).Resize(.Rows.Count - i, j) 　　　　　　With .Columns(j) 　　　　　　　　.Formula = CF 　　　　　　　　.Value = .Value 　　　　　　　　.Cells(1) = 1 ' ★ 　　　　　　End With 　　　　　　.Sort .Cells(j), xlAscending, Header:=xlNo ' ★ 　　　　　　With .Columns(j) ' ★ 　　　　　　　　On Error Resume Next ' ★ 　　　　　　　　.SpecialCells(xlCellTypeBlanks).EntireRow.Delete ' ★ 　　　　　　　　On Error GoTo 0 ' ★ 　　　　　　　　.ClearContents 　　　　　　End With 　　　　End With 　　End With 　　Application.ScreenUpdating = True End Sub
＞パワーシェルにファイルをドラグ・ドロップするのも早いですね・・・ 同様のフリーソフトで「フルパス取得くん」がありますね。 http://news.mynavi.jp/c_cobs/news/okguide/2012/0 … 「フルパス取得くん」 http://www.vector.co.jp/soft/win95/util/se291592 … 「FileNameCopy」と同様な「Path Copy Copy」等もあります。 http://www.gigafree.net/system/context/pathcopyc … 参考まで。
ツッコミどころがいろいろありますが… >DataGridView2.Rows(0).Cells(1) = txt1 >DataGridView2.Rows(0).Cells(2) = txt2 右辺と左辺が間違っていませんかね？ まぁそれでも型が違うのでこのままではエラーなんですが。 >DataGridView2.Rows(0).Cells(3) = value こっちも恐らく型が…。
Dim Number As Single ではなく Dim Number As Double にすればどうでしょう。
ここで答えを言うのは簡単ですが、あなたの会社はそれを望んでいるのかな？ とりあえず、今の設定ではどうやっても顧客名や商品名で登録は出来ません。 マスタを直接触る必要があります。
以下のようにしてください。 マクロ名をMacro1としています。 ----------------------------------- Sub Macro1() Dim i As Long Dim j As Long Dim rowmax As Long For i = 6 To Worksheets.Count rowmax = Worksheets(i).Cells(Worksheets(i).Rows.Count, 2).End(xlUp).Row For j = 17 To rowmax If Worksheets(i).Cells(17, 2).Value = "" Then Exit For End If Worksheets(i).Cells(j, 2).WrapText = True Next Next End Sub -----------------------------------
3次元になると上下が相当大きくなります。 そこで、ｘの範囲を-ｘ1~ｘ2までとしたら 0.1刻みとか大きい値で入力していって最大値と最小値を求め それによって　Y軸方向の縮尺を決めます。
[ア]くらいはわかりませんか? TextBoxの内容を知るためには、[カ]プロパティを使います。 [カ]プロパティの型はStringなので、[エ]型に変換するために[オ]を使います。 Graophicクラスの線を描くメソッドは、 https://msdn.microsoft.com/ja-jp/library/system. … で調べられます。 引数違いで複数ありますが、いずれも、最初の引数はPenです。 よって、 [ク].[ケ] はPenの指定です。 [コ]〜[ソ]は座標です。 この部分からわかるのは以上です。 以下の点が不明なため「正解」はわかりません。 ・Graphicの元になる画像等が何かがわからないので、 [イ].[ウ] に何をすればいいか不明 ・座標に整数(Int32)を使いたいのか、小数(Single)を使いたいのかが不明なため、[エ]に何を使っていいかが不明 　[エ]型に変換するために[オ]を使うので、[エ]が不明なら、[オ]も決められない ・どんな色で線を書くかの指定が無いので、 [ク].[ケ] のPenを指定することができない ・どのテキストボックスがどこの点の座標を意味しているかが不明なので、[コ]〜[ソ]に何を指定していいかが不明
昨日からずっと引っかかっていたのですが、 この私には、とても、他人の書いたものを修正するほどの気持ちのゆとりがありません。 >修正箇所をお教え頂けませんでしょうか？ となっていますが、 新たに作り直す方が楽なのです。 今、CSVの見本と、元のフォーマットファイルがあれば、すぐにでもコードを書けますが、お書きになっているVBAコードは、少なくとも私の書くスタイルにはマッチしておりません。 要するに ■元となるエクセルの列 A：項 B:状況 C:雇用形態 D:勤務地 E:応募媒体 F:応募詳細 G:氏名 H:かな I:年齢 J:電話番号　K:Mail L:入力日 この中の、(E:応募媒体), G:姓+名,I:年齢, J:携帯, K:メール, (L:入力日) これを、CSV から抜き出してやれば良い話ではないでしょうか。 配列で、抜き出して、配列で配分するという方法です。 G:姓+名　→「かな」を導くというのは、H列にPhonetic 関数を置けば良いものの、読みそのものを、GetPhoneticで、呼び出してあげなくてはなりません。これは、省略します。 この内容がさっぱり分からないようでしたら、誰か、他に書いてくれる人を待ってください。私は、あまりスタイルを変えて書く気がありませんから。 '// Sub TestImportCSV() 　Dim Fname As String 　Dim FNo As Integer 　Dim TextLine As String 　Dim i As Long, j As Long, k As Long, t As Long 　Dim Ar() 　Dim Arbuf 　Dim iOrder As Variant 　iOrder = Array(7, 7, 9, 10, 11)　'入力順序 　' O:氏名○ P:氏名○ Q: R:年齢 Y:携帯電話番号○ Z:Mail○ 　 　Const APLY As String = "06.エン転職" 　Dim MyDate As String: MyDate = Format$(Date, "mm/dd") 　 　Fname = "C:\Temp\TEST160722.csv" ' "★ファイル名" 　 　FNo = FreeFile() 　Open Fname For Input As #FNo 　Do While Not EOF(FNo) 　　Line Input #FNo, TextLine 　　Arbuf = Split(TextLine, ",") 　　If IsArray(Arbuf) Then 　　　'If k > 0 Then 'タイトル行がある場合 　　　　ReDim Preserve Ar(4, i) 　　　　Ar(0, i) = Arbuf(14) '姓 O ->7 　　　　Ar(1, i) = Arbuf(15) '名 P ->7 　　　　Ar(2, i) = Arbuf(17) '年齢 R ->9 　　　　Ar(3, i) = Arbuf(24) '携帯 Y ->10 　　　　Ar(4, i) = Arbuf(25) 'Mail Z ->11 　　　　i = i + 1 　　　　Erase Arbuf 　　　'End If: k = k + 1 　　End If 　Loop 　Close #FNo 　k = Cells(Rows.Count, 1).End(xlUp).Row + 1 　For j = LBound(Ar, 2) To UBound(Ar, 2) 　　Cells(k + j, 5).Value = APLY　'媒体 　　Cells(k + j, 12).Value = MyDate　'入力美 　　For i = 0 To 4 　　　If i = 1 Then 　　　　'姓＋名 　　　　Cells(k + j, iOrder(i)).Value = Cells(k + j, iOrder(i)).Value & " " & Ar(i, j) 　　　ElseIf i = 3 Then 　　　　Cells(k + j, iOrder(i)).Value = "'" & Ar(i, j)　'電話番号 　　　Else 　　　　Cells(k + j, iOrder(i)).Value = Ar(i, j) 　　　End If 　　Next i 　Next j End Sub
原因を説明するよりも、どれか1つのプロパティのデフォルトをTrue にして置かなければ、マクロを実行しただけでは、そのオプションボタンは、デフォルト状態で立ち上がるので、他と関連性を持たないで休眠状態ままですから、両方OFFになりますね。 どれかひとつを、予めTrue にしておくか、マクロの起動の際に、その1つを、Trueにします。
ANo1です。 まったくトンチンカンな回答をしてしまいました。 申し訳ありませんが、ANo1は無視してください。 お騒がせしてすみません。m(__)m
以下のようにしてください。 Sheet6のF1のセルへチェック数を設定する場合です。（シート名、セル位置は適宜変更してください） ----------------------------------------- Private Sub count_CheckBox() Dim i As Long Dim count As Long '・・・この行を追加 count = 0 '・・・この行を追加 For i = 1 To 20 If Me.Controls("CheckBox" & i).Value = True Then count = count + 1 End If Next i If count > 0 Then MsgBox count End If Worksheets("Sheet6").Select '・・・この行を追加 Range("F1").Value = count '・・・この行を追加 End Sub
＞Workbooks(Excel_name).Worksheets("Sheet1").Range("B1:C10").Copy Destination:=Worksheets("Sheet1").Range("B1:C10") ＞この行で実行時エラーとなり、「インデックスが有効範囲にありません。」となります。 こちらでは、正常に動作しています。 恐らく、こちらで提示したソースを転記したときか、ソースにあなた独自の処理を埋め込んだ箇所が原因と思われます。 １．まず、こちらで提示したソースをそのままコピー＆ペーストして、実行して頂けませんでしょうか。 （絶対に手書きで転記はしないで下さい。コピー＆ペーストによりインデントが乱れますが、気にする必要はありません） ２．もし、上記１で、同様に同じエラーが発生する場合は、あなたと私の環境に違いが原因と思われますので原因の特定が難しくなります。 （ちなみに、こちらはWindows7 excel2007で確認しました） もし、上記１でエラーが発生しない場合は、あなたの転記ミスなどが原因と考えられます。 差し支えなければ（機密保護の観点からも含めて問題なければ）、あなたのソースをここに、コピー＆ペーストしていただけませんでしょうか。 それが出来れば、こちらで、動作確認が可能ですので、原因が特定しやすくなります。
処理速度を最優先にして、コードを書いてみました。 思ってもみなかったExcelの制限に阻まれて、きれいなコードにならなかったのですが、せっかくできたのでアップしておきます。処理速度的には及第点と思っています。 本当は、Range("2:2､……､5000:5000"）のように、すべてを一括選択してコピーしたかったのですが、一度に指定できる行数に上限があるようです。･･･残念！！！ ちなみに、下記コードの変数cに設定できる上限は２５行程度のようです。とりあえず今回は１０行分に抑えているので（コードの見栄え的に）、やろうと思えば、あと2.5倍程度のスピードアップは可能かもしれません。 Sub Sample() Dim c As Range Dim r As Range Dim i As Long With Sheets("Sheet1") Set c = .Range("2:2,4:4,6:6,8:8,10:10,12:12,14:14,16:16,18:18,20:20") Set r = c For i = 20 To .Cells.SpecialCells(xlCellTypeLastCell).Row Step 20 Set r = Union(r, c.Offset(i, 0)) Next i r.Copy Destination:=Sheets("Sheet2").Range("A1") End With End Sub
ワークシートのセルには入力規則が設定できますが、残念ながらテキストボックスに同様の機能はありません。よって、自力でチェックコードを書くことになります。 すでに、ニューメリックチェックは掛けているようなので、同じように、オプションボタンの状態を判断しながら、ゼロ未満、またはゼロ以上のチェックを追加することになります。 オプションボタンの判定の仕方も分かっているようなので、他に何をアドバイスすれば良いのやら…。
私はいろんなフォームを知っているせいか、フォームというと、フォームコントロールのフォームのフォームはUserFormとよく似ています。 ただ、ご質問レベルでは、フォーム側のものは、ほとんどてできません。フォームとは、UserForm のことを指しているのでしょうか？他にもあるからです。 でも、別のシートを使ってとか、難しいことをしますね。 UserForm の中だけでするなら、このようにします。他にもやり方はあっても、原理は、これと同じことです。 '//UserForm上にひとつのボタンを設けたとしたら、 Private Sub CommandButton1_Click() Dim i As Long Dim t As Long For i = 1 To 10 'チェックボックスが10個あるとすれば。 If Me.Controls("CheckBox" & i).Value = True Then 　t = t + 1 End If Next i If t > 0 Then 　 MsgBox t End If End Sub
#1さんのご質問に、質問者さんは解決したようですから、触れていないようですが、部分置換ですから、日本の地名などにもいろいろありますから、偶然の一致というのは、少ないかとは思いますが、それでも、間違いの入力を含めると、変な所でヒットしてしまう可能性があります。 >表からInputboxにて特定の文字を複数検出し，削除した後に，背景の塗りつぶし設定を”なし”の状態にしたく VBAの、既定にはない関数に、ワークシートのMatch関数がありますが、配列の中で、1つをヒットさせるものです。総当りでは、あまり効率がよくありません。VBAでは、外部オブジェクトの正規表現しか存在しませんが、それを持ち出すのも野暮だと思いました。 以下のVBAマクロは、かなり特殊な部類で本来は、Findメソッドが一般的だと思います。私の書くマクロは、時代が違うせいか、参考にする人は少ないのですが、一応、私も読んだという足跡ぐらいはつけて置きます。 空白のSpace(1) をTextMode で置換すると、半角になります。 '// Sub Deleta_Selected() 　　Dim rng As Range 　　Dim c As Range, i As Variant 　　Dim ar As Variant 　　Dim buf As Variant 　　On Error Resume Next 　　Set rng = ActiveSheet.UsedRange.SpecialCells(xlCellTypeConstants, xlTextValues) 　　If rng Is Nothing Then　　'ここは本来、UsedRange に、範囲を定めます。 　　　　 MsgBox "該当するデータが見当たりません。", vbExclamation 　　　　 Exit Sub 　　End If 　　On Error GoTo 0 　　buf = Application.InputBox("削除する文字列を入れてください。区切りはスペースです", Type:=2) 　　If VarType(buf) = vbBoolean Then Exit Sub 　　buf = Replace(Trim(buf), Space(1), Space(1), , , vbTextCompare) 　　Do 　　　　buf = Replace(buf, Space(2), Space(1), , , vbBinaryCompare) 　　Loop Until InStr(1, buf, Space(2), vbBinaryCompare) = 0 　　ar = Split(buf, Space(1)) 　　For Each c In rng.Cells 　　　　i = Application.Match(c.Value, ar, False) '<-VBAには同様の関数がない/Filter関数は違う 　　　　If IsNumeric(i) Then 　　　　　　c.ClearContents 　　　　　　c.Interior.ColorIndex = xlColorIndexNone 　　　　End If 　　　　DoEvents 　　Next c End Sub '//
こちらの環境(Excel2016)でマクロで保存しても表示します。 記録されたマクロは下記です。 OpenAfterPublish:= True を Falseにしたら表示しなくなりました。 --------------------- ActiveSheet.ExportAsFixedFormat Type:=xlTypePDF, Filename:= _ "C:\Users\○○\Desktop\test.pdf", Quality:=xlQualityStandard, _ IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:= _ True
>For...Next文をつかってボタン1を、押したら3.2.1.0.と順にカウントダウンするメッセージボックスが表示されるようなプログラムのコードを書きなさい。 VBAの問題としては、Step の使い方を覚えさせるためなのですが、課題の内容が、どこか間違えているようですから、もう一度、読みなおしてください。 #3さんの仰るとおりです。 そういう私は、そういうコードは、Excelでは作ったことがないような気がします。 今回は「メッセージボックス」と、カタカナで書いていますから、そこであえて、「メッセージボックス」を使ってみました。 たぶん、私のは提出できません。学校では教えないからです。 ボタンは、フォームコントロールのボタンを使います。 '// #If VBA7 And Win64 Then '64bit Private Declare PtrSafe Function MessageBoxTimeoutA Lib "user32" (ByVal hWnd As Long, _ 　　 ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long, ByVal _ 　　 wLanguageId As Long, ByVal dlliseconds As Long) As Long #Else Private Declare Function MessageBoxTimeoutA Lib "user32" (ByVal hWnd As Long, _ 　　 ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long, ByVal _ 　　 wLanguageId As Long, ByVal dlliseconds As Long) As Long #End If Sub ボタン1_Click() Dim i As Long For i =3 To 0 Step -1 　 MessageBoxTimeoutA 0&, CStr(i), "msgbox", vbMsgBoxSetForeground, 0, 800 Next i 　 MessageBoxTimeoutA 0&, "Bom!", "msgbox", vbMsgBoxSetForeground, 0, 1000 End Sub
For cnt = 3 To 0 Step -1 　MsgBox "カウントダウン" & cnt Next cnt
実装されていません。
意味が伝わらなかったですかね。 DoCmd.TransferText acImportDelim, "M159定義", "M159", "C:\Users\t.yukie\Desktop\m159.csv", True はC:\Users\t.yukie\Desktop\m159.csvのファイルをM159定義を使ってM159にインポートするということなので あなたがやりたいことは 指定したファイルをM159定義を使ってM159にインポートするなので DoCmd.TransferText acImportDelim, "M159定義", "M159", msg, True になるのでは？ということだったのですが。
すでに「ﾋﾟﾎﾞｯﾄﾃｰﾌﾞﾙ2」が作成されているのであれば、そのSourceDataの範囲を変えるだけで、対応できると思います。 こんな感じです。 Sub Macro3() ActiveSheet.PivotTables("ﾋﾟﾎﾞｯﾄﾃｰﾌﾞﾙ2").ChangePivotCache ActiveWorkbook. _ PivotCaches.Create(SourceType:=xlDatabase, _ SourceData:="Sheet1!B1:R" & Sheets("Sheet1").Cells(Rows.Count, "B").End(xlUp).Row, _ Version:=xlPivotTableVersion14) End Sub 注）ピボットテーブルが表示されているシートがアクティブでないと正しく動きません。アクティブでなくても動くようにしたい場合は、次のように修正して下さい。 ActiveSheet.PivotTables("ﾋﾟﾎﾞｯﾄﾃｰﾌﾞﾙ2")～ 　↓ Sheets("シート名").PivotTables("ﾋﾟﾎﾞｯﾄﾃｰﾌﾞﾙ2")～
＃９です 補足しておきます A1 X C1 D1 A2 X C2 D2 A3 Y C2 D3 A4 Y C1 D4 A1 X C2 D1 と、A1 X が重複して出現した場合、 それまで作ってきた A1 X C1 D1 D4 を、以下▼部分に挿入するようにしておきました A1 X ▼ C2 D1 A1 X A1 X C1 D1 D4 C2 D1 一目でおかしいことがわかると思います 処理している箇所は >　　　　　　If (dic.Exists(vK)) Then >　　　　　　　　sS = dic(vK) & CSEP & sS >　　　　　　End If また A1 X C1 D1 A2 X C1 D2 A3 Y C2 D3 A4 Y C1 D4 この場合 A1 X C1 D1 D4 A2 X C1 D2 D4 となります
どこかに C列 と D列 をセル結合しているところがあるんじゃないでしょうか。
日付は＃で挟みましょう。
以下のようにしてください ---------------------------------------------- Option Explicit Private Sub CheckBox1_Click() Call setCellValue(CheckBox1.Object, 1) End Sub Private Sub CheckBox2_Click() Call setCellValue(CheckBox2.Object, 2) End Sub '途中、省略 CheckBox3～CheckBox19も同様につくる Private Sub CheckBox20_Click() Call setCellValue(CheckBox20.Object, 20) End Sub 'チェックボックスに対応するセルの設定 Private Sub setCellValue(ByRef cBox As Object, ByVal colBias As Long) Dim row As Long Dim sheetName As String sheetName = GetSheetName MsgBox ("sheetname=" & sheetName) Worksheets(sheetName).Select row = getRow() If row = 0 Then Exit Sub End If Cells(row, colBias + 8).Select If cBox.Value = True Then Cells(row, colBias + 8).Value = 1 Else Cells(row, colBias + 8).Value = "" End If End Sub 'チェックボックスが設定すべき行を取得する関数 Private Function getRow() Dim i As Long Dim colmax As Long Dim rowmax As Long '最後の行、列を取得 ActiveCell.SpecialCells(xlLastCell).Select colmax = ActiveCell.Column rowmax = ActiveCell.row 'A列に値が設定されている最大の行数を取得する For i = 1 To rowmax If Cells(i, 1).Value = "" Then getRow = i - 1 Exit Function End If Next '最後までA列に値があれば最後の行とする getRow = rowmax End Function '条件に従いシート名を決定する Private Function GetSheetName() Dim jyoken As Long jyoken = 3 Select Case jyoken Case 1 GetSheetName = "sheet1" Case 2 GetSheetName = "sheet2" Case 3 GetSheetName = "sheet3" Case 4 GetSheetName = "sheet4" Case 5 GetSheetName = "sheet5" Case 6 GetSheetName = "sheet6" End Select End Function ---------------------------------------------- GetSheetNameで処理対象となるシート名を決定しています。 ここは、あなたの条件を記述してください。 GetSheetNameでどのような場合でもsheet1～sheet6の何れかを返すようにしてください。 シート名が返されたとき、そのシートに対して処理します。 実際に返す名前は、sheet1でなくてもかまいません。（aaaのシートが存在すればaaaなどでもOKです。） MsgBox ("sheetname=" & sheetName)でシート名を表示しています。不要であればコメントアウトしてください。
>いくつかのセルに色が付いていますが、その後データが追加されます。 この条件とは、例えば、上方　例えば、A3 で色がついていない場合に、下記で色がついていたとしても、色はつきません。あくまでも、下方に対して、その条件が働きます。 ある程度の修正は可能ですが、これは、Dictionary オブジェクトを使わない条件として作ったものです。 '// Sub FindFormatCell() 　Dim c As Range 　Dim rng As Range 　Dim ur As Range 　Dim ar() 　Dim ar2() 　Dim src 　Dim i As Long, x As Long, y As Long 　Dim FirstAddress As String　　 　Application.FindFormat.Clear 　'基点になる色のついたセルを右辺に指定してください。 　'下行でも、一度、このセルを使います。 　Application.FindFormat.Interior.Color = Range("A2").Interior.Color 　Set rng = Range("A1").CurrentRegion 　 　With rng 　Set c = .Find(What:="?*", SearchFormat:=True) 　If c Is Nothing Then 　　　　Exit Sub 　Else 　　　FirstAddress = c.Address 　　　Do 　　　　　If ur Is Nothing Then 　　　　　　　Set ur = c 　　　　　Else 　　　　　　　Set ur = Union(ur, c) 　　　　　　　ReDim Preserve ar(x) 　　　　　　　ar(x) = c.Value 　　　　　　　 x = x + 1 　　　　　src = Filter(ar, c.Value) 　　　　　If UBound(src) = 0 Then 　　　　　　　ReDim Preserve ar2(1, y) 　　　　　　　ar2(0, y) = src(0) 　　　　　　　ar2(1, y) = c.Address(0, 0) 　　　　　　　y = y + 1 　　　　　End If 　　　　　End If 　　　　　DoEvents 　　　　　Set c = .Find(What:="?*", After:=c, SearchFormat:=True) 　　　　　If c.Address = FirstAddress Then Exit Do 　　　Loop Until c Is Nothing 　End If 　End With 　If Not (ur Is Nothing) Then 　FirstAddress = "" 　For i = 0 To UBound(ar2, 2) 　　With rng 　　Set c = .Find(What:=ar2(0, i), After:=Range(ar2(1, i)), LookIn:=xlValues, _ 　　　　LookAt:=xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext) 　　 If Not c Is Nothing Then 　　　FirstAddress = c.Address 　　　　　Do 　　　　　Set c = .FindNext(c) 　　　　　If c.Interior.ColorIndex = xlColorIndexNone Then 　　　　　　　 c.Interior.Color = Range("A2").Interior.Color 　　　　　End If 　　　　　If c.Address = FirstAddress Then Exit Do 　　　Loop Until c Is Nothing 　　 End If 　　End With 　　Next 　　End If End Sub
ミス有り(最終列の上下逆部分）。訂正版は以下 Dim 列カウント As Long Dim 行カウント As Long Dim END1 As Long Dim 最終行 As Long Dim 最終列 As Long Dim 入替END As Long Dim CNT As Long Dim WK As Variant Dim Sh1 As Worksheet Dim Sh2 As Worksheet Set Sh1 = Worksheets("Sheet1") Set Sh2 = Worksheets("Sheet2") END1 = Sh1.Range("A1").End(xlDown).Row '最終行番号取得 'Sheet1 A列をSheet2へ分解セット CNT = 1 For 列カウント = 1 To 250 'MAX250列まで試行 For 行カウント = 1 To 5000 '5000行実行 If Sh1.Cells(CNT, 1) > -1 Then '-1より大を対象 Sh2.Cells(行カウント, 列カウント) = Sh1.Cells(CNT, 1) Else 行カウント = 行カウント - 1 End If CNT = CNT + 1 If CNT > END1 Then GoTo NEXT1 End If Next 行カウント Next 列カウント NEXT1: ' 偶数列は上下を入れ替える 最終列 = 列カウント 最終行 = 行カウント 最終行W = 行カウント For 列カウント = 2 To 最終列 Step 2 If 列カウント = 最終列 Then 入替END = 最終行W / 2 最終行=最終行W Else 入替END = 2500 最終行 = 5000 End If '入れ替え実行 For 行カウント = 1 To 入替END WK = Sh2.Cells(行カウント, 列カウント) Sh2.Cells(行カウント, 列カウント) = Sh2.Cells(最終行 - 行カウント + 1, 列カウント) Sh2.Cells(最終行 - 行カウント + 1, 列カウント) = WK Next 行カウント Next 列カウント Application.StatusBar = False End Sub
開始行の修正 ＞Range("A1").Select ここでA1を選択してます。つまりactiveCellはA1です。 ＞tanka = ActiveCell.Offset(0, 1).Value A1の1列右はB1ですが、B1を見ると「単価」という文字列であって、数字ではありません。つまり開始行を2行目にする必要があります。 繰り返し処理 Do loopの1回目が終わり2回目に移っても、計算する場所は相変わらず1行目のままで、次の行に進みません。どうするかというと、 i=1 Do tanka = ActiveCell.Offset( i, 1).Value ～ ～ i=i+1 Loop とすると、loop終了時にiの値が1ずつ増えるので、行番号設定つまりoffset設定に使えます。
理解出来ない説明内容です。 >>0.09 ←こんな数値の羅列が100万くらい どういう風な並び？A1～A1048576の範囲内？B列以降には無い？ >>(列×行）5000×100に数値が埋め込まれるはず ・行×列では無いのですか？ ・数値の羅列が100万くらい、と言ってるのに何故50万？ >>0.117 0.117 0.117 0.117 ←このように偶数行のみ上下逆にしたい どこがどう上下逆？？
#3の回答者です。 この話を書くために、いくつか話を読んでみました。 「プログラミング教育の現場から 」 http://vbae.odyssey-com.co.jp/solution/interview … 大岩元教授(慶応大学）という人もいるけれども、こういう人たちでは推進できないかもしれません。 どこかの掲示板で、盛んに、プログラミングの早期教育をと言っている人がいましたが、どんなものでしょうね。好きな人は、何歳からでも始められると思います。世の中には、語学を含めて天才的にできる人がいます。 私は、プログラミングというものは、将棋や碁の世界と同じような気がします。 プロでなくても、仕事でしなくてはならない人もいますが、ただ、楽しみとか娯楽というものもあるはずです。 >見渡すと3分の1がマクロを使います。市民権を得たなと思います。 以前よりもずっとユーザーは増えたようです。社会的な市民権がないと、隠れて使う？ということもありえましたから。しかし、今も昔も私は、ほとんど教える気などはおきません。理由は、人から分からないということと、「なぜ」と言われて教えるのが面倒だからです。 以前、ある中小企業の会社の偉い人はVBAが分からないから、部下に対して、VBA禁止だとかいう話とか、いろんな会社でVBAの拒否反応というものが、聞かれていました。労働生産性の観点からすれば、マクロ禁止というのは命取りのはずなのです。電卓と鉛筆と紙の計算で1日近く掛かるものでも、瞬時に終わってしまいます。 ですが、10年ほど前に、ここの住人でもあった、b****yさんは、Ver.4 マクロ関数などは、危険な存在そのものだから、絶対になくなるし、私が使うのも禁止だと、言われたことが懐かしいです。結局、自分が知らないこと、知ることができないことは、存在そのものを否定したい、という気持ちは、誰しもあることはあります。しかし、目の前に自分の知らないことがあれば、どうしても知りたいと思う気持ちもあります。Ver.4マクロ関数が問題ではなく、未知のことに拒否するということについては、プログラミンを学ぶ者としてなら、脱落者の一人だったかもしれません。 技術を覚えられる時に、それを取り入れることができる間に取り入れないと、絶対に戻らないものなのですね。 まあ、多くはVBA解禁にはなったものの、掲示板は、できる人に無料でマクロを作ってもらう場所だと思っている人がいるようです。自分で覚えようともしないのに、あれこれと注文を付けられると、実際のところ、閉口します。 提示されたものも調べようとはしない受け身では、できるようにはならないと思います。最初は、できる人と初心者の差は圧倒的に差があるものですが、だんだん縮まってしまいます。しかし、そういう差がない所で書いていると、だんだん、こちらがおかしくなっていくような気がします。 学校の問題を、掲示板で聞いていれば世話ないけれども、結局、学校というものは、その過程を重視しないから、プログラム自体を本当に理解することなどはありえないと思うのです。 最近、私は遅ればせながらですが、もう一度、VBAの勉強で取り組んでいるのは、以下のようなものです。 ・Web のデータを取り出す(Crawling) ・Basp21のPerl系　正規表現(もうこれ自体とても古い） ＊Ribbon カスタマイズ ・XML >実践性が感じられない質問 　私の場合は、自分で考えて分からなかったり、間違えたら、解答をみて、自分とどう違っていたか見比べて、次に進みます。途中で考えこんでしまうのが一番いけないと思っています。学校では、解答を生徒から取り上げて教師独占なんかにするから、答えだけを知りたがるのでしょうね。 それと、プロセスを重視しないので、先生でも、おかしなことを言う人が出てきます。 　×VBAは、大文字・小文字の区別がありませんから、入力は、全部小文字でいれてください、正しく入力したら自動的に変わります。(時代は変わりました） 　×組み込み定数は、全部数字でいいです。(わざわざリストを作る人がいます） 　×デフォルト・プロパティはつけなくてもよいです。 　△エラーが出るようなら、On Error Resume Next を入れてください。 　×浮動小数点誤差は、考えなくてもよいです。 　△VBAでExcelの関数を利用しましょう。 (解説が必要なものもあるかもしれませんが、いずれ、説明する時が来るかもしれません。） この先の10年で、どう変わるかでしょうね。VBAがなくなっているかもしれませんし、もしかしたら、私は、もういないかもしれませんが……。
intWindowStyle にお好きなものを https://msdn.microsoft.com/ja-jp/library/cc36442 … "taskmgr.exe", 7 , False かな。
すみません。記述を間違えました。 Sub グラフタイトル連番() Dim cht As ChartObject Dim i As Long 　For Each cht In ActiveSheet.ChartObjects 　　i = i + 1 　　　With ActiveSheet.ChartObjects(i).Chart 　　　　.HasTitle = True 　　　　.ChartTitle.Text = i 　　　End With 　Next cht End Sub
ExcelではなくAccessを使うことを勧めてみる。 その手の処理はAccessが得意とする分野です。 ・・・ 質問の内容はまるで… Wordに罫線で表を作って、表中の数字を横方向に掛け算。その結果を縦方向に足し算して集計する …ようなものですよ。 これってExcelなら簡単にできる処理でしょ？
＞サブフォーム内のデータはクエリから表示をしています。 Forms!![メインフォーム名]![サブフォーム名]![フィールド名] で参照できると思いますが、、、 余計なおせっかいとしては、このエラー処理はまずいね。１回目のSQLが実行できて２回目のSQLでつまずいた場合も同じエラーになってしまう。 あと、、どういう職種なのかわからないけど、人に聞かないで調べる習慣つけたほうが良いよ。
戻り値がある場合には括弧が必要になります。 Rtn = Application.Run(Prc_Name)
VB.NET は殆んど知りませんが oSheet.Cells(3,3).Activate() oExcel.ActiveWindow.FreezePanes = True とかで出来ませんか？ VBA ならこれでいけますが。
質問が断片的なような気がします・・・。 >forms!親!子.from.RecordSource = Sql forms!親!子.FORM.RecordSource = Sql ４行は投稿時のタイプミスだと思います。 とりあえず喫緊のは Me!子.SetFocus Me!子.form.AllowAddition = True '←コンパイルエラー DoCmd.GoToRecord , , acNewRec では？ サブフォームのプロパティなどを対象とする場合には、Formを指定する必要があります。 説明が上手にできないので師匠さんの サブフォームとサブフォームコントロールの違いとは？ http://hatenachips.blog34.fc2.com/blog-entry-347 … でご勘弁を。 >また、親フォームを開き直した時も、サブフォームのデータを保持していたいです。 これは無理？ １・非連結のサブフォームであること、 ２・親フォームを開きなおした時に、子フォームも初期化されること。 開きなおす『前』にどこかのテーブルに情報を保存できれば可能かもしれません。
#2様が、すでに、Dictionary Object を使っていましたので、こちらは、.Net Framework のSortedList を使ってみました。確か、Excel 2003以降から可能だったと思います。 あくまでも勉強のためですが、こちらのメリットは、どんな並びでも、Keyが並べ替えされて出てきます。今後、こういうスタイルもちらほら出てくるようになるでしょう。また、実務上は、objSortedList は、長過ぎますから、DataList でもすると見やすいかと思います。 なお、VBScript なら、厳禁ですが、VBAでは、全角スペースは無視されるようです。 '// Sub IntegratedNumbers() Dim objSortedList As Object 'mscorlib.SortedList Dim t1 As String, t2 As String, a As String, b As String Dim i As Long, j As Long, c As Variant Set objSortedList = CreateObject("System.Collections.SortedList") For Each c In Range("A2", Cells(Rows.Count, 1).End(xlUp)) 　　 t1 = Trim(c.Offset(, 0).Value) 'Item 　　 t2 = Trim(c.Offset(, 1).Value) 'Key 　　If objSortedList.ContainsKey(t2) = False Then 　　　　 objSortedList.Add Trim(t2), t1 　　Else 　　　　b = objSortedList.Item(t2) 　　　　objSortedList.Item(t2) = b & "-" & t1 　　End If Next c j = 2 For i = 0 To objSortedList.Count - 1 　　Cells(j, 4).Value = objSortedList.GetByIndex(i) 　　Cells(j, 5).Value = objSortedList.GetKey(i) 　　j = j + 1 Next i Set objSortedList = Nothing End Sub '//
せっかく#1さんが解説した後で、こちらが訳の分からないようなことを書くのはおこがましいと思われるかもしれませんが、 私は、#IF ダイレクティブをみて、 語学などで使う用語で　メタ言語と呼ばれるものがありますが、それだなと思いました。つまり、メタ言語というのは、言葉を言葉で規定するということです。 この「メタ」という概念をプログラミングに置き換えると、VBAの一般の記述があり、それを「一つ上の段階から定義したり規定させること」ができるものと解釈できます。 あまり良い例が思いつきませんでしたが、 ひとつは、バージョンや32bit, 64bit で切り分けなくてはならない場合と、 もうひとつは、プロジェクト全体として、環境の違いにより、致命的なエラーを回避する必要がある時 だと思います。 ただ、よくよく考えてみると、Option Explicit で変数の宣言を強制するとか、32bit と64bit の違いによるプログラムの違いとかでないと、それほど重要な位置にとなるものは少ないのではないでしょうか。 だから、もし、これを同じVBAのステージで行うなら、例えば、バージョンなら、Val(Application.Version) などで、Version を取るのが普通です。 >これはVBA7という変数がコンパイル時にのみ有効で >実行時には存在しないためだからでしょうか？ と言われれば、否定はしないけれども、VBA7は変数ではありませんね。条件付きコンパイル定数というわけで、予め組み込まれているわけですが、後々、気がついたことですが、VBA7 は、Excel 2010 以降とそれ以外を分けるものになっているわけで、こういう区分けは、あまり意味があるとは思えません。 Option Explicit #If VBA7 Then 　Dim ret As Long　'Office 2010以降はこちらです。 #Else 　Dim ret As Integer　'2007だと、こちらになる #End If Sub Test1() 　MsgBox TypeName(ret) End Sub そのコードをコンパイルで巻き込むとエラーを出すので、回避するためが中心で、それ以上に重宝するとも言えません。 それに、どこまでこの条件付きコンパイル定数が登録されているのかは、分かりません。せいぜい、64bit と32bit を分けるWin32 APIの区分けぐらいだけです。 Excel2003とそれ以降のファイルの違いで、リボン・コントロールイベントとクラスイベントの区分けを#IFダイレクティブで区分けできるとも言えません。せいぜい、コードエラーを出さないだけでしかありませんでした。 例： http://oshiete.goo.ne.jp/qa/9317937.html
達人かどうかは別として、私の昔の古い書き方に似てはいます。 しかし[ツッコミがいがある）書き方かなって思います。（^^; 私が、昔の私にダメ出しするような気がします。 もし、今回のように数値検索では、 　　LookAt:=xlPart, 　 は、うまくないなって思います。 本当は、xlWhole にしておいて、20*, 40* などとした方がよいような気がします。今回はこれは手をつけません。 >Set Set Rng = SelectionをRange("A1,C3")～～～などなど試してみましたが、どうも根本的に違うような。。。 非連続であろうがなかろうが、ヒットしたセルを対象とするのですが、特にセルを1つずつ拾う必要はありません。 Range("A1,C3")　ではなく、Range("A1","C3") か、Range("A1:C3")です。 MatchCase:=True は、何か理由があるのでしょうか。アルファベットの大文字・小文字を区別するものです。 #2さんの「ＶＢＡが異様に長いです。」 Findメソッドってこういうスタイルしかないと思うのです。私の頭では細かく入れることが出来そうにもありませんので、Findメソッドは、最初からテンプレートに入れているのです。 昔は、My と大文字で書いていましたが、今は、myは小文字で書くようになりました。 '// Sub MultiReplacement2() 　　Dim myWords As Variant 　　Dim wd As String, rp As String 　　Dim myRepWords As Variant 　　Dim i As Long 　　Dim blkRng As Range 　　Dim Rng As Range 　　Dim c As Range 　　Dim buf As Variant 　　Dim FirstAddress As String 　　 　　wd = "20,40" 'ここに検索語を入れてください。 　　rp = "good,bad" 'ここに置換語を入れてください。 　　Set Rng = Range("A1:C3") 　　myWords = Split(wd, ",") 　　myRepWords = Split(rp, ",") 　　For i = LBound(myWords) To UBound(myWords) 　　　　buf = InStr(1, rp, myWords(i), vbTextCompare) 　　　　If buf > 0 Then 　　　　　　MsgBox myWords(i) & "は、検索語と置換後に単語が混じっています。", vbExclamation 　　　　Exit Sub 　　　　End If 　　Next i 　　Application.ScreenUpdating = False 　　If UBound(myWords) <> UBound(myRepWords) Then 　　　　MsgBox "検索語と置換後の数が違っています。", vbExclamation 　　　　Exit Sub 　　End If 　　On Error Resume Next 　　Set blkRng = Rng.SpecialCells(xlCellTypeBlanks) 　　On Error GoTo 0 　　If Not blkRng Is Nothing Then 　　　　blkRng.Value = "エラー" 　　End If 　　For i = LBound(myWords) To UBound(myWords) 　　　　With Rng 　　　　　　Set c = .Find( _ 　　　　　　What:=myWords(i), _ 　　　　　　LookIn:=xlValues, _ 　　　　　　LookAt:=xlPart, _ 　　　　　　SearchOrder:=xlByRows, _ 　　　　　　MatchCase:=False, _ 　　　　　　MatchByte:=False) 　　　　　　If Not c Is Nothing Then 　　　　　　　　FirstAddress = c.Address 　　　　　　　　Do 　　　　　　　　　　c = Replace(c.Value, myWords(i), myRepWords(i), , , vbTextCompare) 　　　　　　　　　　Set c = .FindNext(c) 　　　　　　　　　　DoEvents 　　　　　　　　　　If c Is Nothing Then Exit Do 　　　　　　　　　　If c.Address = FirstAddress Then Exit Do 　　　　　　　　Loop 'Until c Is Nothing 　　　　　　End If 　　　　End With 　　　　FirstAddress = "" 　　Next i 　　Application.ScreenUpdating = True End Sub '//
このマクロは、奇をてらった面白いパターンですが、実務面では、ちょっと無理があるかもしれません。 Columns(1).SpecialCells(xlCellTypeConstants)　これを、With ステートメントはふつうはしないのです。 　.Offset(, 2).Formula = xFormula 　 　.Offset(, 2).NumberFormatLocal = "0.00%"　　'←これを加えます。
エキストの切り替えがTextBoxそのものを切り換えるなら https://oshiete.goo.ne.jp/qa/9319916.html でImageを切り換えたのと同じで。 TextBoxは1つでその記述を変えたいなら、Imageの時と同様の条件分岐の先で TextBox1.Text ＝ "○○○○" というように指定すればいいと思います。
Me.SUB_kekka.個社 = kosya_Name などで出来るのは 帳票/単票フォームの場合です。 データシートでは不可なので サブフォームのレコードセットで扱うことにします。 たとえばコマンドボタンに設定するなら Private Sub ぼたん_Click() Dim Rs As dao.Recordset Set Rs = Me!SUB_kekka.Form.Recordset 'サブフォーム上でカレントになっているレコードの変更 Rs.Edit Rs!個社 = kosya_Name Rs!ファイル名 = myFilename Rs!件数 = dataVolume Rs.Update Stop 'サブフォームに新規レコード追加 Rs.AddNew Rs!個社 = kosya_Name Rs!ファイル名 = myFilename Rs!件数 = dataVolume Rs.Update Stop '次のレコードに移動 Rs.MoveNext Stop '頭から数えて３番目に移動 Rs.AbsolutePosition = 3 - 1 Stop '現在位置から２番目に Rs.Move 2 Set Rs = Nothing '後始末 End Sub のようなイメージになります。 kosya_Name等々の処理はこちらでは入れようがないので コピペッタンしただけでは当然エラーになりますから修正が必要です。 所々でStopしていますので、VBE上でF5で順次実行しつつ確認してみてください。
#4の回答者です。 私の回答の要点は、FileFormat と Filename の順序を逆にすることだったのですが、それがダメだったのでしょうか。 私は、同じような条件で、何度やってみても、テキスト出力(Windowsタイプなど）では、FileFormat を後にするとエラーが出たし、過去の記録をみても、逆にしていたからなのです。それで、ご指摘したわけなのです。 >「a」の変数の型は何にすべきでしょうか？ 常識的にString 型と言いたいのですが、実際、ファイル名は、Variant型のほうが圧倒的に多いはずです。変数の型とかの問題ではなくて、ファイル名そのものだと思います。 なお、ファイル名やパス名は、一旦全体を変数に入れてから、出力に与えたり、その前に、Dir関数などでファイル名をチェックするのは、実務上は一般的です。リテラルでは、どうしても不備が出てきます。 http://dobon.net/vb/dotnet/file/invalidpathchars … ここで見てみると、ファイル名正規表現で調べろ、となっているのですが、 "[\\x00-\\x1f<>:\"/\\\\|?*]" + "|^(CON|PRN|AUX|NUL|COM[0-9]|LPT[0-9]|CLOCK\\$)(\\.|$)" + "|[\\. ]$", こちらでは、エスケープシーケンスが紛れ込むことはないはずですが、VBA用にファイル名チェッカーも考えてみました。 '//その一部になりますが、ユーザー定義関数で作ります。(仮） '//ルートからのファイル名の長さもチェックが必要です。(割愛－要再考） 　 BaseFileName =WorksheetFunction.Clean(BaseFileName) 　For Each v In Array(":", "\", "/", "?", "*", "[", "]", "|") 　　　　i = InStr(1, BaseFileName, v, vbBinaryCompare) 　　　　If i > 0 Then Flg = True: Exit For 　Next v ここのスレに出てくる「ファイル名の」エラーですと、ファイル名エラーチェッカーが必要だと思います。ファイル名の精査するプログラムが一つも入っていないと、実務上はエラーが発生することはあります。 セルからなどで、直接渡すとこのようなことがエラーを発生させますので、難しく考えないで、Application.GetSaveAsFilename を通して、ファイル名チェックを行ったりする人も多いようです。 なお、私は、MsgBoxではなく、Degug.Print で、実際どんな文字列が命令に与えられて、エラーが発生しているのか、調べます。理由は、ルートからのファイル名でも、文字長は決められています。あまりフォルダーが深すぎると、エラーが発生することがあるからなのです。入れてはならない文字やら、後で調べてみないと分からないことがあります。
こっちでしょうね。 ■Excel VBAでエクセル(Excel2003)で動画を再生する方法 http://blog.ch3cooh.jp/entry/20080404/1244601027
こんばんは 実際に入力フォームをExcelに貼り付けてみると コントロール1 コントロール2 ・ ・ と表示されますね。 デザインモードにしたあと、ホーム⇒検索と選択⇒オブジェクトの表示と選択　で見てみると、このコントロールの名前は Control 1 Control 2 ・ ・ となっているようです。 ですので、OLEObjectで操作すれば大丈夫なはずです。 Sub コントロールの値取得() i = 1 Dim Obj As OLEObject For Each Obj In ActiveSheet.OLEObjects myTarget = "Control " & i If Left(Obj.Name, Len(myTarget)) = myTarget Then Cells(i, 1) = Obj.Object.Value i = i + 1 End If Next Obj End Sub ※"Control "の部分はControlのあとにスペースが入るので気を付けてください。
比較的簡単に実装できます。 イメージコントロール http://www.petitmonte.com/excel/excel_vba_40.html ラジオボタン http://excelvba.pc-users.net/fol10/10_5.html
どういう方法がよいか、一つの参考にしてみてください。 なるべく、元を活かして作ったつもりです。 「これでよろしいですか？」で一旦対話式にしています。 ここを以下の様な工夫すれば、やり直しという手順も可能になります。 If MsgBox(Add & " の行" & vbCrLf & "これでよろしいですか？", vbOKCancel) = vbCancel Then Range("A1").Select Add ="" Set Rng = Nothing Exit Sub End if '// Private Sub CommandButton1_Click() 　　Dim i As Long 　　Dim Add As String 　　Dim lRw As Long 　　Dim Rng As Range 　　Dim num As Variant 　　Worksheets("Sheet1").Select 　　For i = 1 To 15　　'テキストボックスの数 　　　　num = Val(Me.Controls("TextBox" & i).Text) 　　　　If num > 0 Then 　　　　　　Add = Add & "," & "A" & CStr(num) 　　　　End If 　　Next i 　　If Len(Add) > 2 Then 　　　　Add = Mid(Add, 2) 　　　　Set Rng = Range(Add).EntireRow 　　　　Rng.Select 　　　　If MsgBox(Add & " の行" & vbCrLf & "これでよろしいですか？", vbOKCancel) = vbCancel Then GoTo EndLine 　　End If 　　With Worksheets("Sheet2") 　　　　lRw = .Cells(Rows.Count, 1).End(xlUp).Offset(1).Row 　　　　If lRw = 2 Then lRw = 1 　　End With 　　Rng.Copy Worksheets("Sheet2").Cells(lRw, 1) 　　Rng.Delete Shift:=xlUp EndLine: 　　Range("A1").Select 　　Set Rng = Nothing 　　Unload Me End Sub
前回のご質問の読んでいたけれども、間に合わなかったようです。 前回のご質問で解決をしたのなら良かったけれども、配列での値コピーは、両方のサイズを同じにしないて行けませんし、今回のようなVisible セルだけの値をコピーするのは前回の方法では、逆に複雑になってしまったように思います。 私の記憶では、オートフィルタだけなら、 　SpecialCells(xlCellTypeVisible) は不要だったと思います。しかし、テーブルのフィルタでは利きませんので注意が必要になります。 以下は、貼り付け先とデータ元と間違えると大変なことになりますから、十分に調べてから、本番でお使いになるようにしてください。 '// Sub TestMacro() 　　Dim myRng As Range 　　Dim lastRow As Long, lastCol As Long 　　Dim fn As String 　　Dim fn2 As String 　　Dim ws As Worksheet 　　Dim ws2 As Worksheet 　　 　　fn = "BookA.xlsx" 'データ 　　fn2 = "BookB.xlsm"　'貼り付け先 　　Set ws2 = Workbooks(fn).Worksheets("Sheet1")　　'データ 　　Set ws = Workbooks(fn2).Worksheets("Sheet1") '貼り付け先 　　With ws2 　　　　lastRow = .Cells(Rows.Count, "A").End(xlUp).Row ' 　　　　lastCol = .Cells(1, Columns.Count).End(xlToLeft).Column ' 　　　　Set myRng = .Range(.Cells(2, "A"), .Cells(lastRow, lastCol)).SpecialCells(xlCellTypeVisible) 　　End With 　　If myRng Is Nothing Then Exit Sub　'これはありえないかもしれません　 　　myRng.Copy 　　ws.Cells(Rows.Count, "A").End(xlUp).Offset(1).PasteSpecial (xlPasteValues) 　　Application.CutCopyMode = False End Sub
こんにちは 手操作での「形式を選択して貼り付け」-「値」と同等の処理をなさればよろしいかと。 具体的にはPasteSpecialメソッドを利用することで可能です。 一旦copyしておいて、pasteSpecialとなるので、copyメソッドのように1行ではなく2行の記述になりますが・・・ https://msdn.microsoft.com/ja-jp/library/office/ … あるいは、すでに#1様が回答済ですが、値を代入する記述法に変えることでももちろん可能です。 wS.Cells(Rows.Count, "A").End(xlUp).Offset(1).Value = myRng.Value
> 本来webbrowserはIEの設定を使ってプロキシを使うようなのですが、 ↑これはwebbrowserとIEが違うもののように聞こえますが、IEとは別の、例えば Firefox などのWebブラウザのことを示していますか？ もしそうなら、IE 以外のWebブラウザは IE の設定を使用(参照)してプロキシ経由でインターネットへアクセスする機能もありますが、逆に個別に設定することもできます。 ご使用する、Webブラウザの設定方法を確認してみてください。
こちらが参考になるでしょう。 オプショングループ内に３１ケのトグルボタンを一気に作る方法 http://tsware.jp/tips/tips_436.htm
#If VBA7 Then この　#IF ディレクティブは、Excel 2007 以降ではなく、Excel 2010 からでした。 条件付きコンパイラ定数を探してみましたが、ありませんので、 #VER =12 #IF VER =12 OR VBA7 Then とするくらいしか、今のところ思い浮かびません。
通常、TextBox内でTabを押下した時、次のコントロールへフォーカスが遷移しますが、遷移しない場合もあります。 (次のコントロールとして認識されるものがない場合もあり得る) そのため、Tabの制御をValidatingイベントで実装することは非現実的です。 Tab制御を問題視しているのか、Validatingイベントの制御を問題視しているのかがよくわかりません。 以下のようにした場合、フォーカス遷移が行われる際に必ずキャンセルされます。 それはTabキー押下に限った話ではありません。 private void textBox1_Validating(object sender, CancelEventArgs e) { errorProvider1.SetError(textBox1, "hoge"); e.Cancel = true; } Tabキーの話をしているのならば、PreviewKeyDownイベントで実装し、Tabを入力キーとしてしまって、フォーカス遷移を行わないようにできます。 が、TabがWindowsの仕様と異なることになります。 当たり前ですが、色々制御した結果、ヨシとした場合、それによってフォーカスが遷移するならば、Validatingイベントも走行しますので。 private void textBox1_PreviewKeyDown(object sender, PreviewKeyDownEventArgs e) { if (e.KeyCode == Keys.Tab) { errorProvider1.SetError(textBox1, "hoge"); e.IsInputKey = true; } }
>>B4からデータがありデータがなくなるまで処理を続けてほしい 意味不明です。 カンマ区切りデ－タが１つのセルに入っているという意味ですか？ そういうセルが多くある？ B4からって？　から　の意味が解らない
マクロの記録を使い、 1. タブ区切りファイルを開く 2. 範囲を選択 3. 散布図を作成 の一連の動作を行い、記録された VBA コードを解析する。 コードには余分な指定も書き込まれているので、そいつを見つけてそぎ落としていく。 次に、記録されたコードの中で固定値になってしまっている個所 (ファイル名、セル番地など) を変数で指定するために、変数に値を入れておくための方法を考える。 テキストファイルのファイル名を指定する箇所は GetOpenFileName とか。 セルの最終行列（セル範囲の右下の番地）をどうやって指定するか。 など。
これが参考になるかな https://oshiete.goo.ne.jp/qa/2245476.html
そのオブジェクトヘの参照が全てなくなってから、その後の いつかです。 >x = Nothing とする場合でも、直ぐには回収されません。 GCがそれをいつ発見するかはとても複雑な話なので いつになるか判らないという仮定でプログラムを組む 必要が有ります。
チャートオブジェクトにデータを与えていないからです（記録したマクロをご確認下さい） for～nextの間を以下にしてください。（Ragge型変数targetを追加しましたので宣言も追加ください） ----- Set target = sPoint.Resize(720, 10) '図にしたい範囲を選択 ActiveSheet.Shapes.AddChart2(240, xlXYScatter).Select ActiveChart.SetSourceData Source:=target ' これが無いです。 Set sPoint = sPoint.Offset(720, 0) '対象を720行下へ移動 ※710だったのを修正しました -----
枠線だけなら境界線スタイルを透明にすれば？
エクスポートするときに設定できます。 バージョンによって操作方法が違いますので 「access　エクスポート　ダブルコーテーション」などの検索ワードでお調べください。
こんにちは 雰囲気はわかりますが、No1様のおっしゃるようにいろいろなケースが考えられるので、その時の処理をどのようにするのかが不明です。 基本的には、値が常に1から（15まで）の数値で、欠番がなく、重複もないようにしたいということと理解しました。 一方で、入力値（飛び番を入力など）が入力直後に変わってしまうのも気分が悪い（意図的な場合）とか…いろいろありそうなのが、最初に記した「いろいろなケース」の一例です。 全てのケースをお尋ねするのも面倒なので、勝手な解釈でサンプルとして作成してみました。 （なので、多分いろいろと違っていると想像します） ※ 範囲内にエラー値がある場合は動作しません。（VBAのエラーになります） ※ 考え方の一例ですので、入力値のチェック等は一切省いています。 　（実際には、上記両方への対処もしておいた方が良いと思います。） ※ 若干効率の悪い方法ですが、全体でたかだか15程度なので・・・ 基本的に、以下のような考え方で処理しています。 ・入力値は基本的に変更しない ・入力値以外の数値は小さい順に1～の整数に置き換える ・入力値と同じ値は発生させない ・ダブルクリックしたセルが数値以外なら、最も大きな整数に変える 以下、ご参考まで。（シートモジュールに記載のこと） Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) 　Call toOrder(Target, 0) End Sub Private Sub Worksheet_Change(ByVal Target As Range) 　Call toOrder(Target, 1) End Sub Sub toOrder(t As Range, f As Integer) 　Dim r As Range, rg As Range 　Dim ary, val, tval, n, i 　Set r = Range("C4:C18") 　Set rg = Application.Intersect(t, r) 　If rg Is Nothing Then Exit Sub ' 条件設定に合わせて前処理 ' （入力値を保存） 　Set rg = rg.Cells(1, 1) 　tval = -1 　If f = 1 Or WorksheetFunction.IsNumber(rg) Then 　　f = 1 　　tval = rg.Value 　End If ' 既入力の値を1からの順に変更 Application.EnableEvents = False 　rg.Value = Empty 　ary = r.Value 　n = 1 　val = WorksheetFunction.Min(r) 　Do While val > 0 　　i = WorksheetFunction.Match(val, r, 0) 　　r.Cells(i, 1) = Empty 　　ary(i, 1) = n 　　n = n + 1 　　If n = tval Then n = n + 1 　　val = WorksheetFunction.Min(r) 　Loop 　r.Value = ary ' 入力値を戻す（または次の値を入れる） 　If f = 1 Then n = tval 　rg.Value = n Application.EnableEvents = True End Sub ※ 条件が少し違うような場合は「前処理」のところで調整してみてください。 　 基本的に内容が違っている場合は、スルーしてください。（笑）
こんにちは 色を条件になさりたいようですが、考え方は2通りあるように思います。 ＞別のVBAを使い、順番に果物の名前をバーコード入力すると ＞選択された果物の名前のセルに、色が付いていくようになっています 何らかの条件判定をして色を付けていると思いますので、新しく色を付けた際に、同じ行の他のセルも判定して、全ての条件が揃っていたら○も記入してしまうようにすれば宜しいかと。 （この場合は、ご説明とは異なり、色を付ける元となる条件で判定していると言えます） 結果だけから改めて判定する場合でも、上記と同様の方法はとれると思います。 一方で、元の条件とは関係なく、色だけを手掛かりに判別したいのであれば、セルの背景色は 　Cell.Interior.Color で取得できますので、色が分かっていれば全部がその色かどうかを判定、あるいは白以外の色になっているかなどを確認することで判定可能だと思います。 （こちらは、シートに表示されている結果のみから判定する方法とも言えます） VBAで色を設定しているというご説明ですので、このあたりのことは既にご存知のことと想像しますが、逆に、どこが質問なさりたいポイントなのでしょうか？ （わからないところがどこなのかわからないのです。）
これでできると思います。 http://nasunoblog.blogspot.jp/2013/10/access-201 …
https://msdn.microsoft.com/ja-jp/library/sf1aw27b(v=vs.100).aspx Convert.Toint32 のマニュアルは読みましたか? ヒントも書いてありますよ。 > ただ、空欄でタブを押すとバグが出てしまいます。 こういう曖昧な情報にはほとんど意味はありません。 「具体的に」どんな状態になったのか、エラーが出たなら「具体的に」どんなエラーメッセージなのか、が重要です。 できれば、ご自身で読んで、ご自身で理由を考え、ご自身で直せるように勉強しましょう。
あらかじめ用意した文の中に、A1、B1、C1それぞれの挿入位置を特定する情報はありますか？ あれば可能です。無ければ作る必要があります。 例えば、あらかじめ用意する文を「あいうえお%A1%かきくけこ%B1%さしすせそ%C1%たちつてと」のようにして、％A1%をA1セルの内容で置き換えるようにします。 VBAであれば、Replace関数が使えるので、こんな感じです。 Sub sample() Dim a As Variant a = "あいうえお%A1%かきくけこ%B1%さしすせそ%C1%たちつてと" a = Replace(a, "%A1%", Range("A1")) a = Replace(a, "%B1%", Range("B1")) a = Replace(a, "%C1%", Range("C1")) Range("D1") = a End Sub
こんばんは！ コード内の ＞If Format(c.Value, "aaa") = "ABA" Then が何を意味しているのかイマイチ判らないのですが、 値が「ABA」という解釈での一例です。 Sub Sample1() Dim c As Range Range("A2:C4,A9:C11").Borders(xlDiagonalDown).LineStyle = xlNone For Each c In Range("A1:C1,A8:C8") If c = "ABA" Then c.Offset(1).Resize(3).Borders(xlDiagonalDown).LineStyle = xlContinuous End If Next c End Sub こんな感じではどうでしょうか？m(_ _)m
こんにちわ ユーザーフォーム1の質問ではないと思いますが、 入力項目が多いので、簡単にしてみました。 '"顧客シート"のA列～Q列にデータがある '氏名は2(B)列､住所は4(D)列､電話番号は6(F)列､メールアドレスは8(G)列 'ColumnWidthsが､0だと表示しない(ふりがな) 'xyLIst配列は､一次元目が列､二次元目が行になっている｡ 'Me.ListBox1.Column() = xyLIstで行列入れ替えている｡ 'UserForm1にはTextBox1､CommandButton1､CommandButton2､ 'CommandButton3､CommandButton4､ListBox1が有る｡ 'ここからUserForm1のコード　 Const cSheetName As String = "顧客シート" Private Sub UserForm_Initialize() Me.CommandButton1.Caption = "氏名で検索" Me.CommandButton2.Caption = "住所で検索" Me.CommandButton3.Caption = "電話番号で検索" Me.CommandButton4.Caption = "メールアドレス検索" Me.ListBox1.ColumnCount = 10 Me.ListBox1.ColumnWidths = _ "30;50;0;150;150;50;50;150;50;50" End Sub Private Sub CommandButton1_Click() '氏名で検索 '氏名は2(B)列､住所は4(D)列､電話番号は6(F)列､メールアドレスは8(G)列 Call 検索(2) End Sub Private Sub CommandButton2_Click() '住所で検索 '氏名は2(B)列､住所は4(D)列､電話番号は6(F)列､メールアドレスは8(G)列 Call 検索(4) End Sub Private Sub CommandButton3_Click() '電話番号で検索 '氏名は2(B)列､住所は4(D)列､電話番号は6(F)列､メールアドレスは8(G)列 Call 検索(6) End Sub Private Sub CommandButton4_Click() 'メールアドレス検索 '氏名は2(B)列､住所は4(D)列､電話番号は6(F)列､メールアドレスは8(G)列 Call 検索(8) End Sub Private Sub 検索(ByVal 検索列 As Long) Dim xyLIst As Variant Dim Ws As Worksheet, xText As String Dim i As Long, j As Long, k As Long, n As Long Dim iCol As Long, iRow As Long xText = Me.TextBox1.Text If xText = "" Then MsgBox "TextBoxに入力してください。" Exit Sub End If Set Ws = Sheets(cSheetName) iCol = Ws.Range("A1").CurrentRegion.Columns.Count iRow = Ws.Range("A1").CurrentRegion.Rows.Count ReDim xyLIst(1 To iCol, 1 To 1) n = 0 For i = 2 To iRow If InStr(Ws.Cells(i, 検索列).Value, xText) Then n = n + 1 ReDim Preserve xyLIst(1 To iCol, 1 To n) For j = 1 To iCol xyLIst(j, n) = Ws.Cells(i, j).Value Next j End If Next i If n = 0 Then Exit Sub Me.ListBox1.Column() = xyLIst End Sub 使用方法 まず、テキストボックスに入力します。 その後、検索ワードの種類に会ったコマンドボタンをクリックする。
私も回答に加わります。 ただ、こちらの解釈が違っていましたら、特に、フィードバックは不要です。 >項目にダブルクオーテーション >見出し無し、 項目というのは、1列目という意味ですか？ 項目というのは、左端と一番上の行のことを指しますが、 その内、一番上の行は項目(フィールド行）ではないので、2行目からということでしょうか。 Ｈ列はyyymm形式　というのはよく分かりません。 VBAの場合は、正しくでません。 「201606」という形式で年月だけを表示する、というのでしたら、yyyymm です。 以下のスタイルの場合は、Text値では出せませんので、新たに書式で変えることになります。むろん、全部、Quotation Mark(Q) を入れるなら、Join の所を変えて、行の前後にQ を入れれば済みます。 '// Sub CSVMaking() 　　Dim myFileName 　　Dim Dat, buf 　　Dim fNo As Integer 　　Dim i As Long, j As Long 　　Const Q As String = """" 　　myFileName = Application.GetSaveAsFilename(FileFilter:="CSVファイル (*.csv,*.csv") 　　If TypeName(myFileName) = "Boolean" Then Exit Sub 　　　　fNo = FreeFile() 　　　　Open myFileName For Output As #fNo 　　Dat = Range("A2:N73").Value 　　For i = 1 To UBound(Dat) 　　　　　　　　buf = Application.Index(Dat, i) 　　　　　　　　buf(1) = Q & buf(1) & Q 　　　　　　　　buf(7) = Format$(CDate(buf(7)), "yyyy/mm/dd") 　　　　　　　　buf(8) = Format$(CDate(buf(8)), "yyyyMM") 　　　　　　　　Print #fNo, Join(buf, ",") 　　Next i 　　Close #fNo End Sub
返事ありがとうございます。 簡略化してみると分かるかと思います。 Do Until Fn = "" ファイルを取得 ① Wb.Worksheets(3) Wb.Worksheets(2) Wb.Worksheets("指定額") この条件を満たしているか。エラーの発生をチェックして、 ② エラートラップ(On Error ....)で捕まえて、 －エラーがないなら、中身を読む －エラーが発生したら、中身を読まないようにする。 ③ Fn = Dir 次のファイルを探す。 -Loop という仕組みです。
#1 です。 私の回答内容や #2 の回答内容と Range.Copy のヘルプを読んで、想像をして、新規 Excel ファイルで 「コピーして貼り付ける」 の部分だけを実験してみてください。 適当なセルをコピーして適当なセルに貼り付けてみるってだけの実験です。 そういう行為に尻が重いようではこの先も・・・ > 今の記述に<コピー先の Range>.PasteSpecial Paste:=xlPasteValueを追記すれば良いのでしょうか？ <コピー先の Range>.PasteSpecial Paste:=xlPasteValue はクリップボードの内容を貼り付ける命令です。 まずコピーしたい内容をクリップボードにもっていってください。 その方法は前回の回答に書いてあります。 # <コピー元の Range>.Copy # のようにコピー先のセル情報を指示しなければクリップボードに張り付く。 この流れは手動でコピペする操作をそのまんまコード化した流れになります。 1. コピー元のセルを選択し、[Ctrl]+[C] でコピーする。 　→ コピー元のセルの枠線が破線になってクルクル回りだし、内容がクリップボードにコピーされたことがわかる。 2. コピー先のセルを選択し、[ホーム]-[貼り付け]-[値の貼り付け] でセルにペーストする。
見出しの下の行にフィルタをかければ、いけるのでは…。 こんな感じです。 Sub 更新確認マクロ() ' Rows(5).AutoFilter Range("A4").CurrentRegion.AutoFilter Field:=11, Criteria1:="Check" Range("A4").CurrentRegion.Copy Sheets("Sheet2").Range("A1") Selection.AutoFilter End Sub
コードを確認したら、C列の値をクリアした時は、B列とG列～AA列はクリアしてありますよ。 シート複数での処理なら、ThisWorkbook のモジュールに変更しなければなりません。 そして現在番号をどこか固定のシートセルに持たせなければならないです。 C列をクリアした時、番号が抜けてもいいのかなど、きちんと仕様を考えて下さい。
自PC（Windows7 Pro ）からEventLogApp.xlsmを試した結果です。 相手PCがWindowsXP (^_^;) ならファイアウォールを無効にするだけで取得できました。 Windows7、Windows10ではさらに管理共有を有効にすることで取得できるようになりました。 (それぞれのPCに管理者権限あり、ワークグループ環境。) https://support.microsoft.com/ja-jp/kb/947232 ↑の『自分で解決する』をBATファイルにしたものを以下に置いておきます。 Windows10 Pro（10586）でも可。 ファイアウォールにしろ管理共有にしろセキュリティに関わることですので もっとピンポイントな設定がある筈なのだが。。。orz 管理共有_切り替え.bat rem 管理共有を有効にします。リモートシャットダウンなども可能になります。 echo off cls for /f "tokens=3 delims=\ " %%i in ('whoami /groups^|find "Mandatory"') do set LEVEL=%%i rem echo %LEVEL% if "%LEVEL%" neq "High" ( echo === 設定変更するには『管理者として実行』する必要があります。=== echo === このBATは変更するマシンのローカルにある必要があります。 === ) set RegAddress=HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy rem 『名前』登録されているか reg query %RegAddress% echo 現在の設定です。DWORDの値が 0x1 の場合は管理共有が有効です。0x0 の場合は無効。 echo; echo === 未設定の場合には、エラーが返ってきます。=== echo; echo -------------------------- echo [キーそのものを削除] U echo -------------------------- echo [管理共有を有効に] S echo -------------------------- echo [管理共有を無効に] D echo -------------------------- echo [キャンセル] C echo -------------------------- echo 選択は？ choice /C usdc /N > nul IF %ERRORLEVEL%==4 GOTO Cancel IF %ERRORLEVEL%==3 GOTO Disable IF %ERRORLEVEL%==2 GOTO SetKey IF %ERRORLEVEL%==1 GOTO UnSetKey IF %ERRORLEVEL%==0 GOTO Cancel rem来ない :UnSetKey reg delete %RegAddress% goto Result :SetKey set t= /t REG_DWORD /d 1 reg add %RegAddress%%t% goto Result :Disable set t= /t REG_DWORD /d 0 reg add %RegAddress%%t% goto Result :Cancel echo キャンセルが選択されました。 timeout /t 3 exit :Result echo; echo 操作結果 reg query %RegAddress% echo 終了します。何かキーを押してください。 pause>nul
> そのため、１とリネームされたCSVファイルとZIPファイルが残って > いる状態なのですが、この２つは上の作業後終了と同時に > 消すことは可能なのでしょうか？； 前回のコードに一部変な漏れがあったので、一緒に直したものを提示します。 また、エラーが発生した時にどうあるべきか、までは考慮してません。 ' ' 解凍したファイルのパスリスト ' ' Private Type extractPathList ZipFilePath As String CsvFilePath As String End Type Public Sub test() ' zipファイルを解凍して1.csvにリネームする Dim pathList As extractPathList pathList = extractFile(ActiveWorkbook.Path, ActiveWorkbook.Path) pathList.CsvFilePath = rename(pathList.CsvFilePath) ' With ActiveSheet.QueryTables.Add(Connection:= _ ' "TEXT;" & CsvFilePath _ ' , Destination:=Range("$A$2")) ' .Name = "1" ' .FieldNames = True ' .RowNumbers = False ' .FillAdjacentFormulas = False ' .PreserveFormatting = True ' ' ・・・ ' 1.csvファイル、zipファイルの削除 Kill pathList.CsvFilePath Kill pathList.ZipFilePath End Sub ' ' ファイルの解凍を行う ' @param targetDirectoryPath 走査するディレクトリ ' @param destPath 解凍先 ' @return 最後に解凍されたcsvファイルパス ' Private Function extractFile(targetDirectoryPath As String, destPath As Variant) As extractPathList Const FOF_SILENT = &H4 '進捗ダイアログを表示しない。 Const FOF_NOCONFIRMATION = &H10 '上書き確認ダイアログを表示しない（[すべて上書き]と同じ）。 Dim fso As Object Dim lastExtractFileName As String Set fso = CreateObject("Scripting.FileSystemObject") ' ファイル内の全てのファイルを調べる For Each file In fso.GetFolder(targetDirectoryPath).Files If fso.GetextensionName(file) = "zip" Then extractFile.ZipFilePath = file Dim shell As Object Dim zipFile As Object Dim destDirectory As Object Set shell = CreateObject("Shell.Application") Set zipFile = shell.Namespace(file.Path) Set destDirectory = shell.Namespace(destPath) For Each f In zipFile.Items If Not f.IsFolder And Right(f.Name, 4) = ".csv" Then destDirectory.CopyHere f, FOF_NOCONFIRMATION + FOF_SILENT lastExtractFileName = f.Name End If Next End If Next Set destDirectory = Nothing Set zipFile = Nothing Set shell = Nothing Set fso = Nothing extractFile.CsvFilePath = destPath & "\" & lastExtractFileName End Function ' ' ファイル名を固定値に変更する ' @param targetFilePath ファイル名を変更するファイルパス ' @return ファイル名が変更されたファイルパス ' Private Function rename(targetFilePath As String) As String Dim destFilePath As String Dim directoryPos As Integer directoryPos = InStrRev(targetFilePath, "\") destFilePath = Left(targetFilePath, directoryPos) & "1.csv" Name targetFilePath As destFilePath rename = destFilePath End Function
呼び出し方はあっています。 ＵＲＬにもう一か所レース場のコードを入れないといけなかったようです。 こちらに差し換えて下さい ---------------------------------------------------------------------------- Sub データ抽出(Day_初日 As Date, Day_日付 As Date, Lng_場 As Long) Dim Obj_IE As Object Dim Str_ソース As String Dim Str_アドレス As String Dim Lng_レース As Long Lng_レース = 1 Str_アドレス = "http://app.boatrace.jp/race/" & Format(Lng_場, "00") Str_アドレス = Str_アドレス & "_" & Format(Day_初日, "yyyymmdd") Str_アドレス = Str_アドレス & ".php?day=" & Format(Day_日付, "yyyymmdd") Str_アドレス = Str_アドレス & "&jyo=" & Format(Lng_場, "00") Str_アドレス = Str_アドレス & "&rno=" & Format(Lng_レース, "00") & "&type=program" Set Obj_IE = CreateObject("InternetExplorer.Application") With Obj_IE .Navigate Str_アドレス Do While .Busy = True DoEvents Loop Do While .Document.ReadyState <> "complete" DoEvents Loop Str_ソース = .Document.Body.InnerText .Quit End With Set Obj_IE = Nothing If InStr(Str_ソース, "このページは表示できません") <> 0 Then MsgBox ("アドレス違い") Exit Sub End If If InStr(Str_ソース, "データが見つかりません") <> 0 Then MsgBox ("データが見つかりません") Exit Sub End If If Len(Str_ソース) < 1500 Then MsgBox ("データが有りません") Exit Sub End If Sheets("作業").Select Cells.Delete Shift:=xlUp For Lng_レース = 1 To 12 Str_アドレス = "http://app.boatrace.jp/race/" & Format(Lng_場, "00") Str_アドレス = Str_アドレス & "_" & Format(Day_初日, "yyyymmdd") Str_アドレス = Str_アドレス & ".php?day=" & Format(Day_日付, "yyyymmdd") Str_アドレス = Str_アドレス & "&jyo=" & Format(Lng_場, "00") Str_アドレス = Str_アドレス & "&rno=" & Format(Lng_レース, "00") & "&type=program" Str_アドレス = "FINDER;" & Str_アドレス With ActiveSheet.QueryTables.Add(Connection:=Str_アドレス, Destination:=Cells(1, Lng_レース * 5 - 4)) .Name = "Data" .FieldNames = True .RowNumbers = False .FillAdjacentFormulas = False .PreserveFormatting = False .RefreshOnFileOpen = False .BackgroundQuery = False .RefreshStyle = xlInsertDeleteCells .SavePassword = False .SaveData = True .AdjustColumnWidth = True .RefreshPeriod = 0 .WebSelectionType = xlEntirePage .WebFormatting = xlWebFormattingAll .WebPreFormattedTextToColumns = True .WebConsecutiveDelimitersAsOne = True .WebSingleBlockTextImport = False .WebDisableDateRecognition = False .WebDisableRedirections = False .Refresh BackgroundQuery:=False End With Next MsgBox ("終了しました") End Sub
こんばんは 関数では同じセルの値を置換することは出来ませんがVBAなら可能です。 sample1はIF関数のVBA版です。 sample2は置換の機能を使っています。 Sub sample1() Dim i As Long For i = 1 To Rows.Count If Cells(i, "A") = "A" Then Cells(i, "A") = "良好" If Cells(i, "A") = "B" Then Cells(i, "A") = "普通" If Cells(i, "A") = "C" Then Cells(i, "A") = "不可" Next End Sub または Sub sample2() Range("A:A").Replace "A", "良好", xlWhole Range("A:A").Replace "B", "普通", xlWhole Range("A:A").Replace "C", "不可", xlWhole End Sub
モジュールのエクスポートは、あるブックで作成したモジュールをバックアップする。または、他のブックに移植する場合などに使うものですよね？マクロ有効ブック（xlsm）で保存すればモジュールも一緒に保存されるので、普通は使う必要はありません。 自動オープンでフォームを開く場合は、ThisWorkbookオブジェクトのWorkbook_Openイベントプロシジャに次のように記述すればOKです。 Private Sub Workbook_Open() UserForm1.show End Sub タブストリップでリンク先のシートを変更するのは、こんな感じです。 タブを切り替える度に、表示されたタブのValueプロパティを判断して、リストボックスのRowSourceプロパティを設定し直します。 Private Sub TabStrip1_Change() Dim ws As String Select Case TabStrip1.Value Case 0 ws = "Sheet1" Case 1 ws = "Sheet2" Case Else ws = "Sheet3" End Select ListBox1.RowSource = ws & "!A1:A10" End Sub
No.1・3です。 ＞仮に"Sheet1"シートのA行から"統計"シートのB行へコピー、"Sheet1"シートのD行から"統計"シートのF行へ・・・ 「Sheet1」のA列を「統計Sheet」の最終行1行下のB列に、 「Sheet1」のD列を「統計Sheet」の最終行1行下のF列のにそれぞれコピー＆ペーストする！という意味でしょうか？ そうであれば当然コードそのものが変わってきます。 Sub Sample3() Dim j As Long, lastRow As Long, maxRow As Long, wS As Worksheet Dim Kyouka As String, myRnk As String Set wS = Worksheets("統計") With Worksheets("Sheet1") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row Kyouka = Application.InputBox("フィルタを掛ける教科を入力") myRnk = Application.InputBox("フィルタを掛けるランクを入力") With .Range("A1") .AutoFilter field:=3, Criteria1:=Kyouka .AutoFilter field:=5, Criteria1:=myRnk End With If .Cells(Rows.Count, "A").End(xlUp).Row > 1 Then maxRow = wS.UsedRange.Rows.Count + 1 Range(.Cells(2, "A"), .Cells(lastRow, "A")).Copy wS.Cells(maxRow, "B") Range(.Cells(2, "D"), .Cells(lastRow, "D")).Copy wS.Cells(maxRow, "F") wS.Range("A1").CurrentRegion.Borders.LineStyle = xlContinuous End If .AutoFilterMode = False End With End Sub こんな感じになると思います。 ただ、「統計」Sheetの貼り付ける列を変えてしまうと、項目が異なる列に貼り付けることになるので データとしては全く意味がないものになるような気がするのですが・・・m(_ _)m
練習してるんだよね？ 答え聞いたら練習にならないじゃん
サンプルです。 「ABC」「DEF」のフルパスを正しく記載すれば動きます。 xlsxの場合はサンプルのxlsを修正して下さい。 vbaを貼り付けたエクセルをデスクトップ以外の場所に格納して実行して下さい。 Sub WK() Dim buf As String Dim newfilename As String Dim oldfilename As String Dim Sh As Worksheet Const Path As String = "C:\Users\user\Desktop\ABC\" 'ファイル一覧を取得 buf = Dir(Path & "*.xls") Do While buf <> "" 'ブックを開く Workbooks.Open "C:\Users\user\Desktop\ABC\" & buf oldfilename = buf buf = Dir() 'A2のファイル名を取り込む newfilename = Workbooks(oldfilename).Worksheets(1).Range("A2") 'ブックを名前を付けて保存 Workbooks(oldfilename).SaveAs filename:="C:\Users\user\Desktop\DEF\" & newfilename 'ブックを閉じる Workbooks(newfilename & ".xls").Close Loop E4: Application.StatusBar = False End Sub
ちょっとだけまずいところが有りましたので、修正します。 '検索用のテキストボックス更新後の処理 Private Sub TextBox1_AfterUpdate() Dim Obj As Object Dim wAddST As Variant Dim wAddress As Variant Dim wKamoku As Variant With Worksheets("Sheet1") 'テキストボックスの値が含まれるセルを検索 Set Obj = .Range("A:A").Find(what:=TextBox1.Value, _ LookIn:=xlValues, _ lookat:=xlPart, _ matchbyte:=False) '検索対象がない場合はメッセージを表示 If Obj Is Nothing Then MsgBox "対象科目は存在しません。", _ vbOKOnly + vbInformation, "検索" Else '検索にヒットした先頭のセルのアドレスをセット wAddST = Obj.Address 'リストボックスのList列数をセット 'ReDim ListBox1.List(0 To 0, 0 To 2)の替り ListBox1.List = Range("A1:C1").Value 'リストボックスをクリア ListBox1.Clear '検索の繰り返し処理 Do '検索にヒットしたセルの値を取得 'リストボックスに追加 ListBox1.AddItem Obj.Value ListBox1.List(UBound(ListBox1.List), 1) = Obj.Offset(, 1).Value ListBox1.List(UBound(ListBox1.List), 2) = Obj.Row '次の検索を行う Set Obj = .Range("A:A").FindNext(Obj) '最初にヒットしたアドレスと同じ場合は処理を終了 If Obj.Address = wAddST Then Exit Do Loop End If End With End Sub '検索リストボックス内のデータをダブルクリックするとシートのデータを選択します。 Private Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean) Dim i As Long i = Me.ListBox1.ListIndex Worksheets("Sheet1").Activate On Error Resume Next Cells(Me.ListBox1.List(i, 2), "A").Select On Error GoTo 0 End Sub
ActiveSheetを使うなら、その前で、Sheets(シート名).Activateすべきです。 何が問題か、理解できていますか？
ANo1です。 ACCESSはまったく知らないのですが（←しつこい（苦笑））、どうやら予定なさっているものと、とインデックスが異なっているようですね。 回答者には、質問文にご提示のコードしか情報がなくそれ以外はわかりませんので、どこが悪いのかの特定はできません。 データが正しいのであれば、その扱い方（＝ご提示のコード）が間違っていることになりますし、コードが正しいとすれば、データが壊れている可能性も考えられます。 あるいは、両方ともおかしいのか・・・ いずれにしろ、データとその取扱い（＝コード）がマッチしていないためにエラーが起きていると考えられます。 CSVの各レコードのデータ数が異なる可能性があるのであれば、それに応じた扱いをする必要があります。 存在しないかも知れないデータをいきなり、myArray(6）などで利用しようとすればエラーになる可能性がありますよね？ このような場合は、事前にデータが存在するかの確認を行うことと、存在しない場合の処置も併せて記述しておく必要があります。
こんにちは ＞ファイルの保存先が、指定フォルダでは無く、 ＞最後に指定したフォルダへ保存されてしまいます。 保存先としたいフォルダは、\\TEST\testということでしょうか？ ＞ActiveWorkbook.SaveAs～～ のところで、思い通りにならないのかと想像しますが、パラメータに 　Filename:="\\TEST\test\" & FLname を加えてもうまくいきませんか？ https://msdn.microsoft.com/ja-jp/library/office/ …
DataGridViewとDataSetおよびDataTableは別物ですよ。 DataGridViewをソートしたからといって、DataTableの並び順が変わるわけではありません。 ループする対象は、DataTableではなく、DataGridViewでしょうね。 また、いくつかの方法論が出てきますが、ここら辺の説明のように、DataViewを利用するとか、ソートしたものを別なDataTableに落とし込むとかします。 https://social.msdn.microsoft.com/Forums/vstudio … http://www.atmarkit.co.jp/fdotnet/dotnettips/363 … http://jehupc.exblog.jp/9814663/ http://noqisofon.hatenablog.com/entry/20110328/1 … http://futuremix.org/2009/03/datatable-select-sort が、可能ならば、そもそも求めるソート順で読み込むという方が楽です。
これってどうすかぁ →http://www.geocities.jp/japan_inf/DotNetBarcode/ …
ANo2です。 すみません、無知でした。 ANo1様の回答で、基本的にできますね。 あとはいろいろなケースを考慮して、対応すれば宜しいかと。 失礼いたしました。
以下 QA の Samp3 でどうでしょう エクセル　表の縦横全てを網羅した入れ替え http://oshiete.goo.ne.jp/qa/9081579.html Samp3 を使う場合の設定データは、 A, B ～ 列方向：求めたい桁数分 1 行目：1 2 行目：2 ある桁だけ 3 も･･･なら、その桁の 3 行目に 3 ※ 数字以外の設定でも･･･
こんにちは。 >すみませんVB初心者のため、全体的なコーディングの流れを教えて頂けると助かります。 コーディングといっても、VB.Net では、TextBox に出てきたものを流し込むだけですよね。今、VB.Net と言われても、感覚を取り戻すまでには時間も掛かります。ですから、VBSで間に合わせさせていただきます。 》xd2tx216.zip に入っている 》xd2txcom.dll (xdoc2txt com dll版)サンプル VBScipt は参考にはなりませんか？ 》 (1)xd2txcom.dllをregsvr32で登録してから実行してください。 》　regsvr32 xd2txcom.dll 》 (2)64bit OSで実行するときは、%WINDIR%SysWOW64\CScript.exe で実行してください。 細かい所は、「誰でも使えるxdoc2txt」を参考にしてください。 http://talk-pc.sakura.ne.jp/anybody_setup_xdoc2t … ありきたりですが、簡単なコードを、VBSで作ってみました。 要するに、regsvr32 で登録した後は、 Set objXDOC = CreateObject("xd2txcom.Xdoc2txt.1") とか、com オブジェクトで設定すれば済むわけです。 objXDOC.ExtractText(strArg, False) 実行コマンドはこれです。 後は、通常通りだと思います。 以下は、ドラッグ&ドロップ でアーギュメントを与える方法ですが、必要な部分だけを取り出してまってください。 主要なものはほとんど読めるようになっています。 As/R というファイラーに組み込んでしまいましたが、 http://www.all.undo.jp/asr/1st/ こんな簡単なものでも、思った以上に便利です。 Editorでみますから、textファイルは読みません。 また、画像が入っているものは、しばらく止まっていることがあります。 バグっぽいところは、気がついているのですが、それは、ご容赦のほどを。 '----Xdoc2Txt_Viewer.vbs---- Dim ext Dim objFs Dim txtOut Dim strArg Dim strExt Dim exts Dim ret Dim buf strExt = "rtf,docx,xlsx,xlsm,pptx,doc,xls,ppt," & _ "sxw,sxc,sxi,sxd,odt,ods,odp,odg,jaw,jtw,jbw," & _ "juw,jfw,jvw,jtd,jtt,oas,oa2,oa3,bun,wj2" & _ "wj3,wk3,wk4,123,wri,pdf,mht,html,eml" exts =Split(strExt,",") Set Args =Wscript.Arguments txtOut ="" Set objXDOC = CreateObject("xd2txcom.Xdoc2txt.1") Set objFs= CreateObject("Scripting.FileSystemObject") For Each strArg in Args ext= objfs.GetExtensionName(strArg) ret =Filter(exts,ext,True,1) If UBound(ret)>-1 And Ubound(ret)< 2 Then buf =objXDOC.ExtractText(strArg, False) txtOut = txtOut & buf & vbCrLf Else txtOut =txtOut & vbCrLf & strArg End If Next If txtOut <>"" Then MsgBox txtOut End If '----------------
こんな感じになると思います。 登録については、エラーチェックをするように書かれていたので、チェックしていますが、削除の方はノーチェックです。登録のコードを参考に、自力で実装してみて下さい。 Private Sub 削除_Click() Dim c As Variant Dim firstAddress As Variant With Worksheets("Sheet1").Range("A:A") Set c = .Find(削除_品目, LookIn:=xlValues) If Not c Is Nothing Then firstAddress = c.Address Do If c.Offset(0, 1) = 削除_ロケ Then c.EntireRow.Delete Shift:=xlUp Exit Sub End If Set c = .FindNext(c) Loop While Not c Is Nothing And c.Address <> firstAddress End If End With End Sub Private Sub 登録_Click() Dim StoreRow As Long If 登録_品目 = "" Or 登録_ロケ = "" Then MsgBox "入力してください！！" Exit Sub End If With Worksheets("Sheet1") If WorksheetFunction.CountIfs(.Range("A:A"), 登録_品目, _ .Range("B:B"), 登録_ロケ) > 0 Then MsgBox "重複しています！！" Exit Sub End If If WorksheetFunction.CountIf(.Range("A:A"), 登録_品目) > 0 Then If MsgBox("重複があります。登録しますか？", vbOKCancel) = vbCancel Then Exit Sub End If End If StoreRow = .Cells(Rows.Count, "A").End(xlUp).Row + 1 .Cells(StoreRow, "A") = 登録_品目 .Cells(StoreRow, "B") = 登録_ロケ End With MsgBox "登録しました。" End Sub
Rowsourceプロパティは、String型なので、普通に文字列の結合でできますよ。 以下、サンプルです。UserForm_Clickイベントプロシジャに張り付けてみて下さい。 ユーザフォームをクリックするたびに、アクティブシートを移動し、移動後のA1:A10をRowsourceに設定してます。 Private Sub UserForm_Click() Dim I As Long Dim RowSourceSheetName As String I = ActiveSheet.Index + 1 If I > Worksheets.Count Then I = 1 Worksheets(I).Select RowSourceSheetName = ActiveSheet.Name ListBox1.RowSource = RowSourceSheetName & "!A1:A10" End Sub
とりあえず、シングルクォーテーションが全角なのは投稿時のタイプミス？ RS.Find "住所１= ’" & abc & "’" ↓ RS.Find "住所１= '" & abc & "'" 質問する上で どの行で止まるのか。 エラーメッセージの内容。 少なくともエラーが発生するまでのプロシージャの内容。 Accessのバージョン。 を今後はのせるようにしましょう。 蛇足ですが、標準モジュールで Sub Test() dim v as long v = 1 /0 end sub を実行するとエラーになります。 この時に、[デバッグ]を選択し、 Ctrl + G でイミディエイトウィンドウが出ます。 そこに ?err.description,err.number でEnter Key にて、『0 で除算しました。　　　　　 11 』と表示されます。
更新クエリでなくても、フォームに合計フィールドと連結しているテキストボックスを作成し、そこに反映させれば保存されますよ。 そういう方法もあります。
whereで列ＢがNothingだけにして、列ＡのMinの値を取得 列Ａ指定して、狙い打ちでUpdate
動作の確認はしていません Sub Macro1() Dim GYOU As Long Workbook.Open Filename:=”C:¥共有¥マクロ.xlsx” ThisWorkbook.Activate With Workbooks(”マクロ.xlsx”) .Sheets(”様式1”).Unprotect GYOU = .Sheets(”様式1”).Range(”A” & Rows.Count).End(xlUp).Row + 1 .Sheets(”様式1”).Range(”A” & GYOU & ”:AA” & GYOU + 1880).Value =Sheets(”様式A”).Range(”A2:AA2000”).Value .Sheets(”様式1”).Protect DrawingObjects:=True, Contents:=True, Scenarios:=True .Sheets(”様式2”).Unprotect GYOU = .Sheets(”様式2”).Range(”A” & Rows.Count).End(xlUp).Row + 1 .Sheets(”様式2”).Range(”A” & GYOU & ”:W” & GYOU + 1880).Value =Sheets(”様式B”).Range(”A2:W2000”).Value .Sheets(”様式2”).Protect DrawingObjects:=True, Contents:=True, Scenarios:=True .Close SaveChanges:=True End with End Sub >③様式A,Bは特にプロテクト外さなくても大丈夫ではないですか？
よ～く、考えてコードを見てみましょう。 ThisWorkbook.Activate With Workbooks(”マクロ.xlsx”) Sheets(”様式1”).Activate Sheets(”様式1”).Unprotect 保護を解除したのは、ThisWorkBookの　 Sheets(”様式1”).Unprotect 本当は、Workbooks(”マクロ.xlsx”) ではないでしょうか。 ならば ThisWorkbook.Activate With Workbooks(”マクロ.xlsx”) .Sheets(”様式1”).Unprotect
あわせて作り直しました。ただ「Range(”A2:AA6000”).Value=””」はどのシートか判らないので省きました。 --------------------------------------------------------------- Sub Macro1() Dim GYOU As Long Workbooks.Open Filename:="C:\共有\マクロ.xlsx" With Workbooks("マクロ.xlsx") .Sheets("様式1").Select ActiveSheet.Unprotect GYOU = .Sheets("様式1").Range("A" & Rows.Count).End(xlUp).Row + 1 ThisWorkbook.Activate Sheets("様式1").Select Range("A2:AA2000").Select Selection.Copy .Activate Range("A" & GYOU).Select Selection.PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:=False, Transpose:=True ActiveSheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True .Sheets("様式2").Select ActiveSheet.Unprotect GYOU = .Sheets("様式2").Range("A" & Rows.Count).End(xlUp).Row + 1 ThisWorkbook.Activate Sheets("様式2").Select Range("A2:W2000").Select Selection.Copy .Activate Range("A" & GYOU).Select Selection.PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:=False, Transpose:=True ActiveSheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True Application.CutCopyMode = False .Close SaveChanges:=True End With End Sub ---------------------------------------------------------------
どこで、どのようなエラーが出ましたか？ よく見ていませんが「ActiveSheet.Unprotect」は「ThisWorkbook.Activate」の前の行に入れないと保護解除されません。
＞だけど接続先が教えてくれるでしょうか？ (´･ω･｀)しらんがな 今やろうとしていることは悪戯では済まされない事と理解しているのだろうか。
>AutoFilter で間が空くような現象 フィルターの条件を複数指定して、条件の１つに(空白セル)を入れるとか？ (＝特定のコード１つのみ除外して残りのデータは全て残したい場合など) >Range("a1").CurrentRegion.Rows.Count + 1).PasteSpecial Paste:=xlPasteValues わざわざこう書く場合は、貼り付け先に既にデータがあるという事ではないのでしょうか。 つまり、元々のコードは過去データに追記していくような仕様で設計されているとか？ ※提示されたコードを２回実行すれば動きが確認できると思います。 その場合、空白を含んではいけない仕様になります。 [予想] どこかからコード流用。そのコードは過去データに追記する仕様(空白セルを含んではいけない前提) ↓ 質問者が元コードの仕様を理解せず、自分の都合で空白セルを含む仕様を追加して質問。
「Workbook.Open Filename:=”C:¥共有¥マクロ.xlsx”」は 「Workbooks.Open Filename:="C:\共有\マクロ.xlsx"」です。 「Sub Macro1()」の後に 「Dim GYOU As Long」も必要です。 シート保護を解除するため「ActiveSheet.Unprotect」も必要です。
「他のパソコン」のユーザー名が「会社User」ではないと指定のパスは存在しなくなります。 ChDir "C:\Users\会社User\Desktop"　を以下の様に変更したらどうでしょうか？ ↓ ChDir "C:\Users\” & Application.UserName & "\Desktop"
ANo3です。 ANo3の説明が縦・横が逆になって、おかしな説明になってしまっていました。 （意図するところは通じるとは思いますが・・・） 以下、念のため。 Column(2)　→　Rows(2) 　（列にしてもColumns(2)とすべきところでした（汗）） Range("C2:C100")　→　Range("C2:CX2") 　（こちらの範囲は適当ですので、よしなに・・・）
簡単に検索しただけでは駄目でしたな。 添付画像は「どなたかが作成したもの」であってコントロールの実際の表示ではない。ということのようで。 http://dobon.net/cgi-bin/vbbbs/cbbs.cgi?mode=al2 … http://ja.stackoverflow.com/questions/21731/c-da … 簡単な方法は無い。と思われます。 表示したいカレンダーコントロールを自前で作成し、DateTimePickerから継承したコントロールで地道に作る…ということになるかと。 DateTimePickerコントロールで表示されるカレンダー(予定表)を制御する手段があるのかどうかはちょっと判りませんが。 DropDownイベントとCloseUpイベントがあるのは確認できましたけど…。
こんな感じです。 「デスクトップに年月日のフォルダを作り」とのことでしたが、デスクトップのパスの取得方法が分からなかったので、マクロ実行ブックのあるフォルダに年月日のフォルダを作っています。 それから、識別コードに対する担当者名が無い場合は、識別コードそのものでブックを作成しています。 Option Explicit Dim SAVEPATH As String Sub sample() Dim fd As FileDialog Dim ps As String Dim fn As String Dim ws As Worksheet Dim wb As Workbook Set fd = Application.FileDialog(msoFileDialogFolderPicker) If fd.Show <> -1 Then Exit Sub ps = fd.SelectedItems(1) SAVEPATH = ThisWorkbook.Path & "\" & Format(Now(), "yyyymmdd") On Error Resume Next MkDir SAVEPATH On Error GoTo 0 fn = Dir(ps & "\*.xlsx") Do While fn <> "" Set ws = Workbooks.Add(ps & "\" & fn).Worksheets(1) Call SubAdd(Right(ws.Name, 4), Tantousyamei(Right(ws.Name, 4)), ws) ws.Parent.Close (False) fn = Dir() Loop For Each wb In Workbooks If Not wb Is ThisWorkbook Then wb.Close Next End Sub Private Sub SubAdd(TanCode As String, TanMei As String, ws As Worksheet) Dim wb As Workbook On Error GoTo ErrorHandler Set wb = Workbooks(TanMei & ".xlsx") ws.Copy After:=wb.Sheets(wb.Sheets.Count) ActiveSheet.Name = TanCode wb.Save Exit Sub ErrorHandler: Select Case Err.Number Case 9 ws.Copy ActiveSheet.Name = TanCode ActiveWorkbook.SaveAs (SAVEPATH & "\" & TanMei) Exit Sub Case Else MsgBox Err.Number & " " & Err.Description End End Select End Sub Private Function Tantousyamei(c As String) As Variant Tantousyamei = c On Error Resume Next Tantousyamei = WorksheetFunction.VLookup(c, ThisWorkbook.Sheets(3).Range("A:B"), 2, False) & "様分" End Function
質問内容が明確になりました。ありがとうございます。 再度確認します。 指定したフォルダの中のエクセルファイルを全て確認し、経費用ファイルなら経費用シートへ転記、交通費用ファイルなら交通費用のシートへ転記、それ以外は無視。 となると思いますが良いですか？ それで、話を進めるとして、処理の順番でいうと、 １、フォルダ名を取得 ２、そのフォルダのエクセルファイルを全て取得 ３、取得したエクセルファイルを順番に開き、A1セルを取得 ４、A1セルが経費用か交通費用かそれ以外かを判定 ５、転記開始 ざっくりとこんな感じになるかと思いますが、どうですか？ ただ、初心者にはかなりしんどいと思いますよ。 言われた通りに作成したとしても、おそらく今後のメンテも担当するのではないですか？修正できますか？ こういう場合、一旦受けたとしても「どれくらい時間がかかるのか」を考え、その期間をもらわないとダメですよ。仮に１週間もらったとしても、それに間に合わないようなら早めに相談すべきです。なかなか難しいんですけど、これがあなたにとって最良の選択だと思います。 可能な限り支援させてもらいますが、「コードを作ってくれ」というような依頼であれば、再度質問を立てて下さい。 あとはあなた次第です。
うーむ… VBAに関しては、女性も男性もないですよ。 まず、VBAは初めてなんですよね？ 変数も分からない？ IF文も分からない？ とはいえ、やるしかないか… なので、質問に他の方の回答がありますので、その順番でやりましょう。 １は出来てるんですよね。 確認ですが、レポートにもサブレポートにも、レコードソースは設定されてるんですよね？単独でも開くんですよね？
↓ の説明です。 「i」は行番号です。 「j」は列番号です。（「X列」までで最後の「,」が不要なので23+1までとしました。） 「s」は１行分の文字列です。（For～Next の方がコードが短くなるので、いったん文字列へ代入しましたが、もちろんダラダラ～と書いても良いです。） 「Write」→「Print」の理由は自分の好きな書式に出来るためです。 「Chr(34)」は「"」の事です。 後は、元のコードを生かしたつもりなので説明不要かと…
転送処理前にマクロで転送先のシート保護を外して、転送後にマクロでシート保護をかければ実現します。 シート保護と解除をマクロの自動記録させればコードも大体わかると思います。
テキストボックスには、ControlSourceプロパティというのがあるのですが、これを設定すると任意のセルとリンクが張れます。セルの値が表示できるだけではなく、テキストボックスの値を変更すれば、セルに反映してくれるので、目的によっては非常に便利です。 リンクを張り替えることにより、表示するセルを移動できます。 簡単なサンプルを書いてみたので、ご確認下さい。 Private Sub UserForm_Initialize() A.ControlSource = "A1" B.ControlSource = "B1" C.ControlSource = "C1" End Sub Private Sub 次へ_Click() On Error GoTo Fin Selection.Offset(1).Select A.ControlSource = "A" & Selection.Row B.ControlSource = "B" & Selection.Row C.ControlSource = "C" & Selection.Row Fin: End Sub Private Sub 戻る_Click() On Error GoTo Fin Selection.Offset(-1).Select A.ControlSource = "A" & Selection.Row B.ControlSource = "B" & Selection.Row C.ControlSource = "C" & Selection.Row Fin: End Sub
あ、取得と反映です。 A1セル＝Sheets("Sheet1").Cells（1,1） ※スマホなんで、時間がかかってしまいます。
CurrentRegion http://officetanaka.net/excel/vba/cell/cell10.htm これとかどうです？
どこかで見たような・・・。 hatena師匠のサイトでした。 http://hatenachips.blog34.fc2.com/blog-entry-159 … 実装したことはありませんが参考になるかと思います。
こんな感じでしょうか？ シートモジュールに -------------------------------------------------------------- Private Sub Worksheet_Change(ByVal Target As Range) If Target = Range("A1") Then Select Case Range("A1").Value Case "a001", "a002" Sheet2.Select Case "b001", "b002" Sheet3.Select End Select End If End Sub --------------------------------------------------------------
横からすみません 隊を入れるだけで良ければ Workbooks.Open Filename:="C:\共有\マクロ.xlsm" ActiveSheet.Unprotect Range("D7:G27").Value=ThisWorkbook.Range("C4:F24").Value ActiveSheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True ActiveWorkbook.Save ActiveWindow.Close を３回ではダメでしょうか。
ReadFlc.dll の配置方法の問題ではなく、ReadFlc.dll の 64bit OS 対応の問題なのでは？ ReadFlc.dll の入手元または開発元に確認するのが確実と思われます。 ReadFlc.dll の配布サイトと思われる下記のサイトでのページ下部、動作環境のセクションに 「本DLLは、Windows Vista（32bit）、Windows7（32bit）でのみ動作可能です。それらのOSの64bit版やWindows XPでは動作しません。」 と書かれています。 配布元と思われるページ http://tsware.jp/download/accpasori/
１６進だと「3042 3044 3046 3048 304A」 メモリ上では「42304430463048304A30」 これをシフトＪＩＳだと「B0D0F0H0J0」なります。 エクセルはシフトＪＩＳ表示になるため
Excel2003だと、RemoveDuplicates だけではなく、SUMIFS も使えませんね～。 そうなるとスマートな書き方ができません。ゴリゴリのVBAになりますが、こんな感じでどうでしょう。 Sub 抽出_Click() Dim ws1 As Worksheet Dim ws2 As Worksheet Dim dic As Variant Dim Key As Variant Dim MaxRow As Long Dim I As Long Dim J As Long Set ws1 = Sheets("登録") Set ws2 = Sheets("代表") Set dic = CreateObject("Scripting.Dictionary") ws2.Rows("2:" & Rows.Count).ClearContents MaxRow = 1 For I = 2 To ws1.Cells(Rows.Count, "A").End(xlUp).Row Key = ws1.Cells(I, "A") & "|" & ws1.Cells(I, "B") & "|" & ws1.Cells(I, "C") If dic.Item(Key) = "" Then MaxRow = MaxRow + 1 dic.Item(Key) = MaxRow J = dic.Item(Key) ws2.Cells(J, "A") = ws1.Cells(I, "A") ws2.Cells(J, "B") = ws1.Cells(I, "B") ws2.Cells(J, "C") = ws1.Cells(I, "C") End If J = dic.Item(Key) ws2.Cells(J, "D") = ws2.Cells(J, "D") + ws1.Cells(I, "E") Next End Sub
既に回答が出ていますが ＞どこにどの様にプログラミングすれば良いかお教え頂けないでしょうか。 もし、ユーザーフォームを開いた時に　と云う事であれば Private Sub UserForm_Initialize() TextBox1.Value = Range("A1").Value End Sub とします。 Private Sub UserForm_Initialize() は、 このUsefromを開いた時に実行するイベントです。
「End If」が、１つ足りません。 ---------------------------------------------------------- Private Sub 登録_Click() Dim MyRegEx As New RegExp Dim RegCheck As Boolean '電話番号正規表現チェック' If 電話番号テキストボックス.Value <> "" Then MyRegEx.Pattern = "\d{2,4}-\d{2,4}-\d{4}" RegCheck = MyRegEx.Test(電話番号テキストボックス.Text) If RegCheck = False Then MsgBox "電話番号が不正です。" Exit Sub End If End If ' 登録作業 MsgBox "登録完了" End Sub ---------------------------------------------------------- もし下図のようにエラーメッセージが出た場合「Microsoft VBScript Regular Expressions ?.?」（?.? にはバージョン 1.0 とか 5.5 が入ります）が参照設定されていません。（複数ある場合はどれか１つ） VBEの画面で、「ツール」→「参照設定」で、「Microsoft VBScript Regular Expressions ?.?」にチェックを付け、決定してください。
Private Sub MakeNewData(angle As Integer, arrayData() As Variant) 　　Dim index1 As Integer 　　Dim index2 As Integer 　　Dim index1t As Integer 　　Dim index2t As Integer 　　Dim x As Integer 　　Dim y As Integer 　　Dim xt As Integer 　　Dim yt As Integer 　　For index1 = LBound(m_objOriginalData, 1) To UBound(m_objOriginalData, 1) 　　　　For index2 = LBound(m_objOriginalData, 2) To UBound(m_objOriginalData, 2) 　　　　　　x = index1 - Application.RoundUp(SQUARE_ONESIDE / 2, 0) 　　　　　　y = Application.RoundUp(SQUARE_ONESIDE / 2, 0) - index2 '　　　　　　Debug.Print "[kx,ky]" & vbTab & index1 & " " & index2 & "→" & x & " " & y 　　　　　　 　　　　　　Call Calculate(x, y, angle, xt, yt) '　　　　　　Debug.Print "[x,y]" & vbTab & x & " " & y & "→" & xt & " " & yt 　　　　　　 　　　　　　index1t = xt + Application.RoundUp(SQUARE_ONESIDE / 2, 0) 　　　　　　index2t = Application.RoundUp(SQUARE_ONESIDE / 2, 0) - yt '　　　　　　Debug.Print "[tx,ty]" & vbTab & index1 & " " & index2 & "→" & index1t & " " & index2t 　　　　　　If index1t >= LBound(arrayData, 1) _ 　　　　　　And index1t <= UBound(arrayData, 1) _ 　　　　　　And index2t >= LBound(arrayData, 2) _ 　　　　　　And index2t <= UBound(arrayData, 2) _ 　　　　　　Then '　　　　　　　　Debug.Print index1 & " " & index2 & "→" & index1t & " " & index2t 　　　　　　　　arrayData(index1t, index2t) = m_objOriginalData(index1, index2) 　　　　　　End If 　　　　Next 　　Next 　　 　　Call ExcelWrite(ThisWorkbook.Worksheets(SHEET_NAME).Range(ORIGIN_ADDRESS).Offset(CInt(-1 * SQUARE_ONESIDE / 2), CInt(-1 * SQUARE_ONESIDE / 2)), arrayData) End Sub Sub Calculate(ByVal x As Integer, ByVal y As Integer _ 　　　　, ByVal angle As Integer _ 　　　　, ByRef x1 As Integer, ByRef y1 As Integer) 　　x1 = x * Cos(Application.Radians(angle)) - y * Sin(Application.Radians(angle)) 　　y1 = x * Sin(Application.Radians(angle)) + y * Cos(Application.Radians(angle)) End Sub
こんにちは。 ＞間は常に１０行 という意味は、例えば10行目に「名前」があったとして、次の「主食」は20行目になるのでしょうか、それとも間に10行入れて21行目ということかな？ とりあえず、20行目となるものと仮定して作成してみました。 （21行目にするなら、最初のほうの定数rwDを11に変えればよいです） ※ 名前、果物、主食の順序は考慮していません 　　（該当するものがあれば、その前との間を10行にする） ※ 10行以上ある場合は、何もしません。 　　（空白行を探して、削除することも不可能ではありませんが） 以下、ご参考まで。 Sub Sample() 　Dim rw0 As Long, rw As Long, rwMax As Long 　Dim v As String 　Const rwD = 10 ' ←間隔とする行数 　rwMax = Cells(Rows.Count, 1).End(xlUp).Row 　rw0 = rwMax + rwD 　For rw = rwMax To 1 Step -1 　　v = Cells(rw, 1).Text 　　If v = "名前" Or v = "果物" Or v = "主食" Then 　　　If rw0 - rw < rwD Then 　　　　Cells(rw0, 1).Resize(rwD + rw - rw0, 1).EntireRow.Insert 　　　End If 　　　rw0 = rw 　　End If 　Next rw End Sub
”<Date" これがダメです。 Dateは関数（メソッド）ですのでダブルコーテーションでくくってはいけません。 回答1のように、Dateをダブルコーテーションの外に出して、&で繋げてください
多重起動って、オートメーションを２回行えばいいのではありませんか？ 　strURL ="http://www.xxxx.html" 　Set objIE = CreateObject("InternetExplorer.application") 　objIE.Visible = True '------以下を繰り返す----- 　objIE.Navigate2 strURL 　Do While objIE.Busy Or objIE.ReadyState <> 4: DoEvents: Loop 意味が違いますか？ IE は、多重化しやすいので、頭を悩ませます。そうすると機能が半減してしまうからです。 だから、私は、今、逆に、二重起動を避ける、つまり、今開いてる画面の横取りですが、半々の成功率です。なぜか分かりません。（^^; もしかしたら、FAQで、IEタブに入れる話と違いますか？
Sub 転記() Dim s As String Dim ss As String s = "スカイライン（GTR)" ss = "スカイライン" Worksheets("Sheet2").Range("A1").Value = "" If InStr(1, Worksheets("Sheet1").Range("A1").Value, ss) > 0 Then Worksheets("Sheet2").Range("A1").Value = ss Exit Sub End If If InStr(1, Worksheets("Sheet1").Range("A1").Value, s) > 0 Then Worksheets("Sheet2").Range("A1").Value = s End If End Sub こういう場合は、上記のように条件が整った時に「 Exit Sub 」で抜けるのが良いですよ。
こんにちは ご質問は2行のセンテンスで、3行目以降はそれを分解したものなのかな？ １語ずつ分解して理解しようとしても・・・と思いますのと、わからないことをある程度はご自身で調べられるようになることが重要と思いますので、まずは調べる方法のヒントを。 ご提示のものは、エクセルのVBAの断片だと想像しますが、VBAエディタで対象語にカーソルを置いてF1キーを押すとそれに関連したヘルプが表示できます。 内容的にはこれとほとんど変わりはありませんが、MSのサイトにもリファレンスがあります。 上記2箇所で意味を確認するのにはほぼ足りると思いますが・・・ VBAに関してして説明しているサイトも多くありますので、知りたい語を入れながら検索すれば数多くヒットすると思います。 こちらは補助的に利用するものとして、できるだけヘルプとＭＳＤＮ（ＭＳのドキュメントサイト）で調べるのが宜しいかと思います。 ・・・で、ご質問文に戻りますが、 ご質問文には記されていませんが、ご提示のセンテンスはWith Range文の中の一部を取り出したものと想像します。 Withで示されている範囲に対して、並べ替えをして、その後、式で算出しているセルに関しては値を空にしています。 おおまかな意味としては、 　1行目は並べ替えのメソッドの呼び出しとパラメータの設定（キーとなる行、並び替え順の指定、見出し行の有無など） 　2行目は式定義のセルの値の消去 といった感じです。 詳しくは以下で調べてみましょう。 ・Sortメソッド https://msdn.microsoft.com/ja-jp/library/office/ … ・昇降順の定数 https://msdn.microsoft.com/ja-jp/library/office/ … ・SpecialCellsメソッド https://msdn.microsoft.com/ja-jp/library/office/ … ・セルタイプの定数 https://msdn.microsoft.com/ja-jp/library/office/ …
折角こちらでヒントを頂いているのですから 少しはご自分で考えてほしかったですね。 http://oshiete.goo.ne.jp/qa/9270401.html 'ファイル名をA列にセット .Range("A" & n).Resize(n1).Value = Left(MyFnm, InStrRev(MyFnm, ".") - 1)
MyFnmって配列変数ですよね？であれば、MyFnm(n) に格納する時点で拡張子をカットすべきです。 拡張子をカットするには、 MyFnm(n) = Left(拡張子付きファイル名, InStrRev(拡張子付きファイル名, ".") - 1)
こんなのはいかがですか？ Sub 転記Macro() Dim 元行 As Long Dim 先行 As Long Dim 小計 As Long Dim 一致 As Boolean Sheets("Sheet2").Select Cells.ClearContents Sheets("Sheet1").Select Cells.Sort _ Key1:=Range("A2"), Order1:=xlAscending, _ Key2:=Range("B2"), Order2:=xlAscending, _ Key3:=Range("C2"), Order3:=xlAscending, _ Header:=xlYes, OrderCustom:=1, _ MatchCase:=False, Orientation:=xlTopToBottom, _ SortMethod:=xlPinYin 元行 = 2 Do While Cells(元行 - 1, 1).Value <> "" 一致 = False If Cells(元行, 1).Value = Cells(元行 - 1, 1).Value Then If Cells(元行, 2).Value = Cells(元行 - 1, 2).Value Then If Cells(元行, 3).Value = Cells(元行 - 1, 3).Value Then 一致 = True End If End If End If If 一致 Then 小計 = 小計 + Cells(元行, 4).Value Else 先行 = 先行 + 1 Sheets("Sheet2").Cells(先行, 1).Value = Cells(元行 - 1, 1).Value Sheets("Sheet2").Cells(先行, 2).Value = Cells(元行 - 1, 2).Value Sheets("Sheet2").Cells(先行, 3).Value = Cells(元行 - 1, 3).Value Sheets("Sheet2").Cells(先行, 4).Value = 小計 小計 = Cells(元行, 4).Value End If 元行 = 元行 + 1 Loop Sheets("Sheet2").Select Cells(1, 4).Value = "小計" End Sub
VS付属のセットアッププロジェクトの場合、 「カスタム動作」の追加で対応します。 https://www.google.co.jp/?gws_rd=ssl#q=msi+%E3%8 …
① シート１の１行目を「選択」「コピー」 ② シート２のＢ１セルを選択「形式を選択して貼り付ける」で「行列を入れ替える」にチェックを入れ実行 ③ シート１の２行目を「選択」「コピー」 ④ シート２のＡ１セルを選択「形式を選択して貼り付ける」で「行列を入れ替える」にチェックを入れ実行 ⑤ シート１の３行目以降を「選択」「コピー」 ⑥ シート２のＣ１セルを選択「形式を選択して貼り付ける」で「行列を入れ替える」にチェックを入れ実行 ⑦ シート２で１行目を選択してオートフィルターをかける。 ☆ 必要に応じてＡ１セルの右側の▼をクリックして「（オプション）」を選択し、条件をセットして「ＯＫ」ボタンを押す。
VlookUp の場合ですが、私は、以下のように書き換えればよいかと思いますが……VlookUpは、古くからある関数ですが、オブジェクト範囲を引数にして抱え込んでいますので、その分、重く、エラーも排出します。VlookUpそのものの範囲さえ分かりすさえすれば、そのまま、数式さえも、VBAで置き換えることは可能です。 　　　　On Errror Resume Next　'エラーを無視する 　　　　For i = 1 To Lastrow　'ここは、1からという意味で、数が定数なら、Lastrow よりも、To 356 のほうがよいでしょう。 　　　　　　.Range("A1").Value = i 　'//**変更** 　　　　　　.PrintOut 　　　　　　'.PrintPreview True　　'プレビューになります。 　　　　　　DoEvents 'Esc で離脱可能にする ''　　　　　　Sleep 300 '余裕を300ミリ秒を取る //これは辞めたほうがよいかも 　　　　Next i 　　　　On Errror Goto 0
>できましたー！ >ありがとうございます。 それはよかったです。今回は、まさかの、そのまさかでした。 やっと来ましたね。ほっとしています。 >一点だけ、添付ファイルが画像データとPDFの二種類あるのですが、PDFのみ抜き出しとかできますか？ 最後の行から遡って、'** でつけたように、If ～　End If で挟みます。 今は、pdf ファイルのみというスタイルになっています。 画像データとpdf 2つ以上がある時に、pdf ファイルのみという方法ですと、少し複雑になります。 Sub SaveEachItem() ・ ・ 　For Each att In AttachedItems 　　　　With att 　　　　　　If StrConv(.FileName, vbLowerCase) Like "*.pdf" Then　'** 　　　　　　.SaveAsFile strAttPath & "\" & .FileName 　　　　　　End If　　　　 '** 　　　　End With 　　Next 　　Beep EndLine: 　　Set objFS = Nothing 　　Set AttachedItems = Nothing End Sub
ユーザー名を指定しないと、なぜかDirで出て来ませんでした。 （少し調べれば、分かるかもしれませんが・・・） 以下で、起動しました。環境は、VB2008でやってみました。 テストしながらしてるので、注釈が入っております。 Dim strUserName As String = "UserName"'Windowsのユーザー名 Dim strPassText As String = "Password" 'パスワード Dim prss1 As New System.Diagnostics.Process Dim secStr As New System.Security.SecureString For Each c As Char In strPassText secStr.AppendChar(c) Next With prss1 With .StartInfo '出力を読み取れるようにする .UseShellExecute = False '.RedirectStandardOutput = True '.RedirectStandardInput = False 'ウィンドウを表示しないようにする .CreateNoWindow = False 'True:非表示 .UserName = strUserName .Password = secStr ''UACダイアログが親プログラムに対して表示されるようにする() '.ErrorDialog = True '.ErrorDialogParentHandle = Me.Handle '作業フォルダを指定する .WorkingDirectory = "C:\WINDOWS\System32" '.Verb = "runas" '管理者実行 .FileName = "cmd.exe" '.Arguments = """/K Dir C:\WINDOWS\System32\winsat*""" .Arguments = "/K WinSAT.exe formal -restart clean" End With .Start() '終了するまで待つ .WaitForExit() .Close() End With
エクセルVBAと云う事であれば、現在販売されている機種で 最低限のスペックPCでも大丈夫です。 メモリ, 容量を必要とするようなVBAを記述するなど、逆に至難の業です。 他の方がおっしゃるようOfficeがプリインストールされているPC 7～10万円程度ものが妥当かと思います。 Win7や８のOSで在庫処分の安い商品が並んだ時期もありましたが 今は、ちょっと難しいです。 中古で、Win　Xpなどはただ同然ですが、手を出してはいけません。
No.2です。 たびたびごめんなさい。 前回のコードの ＞Next c の下にある ＞MsgBox myCnt の1行は削除してください。 こちらで動きを確認するために余計なコードを入れていました。 どうも失礼しました。m(_ _)m
> =SERIESから始まる式をmsgBoxには表示できるのですが、msgBoxではなく > 結果をセルに書き出すにはどうすればよいのでしょうか。 以下で如何でしょう？ セルA20から下方向へ書き出す様にしています。 .Item(i).Formulaで取得した文字列のままだと上手くいかない様なので、左端の"="を削除しています。 ----------------- Dim i As Long Dim s As String Dim rng As Range: Set rng = ActiveSheet.Range("A20") Dim objChart As Chart Set objChart = ActiveSheet.ChartObjects(1).Chart With objChart.SeriesCollection 　　For i = 1 To .Count 　　　　MsgBox "系列" & i & "のソースデータ範囲は　⇒" _ 　　　　　　& vbCrLf & .Item(i).Formula 　　　　s = .Item(i).Formula 　　　　s = Right(s, Len(s) - 1) ' 左端の=を削除 　　　　rng.Value = s 　　　　Set rng = rng.Offset(1, 0) 　　Next i End With Set objChart = Nothing
以下で如何でしょう？ ThisWorkbook.Sheets("集計").Range("A" & lngRow).Value = .Sheets("Sheet1").Range("A1").Value
論理式全体をカッコで囲んでください。 Case (a < Range("G11") And a < Range("H12") And a < Range("I12") And a < Range("H10"))
コードの詳細をよく読んでいないのですが…… > Public Sub takePicture(ByRef objIe As Object) と引数objIeを必要とする定義にしているのに > Private Sub btnTakePicture_Click() > 　　call takePicture > End Sub 呼ぶ側で引数を与えていないのは変ですよね？ そもそもobjIeは、広域変数として宣言しているのでtakePictureの定義では引数は不要ではないでしょうか？
追伸です。 >Net Work Monitor とか、通信を監視するモニターで監視したいところですが。 これは良いのですが、 後継の　Microsoft Message Analyzer　も入れたら、IEがうまく開かなくなりましたので、たぶん、どちらか一つのようです。 このスレの質問とは直接関係のないことですけれどもね。 たぶん、当たらずとも遠からずです。
こんにちは。 うまい方法がありそうな気もしますが、そのまま愚直にやればこんな感じでしょうか？ Sub Sample() 　Dim rw As Long, rwMax As Long, r As Long 　rwMax = Cells(Rows.Count, 2).End(xlUp).Row 　For rw = 1 To rwMax 　　Cells(rw, 1).MergeArea.UnMerge 　Next rw 　rw = 1 　Do While rw < rwMax 　　r = 1 　　Do While Cells(rw, 2).Value = Cells(rw + r, 2).Value 　　　r = r + 1 　　Loop 　　If r > 1 Then 　　　Application.DisplayAlerts = False 　　　Cells(rw, 1).Resize(r, 1).Merge 　　　Application.DisplayAlerts = True 　　End If 　　rw = rw + r 　Loop End Sub
こんばんは。 マクロは良く書けているようでしたので、そのまま加筆するだけで利用させていただきました。これだけ書ける人なら、出来なくもないと思います。一応、コードは一度通しておりますが、細かい部分でバグがあるかもしれませんから、十分に検査してください。 '// Sub PDF保存() Dim fName As String Dim a As String, b As String a = Worksheets("元Sheet").Range("A1").Value & "" b = Worksheets("発注書").Range("B1").Value & "" If Len(a) > 0 And Len(b) > 0 Then 　　 fName = a & b 　　 If MsgBox(fName & ".pdf のファイル名でよろしいですか？", vbOKCancel) = vbCancel Then 　　　　　　Exit Sub 　　 Else '保存操作 　　 '保存ファイル名及び保存場所の設定 　　 fName = Application.GetSaveAsFilename(fName, "PDFファイル,*.pdf") 　　 Sheets("発注書").ExportAsFixedFormat Type:=xlTypePDF, Filename:=fName 　　 End If Else 　　 MsgBox "ファイル名の要素が不足しています。", vbCritical End If End Sub Private Sub CSV保存() Dim fn As String Dim a As String, b As String, c As String 　With ThisWorkbook 　a = .Worksheets("元Sheet").Range("A1").Value & ""　　'空の時も文字列にする 　b = .Worksheets("発注書").Range("B1").Value & "" 　c = .Worksheets("CSV用").Range("B1").Value & "" 　End With 'ファイル名を整える 'fn = Format(Now(), "yyyymmdd_hhmm") & "_ファイル.csv" 　If Len(a) > 0 And Len(b) > 0 And Len(c) > 0 Then 　　 fn = a & b & c 　　 If MsgBox(fn & ".csv のファイル名でよろしいですか？", vbOKCancel) = vbCancel Then 　　　　 Exit Sub 　　 Else 　　'保存先を選択させる 　　 fn = Application.GetSaveAsFilename(fn, "CSVファイル,*.csv", 1, "保存先の指定") 　　　　 If fn = "False" Or fn = "" Then Exit Sub 　　 End If 　Else 　　　　MsgBox "ファイル名の要素が不足しています。", vbCritical 　　　　Exit Sub 　End If 'キャンセルなら中止 　　'Sheet3をコピー 　　Worksheets("CSV用").Copy 　　'CSV形式で保存 　　With ActiveWorkbook 　　　　 .SaveAs Filename:=fn, FileFormat:=xlCSV 　　'保存せずに閉じる 　　　　 .Close SaveChanges:=False 　　End With End Sub
>>採番がされるのはデータコピー時のみにしたい 今は無条件にやってるので、callに位置を変更して下さい If st Is Nothing Then MsgBox ("選択されたブックにはSheet1がありません。") Else '選択されたブックのSheet1!A1:P45をこのブックに貼り付ける st.Range("A3:P45").Copy ThisWorkbook.Worksheets("★貼り付け").Range("A3") ●この位置にcall Auto_Openを移動して下さい。● End If
No.2です。 失礼しました、VBスレで書かれているので、VBでの連番の振り方ってことでしたね。てっきり関数で作られるかと勘違いしておりました。申し訳ない。 とはいえ、連番を作るということは出来るのですが、削除した場合の振り直しはちょっと厳しいかも知れません。とりあえず、連番を作成する場合の方法は、次のとおりです。 連番計算用のテンプレートシート(ここでは、シート名をtempにします)を作成し、A1列に次の式を入れます。 =MAX(Sheet1!A:A,Sheet2!A:A,Sheet3!A:A,Sheet4!A:A, ......... Sheet10!A:A) これで、現在の最大値が表示されます。 各シートのchangeイベントに、次の文字列を記載します。 if Target.Column =2 then 　　　　Cells(ActiveCell.Row-1,1) = Worksheets("temp").Range("A1").Value + 1 end if 上の例では、B列の値を変更した場合、A列にデータを入れるということになっています。また、入力確定後、下方向にセルが移動する設定になっていると仮定していますので、ActiveCell.Rowに-1をしています。このあたりは、環境によって変更してください。 連番の振り直しは、考えたのですが、振り直し用のマクロを組むのが一番早そうですね。 ただ、振り直しの順序をどの様にするのかを考えると、簡単に思いつかなかったです。
教唆はいけません。 『人にいろいろ暗示を与えて、悪事・犯罪などを犯すように仕向けること』ですから「教示」ですね。 さて、本題。 フォームにコマンドボタンを二個（名前をそれぞれ BtnStart と BtnReset にします） テキストボックスを一個（名前を TxtTime にします） フォームのモジュールに Option Compare Database Option Explicit '下記二行は宣言部 Private FormTime As Single Private PassedTime As Single Private Sub BtnReset_Click() 　　Me.TimerInterval = 0 　　FormTime = 0 　　PassedTime = 0 　　Me!TxtTime = 0 　　Me!BtnStart.Caption = "Start" End Sub Private Sub BtnStart_Click() 　　If Me.TimerInterval = 0 Then 　　　　FormTime = Timer - FormTime 　　　　Me!BtnStart.Caption = "Stop" 　　　　Me.TimerInterval = 100 　　Else 　　　　Me!BtnStart.Caption = "Start" 　　　　Me.TimerInterval = 0 　　　　FormTime = PassedTime 　　End If End Sub Private Sub Form_Timer() 　　Dim sMod As Long 　　PassedTime = Timer - FormTime 　　sMod = Int((PassedTime - Int(PassedTime)) * 100) 　　Me!TxtTime = CDate(PassedTime / 60 / 60 / 24) & Format(sMod, "\.00") 　　'Me.Repaint End Sub ※なお、Timer関数を使用している都合上、日付をまたがって使用していると誤表記されます。 投稿用にタブインデントの代わりに全角スペースを使用しています。 Access2010での動作確認です。
こんにちは！ Sub Sample1() Dim i As Long, k As Long, c As Range, myAry As Variant Range("E2:F2").ClearContents For i = 2 To Cells(Rows.Count, "A").End(xlUp).Row If InStr(Cells(i, "A"), ",") > 0 Then myAry = Split(Cells(i, "A"), ",") For k = 0 To UBound(myAry) Set c = Range("B:B").Find(what:=myAry(k), LookIn:=xlValues, lookat:=xlPart) If c Is Nothing Then With Range("F2") If .Value = "" Then .Value = myAry(k) Else .Value = .Value & "," & myAry(k) End If End With Else With Range("E2") If .Value = "" Then .Value = myAry(k) Else .Value = .Value & "," & myAry(k) End If End With End If Next k Else Set c = Range("B:B").Find(what:=Cells(i, "A"), LookIn:=xlValues, lookat:=xlPart) If c Is Nothing Then With Range("F2") If .Value = "" Then .Value = Cells(i, "A") Else .Value = .Value & "," & Cells(i, "A") End If End With Else With Range("E2") If .Value = "" Then .Value = Cells(i, "A") Else .Value = .Value & "," & Cells(i, "A") End If End With End If End If Next i End Sub こんな感じではどうでしょうか？m(_ _)m
こんにちは。 私は、行列で、この問題を解いてみました。その行列式を考えつくまでに、数日を掛かってしまいましたが、まだ開いているようなので、一応、アップロードさせていただきます。 後出しのアップロードのつもりはないのですが、オブジェクトも使わないで、配列も使わずに、行列だけで作るというのは、久々に頭を使いました。単純な仕組みほど、力を試されるものかもしれませんね。 この2行4列、1空行のブロックがなければ、本当は簡単だと思います。 3-4, 6-7, 9-10, 12-13, 15-16,.... なぜ、こんなブロックを作ったのだろうか、と恨み言一言言いたくなりましたね。（^^; たぶん、質問の元のコードの延長的な考え方に近いと思っています。 iRow(以下では j) は、書き込み用には使えないという所が、難しいところです。なお、変数は、思いつきなので、統一性がありません。 IsNumericで数値を拾うという意味だけで、すべて値のない部分によって改行が加わります。9個以上の連番の場合は、1行開けて次のブロックに入ります。画面がちらつくようなら、ScreenUpdating =False を入れてください。 '// Sub 並び替え2() 　　Dim j As Long　'カウンタ変数 　　Dim i As Long　'列数 　　Dim m As Long　'相対的な行数 　　Const t As Long = 3 '初期の行数位置 　　j = 1 　　m = 0 '　　Range("F1:I100").ClearContents　'値を消す 　　Do 　　　　If Cells(j, "A").Value <> "" Then 　　　　　　If IsNumeric(Cells(j, "A").Value) Then 　　　　　　　　Cells(t + m - 1, "F").Offset(, i).Value = Cells(j, "B").Value 　　　　　　　　If (i + 1) Mod 4 <> 0 Then 　　　　　　　　　　i = i + 1 　　　　　　　　Else 　　　　　　　　　　i = 0 　　　　　　　　　　m = m + 1 　　　　　　　　End If 　　　　　　　　flg = True 　　　　　　End If 　　　　ElseIf flg Then　'連続の値が途切れた時は、間を開ける 　　　　　　　　m = Int(m / 4) * 3 + 4: i = 0 　　　　　　　　flg = False 　　　　End If 　　　　'通常は、1行ずつだけど、次が、3で割れたら、1行開ける 　　　　If (m Mod 3) = 0 Then m = m + 1 　　　　j = j + 1 　　Loop Until Cells(j, "B").Value = "" End Sub '//
年賀状作成ソフトの「筆まめ」を購入して、カード(住所録)に氏名、 住所他を入力し、宛名面にて「タック紙(シールラベル)」を選択して 必要枚数を指定しますと、「シールラベル」が印刷できます。 単に会員に郵送物を送付するために「ラベル」を印刷するのであれば 「筆まめ」を利用するとプログラムを作らずに、容易にできますので 良いと思います。 また、会員の名簿なども簡単に表示、印刷できます。
こんにちは 表題のように『B4に入力すると～～』であれば、関数でも可能です。 （値があれば上のセルと同じ値、値が無ければ無し） C4セルに 　=IF($B4="","",C3) を入れて、必要な範囲（右、下）へフィルコピー 本文のように『Bがアクティブになると～～』の場合は、ユーザーの操作を監視することになりますので、関数では無理でVBAでしかできませんね。 シートモジュールに Private Sub Worksheet_SelectionChange(ByVal Target As Range) 　Dim r As Range 　Set r = Intersect(Target, Columns(2)) 　If (r Is Nothing) Then Exit Sub 　If (r.Row < 2) Then Exit Sub 　Set r = r.Cells(1, 1).Offset(0, 1).Resize(1, 4) 　r.Value = r.Offset(-1, 0).Value End Sub という感じでしょうか？ ご質問の言葉通り、『選択した時に直上の値をコピペする』だけなので、関数で定義した場合とは異なり、後で上のセルの値が変わったりしても連動するようなことはありません。 ＞Cがアクティブになると一つ上をコピーしてスクロールバー1〜15 ＞まで選べて数字の数だけ下にペーストしたいと思っています については、何をなさりたいのかよくわからないので、回答ができません。 他の方の回答を待つか、ご自身で研究なさってみてください。
解決されてましたらスルーください > 0と「量」が入っている行の削除 これは図から、D 列の金額が空白なら･･･と置換え可能ですか？ 置換え可能ということで、元の表が A1 からあり、 そのシートにはその表以外ないという前提で、 以下を標準モジュールに記述して、 アクティブシートを対象に処理させてみて、 雰囲気でどうなりますか やっていることは 現在使用中の領域右外側１列を作業用に使用して D 列が空白なら 1 を設定する式を埋め込み、 式 → 値 に変更して 1 の所の行をバッサリ削除して ' ★位置　（ここまでが、できていたという別のやり方） 削除後の A1 の CurrentRegion の行数を入手し 全体 20 行から、その行数を引いて、> 0 なら 最終行部分で、足りない行数分挿入して C 列両側の罫線が伸びてこないので、挿入した範囲で罫線引いて ループするところはないので、ステップ実行してみてください ※ > 「0」と「量」は他のシートからリンクしているので 式を埋め込んだ状態では確認していないので、 おかしかったらごめんなさい Public Sub Samp1() 　　Dim i As Long, j As Long 　　Const CF As String = "=IF(RC[{%1}]="""",1,"""")" 　　Application.ScreenUpdating = False 　　With ActiveSheet 　　　　With .UsedRange 　　　　　　With .Columns(.Columns.Count).Offset(, 1) 　　　　　　　　.FormulaR1C1 = Replace(CF, "{%1}", 4 - .Column) 　　　　　　　　.Value = .Value 　　　　　　　　On Error Resume Next 　　　　　　　　.SpecialCells(xlCellTypeConstants).EntireRow.Delete 　　　　　　　　On Error GoTo 0 　　　　　　End With 　　　　End With ' ★ 　　　　j = .Range("A1").CurrentRegion.Rows.Count 　　　　i = 20 - j 　　　　If (i > 0) Then 　　　　　　.Rows(j).Resize(i).Insert 　　　　　　With Cells(j, "C").Resize(i) 　　　　　　　　.Borders(xlEdgeLeft).LineStyle = xlContinuous 　　　　　　　　.Borders(xlEdgeRight).LineStyle = xlContinuous 　　　　　　End With 　　　　End If 　　End With 　　Application.ScreenUpdating = True End Sub
下からダウンロードして見て。 こんな感じかな。 http://www.tfumi01.com/test/test1.html
#1,#2で書いた者です。 お返事が付かないようですが、#2の考え方というのは、 保存できないものは、回避して、名前だけ記録していこうという趣旨です。 それで、そのファイルの原因が分かったら、それに対応する処置を取ったらどうかという考え方です。全部がダメなら、そこは保存できない場所っていうことになりますが。 主な原因は、ロードとセーブ(SaveAs)でのファイル名の取り扱いに違いがあるということです。
こんにちは。 >時系列データを取込んでいたのですが ということは、 日足　前場後場　1時間足　30分足　15分足　5分足 この6つということですか？ 本来は、ご質問にあるように、Webクエリに近いスタイルで作るべきでしたが、今は、どこのサイトでも、スクレイピングが嫌われるよううなので、そのサイトの、CSVダウンロードのポートを利用してみました。 このマクロは、6種類をダウンロードしてくるのと、それを「新規のブック」にインポートします。今回は、個人的に新しい試みです。 >ＩＥを制御して取込む方法を試してみましたが、 まずかったら、そちらのスタイルに戻すつもりでいます。かなり、鈍速になるはずです。 他にも、DOMでインポートする方法があります。以下のマクロは、最終的な書式処理が抜けております。その点はお詫びいたします。 なお、これは、私の個人的・継続的にVBAマクロの練習をしているので、教えているのではなく、ご質問を利用させていただいているのです。 参考サイト： http://www.ka-net.org/blog/?p=4855 '//'標準モジュールに貼り付けてください。 Private Declare Function DeleteUrlCacheEntry Lib "wininet" Alias "DeleteUrlCacheEntryW" (ByVal lpszUrlName As Long) As Long Private Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileW" (ByVal pCaller As Long, ByVal szURL As Long, ByVal szFileName As Long, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long Private Filename As String Private NewBook As Workbook Private ShCount As Long Private Er As Long Sub DownLoadFiles() 　　Dim Ret As Long 　　Dim mPath As String: mPath = ThisWorkbook.Path & "\" 　　Dim Filename As String 　　Dim buf As Variant 　　Dim BaseUrl As String 　　Dim Url As String 　　Dim Urls As Variant, sAdd As Variant 　　Dim SaveFilePath As String 　　 　　'***************** 　　'目的のURL を入れてください。 　　BaseUrl = "http://k-db.com/stocks/1458-T/" 　　Urls = Array("", "4h", "1h", "30m", "15m", "5m") 'ダウンロード項目 　　'***************** 　　 　　If NewBook Is Nothing Then 　　　　Set NewBook = Workbooks.Add 'ブックを作る 　　End If 　　 　　buf = Split(BaseUrl, "/") 　　If InStr(1, BaseUrl, "k-db.com/stocks", 1) = 0 Then 'Urlをチェック 　　　　MsgBox "URLは、【株式データサイト】に限ります。", vbExclamation 　　　　Exit Sub 　　End If 　　buf = buf(3) & "_" & buf(4) 'ダウンロード名を生成 　　 　　For Each sAdd In Urls 　　　　If Len(sAdd) > 0 Then 　　　　　　SaveFilePath = mPath & buf & "_" & sAdd & ".csv" 　　　　Else 　　　　　　SaveFilePath = mPath & buf & sAdd & ".csv" 　　　　End If 　　　　 　　　　Url = BaseUrl & sAdd & "?download=csv" 　　　　''MsgBox Url 'URLチェック用 　　　　Ret = DownloadFile(Url, SaveFilePath) 　　　　If Ret <> 0 Then 　　　　　　MsgBox "取得に失敗しました。", vbExclamation 　　　　Else 　　　　　　If Dir(SaveFilePath) <> "" Then 　　　　　　　　ImportFiles SaveFilePath 　　　　　　Else 　　　　　　　　MsgBox "ダウンロードに失敗しました", vbCritical 　　　　　　　　Er = Er + 1 　　　　　　End If 　　　　End If 　　Next sAdd 　　If Err = 0 Then 　　　　MsgBox "正常に終了しました。", vbInformation 　　End If End Sub Private Function DownloadFile(ByVal Url As String, ByVal SaveFilePath As String) Dim Ret As Long 　　DeleteUrlCacheEntry StrPtr(Url) 'キャッシュクリア 　　Ret = URLDownloadToFile(0, StrPtr(Url), StrPtr(SaveFilePath), 0, 0) 　　DownloadFile = Ret End Function Sub ImportFiles(ByVal FilePath As String) 　　　　Dim Fname As String 　　　　Dim FNo As Integer 　　　　Dim TextLine As String 　　　　Dim i As Long 　　　　Dim Ar As Variant 　　　　ShCount = ShCount + 1 　　　　With NewBook 　　　　　　If ShCount > .Worksheets.Count Then 　　　　　　.Worksheets.Add After:=.Sheets(.Sheets.Count) 　　　　　　Else 　　　　　　 .Worksheets(ShCount).Activate 　　　　　　End If 　　　　End With 　　　　ActiveSheet.Name = _ 　　　　Replace(Mid$(FilePath, InStrRev(FilePath, "\") + 1), ".csv", "", , , vbTextCompare) 　　　　i = 1 　　　　Fname = FilePath 　　　　FNo = FreeFile() 　　　　Open Fname For Input As #FNo 　　　　Do While Not EOF(FNo) 　　　　　　Line Input #FNo, TextLine 　　　　　　Ar = Split(TextLine, ",") 　　　　　　Cells(i, 1).Resize(, UBound(Ar) + 1).Value = Ar 　　　　　　i = i + 1 　　　　Loop 　　　　Close #FNo End Sub
こんにちは。 正直な話、もうCDOを使ったのは古い昔の話なので、このエラーの要因というのは、コードそのものよりも、固有の設定に問題があるように思います。 自分で作ってみました。 ご質問のコードを元に、googleを使って自分自身用に作ってみました。 以下のコードで送られることは確認しましたが、ここ最近、Google は、メールの設定が異様に厳しくなりましたので、Google自体のメール・セキュリテイの設定を下げないとGoogleからは送信されませんが、コード自体は問題なさそうです。 >「転送においてサーバーに接続できませんでした」 このエラーメッセージは、Configuration のミスで発生しました。正しく直したら、通りました。 細かい問題は、相手のメールサーバーとの関係ですから、設定を細かく見ていくしかないと思います。 '// Const myAddress As String ="********" Const myPSW As String = "********" Public Sub SendMail2() Dim objCDOMsg As CDO.Message ' New CDO.Message '/* CDOメッセージオブジェクト */do. Set objCDOMsg = New CDO.Message '// Dim objCDOMsg As Object '/* CDOメッセージオブジェクト */ '// Set objCDOMsg = CreateObject("CDO.Message") On Error GoTo ErrHandler With objCDOMsg 　　' /* メールサーバ設定 */ 　　With .Configuration.Fields 　　　　.Item(CdoConfiguration.cdoSendUserName) = myAddress　'/*ユーザー名*/ 　　　　.Item(CdoConfiguration.cdoSendPassword) = myPSW　　'/*パスワード*/ 　　　　.Item(CdoConfiguration.cdoSendUsingMethod) = CdoSendUsing.cdoSendUsingPort '/* 外部SMTP指定 */ 　　　　.Item(CdoConfiguration.cdoSMTPConnectionTimeout) = 100 '/* タイムアウト */ 　　　　.Item(CdoConfiguration.cdoSMTPServer) = "smtp.gmail.com" ' /* SMTPサーバ名 */ 　　　　.Item(CdoConfiguration.cdoSMTPServerPort) = 465 '/* ポート№ */ 　　　　.Item(CdoConfiguration.cdoSMTPAuthenticate) = cdoBasic 　　　　.Item(CdoConfiguration.cdoSMTPUseSSL) = True 　　　　.Item(CdoConfiguration.cdoLanguageCode) = CdoCharset.cdoShift_JIS '/* 文字セット */ 　　　　.Update 　　End With 　　 　　' /* メール編集 */ 　　.To = "xxxxxx@yyyyy.co.jp" '/* 宛先 */ 　　.From = "******@gmail.com" '/* 送信者 */ 　　.Subject = "Test mail" '/* 件名 */ 　　.TextBody = "MainMessage" & vbNewLine & Date & " " & Time & vbNewLine & _ 　　 "This is TesMail" '/* メール本文 */ 　　'.AddAttachment ThisWorkbook.Path & "\myTest.Txt" ' "C:\Users\term\Desktop\TempFile.txt" '/* 添付ファイル */ 　　' /* メール送信 */ 　　.Send '<------------------- このコードをステップ実行後にエラーメッセージ表示 End With ErrHandler: If Err.Number <> 0 Then 　　 MsgBox Err.Number & " :" & Err.Description 　　 'Debug.Print Err.Number & " :" & Err.Description End If ' /* オブジェクト変数解放 */ Set objCDOMsg = Nothing End Sub
以前、この「教えて！goo」で回答用に作成したものです（回答を投稿する前に締め切られてしまいましたが…）。 ちょっと冗長的なコーディングですが、シンプルなロジックにしたつもりです。 関数で実装しています。引数は開始時刻St、終了時刻Etで、戻り値が深夜勤務時間です。 深夜時間として、当日0:00～5:00、当日22:00～翌日5:00、さらに、翌日22:00～24:00（翌々日0:00）の時間を合計しています。 Function Midnight(St As Variant, Et As Variant) As Variant Dim MidStart As Variant Dim MidEnd As Variant '当日0:00～5:00の勤務時間を求め、加算する。 MidStart = TimeValue("00:00:00") MidEnd = TimeValue("05:00:00") If Not (St >= MidEnd Or Et <= MidStart) Then If MidStart < St Then MidStart = St If MidEnd > Et Then MidEnd = Et Midnight = Midnight + MidEnd - MidStart End If '当日22:00～翌日5:00の勤務時間を求め、加算する。 MidStart = TimeValue("22:00:00") MidEnd = 1 + TimeValue("05:00:00") If Not (St >= MidEnd Or Et <= MidStart) Then If MidStart < St Then MidStart = St If MidEnd > Et Then MidEnd = Et Midnight = Midnight + MidEnd - MidStart End If '翌日22:00～同24:00（翌々日0:00）の勤務時間を求め、加算する。 MidStart = 1 + TimeValue("22:00:00") MidEnd = 2 + TimeValue("00:00:00") If Not (St >= MidEnd Or Et <= MidStart) Then If MidStart < St Then MidStart = St If MidEnd > Et Then MidEnd = Et Midnight = Midnight + MidEnd - MidStart End If End Function
お付き合いついでと云う事で 次ステップですが 毎月のデータがフィルダーごとに残るデータ保存の方法を考えましょう。 永遠にファイルとフォルダーが増えて、過去の検索も大変になるでしょう。 毎月のデータを保存するフォルダーを一つ データを取込後に、年と月の情報を入れる列を作る。 常に一枚のシートでデータを管理する。 こうすることで、一年の入金金額なども簡単に集計できますよね。 月ごとのグラフも作成できるでしょう。 頑張ってみてください。
こんにちは。 ふつう、セルに数式を入れるというのは、別の方法だと思いますが、 Dim arr(1 To 1, 1 To 2) As Variant　'２次元 Dim frml1 As String Dim frml2 As String frml1 = "=A1+B1" frml2 = "=A3+B5" arr(1, 1) = frml1 arr(1, 2) = frml2 Range("A10", "B10").Value = arr 特に問題はありませんね。 >"=A1+B1"のように文字列が表示されます。 これは、別の要因（書式）のようですね。 その場合は、このようにすればよいはずです。 Range("A10", "B10").ClearFormats Range("A10", "B10").Value = arr　'書式をきれいにしてから入れればよいはずです。
こんにちは。 ご質問のコードを何度か書き換えながら試してみました、早い話、.Body.InnerText　で、ゴミを拾ってくるだけでした。 >エラーの内容は、プロシージャの呼び出し、または引数不正です。 このエラーは、バッファの容量を越えてしまっているわけです。 サーバーによって例外が返されました。(HRESULTからの例外：0x80010105(RPC_E_SERVERFAULT)) となるわけですが、VBSの範囲ですと、テキストバッファの容量が少ないので、あれこれしてみましたが、そのものを取り扱うことは無理だと分かりました。 こんなテクニックができればよいのですが、 i = InStr(1, strBdytxt, "Amazon ") buf = Mid(strBdytxt, i, 20000) InStrでも同じ現象が置きてしまいます。このまま、生のVBSでは無理なのではないかと思います。VBSで何か別のオブジェクトやラッパーなどを使えば別だと思います。どうやっても、そのままでは解決付きそうにはありません。 それと、余計なことですが、Amazon は、確か、スクレイピングを嫌っていましたよね。これ一つのページで、どういじろうが問題はないと思うのですが、Amazon側では、APIを使えというわけです。とはいえ、ちょっとAPIは敷居が高いわけです。私自身、Amazon APIには手を出したことがありません。 内容はくどくなりますから、書きませんが、下記に書かれています。 ・利用許可およびサイトへのアクセス http://www.amazon.co.jp/gp/help/customer/display …
こんにちは！ 一例です。 元データは↓の画像のような配置でSheet1にあるとし、Sheet2に表示させるとします。 標準モジュールにしてください。 Sub Sample1() Dim i As Long, c As Range, r As Range, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") Set c = wS.Rows(1).Find(what:=.Range("B1").Text, LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then For i = 3 To .Cells(Rows.Count, "A").End(xlUp).Row Set r = wS.Range("A:A").Find(what:=.Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not r Is Nothing Then wS.Cells(r.Row + 1, c.Column) = .Cells(i, "B") End If Next i End If End With End Sub こんな感じではどうでしょうか？m(_ _)m
.Copyを使ってるので、普通にマウスでエクセル全列を３行丸丸コピーするのと同じ操作です。 一旦クリップボードに格納され、「貼り付け」で、そこから貼り付けられます。 仕方無い事ですが、VBA処理の中で、前後でクリップボードをクリアしたら良いかと思います。 Application.CutCopyMode = False を処理に入る前と、最後に入れたら良いかと思います。
こんにちは。 具体的な手順がよくわからないところがありますが、以下のようなものが参考になりませんか？ （検索すればもっといろいろと見つかると思います） http://language-and-engineering.hatenablog.jp/en … http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub0 … http://excel-ubara.com/excelvba5/EXCELVBA232.html
以下でどうでしょう？ If Not wSheet.name Like "*予定*" Then
http://m.chiebukuro.yahoo.co.jp/detail/q11158142 … http://m.chiebukuro.yahoo.co.jp/detail/q11158095 … もう１つあって回答も付いてた筈だけど、削除したの？
既に的確な回答が最初に示されていると思いますが… Call RefSample( num * 2 ) こういった式を渡せないと不便だからだと思いますね。 機械語コード的には Dim temp = num * 2 Call RefSample( temp ) こんな展開になるはずで、参照渡しは変わらないはず。
こういう帰納法（多くある現象から集約する）形式では、かなり難しいものがあります。 あまり、こういうことは決まった内容ではないのですが、ご本人の作ったコードでないとついありがちな問題のひとつとして、例えば、私の場合、省メモリで、オブジェクトの設定のオーバーヘッド（Set の設定の時の時間的ロス）を減らすために、グローバル変数にしてしまうのです。 例： 'Module1 Public objWShell As Object　　 '① Sub objSetting() '② 　Set objWShell = CreateObject("WScript.Shell") '③ End Sub '④ 'Module2 Sub Test1() 　　Dim mPath As String 　　mPath = objWShell.SpecialFolders.Item(16)　　'16=Documents 　　MsgBox mPath End Sub こういう場合、コードが正しくても、②を忘れたり、①が落ちていたりすると、そのエラーが出ます。④は、どこか分からないけれども、内在的なエラーを持っている場合、そして何よりも③でオブジェクトが作れない時。 そのエラーが出ます。 この③が問題です。何が原因なのか、ウィルスなのか、取れていないこともあります。また、場合によっては、参照設定で基本になる、Visual Basic, Microsoft Excel, OLE Automation のどれかが落ちていることがあります。人からファイルをもらい受けた時に、発生することがあります。 Office Tanakのは、ほとんどプログラミング・ミスに限ります。 http://officetanaka.net/excel/vba/error/executio …
Windows10も7と同様でした（Pro Build 10568）。 VBAから時刻の同期は面倒くさいと思います。 Adminユーザーであっても『管理者として実行』しないとUAC？で阻まれます。 以下、MsAccess.exe を『管理者として実行』した場合に成功しましたが・・・。 Dim Ret As Double Ret = Shell("sc start w32time"): Debug.Print "1", Ret Ret = Shell("w32tm /resync"): Debug.Print "2", Ret 参考にしたところ http://www.atmarkit.co.jp/ait/articles/1207/12/n …
スタートアップからの常駐であれば　自分はccleanerを使っている。
雰囲気以下でどうなりますか 提示あった myList 内容では、「果物」等との関連付けができてないので変更 Samp1 では、静岡、静岡 Samp2 では、静岡 なお、どちらともカテゴリを求める時には、「りんご」「リンゴ」は同じと解釈 Samp1 では、「りんご」「リンゴ」は別表示 Samp2 では、同じものとして先に出現した文字列で 結果は 果物 = りんご、いちご、バナナ、リンゴ 県名 = 静岡、静岡 果物 = りんご、いちご、バナナ 県名 = 静岡 Sub Test() 　　Dim myList, Recipe 　　myList = Array( _ 　　　　Array("果物", Array("メロン", "りんご", "バナナ", "ナシ", "いちご")), _ 　　　　Array("県名", Array("神奈川", "東京", "静岡", "千葉", "埼玉")), _ 　　　　Array("月名", Array("1月", "2月", "3月", "4月", "5月")) _ 　　) 　　Recipe = Array("りんご", "静岡", "いちご", "バナナ", "リンゴ", "静岡") 　　Call Samp1(myList, Recipe) 　　Call Samp2(myList, Recipe) End Sub Public Sub Samp1(myList As Variant, Recipe As Variant) 　　Dim dic As Object, dicL As Object 　　Dim vK As Variant, v As Variant 　　Dim i As Long 　　Set dic = CreateObject("Scripting.Dictionary") 　　Set dicL = CreateObject("Scripting.Dictionary") 　　dicL.CompareMode = vbTextCompare 　　For Each vK In myList 　　　　For Each v In vK(1) 　　　　　　dicL(v) = vK(0) 　　　　Next 　　Next 　　For Each v In Recipe 　　　　vK = dicL(v) 　　　　If (IsEmpty(vK)) Then vK = "他" 　　　　If (Not dic.Exists(vK)) Then 　　　　　　dic.Add vK, CreateObject("Scripting.Dictionary") 　　　　End If 　　　　i = dic(vK).Count 　　　　dic(vK)(i) = v 　　Next 　　For Each vK In dic.Keys 　　　　Debug.Print vK & " = " & Join(dic(vK).Items, "、") 　　Next 　　Set dic = Nothing 　　Set dicL = Nothing End Sub Public Sub Samp2(myList As Variant, Recipe As Variant) 　　Dim dic As Object, dicL As Object 　　Dim vK As Variant, v As Variant 　　Set dic = CreateObject("Scripting.Dictionary") 　　Set dicL = CreateObject("Scripting.Dictionary") 　　dicL.CompareMode = vbTextCompare 　　For Each vK In myList 　　　　For Each v In vK(1) 　　　　　　dicL(v) = vK(0) 　　　　Next 　　Next 　　For Each v In Recipe 　　　　vK = dicL(v) 　　　　If (IsEmpty(vK)) Then vK = "他" 　　　　If (Not dic.Exists(vK)) Then 　　　　　　dic.Add vK, CreateObject("Scripting.Dictionary") 　　　　　　dic(vK).CompareMode = vbTextCompare 　　　　End If 　　　　dic(vK)(v) = Empty 　　Next 　　For Each vK In dic.Keys 　　　　Debug.Print vK & " = " & Join(dic(vK).Keys, "、") 　　Next 　　Set dic = Nothing 　　Set dicL = Nothing End Sub
下の通り 但し、CSVの格納場所は修正して下さい C:\Users\user\Desktop\の部分 Sub WK() Dim ファイル名 As String 'Sheet1のA1の内容を読む変数 Application.DisplayAlerts = False ファイル名 = Sheets("Sheet1").Range("A1").Value 'CSVファイル名を取り込む Sheets("Sheet2").Copy ActiveWorkbook.SaveAs Filename:="C:\Users\user\Desktop\" & ファイル名 & ".csv", _ FileFormat:=xlCSV ActiveWindow.Close Application.DisplayAlerts = True E4: Application.StatusBar = False End Sub
一瞬、昔、私の書いたコードかと思いました。（^^; もしかしたら、それをお読みになったのかもしれませんが、どうやら意味が違いますね。 >いろいろ調べてリンク貼の解除を見様見真似でやったんですが >今度は写真台帳のfile自体が重くなってしまいました。 リンクの解除をすると、今度は、Excel自体に、BMPに準拠したメタファイルとして残ります。だから大きくなるのですが、 ここのサイトで実験されていますが、 http://0019062.cocolog-nifty.com/mememomo/2009/0 … >■４．実際にやってみる 要するに、マクロで、サイズを小さくしても変わらないということです。 多少、画像は荒くなるかもしれませんが、手動の「画像の圧縮」でやるしかないようです。 [この画像だけに適用する]のチェックを外したら、全体に及ぶはずです。これを呼び出すマクロは、今のところ見つかりませんでした。
私も #1 の意見に一票。 VBA 用に用意されているソート機能を使うなら命令一発。この場合 VBA 側から見れば 1つの命令を発行し、完了を待つだけなので途中経過を知ることはできない。 0% の次は 100% となってしまう。 プログレスバーに進捗を表示するためのソート処理を書くとなると、進捗を表示する部分よりも 「進捗具合を測れる独自のソート ロジック」 を実装する部分のほうがエネルギーを使いそう。
詳しく見ていないけど、このあたり参考になる可能性があるかな？？？ https://sim0n.wordpress.com/2009/03/28/vbnet-key …
>>計算に使うセルが変更された時「だけ」再計算される 関数とは、そういうものですよ ・A50の値を変更した時　⇒　再計算されない ・A11の値を変更した時にB1は　⇒　再計算されない ・隣のシートのA1を変更した時　⇒　再計算されない 保留しなくても良いですね。
単純に置換なら以下のコードで実装可能 ただし、エラー処理などは一切しておりません。 VBS勉強中とのことなので、各々の関数の使い方や意味については、ご自身で学習してください。 どれも基礎レベルの内容です。 '------Sample.vbs--------- 'Sample.txtファイル内の"t"の文字を""へ置き換え、置き換えたファイルをSample2.txtとして出力 '作成したVBSファイルと読み込み用ファイルは同一フォルダ内に配置する必要がある Dim objFSO 'ファイルシステムオブジェクト Dim Readtxt , Writetxt '読み込み用ファイル、書き込み用ファイル Set objFSO = CreateObject("Scripting.FilesystemObject") Set Readtxt = objFSO.OpenTextFile( objFSO.GetParentFolderName( Wscript.ScriptFullName ) & "\Sample.txt" , 1 ) Set Writetxt = objFSO. OpenTextFile ( objFSO.GetParentFolderName( Wscript.ScriptFullName ) & "\Sample2.txt" , 2 ,True ) Do until Readtxt.AtEndOfStream Writetxt.Writeline Replace(Readtxt.Readline,"t","") Loop Set objFSO = Nothing Readtxt.Close Writetxt.Close
>>後から、入力しても、連動して変わるように・・・ セル入力都度マクロを実行しても良いのですが、動き回るので、Excelブックを閉じる時にも実行させてしまうのが最善だと思います。 Objects内の「ThisWorkbook」に以下を記述します。 Private Sub Workbook_BeforeClose(Cancel As Boolean) '今の処理をここへも記述 End Sub
もう、私は、あまりVBAマクロは分からないけれども、少し、読んで試してみました。 今、Excel 2013をインストールしてないPCだから、新しいメソッドは分かりませんし、知りませんが、とにかく、Excel 2010 で考えてみました。 Private Sub Workbook_BeforeClose(Cancel As Boolean) rc = Application.Run("BOOK1.xlsm!終了処理") If rc = True Then Cancel = True これでは、Close メソッドは利きません。Cacel =True は、「閉じる命令を止めます」という意味ですから。 Application.Quit　では、マクロは、止めるようになっていませんから、動くでしょうね。 >バックアップをとるために新しいブックを作成してデータをコピーしたい として、新しいブックを作成するというのは、 Workbooks.Add.SaveAs ということでしょうけれど、2013以降で、分からないから、旧式の書き方で恐縮ですが、考えてみました。 '// 'ThisWorkbook モジュール Private Sub Workbook_BeforeClose(Cancel As Boolean) 　　Dim fn As String 　　Dim mPath As String 　　On Error GoTo ErrHandler 　　'バックアップファイルは、孫を作らない 　　If InStr(1, ThisWorkbook.Name, "bk.", vbTextCompare) > 1 Then Exit Sub 　　With CreateObject("Scripting.FilesystemObject") 　　　　fn = .GetBaseName(ThisWorkbook.Name) & "bk"　　'ベース名から、BackUp名を作る 　　End With 　　mPath = ThisWorkbook.Path & "\"　　'別フォルダのほうがよい 　　Cancel = True '命令を阻止 　　Application.EnableEvents = False 　　Application.DisplayAlerts = False 　　With ThisWorkbook 　　　　.Save　'* 　　　　.SaveAs mPath & fn, xlOpenXMLWorkbookMacroEnabled '* 　　　　ActiveWorkbook.Close False　'ここは、必ず　False です。 　　　　.Close False 　　End With 　　Application.DisplayAlerts = True 　　Application.EnableEvents = True 　　Exit Sub ErrHandler: 　　MsgBox Err.Number & " :" & Err.Description End Sub '標準モジュールに念のためですが、 Sub Auto_Open() 　Application.EnableEvents = True End Sub '//--- *の部分が、新しいメソッドで統合できると思います。
回答が付かないようなので、とりあえず･･･です。 シートの内容（A2:E4)をリストに表示し、そこで選択された行の内容をラベル？（A列･･･E列と表示されているところ）に表示するVBAを書いてみました。参考になりますかね？ もしかしたら、検索結果のみをリストに表示したいのでしょうか？ 正直なところ、やりたいことがよくわからないので、適切な回答になっていないと思います。必要出れば追加で質問することをお勧めします。 以下、サンプルです。コードはユーザフォームの下に張り付けて下さい。 リストボックス名「ListBox1」 ラベル名「LabelA,LabelB,LabelC,LabelE」 Private Sub ListBox1_Click() LabelA.Caption = ListBox1.List(ListBox1.ListIndex, 0) LabelB.Caption = ListBox1.List(ListBox1.ListIndex, 1) LabelC.Caption = ListBox1.List(ListBox1.ListIndex, 2) LabelE.Caption = ListBox1.List(ListBox1.ListIndex, 4) End Sub Private Sub UserForm_Initialize() ListBox1.ColumnCount = 5 ListBox1.RowSource = "Sheet1!A2:E4" ListBox1.ListIndex = 0 End Sub
For...Nextの間でB列に日付を設定しているようですが、これは意図したものではないのですか？ コードを見ただけでは何がしたいのか不明です。（特にFor...Nextの間） 仕様の説明をお願いします。
以下でどうでしょう？ Columns("AO") = Application.Round(Columns("AO"), 0) ↓ Cells(i, "AO").Value = WorksheetFunction.Round(Cells(i, "AO"), 0)
残念ですが、今の情報を、丹念に追って見ていきましたが、私には、少なくともマクロの修正は不可能だと思います。分からない所がありすぎます。私よりも、ずっとできる方がいるかもしれません。 このマクロだけをみると、マクロはほとんど初心者のレベルだったようですし、なおかつ、「時間の引き算」や「時間の割り算」がある以上は、それを補正しなければなりません。浮動小数点型誤差や無限ループに近いような再帰が発生してしまっています。 私が見る所によると、イベント・ドリブン型で行われているところに問題があるようです。 これら自体を直すことはやぶさかではないのですが、その前に、他の問題もあるし、未だ、表全体の説明不足があります。 Do ～ Loop は、計算されていない部分を、マクロ処理で計算しているようですが、特異事項などがあるようですが、それはご指摘になっておらないようです。 関数処理のほうがよいとは思います。 >セルに入力するのは午前、午後四か所必ず入力しないといけません。 >この計算式を8.0ｈ→7.5ｈ >半休なら3.75ｈ >に変えれる計算式を教えていただけないでしようか？ 私は、ここで関数で表を作って差し上げることはできません。Excelカテゴリで新たにお聞きになってください。非常に、得意な方たちがいらっしゃるようですから。 >記入する最初のセルです >Ｓ1： 8：00 >Ｔ1：17：00 これは定数のようですが、この意味する所が分からないのです。 >Ｌ8：記入する最初のセルです。 という意味も理解できません。 VBAの計算そのものは、私は分かりますが、その計算式では、とても正しくでるようには思えません。 また、説明をされていないセルを参照して計算しているようですから、どうしようもありません。分からないからお聞きするといっても、限界があります。 本来、どういう計算をしたいのか書かれたほうが、マクロを直すよりもずっと早いと思います。たぶん、本来、この内容さえわかっていれば、この規模なら、マクロであろうが関数であろうが、1時間程度でできるはずです。説明の代わりにマクロを読みながら、修正するのは、何時間掛かっても読みきれません。 こちらが、申していたのは、画像で説明していただいたほうが早いからです。一応、無駄にはなると思いますが、私の分からない部分を画像にして出しておきます。マクロを見ていくと、その間の部分を参照しているように見受けられました。
こんばんは！ フィルタで絞り込まれている時だけマクロを実行するようにしてみてはどうでしょうか？ 一例です。 Sub Sample1() Dim lastRow As Long, lastCol As Long Dim myRng As Range, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") If .FilterMode Then lastRow = .Cells(Rows.Count, "A").End(xlUp).Row '←A列で最終行を取得// lastCol = .Cells(1, Columns.Count).End(xlToLeft).Column '1行目で最終列を取得// Set myRng = Range(.Cells(2, "A"), .Cells(lastRow, lastCol)).SpecialCells(xlCellTypeVisible) myRng.Copy wS.Cells(Rows.Count, "A").End(xlUp).Offset(1) If MsgBox("コピー＆ペーストした範囲を削除しますか？", vbYesNo) = vbYes Then myRng.Delete shift:=xlUp End If Else MsgBox "絞り込まれていません" End If End With End Sub こんな感じではどうでしょうか？m(_ _)m
ご自身で作成する気があるのか不明ですが、一応、参考になりそうな手順として・・・ まずは、1行分を処理できるものを作成しておいて、それを繰り返して実行するという考え方にすると、分かり易いのではないかと思います。 （参考サイトを上げましたが、吟味したものではありませんので、ご自身で調べてください） 1）指定したページを開いてみる 　まずはブラウザで指定したページを開けるようにしてみましょう http://vba-code.net/ie/ http://www.vba-ie.net/ie/index.html 2）検索したいページを開けるようにする http://www.yoheim.net/blog.php?q=20120611 3）検索結果の文書から必要な情報を抜き出して処理する http://www.forest.impress.co.jp/docs/special/201 … http://language-and-engineering.hatenablog.jp/en … ここまで、できれば1行分の処理はできるようになったのではないかと思います。 4）1行分の処理を繰り返して行う http://yumem.cocolog-nifty.com/excelvba/2010/08/ … http://www.asahi-net.or.jp/~zn3y-ngi/YNxv214.htm … ※ 一気に全部やろうとすると大変かもしれませんが、順番に一つづつ確実に作っていくのがコツかも知れませんね。 ※ 大抵の場合、URLを検索するとそのURLがヒットすると思いますけれど。
数式で取得した後、数値に置き換えれば済みます。 Sub Macro1() 　with Range("D2", Cells(Rows.Count, "D").End(xlUp)).offset(0,1) 　　.Formula= "=vlookup(D2, A:B, 2,0)" 　　.Value=.Value 　End With End Sub
＞References.AddFromFile "C:\Windows\system32\scrrun.dll" 使いたいのはわかりますが、VBAレベルではかなり上級ですよね。 これからVBA講座を受けられても、この内容までは出てこないと思います。 一案ですが default.txt　が固定した内容であれば 新しいシートのコピーしておく。 C1,C2,C3の部分をActiveSheetのＡ１、Ａ２、Ａ３に置き換えるマクロを考える。 置き換えたシートをTxtの形式で保存してみて ご希望のシートにならないか試してみる。 これで良ければ、ほとんどがマクロの記録で出来ると思います。 もし、default.txtが時に変更があり場合は別途 default.txtのシートへの貼付けのボタンを別途準備するなどが 考えられます。 講座のなかでも、初歩の部分で出来ると思います。
sendkeyで操作なさっているのだと想像しましたが、制御するのは同様の方法しかないのではと思います。 手元にChromeが無いので確認できてはいませんが、デフォルトでショートカットが設定されていればそれを、設定がなくても多くのブラウザではダイアログ表示時点でそのまま「印刷」がデフォルトになっていると想像しますので、リターンキーで印刷されませんか？ 手元にあるブラウザで試してみたところ 　ＩＥはショートカットAlt+Pでもリターンキーでも印刷される 　Ｆｘはショートカットは無し、リターンキーで印刷される という状況でした。 ご参考まで。
このためにテーブルを作成してもよろしければ テーブル名：てーぶる フィールド名：顧客情報更新日 フィールドタイプ：日付時刻型 を作成します。 元データ入れ替えボタンのクリック時などに Private Sub 元データ入れ替えボタン_Click() Dim TD As Variant Dim DB As Database Dim RS As DAO.Recordset Set DB = CurrentDb Set RS = DB.OpenRecordset("てーぶる", dbOpenDynaset) TD = InputBox("更新日は？", , Date) If TD = "" Then MsgBox "取りやめ" Exit Sub End If If RS.EOF And RS.BOF Then RS.AddNew RS!顧客情報更新日 = TD RS.Update Else RS.Edit RS!顧客情報更新日 = TD RS.Update End If if dcount("*","てーぶる")>1 then msbgox "不正なデータがてーぶるにあります" rs.close:set rs=nothing exit sub endif Me!ラベル更新日.Caption = TD rs.close:set rs=nothing End Sub でこのボタンの近くにでもラベルを置いて初期値として、2000/1/1 とでもしておきます。 このフォームの開くときのイベントに Private Sub Form_Open(Cancel As Integer) Me!ラベル更新日.Caption = Nz(DLookup("顧客情報更新日", "てーぶる"), "") End Sub とすれば？ テーブルは作りたくないのなら・・・。
可能性のひとつとして読んでください。 アクティブシートの$A$1セル以降にcsvファイルが読み込まれますが、そもそもアクティブシートの180行目までデータが入っていませんか？ csvファイルを読み込む前の状態において、見た目は何もなくても、空白が入力されている可能性があります。 一旦、全行削除してから取り込みを行えば、イケるような気がします。
表示、非表示は、Hiddenプロパティで判定できます。表示の場合は、Falseとなります。 よって、次のようにすれば表示行のみを処理できます。 それから、大きなお世話かもしれませんが、プログラムコードに無駄が多すぎますよ。感じとして、1/3くらいのステップで実現可能そうですが…。他の方のプログラムを参考にして、精進してください。 For Each Rng In Selection.Rows If Not Rng.Hidden Then p = Rng.Row '・ '・ '・ End If Next Rng
マクロ実行中のBookのExcelでは他の作業をしないようにします。 Excel を Alt キーを押しながら立ち上げて別のインスタンスでExcelを開き、 そちらで作業を行えばよろしいかと。 別のインスタンスで開けているかはタスクマネージャで確認してください。 エクセル2013基本講座：Excel2013を別のインスタンスで起動するには? http://www4.synapse.ne.jp/yone/excel2013/excel20 … 対症療法的に感じるかもしれませんが一番確実かと思います。 なお、マクロ中でBookやSheetのオブジェクトの指定が曖昧で 問題が発生している可能性もありそうですね。
「*」と変数の間にスペースは入っていますか？ NG　&***&　 OK　& *** &
> 後学として、VBAで行う方法も知りたいです。御存知の方がいらっしゃれば御回答よろしくお願いいたします。 > ③リストビュー上で選択した画像をイメージに表示する。 Image1.Picture = LoadPicture(pathImageFile) Image1.PictureSizeMode = fmPictureSizeModeZoom ※Image1はユーザーフォーム上のイメージオブジェクトです。 > ④必要な画像だけを選択し(チェックボックスを用いることを考えていますが、その他代替案がございましたらそれでOKです。)一度に画像をEXCELに保存する。 リストビューが使用できる環境でないので未確認ですが、リストビュー上の複数の項目を選択できるモードがあると思いますので、プロパティを確認してみてください。（選択操作は、CtrlキーやShiftキーを押しながらの項目クリック。エクスプローラ上で複数ファイルを選択する場合と同じです。） 選択した項目の処理については↓が参考になるかと https://oshiete.goo.ne.jp/qa/800892.html
Sheet1とSheet2のレイアウトを同じにすることはできないのでしょうか？また、番号２と３の連結は必須ですか？ この辺を整理すれば、もっとシンプルなVBAで対応できそうですが、結果的に自分の首を絞めているような気がします。 ご要望の通りにすると、こんな感じです。コメントを豊富に付けましたので、ご参考までに。 Sub sample() Dim ws1 As Worksheet Dim ws2 As Worksheet Dim ws As Worksheet Dim I As Long Set ws1 = ThisWorkbook.Sheets("Sheet1") '集計元シート定義 Set ws2 = ThisWorkbook.Sheets("Sheet2") '集計先シート定義 '集計元シートをコピーして、作業用シートとして定義 ws1.Copy Set ws = ActiveSheet '作業用シートから集計キー項目の重複行を削除 ws.Range("A:J").RemoveDuplicates _ Columns:=Array(4, 5, 6, 7, 8, 9, 10), Header:=xlYes '作業用シートの集計 For I = 2 To ws.Cells(Rows.Count, 1).End(xlUp).Row ws.Cells(I, "A") = WorksheetFunction.SumIfs(ws1.Range("A:A"), _ ws1.Range("D:D"), ws.Cells(I, "D"), _ ws1.Range("E:E"), ws.Cells(I, "E"), _ ws1.Range("F:F"), ws.Cells(I, "F"), _ ws1.Range("G:G"), ws.Cells(I, "G"), _ ws1.Range("H:H"), ws.Cells(I, "H"), _ ws1.Range("I:I"), ws.Cells(I, "I"), _ ws1.Range("J:J"), ws.Cells(I, "J")) ws.Cells(I, "B") = WorksheetFunction.SumIfs(ws1.Range("B:B"), _ ws1.Range("D:D"), ws.Cells(I, "D"), _ ws1.Range("E:E"), ws.Cells(I, "E"), _ ws1.Range("F:F"), ws.Cells(I, "F"), _ ws1.Range("G:G"), ws.Cells(I, "G"), _ ws1.Range("H:H"), ws.Cells(I, "H"), _ ws1.Range("I:I"), ws.Cells(I, "I"), _ ws1.Range("J:J"), ws.Cells(I, "J")) ws.Cells(I, "C") = WorksheetFunction.SumIfs(ws1.Range("C:C"), _ ws1.Range("D:D"), ws.Cells(I, "D"), _ ws1.Range("E:E"), ws.Cells(I, "E"), _ ws1.Range("F:F"), ws.Cells(I, "F"), _ ws1.Range("G:G"), ws.Cells(I, "G"), _ ws1.Range("H:H"), ws.Cells(I, "H"), _ ws1.Range("I:I"), ws.Cells(I, "I"), _ ws1.Range("J:J"), ws.Cells(I, "J")) Next I 'コピー先シートのクリアと作業用シートからの転記 ws2.Rows("2:" & Rows.Count).Delete For I = 2 To ws.Cells(Rows.Count, 1).End(xlUp).Row ws2.Cells(I, "A") = ws.Cells(I, "D") '番号1 ws2.Cells(I, "B") = ws.Cells(I, "E") & ws.Cells(I, "F") '番号2+3 ws2.Cells(I, "C") = ws.Cells(I, "I") '率 ws2.Cells(I, "D") = ws.Cells(I, "B") '数量1 ws2.Cells(I, "E") = ws.Cells(I, "C") '数量2 ws2.Cells(I, "F") = ws.Cells(I, "J") 'コード ws2.Cells(I, "G") = ws.Cells(I, "G") '記号 ws2.Cells(I, "H") = ws.Cells(I, "H") '識別 ws2.Cells(I, "I") = ws.Cells(I, "A") '金額 Next '作業用シートを閉じる ws.Parent.Close SaveChanges:=False End Sub
>こうした人材情報をどこでどのように定義するかで迷っています。 > たとえば、VBAのユーザー定義型を使って 　…… >などのようにどこか1ヶ所に宣言して、各ツールで「役職が営業担当のみ」「社内メンバーのみ」「マネージャ権限を持つ人のみ」を判定して該当者をふるい分けられる仕組みができれば最高なのですが、どのように考えれば良いのか分からずに困っています。 Excelを使用するのでしたら、普通にシート上に表としてまとめれば良いのではないでしょうか？ 縦方向に氏名、横方向に役職やメールアドレス等グループ分けに必要な属性を記載する。 vbaでは、表の属性情報をみて必要なメアドなりを収集する様にする。 表へのアクセス制限を行いたい場合には、当該シート或いはファイルにパスワードを書ければ良いとと思います。
No.1です。 >No.2さん ご指摘ありがとうございます。 確かに、エクセルファイルの対象のシートがアクティブでない状態で保存されていた場合のテストをしておりませんでした。
ANo1です。 ＞単純に選択した図形のサイズを知るプログラムを探しているのですが、見つかりません。 単純に高さ、幅を取得したいのでしたら、ShapeRangeのheight、widthを参照すればよろしいと思います。 　https://msdn.microsoft.com/ja-jp/library/office/ … WordのVBA関連のたいていのことは、（↑）で調べられます。 ただし、上記のままだとピクセル値（72px/inch)が返ってくるようですので、例で挙げておられるのと同様に、計算する単位に合わせた変換が必要かも知れません。
ActiveWorkbook.SaveAs Filename:= "C:\Macro\hozon.xslx", FileFormat:=xlOpenXMLWorkbook, CreateBackup:=False
WshShell.Run "C:\サンプル\abcd.vbs " & AA & " " & BB で出来ました。 こちらのページを参考にしました。 http://vba-geek.jp/blog-entry-238.html https://msdn.microsoft.com/ja-jp/library/cc36442 …
DoEventsを書く場所を後ろにずらしたらどうでしょうか？ファイル名をペーストして、さらにOKボタンをクリックしてからDoEventsとすれば、進むような気がします。要するに、FreeSoftが待ち状態を通過するまでの操作を行ってからDoEventsを発行するイメージです。
No.2・3です。 ＞コンパイルエラー ＞SubまたはFunctionが定義されていません このようなメッセージが表示される場合は Call　で呼び出しているプロシージャが存在しない場合が多いです。 今一度標準モジュールのマクロ名と　Call　で呼び出しているマクロ名が一致しているか確認してみてください。 それでもダメなら別案として、Sheet2のシートモジュールですべて処理するのはどうでしょうか？ Sheet2のシートモジュールを↓に変更してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) Dim i As Long, cnt As Long, wS As Worksheet If Intersect(Target, Range("A2:C2")) Is Nothing Or Target.Count > 1 Then Exit Sub Set wS = Worksheets("Sheet1") Range("D2").ClearContents If WorksheetFunction.CountBlank(Range("A2:C2")) = 0 Then For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row If wS.Cells(i, "A") = Range("A2") And wS.Cells(i, "B") = Range("B2") Then cnt = cnt + 1 With Range("D2") .Value = .Value + wS.Cells(i, "C") End With If cnt = Range("C2") Then Exit For End If Next i End If End Sub ※　このコードの場合、標準モジュールのコードは不要です。m(_ _)m
> いろいろファイルの違うものに変更すると、 > If ary(1) = strFind Then　でまだ、「型が一致しません」のエラーがでています。 > しかし解決方法がネットでも見つかりません。うまい解決法はあるのでしょうか？ エラーが起きる具体的なテキストデータがわからないと、なんとも答えようがないです。
こんな感じで如何でしょうか。 Sub aaa() Dim r As Range Set r = Worksheets("Sheet2").Cells.Find(Worksheets("Sheet1").Range("A1").Value) If Not r Is Nothing Then Worksheets("Sheet2").Select r.Select Else MsgBox "見つかりませんでした。", vbExclamation End If End Sub
ざっと見ただけですけれども > Call MsgBox("Missing Log file", vbOKOnly, "OK") Call不要 > strFileName For Input As #5　（ここがアレンジした部分） Openがない > If (strFileName <> "False") Then > If (Trim(Dir(strFileName)) = "") Then 対応するEnd Ifがない
自己解決、おめでとうございます。記載されているコードが想定通りの動作であれば、問題はありません。 注意点としては、On Error Resume Next は以降で発生したすべてのエラーを無視して処理が継続されます。よって、本来のエラー（プログラムバグ等）があってもスルーしてしまいます。すると本来の結果が得られないのに、どこがおかしいのか発見が難しくなります。 記載の例でいうと、例えば、Sheets("一番")が無い場合、下から3行目のSelectに失敗します。それにより、次の行Range("H24:O24").Select は、Sheets("三番")のセルを選択してしまいます。これが、全体に影響を与えないのであれば問題はないのですが…。 エラーの発生が予想される部分を通過したら、On Error Goto 0 で エラートラップを無効にすべきです。
キーワードを入れるテキストボックスは1つですよね？ ということは キーワード検索1.Value キーワード検索2.Value キーワード検索3.Value としているのが問題では？ 全てキーワード検索1.Value でいいと思うのですが…
事前に以下の設定をしておいて、次回からは[接続]ボタンのワンクリックで接続するだけ、という方法ではダメということでしょうか。 1. [リモートデスクトップ接続]ダイアログの[全般]タブの”ログオン設定”の"☑資格情報を常に確認する"のチェックを外し、[接続]ボタンをクリックする。 2. [Windowsセキュリティ]ダイアログが表示されら、パスワードの入力と"□資格情報を記憶する"にチェックを入れて、[OK]ボタンをクリックする。 3. [リモートデスクトップ接続]ダイアログ（"このリモートコンピュータのIDを識別できません。接続しますか？"の黄色い帯付）が表示されたら、"□このコンピュータへの接続について今後確認しない"のチェックを入れる。 次回以降は、1の[接続]ボタンをクリックするだけで、リモート先のサーバorＰＣにログインした状態になります。
これでどうでしょう。 Selection.Cut Selection.Rows.Offset(Selection.Rows.Count + 1).Insert Shift:=xlDown Selection.Offset(1, 0).Select
こんにちは。 ＞気にせず保存終了します これはVBAでの処理なのか、ユーザがエクセルの保存機能で操作するのかよくわかりませんが・・・ もともとのテキストの形式が不明ですが、例えばcsvファイルとして・・・ エクセルからcsv等に出力する際に、通常の保存操作で行うと、表示中のテキストが各セルの値として保存される仕様になっているようです。 それなので、保存時にはシートに表示されている形式（有効桁数等）になりますので、ご質問の事象となっているのではないでしょうか？ ＞元のデータ形式で保存するにはどうすればいいでしょうか。 保存形式がわかりませんが、VBAで順次、（ループなどで）各セルの値をテキスト出力するようにすれば解決するものと想像します。 csvなどのような一般的な形式で、エクセルの保存機能を利用するような場合は、そのままですと上記のようにシートの表示形式に左右されてしまいますので、保存直前にシート全体の書式をクリアするか文字書式等に変えてから、エクセルの保存機能を利用して保存することで、元のデータの桁数のまま出力されることと思います。
こんばんは！ 一例です。 Sub Sample1() On Error Resume Next '←念のため Range("B:B").SpecialCells(xlCellTypeFormulas, xlErrors).EntireRow.Delete End Sub B列に入っているのはVLOOKUP関数だというコトですので、 上記のコードで大丈夫だと思いますが、 他のエラー（#DIV/0!　や　#REF!　等々）すべてのエラーが削除されてしまいます。 他のエラーもあり、#N/A　だけの行を削除する場合は↓のコードにしてみてください。 Sub Sample2() Dim c As Range, myErr As Range, myRng As Range On Error Resume Next Set myErr = Range("B:B").SpecialCells(xlCellTypeFormulas, xlErrors) If Not myErr Is Nothing Then For Each c In myErr If c = CVErr(xlErrNA) Then If myRng Is Nothing Then Set myRng = c Else Set myRng = Union(myRng, c) End If End If Next c myRng.EntireRow.Delete End If End Sub こんな感じではどうでしょうか？m(_ _)m
例えばA1に記入したいなら、 ThisWorkbook.Worksheets("sheet1").Range("A1").Value=activeworkbook.name
https://oshiete.goo.ne.jp/qa/8372965.html スタックトレースをログに吐くか、 それが難しいのであれば、 客先のＰＣに、無償版の Visual Studio Express 2013 をインストールしてもらった方が良いかと
浮動小数点型には必ず演算誤差がついて回ります。一度、判定してるIf文の前に以下の実験コードを入れて実感してみてください。 msgbox i * 0.3 msgbox j * 0.2 こうなる理由の詳細は、浮動小数点型　誤差　でググってみましょう…ってのではあまりにも適当すぎるんで、一例を以下に。解決策についての言及もあります。 http://dobon.net/vb/dotnet/beginner/floatingpoin … 精度が小数点以下4桁で足りるなら、固定小数点型の一種であるCurrency型（通貨型）使うのも手です。
> 通貨型に変換してから計算を行なうことで誤差はなくすことができるのでしょうか？ そうです。 小数点以下４桁まで、誤差なしで計算できます。 ? 0.4 * 3 - 0.6 * 2 1.11022302462516E-16 ? CCur(0.4) * 3 - CCur(0.6) * 2 0
こんにちは！ 質問文の解釈だと Sub Sample1() Dim i As Long For i = 10 To 1 Step -1 If Cells(i, "C") <> "" Then Exit For Next i On Error Resume Next '←念のため Range(Cells(1, "C"), Cells(i, "C")).Select End Sub でいいような気がしますが・・・ 余計なお世話でもう一つ Sub Sample2() Dim i As Long For i = Cells(Rows.Count, "C").End(xlUp).Row To 1 Step -1 If Cells(i, "C").HasFormula And Cells(i, "C") <> "" Then Exit For Next i On Error Resume Next Range(Cells(1, "C"), Cells(i, "C")).Select End Sub でもOKだと思います。m(_ _)m
解説書を読んでいるうちはあまり解説書のバージョンから離れることはお勧めできません。 といいますのも2010から2015の間にforeachが全く構文が変わっていないのに挙動が変わっていたり、そもそも構文が変わっている機能もあります。 それらを調べながら解説書を読むくらいなら、解説書を読み終わってからバージョン間の差分を覚える方が結果的に早く覚えられるかと思いますよ。 またVisual Basic 2010 Expressは最小限のVisual Basic環境ですが、 Visual Studio 2015 Communityはバージョン管理機能やソースコード監査機能などVisual Studioのフル機能です。 Visual Studio 2015 Communityはアップデートを適用するに依存関係のあるパッケージを手動インストールする事が要求されたりと、 「用語を並べれば理解できる程度の知識」を前提とした設計が各所に見られます。 最後に… プログラムは分解すれば他の機能を呼び出す、分岐する、ループするの3種類の動作だけの塊です。 （極論言えば他の機能を呼び出す、分岐するの2つだけでも十分です。） ですから新しい言語を覚える時はその言語（今回の場合Visual Basic）の最新を追いかけるより、3点をどうやったら素早く覚えられるかを考えたほうがいいですよ。
> 特定の文字列はA列です。 失礼しました。行番号をA列のデータとして考えていました。 以下の様に修正してみてください。 誤　If InStr(Worksheets("Sheet1").Cells(tRow, 1).Value, Worksheets("Sheet2").Cells(sRow, 2).Value) <> 0 Then 正　If InStr(Worksheets("Sheet1").Cells(tRow, 1).Value, Worksheets("Sheet2").Cells(sRow, 1).Value) <> 0 Then
ComboBox2.List = ComboBox1.List ComboBox2 = ComboBox1 みたいなこと？
Public Function pass() As String pass = CurrentProject.Path End Function =iif(「条件式」, pass() & "\gazou.gif","") そのままコピーして「条件式」の部分を変更したクエリを作成しましたが正常に動作します。 レポートのどこに=iif(「条件式」, pass() & "\gazou.gif","")を入力しましたか？ レポートのレコードソースにテーブルやクエリを指定していますか？
○たぶん動くでしょうけど、全て保証されているわけではないので、あくまで自己責任で。 ○VB6 WIn10 で検索してみました ・インストールに失敗することがあるようです。 ・挙動がおかしいこともあるようです。 ○個人使用等の条件があっていれば、 Visual Studio Community Edition が無料で使えます。 https://www.visualstudio.com/ja-jp/products/visu … これを機会に新しいものに挑戦するのもよいかと。
指定したフォルダの下にあるファイル名とそのタイムスタンプを取得できれば良いのですよね。 サブフォルダを無視して良いなら、こんなのはいかがでしょうか。 このサンプルプログラムは、"C:\Users\xxxx\Documents\"フォルダ内のファイル名をDir関数で順次取得し、さらに、FileDateTime関数でタイムスタンプを取得。それを Debug.Print しています。 Sub test() Dim MyPathName As String Dim MyFileName As String Dim MyTimeStamp As String Dim cnt As Long MyPathName = "C:\Users\takashi\Documents\教えてGoo - コピー\" MyFileName = Dir(MyPathName & "*.*") Do While MyFileName <> "" cnt = cnt + 1 MyTimeStamp = FileDateTime(MyPathName & MyFileName) Debug.Print MyTimeStamp & " " & MyFileName MyFileName = Dir Loop MsgBox cnt End Sub
いきなりEnableResize = Falseはできないです。 Dim MainWindow As Object Set MainWindow = Application.Windows(ThisWorkbook.Name) With MainWindow 　　.WindowState = xlNormal 　　''その他設定 　　・・・・ 　　.EnableResize = False End With でいけると思います。 あと蛇足ですが仰るとおり2013からSDIになったのでActive等で指定するのではなく直接ブック名を指定するといいと思います。
No.2のママチャリです。 nao0620さんの回答を理解できれば、もう答えは分かっていますよね。 念のため、プログラムコードを書いておきますが、内容を理解しないと、 応用ができませんよ。 Sub WriteDiary() ChDir ThisWorkbook.Path ChDir ".." '一階層上がる ChDir CurDir & "\フォルダＢ\フォルダＤ" Open CurDir & "\" & WorkSheets("Sheet1").Range("A1") & ".txt" For Output As #1 Print #1, WorkSheets("Sheet1").Range("A2") Close End Sub
If Selection.Cells.Interior.Color = 16777215 thenの代わりに、 If Selection.Cells.Interior.Color.Index = xlNone Thenとも書けます。
こんな感じで如何でしょう？ 以下を当該のユーザーフォームに入力してください。 元の表は、アクティブなシートのA1:D15に書かれていることが前提になります。 Ckaisha,Cshoshin,Caji,Csizeが、それぞれ会社、商品、味、サイズの各コンボボックス名になります。 ※私の環境(Win10 64bit/Excel2013)では、イベント連鎖抑止目的でApplication.EnableEventsが上手く機能しなかったので、flagというモジュール内変数を宣言して代わりに使用しました。 --------------------------------------------------------- Option Explicit Private flag As Boolean Private Sub UserForm_initialize() flag = True Call makeKaishaList(Range("A2:A15")) flag = False End Sub Private Sub Ckaisha_Change() If flag Then Exit Sub End If flag = True Call makeShohinList(Range("B2:B15")) flag = False End Sub Private Sub Cshohin_Change() If flag Then Exit Sub End If flag = True Call makeAjiList(Range("C2:C15")) flag = False End Sub Private Sub Caji_Change() If flag Then Exit Sub End If flag = True Call makeSizeList(Range("D2:D15")) flag = False End Sub Private Sub makeKaishaList(ByRef r As Range) Dim rng As Range Dim i As Long Dim f As Boolean Ckaisha.Clear For Each rng In r f = False With Ckaisha For i = 0 To .ListCount - 1 If rng.Value = .List(i) Then f = True Exit For End If Next i If Not f Then .AddItem rng.Value End If End With Next Ckaisha.ListIndex = 0 Call makeShohinList(r.offset(0, 1)) End Sub Private Sub makeShohinList(r As Range) Dim rng As Range Dim i As Long Dim f As Boolean If Ckaisha.Text = "" Then MsgBox "選択されていない項目があります。", vbExclamation Exit Sub End If Cshohin.Clear For Each rng In r f = False If rng.offset(0, -1).Value <> Ckaisha.Text Then GoTo L_CONTINUE With Cshohin For i = 0 To .ListCount - 1 If rng.Value = .List(i) Then f = True Exit For End If Next i If Not f Then .AddItem rng.Value End If End With L_CONTINUE: Next Cshohin.ListIndex = 0 Call makeAjiList(r.offset(0, 1)) End Sub Private Sub makeAjiList(r As Range) Dim rng As Range Dim i As Long Dim f As Boolean If Ckaisha.Text = "" Or Cshohin.Text = "" Then MsgBox "選択されていない項目があります。", vbExclamation Exit Sub End If Caji.Clear For Each rng In r f = False If rng.offset(0, -2).Value <> Ckaisha.Text Then GoTo L_CONTINUE If rng.offset(0, -1).Value <> Cshohin.Text Then GoTo L_CONTINUE With Caji For i = 0 To .ListCount - 1 If rng.Value = .List(i) Then f = True Exit For End If Next i If Not f Then .AddItem (rng.Value) End If End With L_CONTINUE: Next Caji.ListIndex = 0 Call makeSizeList(r.offset(0, 1)) End Sub Private Sub makeSizeList(r As Range) Dim rng As Range Dim i As Long Dim f As Boolean If Ckaisha.Text = "" Or Cshohin.Text = "" Or Caji.Text = "" Then MsgBox "選択されていない項目があります。", vbExclamation Exit Sub End If Csize.Clear For Each rng In r f = False If rng.offset(0, -3).Value <> Ckaisha.Text Then GoTo L_CONTINUE If rng.offset(0, -2).Value <> Cshohin.Text Then GoTo L_CONTINUE If rng.offset(0, -1).Value <> Caji.Text Then GoTo L_CONTINUE With Csize For i = 0 To .ListCount - 1 If rng.Value = .List(i) Then f = True Exit For End If Next i If Not f Then .AddItem (rng.Value) End If End With L_CONTINUE: Next Csize.ListIndex = 0 End Sub
ユーザーフォーム UserForm1 にTxtPassword という名前のテキストボックスがある、 ということでしょうか？ でしたら appwb.UserForm1.Controls(”TxtPassword").Value = Sheet2.Range("K2")
> 関数のカッコの有無は戻り値を使うか否かの為とあり、 > まったくキツネにつままれたようです。 こちらなどは分かりやすいと思いますが。 VBAにおける括弧()の使い方 http://excel-ubara.com/excelvba4/EXCEL244.html
ページの指定は Value によりますが ページの Caption ではなく Name を使えば ループしなくても ページのインデックスを取得できます。 MultiPage1.Value = MultiPage1.Pages("1ページ目のPage名").Index とか。 プロパティで Caption と Name を同じに変更しておけば 直観的には Caption で指定したような感じになるでしょう。 ただし、オブジェクト名に使えない文字が含まれる場合は この手は使えませんが。 その場合でも、デフォルトのページ名から 内容の分かりやすい名前に変更しておくことをおすすめします。 プロパティの設定方法が ユーザーフォーム と シート で異なっていますが マルチページ は、そのどちらにありますか？
A列に入力してある最終行までループするマクロです。 Sub sample() For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row If Cells(i, 1) <> "" And Cells(i, 2) <> "" Then _ Cells(i, 3) = Cells(i, 1) & "(n=" & Cells(i, 2) & ")" Next End Sub なお、VBAでなくても下記関数にて対応は可能です。 C列全体を選択し、Ctrl+Enterで確定 =IF(AND(A1<>"",B1<>"")=TRUE,A1&"(n="&B1&")","")
Application.WindowState = xlMaximized という書き方をやめ、 Windows("ブック名").WindowState = xlMaximized Windows("ブック名").Width Windows("ブック名").Height という書き方に変更してみてください。（"ブック名" のところで指定するブックをすべて同一のブックにする） おそらくですが、 Application.WindowState = xlMaximized で最大化したウィンドウと Windows("ブック名").Width でサイズを取得しようとしているウィンドウが違っているのではないかと思います。 最大化したブックで見えなくなっていますが、その後ろで Windows("ブック名") は xlNormal なままでいると思います。 Excel 2013 は SDI になりました。(SDI と MDI の違いは分かりますか？) ブックを複数開いた状態で、すべてのブックが独立した Excel のウィンドウになっていると思います。 なので Application.WindowState = xxx で操作対象になるのは 「現在アクティブなブックのウィンドウ」 であり、 ActiveWindow.WindowState = xxx と同じ事になっているんじゃないかと。 Excel が MDI から完全な SDI に変わったことで、私の中で当時大変大きな話題になった記憶があります。。。
No.1です、 > 各列に無い場合②の作業を行う指定を"本文"のやり方から"補足コメント"記載のように変更したいのです。 その様にしたつもりなのですが……仕様について理解しきれていないのかもしれません。 > " 7622 " の十の位の場合は、一番近いのが、百の位の三回前にあたりますので→ Q12→”X" , R12→”百,3”と表記したいです。 となっていませんか？ 私の理解に間違いがあるかもしれませんので、 質問欄に提示していただいたデータで、具体的に実行結果がこうなっているけど、こうして欲しいという様にご提示いただけないでしょうか？
No.4ママチャリです。 まず①の件ですが、確かに Office 2013 and later となっていますね。でも、私の環境もExcel2010ですが、ヘルプにも掲載されているし、実際、StartRowで指定した行から読み込めています。各種ホームページを見ても2013より前のバージョンでも話題になっているので、問題ないと思います。 ②の方ですが、OverTheGalaxyさんが書いたコード（Workbooks.OpenText Filename:=vFile, DataType:=xlDelimited, startrow:=ReadRow, comma:=True）を実際に動かしたところ、正常に動きました。確かにstartrowは大文字になりませんでしたが･･･。 試しに、[ファイル]ｰ[開く]の手順をマクロに記録し、それをベースに実験してみてはいかがでしょうか。各種HPを見ていて、「省略可能なパラメータと書いてあるくせに、省略したら問題が発生した」みたいな記事がありましたので･･･。 マクロを記録する際、列数が多いと FieldInfo パラメータがあふれることがあります。ただ、形式を指定する必要がなければ、不要なものなので捨てちゃってOKです。 では、ご検討をお祈りします。 それにしても、同じ環境（2010ではやっていないのでしたっけ？）で動作が異なるとは、Micr●s●ftらしいですね。
VBのカテゴリへのご質問なので、関数じゃなくても良いのかしらん・・・ 第二キーの説明を正しく理解しているかやや不安ですが、こんな感じでしょうか？ ※ シートの並べ替えを利用する関係で、G3:I12の範囲を使用しています。 　　もしも、Ｉ列をご利用なさっている場合は工夫が必要です。 ※ マクロ実行で処理していますが、シートのチェンジイベントに組み込む 　　ようにすれば、値を入力で、即、結果に反映されるようにもなります。 ※ データ値のチェックなどは行っていません。 Sub test() 　Dim data As Range, result As Range, c As Range 　Dim rw As Integer, col As Integer, rank As Integer 　Set data = Range("C3:F12") 　Set result = Range("G3:I12") 　For rw = 1 To 10 　　result.Cells(rw, 1).Value = rw - 1 　Next rw 　result.Columns(2).Formula = "=COUNTIF(C$3:F$12,""=""&G3)" 　result.Columns(3).Value = 0 　For rw = 1 To 10 　　For col = 1 To 4 　　　rank = rw * 10 + 5 - col 　　　Set c = result.Cells(data.Cells(rw, col).Value + 1, 3) 　　　If c.Value < rank Then c.Value = rank 　　Next col 　Next rw 　result.Sort Key1:=result.Columns(2), order1:=xlDescending, _ 　　　　　　　Key2:=result.Columns(3), order2:=xlDescending 　result.Columns(3).ClearContents End Sub
「ファイルが無い」 というメッセージを発する箇所がコード中に見受けられません。 ファイルの存在確認をしてい 「・・・は存在しません」 というメッセージを発する箇所が 2箇所ありますが、どちらのコードで出ているのでしょうか？ orgdata という変数で参照しているシートの L4 と L5、そして sheet2 の G2 には実際にどんな値が書き込まれているのでしょうか？ ファイル名だけですか？ それともフルパスでしょうか？ ファイル名だけの場合はコード実行時に Excel が認識しているカレント ディレクトリが関係しているかもしれません。 デバッグ作業などの仕方によってもカレント ディレクトリはコロコロと変わりますので、できればフルパスにした方が良いと思います。 ファイル名だけにする場合でも、最終的にファイルの場所が明示的にわかるようにコードを書いた方がいいです。 どこかのセルに親フォルダーのパスが書いてあるとか、ThisWorkbook のフォルダーの配下にあるとか。 ちなみにファイルの存在確認をするのに Dir を使ったり FileSystemObject を使ったりしてますが、FileSystemObject に絞った方が良いと思います。 また、コードの後半では暗黙的な Sheet2 でシートを参照してセルにアクセスしている箇所があります。 Set しているコードが無いので外しているかもしれないですが前半では orgdata という明示的な変数でシートを参照しているようです。 Sheet2 というのが明示的に宣言した変数じゃない場合、VBA コードが書いてあるブックだけを開いている場合は ThisWorkbook の Sheet2 を指すことになりますが、別のブックを開いてしまうと 「アクティブなブック」 の Sheet2 を参照してしまいます。（シート名ではなくて VBEditor のプロジェクト エクスプローラーで見た時のオブジェクト名） 混乱のもとになるので、複数のシートや複数のブックを扱う場合は必ずブックやシートを変数で明示的に参照したほうが良いです。
それ、1行ずつ読み込む必要あるんですか？ 単純にファイルごとコピーじゃダメなのでしょうか？ 下記は CSV ファイルを開き、1行まるごと読み込んで、別のファイルに転記するコードです。 Sub test1() 　　Const ForAppending = 8 　　Const ForReading = 1 　　Const ForWriting = 2 　　 　　Dim fso As Object 　　Set fso = CreateObject("Scripting.FileSystemObject") 　　' Scripting.TextStream Dim srcCsv As Object 　　Dim destCsv As Object 　　 　　' 読み込み元の CSV と転記先の CSV を開く。 　　' 転記先のファイルが存在しない場合は自動作成する。 　　' 転記先のファイルが存在する場合は上書きする。(ForWriting) 　　' 上書きではなく追記にしたい場合は ForWriting の記述を ForAppending に変更する。 　　Set srcCsv = fso.OpenTextFile("D:\src1.csv", ForReading, False) 　　Set destCsv = fso.OpenTextFile("D:\dest1.csv", ForWriting, True) 　　 　　Dim srcLine As String 　　Do Until srcCsv.AtEndOfStream 　　　　srcLine = srcCsv.ReadLine 　　　　destCsv.WriteLine srcLine 　　Loop 　　 　　srcCsv.Close 　　destCsv.Close 　　 End Sub 本当に 1行読んで 1行書き込むだけなら Do ～ Loop の間は destCsv.WriteLine srcLine.ReadLine だけでも良い。 下記のコードはファイルを読み込みもせず丸ごとコピーする。 Sub test2() 　　Dim fso As Object 　　Set fso = CreateObject("Scripting.FileSystemObject") 　　fso.CopyFile "D:\src1.csv", "D:\dest1.csv", True End Sub
Application.Dialogs(xlDialogPatterns).Show このダイアログはそもそもセルの塗りつぶし設定をするダイアログのためのコードで、図形を対象に表示させても枠線の色を変更できなかったりします。 恐らく昔からこの仕様は変わっていないと思います。 https://support.microsoft.com/ja-jp/kb/212177 つまりお探しの機能を果たす組み込み式ダイアログに対する定数はないようなのです。 マイクロソフトのサポート情報にあるように、図形を選択した状態で SendKeys "^1", True です。 ^1 は [Ctrl] + [1] を意味します。 現在選択されているオブジェクトに対する適切な書式設定ダイアログを呼び出すためのショートカットです。
9 節 ファイル処理 に、ファイルへの読み書きが書いてあるはずです。 #1でも書きましたけど、この問題だけでは、決まっていることが少なすぎるので、自分であれこれ考える必要があります。 一番単純には "01,青森県,8998" という文字列をファイルに出力 "02,岩手県,15092" という文字列をファイルに出力 .... として書き出したものを 1文字列読み込み→すぐに表示 ( 01,青森県,8998 が表示される) 1文字列読み込み→すぐに表示 ( 02,岩手県,15092 が表示される) ... とすることでしょう。 ですが ・項目毎に別の変数にした方が計算とかの処理がしやすい 　CODE$="01" 　PERF$="青森県" 　AREA=8998 ・表としてデータを扱うなら、配列を使うのが便利 　CODE$(0)="01" 　PERF$(0)="青森県" 　AREA(0)=8998 　CODE$(1)="02" ... ・ランダムアクセスにすれば、途中から自由に読み書きできで、データベースのように扱える 等と、他にもいろんな方法が考えられ、それぞれでプログラムが変わってきます
64Bit版のODBCデータソースアドミニストレーターで確認されたのですよね？！ ユーザーDSNに見える『MS Access Database』は32Bit版のが表示されているだけです。 『構成』ボタンを押してもエラーで叱られるだけです。 http://support.microsoft.com/kb/942976/ja より抜粋 「64 ビット版の ODBC アドミニストレーター ツールは、64 ビットのシステム DSN、32 ビットのユーザー DSN、および 64 ビットのユーザー DSN を表示します。」 繰り返しになりますが、ドライバータブを開いてそこにAccess 関連のドライバーがあるか確認を。 そのうえで OSとPerlの32/64Bitの明記も合わせてPerlカテゴリで再質問されては？ 環境を構築して検証しつつ回答できればよいのでしょうけどPerlは不明のため ミスリードが怖いのでこの辺が限界です。
Resumeステートメントで戻り先を指定します。 こんな感じです。 ErrorHandler： 　　・ 　　・ Resume　'←エラーが発生した命令から実行が再開されます。 Resume Next　'←エラーが発生した命令の次の命令からに再開されます。 Resume 行ラベル　'←指定した行ラベルへ戻ります。 　　・ 　　・　　'　それ以外にも、Exit SubやEnd等も記述可能だと思いますが、何も書かないと End Sub　'←ここにくるので、当プロシージャは終了します。 詳しくは、ヘルプを参照してください。
宛先がない。誰かが使っているから、既に開いて使用中の処理が途中なのに開こうしているから、という感じですね。 使用しているパソコン、また他者で開いていたパソコン　を　再起動してみてください。 起動は、時間差をつけて行わないとエラーしますので気を付けて。
「思うように動いてくれない」 とは、具体的にどうなってしまっているのでしょうか？ エラーが発生している場合 On Error Resume Next を削除して実行すればエラーの内容が確認できるはずです。 Access 2013 + Microsoft ProgressBar Control, version 6.0 Access 2010 + Microsoft ProgressBar Control, version 6.0 この 2種類ではうまく動きました。 Access 2010 + Microsoft ProgressBar Control, version 5.0 はエラーになりました。 「”実行時エラー '438' オブジェクトは、今プロパティまたはメソッドをサポートしていません。」 Data.Files にアクセスしたところでエラーになっているようでした。 それと、リスト ボックス コントロールのプロパティ 「値集合タイプ」 を 「値リスト」 に変更しておかなければファイルパスを追加するところでエラーになります。
失礼しました。Visual Basicのカテゴリだったため、VBAの方が良いのかなと思っていました。 VBAでなくてもよいのであれば、普通に「名前を付けて保存」の操作で可能です。 ピボットテーブルを作成したシートをアクティブにして、「ファイル」タグの「名前を付けて保存」 から、「ファイルの種類」で「ｃｓｖ」を選択して、保存してください。 何回かコーションが表示されますが、気にしないで保存してください。
品名と個別の組み合わせで重複はないという事でよろしいでしょうか リスト１は 　A　　　B　　　C 品名　　個別　　答え　 だとして リスト２の リンゴとa1のクロス部分に =INDEX($C:$C,SUMPRODUCT(($A:$A=$D2)*($B:$B=E$1)*ROW(A:A))) で右へコピー、下へコピーでは如何でしょうか。 SUMPRODUCT(($A:$A=$D2)*($B:$B=E$1)*ROW(A:A)) で、二つの条件があっている行の行番号が出ます。
悩める柴太郎さんの認識で、正しいですよ。 でもダメだったということですよね？ テキストボックスをシートに貼っているにも関わらず、コードを 標準モジュールに書いているとかですかね。 プロジェクトウィンドウに、Sheet1等があると思います。 テキストボックスの貼ってあるシートにコードを移してみてください。 マクロ記録では、標準モジュールにコードが生成されます。 それを上記と同じ要領で Sheet1等に移す必要があります。
ワイルドカードでの比較は、Like演算子を使います。 Deleteのワークシート名に、ワイルドカード指定はできません。 よって、こんな感じです。 If daaa.Name Like "*" & saaa & "*" Then daaa.Delete
ANo1です。 申し訳ないです。実は、VBSはほとんど知らないのですが、違ってたのかな？ ・・・ってんで、慌ててにわか勉強しならテストしてみました。 ご提示のサイトには残念ながらアクセスできない環境からなので、違うページでテストしています。 Dim objIE, elms Dim idx, res Set objIE = CreateObject("InternetExplorer.Application") objIE.Visible = True objIE.Navigate "http://www.data.jma.go.jp/obd/stats/data/mdrr/sy … Do Until objIE.readystate = 4 Wscript.Sleep 200 Loop Set elms = objIE.Document.GetElementsbyClassName("o0") res = "" For idx = 0 To 10 res = res & elms(idx).innerText & " , " Next MsgBox "Length=" & elms.Length & vbCrLf & res objIE.Quit Set objIE = Nothing ※ 気象庁のページですが、表中、地名の欄にクラス名「o0」が付いています。 上記を実行すると、 　Length= 164 　札幌 , 稚内 , 北見枝幸 , 旭川 , 留萌 , 羽幌 , 岩見沢 , 小樽 , 寿都 , 倶知安 , 網走 , のように、表中の最初の11の地名が表示されます。 それなので、要素は取得できていると考えても良さそうです。 上の例では文字列を取得していて属性値ではないところが違うと言えば違いますが、上記の要素には他に属性値がないので、 　res = res & elms(idx).className & " , " と、クラス名を取得してみると、（←バカバカしいですが） 　o0 , o0 , o0 ・・・・・ となりますので、予想通り属性値も取得できるようです。 ということで、こちらで試した範囲ではANo1でいけそうに思えるのですが・・・ 何ぶんにもにわか勉強の者なので、どこかに間違いがあるのかも知れません。 ＞Lengthで要素の数が返ってくるのに、配列ではないということはあるのでしょうか？ GetElementsbyClassNameが返すものは、要素リスト（NodeList）と言われるもので、DOM要素と直結した「活きた」リストです。（純粋な配列とは違います） 読み出して使う範囲では、ほぼ配列と同じ扱いができたはずです。 ＜参考＞ http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-2 …
Wscript Arguements について調べてみてください。 https://msdn.microsoft.com/ja-jp/library/cc36447 … のVBScriptを、Q.vbs とかの名前で保存します。 Excel VBA からは Shell "wscript.exe C:\test\Q.vbs ""aa"" "" bb" などと実行すると、aa bb が渡されて aaとbbが返ってきます。
処理の確認 1　多年度表を今年度表にコピー貼り付けする 2　今年度シートから他の年度の行、と四文字熟語の行 （この表では、3、4、　6、7、　9、10行）を削除 3　今年度シートから年度の列と合計の列を削除 で良いのかな 回答は、マクロになります。
No.1(kmeeさん）の回答にGoodをポッチったママチャリです。 と言っても放置するのは忍びないので、タダでできる範囲まで仕様を落として回答させて頂きます。 仕様を落とした点は、次の通りです。 要求仕様）重複する場合、連番を付加する。 実装仕様）重複の有無に関わらず、日時を付加してユニークにする。 それから、“バグありYYYYMMDD-HHMMSS”は、ファイル名の前に付けました。 （この方がファイルマネージャで見たときに便利？） どうしても後ろにつけたい場合は、そのための命令もコメントとして記述しました。 必要に応じて、コメントを外してください。 'ーーーーーーーーーここのマクロをつくってほしいーーーーーーーーー Dim MyPath As String, MyFile As Variant MyPath = "E:\コスモス2006リンクフォルダ\体温表\" & Year(Now) & "\" MyFile = Split(OpenFileName, "\", -1) MyFile = MyFile(UBound(MyFile)) '↓ファイル名の前に日付を付ける場合は、こちらで↓ MyFile = "バグあり_" & Format(Now(), "yyyymmdd-hhmmss") & "_" & MyFile '↓ファイル名の後ろに日付を付ける場合は、こちらで↓ 'MyFile = Replace(MyFile, ".xlsm", "_バグあり(" & Format(Now(), "yyyymmdd-hhmmss") & ").xlsm") Name OpenFileName As MyPath & "※バグあり分\" & MyFile FileCopy MyPath & "※原本\新体温表色あり.xlsm", OpenFileName 'ーーーーーーーーーーーーーーー以上ーーーーーーーーーーーーーーー
こんな感じで如何でしょう。 --------------------------- Sub aaa() Dim r As Range Dim area As Range Dim idx As Long Dim color(4) As Long color(0) = RGB(&HFF, &HFF, 0) ' 黄色 color(1) = RGB(&HFF, &H99, 0) ' オレンジ color(2) = RGB(&HAA, &HFF, 0) ' 黄緑 color(3) = RGB(&HAA, 0, &HFF) ' 紫 For Each r In Range("B3:GN62") ' 塗りつぶし範囲 idx = 0 Set area = Range("A2:A12") ' 条件エリアの初期値をセット Do While (area.Column < 5) ' 条件エリアがD列まで繰り返す If searchValue(r.Value, area) Then r.Interior.color = color(idx) Exit Do End If idx = idx + 1 Set area = area.Offset(0, 1) ' 条件エリアを一つ右へ Loop Next End Sub ' area内のnumの値のセルがあればtrue, 無ければfalse Function searchValue(num As Long, area As Range) As Boolean Dim r As Range For Each r In area If (r.Value <> "") And (num = CLng(r.Value)) Then searchValue = True Exit Function End If Next searchValue = False End Function
MsgBox (Replace(Sheets("Sheet1").Cells(1, 1).Value, "私", Sheets("Sheet2").Cells(1, 1).Value)) とかですか。
とりあえず以下の仕様で作成してみました。 ・ブックを開くタイミングでその月のシートが無ければシートのコピーを行う ・ブックを閉じるタイミングで、backup_yymmdd_を付加したバックアップを同じフォルダに作成する。 　既にバックアップファイルがある場合は上書きします。 　別のフォルダに作成するときは、変数pthの値を適宜変更して下さい。 下記はThisWorkbookに入力して下さい。 Private Sub Workbook_BeforeClose(Cancel As Boolean) Dim pth As String Dim fName As String Dim fDate As String Dim t As Date: t = Date If Cancel Then Exit Sub End If fDate = Right("0" & Year(t), 2) _ & Right("0" & Month(t), 2) _ & Right("0" & Day(t), 2) pth = ThisWorkbook.path fName = ThisWorkbook.name Application.DisplayAlerts = False ThisWorkbook.SaveAs (pth & "\" & "Backup_" & fDate & "_" & fName) Application.DisplayAlerts = True End Sub Private Sub Workbook_Open() Dim ws As Worksheet Dim m As String Dim wsExist As Boolean: wsExist = False m = Month(Date) & "月" For Each ws In Worksheets If ws.name = m Then wsExist = True Exit For End If Next If wsExist = False Then ThisWorkbook.Worksheets("テンプレート").Copy _ before:=ThisWorkbook.Worksheets("テンプレート") ActiveSheet.name = m End If End Sub
こんにちは VBSをほとんど知らないので、正しくはないかもしれないけれど、 想像するところ、ハンドラへの参照を設定しなければならないはずなので… 　Sub Sample1 　　Set button1.onclick = GetRef("Sample2") 　　msgbox "Sample1" 　End Sub 　Sub Sample2 　　msgbox "Sample2" 　End Sub とかで、いけるんではないでしょうか？
>挿入された図の名前がPicture1と分ってないと選択出来ません。他に方法あるのでしょうか？ Pasteする際に、Excelが勝手につけた名前を変数に保存して、その名前でSelectすることができます。 名前の保存は、こんな感じで。 MyPicName = ActiveSheet.Pictures.Paste.Name　　’Pasteと同時に、その名前を変数に代入します。
①②について、 </script>という文字があるとダメみたいですね。たぶんsample1.htaの冒頭の<script ～>に対応する閉じタグと誤認識されるではないかと。 スクリプトを書くエリアの部分を以下にしたらOKでした。 ------------------- <html> <head> <script language="vbscript"> ' ここは元のままでも良いかも <!-- ' htmlのコメント開始の記号を追加する 　ここにvbscriptを書く --> ' htmlのコメント終了の記号を追加する </script> </head> <body> 以下略 ----------------------------- ③④について sh.runの第三引数をtrueにすると起動したプログラム(mshta.exe)が終了するまで、スクリプトの実行が停止するので、その直後でファイル削除してもイケます。 詳細はMSDNを参照してくだい（https://msdn.microsoft.com/ja-jp/library/cc36442 …） ----------------------------- sh.run "mshta.exe C:\sample2.hta", 1, true fso.deletefile "C:\sample2.hta" -----------------------------
こんな感じでしょうか？ 勘違いがあったらすみません。 ------------------------------------- Dim target As Range Dim srcArea As Range ' 最初の計算結果を書き込むセル Set target = Worksheets("テスト2").Range("B7") ' 最初のSubTotal対象範囲 Set srcArea = Worksheets("テスト1").Range("AC:AC") Worksheets("テスト1").Range("A:XFD").AutoFilter Field:=1, Criteria1:="4月" ' 書き込むセルが J列になるまで繰り返す Do While (target.Column < 14) ' 計算範囲の合計を指定セルに書く target.Value = WorksheetFunction.Subtotal(9, srcArea) ' 計算結果を書き込むセルを右へずらす Set target = target.Offset(0, 1) ' SubTotal対象範囲を左へずらす Set srcArea = srcArea.Offset(0, -1) Loop
こんにちは あちこちのセルに式が設定してある場合に、誤操作やうっかりミスで式を上書きしたり消してしまったりすることの防止としても、シートの保護は有効だと思います。 マクロの実行時にセル操作ができないとのご指摘だと思いますが・・・ ＞保護の解除や実行をVBAからやれなくはないのかもしれませんが～ 保護の解除/設定のメソッドが用意されていますので、簡単に可能ですよ。 マクロからセルの操作を行う前に解除して、操作が終わったら再設定といった感じにすればよいでしょう。 それぞれ1行を追加するだけですみます。 具体的には、 　　　　～～～～ 　ActiveSheet.Unprotect Password:="hogehoge" 'パスワード設定がある場合 　　' セルの値を操作する処理 　ActiveSheet.Protect Password:="hogehoge" 　　　　～～～～ のような感じで実現できるはずです。 以下は書式等のご参考に。 https://msdn.microsoft.com/ja-jp/library/office/ … https://msdn.microsoft.com/ja-jp/library/office/ …
IShellDispatch.Openメソッドは参照を返す訳ではないので、何れにしても、IShellWindowsによる検索が必要でしょうね。 https://gist.github.com/kumatti1/2222dcaabf4f14b …
> A15に入力すると、E15だけ実行できる方法などありますか？ こんな感じどうでしょう？ A1以外のA列の変化時のみ動作させます。 Private Sub Worksheet_Change(ByVal Target As Range) Dim dest As Range If (Target.Column <> 1) Or (Target.row = 1) Then Exit Sub End If Set dest = Target.Offset(0, 4) With dest .Value = Target.Value .Font.name = "BC39" .Font.size = 30 .HorizontalAlignment = xlCenter End With End Sub
Dim saa As String Top: ←追加 saa = InputBox("実行する日付を入力して下さい" & vbCrLf & "入力例）2016/03/17（半角入力）", "日付入力") If saa = "" Then Exit Sub If Not IsDate(saa) Then　←修正 MsgBox "日付の入力が間違っています" & vbCrLf & "2016/01/07のように入力して下さい", 16 GoTo Top ←追加 End If
こんな感じですかね。 Sub Sample() 　　Dim test As Collection 　　Dim tmp(0, 9) As String 　　Dim ary As Variant 　　Dim i As Integer 　　Set test = New Collection 　　tmp(0, 0) = "test" 　　tmp(0, 1) = "56" 　　test.Add tmp 　　tmp(0, 0) = "test2" 　　tmp(0, 1) = "tttt" 　　 test.Add tmp 　　tmp(0, 0) = "test3" 　　tmp(0, 1) = "zzz" 　　test.Add tmp 　　Debug.Print "データ数 : " & test.Count 　　For Each ary In test 　　　　Debug.Print ary(0, 0) 　　　　Debug.Print ary(0, 1) 　　Next 　　Worksheets.Add Before:=Worksheets(1) 　　For i = 1 To test.Count 　　　　Range(Cells(i, 1), Cells(i, 10)) = test(i) 　　Next 　　Worksheets.Add Before:=Worksheets(1) 　　For i = 1 To test.Count 　　　　ary = test(i) 　　　　Range(Cells(1, i * 2), Cells(10, i * 2)) = WorksheetFunction.Transpose(ary) 　　Next End Sub
N0.4の回答で一部誤りをしていました。 前の回答では、1月のシートのとき、G50のセルでエラーを起こします。 次のように、修正します。 《ThisWorkbookのモジュール：前の回答と同じ内容》 Private Sub Workbook_Open() Application.ScreenUpdating = False Range("D50").Select skip TB_S TB_T Application.ScreenUpdating = True End Sub 《どこかの標準モジュール：例えば　Module2》 Public TbS(1 To 7, 1 To 2) As Integer Public TbT(1 To 6, 1 To 2) As Integer Sub skip() Application.OnKey "~", "macro_new" Application.OnKey "{enter}", "macro_new" End Sub Sub TB_S() TbS(1, 1) = 0: TbS(1, 2) = 2 TbS(2, 1) = 1: TbS(2, 2) = 0 TbS(3, 1) = 0: TbS(3, 2) = 1 TbS(4, 1) = -1: TbS(4, 2) = 2 TbS(5, 1) = 1: TbS(5, 2) = 0 TbS(6, 1) = 0: TbS(6, 2) = 1 TbS(7, 1) = 1: TbS(7, 2) = 0 End Sub Sub TB_T() TbT(1, 1) = 0: TbT(1, 2) = 2 TbT(2, 1) = 1: TbT(2, 2) = 0 TbT(3, 1) = 0: TbT(3, 2) = 2 TbT(4, 1) = 1: TbT(4, 2) = 0 TbT(5, 1) = 0: TbT(5, 2) = 1 TbT(6, 1) = 1: TbT(6, 2) = -5 End Sub Sub macro_new() mr = ActiveCell.Row: mc = ActiveCell.Column ma = ActiveCell.Address(0, 0) If ma = "C28" Then Range("J50").Select: Exit Sub If ma = "G50" Then hhf = Replace(ActiveSheet.Name, "月", "") hhg = (Val(hhf) - 1) If hhg = 0 Then Range("C28").Select: Exit Sub ' 　この上の一行が抜けていたので、修正追加した Worksheets(hhg & "月").Activate hhh = Range("h47") & "/" & hhg & "/1" hhi = Day(WorksheetFunction.EoMonth(DateValue(hhh), 0)) + 49 Cells(hhi, 10).Select: Exit Sub End If If ma = "I80" Then Range("J81").Select: Exit Sub If mr > 49 And mr < 81 And mc > 3 And mc < 11 Then mcs = mc - 3 ActiveCell.Offset(TbS(mcs, 1), TbS(mcs, 2)).Select Exit Sub gfh = jjhg End If If mr > 49 And mr < 110 And mc > 12 And mc < 43 Then ccl = Int((mc - 12) / 8) * 8 + 12: ccr = ccl + 7 rru = Int((mr - 49) / 8) * 8 + 49: rrd = rru + 5 be = Cells(rrd - 1, ccr - 1).Address(0, 0) If mr > 105 And mc > 36 Then ActiveCell.Offset(1, 0).Select: Exit Sub End If If mr < rrd And mr > rru And mc > ccl And mc < ccr Then If ma = be Then Exit Sub mcs = mc - ccl ActiveCell.Offset(TbT(mcs, 1), TbT(mcs, 2)).Select Exit Sub End If ActiveCell.Offset(1, 0).Select Exit Sub End If ActiveCell.Offset(1, 0).Select End Sub
差出がましいですが 毎日シートが増えて、毎月ファイルが増えるような構成は 初心者が陥りやすい誤ったシート構成です。 エクセルをワープロ代わりに使うと後々、大変な目にあいます。 日報のシートと 日報に必要なデータのシートの２枚の構成にします。 データのシートに必要な情報を日付と一緒に入力していき 日報のシートで日付を指定すれば 所定のフォーマットの表示になる方法を考えます。 後々、月単位の合計、年単位の集計などに使えます。
https://gist.github.com/kumatti1/25c9118ba867784 … 既に回答が出されてますが、最前面がSetWindowPosのHWND_TOPMOSTを指すならご検討ください。
こんにちは、 より速く・簡潔に。ということですが、設定をしている行が多いですね。これだけでは、不要行が判断できません。 単に、行を短くしたいだけなら、定型の設定を一行にまとめるだけでも見やすくなるかと思います（見る人によりけりですが）。 Application.Visible = False Application.WindowState = xlMinimized Application.DisplayAlerts = False （上の３行を１行にまとめた場合） With Application: .Visible = False: .WindowState = xlMinimized: .DisplayAlerts = False: End With あと、「Application.ScreenUpdating=...」は、いらないかと思います。 では
まずは、シートイベントを使ってください。 一例です。 指定したいシート名のタブを右クリックして コードの表示をクリックして、VBエディターを起動します。 この時点でシートモジュールが選択されています。 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Column < 6 Then Target.Offset(0, 1).Activate End If End Sub を張り付けて閉じてみてください。 意味は、6列目までで、セルの内容が変更されたら 右隣のセルをアクティブにするという意味です。
Sub シートの選択() If Range("H133") >= 1 And Range("H133") <= 12 Then Worksheets(Range("H133") & "月").Select End If If Range("F1") <> Range("H1") Then MsgBox "この体温表は " & Range("F1") & " 年分です。" & vbCrLf & "　　 (現在は " & Range("H134") & " です)" Worksheets("1月").Select End If End Sub
If VarType(Selection) = vbObject Then
Dim 時 As String Dim 分 As String として 時 = Hour(DateAdd("s", -1, Time)) '1秒前の時刻部分を抽出 分 = Minute(DateAdd("s", -1, Time)) '1秒前の分を抽出 分 = "00" & (分 \ 30) * 30　'30単位に整列 分 = Right(分, 2)　'０だけを考慮 ActiveCell.Value = 時 & ":" & 分
#1の回答者です。 集計表は、うまく出来たでしょうか。 >'Set ws2 = ThisWorkbook.Sheets("Sheet2") >'拡張子はバージョンに合せる　.xls　.xlsx >先頭に「’」がついてコメントとなっていくのはなぜですか？ >'Set ws2 = ThisWorkbook.Sheets("Sheet2")は テストの時に、別のブックを作るのが面倒なので、その時の名残です。 >'拡張子はバージョンに合せる　.xls　.xlsxは Excelのバージョンが、2007以上だと、.xlsx　2003以下だと、.xlsということは解りますよね。 だから、Excel2007以上だったら、.xlsを.xlsx書き換えてほしいのです。 >ws1とws2はそれぞれ同じブックのシートを指しているのでしょうか？ Set ws1 = ThisWorkbook.Sheets("Sheet1") のコードで、このマクロの書いてあるブックのシートを指しています。 Set ws2 = Workbooks("集計表.xls").Sheets("Sheet1") のコードで、集計表.xlsブックのシートを指しています。
誤解しているかもしれませんが、シート１やシート２、シート３に入力したり、修正した作業を、そのシート名とアドレス、最終的な内容をすべてシート３に一覧になるように記録し、BOOKを閉じるときに、シート３だけを保存するということでしょうか。 そうだとすると、 シート毎に次のコードを入れておく 《Sheet1》の場合 Private Sub Worksheet_Change(ByVal Target As Range) Dim LastRow As Long Application.EnableEvents = False LastRow = Worksheets("Sheet3").Range("A50000").End(xlUp).Row + 1 Worksheets("Sheet3").Range("A" & LastRow) = Time Worksheets("Sheet3").Range("B" & LastRow) = Target.Address(xlA1) Worksheets("Sheet3").Range("C" & LastRow) = Target.Value Worksheets("Sheet3").Range("D" & LastRow) = "Sheet1"　　 ’（シート２の場合は"Sheet1"　シート３の場合は"Sheet3"） Application.EnableEvents = True End Sub ThisBOOKに次のコードを入れておく Private Sub Workbook_BeforeClose(Cancel As Boolean) Application.Calculation = xlCalculationManual Dim myname As String myname = ThisWorkbook.Name Dim xSheet As Worksheet Set xSheet = ThisWorkbook.Worksheets("Sheet3") mejirusi = Format(Now(), "ddhhnnssss") xSheet.Range("C1") = mejirusi myFileName = "sheet_copy_" & mejirusi & ".xlsx" xSheet.Copy Application.DisplayAlerts = False ActiveWorkbook.SaveAs Filename:=ThisWorkbook.Path & "\" & myFileName MsgBox "Sheet3を " & "sheet_copy_" & mejirusi & ".xlsx と保存しました" If ActiveWorkbook.Name = myFileName Then ActiveWorkbook.Close SaveChanges:=False End If Application.DisplayAlerts = False Workbooks(myname).Close SaveChanges:=False End Sub そうすると、このブックを保存してあったフォルダに、（このブックを閉じると）Sheet3だけが、保存されます。
ご質問文でよくわからないところがありますが・・・ とりあえずこんな感じでしょうか？ （変更というよりは別の形ですが…） Sub TEST() 　Dim str As String, v As Long 　Dim rng As Range, c As Range 　Set c = ActiveCell 　str = InputBox("挿入行数を入力してください", "行の追加", "1") 　If c.Row > 1 And IsNumeric(str) Then 　　v = Int(Val(str)) 　　If v > 0 Then 　　　ActiveSheet.Unprotect Password:="0000" 　　　Set rng = c.Offset(1, 0).Resize(v, 1).EntireRow 　　　c.EntireRow.Copy 　　　rng.Insert 　　　rng.Offset(-v, 0).SpecialCells(xlCellTypeConstants).ClearContents 　　　c.Select 　　　ActiveSheet.Protect Password:="0000" 　　End If 　End If End Sub ※ ご提示のコードの変更で実現なさりたい場合は、ご提示の内容を指定行数分繰り返すようにすればよろしいかと思います。 　　繰り返しは、例えば For ～～ Next などで実現できます。
望みのシートのシートモジュールに書いて下さい。 ＞各行ごとに実行できればと思っております。 全セルに対して自動実行されます。 Private Sub Worksheet_Change(ByVal Target As Range) Dim c As Range For Each c In Target If IsNumeric(c.Value) And c.Value > 10 Then c.Value = 0 End If Next End Sub 手入力やマクロにより入力されても対応しますが、関数入力されると関数が優先になります。
最近の若い人の特徴かな？。余計な文章が多くて何を言いたいのか要点がさっぱり伝わらない。 素直に頼みたい内容だけ書けばいいのに。こんな書き方が面白いとでも思っているのかい？。 大きなお世話かもしれないけど、他人を不快にさせるだけだよ。 と言いつつ、答えてみる。 Sub Macro1() Dim i As Integer Dim z As Integer z = 3 For i = 1 To 260 Range(Cells(17, i), Cells(26, i)).Select Selection.Cut Cells(4, z).Select ActiveSheet.Paste ActiveWorkbook.Worksheets("Sheet1").Sort.SortFields.Clear ActiveWorkbook.Worksheets("Sheet1").Sort.SortFields.Add Key:=Cells(4, z), _ SortOn:=xlSortOnValues, Order:=xlDescending, DataOption:=xlSortNormal With ActiveWorkbook.Worksheets("Sheet1").Sort .SetRange Range(Cells(4, z), Cells(13, z)) .Header = xlNo .MatchCase = False .Orientation = xlTopToBottom .SortMethod = xlPinYin .Apply End With z = z + 4 Next End Sub ※ 列数が多いので当然 Excel 2007 以上の xlsm 型式じゃないと使えません。 ※ この例では１列移動するたびに降順の並べ替え処理をしています。 　　全て移動してから、あらためて降順処理をしたいのであればご自分で改造して下さい。
あらま、こちらにも同じような質問をされていましたね。 とりあえず If Target.Address = "$A$2" Then If Range("C2").Value = "A" Then で試してみて・・・
No2です。 > 変数のとこにセミコロンがあるのはどういう意味なんでしょうか。なにかウルトラC的な要素があるのかな？ 改行せずに同じ行に次の文を書く場合には、コロンで区切ります。 私は、変数の初期設定をするときに、忘れない様に宣言と同じ行に書くようにしているだけで この様に書かなくてはいけないということではありません。
＃２です 気を悪くされたらごめんなさい > Dim r1, r2 As Integer この部分は、以下と同じ？ Dim r1 As Variant, r2 As Integer > 行数は70000行あります。 より Dim r1 As Long, r2 As Long が良いかも？です 似た処理で記述してみました Public Sub Samp2() 　　Dim r1 As Range, r2 As Range 　　Dim sPath As String 　　Dim bGo As Boolean 　　Const CCHK As Long = 66666 　　With Application.FileDialog(msoFileDialogFolderPicker) 　　　　If (Not .Show) Then Exit Sub 　　　　sPath = .SelectedItems(1) & "\" 　　End With 　　Application.ScreenUpdating = False 　　Application.DisplayAlerts = False 　　With Range("A1", Cells(Rows.Count, "A").End(xlUp)) 　　　　bGo = True 　　　　Set r1 = .Cells(.Rows.Count) 　　　　Set r2 = .Find(CCHK, r1, LookAt:=xlWhole) 　　　　While ((Not r2 Is Nothing) And (bGo)) 　　　　　　Set r1 = r2 　　　　　　Set r2 = .FindNext(r1) 　　　　　　If (r1.Row >= r2.Row) Then 　　　　　　　　Set r2 = .Cells(.Rows.Count).Offset(1) 　　　　　　　　bGo = False 　　　　　　End If 　　　　　　If (r2.Row - r1.Row > 1) Then 　　　　　　　　With Workbooks.Add 　　　　　　　　　　Range(r1.Offset(1), r2.Offset(-1)) _ 　　　　　　　　　　　　.Resize(, 6).Copy .Worksheets(1).Range("A1") 　　　　　　　　　　.SaveAs sPath & r1.Offset(, 1).Value 　　　　　　　　　　.Close False 　　　　　　　　End With 　　　　　　End If 　　　　Wend 　　End With 　　Application.DisplayAlerts = True 　　Application.ScreenUpdating = True End Sub ※ > 　　Application.DisplayAlerts = False を追加して、同じファイル名があった際には、強制上書きするように （上書きしますか？メッセージは出てこない） Resize(, 6)　で、６列分を Copy してましたが、 EntireRow　に変更すると、その行全部になります ※ ・都度、新規ファイルを Add / Close した方が良いのか、 ・使いまわしした方が良いのか どちらが軽い処理なのかわかりません ５０ファイル程度で、Samp1 / Samp2 さほど時間差ないみたい･･･ 以下は簡易確認用データ作成（A,B列だけの） Public Sub testData() 　　Dim i As Long, j As Long, k As Long '　　Const CLINES As Long = 70000 　　Const CLINES As Long = 2000 　　Const CCHK As Long = 66666 　　Randomize 　　Application.ScreenUpdating = False 　　Cells.Delete 　　i = 1 　　k = 101 　　While (i <= CLINES) 　　　　With Cells(i, "A").Resize(, 2) 　　　　　　.Value = Array(CCHK, k) 　　　　　　For j = 1 To Int(100 * Rnd()) + 1 　　　　　　　　With .Offset(j) 　　　　　　　　　　.Value = Array(k, .Address(False, False)) 　　　　　　　　End With 　　　　　　Next 　　　　　　i = i + j 　　　　　　k = k + 1 　　　　End With 　　Wend 　　Application.ScreenUpdating = True End Sub
試した訳ではないですが、MSDNのサイトを見ると・・・。 ZipFile.CreateFromDirectory https://msdn.microsoft.com/ja-jp/library/hh485707(v=vs.110).aspx これで、フォルダから簡単にZIPが作成出来るので、サンプルが多いのではないでしょうか？ ZipFileExtensions.CreateEntryFromFile メソッド https://msdn.microsoft.com/ja-jp/library/hh485720(v=vs.110).aspx このメソッドで一つのファイルを圧縮出来そうに見えますが？？？
何がやりたいのか意味不明ですが・・・。 ＞Dim Word() As Variant ＞Word(i) = "UserForm2.Label" & i Wordには、文字列を代入しているのでVariant宣言する意味が不明。 ＞With Word(i) ＞.Caption = "Sample" & i ＞.Font.Name = "ＭＳ Ｐゴシック" ＞.Font.Size = 11 ＞End With WordがStringなのに、「.Caption」「.Font.Name」などのプロパティメソッドにアクセスしているのが意味不明。 フォーム「UserForm2」が存在し、そのフォームにラベルを追加する。 との事だとして、以下のようにすればどうですか？ Sub test2() Dim i As Long For i = 1 To 20 With UserForm2.Controls.Add("Forms.Label.1", "Label" & i, True) .Top = i * 10 .Left = 0 .Caption = .Name .Font.Name = "ＭＳ Ｐゴシック" .Font.Size = 11 End With Next UserForm2.Show vbModeless End Sub
＃２です。コメント拝見しました。 ちょっと改造したうえで、説明用のコメントを追加しています。 前回同様、1行目は見出し行と考えています。 最後の吐き出し先はC列のままとしていますが、適宜いじってください。 B、C、K列の列番号は、それぞれ、２、３、１１です。 '--------------------------------------------------------------------------- Option Explicit Sub 非重複抽出() '変数宣言とセット Dim r As Long, k As Long, myStr As String Dim Dic As Object, myKeys As Variant Dim WSF As Object, Lstrow As Long Set Dic = CreateObject("Scripting.Dictionary") Set WSF = Application.WorksheetFunction 'B列K列のデータから非重複のリストを作成 r = 2 '2行目から下に、B列を見に行き、初めて出てきた品名をDicに格納 Do While Cells(r, 2).Value <> "" 'B列（列番２） 　myStr = Cells(r, 2).Value　　　　'B列（列番２） 　If Not Dic.Exists(myStr) Then 　　Dic.Add myStr, myStr 　End If 　r = r + 1 Loop r = 2 '2行目から下に、K列を見に行き、初めて出てきた品名をDicに格納 Do While Cells(r, 11).Value <> "" 'K列（列番11） 　myStr = Cells(r, 11).Value 　If Not Dic.Exists(myStr) Then 　　Dic.Add myStr, myStr 　End If 　r = r + 1 Loop myKeys = Dic.Keys '出来上がったDicの結果を、配列 myKeysとする '配列 myKeysを順に見ていき、その中から、B列またはK列にしか存在しないものを列記（BK両方にあるものは無視） For k = 0 To UBound(myKeys) 'myKeysの値をすべてループ 'CountIf関数を用いて、B列（列番２）の個数が0 または、K列（列番11)の個数が0ならば転記（それ以外はスルー） 　If WSF.CountIf(Columns(2), myKeys(k)) = 0 Or WSF.CountIf(Columns(11), myKeys(k)) = 0 Then 　　Lstrow = Cells(Rows.Count, 3).End(xlUp).Row + 1 '転記先はC列（列番３） 　　Cells(Lstrow, 3).Value = myKeys(k) 'C列（列番３） 　End If Next k Set Dic = Nothing Set WSF = Nothing MsgBox "End." End Sub '----------------------------------------------------- このマクロを実行するには、先の回答通り、Alt+F8 から行ってください。 あるいは、ボタンに登録したほうが楽かもしれません。念のため登録方法は以下。 １）エクセル上部のリボンから「開発」タブを選択 　「開発」が出ていない場合は、ファイル＞オプション＞リボンのユーザー設定＞右半分の「メインタブ」のところで「開発」にチェック ２）「挿入」ボタン。道具箱にトンカチとスパナがクロスした絵のやつ。 ３）フォームコントロール。左上の「ボタン」をクリックし、シート上で適当な大きさにするようドラッグ ４）マクロの登録　となりますので、「非重複抽出」を登録すればOK ボタン名が「ボタン１」などとイケていないので、ボタンの上で右クリック、「ボタン１」のあたりで左クリックすれば変更可能。 ホントは、C列の前回結果を消去するフローも入れたほうがより楽でしょうが、詳細が分からないので対応していません。 学習がてら適宜対応ください。
回答が難しいです。 ＞何となく入れ替えたりしてみましたが、上手く出来ませんでした。 　プログラムは「何となく入れ替えたりしてみましたが、・・・」では組めませんし動きません。まず設計をしたり処理の流れを追っていきます。 ＞入力された値で検索であいまい検索して表示させる方法が分りません。 　「あいまい検索」って簡単に言われても・・・。 　本来は難易度がむちゃくちゃ高い内容だったりもします。 　一致検索は可能でしょうか？ 2008に拘るのであればこういった書籍なのだろうか？自身は中身を確認していないので無闇とは薦めません。興味がありましたら書店へどうぞ。 http://www.amazon.co.jp/%E7%8B%AC%E7%BF%92Visual … 　何かと便利な逆引き辞書です。 ＞VisualBasic2008逆引き大全555の極意 ＞http://www.amazon.co.jp/VisualBasic2008%E9%80%86 … 　参考になればと思います。
マクロでやる必要があるのでしょうか？ Sub Sample() Cells(1, 1) = DateAdd("m", 1, Cells(1, 2)) End Sub で、表されますが。 単にA1へ、B1に入力された翌月の日付を返したいのであれば、関数を用いて =DATE(YEAR(B1),MONTH(B1)+1,DAY(B1)) と入力するだけです。
すいません、グラフシートと書いてましたね。 グラフシートは常に最大サイズなので変更は出来ません。 どうしてもサイズを変えたいならワークシート上でグラフを配置するしかありません。
こんにちは、No.1です。 > Set ws = Sheets(name) > で「インデックスが有効範囲にありません」というエラーが出て自力では解決できませんでした。 これは、この行が実行される時点で、変数nameの値が未定になっているので、 「未定」という名前のシートは無いよ！というエラーになります。 あと、No.1のソースですが、Ａ○シートに対応する○シートがなかった場合のエラーメッセージ表示を追加したものを以下に書きますので、参考にしてください。 ------------------------------------------------------------------ Sub foo() On Error GoTo ERR_TRAP Dim name As String With ActiveWorkbook If Left(ActiveSheet.name, 1) <> "A" Then MsgBox "現在アクティブなシートのシート名にAがついていません。", vbExclamation Exit Sub End If name = Mid(ActiveSheet.name, 2) .Worksheets(name).Range("A1").Value _ = ActiveSheet.Range("A1").Value + ActiveSheet.Range("A2").Value End With GoTo LAST ERR_TRAP: MsgBox ActiveSheet.name & "に対応するA無しシートがありません。", vbExclamation LAST: End Sub
まず配列があるプログラム共通ですが、絶対的な配列の限界としてaaa(xxxxx)のxxxxxに限界があります xxxxxはプログラム上変数として扱われており、変数が扱える数の限界が存在します その限界が"132813299"だと思われます 変数の限界に関してはVBAならIntegerやLongなどを調べると記載されていますが、元から変数としての最大値が決定されているため、メモリにどれだけ余裕があろうとそれ以上取る事はできません そのため配列を増やすと変数の上限は回避できます ここからは完全に予測なりますが、前述のとおり配列の数を表すのにも変数が使われております そして変数は型を宣言した時点で、通常はメモリが確保されています 特に動的配列は配列の数を変更する度に、使用するメモリサイズを宣言しなおしているため、動的配列として扱えてます ここで問題となるのは事前に確保されるメモリの話で10個程度の配列を表すのに、"132813299"の数を表せる変数を使うのはメモリの無駄です ですから無駄を避けるためには、小さ目の型でメモリを確保して置き、後から必要となった際に大きな型に変更する処理を行っていると思われます この結果、配列の数を表す変数に大きくメモリサイズが消費されていない細かく分割した3番目のケースが最も効率よく配列を多く取れたとしても不自然ではありません 配列の大きさで変わる原因としては以上が考えられます 最もシステムのメモリ使用状態が同一であると仮定した上での話ですから、複数回試さないと確実とは言えません
＃４です ご迷惑をおかけしました 私より先に回答つける方がいるかと思いましたが･･･ 解決されていましたでしょうか？ 解決に結びつくかわかりませんが、以下でデータを確認してみませんか ★部分を 6:00 の範囲に設定して実行すると、 値の重複を排除しながら違う値が出現した初めのセル番地を覚えておき、最後に出力します （結果はイミディエイトウィンドウに） Public Sub testData() 　　Dim dic As Object 　　Dim r As Range 　　Dim v As Variant 　　Set dic = CreateObject("Scripting.Dictionary") 　　For Each r In Range("B1:B1500") ' ★ 　　　　v = r.Value 　　　　If (v <> "") Then 　　　　　　If (Not dic.Exists(v)) Then 　　　　　　　　dic(v) = r.Address(False, False) 　　　　　　End If 　　　　End If 　　Next 　　Debug.Print ">> 値の個数"; dic.Count 　　On Error Resume Next 　　For Each v In dic.Keys 　　　　Debug.Print dic(v), v, 　　　　Debug.Print CDate(v), 　　　　Debug.Print 　　Next 　　Set dic = Nothing End Sub ここで、値の個数が１個の場合、解決方法等まったくわかりません ただ、複数個の場合、 > With ActiveWorkbook.Worksheets("シフトコード") ' ▲▲ > 　　.Range("L4") = TextBox1.Value > End With > Dim ret As Variant > Dim myTime As Double > With ActiveSheet ' ▲▲ > 　　myTime = .Range("L4").Value より、Range("L4").Value　が異なるシートを指していて、 たまたま異なる値が入っていて、たまたま一致したとか？ Find で出来るそうなので Match → Find に変えてやってみるとか？ 補足に提示されたデータを貼り付けたものでは 　　myTime = #6:00:00 AM#　後の Match で WA84 の所が選択されましたが、 ＃４でのシートでは、エラー 2042 で確認できませんでした（ 2007 ） こう記述すると、おかしいように思えるかもしれませんが、 ＃４のシートには 6:00 は無いので･･･ 方法を提示された方の補足に記述されると、早い回答が得られるかも 回答者の多くは、 > そのスレが解決するということが第一 と考えられている人が多いのか･･･と期待はしています 余談） ＃４での　Format(XXX,"yyyymmddhhnnss")　で変換してから･･･ これ、Access でも比較できない時があって、対処した方法だったので紹介してみました ブログにチョット書いてましたが、URL 記述できないので･･･ Excel って賢いのですね 失礼しました
直接の回答ではありませんが、SQL側で制限するのはどうですか？ SQLSTR = "SELECT * FROM csvファイル名 WHERE UID BETWEEN 1 AND 10" 　　　※ UIDは、csvファイル内のユニークな値のフィールド（列）です。
とりあえず以下で如何でしょう？ マクロfooを実行すると、選択されているブックの各シートA○のセルA1とセルA2の合計を、対応するシート○のセルA1に書きます。シート○が存在しない場合はメッセージを表示します。 > シートA○のセルA1とセルA2に数字を入力したら、シート○のA1にシートA○のセルA1とセルA2の合計が自動入力される 数字を入力したら自動で計算・入力させる様にするには、各A○シートにコードを記入する必要があります。ですから、そのシートを削除することにある用途での使用は現実的でないと思います。 ----------------------------------------------------- Sub foo() Dim dic As Object Dim ws As Worksheet Dim name As String Set dic = CreateObject("Scripting.Dictionary") With ActiveWorkbook ' A無しシートの存在チェック For Each ws In .Worksheets If Left(ws.name, 1) <> "A" Then dic(ws.name) = True End If Next ' 計算＆記入 For Each ws In .Worksheets If Left(ws.name, 1) = "A" Then name = Mid(ws.name, 2) If Not dic.Exists(name) Then MsgBox name & "シートがありません", vbExclamation Else .Worksheets(name).Range("A1").Value _ = ws.Range("A1").Value + ws.Range("A2").Value End If End If Next End With Set dic = Nothing End Sub
○今の具体的な方法は? 　例えば 　　temp_Str &= 〜 　　temp_Str = temp_Str & 〜 　などとやっているなら、StringBuilderで効率がよくなるかもしれません。 ※ & で連結する場合、内部では「 旧文字列 & 連結する文字列」 という新しい文字列オブジェクトを作ります。 　効率はよくはありません。 ○本当に文字列が原因ですか? 　例えば For j = 1 To 数100万件 　temp_Str ="" 　For i = 1 To 1000 　　データ処理 　　temp_Str &= "〜," 　Next 　temp_Strの出力 Next 　みたいな構造で、毎回temp_Strがクリアされているなら、文字列がメモリ不足の原因になるとは思えません。 　この中の「データ処理」の方が原因だったりしませんか? 　例えば、1回ループする度に、データ取得や計算用に作られたオブジェクトがGCされないまま残っている、とか。 　あるいは「 temp_Strの出力」 の部分が「配列やListに追加」とか「TextBox1.Textに追加」とかだったら、ループ毎に使用メモリが増えていくことになります。 都度ファイルやデータベースに書き出すのがよいでしょう。 まずは、原因をちゃんと調べることです。 まずは、データ処理をばっさりコメントアウトして「 temp_Str にカンマ区切りの数値を連結」だけにしても発生するのか調べてみましょう。 VisualStudioにパフォーマンスツールが付いているなら、それを使うのも手です。 http://www.atmarkit.co.jp/fdotnet/chushin/vsperf …
結論を言うと「ありません」です。 ウィンドウラベルの赤い「×」を押すとWindowsは該当ソフトウェアの強制終了を行いますが、その処理に入る前に確認ダイアログを表示してユーザーの入力を待つというオプション機能は備えていません。 （Windowsの系譜にこの機能を持ったものは無いと思います） 一方、Windowsから強制終了させられるソフトウェアは、自分が強制的に終了させられるという情報を取得することができます。この機能は一般的には「ちゃんと後処理してから終了しないと次回の使用時に支障を来たす場合がある」機能を持ったソフトウェアで使用されます。書かれておられる終了してよいかの確認をするソフトウェアはこの情報を取得して自ら確認ダイアログを表示させています。 ということで、残念ながら「確認表示を行っていないソフトウェアも確認表示を行う」ように利用者が設定する術はありません。
＃７です まだ閉じられてなかったですね ＃１さんの再登場までお待ちください （ご迷惑をおかけしつつ、お願いはしてみました） 質問者さんが記述された内容を追ってみました 1 日付 氏名 開始時間 終了時間 2 2月3日 A 4:00 5:00 3 2月3日 A 5:00 6:00 4 2月3日 B 10:00 11:00 5 2月3日 B 11:00 13:00 このデータがあった時（左の数字は行） i = 2, j = 2 で i = 2 の時間覚え i = j だけど、時間比較 i = 2, j = 3 でループ繰り返し i = 2, j = 3 で時間比較 i = 2, j = 4 でループ抜け i = 2 の日付、氏名と時間書き出し i = 5, j = 4 とし i = 5 の時間覚え i = 5, j = 4 で時間比較 i = 5, j = 5 でループ繰り返し i = j だけど、時間比較 i = 5, j = 6 でループ抜け i = 5 の日付、氏名と時間書き出し i = 7 でループ抜け これで処理できるデータは、以下の条件の時 ・日付が変わったら、氏名も変わる ・その人のデータは ２行/日 以上ある これを、裏仕様と言わせていただきました 元々のデータは、この仕様から外れるものはない･･･のなら、以下スルーで･･･ 外れたデータでの動きは 1 日付 氏名 開始時間 終了時間 2 2月2日 A 4:00 5:00 3 2月3日 A 5:00 6:00 4 2月3日 B 10:00 11:00 5 2月4日 A 11:00 13:00 i = 2, j = 2 で i = 2 の時間覚え i = j だけど、時間比較 i = 2, j = 3 でループ繰り返し（日付は比較していないので） i = 2, j = 3 で時間比較 i = 2, j = 4 でループ抜け i = 2 の日付、氏名と時間書き出し i = 5, j = 4 とし i = 5 の時間覚え i = 5, j = 4 で時間比較（AさんとBさんの） i = 5, j = 5 でループ抜け（j=4 と j=5 の氏名が違う） i = 5 の日付、氏名と時間書き出し i = 6 でループ抜け 結果は Bさん消えつつ････ 日付 氏名 開始時間 終了時間 2月2日 A 4:00 6:00 2月4日 A 10:00 13:00 外れたデータがあることを前提に、ここまで回答つけてきました 記述意図がわからないので、私から代弁できるものはありません ＃１さんはスキルの高い方なので、記述の意図等聞けるかと思います > DoEvents > Cells(j, 3).Select > eaMin = 1: eaMax = 0 これらは必要なのかとか、StrComp を使った意図とか その際、 > Worksheets("data2").Range("I1", Range("L" & Rows.Count).End(xlUp)).ClearContents > Worksheets("data2").Range("I1:L1").Value = Range("A1:D1").Value この辺りの記述についてもお話あるかもしれません 裏仕様以外のデータが存在する/しない･･･明示されると良いと思います 失礼しました
GetEncodingが、System.Text名前空間だったので、 System.Text 名前空間から、エンコードなしのものが無いか探して StringBuilder クラスを見つけました。 その中のメソッドにStringBuilder.Append(Byte)メソッドがあったのでこれで出来ないかと？ 以下、出来る保証はありませんが・・・。 Dim bytes() As Byte = ' 変換前データを一旦byte配列に落とす Dim sb As New System.Text.StringBuilder() For Each value In bytes 　' valueをEBCDIC派生の独自コードに変換する 　sb.Append(value) Next Dim str As String = sb.ToString();
.TargetPath = "%windir%\explorer.exe" .Arguments = "..\..\aaa\bbb\" ですね。 参考：https://msdn.microsoft.com/ja-jp/library/cc36440 … の「メモ」部分
> イベント選択の｢シートの価が変更された時｣というのは、英語で何て表していますか？ Private Sub Worksheet_Calculate() か Private Sub Worksheet_Change(ByVal Target As Range) ですね。 前者はセルに書かれている計算式の計算の結果変化した場合、後者は入力で変化した場合……だったと思います。後者のTargetという変数は、値が変化したセルになります。
>全店集約するのにすごく時間がかかります（エクセルが途中でフリーズします） これの原因がわからないので？ 良く見るケースで １、データの持ち方が悪い ２、エクセルの活用が出来ていないＶＢＡ です。 私も年年分ものデータ（１０万行ほどある）を集計したりしていますが 殆どの作業が数秒（？）でストレスを感じる事はありません。 元データがどうなっていて、どういう作業をＶＢＡで行わせているのか その辺りが見えないので、何とも回答が出来ません。
こんにちは。 一応、ご質問者さんの反応をお待ちしましたが、反応がないので、現在のものをそのままで掲示します。 '// Dim ret As String Sub Main() Dim i As Long For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row 　If Cells(i, 1).Value Like "http:*" Then 　　 Call DestGet(Cells(i, 1).Value) 　End If 　If ret <> "" Then 　　 Cells(i, 2).Value = ret 　End If Next i End Sub Sub DestGet(strURL As String) 　　　　Dim objHTTP As Object 　　　　Dim httpLog As String 　　　　ret = "" 　　　　On Error GoTo ErrHandler 　　　　Set objHTTP = CreateObject("WinHttp.WinHttpRequest.5.1") 'New winHttp.WinHttpRequest ' 　　　　 　　　　objHTTP.Open "GET", strURL, False 　　　　objHTTP.Send 　　　　If objHTTP.Status = 200 Then 　　　　　　　　httpLog = objHTTP.ResponseText 　　　　　　　　ret = Analysislogs(httpLog) 　　　　Else 　　　　　　　　ret = " err" 　　　　End If Exit Sub ErrHandler: End Sub Function Analysislogs(httpLog As String) 　Dim arLog As Variant 　Dim oHtml As HTMLDocument 　Dim buf As Variant 　Dim tp, tpe, ct, ctt 　Dim i As Long 　Dim ar As Variant 　Dim dst As String 　Dim oRegExp As regExp 　Set oHtml = CreateObject("HTMLfile") 　oHtml.body.innerHTML = httpLog 　Set ct = oHtml.getElementById("content980") 　ctt = ct.innerText 　buf = "" 　Set oRegExp = New regExp 　Dim Matches 　Dim Match 　Dim arPat As Variant 　arPat = Array("[／「]([ぁ-んァ-ヶ・。！-～一-龠]+スキー場)」", "([ぁ-んァ-ヶ・。！-～一-龠]+スキー場)") 　For i = 0 To UBound(arPat) 　With oRegExp 　　　　 .Pattern = arPat(i) 　　　　 .Global = True 　　Set Matches = .Execute(ctt) 　　For Each Match In Matches 　　　　 If InStr(1, Match.SubMatches(0), buf, 1) > 1 Or buf = "" Then 　　　　　　 buf = Trim(buf) & "," & Match.SubMatches(0) 　　　　 End If 　　Next 　End With 　If buf <> "" Then 　　　　Exit For 　End If 　Next i 　If buf <> "" Then 　　 Analysislogs = Mid$(buf, 2) 　End If End Function '///
このコード実はTEST1.xlsxが一切変更されないので、 処理を行わないことがもっとも高速化につながるかと思います。
セル単位で置換するのでいいのなら、結局のところ、ExcelのCtrl+Hで起動する置換をマクロの記録で記録したものと同じになります。 Sub 置換のサンプル() with Cells 　　　.Replace What:="ﾊﾞﾅﾅ*", Replacement:="バナナ" 　　　.Replace What:="ﾒﾛﾝ*", Replacement:="メロン" 　　　.Replace What:="ﾘﾝｺﾞ*", Replacement:="林檎" 　　　.Replace What:="ﾄﾏﾄ*", Replacement:="トマト" 　　End With End Sub 後々を考えるとこれがいいかも。 https://oshiete.goo.ne.jp/qa/5445568.html https://oshiete.goo.ne.jp/qa/2679561.html
>それでタスクバー上に上記のような文字列を表示したいので そのプロセスの適当なところに Application.Caption = "1/100" や ・・"50/100" などを挟み込んでゆけばよいのでは？ DoEventsとセットでないと反映されないかも？ >あるいは常に最前面表示の小さなウインドウを こちらの物好きじいちゃんさんのが参考になるのでは？ https://oshiete.goo.ne.jp/qa/9130415.html 当方32Bit版Officeなので64Bit移植も視野に入れた回答は不可です。あらかじめ。 >タスクバー上のExcelが点滅するようなアクション 適当なのがなさそうなので 標準モジュールに Private Declare Function FlashWindowEx Lib "user32" _ (FWInfo As FLASHWINFO) As Boolean Private Declare Sub Sleep Lib "kernel32" _ (ByVal dwMilliseconds As Long) Private Type FLASHWINFO cbSize As Long ' size of structure hWnd As Long ' hWnd of window to use dwFlags As Long ' Flags, see below uCount As Long ' Number of times to flash window dwTimeout As Long ' Flash rate of window in milliseconds. 0 is default. End Type Const FLASHW_STOP = 0 Const FLASHW_CAPTION = 1 Const FLASHW_TRAY = 2 Const FLASHW_ALL = FLASHW_CAPTION Or FLASHW_TRAY Const FLASHW_TIMER = 4 Const FLASHW_TIMERNOFG = 12 Sub FlashTest() Dim retVal As Integer Dim FWInfo As FLASHWINFO ' Fill the structure: With FWInfo .cbSize = 20 ’これが不明 .hWnd = Application.Hwnd 'Excelの場合 .dwFlags = FLASHW_ALL .uCount = 10 '回数 .dwTimeout = 200 ’間隔 End With ' Allow time to cover the window: Sleep 2000 ' call the function: retVal = FlashWindowEx(FWInfo) End Sub としておいて終了の際に、Call FlashTest を呼び出したら・・？ ※上記のAPIもMSDNだったかに載っていたのを以前にメモってただけです。 Excel2010以前と2013以後では異なる結果になるかもしれません。 以上、ご参考まで。
>Cのファイルだけいくつもシートを持っているので対象となるシートを選択できるようにしたいです。 なので、操作の流れを考えた方が便利になると思うのですが。 例えば 操作１　Ｂファイルを開く、必要なシートをアクティヴにした状態で、保存する。（手作業） 　　　　Ｃファイルも同様にして保存 操作２　Ａファイルに別途、データコピー用のシートを準備、Ａファイルを開いて、マクロを実行すると 　　　　自動で、Ｂファイルを開く、アクティブなシートを、データコピー用のシートに２行目以下に張り付けて閉じる。 　　　　次に、Ｃファイルを開いて、アクティブなシートを、データコピー用のシートの最終行以下に刈りつけて閉じる。 操作３　ＡファイルのＭ列には、データコピーのシートを参照に行くＶｌｏｏｋｕｐ関数を配置しておく。 たぶん、この流れでご希望の値が表示されると思うのですが。 つまり、手作業では、操作１　を、それぞれ２回 Ａファイルのマクロボタンをクリック になります。
こんばんは。 いろんな方法があるはずですが、私は、専ら正規表現を使ってしまいます。 以下のような場合は、abcdef1234abcdef1234 -> 1234,1234 と抜き出します。abcdef1234abcdef -> 1234 となります。 '// Sub TestMacro() Dim c As Variant 　For Each c In Range("A1:A10") 　　c.Offset(, 1).Value = PickNumbers(c) 　Next c End Sub 'ユーザー定義関数 Dim Matches As Object Dim Match As Object Dim myVal As String Dim buf As Variant If TypeName(arg) = "Range" Then 　　myVal = arg.Value End If With CreateObject("VBScript.RegExp") 　　　　.Pattern = "(\d+)" 　　　　.Global = True 　　　　.IgnoreCase = False 　Set Matches = .Execute(myVal) 　For Each Match In Matches 　　　　buf = buf & ", " & Match.Value 　Next End With 　　PickNumbers = Mid(buf, 2) End Function '///
単純な以下でどうなりますか 指定したその場所で更新します Public Sub Samp1() 　　Dim rng As Range 　　Dim v As Variant 　　Dim i As Long, j As Long 　　Set rng = Range("A2:D3") ' 場所指定 　　For i = 1 To rng.Count - 1 　　　　For j = i + 1 To rng.Count 　　　　　　If (rng(j) <> "") Then 　　　　　　　　If ((rng(i) = "") Or (rng(i) > rng(j))) Then 　　　　　　　　　　v = rng(i) 　　　　　　　　　　rng(i) = rng(j) 　　　　　　　　　　rng(j) = v 　　　　　　　　End If 　　　　　　End If 　　　　Next 　　Next End Sub ※ 山梨と高尾の順が違いますけど 問い） 上記処理は単純に文字列として比較しているだけですが、 後ろの数字部分について ・２桁になることはありますか？ （高尾２ と 高尾１１ を単純比較すると、高尾１１、高尾２の順に） ・半角/全角混在しますか？ ・数字前文字の出現個数が多い順ですか？ 上記問いが全て「はい」で ・数字部分の始まりに 0 はない ・数字前にカタカナはない の条件の時、雰囲気以下？ Public Sub Samp2() 　　Dim dic As Object, dicC As Object 　　Dim vA As Variant, vK As Variant, v As Variant 　　Dim vC As Variant 　　Dim sS As String, s As String 　　Dim i As Long, j As Long, k As Long, n As Long 　　Set dic = CreateObject("Scripting.Dictionary") 　　Set dicC = CreateObject("Scripting.Dictionary") 　　With Range("A2:D3") 　　　　vA = .Value 　　　　For i = 1 To UBound(vA) 　　　　　　For j = 1 To UBound(vA, 2) 　　　　　　　　If (vA(i, j) <> "") Then 　　　　　　　　　　sS = StrConv(vA(i, j), vbNarrow) 　　　　　　　　　　s = "" 　　　　　　　　　　n = 0 　　　　　　　　　　For k = 1 To Len(sS) 　　　　　　　　　　　　If (Mid(sS, k, 1) Like "[0-9]") Then 　　　　　　　　　　　　　　n = Val(Mid(sS, k)) 　　　　　　　　　　　　　　sS = Left(vA(i, j), k - 1) 　　　　　　　　　　　　　　s = Mid(vA(i, j), k) 　　　　　　　　　　　　　　Exit For 　　　　　　　　　　　　End If 　　　　　　　　　　Next 　　　　　　　　　　If (s = "") Then sS = vA(i, j) 　　　　　　　　　　If (Not dic.Exists(sS)) Then 　　　　　　　　　　　　dic.Add sS, CreateObject("Scripting.Dictionary") 　　　　　　　　　　End If 　　　　　　　　　　dic(sS)(n) = s 　　　　　　　　　　vA(i, j) = "" 　　　　　　　　End If 　　　　　　Next 　　　　Next 　　　　For Each vK In dic.Keys 　　　　　　i = dic(vK).Count 　　　　　　If (Not dicC.Exists(i)) Then 　　　　　　　　dicC.Add i, CreateObject("Scripting.Dictionary") 　　　　　　End If 　　　　　　dicC(i)(vK) = Empty 　　　　Next 　　　　i = 1 　　　　j = 1 　　　　For Each vC In mySortDesc(dicC.Keys) 　　　　　　For Each vK In mySort(dicC(vC).Keys) 　　　　　　　　For Each v In mySort(dic(vK).Keys) 　　　　　　　　　　vA(i, j) = vK & dic(vK)(v) 　　　　　　　　　　j = j + 1 　　　　　　　　　　If (j > UBound(vA, 2)) Then 　　　　　　　　　　　　i = i + 1 　　　　　　　　　　　　j = 1 　　　　　　　　　　End If 　　　　　　　　Next 　　　　　　Next 　　　　Next 　　　　.Value = vA 　　End With 　　Set dic = Nothing 　　Set dicC = Nothing End Sub Private Function mySort(ByVal vA As Variant) As Variant 　　Dim v As Variant 　　Dim i As Long, j As Long 　　For i = LBound(vA) To UBound(vA) - 1 　　　　For j = i + 1 To UBound(vA) 　　　　　　If (vA(i) > vA(j)) Then 　　　　　　　　v = vA(i) 　　　　　　　　vA(i) = vA(j) 　　　　　　　　vA(j) = v 　　　　　　End If 　　　　Next 　　Next 　　mySort = vA End Function Private Function mySortDesc(ByVal vA As Variant) As Variant 　　Dim v As Variant 　　Dim i As Long, j As Long 　　For i = LBound(vA) To UBound(vA) - 1 　　　　For j = i + 1 To UBound(vA) 　　　　　　If (vA(i) < vA(j)) Then 　　　　　　　　v = vA(i) 　　　　　　　　vA(i) = vA(j) 　　　　　　　　vA(j) = v 　　　　　　End If 　　　　Next 　　Next 　　mySortDesc = vA End Function
こんばんは。 今は、試していませんが、 >2010では何度で実行しても問題は発生しません ざっとみると、どのExcelでも、1回めはできても、2回めはうまくないような気がしますけれども。 今は、Excel 2013はインストールしていないので、正確には申し上げられないけれども、 ActiveSheet.ListObjects.Add は、一つのシートでは繰り返しができないことも多いかと思います。 With ActiveSheet.ListObjects(1) 最後のコードで、ListObject を削除していないのですから、当然、ListObjects(1)とかが、ActiveSheet上に残っているはずですから、それを再利用すればよいはずです。
こんばんは。 ちょっとだけ、以下のように変えてみました。 でも、そのコードは、コピーに失敗はしていないし、コードそのものは問題ないのでは？ それと、その、ClipboardData.ClearData　というのは必要なのですか？ 空のClp を、そのまま表示すれば、null になりますね。 null は、Variant型の何もない状態のものです。もし、空のClpでも、""(長さ0の文字列)ぐらい入れれば、Text1 は、見かけの空白にはなります。 それと、Dim Clp の変数の宣言を、外に出して、Clpを空にしないようにしてみました。つまり、何もしなければ、そのまま残るということです。 なお、実際のご要望とは違ってしまったら、ご容赦ください。その場合、「解決法」の意図する所を、誤解しているはずです。 '// Dim Clp Sub window_onload resizeTo 200,200 End Sub Sub Sample With CreateObject("Wscript.Shell") .Sendkeys "^c" End With Clp = ClipboardData.GetData("text") If IsNull(Clp)=False Then text1.Value = Clp 'ClipboardData.ClearData End If End sub '///
＞Excel2013(64bit)です なので、hwndの型はLongでなくてLongPtrになります。 '宣言の変更 Private Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hwnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr ＞Dim hwnd As Long Dim hwnd As LongPtr
間違っていたらすみません。 例外処理では駄目なのでしょうか？ 'Button1を張り付けたフォーム Private Sub Button1_Enter(sender As Object, e As EventArgs) Handles Button1.Enter 　Try 　　 '(Enterイベントの処理) 　Finally 　　'(Enterイベント終了直後に行いたい処理) 　End Try End Sub
そのような関数を自前で作成するのが最善の策かと思います。 以下は、Long型の配列にSplit結果を格納する関数：MySplitの実装例です。 Sub hyoujiは結果を表示する関数です。（参考用） ----------------------------------------------------- Option Explicit Public Sub sample() Dim result1() As Long Dim result2() As Long Dim result3() As Long result1 = MySplit("23:53:12345678901888", ":") Call hyouji(result1) result2 = MySplit("1:23:456.7", ":") Call hyouji(result2) result3 = MySplit("aaa", ":") Call hyouji(result3) End Sub Public Function MySplit(str As String, dlm As String) As Long() Dim i As Long Dim strArray() As String Dim vals() As Long strArray = Split(str, dlm) For i = 0 To UBound(strArray) ReDim Preserve vals(i) On Error GoTo MYSPLIT_ERR vals(i) = Val(strArray(i)) Next MySplit = vals Exit Function MYSPLIT_ERR: MsgBox ("実行時エラー:" & Err.Number & " " & Err.Description & vbCr & "不正データ=[" & strArray(i) & "]") vals(i) = 0 Resume Next End Function Public Sub hyouji(vals() As Long) Debug.Print "-------------" Dim i As Long For i = 0 To UBound(vals) Debug.Print vals(i) Next End Sub -------------------------------------------------- 以下、実行結果です。 ------------- 23 53 0 ------------- 1 23 457 ------------- 0 ｰｰｰｰｰｰｰｰｰｰｰｰｰｰ 尚、Long型に格納できないような数字（例では12345678901888） 等が、指定されると、エラーが発生しますので、その場合は、 メッセージBOXにエラー表示し、０を格納するようにしています。 もし、メッセージBOXの表示が不要であれば、その行をコメントアウトしてください。
「PCに取り込む」っていうのが何のことだかよくわかりませんが。 入力方法だったら、画面上の「カナ」だの「A」だの書いてあるメニューにある「絵文字と記号を表示」で選べます。
こんばんは。 >そのような手段を使ってコードを書く方法は思いついており #3さんの書いた方法は思いつかないですね。（^^; とても、私には、ユニークだと思いましたが……。 なお、私が、#2で書いた内容は、まったく次元に違うことです。文字列をVBAのコマンドラインに書き込むことです。 >特定のファイルを複数の候補フォルダから探すようなコードを書いているのですが、 そこには、何かの誤解が混じっているように思います。それが、元のご質問の内容に繋がるなら、ロジックそのものが違っています。そのような所には、ほぼ、ThisWorkbook.Path などは出てきません。ThisWorkbookは、特定のファイルではなく、現在、マクロを動かしているブックのことです。「ほぼ」と言うのは、それは、一種のマジックナンバーだからです。それは、定数のようで定数でないからです。つまり、該当することもたまにはあるということです。 かつては、FileSearch というコマンドがありましたが、今は、ありませんので、自分で組み込むしかありません。 >技術的に可能なのかが気になるという側面が強いです。 私としては、可能か可能でないかというような話はついていけませんが、ファイルを探して、そのフォルダーを出すぐらいなら、VBAですと、だいたいは、Dir 関数を使うことが多いのではないかと思います。 http://officetanaka.net/excel/vba/tips/tips36.htm ここにも、FileSystemObject を使った書き方がありますが、もう少しこれは詰めないと、今回の要件とは少し外れています。例えば、VBA　から、command line(Shell) で、Path を作っておいて、Where コマンドで探すという方法もあります。子プロセッサですから、Path は、テンポラリーでしかありません。それが残ってトラブルを起こすこともありません。 http://www.atmarkit.co.jp/fwin2k/win2ktips/1151w … 私としては、このぐらいまでです。
単純な話、ラベルが独立しているだけのような気がします。 [あいう]を選択して同時にラベル320も選択状態になりますか？。 または[あいう]を移動してみてください。ラベル320が取り残されませんか。 一体化していないとラベルは消えません。
複数選択可能にしました。 Sub resize() Dim fName As Variant Dim png As Variant fName = Application.GetOpenFilename("pngファイル, *.png", MultiSelect:=True) If IsArray(fName) Then For Each png In fName With ActiveSheet.Pictures.Insert(png) .TopLeftCell = ActiveCell .ShapeRange.LockAspectRatio = msoFalse .ShapeRange.Height = 100 .ShapeRange.Width = 300 .Cut End With ActiveSheet.PasteSpecial Format:="図 (JPEG)", Link:=False, DisplayAsIcon:=False ActiveCell.Offset(2, 0).Activate Next png End If End Sub
同じ環境が作れないので・・・。 こんな情報がありました。 IEのオブジェクトをCreateObjectではなく、GetObjectで作成する。 以下、サンプルです。 ClsIDの値ですが、レジストリの情報で、 \HKEY_CLASSES_ROOT\InternetExplorer.Application\CLSID の値を設定します。 ------ 以下サンプル ------------- Const ClsID = "{0002DF01-0000-0000-C000-000000000058}" Dim objIE Set objIE = GetObject("new:" & ClsID) objIE.Navigate2 "http://syanai.co.jp/" WScript.Sleep 5000 objIE.Visible = True
数学は好きですか？ある程度習熟して、 integerの最大値はいくら？ このマクロ、どの位時間掛かる？やり方変えよう 等を考えつつマクロを作るようになったら、挑戦してみて下さい。 https://projecteuler.net/archives
必ず使えるかは不明ですが、やり方だけ・・・。 例えば、最初のリンクにあるソースですと、 ＞' Bitmap をファイルのパスから作成 ＞Dim bmp As New Bitmap(argv(1)) ＞' キャンバス ＞Dim gra As Graphics = Graphics.FromImage(bmp) ＞' 書き出すテキストのフォントを作成 ＞Dim myFont As Font = New Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold) こんな感じに dim objbmp, objgra, objmyFont ' Bitmap をファイルのパスから作成 set objbmp = CreateObject("System.Drawing.Bitmap").Bitmap(argv(1)) ' キャンバス set objgra = CreateObject("System.Drawing.Graphics").FromImage(bmp) ' 書き出すテキストのフォントを作成 set objmyFont = CreateObject("System.Drawing.Font").Font(FontFamily.GenericSansSerif, 20, FontStyle.Bold) こんな感じで、.NetFrameworkのオブジェクトをCreateObjectで作成して利用する。 以下、参照 【System.Drawing.Bitmap】 https://msdn.microsoft.com/ja-jp/library/system. …(v=vs.110).aspx 【System.Drawing.Graphics】 https://msdn.microsoft.com/ja-jp/library/system. …(v=vs.110).aspx 【System.Drawing.Font】 https://msdn.microsoft.com/ja-jp/library/system. …(v=vs.110).aspx ※.NetFrameworkの中には、使えるものと使えないものがあるようなので、あくまでも参考程度で・・・。
http://excelwork.info/excel/paramarray/ 上記参照URLによると、Paramarrayを使う場合はVariant型配列として宣言する必要があるそうです。 どこの誰が書いたかもわからんページですが。。。
こんばんは。 #3の回答者のWindFaller(棚からぼたもちを受け取る人）です。 >Retに一度格納して空白じゃなかったら変数に格納するということですか。 実は、エラーを出すと、変数が活性化しないので、前のデータが残っているので、一度、初期化してあげないといけないのです。Variant 型では、通常は、Empty です。それを調べるのは、IsEmpty(変数)です。ただ、今回は、仰々しくなるのでやめたというわけです。 >表が大規模なのでメモリの使用量 Excel 2003時代には試したことがあるのですが、VBAのワークシート関数で範囲を指定しておくと、常に、ワークシートの設定した範囲の監視状態になってしまう、いえ、正確にいうと、VBEditor のツール－オプションのコンパイルの方法を、順次コンパイルだけに換えておいた方がよいこともあります。 うっかりしていました。 今気がついたのですが、もしかしたら、ループの抜けは、メモリーがリークしたのでは？たぶん、間違いないと思います。必ず、そういう現象が現れます。 もし、そうなら、全面的にコードを変えたほうがよいです。やはり、関数とやることは同じでも、VBA側のFindメソッドは、負担が軽いです。 Findメソッドを使ったコードは、独特の内容になりますが、たぶん、ヘルプなどのサンプルで真似すればよいだけです。 #4さん曰く >マクロが変わった等ではなく、単にコーディングが不完全でデータの値によってはエラーが出るマクロであったと、そういう経験は多数あります（苦笑） 私もあります。まるで、昔流行った「マーフィーの法則」のようです。なぜ、以前に、そんな凡ミスが見つからなかったのか、不思議だなって思います。
VBで配列を引数で渡す場合、先頭のアドレス（住所）を渡しています。 （C言語のポインター） その為、サブルーチンの引数の型は、その「アドレスを表す変数」が値渡しか参照渡しかを表すことであって、配列の中身を値渡しか参照渡しかを指定している訳ではありません。 つまり、 Sub TestB(Byref MyArray() As Integer) ※MyArray変数がByref Sub TestB(Byval MyArray As Variant) ※MyArray変数がByval 詳しくは、以下のサイトを参考にしてみてください。 https://msdn.microsoft.com/ja-jp/library/eek064h …
～前略 for a = 1 to b sheets(2).range("a1")=a sheets(2).printout application.wait now + timevalue("0:00:01") next a end sub のように１～秒程度待機させてみては？ 要は印刷処理をこの段階で制御したら？ということです。
＞もっとも高速なのは最初に大きな配列を生成してから、一度に書き込む方法です。 メソッドを呼び出すのにも時間がかかります。 なので、メソッドの呼び出し回数を減らせば速度はアップします。 ＞いまデータはHDDに保存されているので HDDのアクセスが早いので、シーケンシャルでもランダムでも速度差を感じなくなっているのです。 しかし、この考え方がなくなっているわけではありません。 すみません。何かおかしいと最初から読み直したのですが、基本が間違っていました。 １：「TEXTファイル」を「シーケンシャルアクセス」 Append、Input、Output ２：「TEXTファイル」を「ランダムアクセス」 Random ３：「Binaryファイル」を「シーケンシャルアクセス」←「ランダムアクセス」 Binary ＞テキストファイルの場合だと最初から呼んでいかないと行やファイルの終端がどこにあるか そのようなファイルを扱うのが「１：」のパターンです。 テキストファイルでも、１行の長さを固定にして出力すれば、読み込むときに計算で読みたい位置はわかるのでランダムにアクセスできます。これが「２：」のパターンです。 テキストファイル同様、バイナリーファイルでもファイルの構造によって必ずしもランダムアクセスできるわけではありません。そこのところは間違えないようにしてください。
No.3です。 No.4さんの記述を読んで、間違った解釈をした事に気づきました。 一度定義した変数aaaの型を途中で変えるということだったのですね。 確かに出来なくはないですが、No.4さんのおっしゃるとおり 「すべきではない」と思います。
sh.run "AcroRD32.exe ""C:\Test\"" & fi.Item(i)" をどういうつもりで書いていますか？ sh.run "AcroRD32.exe ""C:\Test\""" & fi.Item(i) では？
FirefoxはVBScriptでは制御できません。無理です。 ソースを取得したいのなら、IEで十分では？
以下に同等の内容がありますよ。 https://oshiete.goo.ne.jp/qa/8611462.html
こんばんは。 s = "aaa"　　'aaaは任意の値 0x というのは、16進ですから、 Long 型の配列に格納するためには、一度、10進に戻さないといけません。 >l[1]=0x0061 このままでは入りません。0x0061 は、10進で97 です。 つまり、文字をコードに変換すればよいわけです。 0x0061 自体は、格納しようにも、16進ですから、Long型変数には格納できません。 Dim s As String Dim buf Dim ret Dim i As Long, j As long Dim l(9) As Long 　s = "aaa" 　For i = 1 To Len(s) 　　a = Mid(s, i, 1) 　　buf = AscW(a) 　　l(j) = buf 　　j = j + 1 　Next 後の問題は、逆に戻す時でしょうね。 For i = 0 To UBound(l) 　buf1 = buf1 & ChrW(l(i)) Next 私が、質問の内容から思いつくのは、このぐらいです。
残念ながら・・・出来ません。 一応、プロパティの中に Handle ってのがあるのですが 取得できるのは ProcessID の値です。 以前、調べていて Handle を見つけた時は、 『やったー ＼(^o^)／』と思いましたが ぬか喜びでした。。。orz なお、当方の環境は、Windows7 Pro & Office2010 です。
>rc = WSH.Popupのところで止まって先に進みません。 この段階で何もメッセージが出てこないのでしょうか？ また、そこから、F5 か F8 で進めた時にどうなるか・・・。 PS. Set WSH = CreateObject("WScript.Shell") の後におまじないの行を挿入 Doevents では？
改行コードの事は気にしてませんので気になるならご自分でなんとかしてください。 head も含めた全ソースコードは WebBrowser.Document.DocumentEelment.outerHTML body の全ソースコードは WebBrowser.Document.Body.outerHTML ので取得できるようです。 outerHTML ってぐらいだから innerHTML もあると思います。 Dim source As Variant source = Split(Me.WebBrowser1.Document.DocumentElement.outerHTML, vbCrLf) Dim sht As Worksheet Set sht = ThisWorkbook.Worksheets(1) Dim i As Long For i = 0 To UBound(source) sht.Cells(i + 1, 1).Value = source(i) Next
条件付き書式を使ったらどうでしょうか。 条件は、 =CELL("ADDRESS")=CELL("ADDRESS",OFFSET(A1,0,6)) この条件がTrueの時水色にする これをA1のセルに入力し必要範囲にコピーする。 これだけだと、再計算しないと色が変わらないので、 Private Sub Worksheet_SelectionChange(ByVal Target As Range) Application.Calculate End Sub をマクロに追加 これで如何でしょうか。
今でも32bit版Windowsには、debugというコマンドが付属していてるそうです。 それがあれば、バイナリ編集できます。出来ないというのは間違いです。コマンドラインツールなのでGUIではありません。 16bitアプリなので、64bitWindowsでは動かないですね。 フリーソフトなら色々あります。
恐らくメモリ不足で出来なくなった原因としては Moveされたファイルを閉じるコードが入ってないためエラーを起こしていると思います。 生成されたファイルを閉じるコードを付けてみましたので 参考までに Sub sheetmove() Dim i As Integer For i = Worksheets.Count To 2 Step -1 Worksheets(i).Move ActiveWorkbook.SaveAs ThisWorkbook.Path & "\" _ & ActiveSheet.Range("B2") & ".xls" Workbooks(ActiveSheet.Range("B2") & ".xls").Close　　’この欄を追加してます。 『Move』で作成したファイルを閉じるコード ThisWorkbook.Activate Next i End Sub
簡単なもので失礼しますが Sub ボタン1_Click() Range("B2").Value = Now() + Range("B4").Value / 24 / 60 + Range("D4").Value / 24 / 60 / 60 Range("B3").Value = Now() Call countdown End Sub Sub countdown() If Range("B3").Value >= Range("B2").Value Then Range("C6").Value = "時間となりました" Call CallBeep Exit Sub End If Application.OnTime Now() + TimeValue("00:00:01"), "countdown" Range("B3").Value = Now() Range("B4").Value = Minute(Range("B2").Value - Range("B3").Value) Range("D4").Value = Second(Range("B2").Value - Range("B3").Value) End Sub Private Sub CallBeep() Beep Range("D3").Value = Now() + TimeValue("00:00:01") Application.OnTime Range("D3").Value, "CallBeep" End Sub Sub ボタン2_Click() Application.OnTime Range("D3").Value, "CallBeep", , False Range("C6").Value = "" End Sub B2,B3、D3セルは空いているとして B4に分、D４に秒を入れて ボタン１で　ボタン1_Click()　カウントダウン ボタン２で　ボタン２_Click()　アラムストップ です。
もう少し詳しく書いたほうがよさそうです。 ・図が不鮮明、小さくて読めない ・読み込みたいデータのファイルは一つなのか（一つのファイルに複数シート）、 　複数ファイル（パスを指定した先のフォルダにある全ファイル）なのか、 　で、さらに複数シートなのか ・図2にある日付、元のデータとの関係性が不明。 というわけでざっくりの回答となります。 手作業でやることを考えて書いていってはどうでしょうか。 あくまで一例です。いろいろ組み合わせてみてください。 1) ファイルを開く 　Workbooks.Open FileName:=パス名からのファイル名 ２）あるフォルダにある全ファイルを開く 　Dir関数と言うのがあります。 http://officetanaka.net/excel/vba/tips/tips95.htm たとえば '--------------------------------------- Sub BBB() Dim myPath As String, FlNam As String myPath = "C:\Users\tomoya\Desktop\" FlNam = Dir(myPath & "*.xlsx") Do Until FlNam = "" Workbooks.Open Filename:=myPath & FlNam FlNam = Dir() Loop End Sub '--------------------------------------- 3) あるファイルの全シートをループする '--------------------------------------- Sub ccc() Dim k As Integer For k = 1 To Worksheets.Count Worksheets(k).Select Next k End Sub '--------------------------------------- 4) 最終行を取得する Dim LstRow As Long LstRow=Cells(Rows.Count,1).End(xlUp).Row 貼付先は、最終行の次でしょうから、実際には上記に　+1　をするとよいでしょう。 ５）B8セルから一番下までの範囲を指定する Dim Rng As Range Set Rng =Range(Cells(8,2),Cells(8,2).End(xlDown))
リストボックスにA1からA47の値を設定している箇所があるとおもいますので、 その設定が完了した後へ、 ListBox1.ListIndex = 13 の行を追加してください。 ListBox1は、都道府県を表示しているリストボックスのオブジェクト名とします。 （この名前はあなたの環境のリストボックスのオブジェクト名を設定してください） １３はインデックスを０から数えた値なので１４番目の場合は、１３になります。 不明点があれば、補足してください。 実際にリストボックスへ都道府県を設定している箇所のソースを提示していただければ より適切な回答が得られるかと思います。
具体的な対処方法ではありませんが・・・。 MHTMLだからということではなく、HTMLでもCGIから出力すると同様の現象が起こる場合があります。 CGIの場合だと、ファイル出力の先頭で「Content-type:text/html」を出力してから出力します。 これを忘れると、IEでは表示されるがChromeではソースが表示されてしまいます。 本来は出力が必要な項目なのですが、IEはあいまいに出来ていて表示出来てしまいます。 VBAはマイクロソフトが開発していますので、その辺があいまいになっている可能性があり、 あくまでも想像ですが、VBAの問題だと思います。 解決方法がわかりませんが、参考になれば・・・。
＞Visual Basic で掲示板が作れますか？ 作れるか？　作れないか？ 単純な答えは、「作れます」（厳密には、VBではなく、VB.NETです） 但し、ＷｅｂサーバーアプリがＩＩＳになります。 当然、サーバーのＯＳはマイクロソフトのＯＳとなります。 クライアントＯＳ（７，８，１０）でも可能ですが、 同時アクセスユーザー数が１０ユーザーと、とても使い物になりません。 サーバーＯＳが必須となります。 ・・・などなど。 基本的に、VB.NETでWebアプリを構築するのは制限が多すぎます。 PHPは、Webサーバーで動作させる事を目的としたスクリプト言語なのでこちらをお勧めします。 ＞いきなりISPのWebサーバにアップしても、はたして動くのかが疑問です。 http://homepage.nifty.com/_service/cgi.htm ＠niftyのレンタルWebサーバーで、PHPは動作するようです。（有料です） PHPが動作する無料のレンタルWebサーバーは、探せば見つかるので＠niftyに こだわりがないのであれば、そちらを利用されては？ ちなみに、ISPとWebサーバーを同じものと思われているようですが、これらは別物です。 現在、ISPを＠niftyで契約されていたとしても、Webサーバーが利用出来る訳ではありません。 ＠niftyが提供している、ホームページサービス「LaCoocan」（Webサーバー）と別途契約が必要となります。
MediaInfoについては不明ですが、 ファイル・フォルダのアクセス権、 UAC、 セキュリティ対策ソフト、 などによるブロックで「ファイルが見つかりません」 という不親切なメッセージが出たことはありました。 ご参考まで。 PS. ここを見ると http://mediaarea.net/ja/MediaInfo/Support/Formats 3gpフォーマットは載っていないようですけど？ Windows付属のwmvファイルでも検証されては？
こんにちは。 おそくなってすみません。何度もこの質問をみて、質問の意味がやっと分かりました。（^^; 初歩的な内容だと思いますが、 Range("A3").Formula="=INDEX(LINEST(TRANSPOSE(E" & i & ":I" & i & "),TRANSPOSE(E2:I2)^{3,2,1}),1,3)" >手操作で、式の最後にSIFT、CTRL、ENTERとすると、式の両端に｛　＝式　｝が入りきちんと動作するようです。 [Shift+Ctrl - Enter] これを「配列確定」と呼んでいますが、これを入れるためには、 Range("A3").FormulaArray =..... というプロパティを使います。試してみてください。
>Excelの他の機能も使えなくなってしまいますが、 >これらの機能を使える状態で >ファイルの生成を監視することはできないでしょうか？ 以下のようにしてください。 Sleep 100　・・・・Sleep 1000 を100に変更（100でだめなら10で試してください。こちらでは100でOKでした） DoEvents　・・・・この行をSleep 100の後に追加
2つ目のリンクの説明はExcel内のウィンドウを扱うものですから、質問の件の参考にはなりません。 1つ目のリンクの例のように、WindowsAPIを呼び出す必要あります。 WindowsAPIはＣ言語の関数の体裁をしていますので、理解するには若干のＣ言語の知識が必要です。 ウィンドウのサイズ変更は SetWindowPos 関数でできました。関数の説明はここにあります。 https://msdn.microsoft.com/ja-jp/library/cc41120 … ----------------------------------------------------- Option Explicit 'ウィンドウ位置を維持する Public Const SWP_NOMOVE = &H2& 'ウィンドウのＺオーダーを維持する Public Const SWP_NOZORDER = &H4& Private Declare Function FindWindow Lib "user32.dll" Alias "FindWindowA" ( _ ByVal lpClassName As String, _ ByVal lpWindowName As String _ ) As Long Private Declare Function SetWindowPos Lib "user32.dll" ( _ ByVal hWnd As Long, _ ByVal hWndInsetAfter As Long, _ ByVal X As Long, _ ByVal Y As Long, _ ByVal cx As Long, _ ByVal cy As Long, _ ByVal uFlags As Long _ ) As Long 'メモ帳のウィンドウサイズを変更するサンプル Public Sub ChangeRect() Dim hWnd As Long hWnd = FindWindow(vbNullString, "無題 - メモ帳") Call SetWindowPos(hWnd, -1, -1, -1, 400, 300, SWP_NOMOVE Or SWP_NOZORDER) End Sub
色々調べてみました。 http://smdn.jp/programming/vb.net/console_applic … http://www.atmarkit.co.jp/fdotnet/vb6tonet/vb6to … 参考にしてみてください。
こんにちは。 どんな内容か分からないと何も分からないです。 クラスでオブジェクトを生成したものが、インスタンスと言うのではありませんか。 何をされようとしているのか、ご質問からは分かりません。
vbsに限った話ですけど、vbsでは変数の宣言にデータ型を指定できません。 最適と思われるモノがその都度採用されます。 dim v msgbox typename(v) v=1 msgbox "v=1 " & typename(v) v=v*100000 msgbox "v*100000 " & typename(v) v=v/1 msgbox "v/1 " & typename(v) v=v & "a" msgbox "v & ""a"" " & typename(v)
こんばんは。 #2の回答者です。 >ストリーム系のツールか、コマンド・プロンプトで考えなくてはなりません。 #2のこの自分の言葉に引っかかっていていたのですが、最初、sed (ストリームエディタ）やPerl が浮かびましたが、探していれるのも面倒ですから、nkf.exe のことを思い出しました。会社で、これを使えるのかどうかは別として、変換には、1,000万行でも、せいぜい十秒程度です。 nkf -Lw myLF.csv > myCrLf.csv とすればよいです。これは、VBAでも、Shell で取り込めます。nkf が使えればですが。 command prompt というよりも、DOSでは、more を通せば、LF は、CRLF になるそうですが、あくまでも、s_jis のファイルに限るそうです。 http://www.atmarkit.co.jp/ait/articles/1301/25/n … http://osksn2.hep.sci.osaka-u.ac.jp/~taku/osx/cr … ちなみに、 "ADODB.Stream" で、やってみましたが、20分経っても終わらないです。それに、一度全部読んでいますから、これではダメでしょうね。 http://winofsql.jp/VA003334/infoboard_page.php?m …
vbs のスクリプト ファイルでってことでしたら無理じゃないですかね。 msgbox は何らかのメッセージを掲載したダイアログをユーザーに表示し、ユーザーからのボタン クリックによるレスポンスがあるまで待機する機能ですので、メッセージ ボックスが表示されたままの状態で中身を書き換えていくことはできないでしょう。 HTA ではダメなのでしょうか？ 以下のコード <html> から </html> をメモ帳に転記して保存し、拡張子を "txt" から "hta" に変更してください。 ダブルクリックで実行されます。 <html> <head> <title>HtaClock</title> <HTA:APPLICATION APPLICATIONNAME="HtaClock" ID="HtaClock" BORDER="dialog" INNERBORDER="no" MAXIMIZEBUTTON="no" SCROLL="no" VERSION="1.0"/> </head> <script language="VBScript"> Dim tOut tOut = 0 Sub DisplayClock() document.all.disp.innerText = FormatDateTime(Now, 3) End Sub Sub Window_OnLoad Dim width,height width=150 height=130 Self.ResizeTo width,height tOut = setInterval("DisplayClock()", 100) End Sub Sub OnClickButtonOK() window.Close End Sub </script> <body bgcolor="buttonface"> <table border=0 width=100% height=100%> <tr> <td height=100% width=100% valign="top" align="center"> <span id="disp"></span> </td> </tr> <tr> <td align="center"> <input type="button" style="width: 80px" name="OK" id="OK" value="OK" onclick="OnClickButtonOK"> </td> </tr> </table> </body> </html>
こんにちは。 >.Width = Range(Cells(1, 1), Cells(1, 256)).Width > >でうまくいくと思うのですが >おおよそ指定した幅になるのですが >なぜか5%程度大きめのサイズになってしまいます。 >これはなぜでしょうか？ この事象を思い出すまで、しばらく時間がかかりました。かなり昔のデータですが、現在のExcelにも当てはまるはずです。これは、Excel独特の問題だと思います。 シート全体に対して 　1．フォントサイズが、8～14以外が含まれている。 　2．セルを一杯に文字や数式の解を入れて、同じ行の右方向のセルに、データが入っている。 　3． 縦の太い罫線がある。 この場合、右端がずれる原因です。 こちらでは、よくみるとピタリと入っていましたが、実験的に何も余計なデータなどは入っていないからです。ちなみに、これほど大きなボタンを作ったことがありません。代替で、オートシェイプでもボタンと同じ機能をしますので、試してみてください。もともと、このフォームボタンはShape の仲間です。機能的には、同じ結果になるはずですし、同じ現象が現れるかもしれません。 'Excel 2010 で作っていますので、2003以下では、一部コードを変えなくてはなりません。 Sub AlternativeWay()　'代替の方法 Dim shp As Object Dim x1 As Double, x2 As Double Dim y1 As Double, y2 As Double Dim rw As Long 　rw = 256　'256 行目に(ひとつずらしました） 　With ActiveSheet 　 x1 = .Cells(rw, 1).Top 　 x2 = .Cells(rw, 1).Offset(1, 0).Top 　 y1 = 0 　 y2 = .Cells(1, rw +1 ).Left 　 Set shp = .Shapes.AddShape(msoShapeRectangle, x1, y1, x2 - x1, y2 - y1) 　　With shp 　　　　.Top = x1 　　　　.Left = y1 　　　　.Height = x2 - x1 　　　　.Width = y2 - y1 　　　　.Fill.Visible = msoTrue 　　　　.Fill.ForeColor.ObjectThemeColor = msoThemeColorBackground1 　　　　.Fill.ForeColor.TintAndShade = 0 　　　　.Fill.ForeColor.Brightness = -0.05 　　　　.Fill.Transparency = 0 　　　　.Fill.Solid 　　　　.Line.Visible = msoFalse 　　　　.OnAction = "Button_Click"　'登録マクロ(前回のサンプル・マクロ） 　　End With 　　.Cells(rw, 1).Select 　End With End Sub '// >Buttons(1).Top >というスタイルがver95の古い用法ということでしょうか？ そうです。こちらが古いです。呼び名は、フォームコントロールと言います。 Shape の仲間、言い換えれば、Officeの内部のオブジェクトです。 直感的に、こちらが良いと思われたなら、その勘は正しいと思います。(あくまでも個人的な意見ですが、私もそうしているからです）ですが、今は、こういうところは、ネット内で教わらないと、書籍等では情報は入りにくいのではないでしょうか。分からないことは、古い人に聞いたほうが早いようです。 >それとも >OLEObjectの方が古いのでしょうか？ こちらのほうが新しいです。ActiveX コントロールといいます。こちらは、外部オブジェクトです。このカテゴリで、この件に関連した、VB6 Runtimeのお話がされています。 「MSCOMCTL.OCXのアップデートの方法 」(No.9108824) 2015/11/13 >どちらを使った方が良いでしょうか？ Microsoft は、OLEObject つまり、ActiveX コントロールに統一するはずだったのですが、両方使ってみれば分かりますが、フォームコントロールのほうが軽いのは、BUCHURUNさんもお気づきかと思います。 ActiveXコントロール(OLEObject)は、右クリック・左クリック、コントロールを押しながらとか、豊富な操作ができますが、あまり数多く作ると、シート自体が重くなる傾向にあります。どちらかという扱いにくい部分があります。数がは多くない時は、OLEObject でもよいと思います。
JavaScriptになりますが、以下でどうでしょう。 id="aaa"のdivタグ部分にid="bbb"のテキストとボタンを追加し、テキストに文字を入れています。 ----------------------------------- <!DOCTYPE html> <html> <head> <title>テスト</title> <script type="text/javascript"> // 追加 function addText(){ var str; var fm; str = "要素1"; // id="aaa"部分に追加するパーツ fm = '<input type="text" id="bbb"><input type="button" value="ボタン">'; // テキスト枠とボタンを追加 document.getElementById("aaa").innerHTML = fm; // テキストに文字をいれる document.getElementById("bbb").value = str; } // 削除 function delText(){ document.getElementById("aaa").innerHTML = ""; } </script> </head> <body> <input type="button" onclick='addText()' value="追加"> <input type="button" onclick='delText()' value="削除"> <BR> <div id="aaa"></div> </body> </html>
モジュールの右クリックでの　エクスポート、インポート　が基本と思いますが・・・ ほり出し先のホルダーは、出来るだけシンプルなフォルダーを作った方が便利。
こんにちは。 MessageBoxPrt が、半角・全角混在で、できないなら、元のMessageBox　でやってみたらいかがですか？ Private Declare Function MessageBox Lib "User32.dll" Alias "MessageBoxA" ( _ 　　ByVal hWnd As Long, _ 　 ByVal lpText As String, _ 　　ByVal lpCaption As String, _ 　　ByVal uType As Long) As Integer と書いて気が付きました。#1様の示されたリンク先と同じですよね。 ただ、Form などでTextBox に、スクロールを付けて使ったほうが便利そうです。
excelの数値の扱い方の説明を、No.2回答者kmeeさんがされているように、表示と内部数値とが異なるので、いくつかの値に関してはこの計算方式では、答えが狂ってしまいます。 https://support.microsoft.com/ja-jp/kb/78113 Excelのシートであれば、 http://stabucky.com/wp/archives/3083　の説明にある ｢　桁数を表示させたいセル = ROUNDDOWN(LOG10(対象となる数値のあるセル),0)+1　｣でも、ある範囲の数値に関して桁数を表示してくれます。 ただし、その場合も、例えば｢9999999999999=14桁｣｢9999999999998=13桁｣と異なる桁数を示します。｢999999999999999000=19桁｣と誤った桁を示します。 十進数の桁をカウントするならば、見た目が大事と考える方法も有効です。文字列とみなして長さを見れば良いのでしょう。 （対象の数値はB列にある　Cells(i, 2)で選択できる　として　） VBAの場合、私の環境で、(i10 = 2.30258509299405)として ｢Cells(i, k) = Int(Log(Cells(i, 2)) / i10 + 1)｣を4000回したところ 3.38秒でした。　　 この場合、数値には0やマイナスはないとしています。 100、1000、10000などの桁数は間違って算出されます。 VBAの場合、私の環境で、（im = 10000000）として ｢ iv = Cells(i, 2) If iv < 0 Then iv = iv * -1 If iv < im Then iv = iv & ".": Cells(i, k) = InStr(iv, ".") - 1 Else iv = Fix(iv / im) & ".": Cells(i, k) = InStr(iv, ".") + 6 End If　｣ このコードで4000回したところ　2.81秒でした。 桁数に誤りはありません。（０やマイナスの数値の場合も） 対象数値0の場合、０桁とするのか、1桁とするのか気になります。 　（上記のコードは1桁に扱います） 小数点以下の桁数はカウントしません。 対象数値がマイナスの場合、上記のコードは、マイナス記号を除いて桁数を計算しています。 Int(Log(対象数値) / i10)の場合、対象の数値が ０.002の場合、桁数はマイナスになります。（logですから） ０の場合、Log(0)はエラーになります。 マイナスの場合も、Log(マイナス)はエラーになります。
>Win10 PCで作成したVBAをWin7 PCにコピーして使用するためには、 >「～7.0(SP6)(仮称)」にチェックを入れる必要があるはずです。 その場合にはWin7PCではMicrosoft ListView Control 6.0(SP4)にチェックを入れなおせば まず問題ないはずです。 ちなみに当方のWin7 Office2010 のMicrosoft ListView Controlの実体ファイルの 製品バージョンは6.01.9839 Win10 Office2016（プレビュー版）のmscomctl.ocxのバージョンも同一でした。 単純なテストですが、2016 → 2010 では問題なかったです VBAはよく言えば枯れた状態ですので大々的なアップデートは無いでしょう。 あったとしたらMicrosoft ActiveX Data Object x.x Libraryと同様 Microsoft ListView Control 6.0・・・ Microsoft ListView Control 7.0・・・ のように複数バージョンが並行して登録されるとおもいます。 >オフィスを常にアップデートして最新の状態にしておく必要があるということでしょうか？ 大多数の人は更新プログラムを自動的にインストールする設定にしたままだと思います。 最新にというかリビジョンを合わせた方がつまらないトラブルにならないと思います。 ただ、近年のアップデートは地雷が多すぎて何とも言えなくなりました。。。
他の方が質問なさっているように、不明なところがいくつかあるので、そこは適当です。 適当なので、1シート分の処理のみ。（ActiveSheetだけ処理する形） シート全部で実行するには、それぞれのシートを対象にループすれば良いですし、保存するのはsaveするだけですので・・・ ご質問文の1～7の処理だけなので、あくまでもひとつのご参考までに。 （8、9は未実装。1～7の場合以外の処理は適当です。） あと、「〇」の文字も見た目同じようなものが何種類か存在するのでご注意。 （const定義の文字で判別します。 文字を変えればそれで判別します） Sub test() 　Dim sht As Worksheet, target As Range 　Dim keyStr As String, prevStr As String, suffix As Long 　Dim rw As Long, sTmp1 As String, sTmp2 As String 　 　Const chekLetter1 = "○" 　Const chekLetter2 = "P" 　Set sht = ActiveSheet 　keyStr = sht.Cells(1, 1).Text 　prevStr = "" 　suffix = 1 　sht.Columns(5).ClearContents 　For rw = 2 To sht.Cells(Rows.count, 6).End(xlUp).Row 　　Set target = sht.Cells(rw, 5) 　　If (target.Offset(0, 1).Text = chekLetter1) Then 　　　sTmp1 = target.Offset(0, -2).Text 　　　sTmp2 = target.Offset(0, -1).Text 　　　flag = Left(sTmp1, 1) <> chekLetter2 　　　 　　　If (flag And sTmp2 = "") Then 　　　　target.Value = prevStr & "-" & str(suffix) 　　　　suffix = suffix + 1 　　　Else 　　　　If (flag) Then sTmp1 = sTmp2 　　　　prevStr = keyStr & "-" & sTmp1 　　　　target.Value = prevStr 　　　　suffix = 1 　　　End If 　　End If 　Next rw End Sub
気になるところ １・①という環境依存文字の使用 ２・既回答ですが行継続文字の位置 Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, _ SkipBlanks:=False, Transpose:=False ３・Selectしない http://officetanaka.net/excel/vba/speed/s2.htm
＞=Row()　が　成立するのに　 >＝SUMPRODUCT(OFFSET(E5,0,0,-$J$4,1),OFFSET(row(),0,0,$J$4,1))/SUM(OFFSET(row(),0,0,$J$4,1))　が　なぜ　ＮＧか？ OFFSETの関数の使い方が違うからです。 https://support.office.com/ja-jp/article/OFFSET- … OFFSET(基準とする参照位置, 参照位置からの行偏位, 参照位置からの列偏位, [指定する高さ], [指定する幅]) これが使い方なので、ROW()では適切なものになりません。 加重するウエートをセルに明示して確定させておくことが便利だと私は思います。とにかく、そこをシート上に示したくない、セルを使いたくないのであれば、次のような式も考えられると思います。 E4 = SUMPRODUCT(OFFSET($B4,1-E$2,0,E$2,1),ROW(OFFSET($A$1,0,0,E$2,1)))*2/(E$2+1)/E$2 上記では、 E2に加重平均するための期間（例えば、７や２０など）を数値で入力 B4からB789などの下方行に、変動するデータ E4の数式を下方向にドラッグコピーすれば、E2＝20ならば、 E90には、B71:B90の過去を1,2,3,4………20のウエートで加重平均した結果が表示されると思います。 上記の式の$A$1は、ただ行番号を配列にするための指定開始位置なので、$F$1にしても結果は同じです。
こんにちは。 >B列の○の回数といったカウントしません。 ご質問内容では分からない部分がありますが、早い話が、SUBTOTAL関数のような仕様で、COUNTIFSを再現したい、というご趣旨かと思います。 ということはも少なくとも、COUNTIFS　を模したユーザー定義関数でなくてはなりません。だから、内容がCOUNTIFのままでは、先に進みません。しかし、私の以下のコードも、満足といえるものではありませんが、一時しのぎでもみていただけますでしょうか。 以下では、ワイルドキー(?*)は使えますが、記号の[大なり(>)]・[小なり(<)]・[等しい(=)]が使えません。昨日から考えているのですが、簡単な方法が思いつきません。分岐するなりして長い式なら可能だと思います。もう一つは、引数は、本来、パラメータ配列になっているのですが、これをダブルで取るということが再現できていません。しかし、私の力としては、こんな所でしょうか。 なお、以下は、変数のrgSelectの名前は長いので、rgのみにしました。 '// Public Function SUBTOTAL_COUNTIFS(rg As Range, moji As String, Optional rg2 As Range, Optional moji2) 　　Dim cot As Long 'カウンタ 　　If Not (rg.Rows.Count = 1 Or rg.Columns.Count = 1) Then Exit Function　'① 　　If Not rg2 Is Nothing Then　'② 　　If Not (rg.Rows.Count = rg2.Rows.Count And rg.Columns.Count = rg2.Columns.Count) Then Exit Function　'③ 　　End If 　　For i = 1 To rg.Cells.Count 　　　　If Rows(rg(i).Row).Hidden = False Then '表示されている行だけ対象にする 　　　　　　If rg(i).Value Like moji Then 　　　　　　　If Not rg2 Is Nothing Then　'④ 　　　　　　　　If rg2(i).Value Like moji2 Then　'⑤ 　　　　　　　　　cot = cot + 1 　　　　　　　　End If 　　　　　　　Else 　　　　　　　　cot = cot + 1 　　　　　　　End If 　　　　　　End If 　　　　End If 　　Next 　　SUBTOTAL_COUNTIFS = cot End Function '/// ①. 縦横どちらか一つは、一行・一列でなくてはなりません。 ②,④. 引数が1セットの場合は、除外 ③.　引数が2セットの場合、1セット目と範囲の形状は同じでなくてはならない。ただし、横は、隠し列には反応しません。 ⑤.　文字比較のLike演算子を利用します。 関数で考えてみましたが、 =SUMPRODUCT((B2:B7="○")*(C2:C7="×")*SUBTOTAL(3,OFFSET(D1,ROW(A1:A6),0))) これはよりは、ユーザー定義関数のマシかもしれません。ただし、Public でも、アドイン型などグローバルにしたほうがよいかもしれません。
Dim work As Integer ' ’まず、ラベルのキャプションに 1～36を順番に格納する For i = 1 To 36 Label4(i - 1).Caption = i Next ' ' 次に 36～1迄ループをしていく For i = 36 To 1 Step -1 ' ' 初回 36迄の乱数、2回め 35迄の乱数、３回め34迄の乱数・・・ sekigae = Int(Rnd() * i + 1) ' ' 初回36番目の配列の値と、ランダム番目の配列の値を入れ替える work = Label4(i - 1).Caption Label4(i - 1).Caption = Label4(sekigae).Caption Label4(sekigae).Caption = work Next これでいいはず
まず、エラーについて このコードを貼り付けた場所が間違ってると思います。SubプロシージャはどこにくっつけてもいいですがConstステートメントは指定の場所に書かないとエラーになります。 エラーは「End Sub、End Function、End Property以降には、コメントのみが記述できます。」ってゆうのがでませんでしたか？ これは書いてあるとおりでConstステートメントはPrivate、Publicを指定しない時はSub、Function、Propertyプロシージャ内にしか書けません。Private、Publicを指定する時はモジュールレベルに書かないといけません。 コピー処理について コピー元ブックのどのシートのどの範囲をコピー先のブックのどのシートのどの範囲でコピーすればいいですか？ ブックの名前とシート名と範囲を正確に教えて下さい。
再びすみません。 G10が日曜なら印刷しない、ということだと、 それ以外なら印刷する、のでいいですよね？ だったら、そのIf節内で分岐させないとダメですね。 If Weekday(Range("G10").Value<>vbSunday Then ActiveSheet.PrintOut Else End If ですかね。 Elseのとこ、つまり、日曜の時は何もしない、 としてます。 まあElseは無くても回ると思いますが。
0 (非表示）ではダメなのでしょうか？ ffmpegは使っていないので紹介は知りませんが ログが見たいのであれば バッチファイルでリダイレクトでファイルに落とすなどの方法もあるかと思います
If ActiveSheet.Name = "目次" Or ActiveSheet.Name = "印刷用" Or ActiveSheet.Name = "集計" Then Exit Sub If Range("AJ19").Value Like "*おわり*" Then Exit Sub とか If ActiveSheet.Name Like "*おわり*" Then Exit Sub を加えてはダメでしょうか。
setステートメントでオブジェクトを代入をしているので参照先がないとどうにもなりません。 開いてるから参照先を見れてそこで初めてコントロールを参照できるようになります。
一旦、variant型で初期値を格納し、それをInteger型の配列に転送しなおすのが最も簡単な方法です。 コードは以下のようになります。 ------------------------------------------- Public Sub testx() Dim varArray As Variant Dim intArray() As Integer Dim i As Integer varArray = Array(1, 20, 300) 'Integer型に格納 For i = 0 To UBound(varArray) ReDim Preserve intArray(i) intArray(i) = varArray(i) Next '内容を表示 For i = 0 To UBound(intArray) Debug.Print intArray(i) Next End Sub ------------------------------------------- 実際に必要なのは、'Integer型に変換・・・の部分です。 '内容を表示・・・の部分は確認の為です
artooさんが答えられている事の補足となります >どのような用途で用いられるのでしょうか？ 実際に使用されている例としてはMsgBox関数が該当します これはOKボタン等のボタンを押した事を返しますが、通常受け取り用の変数は設定しないと思います この様に返り値が必要であったり、不要であったりするケースの場合もfunctionで定義すべきとなります
No.1の者です ひょっとしてUserForm1に入力された数字を変数に格納する方法も不明なのかと思い、 一応下記を紹介させていただきます 「エクセルの神髄｜鵜原パソコンソフト研究所」 http://excel-ubara.com/excelvba3/EXCELFORM007.html セルに入力してある部分を、検索のキーとして使う変数に書き換えれば使えます 検索に関してですが紹介したサイトは1個見つかる毎に変数に記録しております そこを都度見つかったセルを選択し、下記のコピー処理を行うように変更すれば、 処理時間はともかく作りとしては簡単だと思います コピーに関してですが、コピー範囲の開始セルは検索で選択するとします 次に終端の最右列とでも呼べばいいでしょうか、そのセルは途中に空きが無い限り Range(Selection, Selection.End(xlToRight)) の範囲をコピーすればいい事になります そのため下記でコピーができるはずです Range(Selection, Selection.End(xlToRight)).Copy コピー先
#1です。 コメントありがとうございます。 >Option Explicit は、変数を宣言する、というコードなんですね いえ、違います。 変数の宣言を強制するコードです。 どういうことか。 変数の宣言は、一般的にはコードの冒頭で、Dim なんとかって することが多いと思います。 ですが、宣言せずにいきなり使用することもできます。 たとえば、 Hensu = Range("A1").Value なんて具合に。 しかし、長く複雑なコードを書いたりする時には、時として 誤って、Hansu って書いてしまうかもしれない。 そうすると、PCは、これを別の変数と認識し、思わぬエラーの 元となります。 このOption Explicit を冒頭に記しておくことで、「変数は宣言せず には使用出来ないモード」となります。 これが、変数の宣言の強制です。 なんらかの不具合が起きた時に、デバッグの必要がありますが、 変数の宣言がされていない場合は、どこで不具合が起きたのかが 分かりにくく、ホントにエラい目を見ます。 ですから、この変数宣言の強制は絶対しておいたほうが良いです。 以下のコラムが分かりやすいです。 http://officetanaka.net/excel/vba/variable/02.htm なお、今まで宣言無しで書いてきたコードの冒頭に、 Option Explicit を書けばエラーとなります。
Bさんのデータを選択する手段が自動か手動か関係ないのでは？ -----元々のやりたい内容 手動 1. Bさんのデータを選択（手動） スクリプト実行 2. （選択されている）Bさんの画面2を開く 3. 判定して画面2を閉じる 4. （選択されている）画面1のBさんのデータをクリップボードにコピー 　　※ここが上手くいかない 5. 次の処理 ----- 1.は手動操作 2,3の自動化は既にできている。（どの様にスクリプトを起動するか不明ですが） ならばスクリプトの2の前に4の処理を追加すれば良いだけなのはないですか？ ----- 手動 1. Bさんのデータを選択 スクリプト実行 2. （選択されている）画面1のBさんのデータをクリップボードにコピー 3. （選択されている）Bさんの画面2を開く 4. 判定して画面2を閉じる 5. 次の処理 ----- やりたいことの内容が今一つ伝わってないような気がします。 もう少し細かい作業手順のご説明があった方が良いのかもしれません。
No,4,7です。 ThisWorkbook.Saved　は、開いたまま編集がされていない 或いは、上書き保存した後のままであるかどうかです。 ThisWorkbook.Saved　がFalseの場合は、閉じる際に上書き保存しますかと聞いてきます ThisWorkbook.Saved　が Trueの場合は、そのまま閉じられます。 なので、　Falseの場合、無理やり　True　にしてしまえば 上書き保存しますか　と聞かれないまま閉じてしまいます。
Range("B7").AutoFill Destination:=Range("B7:B"; & Range("B7").End(xlDown).Row + 1), Type:=xlFillMonths
こんばんは。 最後のご質問から手をつけると、 >コマンドを送る側で制御したほうが速い、 というのは、 前回の流れの話ですが、 Private Sub TextBox14_Change() Dim txtbox As Object Set txtbox = TextBox14 call routine(txtbox)　 End Sub 内容を良く分かっていないのに、私は中途半端にことを言ったのですが、もしも、TextBox14 に値を送るなら、送る側から処理したほうが楽だという意味なのです。 call routine(txtbox)　'特にこのサブプロシージャの場合です。 この場合は、当該のTextBox の値が反映されていないからですが。 >Class インスタンスというものがどういうものか >分かっていないのですがこれはどうやって使うものなのでしょうか？ これも想像の話なのですが、TextBox14, とか15 とか、テキストボックスの数を抱えているわけですね。しかし、動いているオブジェクトが何か分からないという場合は、何かのフックをクラスで取り付けてあげるわけです。 以前、モーグにありましたが、今は見つかりませんので、同じような内容のものを探してみました。 http://www.liveway.net/technic/20110428_090002.h … "複数のコントロールのイベントを一つのプロシージャにまとめる(ExcelVBA)" ここの部分が重要： Private WithEvents Btn As MSForms.CommandButton　を このコントロールの部分をテキストボックス(TextBox)に置き換えてみれば、なんとなく分かるはずです。 例えば、 Private WithEvents Tbx As MsForms.Textbox という次第で、多くのTextBox のイベントを一つにまとめてしまうことです。これを、私などは、VBAの「擬似コントロール配列」と呼んでいます。この言葉で、ググるといろんな説明が出てきます。 あまり、全体が見きれていないので、元の質問の核心部分は触れていないような気がしますが、こんなところでいかがでしょうか。
> ということなのですがなぜ-1する必要があるのでしょうか？ 二進数の1111111111111111が十進でいくつかを計算するのに、2^15+2^14+・・・+2^2+2^1+2^0と計算するのが面倒なので、1を足せば10000000000000000になるので、2^16と簡単に計算できます。ここからさっきの1を引きます。十進数2桁の最大数値が99なのと比較して考えてみてください。
>9223372036854775807までは格納できるのですが >これを超えた場合にはVBAでどのように扱えば良いかを教えていただきたいのですが 要は、9223372036854775807より大きな整数を扱う、四則演算をしたいということでしょうか？ その場合は、多倍長整数を扱うパッケージが必要になります。 参考１： http://supermab.com/biginteger.html 上記のサイトは、動作環境として NetFramework4.0 がインストールされている必要があります。 Excel2000以降がインストールされている必要があります。 とうことですが、その要件を満たしているなら利用可能かと思います。 参考２： http://qiita.com/mmYYmmdd/items/23ad7ce279f2828a … 上記のサイトは、多倍長整数を扱うパッケージを独自に開発されたかたのサイトです。 以上、参考まで。
たとえば Sub test() Dim objWSH As Object Set objWSH = CreateObject("WScript.Shell") Dim RtnVal As Long RtnVal = objWSH.Run("%comspec% /c ping 127.0.0.1 -n 10", 8, True) Debug.Print RtnVal End Sub として試すと終了後にはRtnValには0が返ります。 コマンドプロンプトを強制終了させると-1073741510 でした。 pingをpongにすると1になりました。 なのでRtnValの返り値が0かそれ以外かで判断しては？ ※深く考えてはいません。 あなたのCommandの内容次第かもしれない。
passというファイルをコピーしようとしています。 ×　FSO.CopyFile "pass", "D:\Test\" ○　FSO.CopyFile pass, "D:\Test\" 複数選択は、下記URLの 「『ファイルを選択する』（msoFileDialogFilePicker）使用例」 のプログラムが参考になるのではと思います。 .SelectedItems(i)でファイル名を取り出していますね。 http://www.239-programing.com/excel-vba/func/fun …
気になったの体系的に変換後のByte列を確認してみました。 まず前提としてプログラムソース上に書かれた文字列（例："あいうえお")はUnicodeであって、cp932(sjis)ではありません。（プログラムaaa()のr0より） 確認結果は以下の様になりました。 　変換方法　　　　変換元文字　　変換後 1.vbFromUnicode 　Unicode 　　　cp932(sjis) 2.vbFromUnicode 　異常Unicode 　Unicode 3.vbFromUnicode 　cp932 　　　　3Fの連なり（異常） 4.vbUnicode 　　　Unicode 　　　異常Unicode 5.vbUnicode 　　　異常Unicode 　異常Unicode（0が更に追加される） 6.vbUnicode 　　　cp932 　　　　Unicode 　※異常Unicodeとは、0が間に挟まる文字列です。 1番と6番が変換方法と変換前の文字コードが適合している正常な使用方法で結果も正常となります。 その他は変換方法と変換前の文字コードが適合していない誤った使用方法となり、結果は正常なものではありません。2番は変換結果がUnicodeとなって一見正常と見えますが誤った使用方法です。 ご質問後半ですが r6()の変換が誤った変換（Unicode文字列をvbUnicodeで変換）を行っているため結果が正常にならないのだと思います。 ※下記で、StrConv()の第一引数をCStr()で囲んでいないのは、無くても結果が変わらなかったので省略したためです。 Option Explicit Sub msg(ByVal str As String, ByRef a() As Byte) Dim s As String Dim i As Integer Dim v() As String s = str & "= " ReDim v(UBound(a())) For i = 0 To UBound(a()) v(i) = Hex(a(i)) Next MsgBox s & Join(v()) Range("a1") = s & Join(v()) End Sub Sub aaa() Dim r0() As Byte Dim r1() As Byte Dim r2() As Byte Dim r3() As Byte Dim r4() As Byte Dim r5() As Byte Dim r6() As Byte r0() = "あいうえお" Call msg("r0", r0()) '42,30 ～ 4A,30 プログラムソース上の文字列はUnicode r1() = StrConv("あいうえお", vbFromUnicode) Call msg("r1", r1()) '82,A0 ～ 82,A8 vbFomUnicode(Unicode)はcp932へ正常変換 r2() = StrConv("あいうえお", vbUnicode) Call msg("r2", r2()) '42,0,30,0 ～ 4A,0,30,0 vbUnicode(Unicode)は異常Unicodeへ異常変換（0が挟まる） r3() = StrConv(r1(), vbUnicode) Call msg("r3", r3()) '42,0,30,0 ～ 4A,0,30,0 vbUnicode(cp932)は異常Unicodeへ異常変換（0が挟まる） r4() = StrConv(r1(), vbFromUnicode) Call msg("r4", r4()) '3F ～ 3F vbFromUnicode(cp932)は異常変換 r5() = StrConv(r2(), vbFromUnicode) Call msg("r5", r5()) '42,30 ～ 4A,30 vbFromUnicode(異常Unicode)はUnicodeへ正常変換（見た目） r6() = StrConv(r2(), vbUnicode) Call msg("r6", r6()) '42,0,0,0,30 ～ 4A,0,0,0,30 vbUnicode(異常Unicode)は更に異常Unicodeへ変換 End Sub Sub bbb() Dim r4() As Byte Dim r5() As Byte Dim r6() As Byte Dim r7() As Byte r4() = StrConv("あいう\ku予定表", vbFromUnicode) r5() = StrConv(CStr(r4()), vbUnicode) Call msg("r5", r5()) 'r5= 42 30 44 30 46 30 5C 0 6B 0 75 0 88 4E 9A 5B 68 88 r6() = StrConv("あいう\ku予定表", vbUnicode) r7() = StrConv(CStr(r6()), vbFromUnicode) Call msg("r7", r7()) 'r7= 42 30 44 30 46 30 5C 0 6B 0 75 0 81 45 9A 5B 68 81 45 End Sub
http://www.vector.co.jp/soft/win95/net/se265977. … でhtml形式で保存してWordで開けば（コピペではなく）出来るかも？
こんにちは。 あくまでも、Excelに関してということになりますが、VBE上で変換作業をしてみても、あまり実感が沸かないはずです。Excel97の時に、VBE上は、確かに、Unicodeに変わったはずですが、閲覧できるのは、あくまでも、JISの範囲に限られます。矛盾しているような気もしますが、それで長年続いています。 それと、これらの変換の過程は、添付画像で示すように、UserFormのTextBox でやるのが判りやすいはずです。 >gg = StrConv("あ", vbFromUnicode) >と「あ」だけ変換しても"?"になってしまいます。|Unicodeは読めない。 それが、VBE上での現象です。 >一体、このB0というのはどこから来る値なのでしょうか？ >gg2 = StrConv("あ", vbUnicode) >と変換すると"B0"が得られたので あまり意味はないことですが、"B" =42, "0"=30 の文字コードを変換しているにすぎません。 >chr()、Hex(Asc("　"))で得られる結果の違い Chr()は、10進の文字コードの代入ですよね。 ASC(文字）で排出するのも、10進です。16進にしても意味ないと思います。 >CStrにはUnicodeを文字列に変換する機能もあるのでしょうか？ ばらばらのコードをつなぎ合わせるようです。 Dim d2(1) As Byte "あ" ->82A0 d2(0) = &H82 d2(1) = &HA0 s12 = StrConv(CStr(d2()), vbUnicode) Dim d3(1) As Byte "あ" ->3042 (Unicode) d3(0) = &H42 d3(1) = &H30 'VBAでは逆になります(ビッグ・エンディエン） s13 = CStr(d3()) こんなところでしょうか。
> bbb= (aaa(3)) Or (aaa(2) * &H100&) Or (CDbl(aaa(1)) * &H10000) Or (CDbl(aaa(0)) * &H1000000) > これがオーバーフローするのはなぜでしょうか？ 私の環境では、以下の様になりました。 2147483647 Or 1　→　2147483647 2147483648 Or 1　→　オーバーフロー ビット演算を行う場合は両側の数値をInteger型に変換して演算を行う様です。 従ってInteger型の表現できる範囲を超えた数値はオーバーフローします。 ※これまでの流れでOr演算子が登場する意図がわかりません。 　行いたい目的を記載されたほうが、より適切な回答が付くのではないでしょうか？
参考になるかわかりませんが Sub macro2() Dim Sh Dim i As Integer Dim lRow As Long, lCol As Long, lRow2 As Long Application.ScreenUpdating = False '----列見出しをコピーします Worksheets(2).Range("1:1").Copy Worksheets(1).Range("A1") '----コピーする順番にシート名を配列Shに登録します Sh = Array("Sheet1", "Sheet2", "Sheet3") For i = LBound(Sh) To UBound(Sh) With Worksheets(Sh(i)) lRow = .Cells(Rows.Count, 1).End(xlUp).Row lCol = .Range("a1").CurrentRegion.Columns.Count If lRow >= 2 Then lRow2 = Worksheets(1).Cells(Rows.Count, 1).End(xlUp).Row + 1 .Activate .Range(Cells(2, 1), Cells(lRow, lCol)).Copy Worksheets(1).Cells(lRow2, 1).PasteSpecial Paste:=xlPasteValues End If End With Next i Worksheets(1).Activate Range("A1").Select Application.ScreenUpdating = True End Sub
> VBAだとForだとできないとしてVBやC言語などは > Forを使わずに全検索する機能があるのでしょうか？ ファイルに保存されているシーケンシャルなデータを検索するのですから、言語によらず頭から順にチェックしていくしかないはずです。組み込みの検索関数などの機能があって多少の最適化アルゴリズムを使用しているかもしれませんが、結局は同じことではないでしょうか？ あと、速度を気にされるのでしたらVBAよりも、いずれかのコンパイル言語を使用したほうが良いと思います。 > あと、Unicodeだと一文字2バイトのはずなので > ANSI形式で読み込まれているということでしょうか？ たしかに内部表現ではUnicodeを使用しているかもしれませんが、そもそもファイルをbinaryモードでオープンしている時点で適切なエンコードは行われないと思います。
レポートに値は代入できなかったと思います。 どうしてもVBAで行いたいのであればレポートをデザインで開きラベルを書き換えて下さい。 フォームの値を持ってくるだけなら レポートのテキストボックスのコントロールソースに =[Forms]![F_Main]![txt_NO] と入れるだけでフォームの値を持ってこれます。
こんばんは。 strClip = objHTML.ParentWindow.ClipboardData.SetData("text","文字を送る") もちろん、このコードは、ClipboardDataから、文字列を取得するなら、 strClip =objHTML.parentWindow.clipboardData.getData("text") ではあるのですが、 >Set objHTML = CreateObject("htmlfile") >objHTML.ParentWindow.ClipboardData.SetData("text","文字を送る") これ自体が、クリップボードに文字を送れないですね。 どうしてか分かりません。 ご指摘のように、 Set objHTML = CreateObject("InternetExplorer.Application") を使ってはできるようですが、途中で、IEのセキュリティに引っかかってしまいますので、変更しなければなりません。 無難なところでは、以下のような方法ぐらいしか思いつきません。 '// Set objHTML = CreateObject("HTMLfile") Const sTEXT ="文字を送れます" ret =objHTML.parentWindow.clipboardData.clearData("text") ''ret =objHTML.parentWindow.clipboardData.setData("text", sTEXT) Call PutInClip(sTEXT) strClip =objHTML.parentWindow.clipboardData.getData("text") If IsNull(strClip)=False Then MsgBox strClip Else MsgBox "err" End If Set objHTML = Nothing 'ここで終わり Sub PutInClip(Text) Set WshShell = CreateObject("WScript.Shell") Set oExec = WshShell.Exec("clip") Set oIn = oExec.stdIn oIn.WriteLine Text oIn.Close End Sub '///
コード見せて頂いてもよろしいでしょうか？
その示したプログラムが実際にどんな期待を裏切る動きをするのかくらい示さないと…。 どんな裏切り行為をするのかまで読むのが面倒なので、別のアプローチからのアドバイス。 いきなり全部の動作を行うプログラムから書き始めていないか？ １～５を１ステップずつ作ればデバッグも簡単だ。 今作ってあるモノは破棄して、新しく作り直すことを勧めてみる。 質問文を見る限り、いきなり完璧なモノを作ろうとしているように感じるのだ。 慣れていないならそんな無茶はしてはダメ。
プロパティウィンドウを表示しておいて、一番上にあるコントロールのコンボボックスから探したいコントロール名を選ぶ。
質問があっていればですが >④検索しリストボックスに表示された項目を選択し、「OK」のコマンドボタンをクリックしたら「学生情報」のユーザーフォームを開き、それぞれのテキストボックス（27項目程）に表示 学生情報のフォームに Private Sub UserForm_Initialize() TextBox1.Value = 検索Form.ComboBox1.Value ・・・・ TextBox27.Value = 検索Form.???.Value End Sub と云った感じで、学生情報のフォームを開いたら、検索フォームのそれぞれの値を引っ張って来る どうでしょうか。
問題ありませんよ。 提示されているコードに関して言えば、sb2はインスタンス化されてるけど、値が何も入ってません。打ち間違い、ですよね？
勘違いをして回答してしまいました。 ｢テーブル書式を挿入して、そのテーブルで｣という質問でした。 ならば、次のようなので、対応するかもしれません。 Sub Macro2() tbcount = ActiveSheet.ListObjects.Count If tbcount > 0 Then For i = 1 To tbcount If Not ActiveSheet.ListObjects(i).AutoFilter Is Nothing Then If ActiveSheet.ListObjects(i).AutoFilter.FilterMode Then MsgBox "テーブル" & i & "は、絞り込まれています" Else MsgBox "テーブル" & i & "は、絞り込まれていません" End If End If Next i End If End Sub AutoFilterを解除するのは、AutoFilterをかけているFieldを選んで そのFieldの位置（列番号）を指定するだけでOKです。 下は、"テーブル１"で列3のAutoFilterを解除するもの ActiveSheet.ListObjects("テーブル1").Range.AutoFilter Field:=3 ActiveSheet.ListObjects(1).Range.AutoFilter Field:=3
1. strHTML = objIE.Document.all(0).outerHTML 2. 無いと思います。 　ファイルに書き出してみれば確認できます。
こんにちは。 内容が唐突過ぎて、ずっとあれこれ考えて、返事がつけられませんでした。 >Document.body.innerTextで取得した内容 と書いていますが、その親オブジェクトは、IEオブジェクトですか？当たり前のようで当たり前でないからです。 それで、innerText では、配列に取るなら、どうやっても、何らかの方法で切り分けるしかないのではないですね。 切り分けるなら、innerHTMLの方が楽ですが、そもそも、Document.bodyのテキストから取り出すというところが問題がないでしょうか。返って煩雑になってしまうのです。さしずめ正規表現を駆使して取り出すというのも、一つのアイデアですが、innerHTMLの方が楽ですが、それも、一考が必要です。 FileSystemObject？ ストリーミングにでもするということでしょうか。 ここまで書いて、終わったら、不完全燃焼ですから、Sample　を示しておきます。 ここのサイトのデータを取得する、即席のマクロですが、こんな具合です。なんとなく、イメージが分かりますでしょうか。何かの参考になればとおもいます。配列のbuf に、それぞれのデータを格納します。 　Dim objIE As New InternetExplorer　'事前バインディング 　'サイトにアクセスして、その後は、以下の通りです。 　With objIE 　　　'関係のない変数の宣言は全部省略しました。 　　　Dim buf(7) 　　　Set pd = .Document.getElementsByClassName("date") 　　　b = Replace(pd(0).innerText, "質問日時：", "") 　　　buf(2) = Format$(b, "yy-MM-dd hh:mm") 　　　Set pa = .Document.getElementsByClassName("author") 　　　buf(5) = Replace(pa(0).innerText, "質問者：", "") 　　　Set pi = .Document.getElementsByTagName("meta") 　　　For i = 0 To pi.Length 'タイトル 　　　If pi(i).getAttribute("property") = "og:title" Then buf(3) = pi(i).Content 　　　Next i 　　　Set pj = .Document.getElementsByName("good") 　　　If pj.Length > 0 Then 　　　　buf(6) = pj(0).getAttribute("data-qid") 'id 　　　Else 　　　　Set pid = .Document.getElementsByClassName("q_only_remark_item") 　　　　Set pid_c = pid(0).ChildNodes 　　　　b = pid_c(1).innerHTML 　　　　buf(6) = val(Mid(b, InStr(1, b, "/question/") + 10)) 　　　End If 　　　'--続く-- 　End With
こんばんは！ 画像を拝見する限りではD列に重複がないように見えますので・・・ Sub Sample1() Dim i As Long, c As Range Range("A:E").Interior.ColorIndex = xlNone For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row Set c = Range("D:D").Find(what:=Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then Union(Cells(i, "A").Resize(, 2), c.Resize(, 2)).Interior.ColorIndex = 10 End If Next i End Sub 余計なお世話かもしれませんが、D列に重複データがある場合は すこし面倒ですが↓のコードでやってみてください。 Sub Sample2() Dim i As Long, myRng As Range, myArea As Range Dim myFound As Range, myFirst As Range Range("A:E").Interior.ColorIndex = xlNone For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row Set myFound = Range("D:D").Find(what:=Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not myFound Is Nothing Then Set myFirst = myFound Set myRng = Union(Cells(i, "A").Resize(, 2), myFound.Resize(, 2)) Do Set myFound = Range("D:D").FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do Set myRng = Union(myRng, myFound.Resize(, 2)) Loop If myArea Is Nothing Then Set myArea = myRng Else Set myArea = Union(myArea, myRng) End If End If Next i If Not myArea Is Nothing Then myArea.Interior.ColorIndex = 10 End If End Sub ※　Sample2であれば重複があってもなくても対応できます。m(_ _)m
質問文に書いてある単一ユーザーを取得する書き方に沿えばこんな感じかなぁ。 Dim objOU, objUser Set ObjOU = CreateObject("LDAP://OU=OU123_ユーザー,OU=OU123,DC=ad,DC=test,DC=com") objOU.Filter = Array("user") For Each objUser In objOU 　Debug.Print objUser.Name Next 複数のアカウントを取得するので ADODB で DB のように取り扱うこともできそう。(ちょっと長いけど) Dim objConn, objComm, objRst Set objConn = CreateObject("ADODB.Connection") Set objComm = CreateObject("ADODB.Command") objConn.Provider = "ADsDSOObject" objConn.Open "Active Directory Provider" set objComm.ActiveConnection = objConn objComm.Properties("Page Size") = 1000 ' 検索結果の最大取得数 objComm.Properties("Searchscope") = 1 ' この OU の配下も全部なら 2 を指定 objComm.CommandText = "SELECT Name From 'LDAP://OU=OU123_ユーザー,OU=OU123,DC=ad,DC=test,DC=com' WHERE objectCategory='user'" Set objRst = objComm.Execute objRst.MoveFirst Do Until objRst.EOF 　Debug.Print objRst.Fields("Name").Value 　objRst.MoveNext Loop 私は今まで Excel でアカウントの台帳を作っていたので、これを元に Active Directory を操作できないかと考えていたのですが、最近になって考え方を改めました。 台帳はあくまでも Active Directory なので、ユーザーのリストがほしければ都度取得すればいいじゃないか、と。 アカウント登録や変更も、[対象アカウントの存在確認] → [更新] をすりゃいいじゃないか、と。 それで Excel 台帳による二重管理を捨て、PowerShell によるいくつかのスクリプト ファイルを作っているところです。 一覧を取得するだけなら以下の 1行でできちゃいますし。 Get-ADUser -Filter * -SearchBase "OU=OU123_ユーザー,OU=OU123,DC=ad,DC=test,DC=com" -Properties * -SearchScope OneLevel | ForEach-Object { $_.Name}
今頃レスをつけても遅いかもしれませんが、こういうことではないでしょうか。 一例です。 '// Sub Test1() 　Dim pic As Object 　Dim buf As Variant 　For Each pic In ActiveSheet.Pictures 　　buf = StrConv(pic.Name, vbProperCase)　'万が一を考えて半角にしておく。 　　buf = Replace(buf, "Picture", "", , , vbTextCompare)　'要するに数字を取得したい 　　If Val(buf) > 0 And Val(buf) < 2000 Then　'Val は、先頭の半角空白は無視してくれます。 　　　pic.Delete 　　End If 　Next pic End Sub '/// この部分は、 Replace(buf, "Picture", "", , , vbTextCompare) "Picture " と半角スペースを入れればよいとは思うでしょうけれども、もし、手動で書き入れて、半角スペースがなければ、残ってしまいます。逆に、"Pictrue" の場合は、半角スペースが残りますが、Val関数は無視してしまいます。
eee = "abcdefghijk" というのを2行に書くと言うことですかね。 >各行毎に""を閉じる必要がありますか？ そうですね。空白を置ける場所でしか _ による継続は出来ません。
> Dim Atai7 As Long long型は整数なので小数点以下は四捨五入されていまします。 Single型がDouble型を使用してください。
#1です。 >この式はどうやって導いたのですか⁇ A列の1行(lineの値) を C列の1行へコピー A列の2行(lineの値) を C列の4行へコピー A列の3行(lineの値) を C列の7行へコピー となっています。 この関係から lineの値から１を引いて、それを３倍し、１を加える　と良いことが判ります。 もしくは、 lineの値を３倍し、それから２を引いても良いです。(line*3-2) その場合は、 line*3-2　　・・・C列の1回目のコピー line*3-1　　・・・C列の2回目のコピー line*3　 　・・・C列の3回目のコピー のようになります。 これらは A列の1行(lineの値) -> C列の1行 A列の2行(lineの値) -> C列の4行 A列の3行(lineの値) -> C列の7行 のように、いくつかサンプルをとって、試行錯誤すれば、規則が導けます。 （多少、慣れも必要ですが、何回かやれば要領がつかめます）
補足に対して、 ShellObj.Run で実行できるのは拡張子が exe、com、bat、cmd だけです。pauseはpause.exeじゃなくて「コマンドプロンプト」cmd.exeの組み込みコマンドです。 従って、pauseを引数で指定した cmd.exe を起動する必要があります。%ComSpec% には cmd.exe がセットされています。 ShellObj.Run "cmd /c pause",,True でも同じです。
こんにちは。 マクロ有効ファイル等は関係ありません。 ファイル－情報－共有準備 [問題のチェック] [これらの情報をファイルに保存できるようにする] この最後の下線が入った部分をクリツクして、表示を消します。 画像をみてください。
テスト用のコードを作成しました。２種類あります。 マクロ「SheetSet」は空のブックに模擬データを作ります。新規ブックに対して行ってください。 実際の業務用ブックでは、複雑な条件（関数や他ブックの参照など）があるため、要素を単純化した模擬データで問題解決していった方がいいような気がします。 処理 ①Q5:Q3000にランダムな文字列「土・日・月」のいずれかを入力。 　検索に使います。 ②W5:W3000に=row()*10 ③X5:X3000に　=row()*100 この関数式の【値】を取り出すテストを行います。 ④AB5:AB3000には、５行ごとに"データ”という文字列を入力します。 ⑤AC5:AC3000には、３行ごとに"データ”という文字列を入力します。 次にマクロ「Test」を使って、動作確認をします。 やることは ５行目から３０００行目まで 【Q列の値が(土)の行 ＆ AB列の値が空白】→【W列の関数式の（値）をAB列に転記】 【Q列の値が(土)の行 ＆ AC列の値が空白】→【X列の関数式の（値）をAX列に転記】 Q列の値が(土)の行のAB:AC列に、W:X列の関数式の（値）を転記するわけです。 ただし、AB5:AB3000には、５行ごとに"データ” AC5:AC3000には、３行ごとに"データ”があります。 この文字列は消えません。 かなり単純な内容ですが、この模擬ブックとコードを元に、少しずつ改良していけたらと思います。 ----------------------------------------------------------------------- Sub SheetSet() Dim i As Long Cells.Clear For i = 5 To 3000 Cells(i, "Q") = Int(Rnd() * 3) Cells(i, "W").Formula = "=row()*10" Cells(i, "X").Formula = "=row()*100" If i Mod 5 = 1 Then Cells(i, "AB") = "データ" End If If i Mod 3 = 1 Then Cells(i, "AC") = "データ" End If Next Columns(17).AutoFit Range("Q:Q").NumberFormatLocal = "AAA" Range("W:X").EntireColumn.AutoFit Range("A:P").EntireColumn.ColumnWidth = 0.1 Range("R:V").EntireColumn.ColumnWidth = 0.1 Range("Y:AA").EntireColumn.ColumnWidth = 0.1 For i = 5 To 3000 If Cells(i, "Q") = 0 Then Cells(i, "Q").Interior.Color = vbCyan End If Next End Sub ----------------------------------------------------------------------- ----------------------------------------------------------------------- Sub Test() Dim i Dim fRange1 As Range Dim fRange2 As Range Set fRange1 = Cells.Find("土", LookIn:=xlValues) If fRange1 Is Nothing Then MsgBox "" Exit Sub Else Set fRange2 = fRange1 If Cells(fRange2.Row, "AB") = "" Then Cells(fRange2.Row, "AB").Value = Cells(fRange2.Row, "W") End If End If If Cells(fRange2.Row, "AC") = "" Then Cells(fRange2.Row, "AC").Value = Cells(fRange2.Row, "X") End If Do Set fRange2 = Cells.FindNext(fRange2) If fRange1.Address = fRange2.Address Then Exit Do Else If Cells(fRange2.Row, "AB") = "" Then Cells(fRange2.Row, "AB") = Cells(fRange2.Row, "W") End If If Cells(fRange2.Row, "AC") = "" Then Cells(fRange2.Row, "AC") = Cells(fRange2.Row, "X") End If End If Loop End Sub -----------------------------------------------------------------------
-n : 入力情報をそのまま出力しない s/A/B/ : 行内に A で指定したパターンがあればBに置き換える p : 置き換えがあったら置き換え後を表示 .* : 「何か」のパターン (任意の文字が0個以上連続するパターン) .*A.*B.* : 最初に何か、A と B に挟まれた何か、最後に何か、のパターン \(...\) : 後で参照したい部分を示す括弧 \1 : 1番目の括弧の内容 s/.*A\(.*\)B.*/\1/ : 行内に A と B ではさまれた「何か」があれば、その何かだけに置換 というわけで、 処理: sed -n 's/.*A\(.*\)B.*/\1/p' 意味: 標準入力から、A と B に挟まれた「何か」がある行があれば、その何かのみに行を置換して表示
> クロックが　i７＝2.0　ｉ５＝2.3　と違いますが・ そんなに重い処理ではないようですから、クロックの差というのが妥当と思う。 Pentium 4の3.40GHzのパソコンを持っている者が友人等に居れば、そのパソコンで実行してみて比べてみると面白いかも。
一案です。 関数で、一番下の行番号を取得する際には、Match関数を使いますが 空いているセルに =MATCH(10^8,C:C) C列の一番下の値なら =INDEX(C:C,MATCH(10^8,C:C)) と入れてみてください。希望する最後の行何番号がでるようでしたら マクロで活用してみてください Sub ボタン1_Click() MsgBox Range("C" & Range(関数の入っているセル).Value).Value End Sub セルの関数をマクロで行うなら Sub ボタン1_Click() MsgBox WorksheetFunction.Match(10 ^ 6, Columns("C:C")) End Sub
VB6 もメディアプレーヤーコントロールも知らないし、うまくいくかどうかも判らない… 案は、メディアプレーヤーコントロールからダブルクリックスタイルを取り除いてみたらどうか？　です。 方法は SetClassLong か SetClassLongPtr で GCL_STYLE 指定して CS_DBLCLKS を除去する、ですかね。予め GetClassXX が必要でしょうが。
しばらく調べてみました。私も同様の疑問でした。 >全く同じ挙動をしているように思えるのですが >どうやって使い分ければ良いのでしょうか？ Office Tanaka では、Value では、Null 値が現れるようなことが書かれていますが、TextBox において、両者は同じです。String型ですから、Null値が現れるはずがありません。 質問のリンク先の以下の内容は、あくまでも、Access の話です。 「テキストボックスへの入力内容を扱う場合には、「Value」プロパティと「Text」プロパティの違いに注意しなければなりません。前者は・・・フォーカスが離れたときなどに確定した値です。一方、後者は・・・現在編集中のデータ内容・・・現在画面に表示されているものではありません。 」 Excelでは、私には、その違いは見出されません。もしかしたら、PasswordChr に違いがあるかと思いましたが、それもありません。単に、VB6の名残りで使うつもりなら、.Textプロパティなんだろうか、というところだけです。同じだと解釈してよいのではないでしょうか。 あっ、それは別として、些細なことですが、その格納した変数のアドレスが違いますね。だから、何ということもありませんが。 Dim a, b 　a = VarPtr(TextBox1.Value) 　b = VarPtr(TextBox1.Text) 　　MsgBox "Value: " & a & vbCrLf & "Text: " & b 関数の説明 　https://support.microsoft.com/ja-jp/kb/199824 古い内容ですが、ここの質疑回答とほぼおなじです。 http://www.xtremevbtalk.com/excel/108079-textbox … なお、セルの場合は、Textプロパティは、値の取得のみですから、入力ができません。かなり明確に違いが出てきます。
No1です。補足します。 私のパソコンでは動作します。 ・エラーメッセージは何ですか？エラー行はどこですか？ ・コピー先、コピー元ブックは開いてますか？ ・シート名は正しく書いてますか？
> これをcsvに変換出力すると "." で区切られてしまいます。 この意味が何のことやらなのですが、もしかして、 "1.5SVI" というシートを保存すると、"1.5SVI" というファイル名になってしまう。本当は、"1.5SVI.csv" となって欲しいのだが。 ということでしょうか？ そうであれば、 ActiveWorkbook.SaveAs myPath & shName & ".csv", xlCSV と変更するだけです。
#2で回答したものです。 案1を採用したい旨の補足がありましたが、 これは、１sheetで100万行分を格納するので、 ２０sheet使用すると理解しました。 2千万行のデータを1sheetに１００万行ずつ格納していくと、 私の環境では、８シートぶんを作成したあたりで、メモリ不足となり、処理が続行できなくなりました。 私の環境は、windows7(64Bit) メモリ１２Gバイト excel2007です。 （＃２でメモリ４Gバイトと書きましたが、誤りでした。１２Gバイトが正しいです） 案１を採用される場合、メモリ不足が発生するかもしれませんので、 簡単なプロトタイプを作成し、2千万行が２０sheetに格納できることを まず確認することをお勧めいたします。
こんなかんじでしょうか。 A列にファイル名、B列にシート名が書き込まれます。 マクロを実行するExcelファイルは指定フォルダとは別の場所に置いて下さい。 Sub listAllSheetNames() Dim path As String Dim fileName As String Dim wb As Workbook Dim sht As Worksheet Dim row As Integer Dim col As String path = "C:\AAA\BBB\" '指定フォルダ fileName = Dir(path & "*.xls?") row = 1 col = "B" Do While fileName <> "" Cells(row, col).Offset(0, -1).Value = fileName Set wb = Workbooks.Open(fileName:=path & fileName) For Each sht In wb.Worksheets ThisWorkbook.ActiveSheet.Cells(row, col).Value = sht.Name row = row + 1 Next wb.Close savechanges:=False fileName = Dir() Loop End Sub
同じセルの使用頻度が多いですね。 Dim c1 As Range Dim c2 As Range Dim c3 As Range set c1=Range("D3") set c2=Range("D14") set c3=Range("A3") を先頭に追加しRangeを全部置き換えると、ちょっとスッキリします。Range("D15")はc2.Offset(1,0)です。 変更したい時もSub全体を見渡す必要がなく、先頭部分だけ見て修正出来ます。メンテナンス性の向上です。 もちろんRange("D3")はCells(3,"D")でもＯＫです。
＞Set MyTxt = Nothing ＞Set MyTxt = FSO.OpenTextFile(Strpath, 1) ＞とすれば実現できます。 ＞しかし、この方法は一般的でしょうか？ はい、通常、そのようにします。 但し、Set MyTxt = Nothingの前で MxTxt.Closeを実行したほうがよいでしょう。 ＞OpenTextFileをリセットするコマンドって用意されていませんか？ 残念ながら、ありません。 以下は、ファイルの全行を読み込み、内部に格納し、 先頭行と最終行の内容を画面に表示しています。（もちろん、他の行も可能） サイズが約２５Ｍバイトの１０万行のファイルを読み込んだ場合でも２～３秒で処理できました。（もちろんマシンによる個体差はありますが） -------------------------------------------------- Option Explicit Sub Sample() Dim FSO As Object Dim OTS As Object Dim filename As String Dim strText As String Dim inCount As Long Dim strFileName As String Dim strArray() As String Set FSO = CreateObject("Scripting.FileSystemObject") filename = "c:\goo\data.txt" Set OTS = FSO.OpenTextFile(filename, 1) inCount = 0 Do While OTS.AtEndOfStream = False strText = OTS.ReadLine ReDim Preserve strArray(inCount) strArray(inCount) = strText inCount = inCount + 1 Loop OTS.Close Set OTS = Nothing Set FSO = Nothing Debug.Print "inCount=" + CStr(inCount) Debug.Print strArray(0) Debug.Print strArray(inCount - 1) End Sub -------------------------------------------------- 今回のような場合は、全行読み込んでから、処理したほうが 簡単かと思うのですが、そのようにしたくない理由がなにかあるのでしょうか？ （例えば、ファイルサイズが非常に大きいとかです）
#６の内容で、コーディングしました。 以下のようにしてください --------------------------------------------------- Private Sub TextBox5_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger) Dim ret As Integer ret = check_data(TextBox5.text) If ret < 0 Then TextBox5.text = "0.999" KeyAscii = 0 Exit Sub End If If ret = 0 Then If KeyAscii <> Asc("0") Then KeyAscii = 0 End If End If If ret = 1 Then If TextBox5.SelStart = 0 Then KeyAscii = 0 End If If KeyAscii <> Asc(".") Then KeyAscii = 0 End If End If If ret > 1 Then If TextBox5.SelStart < 2 Then KeyAscii = 0 End If If KeyAscii < Asc("0") Or KeyAscii > Asc("9") Then KeyAscii = 0 End If End If End Sub Private Function check_data(ByVal text As String) As Integer check_data = Len(text) If Len(text) = 0 Then Exit Function End If If Len(text) = 1 Then If text <> "0" Then check_data = -1 End If Exit Function End If If Len(text) = 2 Then If text <> "0." Then check_data = -1 End If Exit Function End If If Len(text) >= 3 Then If Mid(text, 1, 2) <> "0." Then check_data = -1 End If If IsNumeric(Mid(text, 3)) = False Then check_data = -1 End If Exit Function End If End Function -------------------------------------------------------- 又、0.234のような状態で カーソルを０又は小数点の前に移動し、キーを押した場合は、無効となるように しました。
>エクスポートして　UserForm1.frmになったのをインポートすると、すでに名前が使用されているとかメッセージが出てインポートできません。なので　UserForm1.frm　を　UserForm２.frmに名前を変更してチャレンジしたのですが Userform1をエクスポート Userform1のオブジェクト名を　UserForm2に変更 Usefrom1..frmをインポートする この手順で如何でしょうか。
#3 です。 すみません、ちょっと訂正です。 ------------------------------------------- Ctrl + G　ジャンプ Alt + S　選択オプション A1 と入力　アクティブセルの配列 ------------------------------------------- このように書きましたが、Alt + S が、不要でした。 正しくは以下でお願いします。 ●列の非表示を復活したい場合（A列が隠れてるとき） ------------------------------------------- Ctrl + G　ジャンプ A1 と入力　　　（参照先にA1と入力） Ctrl + Shift + → Ctrl + Shift + 0　　列の表示 ------------------------------------------- ●行の非表示を復活したい場合（1行目が隠れてるとき） ------------------------------------------- Ctrl + G　ジャンプ A1 と入力　　　（参照先にA1と入力） Ctrl + Shift + ↓ Ctrl + Shift + 9　　行の表示 ------------------------------------------- ※参考 Ctrl + 9 ／Ctrl + 0 は、行・列の非表示です。 これを復活させるのが、 Ctrl + Shift + 9 ／Ctrl + Shift + 0 です。
私もデータベースに 1票。 Access で問題ないと思います。 (どのようにして Excel を 5分間隔で動作させていて、どのようにしてデータを読み込ませているのか、そこへんが不明ですが) データベースであれば生のデータを蓄積し続けることはたやすい。 現在の Excel で言うところの "転送されたシート" というシートで使用しているワークシート関数であれば、データベースのビューでどうにでもなるでしょう。 VLookup で行う部分なら参照するテーブル (または参照するビュー) があればいいわけですし。
一例です。 シート名のタブを右クリック、コードの表示クリック VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$B$2" Then Range("D2").Value = Now End If End Sub Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Target.Address = "$B$3" And Range("B2").Value = "" Then Range("C2").Value = Now Range("B2").Activate End If End Sub を張り付けて閉じる B2セルが、テキスト入力のセル B2セルを空白にして、Enterキーを押す（つまり、B3セルが選択されたら） C2に時刻を入れる B2セルにテクストを入力して、Enterキーを押す（つまりB2セルの値が変更されたら） D２セルに時刻を入れる D2-C2が所要時間 目的に合う様でしたら Callでストップウオッチを呼び出してみてください。
複数のブックに同じマクロを追加するには http://officetanaka.net/excel/vba/vbe/07.htm#sam … をご参照下さい。
Worksheets("sheet1").ScrollArea = Range(Cells(1, 1), Cells(3, 2)).Address
グラフの作成に関しては「VBA　グラフ作成」などをキーに検索すれば数多く出てきますので、それぞれがご質問の『どんなもの』に相当すると言えるでしょう。 例えば http://www.officepro.jp/excelvba/chart_edit/inde … http://www.moug.net/tech/exvba/0021.html http://www.happy2-island.com/excelsmile/smile03/ … マーカーを画像にするのは、手動操作では「データ系列の書式設定」→「マーカーのオプション」→「種類：組み込み」で画像データを指定すればよいみたいです。 そのまま、マクロの記録にしてみればこんな感じ？ set g = ActiveSheet.ChartObjects("fugafugaグラフ").SeriesCollection(1) g.MarkerStyle = -4147 With g.Format.Fill 　.Visible = msoTrue 　UserPicture "C:\hogehogeGazou.jpg" 　TextureTile = msoFalse End With
＞Excel・VBAのAPI VBAのAPIと言うくだりの意味が掴みにくいのですが、これはシステムフォルダにあるWin32API群でなくて、 VBA関数をエクスポートしてるVBE6.DLL/VBE7.DLLの事を仰有りたいのかなと。 Explorerを立ち上げて、Ctrl + F で右上の検索ボックスで先のDLL名を検索すれば出てくるのではと。 ＞MsgBoxのプログラム DLLはVBAの様なインタプリタ形式で作られていなくて、コンパイラ形式なので エディタで中を開いて確認する事は出来ません。 ＞MsgBox を引き合いに出してるのは、Unicodeに未対応とか不便を感じてるから、それを改善したいみたいな事なのでしょうか。 それなら、MsgBox関数はDLL関数なので呼び出しをトラップ(Hook)して、別のプロシージャが呼び出される様に挙動を変更する事が出来ます。
何らかのシートを削除する処理が書かれているのだと思いますが、削除処理の書き方に問題があるのではないでしょうか。 Worksheets(i).Delete とか
こんなかんじです。 Sub foo() Const MAXLINE As Integer = 100 Dim i As Integer For i = 1 To MAXLINE Cells(i, 3).Value = Cells(i, 1).Value & Cells(i, 2).Value Next i End Sub
｢画像貼り付けマクロについて｣の｢前の質問｣がなにかわかるように、例えば、質問履歴がわかるようにするか、あるいは、前の質問のURLを貼っておくのかしないと、どんなことをやろうとしているのかもわかりません。 ｢サブディレクトリから画像を選択し貼り付けしている｣という状況もイメージがわきません。　メインディレクトリとサブディレクトリの言葉から、いくつか下層のディレクトリ（フォルダ）の中のファイルを対象にしているらしいことは想像出来ますが、その先も、最終的にどうしようとしているのかもわかりません。 参照設定　Microsoft Scripting Runtime　をしておくことが出来るのでしたら、 下記のマクロでも、("D:\testFolder\testImageF")の中の複数のフォルダやさらに再下層のフォルダの中の添え字が("jpg")あるいは("JPG")のファイルを、エクセルの現在表示してるシートに小さなサイズで並べることは出来ます。 Sub macro2() Dim objFSO As FileSystemObject, Retu As Long, Syu As String Set objFSO = New FileSystemObject ' FSO Retu = 4: Syu = LCase("jpg") Tg_Path = LCase("D:\testFolder\testImageF") Call File_HARI(objFSO, objFSO.GetFolder(Tg_Path), Retu, Syu) Set objFSO = Nothing End Sub Private Sub File_HARI(objFSO As FileSystemObject, _ ByVal objFolder As Folder, _ Retu As Long, Syu As String) Dim objFolder2 As Folder, objFile As File For Each objFolder2 In objFolder.SubFolders Call File_HARI(objFSO, objFolder2, Retu, Syu) Next objFolder2 GYO = 5 Retu = Retu + 1 Cells(GYO, Retu) = objFolder.Path For Each objFile In objFolder.Files With objFile ' 拡張子を確認し、該当ならシートに貼り付け If LCase(objFSO.GetExtensionName(.Path)) = Syu Then GYO = GYO + 1 Cells(GYO, Retu) = .Name GYO = GYO + 1 ActiveSheet.Pictures.Insert(.Path).Select With Selection .Top = Cells(GYO, Retu).Top .Left = Cells(GYO, Retu).Left .ShapeRange.Height = 35.5 .ShapeRange.Width = 61# End With GYO = GYO + 3 End If End With Next objFile End Sub
#1です。 #1のF.ReadBytesでは、 F.ReadBytes内でByte型をVariant型に変換し、F.ReadBytesの戻り値をVariant型からByte型 に変換しています。 上記のデータの転送は、ファイルのサイズが大きくない場合は、それほど問題になりませんが、 ファイルサイズが今回のように大きい場合は、それなりの遅延原因になります。 その為、以下のReadBytes2を作成してみました。 以下のコードをRandomクラス内に追加してください ---------------------------------------------- Public Function ReadBytes2(ByVal ByteCount As Long, ByRef ReadBuff() As Byte) As Long Dim BytesRead As Long If hFile = INVALID_HANDLE_VALUE Then RaiseError W32F_FILE_ALREADY_CLOSED End If ReadFile hFile, ReadBuff(LBound(ReadBuff)), ByteCount, BytesRead, 0 ReadBytes2 = BytesRead End Function ---------------------------------------------- ReadBytes2の第1引数が読み込みサイズ、第2引数が、読込バッファ 戻り値が実際に読み込んだデータのサイズ（バイト）になります。 戻り値が０の場合は、ファイル終端を意味します。 第２引数の読込バッファは、必ず第1引数の値以上のサイズを確保してください。 以下、実際の呼び出しプログラム側です。 ---------------------------------------- Sub Macro2() Dim buff(1023) As Byte Dim endFlag As Boolean Dim datalen As Long Dim amari As Long Dim readCount As Long Dim i As Long Dim st As Single Dim et As Single Dim F As Random Set F = New Random F.OpenFile "c:\\goo\\File10GB" endFlag = False amari = 0 st = Timer Do While endFlag = False datalen = F.ReadBytes2(1024, buff()) If datalen < 1 Then endFlag = True End If If endFlag = False Then readCount = readCount + 1 For i = 0 To datalen - 1 amari = (amari + buff(i)) Mod 256 Next i End If Loop F.CloseFile Set F = Nothing et = Timer Debug.Print "時間2（秒）=" + CStr(et - st) Debug.Print "読込件数=" + CStr(readCount) Debug.Print "余り=" + CStr(amari) End Sub ------------------------------------------------- 1024バイト単位で読み込むため、 Dim buff(1023) As Byte　を宣言しています。 以下実行結果です。 時間2（秒）=332.0859 読込件数=10485760 余り=236 #1の実行時間は約530秒でしたので、6割程度に時間が短縮されたことがわかります。 ReadBytes2を使用することを推奨します。
＃３です せっかくなので > もし、切った行を次の塊としてコピーするのなら、 > 後半の方を優先するのなら、 > また、AA 以降をクリアしてから･･･とかなら これ、変更量も多くないので盛り込んでみました Public Sub Samp3()    Dim dic As Object    Dim ws As Worksheet    Dim vA As Variant, v As Variant    Dim sS As String    Dim i As Long, j As Long    Const CROWMAX As Long = 10    Set dic = CreateObject("Scripting.Dictionary")    Application.ScreenUpdating = False    Set ws = Worksheets("Sheet2") ' ☆～ AA 以降クリアしないのなら以下をコメントに    With ws       .Cells(1, "AA").Value = 1       .Range("AA1", .Cells.SpecialCells(xlCellTypeLastCell)).Clear    End With ' ～☆    With Worksheets("Sheet1")       vA = .Range("A1", .Cells(Rows.Count, "A").End(xlUp)).Value       For i = 2 To UBound(vA) ' 前優先 '      For i = UBound(vA) To 2 Step -1 ' 後優先          If (vA(i, 1) <> "") Then             If (Not dic.Exists(vA(i, 1))) Then                dic(vA(i, 1)) = "A1"             End If             dic(vA(i, 1)) = dic(vA(i, 1)) & "," & "A" & i          End If       Next       j = 1       For Each v In dic.Keys ' 前優先用 '      For Each v In mySort(dic.Keys) ' 後優先にしたらこっちを有効に          sS = dic(v)          While (Len(sS) > 0)             vA = Split(sS, ",", CROWMAX + 2)             sS = ""             If (UBound(vA) > CROWMAX) Then '' ★～ １０行で切って余ったものを次に・・・なら以下1行有効に '               sS = vA(0) & "," & vA(CROWMAX + 1) '' ～★                ReDim Preserve vA(CROWMAX)             End If             Intersect(.Range(Join(vA, ",")).EntireRow _                , .Range("A:CP")).Copy ws.Cells(j, "AA")             j = j + 52          Wend       Next    End With    Application.ScreenUpdating = True    Set dic = Nothing End Sub Private Function mySort(ByVal vA As Variant) As Variant    Dim v As Variant    Dim i As Long, j As Long    For i = LBound(vA) To UBound(vA) - 1       For j = i + 1 To UBound(vA)          If (vA(i) > vA(j)) Then             v = vA(i)             vA(i) = vA(j)             vA(j) = v          End If       Next    Next    mySort = vA End Function
こんにちは。 ラベルコントロールというのは、ActiveX コントロールか、フォームコントロールかどちらかだと思います 以下は、() 内は、インデックスにしていますが、名前も入れられます。 フォームコントロール Expression.Labels(1).Text = "ABC" ActiveX コントロール Expression.OLEObjects(1).Object.Caption = "DEF"
解決されてましたらスルーしてください 素直にコード記述してみました Sheet2 の A1 ～ A 列最後までの2列分(A、B列)を変数 vA に読み込んで Sheet1 全部を対象に vA(i,1) ･･･ 氏名と一致するものがあるかを1つずつ確認していきます Set r = .Cells.Find(vA(i, 1), LookAt:=xlWhole) で、同じものが見つかったら、 そのセル番地を覚えておいて vA(i, 2) の読みを ふりがな に設定して 同じ氏名がまだあるか　Set r = .Cells.FindNext(r) 最後まで探してなかったら、最初に戻って探す動きをするので 初めに覚えていたセル番地になったら同じ氏名はもう無いということで Do ～ Loop を抜けます この Do ～ Loop の間、氏名を削除しているわけではないので、 見つからない状態にはなりませんね vA 行数分処理したら終わりです Public Sub Samp1() 　　Dim r As Range 　　Dim vA As Variant 　　Dim sAdr As String 　　Dim i As Long 　　With Worksheets("Sheet2") 　　　　vA = .Range("A1", .Cells(Rows.Count, "A").End(xlUp)).Resize(, 2) 　　End With 　　Application.ScreenUpdating = False 　　With Worksheets("Sheet1") 　　　　For i = 1 To UBound(vA) ' 1行目から 　　　　　　If (vA(i, 1) <> "") Then 　　　　　　　　Set r = .Cells.Find(vA(i, 1), LookAt:=xlWhole) 　　　　　　　　If (Not r Is Nothing) Then 　　　　　　　　　　sAdr = r.Address 　　　　　　　　　　Do 　　　　　　　　　　　　r.Phonetic.Text = vA(i, 2) 　　　　　　　　　　　　Set r = .Cells.FindNext(r) 　　　　　　　　　　Loop While (r.Address <> sAdr) 　　　　　　　　End If 　　　　　　End If 　　　　Next 　　End With 　　Application.ScreenUpdating = True End Sub
こんばんは。 答えは、#1さんの回答自体は、完璧だと思います。 しかし、 >「実行時エラー424、オブジェクトが必要です」 ということで、ミスタイプ自体は直したとします。 (添付画像　参照) 私も、VBAは、10年以上やっていて、それ相応に分かっているつもりでしたが、ご質問内容では、同じく分かりません。親オブジェクトから書く方法を、コンテナ型といいますが、その時に、実行時エラー '424'として発生するのは、親オブジェクトが見つからない場合だけです。 しかし、Excelでそのような現象になるとのは、今のところ思いつかないのです。 http://officetanaka.net/Excel/vba/error/executio … このリンク先とは違うように思います。 原因のひとつとして考えられるのは、まず、アプリケーションそのものが違っているというとこです。ThisWorkbook　が違っている場合です。つまり、Wordなどの別のVBAで実行しようとしていると考えられます。Excelだとすると、今は、原因を思いつきません。今までも、初心者の方のご質問は、非常に難問なものが多いような気がします。 以下はWordの標準モジュールで実行した場合です。なお、Cells(1.1) は、小数点以下が丸められますので、Cells(1)の意味ですが、Cells(1.5)は、2になって、B1を意味します。もしA1,A2 と書くのなら、カンマを入れて、Cells(1,1) Cells(2,1) と書くようにします。
Sub Macro1() Dim rng1 As Range Dim rng2 As Range Dim cData As Range Dim c As Range Dim num As Variant 'シート1の検索範囲設定 Set rng1 = Worksheets("Sheet1").Cells(2, "B") Set c = rng1.Offset(1, 0) Do While c.Offset(0, -1).Value = c.Offset(-1, -1).Value + 1 Set rng1 = Union(rng1, c) Set c = c.Offset(1, 0) Loop 'シート２の検索範囲設定 Set cData = Worksheets("Sheet2").Cells(5, "B") Set rng2 = Range(cData, cData.End(xlDown)) 'シート２古いデータをクリア Range(cData.Offset(0, 1), cData.Offset(0, 1).End(xlDown)).ClearContents '検索 For Each c In rng2 num = Application.Match(c.Value & "*", rng1, 0) If IsNumeric(num) Then c.Offset(0, 1).Value = rng1(num).Offset(0, 2).Value End If Next End Sub 教示とは名ばかりの依頼だけですね。あなたは初心者ですらない。
1. とあるマクロ付きブック (仮に macro.xlsm) がある。 こいつは CSV を何らか処理するためのブックである。 2. とある csv ファイル (仮に 20150101.csv) がある。 3. macro.xlsm から 20150101.csv を開き、CSV に書かれているデータを読み取って macro.xlsm 自体のシート上に何らかの転記処理をする。 4. 処理が終わったら macro.xlsm 自身を別名保存する。 ファイル名は読み込み元の CSV ファイルにならって 20150101.xlsm にしたい。 5. 以後、次の CSV を処理する際も macro.xlsm を使って処理を行っていく。 という感じでしょうか。 CSV ファイルを開く際、CSV ファイルの名前を変数にとっておく。 → 標準モジュールの public 変数にでも入れておく。 → "名前を付けて保存" の処理と同じ標準モジュールにあるのなら public じゃなくて private な変数でも良い。 または CSV ファイルを開く際に CSV ファイルを Workbook オブジェクトとして参照しているのなら、その変数の Name プロパティに格納されている。 以下のような変数に CSV ファイルのファイル名 (パスでも可能) を突っ込むと拡張子なしのファイル名を取得できます。 ex.) hoge.csv やら d:\test\hoge.csv やら \\server\aaa\hoge.csv → "hoge" Function GetCsvBasename(aCsvFileName As String) As String 　　Dim fso As Object 　　Set fso = CreateObject("Scripting.FileSystemObject") 　　 　　Dim baseName As String 　　baseName = fso.GetBaseName(aCsvFileName) 　　 　　GetCsvBasename = baseName End Function ただし xlsm ファイルを SaveAs で保存する際は FileFormat 引数に "xlOpenXMLWorkbookMacroEnabled" を指定しなくてはなりません。。 ThisWorkbook.SaveAs "csv ファイル名", xlOpenXMLWorkbookMacroEnabled
こんにちは。 しばらく、内容的には違うけれども、私も同じようなことをしています。私の場合は、元のひな形のシートをコピーして使うものです。 >マクロ３を実行すると、シート１・３のマクロ１やマクロ３のボタン名が『ボタン１３』などと >初期値に戻り、ボタンも押せなくなります。 これを試してみましたが、フォームコントロールのボタンで、そういう現象が起きませんでした。再現性がないということは、こちらが思っているのとは、内容的に違うということです。複製が出来て、マクロが起動しないのは、Active Xコントロールのボタンだということぐらいでしょうか。フォームのコントロールには、そういう問題がないと思います。 ただし、初歩的なことですが、フォームのコントロールボタン用のVBAコードは、標準モジュールに書くことはお分かりになっているとは思います。 後は、もう少し、細かい部分を調べていかないと、回答は難しいと思います。
具体的な回答は出来ませんが 張り付けるではなく、別シートの最終行の下方向に、特定のセルの値を入れる と云うイメージで説明します。 これで書式はコピーされません。 仮にコピー元が　A1~J10までの10行　 別シートのA～J列に値を入れる として GYOU=Sheets("別シート").Range("A" & Rows.Count).End(Xlup).Row+1 Sheets("別シート").Range("A" & GYOU & ":J" & GYOU+10).Value=Range("A1:J10).Value 別シートのデータが入っている最終行番号に　+１　して 別シートの最終行＋１から１０行に元データの値を入れる こんな感じです。
……ふむ、"perl dbi access accdb" でぐぐったらすぐにそれっぽいのが出てきましたよ。 http://d.hatena.ne.jp/perlcodesample/20110513/13 …
>IOライブラリはGPIB-USBをインストールしたときに入れてあります。 ということですと、VBEditor の「参照設定」の中で、該当するライブラリ(VISA COM 3.0 Type Library)などが見えていますか？そこに、チェックは入っていますか？チェックした後「×」が入っていたり、そもそも見えていない場合は、自分で設定し直すか、再インストールしないといけないはずです。 私は、マニュアルだけみているので、はっきりしているのではないのですが。
こんにちは。 お一人さまで、成り立っていますが、やっぱり返事はいるのかしら（^^; >先ほどのコードはA列を基準として最終セルを求めるってことなのかもと思いました。多分、正解のような気がする。 最終セルを求める方法というのは、いくつかあります。最終行が、各列バラバラなこともありますね。そういう時はどうするとか、今回のJ列同じようなものですが、最終行をどこでとるのが良いのかは、こちらでは、正解は、今の状態だけでは分かりません。 以前、VBAの質問者をし続けている人の中に、回答者泣かせのものもあります。それは、データが、散在している場合だ、と後出しされたことです。結局、こちらは、続ける気にならなくなってしまいました。 質問のコードは間違ってはいないとは思いますが、 もし、うまく行っていないのなら、以下も同じです。 何がうまく行っていないのか、こちらではわかりかねますが、データの置き方に特徴があるとかになると、なかなかうまく行かないこともあります。その場合は、詳しく教えていただかないと解決しません。 LastRow = .Cells(.Rows.Count, 1).End(xlUp).Row + 1 .Cells(.Rows.Count, 1).End(xlUp).Offset(1,9).Value　=　 Me.ListBox1.Text これ自体、セルを示しているので、そのまま利用してもいいでしょうね。一行では済みますが、ご質問者さんが書いた前者の方が、可読性は上がります。 まあ、ご参考までにというだけです。
こんにちは。 最初に、答えは分かりません。 ただ、オートメーションエラーなら、オートメーションを使っていることになるはずですが、コードには出てきていませんから、分からないということです。まあ、全体的には、コードは間違いないだろうということだけです。 >起動されたオブジェクトはクライアントから切断されました。』 ということは、オブジェクト(ブックやシート)に命令を与えたら、途中で切れてしまいました、という意味だと思います。命令を与える相手を、コンテナ型(親オブジェクトから書くこと)をしなかったとかで、暗黙的に指していたはずなのに、途中で移動してしまったとか。 Workbooks("Abc.xlsx").Sheets(Trim(DataS(a)).Copy これは、括弧がひとつ抜けていますね。書き損じただけだと思います。 Trim(DataS(a)) この中身はいいとしても、添字は、1からだと思います。 その程度は、お約束だから、大した話でもありません。 >このマクロだけで、このエラーが起こる、ということは　あるのでしょうか？ 私は、それはないと思いますが、私は、そのような方法は取りません。理由は、コードがややこしいからです。 受け側の　Workbooks("Temp.xlsx"). Sheets(a)　 で、添字で場所を換えていますが、先頭から、シートの順逆に入れても同じだからです。 For a = UBound(DataS) To 1 Step -1 　 Workbooks("Abc.xlsx").Sheets(Trim(DataS(a))).Copy _ 　 Before:=Workbooks("Temp.xlsx"). Sheets(1) Next a しかし、これを書いたところで、他人の物笑いの種になる程度でしかありません。それより、OS側の問題で修復を掛けられるなら、試してみる価値はあるとは思います。
こんにちは。 別に、VBAを選択というよりも、使用環境が限定されているから、VBAを使っているという人がほとんどではありませんか？ >みなさんだったら、どうします？乗り換えますか？VBAだけで解けそうですか？ VBA使用者というのは、ド素人集団だから、仮に言語を換えても、やっぱりその換えた時点ではド素人そのものなんだと思います。もしVBAで、うまくないから、言語を換えて解決という話にはならないことだと思います。 >要するにVBAの数値範囲が狭い、あるいは遅いがために工夫して解く部分が多過ぎるのです VBAというよりも、限定的ではあるけれども、VB6なのですよね。だから、VB6のいろんな諸問題をどう解決してきたかという記録からみて取れるのは、その言語に対する期待感からの構築された技術だと思うのです。つまり、大勢の人の努力による積重ねの無形の財産をだったわけです。 それで、逆に、言語換えて、解決していくかというと、まったく目処が立たないのではないかと思うのです。ただ、そもそも、VBAは、アプリの中で操作するものですから、臨時に、言語として単独で利用しているだけにすぎません。 >他言語ではこんなに簡単に解いてる、モチベーションが一気に下がりました。 これは、私自身の感覚的なこともしれませんが、たぶん分かる人は分かってくれると思います。 ひとつは、問題は情報量なのだと思います。 あえて、能力的な話はしませんが、様々な問題に対して、VBAまでサイズダウンしてまで、解法が降りてこないのです。昨今、VB6での解決方法というのは、一切情報として上がってこないので、私などは「VBレスキューの花ちゃん」ぐらいです。 もうひとつは、やはりアルゴリズムなどを利用した解法は、VBAユーザーには不慣れだということです。 もし、プログラミング言語をやりたいのでしたら、今すぐでも、中途半端なVBAなどやめて、本格的なプログラミング言語に挑戦すべきだと思います。 むろん、VBAには、VBAでしか解決しない問題はあるのは承知の上での見切りです。数学的な問題解決に、VBAが、使えれば使えばよいということにすぎないと思います。
私もあまり詳しくないし、数年前に使わなくなって遠ざかっていたので、スマートなやり方は出来ません。 試しに思い出しながら試行錯誤したら、動くモノが出来たので、参考になればと書きます。 ～～～～ 条件　win7、excel2007、 メモリ　実験したらexcelで400MBを越えると、不安定になりました。 次の実験は安定的に動きました。結果的にexcelの使用メモリは140MBくらいです。これを保存するファイルサイズは3.3MBくらいです。 ～～～～ 仮定条件　 １）あらかじめ｢Sheet1｣シートが出来ていて、データが入っている ２）あらかじめ｢除外指定｣シートに除外するべき指定文字列が入っている ３）他にシートは存在しない（社名シートはコードで新造する） ４）データの条件 4-1)　｢Sheet1｣シートのデータ行数は3万行程度 4-2）社名は数十社程度　（400社、500社でも動くことは動く） 4-3) ｢Sheet1｣シートのG列には、空白行、文字行など数値以外の行もある 4-4) ｢Sheet1｣シートのＨ列で、《指定文字列以外》となるモノは多数あるし、《指定文字列》は10種類くらいある ～～～～ 実験では次のコードで、Sheet1に仮データ29999行と、｢除外指定｣シートに13種の文字列を作りました。 Sub 実験データを作る() Randomize With Sheets("Sheet1") For i = 1 To 8 .Cells(1, i) = Chr(64 + i) Next i tb = .Range("A1:H30000") For i = 2 To 30000 tb(i, 2) = Int(Rnd() * 10000 + 38) tb(i, 3) = Int(Rnd() * 100) * 1000 kari = "ID_" & Right("000000" & Int(1000000 * Rnd()), 6) kari = Left(kari, 4) & Chr(64 + Mid(kari, 5, 1)) & _ Mid(kari, 6, 6) tb(i, 4) = kari tb(i, 5) = "ほみにか" & i - 1 & "名前" tb(i, 6) = Rnd() If tb(i, 6) < 0.54 Then tb(i, 6) = Int(Rnd() * 1000) * 100 ElseIf tb(i, 6) < 0.77 Then tb(i, 6) = "○" ElseIf tb(i, 6) < 0.92 Then tb(i, 6) = "×" Else tb(i, 6) = "" End If tb(i, 7) = Chr(64 + Int(Rnd() * 16)) _ & Mid(Rnd(), 3, 1) & "社" tb(i, 8) = "文字列" & Int(Rnd() * 54 + 1) Next i .Range("A1:H30000") = tb Worksheets.Add(after:=Worksheets("Sheet1")).Name = "除外指定" Sheets("除外指定").Cells(1, 1) = "除外するべき指定文字列" For i = 2 To 14 Cells(i, 1) = Sheets("Sheet1").Cells(5 + i, 8) Next i End With End Sub 　～～～～ 上のコードで作ったデータを対象にして、下のコードで、『Sheet1の行で（G列に値が入っている、且つ、H列に指定文字以外の値が入っている）行を、 社名毎の新規シートに、それぞれの社名に合わせて』転写出来ました。 Sub 対象をシートにコピーする() ' F列(A列から6フィールド目)が数値である行だけを表示させる(AutoFilter) Sheets("Sheet1").AutoFilterMode = False Set myrange = Sheets("Sheet1").Range("F:F") myAns = ">=" & Application.WorksheetFunction.Min(myrange) Sheets("Sheet1").Range("A:H").AutoFilter _ field:=6, Criteria1:=myAns ' H列の文字列が、 '　　(｢除外指定｣シートのA列2行目から下にある文字列には該当しない)行だけを '　表示させて、その結果を仮設作業シートにコピーし、G列の社名の辞書を作り '　（社名毎のシートを新造追加し、仮設作業シートを社名でAutoFilterした結果を ' 　社名シートにコピーし、AutoFilterを解除する）のを繰り返す With Sheets("除外指定") gte = .UsedRange.Rows.Count gt = .Range("A2:A" & gte) End With Randomize ksh = "仮設作業シート" & Right(Rnd(), 3) Worksheets.Add(after:=Worksheets(Worksheets.Count)).Name = ksh With Sheets("Sheet1") Dim a a = Application.Transpose(.Range("H2:H" & _ .Range("H60000").End(xlUp).Row).Value) For i = 1 To gte - 1 a = Filter(a, gt(i, 1), False) Next i .Range("A:H").AutoFilter field:=8, Criteria1:=a, Operator:=xlFilterValues End With Sheets("Sheet1").Range("A1").CurrentRegion.Copy Sheets(ksh).Range("A1") Sheets("Sheet1").AutoFilterMode = False DoEvents With Sheets(ksh) Dim Dic Set Dic = CreateObject("Scripting.Dictionary") On Error Resume Next rr = Sheets(ksh).UsedRange.Rows.Count For i = 2 To rr sya = .Cells(i, 7).Value Dic.Add sya, sya Next i mSyasuu = Dic.Count mSyamei = Dic.keys For i = 0 To mSyasuu Worksheets.Add(after:=Worksheets(Worksheets.Count)).Name = mSyamei(i) Sheets(ksh).AutoFilterMode = False Sheets(ksh).Range("A:H").AutoFilter field:=7, Criteria1:=mSyamei(i) Sheets(ksh).Range("A1").CurrentRegion.Copy Sheets(mSyamei(i)).Range("A1") Next i Sheets(ksh).AutoFilterMode = False End With End Sub 条件設定が違うと手直しが必要になりますが、似たような処理で出来ると想像します。
こんばんは！ 一案です。 Z1セルを作業用のセルとして使用していますので、Z1セルは使っていない状態にするか、Z列を表示にしてみてください。 H2～H100セルにリスト設定がしてあるという前提です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて） H列のリスト候補を色々選択してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) 'この行から// Dim str As String If Intersect(Target, Range("H2:H100")) Is Nothing Or Target.Count > 1 Then Exit Sub With Target If .Value <> "" Then str = Range("Z1") & .Value & "," Application.EnableEvents = False .Value = Left(str, Len(str) - 1) Application.EnableEvents = True Range("Z1") = .Value & "," End If End With End Sub Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Intersect(Target, Range("H2:H100")) Is Nothing Or Target.Count > 1 Then Exit Sub Range("Z1").ClearContents If Target <> "" Then Range("Z1") = Target & "," End If End Sub 'この行まで// ※　実際の範囲は ＞Range("H2:H100") の部分で調整してみてください。 ※　作業用セルはZ1セルでなくてもどこか遠くのセルでも構いません。 （Z1セルを変更する場合、コード内の「Z1」部分を変更してください） とりあえずはこの程度で・・・m(_ _)m
間違っています。 ftype zipfile="C:\Program Files----\aaaa.exe" -引数 %1 ですね。 ftype | more で他の定義が見られますので、参考にしてください。
こんにちは。 >Err.Raise 513なんて初めて見ました。意図してないものがあった場合、エラーを発生させる？？ってことなんでしょうか。 Err.Raise で、わざと、ユーザー定義エラーを発生させています。奇をてらったわけではなかったのですが、Goto を使わずに、　Resume Nextを活かす方法として、使ったものです。全シートを当たる方法として、別に他の方法でも良かったのですが、フィルターあるなしに関わらず、総当りしなくても済む方法として、この方法を使いました。 なお、FilterMode(見えない行がある状態) は、オートフィルタだけではありませんが、その点は、未だ不具合が存在しているかもしれません。
方法1 相手に、古い形式のExcelファイル(拡張子XLS)で保存し直して送り直してもらう。 方法２ Excel2000で、拡張子XLSXのファイルを開く。 ここに手順が書いてあります。互換パックをインストールしてください。 https://support.microsoft.com/ja-jp/kb/924074
こんにちは。 返事つけてくださりありがとうございます。 今回は、簡単そうでいて、慣れた人でも、失敗しそうな部分がありますが、理由は、Excel 2007以降になってから、若干、保存の仕様が変わったからのようですね。 >ファイル名はシート名を取得したものとします。 こういう内容がありましたので、 >shName =(ActiveSheet ) .Name　自体がシート名を取得してファイル名にすると言う事でしょうか？ 特に、それ自体をファイル名に変わるわけではありませんが、 ActiveWorkbook.SaveAs myPath & shName, xlCSV　　'* 保存の際に、shName をベース(ファイル)名に使うということです。それを代用するということにしました。 [ベース(ファイル)名というのは、拡張子がないファイル名のことを意味しています。] 読みにくいと思われたのは、 　With ActiveSheet 　　　－記述－ 　End With と、With ステートメントで、省略されているからでしょう。 .オブジェクト名　と　先頭に「．(点)」が、ついていれば、上の行にあるWith の所の'ActiveSheet' を省略していると読んでください。
基数B=642... とします。 例えば、このB進法で 1/8 を小数表記することを考えてください。 1/8 = 1/(2^3) = (3〜251の素数を掛けた合成数 ^3)/ ((2^3)*(3〜251の素数を掛けた合成数 ^3)) = (3〜251の素数を掛けた合成数 ^3) * (B^-3 ) です。つまり、1/8みたいな簡単なものでも、このB進数では小数3桁必要です。 1/8程度の有理数が小数1桁では表現できません。 小数1桁(0.1≦x<1)になる可能性のある 既約分数 m/n (1≦m≦n≦B) で、 ・ n が 2〜251のいずれかの素数の2乗を約数に持つ→ 誤差なく表現するには小数2桁以上必要 ・ n が 251を越える素因数を持つ→ 有限の桁では表現できない です。 基数に10進101桁も使っているのに、誤差無く小数1桁にできる nはたった2^53=9007199254740992 (9.0*10^15)通りしかありません。 「(十分な精度の整数を使った)有理数型」なら、この範囲の全てで誤差はありません。 　ほとんどの場合、nに100桁も使う必要も無いでしょう。 また、(3〜251の素数を掛けた合成数 ^3) * (B^-3 ) を小数表記するには 小数第1位: (3〜251の素数を掛けた合成数 ^3) / B^2 の商 小数第2位: (↑の余り) / B の商 小数第3位: ↑の余り となり、計算量が増えます。 無理数で誤差が出るのは、どんな基数を使っても避けられません。 これを、例えば π ≒ P/B とでも近似しようということなのかもしれませんが、 そんな複雑な基数を使わなくても Pd/10^102 や Pb/2^335 の方が誤差が少なくなります。 多くの種類の素数の合成数なので、約分できる可能性が大きい→効率がよくなる、という効果を狙っているかもしれませんが、上で述べたような事情から、そうなる可能性は極めて低いと言えるでしょう。 以上のようなことから、 B進小数にこだわらない方が、精度も速度もメモリも効率がよくなります。 やり方を考えなおした方がよいでしょう。
アルゴリズムでいえば以下のようになります。 配列数＝５でA,B,C,D,Eの文字で行なう場合 １．配列数の数だけ以下を繰り返す（５回繰り返し） 　　配列から繰り返し番目に該当する１文字を取得する。（文字１とする）（１回目はA、２回目はB・・・となる） 　　その文字を除いたもので、新しい配列を作る。1回目は(B,C,D,E)、２回目は(A,C,D,E)・・・となる。 　　２．新しい配列の配列の数だけ以下を繰り返す（４回繰り返し） 　　　　繰り返し番目に該当する１文字を取得する。（文字２とする） 　　　　その文字を除いたもので、新しい配列を作る。１回目は（C,D,E）・・・となる。 　　　　３．新しい配列の配列の数だけ以下を繰り返す（３回繰り返し） 　　　　　　以下同様（文字３） 　　　　　　４．新しい配列の配列の数だけ以下を繰り返す（２回繰り返し） 　　　　　　　　以下同様（文字４） 　　　　　　　　５．新しい配列の配列の数だけ以下を繰り返す（１回繰り返し） 　　　　　　　　　　以下同様（文字５） 　　　　　　　　　　６．配列の数が０個なので以下の処理を行う 　　　　　　　　　　　　組合せの文字列＝文字１＋文字２＋文字３＋文字４＋文字５ 　　　　　　　　　　　　組合せの文字列をファイルへ出力する 　　　　　　　　５．繰り返し終了 　　　　　　４．繰り返し終了 　　　　３．繰り返し終了 　　２．繰り返し終了 １．繰り返し終了 実装例は以下の通り（但し、配列数は１０個で行っています）（sub1は再帰呼び出しを行っています） --------------------------------------------- Option Explicit Sub test() Dim i As Integer Dim arr As New Collection Const cnsFILENAME = "\SAMPLE.txt" Open ThisWorkbook.Path & cnsFILENAME For Output As #100 For i = 0 To 9 arr.Add (Chr(Asc("A") + i)) Next MsgBox ("start") Call sub1(arr, "") Close #100 MsgBox ("end") End Sub Sub sub1(ByRef arr As Collection, ByVal out As String) Dim str As Variant Dim s As Variant If arr.Count < 1 Then Print #100, out Exit Sub End If Dim i As Integer For Each str In arr Dim ar As Collection Set ar = New Collection For Each s In arr If s <> str Then ar.Add (s) End If Next Call sub1(ar, out + str) Next End Sub ---------------------------------------------------------------------------- excelのbookが存在するディレクトリと同じディレクトリ下にSAMPLE.txtが作成されます。 先頭行：ABCDEFGHIJ（1行目） 最終行：JIHGFEDCBA（3628800行目） になります。 excelのシートへ出力すると行数が多いため、出力できませんのでファイルへ出力しています。
こんにちは。 本当は、shell でしたほうがよいとは思ったものの、VBScript という括りの中なら、このようにすればよいかと思いました。 Dim myFolder Dim objFS Dim objFolder Dim objfile Dim i , j Dim fn Set objWshShell = CreateObject("WScript.Shell") myFolder = objWshShell.CurrentDirectory Set objFS = CreateObject("Scripting.FilesystemObject") Set objFolder = objFS.GetFolder(myFolder) On Error Resume Next For Each objfile In objFolder.Files fn =objfile.Name i = InStr(1, fn, "ScreenShot_", 1) ' j = InStr(1, right(fn,3), "jpg", 1) 'jpgの場合 If i > 0 Then 'If i > 0 And j>0 Then ''拡張子をみる場合。 objfile.Name = Replace(fn, "ScreenShot_","") End If Next
こんばんは。 Chr$(22) はもChr$(&H22) か、10進なら、34 ですね。　Chr(34) 今どき、型宣言文字を使う人はいないと思いますが、 n%=j% これは、n%側は、n でいいですね。 それに、ループしなくても、Instr() 関数で十分だと思います。 n = InStr(1, dat, """")
Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Target.Column = 1 Then 'もし、ダブルクリックしたセルがA列だったら Sheets("Sheet1").Range("I3").Value= Target.Value End If If Target.Column = 5 Then 'もし、ダブルクリックしたセルがE列だったら Sheets("Sheet1").Range("A2").End(xlDown).Value = Target.Value 'Sheet1のA列の最終行のセルに入れる。？ End Sub かな？
基本、話がおかしくない？ mdb　開く部分はアクセスの権利にかかわる分だからして、ランタイムだけ移動しようっても・・・ VBで入力画面作って、ADOで　MDBファイルに読み込み、書き込み処理するのが普通。但し、使う時は、そのマシンごとにインストールする必要があり、 インストールプログラム作るとき、MDBにコンタクトできるADOに配布する権利があるかって聞かれて、すっぴんのアクセスなら、配布権利が無いとなって、インストールブログラムが作れない。 こんな感じのハズですが
こちらでコピペした場合には 余計な行間と行頭の全角スペースが邪魔していますね。 メモ帳を閉じる場合はこんな風です。 但し、Terminateは有無を言わせぬ強制終了なので メモ帳で編集中で未保存の場合でも何も確認メッセージは出してくれませんよ。 for each Process in _ GetObject("winmgmts:{impersonationLevel=impersonate}").ExecQuery _ ("select * from Win32_Process where Name='notepad.exe'") Process.terminate Next
今使っているWindowsであればVista以降でしょうから、choiceコマンドが使えます。 詳しくは、choice /? で表示される説明をよんでください。 サンプル choice set YN=%ERRORLEVEL% if %YN%==1 ( 　Yを押したときの処理 ) if %YN%==2 ( 　Nを押したときの処理 )
こんにちは。 初心者？　これを書いた人は、相当に頭の良い方だろうけれども、私のような、何年も同じようなレールに則った書き方しか出来ない人間（その上、劣化していっています)には、そのちょっとの所が、VBAの標準の軌道から外れているように思います。 むろん、試してみましたが、特にエラーは発生しませんでした。 私が気になる部分： Set Dst = Workbooks.Add.Worksheets(1).Range("A1") こういう書き方はあるものの、新規作成の場合は、ブック・シート・セルのオブジェクトは、分けたほうがよいし、そもそもRange型で保有する必要はないように思います。 Set RR = Book.Worksheets(1).UsedRange Set RR = Intersect(RR, RR.Offset(2)) ここは、確実かどうかです。データの取得に、UsedRangeというのは、かなり無茶です。 それに、そこから、Intersect で、二行下からのデータを取得というところにも、多少の不安を感じます。 Set Dst = Dst.Offset(RR.Rows.Count) そして、上記のRRの生成と連動してくると思います。
こんにちは。 #2では、ダメ出ししていましたが、私がイメージしたものをサンプルで作ってみました。 手順： ------ 名前の登録 Criteria 　=Sheet!$K$1:$K$2　　（クライテリア) Database 　=Sheet!$A$5:$I$35　（データベース) ---- コントロールの書式設定 入力範囲　$M$1:$M$8 リンクするセル　$H$1 ドロップダウンリストの行数　8 ----- 　M列　　　　　　　　　　　　　 N列 　　（空白) 1　性別：男　　　　=F6="男"　 2　性別：女　　　　　　=F6="女" 3　1972年生まれ　　 =AND(G6>="1972/1/1",G6<"1973/1/1") 4　8月生まれ　　　　　 =MONTH(G6)=9 5　東京都在住　　　　 =COUNTIF(D6,"*東京*")>0 --- このN列にある数式が、クライテリア部分のK2 に貼り付けられます。 ---- 'シートモジュール '// Sub DropButton_Change() i = Range("H1").Value If i > 0 Then 　 Range("Criteria").Cells(2, 1).Formula = Range("N1").Cells(i, 1).Formula 　 Range("Database").AdvancedFilter Action:=xlFilterInPlace, _ 　 CriteriaRange:=Range("Criteria") End If End Sub '///
こんばんは！ Sub Sample1() MsgBox Cells(Rows.Count, "B").End(xlUp).Offset(1, -1) & "です。" End Sub くらいで大丈夫だと思います。m(_ _)m
>二つのテキストボックスを用意し 私のいつもの手は ComboboxとLabelにします。 A列に　Noと名前を定義 ComboboxのRowSourceに　Noとして、A列しか選択できない様にします。 E3セルに　はVlookup関数を入れておきます。 Private Sub ComboBox1_Change() Range("E2").Value = ComboBox１.Value Label1.Caption = Range("E3").Value End Sub とわずか2行で済みます。 VBAと関数の関係ですが Range("E2").Value = ComboBox１.Value でE2セルに値を入れると、関数が優先的に実行されます。 結果 Label1.Caption = Range("E3").Value には、Vlookup関数の結果が表示されます。 なぜ　Labelを使うかと云うと、TexｔBoxの様に勝手な編集が出来なくするためです。 VBAとエクセルの機能、関数を組み合わせて賢く使う方法を考えます。
>通常　フルアドレスが必要で、それが、マシン環境で変わる それは、めったにないことでしょうね。その種類にもよりますが。 >DLLネームならばフルアドレスは必要ないわけで それは、一つは、dll を呼び出せるようにレジストリに登録しているということ。 もう一つは、ほとんどは、Windows\System32\ と決まっていますから、フォルダーをあちこち探すことはありません。 >DLLネームまで変わるって事は？？ こちらの話は、たぶん、私では手に追える話ではないのですが、同じような事象があって、私も考えてみたいとは思っています。（と言いつつ、すでに調べていますが、ここの回答のためではありません。自分なりに決着を付けたいと思うだけです。) ただ、少なくとも、単独で、同名のdll をダウンロードサイトからダウンロードしてインストールを入れるのは、リスクが大きすぎますので、辞めたほうがよいようです。 なお、特に、別にこれに返事を付けなくても構いません。
ここを読んでみればよいのですが、だらだらと文章が長いですね。^^; http://www.ken3.org/vba/backno/vba170.html この内容のまとめは、この後でします。もし、ダメだったら、こちらも読んでください。 >onclick="~~" の記述がないケースがあり困っております。 最初に、ストレートな回答ではありませんが、私の場合、いくつかの方法を試しています。 >a href="javascript:;" pnb="~~" scdaction="~~" bulkaction="~~" id="~~">~~</a> この場合は、id がありますから、確実のオブジェクトとして取得できますから、まず最初に、ダメ元で、 id名.Click を一度試してみます。もしくは、この行の上部のコードのオブジェクトのClass名のオブジェクトのひとつから、ヒットさせようとします。 そこでダメなら、ということで、ken3の内容に入るのですが、この著者の結論（正解)は、 ご質問に沿って書くと For i =0 To objIE.Document.links.Length -1 If objIE.Document.links(i).href ="javascript:;" Then　'文字の比較は、大文字・小文字がある 　　 objIE.Document.Links(i).Click End if Next i ということになっています。私は、このコードは少し古臭く感じます。 ここで、ken3 の所では、Testサイトを用意してくれているので、試してみましたが、ダイレクトでサイトがとれている限りは、やはり、 Testサイト：http://www.ken3.org/vba/test170f.html 　objIE.Navigate "javascript:xxxxx;" が利くことが分かりました。ただし、実際は、ここで時間待ちをしなくてはならないでしょう。 解説は、フレームからですので、うまく行かなかったようです。
申し訳ないのですが、私の話は、ほとんど伝わっていないようです。 こちらが一つ書けば否定されて、再度、こちらが詳しく説明するという繰り返しでは、先に進めません。 一つのポイントをクリアして、次に進むのであっても、未だ、最初の段階さえクリアしていないのでは、次には進みません。 >Excelで保存してるという状態で正確にはDLとは違う気がします。 このような表現をされたら、どうしてよいのか分かりません。 >＞IE オブジェクトからの操作をするか この意味も理解していないようですね。ダウンロードのダイアログは、概ねJavaScript なのですが、それをIEオブジェクトから操作するという意味です。そのためには、Web解析をしなくてはならない、と書いても分からないかもしれませんね。 以上ですが、私から、お教えできることは、これ以上ないのです。 もう一度、話をまとめて、質問を仕切り直ししたほうが良いかもしれません。無駄に、お時間を取らせてすみせんでした。
(右)シングルクオートと全角のアポストロフィーは同じものです。 その文字コードはUnicodeで8217(十進)、Shift_JISで8166(16進)です。 フォントを変えるか、ASCII領域にある左右の区別のないシングルクオート「'」を使ってはいかがでしょう。
こんにちは。 With FS 　 .NewSearch 　　.LookIn = strPATHNAME 　　.Filename = "*_障害処理票.xls" 　　.SearchSubFolders = False　　'←サブフォルダーを探さない 　　.Execute 　　 というとこですから、Dir 関数だけでも済むはずです。もし、サブフォルダーも探すとなれば話は変わります。 Private Sub GetFiles_Click() ・ ・ ・ 　' 指定フォルダ内のExcelワークブックのファイル名を参照する(1件目) 　strFILENAME = Dir(strPATHNAME, vbNormal)　 　'-------------'これから下 　Dim myArray() As Variant 　Dim j As Long, i As Long 　ReDim myArray(200) '限界値を200とする 　strFILENAME = Dir(strPATHNAME & "*_障害処理票.xls?", vbNormal) 　Do While strFILENAME <> "" 　　　If strFILENAME <> "." And strFILENAME <> ".." Then 　　　　　If (GetAttr(strPATHNAME & strFILENAME) And vbNormal) = vbNormal Then 　　　　　　　myArray(j) = strPATHNAME & strFILENAME 　　　　　　　j = j + 1 　　　　　　　'配列変数保護のために置いています。 　　　　　　　If j > 200 Then MsgBox "ファィル数が200個を越えました!": Exit Do 　　　　　End If 　　　End If 　　　strFILENAME = Dir 　Loop 　ReDim Preserve myArray(j - 1) 　For i = LBound(myArray) To UBound(myArray) 　 　　' ワークブックを読み取り専用で開く 　　 Set objWBK = Workbooks.Open(Filename:=myArray(i), UpdateLinks:=False, ReadOnly:=True) '-------------変更はここまで 　　 'Set motoSH = objWBK.Sheets("障害処理票") 'シート名指定 　　 '後は同じはずです。
こちらからの確認の問いかけにまともに応える気がなさそうなので これっきりにします。 SELECT * ,0 AS p FROM TableA WHERE F1=3 UNION ALL SELECT * ,1 as p FROM TableA WHERE F1<>3 ORDER BY p, F1; とすれば、 F1｜F2｜p ３｜う｜0 １｜あ｜1 ２｜い｜1 ４｜え｜1 ５｜お｜1 となります。 あとはパラメータクエリにするなどして頑張ってください。私からは以上です。
うーんんｎ 当方の環境（Office2010 Pro）では C:\Program Files (x86)\Common Files\System\ado\msjro.dll にファイルが有り（これがJro.JetEngineの実体です） 参照設定のリストでも Microsoft Jet and Replication Objects 2.6Library として選択できるのですが なぜ、そちらでオブジェクト作成失敗のエラーになるのか・・・ 力不足ですみません。 もっとも、作成に成功していたとしても当初の問題が解決できる保証もなく・・・。 この辺が私の限界です。
>>思うような動作にならず・・・ >というのは、マクロを実行しても複数のパスワード付ブックのうち、なぜか1つしか開かないためです。 それは、マクロの問題ではないと思いますね。 試しに、開く所で、Debug.Print を取ってみればどうでしょうか。これで情報が得られるはずです。なお、Left(Err.Description,15)は、エラーメッセージが長いおそれがあるので、割愛するためです。 　If IsBookOpen = False Then 　　　　　 On Error Resume Next 　　　　　 Workbooks.Open myPath & FileName, ReadOnly:=True, Password:="1111" 　　　　　 If Err() <> 0 Then Debug.Print Left(Err.Description, 15); FileName; Tab(1) 　　　　　 On Error GoTo 0 　　　End If
他人に聞く前に、デバッグのコツを身につけてください。 ブレイクポイントとローカルウィンドウの2つを使って、正しく値が返っているか調べます。マクロ開発をしていく上で、必至のことになります。 ●　file = Dir("フォルダパス\*.xlsx")　'←ここで、ブレイクポイントを設けてみたらいかがですか？ fileという所に何が返って来るでしょうか。 Dir 関数のマクロで基本的な書き方は、 myPath ="フォルダパス\" file = Dir(myPath & "*.xlsx") というようにパスを取り出して書きます。 だから、ファイルを開く時に Workbooks.Open myPath & 　file　 というように書きます。（裏ワザとしては、Chdirで カレント・フォルダーをその場に置いてしまうという手がありますが、返って面倒になることもあります。) >ActiveWorkbook.Save >ActiveWorkbook.Close それから、厳密には、ActiveWorkbook では意味が違いますが、凝った内容でなければ、たぶんマクロは通るはずです。
どうやら、私の#1の回答は、間違いでした。 両方共終わらせられる方法はあるものの、マクロはややこしい気がします（一応、やってみました) >2013を　複数BOOK起こす時　それまでと、変更になった（基本、複数は無理やり・・・）これが　そもの問題と思うのですが たぶん、そうなんでしょうね。 今のところ、私は、2013 をインストールしていないので、はっきりとした現象をつかめていないのですが、今まで、仕様が変わった部分がそのような現象を起こすらしいことはわかりました。 修復に逃げるというのは、私としては、何か不甲斐ないけれども、今のところのアドバイスとしては、このぐらいしか思いつかないです。 http://121ware.com/qasearch/1007/app/servlet/rel … 以下は今回の場合とは違いますし、私なら、レジストリの設定を考えますね。 http://hayakute.kantan-sakusaku.com/excel/2015/0 …
既に適切な回答も出ているとおり、VBAでもCountIfを使ってやればいいでしょう。 もっと複雑な条件分岐が絡むのであればFor Nextで回してカウンタで数えていくべき ですが、今回はシンプルなので前者で。 3～10行目の●の数を数えて11行目に表示。それをA~C列でループ。 ------------------------------------------------------------------------- Private Sub Worksheet_Change(ByVal Target As Range) Dim c As Integer, str As Variant str = "●" Application.EnableEvents = False For c = 1 To 3 Cells(11, c).Value = Application.WorksheetFunction.CountIf( _ Range(Cells(3, c), Cells(10, c)), str) Next c Application.EnableEvents = True End Sub -------------------------------------------------------------------------
こんにちは。 私のミスで、話を長引かせてしまい、すみませんでした。 >2度目のプログラム実行時、uname.length = 0 いくつかは想像できます。 すでに、ログインしているということ。 また、ログインあるとすれば、ログアウトがどこかにあって、それを実行しなければならないとか。 もしくは、サイト側で拒否しているとしか。1回ログインすると、再ログインをしばらく待たされるところもあります。手動でメッセージなどをみて、その戻るメッセージをInstrで取得して、MsgBox に出すというようなことをすることもあります。 時間が経てば復帰するにしても、どこかで、IPアドレスをチェックされているかもしれません。
こんにちは。 エラー自体は、単純なミスだと思うのですが、私は、ご質問のマクロを読みきれていません。 ひとつは、 '指定範囲を取得する >st_row = cht.Range("B" & end_row).End(xlDown).Row >end_row = cht.Range("H" & st_row).End(xlDown).Row st_row の初期値を決めて置かなければ、無理だと思います。 だから、たぶん、想像の範囲ですが、 st_row =5 If st_row >5 then st_row = cht.Range("B" & end_row).End(xlDown).Row End If >cht.Range("B" & st_row - 1 & ":H" & end_row).Select ここで、st_row -1 だから、st_row =0 なら、[B-1 ]でエラーになります。 次に、サブルーチンになっていても、 Sub set_chart(setpage As Integer, chkp As String) その下の ppPst　のオブジェクトは、どこにもありませんから、サブルーチンから持ってくるか、モジュール・スコープ変数にして、共有させなければ、エラーが発生します。 でも、後は、30枚をどうやってやるのかとか、今のマクロの範囲からは、ちょっと想像がつきません。Slide を加えていくのではないのか、と思うのですが……。
総当たりで For Each x In objIE.document.Forms(0).All If x.Title = "CSV出力" Then x.Click End If Next とかは If x.Title = "CSV出力" Then は If x.Value = "CSV出力" Then かも・・・
こんにちは。 Column というのは、Range オブジェクトのプロパティですね。 データ型は、Long型です。 一応、コードのミスを訂正しておきます。 '// 　Call CleanUp(colmns("A")) 　　　↓ 　Call ColumnTreat(Columns("A")) 　　'質問内容から、変更します。ただし、ここは、もうひとつ工夫が必要かもしれません。 　 ''Range型で渡そうが、数値型で渡そうが、文字型で渡そうが、間違いがなければ、結果オーライだと思います。 ''しかし、状況にも依存しますが、Rangeの変数(例：Rng) で渡すのが、ベターだと思います。Columns("A")のような、リテラルな方法ではなく、初心者の人がなにげに無茶する方法で、Sheet を含めたRange型変数が、実は、そこには結構テクニックがあって、何かと簡単にさせてくれます。悪い方法は、文字型のアドレスです。再度、Rangeを指定しなければならないから二度手間です。 '// Sub ColumnTreat(ByRef Tcol As Column)　　　　　’★ 　　　　↓ Sub ColumnTreat(ByRef Tcol As Range) '// 　　For Each c In Range(.Cells(1), .Cells(Rows.Count).End(xlUp)) 　　　c.Value = 1 'セルごとの処理 　　Loop 　　　　　　↓ 　For Each c In Range(.Cells(1), .Cells(Rows.Count).End(xlUp)) 　　　c.Value = 1 'セルごとの処理 　Next c　　　'Loop ではなく、Next '//
こんにちは。 VBのプログラミングのカテゴリにお聞きになっているようですが、関数のサポートは、ちょっと自信はありません。 実際、全ての要件を盛り入れるとすれば、関数ではかなり、かなり面倒な数式になるように思います。 その前に、添付画像の表を御覧ください。この質問で土木部門で使う横に長いカレンダーの方式を思い出しました。実務では、こういうものを付けて行ったらどうかということです。計算式では、見込みだけで、正確には出てこないと思います。直接の回答とは違うとは思いますが、念の為にご紹介しておきます。 画像の日計累計の部分は、このようになっています。 B17: =SUMIFS($C$7:$GR$7,$C$1:$GR$1,">="&$A$1,$C$1:$GR$1,"<"&DATE(YEAR($A$1),MONTH($A$1)+1,1)-1) AP7: =AP5-AP4 AQ3は、フルタイムの意味です。=IF(AQ5-AQ4=9,"○","") ----- 次に、VBA側からです。今回は、いろいろなことを考えて、ユーザー定義関数にはしませんでした。 ・たとえば、2015/8/10 10:00 、2015/8/12 9:00 の経過日時になります。 ・ また、18:00から9:00の間はカウントしない ・ 土日祝日も除外する。 '// 'Option Explicit '祭日データ 2015/7/20 ～2016/12/23"(このデータはフォームが崩れやすいので注意) Public Const HOLIDAYS = "2015/7/20,2015/9/21,2015/9/22,2015/9/23," _ & "2015/10/12,2015/11/3,2015/11/23,2015/12/23,2016/1/1," _ & "2016/1/11,2016/2/11,2016/3/21,2016/4/29,2016/5/3," _ & "2016/5/4,2016/5/5,2016/7/18,2016/8/11,2016/9/19," _ & "2016/9/22,2016/10/10,2016/11/3,2016/12/23" Sub TimeCalculate() Const S As Integer = 9 '開始時間 Const E As Integer = 18 '終了時間 Const FT As Integer = 9 'フルタイム9時間' '--------------------- Dim Rng1 As Range Dim Rng2 As Range Dim d As Long Dim t1 As Date, t1s, t1e, t1o As Date Dim t2 As Date, t2s, t2e, t2o As Date Dim timeflg As Integer Dim DifDate As Integer Dim DifTime1 As Double Dim DifTime2 As Double Dim D2h As Integer Dim mH As Integer Dim mM As Integer Dim ret As Variant Dim d_cnt As Long 'weekday カウント Dim h_cnt As Long '休日・祭日カウント Dim DateArray As Variant DateArray = Split(HOLIDAYS, ",") Set Rng1 = Range("A1") Set Rng2 = Range("B1") If IsDate(Rng1.Text) And IsDate(Rng2.Text) Then 　 t1 = Rng1.Value: t2 = Rng2.Value 　If t2 < t1 Then 　　'数値が大きい方が't2' という決まり 　　t2 = Rng1.Value: t1 = Rng2.Value 　 End If 　 t1o = t1: t2o = t2　'オリジナル変数確保 　 ret = Application.Match(Format(t1, "yyyy/m/d"), DateArray, 0) 　 If IsNumeric(ret) Or Weekday(Int(t1), vbMonday) > 5 Then 　　　MsgBox Int(t1) & "の開始日が、休日・祭日の場合は、この計算できません。", vbExclamation 　　　Exit Sub 　 End If 　 ret = Application.Match(Format(t1, "yyyy/m/d"), DateArray, 0) 　 If IsNumeric(ret) Or Weekday(Int(t2), vbMonday) > 5 Then 　　　MsgBox Int(t2) & "の終了日が、休日・祭日の場合は、この計算できません。", vbExclamation 　　　Exit Sub 　 End If 　　 　 '端の個別の計算(最初の日付) 　 t1 = t1 - Int(t1) 　 If TimeSerial(S, 0, 0) > t1 Then 　　 t1s = TimeSerial(S, 0, 0) 　　 t1e = TimeSerial(E, 0, 0) 　 ElseIf TimeSerial(E, 0, 0) > t1 Then 　　 t1e = TimeSerial(E, 0, 0) 　　 t1s = t1 　　Else 　　 t1e = TimeSerial(E, 0, 0) 　　 t1s = TimeSerial(E, 0, 0) 　　End If 　 　 DifTime1 = CDate(Format(t1e - t1s, "HH:MM")) 　 　 t1o = Int(t1o) + 1 '最初の日付は、端数計算後－日付繰り上がり 　　　 　 '端の個別の計算 (最後の日付) 　 　 t2 = t2 - Int(t2) 　 If TimeSerial(S, 0, 0) > t2 Then 　　　t2s = TimeSerial(S, 0, 0) 　　　t2e = TimeSerial(S, 0, 0) 　 ElseIf t2 > TimeSerial(E, 0, 0) Then 　　　t2s = TimeSerial(S, 0, 0) 　　　t2e = TimeSerial(E, 0, 0) 　 Else 　　　t2s = TimeSerial(S, 0, 0) 　　　t2e = t2 　 End If 　 　 DifTime2 = CDate(Format(t2e - t2s, "HH:MM")) 　 　 '日付と曜日 　 For d = Int(t1o + 1) To Int(t2o)　'端の部分を除いた日付 　　　ret = Application.Match(Format(d, "yyyy/m/d"), DateArray, 0) 　　　If Weekday(d, vbMonday) < 6 Or IsNumeric(ret) Then 　　　　d_cnt = d_cnt + 1 　　　 Else 　　　　h_cnt = h_cnt + 1 　　　 End If 　 Next d 　 DifDate = d_cnt 　 D2h = DifDate * FT 'フルタイムで9時間" 　 mH = Hour(DifTime1 + DifTime2) 　 mM = Minute(DifTime1 + DifTime2) 　 Cells(1, 3).Value = "'" & D2h + mH & ":" & Format$(mM, "00") 　 Cells(1, 4).Value = "祭日休日数: " & h_cnt & "日( -" & h_cnt * 10 & "h)" End If End Sub '/// 数式で、上記のマクロに近づけてみましたが、日曜・祭日を抜く計算などは、ここに入っていません。たぶん、組み込めるはずですが、負担が大きすぎるかもしれません。また、エラー処理もなされていません。 エラー対処としては、数値が大きい方が'B1' という決まりを守ってください。マクロにはエラー処理はしています。 考え方は、図で分かるかもしれませんが、計算の開始の日と最後の日は、特別枠の計算をし、他は、フルタイムという前提で計算されています。フルタイムは「9時間」ということにしています。 C3：に入っている数式です。 =MAX(MIN(MOD(A1,1),"18:00"),"18:00")-MIN(MAX(MOD(A1,1),"9:00"),"18:00")+MIN(MIN(MOD(B1,1),"18:00"),"18:00")-MIN(MAX(MOD(B1,1),"9:00"),"9:00")+(INT(B1)-(INT(A1)+1))*9*(1/24) 土日を検出するのは、 2015/8/10 10:00～2015/8/21 15:00 開始の日を抜いて（片入れ計算)、期間は10日ですから、OFFSET 関数の中に10を入れれば、2日が検出されます。 =SUMPRODUCT((WEEKDAY(A7+COLUMN(OFFSET(A1,,,,10)),2)>5)*1)
この質問は、記録だけのものになってしまうかもしれませんが、ちょっと書かせてもらいます。 オートメーションは、ある意味良く知られた方法ではあるけれども、happy2-islandの方法では、あえてオートメーションする必要があるのかなって思いました。以下は、Excel 本体を立ち上げていますし、もしすでに立ち上がっていれば、横取りします。なお、余計ついでですが、「タブ」は、教室などでExcelを教える際には、画面の下の「シートタブ」のことを指しますが、掲示板などでは、あまり使わない言葉のようです。 '// 　Dim xlApp As Object 　Dim wb As Object 　Dim ret As Long 　Do 　　On Error Resume Next 　　Set xlApp = GetObject(, "Excel.Application") 　　On Error GoTo 0 　　If xlApp Is Nothing Then 　　 ret = Shell("C:\Program Files\Microsoft Office\Office15\Excel.Exe")　'Excel 2013 　　 If ret = 0 Then Exit Sub 　　End If 　Loop Until Not xlApp Is Nothing 　Set wb = xlApp.WorkBooks.Open("C:\Users\[TestID]\My Documents\Test.xls") 　wb.Worksheets("Sheet1").Select 　Set xlApp = Nothing '///
2つのBookを並べて表示させ、参照したい側のセルに「=」を入力して、参照される側のセルにマウスカーソルを合わせてクリックするとよい。 ただし参照される側のBookは保存してファイル名が付いている必要がある。 これでどのようにして他のBookを参照すればよいか分かると思うので、あとは自身で工夫してみてください。
質問内容の理解に苦しみます。 >①Form1で宣言し、かつ読み込んだXMLファイルのデータが書き込まれているDataSetを、Form2で呼び出す方法を教えてください。 この内容のとおりなら、模範解答のままだと思うのですが。 模範解答、Form2_Load()で、親のFrom1クラスのDataSet型のメンバ変数を自身のForm2クラスのメンバ変数に代入していますよね？ > dgrMain = frmMain.dgrPerson Form2クラス内ならForm2_Loadイベントが終わった時点で自由にアクセスできるはずです。btnOK_Click()で書き込みしてますし、質問の意図が読み取れません >②Datasetで指定したセルのみをXMLファイルに書き込む方法を教えてください。 既にあるXMLファイルの指定した特定の要素だけを更新するという意味なら難易度は格段に上がります。このレベルのVB学習中なら非常に難しいと感じるかもしれません。詳しくはDocument Object Modelや、SAXなどを検索してください sample.xml内にある、特定の要素だけをファイルに書き出す場合 例：<name>大島 美加</name> この場合は、DataSetのスキーマを分析してファイルに書き出すかDataGridにバインドしたものを利用すれば比較的簡単です。（スキーマについては割愛） dim strElement as string = dsPerson.Tables(0).Columns.Item(dgrPerson.CurrentCell.ColumnNumber).ColumnName DataSetから、現在選択中の列の名前を以上のように取得できるので StreamWriterなり好きな方法でファイルに書けば良いかと。
#1の回答者です。 成功してよかったです。 もう一つ、最近、こちらの掲示板でも同様の質問がちらほらでますが、 Pictures.Insert を使うと、 「画像のリンク情報が挿入され、肝心の画像が挿入されていない」 という問題が発生します。 つまり、Excelの画像を埋め込んだファイル自体を、他のPCで使う場合に起こる現象です。 その場合は、代わりに、 Shapes.AddPicture　メソッドを使うようにします。 こちらを参考にしてください。 [AddPictureメソッドで画像を貼りつける] http://www.moug.net/tech/exvba/0120020.html
今、どのようにやっているのでしょうか? とりあずは、Microsoftが公開しているサンプル 「別のフォームにデータを設定または取得する方法について」 https://msdn.microsoft.com/ja-jp/library/cc44086 … .NET Tips 「別のフォームのデータを取得、設定する」 http://dobon.net/vb/dotnet/form/accessanotherfor …
ブックやシートの構成がわからないので勘違いがあるかもしれません。 やろうとしていることは、、、 Book1.xlsm の中に "List", "AAA", "BBB", "CCC", "DDD", "EEE", "FFF" というシートがある。 List シートの B3 から下に向かってファイル名書いてあり、E列には ReportType の値が書いてある。 そのレコード行数分だけ処理を行う。 B列の値に合致するファイルを開き、そのファイルの "集計" シート 7行目の 1 ～ 2000列の値を Book1.xlsm のシート "AAA" ～ "FFF" のいずれかのシートの、とある行の 2 ～ 2001列に転記する。 「とある行」 とは、現在 List シートで処理している行と同じ行番号である。 "AAA" ～ "FFF" のどのシートに転記するかは、List シートで処理している行の E列に書いてある文字列の右から 3文字分で決定する。 といった感じでしょうか？ 違っていたらごめんなさい。 で、面倒なので細かいところまで検証していませんが、質問文にあるコードでは 同時に 2つのブックを開き、複数のシートにまたがって行ったり来たりしています。 こういう場合、Cells や Rows などの要素は単独で書かず、必ず親要素から指定してあげてください。 じゃないと質問者が意図しているブック & シートのセルではないブック & シートのセルを VBA が見に行っちゃう事があります。 具体的に挙げると temp = AWB.Worksheets("集計").Range(Cells(7, 1), Cells(7, 2000)).Value これの Range 以降に出てくる Cells はどのブックのどのシートのセルなのか不明です。 もし集計シートのセルを意図しているのであれば temp = AWB.Worksheets("集計").Range(AWB.Worksheets("集計").Cells(7, 1), AWB.Worksheets("集計").Cells(7, 2000)).Value と書かなければなりません。 これはコードが長くなってしまってかなり面倒なので、シートも Worksheet 変数で参照してしまったほうがよいでしょう。 Dim AWB As Workbook Dim awbSummary As Worksheet Set AWB = ・・・ Set awbSummary = AWB.Worksheets("集計") としておけば temp = awbSummary.Range(awbSummary.Cells(7, 1), awbSummary.Cells(7, 2000)).Value と書くことができます。 そこら辺を諸々書き直したコードです。 字下げしているところは全角スペースで埋めているので、コピペする場合は半角スペースに置換してください。 上記で述べた部分以外、Select - Case で出力先シートを決めている部分も書き直しています。 ReportType に格納されている文字列の右端から 3文字分の値が対象シートの名前と一致する仕様であればこのような書き方でも問題ないと思います。 Sub hoge() 　　Dim MWB As Workbook 　　Dim mwbList As Worksheet ' MWB ブックの "List" シート 　　Dim mwbOutput As Worksheet 　　Dim AWB As Workbook 　　Dim awbSummary As Worksheet ' AWB ブックの "集計" シート 　　Dim AnsFolder As String 　　Dim AnsFile As String 　　Dim ReportType As String 　　Dim nRow As Long 　　Dim i As Long 　　Dim temp As Variant 　　Set MWB = Workbooks("Book1.xlsm") 　　Set mwbList = MWB.Worksheets("List") 　　AnsFolder = "C:\test\" 　　nRow = mwbList.Cells(mwbList.Rows.Count, 2).End(xlUp).Row 　　For i = 3 To nRow 　　　　AnsFile = mwbList.Cells(i, 2).Value 　　　　Set AWB = Workbooks.Open(AnsFolder & AnsFile) 　　　　Set awbSummary = AWB.Worksheets("集計") 　　　　ReportType = mwbList.Cells(i, 5).Value 　　　　temp = awbSummary.Range(awbSummary.Cells(7, 1), awbSummary.Cells(7, 2000)).Value 　　　　Set mwbOutput = MWB.Worksheets(Right(ReportType, 3)) 　　　　mwbOutput.Range(mwbOutput.Cells(i, 2), mwbOutput.Cells(i, 2001)) = temp 　　　　AWB.Close (False) 　　　　Set AWB = Nothing 　　　　Set mwbOutput = Nothing 　　Next End Sub
記録マクロですね。記録マクロは、VBAのコーディングとはかなり違ったものです。これは、プログラミングの範疇には入らないのです。ですから、少し説明を加えてくださったほうがよいかもしれません。 わかりにくい部分があります。 一般的には、このようにして変数で受ければよいです。 >「新規シート作成」sheetのB2セルに入力されている文字列と同一のシート名を検索し、そのシートにおいてSelection.Copy以下の作業をしたいのです。 　 myDate2 =（シート) .Range("B2").Value 　Worksheets(myDate2) のようにします。 例： '// Sub MakingNewSheet() Dim myDate As Date Dim myDate2 As Variant Worksheets("新規シート作成").Copy After:=Sheets(2) myDate = Date - 1 With ActiveSheet 　　 .Range("B1").Value = Format$(myDate, "yyyy mm dd") 　　 .Name = Format$(myDate, "yyyy mm dd") 　　　If .Range("B2").Value Like "#### ## ##" Then 　　　　myDate2 = .Range("B2").Value　'変数に取る 　　　Else 　　　　'本来は、エラー発生として、マクロ離脱 　　　　'Exit Sub　 　　　End If End With With Worksheets(myDate2) 　.Select　'←本来は要らない 　'.Columns("E:AR").Copy '"どこかへコピー" End With End Sub '/// P.S. 前回の　No. 9016586のご質問は、非常に難しい内容でしたが、 私が、 >現行のままの質問と解答なら、要求通りにはプログラムで出せます と書いていたのに、理由もわからないままに、私の回答を没にしてしまったのは、ここ最近の私の回答の中では、とても残念で悔いの残るものでした。
それで見当つきました。 FileSystem.FileOpenが失敗した場合の処理を追加してください。 (Try〜Catchで例外を捕まえる) おそらく、失敗しています。 ○ファイル操作関連の処理は、他の処理に比べると「失敗」しやすいです。 ですから、失敗したときの対策を入れておくようにしましょう。 最低限、ファイルオープン時くらいは、正常にオープンできているかを調べましょう。 ○ 詳しくは知らないのですが Visual Studioでデバッグ実行中に、 Form.Loadイベントハンドラ で例外が発生しても、例外のメッセージが出ないで、そのままForm.Loadイベントハンドラが終了し、次の処理へと移行するようです。 実稼動環境で例外になったり、Loadで設定したはずの項目が初期値のままだったり、というのを何度か経験しています。 ○最近のWindowsでは、Cドライブ直下にファイルを置けないようにしています。
http://dobon.net/vb/dotnet/control/buttonarray.h … これですか?だとすると、下に > 'Buttonのクリックイベントハンドラ > Private Sub testButtons_Click(ByVal sender As Object, _ > ByVal e As EventArgs) とイベントハンドラが定義されていて、これをButtonコントロールを関連付けるために > 'イベントハンドラに関連付け > AddHandler Me.testButtons(i).Click, _ > AddressOf Me.testButtons_Click が使われています。この Me.testButtons_Click は、 上の Private Sub testButtons_Click〜 のことです。 対して、あなたのプログラムでは > AddHandler MyLabel(i).Click, AddressOf MyLabel_Click とLabelコントロールとイベントハンドラ MyLabel_Click を関連付けようとしていますが、肝心の MyLabel_Click がありません。 無いものを関連付けることはできません。 ですか、MyLabel_Click を定義してください。 あるいは。 イベントハンドラは、イベントが発生したときに実行するプロシージャです。 イベントが発生したときに特にやることが無いのなら、イベントハンドラを設定する必要はありません。 今回はClickイベントなので、ラベルをクリックしたときにやることが無いなら、関連付けは不要ですし、イベントハンドラを定義する必要もありません。 > Private MyLabel As Label()←Private MyLabel As System.Windows.Forms.Label() > Me.MyLabel = New Label(1) {}←Me.MyLabel = New System.Windows.Forms.Label(1) {} > Me.MyLabel(i) = New Label()←Me.MyLabel(i) = New System.Windows.Forms.Label > System.Windows.Formsを付けたり外したりしても結果は同じです。 今回のエラーとは、まったく無関係です。 > やはりVB2005とVB2010の仕様の違いはないのでしょうか？ 仕様に違いはありますが、今回の範囲では違いはありません。
EventLogReader.ReadEventメソッドのマニュアル https://msdn.microsoft.com/ja-jp/library/bb36089 … には特に明記されていませんが > このクラスを使用するコード例については、「How To: Query for Events」を参照してください。 の「How To: Query for Events」にあるサンプルコードを読むと 「ReadEventがnullを返すまでループを繰り返す」 というアルゴリズムになっています。 そこから予想するに > このオブジェクト内のイベント クエリから返される次のイベントを読み取ります。 > 戻り値 > 型: System.Diagnostics.Eventing.Reader.EventRecord > EventRecord オブジェクトを返します。 に 「次のイベントが読み取れない場合は、nullを返します」 が抜けていると考えてよいでしょう。 > EventRecord er = eReader.ReadEvent(); で代入していますが「 eReader.ReadEvent()」がnullを返すケースもある、ということです。 queryStringが期待したものになっていない、とかがあるのではないでしょうか
元のプログラムでは「コントロール配列」が使われていたのでは? http://homepage1.nifty.com/rucio/main/shokyu/jug … 8個のラベルを1セットとして、それが8セットあるのではないか、と思われます。 VB.NETになって、コントロール配列(Indexプロパティでまとめる)という機能は無くなりました。 対応策はいくつかあるのですが、結局は「変換したプログラムは参考に留めておいて、VB.NET用に新たに作り直す」のが一番よさそうです。 例えば、表状に並んだコントロールはSystem.Windows.Forms.DataGridに置き換える、とか。 Me は 自分自信のインスタンスを表すフィールドです。 他言語での this や self に相当します。
こんばんは！ 色々やり方はあると思いますが、一例です。 シートモジュールにしてください。 Private Sub Worksheet_Calculate() Dim c As Range On Error Resume Next Set c = ActiveSheet.UsedRange.SpecialCells(xlFormulas, xlErrors) If Not c Is Nothing Then MsgBox c.Address(False, False) & "セルがエラー" End If End Sub ※　エラーのセル番地も表示しています。m(_ _)m
前回回答のリンク先の「リスト ２」に GetWindowRect Application.hWndAccessApp, rctSize とあります。 Application.hWndAccessApp でAccessのハンドルを指定していますので ここをデスクトップにします。 サンプルファイルのsample2007（かな？）の標準モジュールModule1に 下記１行を追加します。 Public Declare Function GetDesktopWindow Lib "user32" () As Long フォームのオープン時には Private Sub Form_Open(Cancel As Integer) Dim rctSize As RECT Dim hWnd As Long Dim retVal As Long Dim mWidth as long,mHeight as long hWnd = GetDesktopWindow() retVal = GetWindowRect(hWnd, rctSize) mWidth = rctsize.right mHeight = rctsize.bottom msgbox mwidth & "-" & mHeight MoveWindow Application.hWndAccessApp, 10, 50, 900, 800, True End Sub でモニターの左右・天地が分かりますので計算して MoveWindowで指定すれば良いです。 ついでの継ぎ足しは・・・止めましょね。 マナーに欠けるということで嫌われます。 PS. 複数モニターを使用している場合は不明です。 あとユーザーによっては 「端に置きたいのに何故いつもど真ん中に？邪魔！」という場合もあり。 私からは以上です。
私なら、あまり凝ったものは作りません。 エクスプローラを使うと、Visual Basic 6.0 SP6 ランタイムファイルのオブジェクトで名前を取得する必要になったはずです。 >Application.GetOpenFilename("Excel(*.xls?),*.xls?", , , , True) これは、xlsでも、xlsx でも、xlsm でも、ファイル表示します。そして、MultiSelect =Trueですから、 シフトを押しながら、ファイルを選んたり、Ctrl を押しながら、一ファイルずつ選んでも、複数選択できます。 '// Sub OpenFileNCopy() 'No. 9018968 Dim fNames As Variant Dim fn As Variant Dim orgPath As String Dim dstPath As String orgPath = ThisWorkbook.Path 'ファイルを探すディレクトリ dstPath = "C:\Users\[YourName]\My Documents\"　'末尾には必ず、￥マークを入れてください。 　ChDir dstPath 　fNames = Application.GetOpenFilename("Excel(*.xls?),*.xls?", , , , True) 　If Not (IsArray(fNames)) Then 　　 If fNames = "False" Then GoTo EndLine 　End If 　'Application.ScreenUpdating = False　'画面がチカチカしますから、ここを外した方が良いです。 　For Each fn In fNames 　 With Workbooks.Open(fn) 　 　'ここの範囲は任意に設定してください。貼り付け先は、ThisWorkbookのシート1になっています。 　　　.Worksheets(1).Range("A1:E20").Copy _ 　　　ThisWorkbook.Worksheets(1).Cells(Rows.Count, 1).End(xlUp).Offset(1) 　　　.Close False 　 End With 　Next fn 　'Application.ScreenUpdating = True　　'制御したものを戻します。 EndLine: 　ChDir orgPath End Sub '///
こんにちは。 Unicode をJISに変換するなら、以下のような方法で可能です。 置換するのは、これだけでは足らないとは思いますが……。 どこかで話題になったNBSP(no-breaking space) も厄介ですね。これも、「?」になります。 '// Sub U2JISConvert() 　Dim Fname As String 　Dim iFno As Integer 　Dim buf As String 　Dim bufbyt() As Byte 　Fname = "Unicode_Txt" 　iFno = FreeFile() 　Open Fname For Binary Access Read As #iFno 　bufbyt = InputB(LOF(iFno), #iFno) 　Close #iFno 　buf = MidB(bufbyt, 3) 　buf = Replace(buf, ChrW(&H301C), ChrW(&HFF5E)) '置換 　Debug.Print buf End Sub '///
ほぼ似ているコードが掲載されているサイトを見つけたのですが、VB / C# 両者のコードが掲載されています。 参考になると思います。 http://dobon.net/vb/dotnet/datagridview/ownerdra …
日付部分が 2015/07/03 となっていればそのままDate型に代入できるから、 Replace関数で２箇所の : を / に変えてやればいい。 ddd = Replace(aaa, ":", "/", 1, 2)
\\LANDISK-01D595\disk\" & mywbname & ".xlsx このファイルは開いてるので、Workbooksコレクションの中に入ってます。フルパスでなくファイル名だけを使います。 Sheets("追加").Move After:=Workbooks(mywbname & ".xlsx").Worksheets(Worksheets.Count)
>添付画像で３分と書かれている箇所のidを知りたいです。 IDがあるかどうかは、分からないです。 それに、質問の添付画像にはらしきものがはっきり見えません。 今のIE(Ver11)なら、ボタンの所で右クリックして、 コンテクストメニューから「要素の検査(L)」 (FireFoxなら、FireBugで調べられます) コードをみて、そこに、該当する部分の上部に、ボタンのClassなどがあるでしょうから、 それで、後は、VBAを組み立ててればよいのではないでしょうか？ 当然、Classは、IDと違うことは、ご存じでしょうから、詳しくは述べません。画像は、ここのサイトの例です。
とりあえずは、B列のA列の色番号を表示させるVBA Sub ボタン1_Click() For i = 2 To 15 Range("C" & i).Value = Range("A" & i).Interior.ColorIndex Next End Sub 後は、B列で並び替えします。 ただ、私の思う所ですが 商品名の隣に １　赤が次回も出品する商品 ２　黄色が売り切れ商品 ３　青が新規入荷 と数値を入れていき、条件付き書式で　色を付けた方が作業が楽ではないでしょうか。 データの並び替えも出来ますし 別のシートに 希望のするデータを抽出表示した方が便利なような気がします。
>"xlCenter"という文字列で何か簡単且ついい方法をお願いします。 もう少し、基本的なことを勉強したほうがよいでしょうね。 'xlCenter' というのは、CellFormat オブジェクトのプロパティに使われる、 「組み込み定数」といいます。(オブジェクト・ブラウザで参照してください) それを変数に置くというのは、まったく意味がありません。 「組み込み定数」というものは、時々、製作者側のつごうなのか、Versionの違いなのかで、中身の数値を変えらていることがありますが、この定数自体の名称、例えば「xlCenter」の文字列はそのままにしています。そして、ただの数値に文字列として意味を持たしているわけです。 >strFormat = "-4108" だから、このようなことをせずに、あえてユーザー側は、既存にあるものは、そのまま利用すれば済むようになっています。 したがって、条件によって替えたいのでしたら、Switch やIIf 関数などを利用しましょう。（あまり、そういう方法は取りませんが、あえて使うとすれば、そうなります) Dim i As Integer Dim para As Integer i =1 para = Switch(i = 1, xlCenter, i = 2, xlLeft, i = 3, xlRight) Columns("A:C").HorizontalAlignment = para
画像があると早いのですが、 >（列数は5列表示させています） ということは、カラムが5列ですか？ >選択行 = Userform1.ListBox1.ListIndex これで、選択行が取れなかったように思いますが……。 Private Sub CommandButton1_Click() 　Dim i As Long 　Dim j As Long 　Dim Total As Long 　j = 1 '1列目は読まない 　With ListBox1 　　For i = 0 To .ListCount - 1 　　　If .Selected(i) Then 　　　　Do 　　　　　Total = Total + .List(i, j) 　　　　　j = j + 1 　　　　Loop Until j > .ColumnCount - 1 　　　　Exit For 'Singleセレクトの場合 　　　End If 　　Next i 　If Total <> 0 Then 　　TextBox1.Text = Format$(Total, "#,##0") 　End If 　.Selected(i) = False　'選択の反転はここで消える 　End With End Sub
何度もごめんなさい。 ＞出荷率に0がない場合にエラーが出てしまいますが・・・ コードを変えてみました。 今回は作業用の列は使っていません。 Sub Sample2() Dim lastRow As Long, wS As Worksheet Dim myFound As Range, myFirst As Range, myRng As Range, myArea As Range Set wS = Worksheets("表示範囲") With Worksheets("販売") lastRow = .Cells(Rows.Count, "B").End(xlUp).Row '▼E列の「0」の行を検索// Set myArea = Range(.Cells(2, "E"), .Cells(lastRow, "E")) Set myFound = myArea.Find(what:=0, LookIn:=xlValues, lookat:=xlWhole) If Not myFound Is Nothing Then Set myFirst = myFound Set myRng = myFound Do Set myFound = myArea.FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do Set myRng = Union(myRng, myFound) Loop '▲ここまでがE列の「0」の行を探すコード// 'オートフィルタを掛ける// Range("A1").AutoFilter field:=5, Criteria1:="<=" & wS.Range("C2"), _ Operator:=xlOr, Criteria2:=">=" & wS.Range("D2") 'E列に「0」があればその行を非表示にする// If Not myRng Is Nothing Then myRng.EntireRow.Hidden = True End If End If End With End Sub これではどうでしょうか？m(_ _)m
ご質問の内容をまとめると、 Excel 2010Pictures.Insertメソッドを使った方法では、画像のリンク情報だけを保存して、リンク先を表示しているだけで、元がないと、表示されなくなってしまう、という現象ですね。 ただ、このマクロは、オリジナルの縦横比を維持しようとして、そのどちらが、結合セルよりも大きい場合は縮小を、小さい場合は拡大をするという趣旨ではないかと思います。 ですから、Center に納まるという所については、今の所は、意味が分からないのです。 以下は、だいぶ、私のアレンジが入ってしまっています。 ただ、むしろ、リンクが切れたかどうか、調べてください。別のPCはあるものの、面倒極まりない作業の上に、こちらの時間が限られていますので、ご質問者側で、お願いしたいのです。 LinkToFile:=False　←ここ ※　参考にしたところ： http://www.moug.net/tech/exvba/0120020.html '// Private Sub Worksheet_BeforeRightClick(ByVal Target As Excel.Range, Cancel As Boolean) 　Dim FName As String 　Dim oShape As Shape 　Dim mPath As String, orgPath As String 　Dim mRng As Range 　Dim pic As Object 　Dim ht As Double 　Dim wd As Double 　orgPath = ThisWorkbook.Path 　Application.ScreenUpdating = False 　Cancel = True 　 On Error GoTo ErrHandler 　 　'画像がセル全面に入っていると、右クリックさえ出来ないので加えた 　For Each pic In Pictures 　　If TypeName(pic) = "Picture" Then 　　　If pic.TopLeftCell.MergeCells Then 　　　If MsgBox("画像を削除してよろしいですか？", vbQuestion + vbOKCancel) = vbCancel Then Exit Sub 　　　　pic.Delete 　　　　Set mRng = pic.TopLeftCell.MergeArea 　　　　'Targetセルは、結合セルではないので切り替える 　　　End If 　　End If 　Next pic 　 　If mRng Is Nothing Then 　　If Target.MergeCells = False Then 　　　Exit Sub 　　Else 　　　Set mRng = Target 　　End If 　Else 　　Set mRng = Target 　End If 　'ピクチャーフォルダーを探す 　mPath = CreateObject("Shell.Application").Namespace(&H27).Self.Path 　 　Const MF1 As String = "JPEG Files (*.jpg;*.jpeg;*.jpe),*.jpg;*.jpeg;*.jpe" 　Const MF2 As String = "ビットマップ (*.bmp),*.bmp" 　Const MF3 As String = "GIF (*.gif),*.gif" 　Const MF4 As String = "すべてのファイル (*.*),*.*" 　ChDir mPath 　FName = Application.GetOpenFilename(FileFilter:=MF1 & "," & MF2 & _ 　"," & MF3 & "," & MF4) 　ChDir orgPath 　If FName = "False" Then 　　MsgBox "取り消されました。", vbInformation 　　Exit Sub 　End If 　 　With mRng 　　Set oShape = ActiveSheet.Shapes.AddPicture( _ 　　Filename:=FName, _ 　　LinkToFile:=False, _ 　　SaveWithDocument:=False, _ 　　Left:=.Left, _ 　　Top:=.Top, _ 　　Width:=0, _ 　　Height:=0) 　End With 　With oShape 　　'オリジナルスケールを維持する 　　.ScaleHeight 1, msoTrue 　　.ScaleWidth 1, msoTrue 　　ht = .Height 　　wd = .Width 　　 　　.Placement = xlMove　'結合セルに固定しているのに、これが必要かは不明 　　.LockAspectRatio = msoTrue 　　.Height = mRng.Height 　　 　　If wd > mRng.Width Then 　　　.Width = mRng.Width 　　End If 　End With ErrHandler: 　If Err() <> 0 Then 　　MsgBox Err.Number & ": " & Err.Description, vbExclamation 　End If 　Application.ScreenUpdating = True End Sub '///
Worksheets(2).Range("B3:B10").Value これを Worksheets(2).Range("B3:B10") としてみる。
VisualBasicは使っていませんが…… VisualStudioのソリューションエクスプローラに表示されるプロジェクト名を変更したい。 というだけなら、プロジェクト名選択して右クリックの名前の変更で可能だったはずです。 エクスプローラで見えるプロジェクトフォルダの名前を変えたい。ということであれば、また別の対処が必要かも知れませんが。 んで、今回はフォルダ名とか変更してしまったようですので…… ソリューションのファイル(拡張子.slnのファイル)をテキストエディタで開いて、 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = とかの後ろに書かれているフォルダ名を修正してください。 書式については…軽く探した程度では見つかりませんな…。 最初のがプロジェクトの入っているフォルダ名、2番目がプロジェクトファイルのファイル名…ってところでしょうか？ # .slnファイルの或場所からの相対パス。 で、プロジェクトファイル(拡張子.vbproj)にも、それなりに設定があると思われますので テキストエディタで開いて編集してください。 # C++のプロジェクトだと…<ProjectName>タグでVisualStudioに表示されるプロジェクト名が設定されていましたね。 # <RootNamespace>タグはまた別かなぁ…。
確か、第二水準で、読みがないものが数個あるという話を聞いたことがあるので、以下のようなコードにしました。 文字列でないものは、無視します。 B列の最終行にある漢字を取り出すなら、このようになります。ループは不要のはずです。 '// Sub カタカナ変換R() 　Dim LastRow As Range 　 With Cells(Rows.Count, 2).End(xlUp) 　　If VarType(.Value) = vbString And Application.GetPhonetic(.Value) <> "" Then 　　　 .Offset(, 1).Value = Application.GetPhonetic(.Value) 　　End If 　　End With End Sub '/// 連続して、B1から最終行まで変換するなら、このようになります。 '// Sub カタカナ変換r2() 　Dim c As Range 　For Each c In Range("B1", Cells(Rows.Count, 2).End(xlUp)) 　　If VarType(c) = vbString And Application.GetPhonetic(c) <> "" Then 　　　 c.Offset(, 1).Value = Application.GetPhonetic(c) 　　End If 　Next c End Sub '/// p.s. >（手入力が早いと言われればそれまでなのですが・・・・） うーむ、最近、マクロの質問に対して、心ないレスが目立ちますね。一応、削除対象には入るようです。
悪用防止。
ついでに聞いちゃえ、で当初の問題は解決済みにもかかわらず 質問を引っ張る人 はマナーに欠ける人として嫌われます。特に技術系の質問では。 覚えておいてください。 経験が浅いようですので今回に限ってですがお答えします。 Sub Sample3() 　　Dim myWS As Worksheet, BookTo As Workbook 　　MsgBox "新宿が含まれるシートを選択します" 　　Set BookTo = Workbooks.Add '新規Bookの場合 　　'Set BookTo = Workbooks.Open("C:\temp\aaa.xlsx") '既存Book指定の場合 　　For Each myWS In ThisWorkbook.Worksheets 　　　　If myWS.Name Like "*新宿*" Then 　　　　　　myWS.Range("N1").Hyperlinks.Delete 　　　　　　myWS.Copy before:=BookTo.Sheets(1) '一番左側を指定 　　　　　　'myWS.Move before:=BookTo.Sheets(1) 'Move（オリジナルを消去）するばあい 　　　　　　'myWS.Copy before:=BookTo.Sheets("Sheet1") 'シート名Sheet1の左側 　　　　End If 　　Next 　　BookTo.Close savechanges:=True , Filename:="C:\temp\bbb.xlsx" '新規Bookの場合（FileNameを指定しなければ聞いてきます） 　　'BookTo.Close savechanges:=True '既存Bookの場合の上書き保存 　　Set BookTo = Nothing 'オブジェクトの解放 End Sub 追加質問に不明な点があるのでコメントアウトした部分が増えています。 それぞれの意味をヘルプで調べるなりして取捨選択してください。 私からは以上です。
BSC手順の解説は以下です。 http://www.lineeye.co.jp/html/term_denso_seigyo. … 平たく言えば、 １）送信側がこれから通信始めるぞって合図として、ENQを送る ２）受信側が準備が良ければACKを（だめならNAKを）返す ３）送信側はACKを受け取ったら、データを送る ４）受信側はデータに問題なければACKを（だめならNAKを）返す ５）送信側はACKを受け取ったら、EOTを送って通信完了 この手順を実装すればよいわけです。結局のところ、BSCだろうと無手順垂れ流しだろうとSerialPortクラスを使うことは同じで、設定も同じです。違いは要所要所で指定された文字を使って、どの段階かを示していることだけです。 通信を行うサンプルとしては、次のCONTEC提供のサンプルが参考になります。 https://www.contec.co.jp/product/device/serial/t … と言うのが基本で、後は双方の機器が同時にENQを発した場合にどっちが優先かを決める（すでに決まっているかも？）必要があるかと。 あとお互いに送受信し続けるというのは、見かけ上そうなってるけど、実はどちらか一方がマスターで最初にENQを投げる人は固定だ、なんてことではないですかね。その方がプログラムは簡単になります。本当にどちらも送信元になりうる仕様だと面倒さが増しますね。
こんにちは！ A3セルはシリアル値で、B3セルに時刻が入っている訳ですよね？ 単純に =A3+FLOOR(B3,"0:15") として表示形式を yyyy/m/d hh:mm としてはどうでしょうか？m(_ _)m
#1,2 です。 申し訳ありません、わたしの回答は意味なかったです。 B1セルに繰り返し回数が入ってるんですね。勘違いしてました。 それを全く考慮してないコードでした。 大変失礼しましたm(_ _)m
Excelでマクロを記録すれば分かるはず
ブレークポイントの設定かな？ あるいはStopステートメント。
似たような質問はいくつも出ていても解決しませんね。 質問に不完全なHTMLのコードなどは不要です。 ヤフオクのどこの場所なのか『URL』を教えてください。 そして、何をクリックしたいか書くだけで、わかる人には分かります。 ただし、そこが、特別な会員資格の登録や条件が必要だとしたら、少なくとも私には無理です。
表示されている項目の参照設定を一旦外して、正しい参照設定にしなおせばいいのでは。
可能か不可能かと言うと詳しい人にとっては可能。 >　エクセルでWeb情報を更新しながらある値を取得し エクセルのマクロでHTTPリクエストPOSTするということでよいですか？ ある値を取得するのもエクセルでですか？ ここまでエクセルでやるんだったらUWSC使わずにマクロだけでやりきった方がすっきりすると思います。 それはさておき、UWSCを以下の用途でつかうとすると： >　つねにUWSCでエクセルの値を見続けるのと、UWSCからエクセルの特定のセルを監視させる方法 エクセルのセルの値をクリップボードに入れて、UWSCのGETSTR関数を使うことでセルの値をポーリングで監視できます。
Windows8.1ではサポートされていないのでは。 現に新しいPCには、RS-232Cのスロットは有りません。 ＵＳＢの変換アダプタを勧めます。 小生はまだ、Windows7のままで使っています。
>相手側のサーバーに負担をかけないようにスリープを１秒入れるなどした方が良いのでしょうか？ それは、難しい相談ですね。今のところは加えなくてもよいと思います。 ダメな時は、Sleepとか関係がなく別途ボタン操作などを加えて、直接閲覧できないようにされてしまいます。このマクロを考える時点で、サイトで禁止されていないことは、こちらで確認しました。最近、有名サイトは、今回のようなWebスクレイピングが禁止している所がありますが、そこは、アクセス数が半端ないということもあります。今回のような内容は、確かにサーバーには負担を掛けていると思います。 ※何らかの処置された時には、その対応として、WinHttp を使わずに、InternextExplorer に換えればよいと考えています。ただ、手よりは速くても、かなり遅い反応になってしまいます。たぶん、コードは、今以上にややこしいと想像しています。 スリープは、モジュール画面の一番上（Option Explicitがあれば、その下に入れます） そして、単位は、 Sleep 1000　 '1/1000 秒×1,000 =(1000ms=1秒） また、画像を参考にしてください。 'Option Explicit Private Declare Sub Sleep Lib "kernel32.dll" (ByVal dwMilliseconds As Long) Sleep の掛ける場所ですが、ループの Sub Main() '－中略－ For Each c In Range("A2", Cells(Rows.Count, 1).End(xlUp)) 　 rw = c.Row 　If c.Value Like "http://www.bookservice.jp/bs/ItemDetail?cmId=" Then 　　 Call GetHttpLog(c.Value) 　　　Sleep 1000　　　'ここがよいだろうと思います。 　ElseIf c.Value Like "#######" Then 　　　sURL = adrBASE & c.Value 　　 Call GetHttpLog(sURL) 　End If Next
マクロですよね。 Workbooks.Open Filename:="C:\Users\aaaa\Desktop\Test.xlsx" で開くはずですが。 一度、マクロの記録でコードを取得してみては如何でしょう。 何かが違っているはずです。
私が良く使う手ですが For Each objINPUT In objIE.document.all.tags("td") を For Each objINPUT In objIE.document.Forms(0).All とかで 或いは If objINPUT.Title = "ガイドラインと以下の注意事項に同意して出品する" Then とかではダメでしょうか。
#2です。まだ、開けててくださっているのですね。 返事、ありがとうござます。この2年ぐらい、私は、健康を害しまして、いろいろ急いでいる向きがあり、いつまで、ここで書けるのかなっていう思いが、つたない文章で思わぬ誤解を与える時がありました。 >エクセル以外のオフィスでは、パワーポイントは考えましたが、記録マクロを使えないバージョンなので諦めました。次はおそらくVBSだと思います。 パワーポイント(PPT)のVBAは、新しい段階に入っているような気がします。他のOfficeに波及しなければよいのですが。PPTは、オブジェクトさえ分かれば、そんなに問題なく書けます。 https://msdn.microsoft.com/ja-jp/library/ee81473 … PPTは、実際、プレゼンの時に、マクロというか、少し手の込んだことをすると、余程の場数を踏まない限りは、土壇場では失敗する向きが多いような気がします。私がインストラクター試験を受けた時、その場の緊張感が何か違う空気にさせるようで、凝ったことをしようとした人は、だいたい失敗する人ことが多い気がしました。それで、私は、安全策を取りました。 ところで、質問でエクセルVBAエキスパートのことに触れていましたので、以前は、「プロフェッショナル」という上位クラスがありましたが、そこで、 http://store.aoten.jp/shopdetail/002000000002/or … ここに書かれている題目をベースに、私の学んだものをまじえてみました。何かの時に、思い出していただければ幸いです。この中の技術でも、流行り廃れがありますから、5年先にはどうなっているか分かりませんが、残るものもあるはずです。 ------------------------------- コーディング規約、エラートラップの数々、プライベート・パブリック・グローバルの変数やステートメントの違い、Excel 4.0 マクロ、クラスとインスタンス、カプセル化、私製イベント(WithEvents)とInternetExplorer 、Win32API、COMアドイン、DDEやOLEとオートメーション ------------------------------- 外部オブジェクトのMSHTML, WinHTTP や、SHDocVW(IE)、データベース系の DAOとADO。 それから、VBS 系列のFSO(FileSystemObject), Shell32、VBScript.Exp（正規表現、できれば、BASP21のいくつか）,Scripting.Dictionary と .Net FrameworkのSystem.Collections.ArrayList　の比較 また、VB.Net WMI (Microsoft Windows Management Instrumentation) --------------------------------- VB6.0 SP5/6 Runtimeのコントロール(河西朝雄さんの本が詳しい） ---------------------------------- コンピュータの技術の基礎知識。2進と16進そして論理式と論理演算、文字の種類(JIS,Unicode)、流れ図、TCP/IP、PCのハード系の知識。 ---------------------------------- また、ツールのSpy(MiniSpy)、OLEViewer、DependencyWalker、Process Explorer、Custum UI Editor　など、MiniSpy(Vector)を除いて、マイクロソフトからフリーで手には入ります。 マクロを書く時のツール、インデンターのVbePlus(渡辺ひかるさん作）、テンプレートのVBA MZ-Tools 3.0、Win32APIを書くためのApiViewer は私は重宝しています。 --------------------------------- この他に、ここの教えて！gooで印象深かった人、いうなれば私に影響を与えた人。 教えて！gooの一番華やかな時代で、かつての常連で達人のK氏。K氏が他の追従を許さないワザは、VBAからのJavaScript、Win32APIやExcelのHackの知識など、驚かされることが多かったです。しかし、やがてVBAらしからぬコードを書き始めて、その後、ここを離れてしまいました。 教えて！gooにホンのちょっとしかいなかった、YU-Tangさんは、知っている人は知っている、VBAによるWebスクレイピングの先駆者。（その後、あちこちのサイトで、Webスクレイピングお断りが出るようになりました。） 私自身、Webスクレイピングは、サイトには負担は掛けていないはずですが、現在の「教えて！goo」と「OkWave（昨日バグを見つけてやり直し）」は、ひとカテゴリに1回（1～2page)だけですので、リストを撮っています。 YU-Tangさんのサイト http://www.f3.dion.ne.jp/~element/msaccess/index … 私は、どちらかというと、棺桶に片足突っ込んでも、まだExcelをいじっているようなものです。どのみち、後10数年もすれば、Excelは、まったく別なものに変わっているでしょうけれども、私が思うことは、世界で初めての（PCにおいて）表計算VisiCalcは、Lotus123、Quattro、Multiplan、Excel と、形を変えも同じコンセプトで出来ていますから、次世代の表計算も、その遺伝子は続いていくものだと思います。 #3さんの業務中心か、プログラマーの道かという選択肢に、私自身は、もともと、会社の時も、会社を辞めた後の仕事でも、Excelはほとんど使いませんでしたし、別にプログラマーということもなかったのですが、知りたいという気持ちが、いろいろと学ぶ結果になったのです。 Excelではないのですが、プロの方（プログラマとして独立している人）、何人からか、心得というものを教わりました。 　・お客のHDDの環境を変えようとするな。変えたら、元に戻せ。 　・形（スタイル）やテクニックにこだわるな。 　・プライドなど捨てて、人のコードは利用せよ。 ということでした。思ってもみない助言でした。 正直なところ、私は、Excelをスタートするには、出遅れてしまいました。Excel 2000を前後にして、短い期間に多くの情報が流れていたのですが、気がついた時には、もう遅かったです。もちろん、それを入手するためには、知識だけでなく、お金が必要だったのは言うまでもありません。MSDNサブスクリプションの会員はおろか、CA認証局のデジタル署名でさえ、私にはどうにもならなかった現実が立ちはだかりました。できれば、VBAなどそこそこにして、他の言語をしていればよかったかな、と思うこともあります。 私個人は、マクロ・VBAの類は、ネット以外の場では、まったくというほど教えませんし、教える気がありません。まあ、私から教わろうという人もいませんが、もう、昔のようなコードが書けなくなっていることも事実です。 仮に教える場があっても、人のコードは、エラーなく通れば、それで良いことにします。あれこれ完璧なことを目指し、余計なことを言っても、人は受け入れないものなのです。出来る人は、何も言わなくても、私の技術なんかは、数ヶ月で追い越してしまいます。出来ない人は、ある一定の所までくると、その先には進みません。 VBAでは、いわゆる上級文法といって、動的配列や値渡し・参照渡しなどの項目までは、プログラミングとしては初級に入り、それを習得しないとプログラミング言語としてはいえないわけです。それさえも、終えた人が少ないような気がします。 私の会社勤め時代は、専ら MS-DOSの時代です。ExcelもWindowsも、最初に触ったのは、会社をやめてからですし、ハロワの技術訓練校で、最初にマクロを勉強した時は、自宅にWindowsマシンもExcelもありませんから、家では、紙の上に、プログラムを書いて、訓練校のExcelに書き込んでみて、動くかどうかを試したぐらいです。
念のため、Cドライブ直下にファイルを置いて試しましたが問題ありませんでした。 ただ、Windows Vista？以降からはCドライブ直下はUAC（User Account Control）の制約を受けますので その為かもしれません。 フォルダを作成し、C:\Temp\Book1.csv などにしてみたらどうですか？ 前略 With Cn .Provider = "Microsoft.ACE.OLEDB.12.0" .ConnectionString = _ "Data Source=C:\temp\;" _ & "Extended Properties='text;HDR=NO;" _ & "FMT=Delimited'" .Open End With Set Rs = CreateObject("ADODB.Recordset") Rs.CursorLocation = 3 'adUseClient Rs.Open "SELECT * FROM Book1.csv", Cn, 0, 1, 1 後略 "Data Source=C:\temp\;" _ は"Data Source=C:\temp;" _ と 最後の\が無くても動きますが付けといてください。
Convert C# to VB.NET http://www.developerfusion.com/tools/convert/csh …
こんにちは！ ＞'……４０列まで続く とは「レポート」Sheetの40列（AN列）までというコトでしょうか？ それともデータがある限り3列毎に40回同じ操作を繰り返す！というコトなのでしょうか？ 質問文では A・C・F・I・・・ となっていますので、 A列はそのまま値をコピー＆ペーストし、C列以降3列毎というコトですよね？ 二つやってみました。 「Sample1」がAN列までで、「Sample2」がデータがある限りC列以降3列毎に40回コピー＆ペーストしています。 Sub Sample1() Dim j As Long, cnt As Long, wS As Worksheet Set wS = Worksheets("1") With Worksheets("レポート") .Range("A4:A23").Copy wS.Range("A3").PasteSpecial Paste:=xlPasteValues cnt = 1 For j = 3 To 40 Step 3 '//C列～AN列まで3列毎 cnt = cnt + 1 Range(.Cells(4, j), .Cells(23, j)).Copy wS.Cells(3, cnt).PasteSpecial Paste:=xlPasteValues Next j End With End Sub Sub Sample2() Dim j As Long, cnt As Long, wS As Worksheet Set wS = Worksheets("1") With Worksheets("レポート") .Range("A4:A23").Copy wS.Range("A3").PasteSpecial Paste:=xlPasteValues For j = 3 To .UsedRange.Columns.Count Step 3 '//C列～最終列まで3列毎 If cnt = 40 Then Exit For '//40回繰り返したらループから抜ける★ cnt = cnt + 1 Range(.Cells(4, j), .Cells(23, j)).Copy wS.Cells(3, cnt + 1).PasteSpecial Paste:=xlPasteValues Next j End With End Sub こんな感じで良いのでしょうか？m(_ _)m
#2の回答者です。 >最低でもどのセルにUNICODE文字が含まれているか知りたい ということで、#2のユーザー定義関数を利用した、シート全体を探すマクロを加えておきます。どちらも、標準モジュールを使います。 '// Sub Macro_8996251() Dim Rng As Range Dim c As Variant On Error Resume Next Set Rng = ActiveSheet.Cells.SpecialCells(xlCellTypeConstants, 23) If Err() <> 0 Then Exit Sub On Error GoTo 0 For Each c In Rng.Cells 　If CheckUNICODE(c.Value) = 1 Then 　　 c.Interior.ColorIndex = 3 　End If Next c End Sub '///
入れ子になった内側の With の中で省略できるのは内側の With で指定しているオブジェクトだけです。 質問文の箇所で ThisWorkbook.Worksheets("Sheet1") を省略することはできません。 今回の質問のポイントからは逸れますが、私の場合 Worksheet を操作するときは対象の Worksheet を必ずオブジェクト変数越しに使うようにしています。 Dim sht1 As Worksheet Set sht1 = ThisWorkbook.Worksheets("Sheet1") With ListView1 　　Dim i As Long 　　For i = 2 To filenum0 + 1 　　　　.ListItems.Add Text:=sht1.Cells(i, 1).Value 　　Next i End With
こんにちは。 >autofilterでエラーとなります。どこがおかしいのでしょう？ AutoFilter では、 　Criteria1:=100000 このような書き方はしなかったはずです。 Criteria1:="=100000" 　　か Criteria1:="100000" のいずれかを書けばよいと思います。 ちなみに、 Criteria の部分のヘルプを見ますと、 「抽出条件となる文字列 ("101" など) を指定します。」 と、文字列指定になっています。 '// 　With ActiveSheet 　　.AutoFilterMode = False 　　With .Range("A1").CurrentRegion 　　　.AutoFilter Field:=1, Criteria1:="100000" _ 　　　, Operator:=xlFilterValues 　　End With 　　　.AutoFilter.Range.SpecialCells(xlCellTypeVisible).Copy _ 　　　Worksheets("Sheet2").Range("A1") 　　.AutoFilterMode = False 'AutoFilter を解除 　End With '/// .AutoFilter.Range. これは、AutoFilterとして認識されている範囲だという意味です。
#1の回答者です。 前：　If ActiveCell.Text <> "" Then 　　TxtData = Replace(Trim(ActiveCell.Text), """", "") 　　↓ 後：　If Range("E6").Text <> "" Then 　　TxtData = Replace(Trim(Range("E6").Text), """", "") 　 .Text プロパティと、.Value プロパティの違いは、ほとんどないはずですが、書式で変更されたものを優先させる場合などは、.Text プロパティになります。親オブジェクトのWorksheets(～).Range(～)がないというのは、ActiveSheet という意味です。 また、Trim関数自体は文字の前後の空白を取るためのものですから、不要とあれば、そのままなくても良いと思います。
Range("C10").Formula = "=YEAR(A10) & "&quot;/"" & Month(A10) & ""/"" & Day(A10) & "" "" & HOUR(B10)"
私はいつもメールの本文にコピペして送ってますよ。
> で、問題なのですが、MSDNのリファレンスを見ていると、ConfigurationManager.AppSettings プロパティのページでhaskeysの記載がなく、HasKeysのページで、AppSettings の記載がありません。 1 個間を挟みましょう。 ConfigurationManager.AppSettings プロパティのページに「構文」節があって、以下の記述があると思います。 型 : System.Collections.Specialized.NameValueCollection つまり、このプロパティは System.Collections.Specialized.NameValueCollection という型であると明記されています。丁寧なことにその型のページへのリンク付きで。 そして、そのリンク先のページのメソッド節に HasKeys のページへのリンクが存在します。それをクリックすればいいのですよ。 なぜ互いのページに相手の記述が無いかというと、MSDN の利用者は AppSettings プロパティに対して必ず HasKeys を使うわけではなく、HasKeys （というか NameValueCollection 型）は AppSettings 専用ではないからです。 AppSettings でどんな操作ができるかを知りたいならばそのプロパティの型でどんな操作ができるかがわかればいいのです。だから AppSettings のページではどんな操作ができるは記述せずただその型を記述し、それ以外の、どんな値が入っているかを主に記述しているのです。 一方、NameValueCollection 型はアプリケーションの設定に限らず「この文字列に対してこの文字列が対応している、という対応が複数ある」という場面で広く使われています。そのような状況で AppSettings に関する記述だけを書くわけには行きません。かといって、この型を使用しているすべてのプロパティやメソッドについてすべてを記述したならばこの型のページは数倍に膨れ上がり、かつ、それはそのページを訪れた人にとってほとんどが無意味な情報になります（たとえばあなたの場合、AppSettings 以外のどのプロパティが NameValueCollection 型かなんてどうでもいい事ですよね?）。だから NameValueCollection 型のページにはこの型がどこで使われているかは記述していないのです。 何か長文になってしまいましたが、MSDN に限らずリファレンスマニュアルを調べる場合には、そのプロパティやメソッドで使用したり返してくる型が何かを見ることも大事です。
そういうコマンドは無いので、自分でプログラムを作る必要があります。 送りたいメールアドレス一覧があるなら、メールソフトで普通に送ればいいだけだと思いますが、毎日同じ宛て先に違うファイルを送る業務があるとかですか？メールソフトにそれにつかえる機能があったりしませんか？
レイアウトがわかりませんのではっきりは言えませんが、COUNTIFなどでできると思いますよ。 どういった点が複雑…？
処理の流れは (1) データを元に、 gnuplot のスクリプトを作成する (2) (1)のスクリプトを gnuplot で処理する となります。 スクリプトについては、解説サイトが充実していますので、そちらを参考にしてください。 i) まずは、VBAは使わずに、テキストファイルでスクリプトを作ります。 それが期待通りの画像になるようにスクリプトを修正しましょう。 ii) 次に、VBAで、上記スクリプトと同様の内容をテキストファイルに書き出すプログラムを作ります。 iii) ii)のスクリプトをgnuplotで処理します。 　・VBAから、 スクリプトを指定してgnuplotを実行 　・VBAから、 スクリプトをファイルでなくgnuplotの標準入力へリダイレクトするようにする 　・保存したスクリプトをバッチファイルを使ってgnuplotで処理 等があります。
もしかして、、、 ボタン1のどこかでEnd使ってない？ End Subとかじゃなくて、単独のEnd
こんばんは！ 「s」が入るのは1行に付き、一つという前提です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）各セルに「s」を入力してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) '//この行から Dim j As Long, k As Long Dim myFlg As Boolean, myAry As Variant '//対象セルの行番号を格納 myAry = Array(25, 31, 37, 43, 50, 56, 62, 68, 74) '//複数セル変化の場合は何もしない If Target.Count > 1 Then Exit Sub With Target '//変化セルがF～M列の場合 If .Column > 5 And .Column <= 13 Then '//変化セル行番号が対象セル内にあるか確認 For k = 0 To UBound(myAry) If .Row = myAry(k) Then myFlg = True Exit For End If Next k '//変化セルが対象範囲内の場合は If myFlg = True Then Application.EnableEvents = False If .Value <> "" Then '//該当せるが「s」と入力された場合 If .Value = "s" Then '//E列～変化セルの左セルデータを消去 Range(Cells(.Row, "E"), Cells(.Row, .Column - 1)).ClearContents '//変化セルがL列までの場合は変化セル～M列データを消去 If .Column < 13 Then Range(Cells(.Row, .Column + 1), Cells(.Row, "M")).ClearContents End If For j = .Column - 1 To 5 Step -1 If Cells(.Row, j).Offset(1) <> "" Then Cells(.Row, j) = "○" Exit For End If Next j End If Else Range(Cells(.Row, "E"), Cells(.Row, .Column - 1)).ClearContents End If Application.EnableEvents = True End If End If End With End Sub '//この行まで とりあえずはこの程度で・・・m(_ _)m
MIDI なんて 20年ぐらいぶり。 しかもバイナリでなんか気にも留めたことなかった。 タイムベースが 0x01E0 となっているので、10進数に直してみると 480になる。 つまり四分音符の分解能は 480ってこと。 んで四分音符と同じ長さでデルタタイムを記述したいのなら 480 をセットする。 480 を 2進数にすると 00000001 11100000 となる。 ただしこの 2進数は 8bit で素直に算出したもの。 これを MIDI の 7bit 区切りにすると 10000011 01100000 となる。 これを 16進数にすると 0x8360 になる。 逆に言えば、 バイナリ中のデルタ値が 0x8360 になっていたとすると これを 2進数にすると 10000011 01100000 となる。 これは MIDI のお約束で 7bit化された値を 8bitで表したもの。 これを純粋な 8bit に直す。 下位 01100000 の先頭の 0 を捨てると 1100000 となる。 先頭の 1ビットは上位の一番ケツの値から持ってくる。 上位 の一番ケツの値は 1 なので、こいつをもらう。 そうすると下位の値は 11100000 になる。 上位 10000011 は、ケツの 1 を下位にくれてやり、全体を右にシフトする。 ただし先頭の 1 は 「下位とつながってる」 というフラグ値なので捨てる。 そうすると上位 10000011 は 00000001 になる。 上位と下位を並べると 00000001 11100000 となる。 これは 16進数だと 0x01E0 になる。 タイムベースで指定している値と同じなので、四分音符ぶん待つよう書かれていることが分かる。
CoreTweet というライブラリが有名です。 NuGet を使えば VB.NET のプロジェクトに簡単に導入できます。 ただし世のサンプルはほとんど C# で書いたものなのでサンプルコードを自分で VB.NET に翻訳する必要がありますが、そこは問題ないと思います。 CoreTweetをVisualBasicで使ってみた。 http://blog.kanbouex.com/?p=83 CoreTweet の Wiki https://github.com/CoreTweet/CoreTweet/wiki
A=12345 A=Int((A+5)/10)*10 で、おおむねいいのですが、-105 が、-110でなく-100になります。 -105を-110にしたければ、 A=Sgn(A) * Fix((Abs(A) + 5) / 10) * 10 のように符号を明示的に見ないといけません。
Webの情報は、「ちょっとした便利な小技」のような断片情報ばっかり多く、きちんとしたアプリケーション開発については書籍を読むのがいいのですが、いままで良い本がなかなかなかったです。 つい最近でたこの本 ttp://www.amazon.co.jp/Excel-VBA-%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80%E3%80%80%EF%BD%9E%E6%97%A5%E5%B8%B8%E6%A5%AD%E5%8B%99%E3%81%AE%E8%87%AA%E5%8B%95%E5%8C%96%E3%81%8B%E3%82%89%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E9%96%8B%E7%99%BA%E3%81%BE%E3%81%A7%EF%BD%9E-%E5%A4%A7%E6%9D%91-%E3%81%82%E3%81%A4%E3%81%97/dp/4774173673/ref=sr_1_2?s=books&ie=UTF8&qid=1432160316&sr=1-2&keywords=%E3%82%A8%E3%82%AF%E3%82%BB%E3%83%AB+vba+%E5%85%A5%E9%96%80 オイラはとても良いと思ったのですが、本屋でみられたらどうでしょう。
マルチポストだったんですね http://www.moug.net/faq/viewtopic.php?t=72029 マルチポストとは 『[Tips]マルチポストが嫌われる理由～なぜマルチポストは問題か？』 http://stakasaki.at.webry.info/200512/article_3. … 私からは以上です。
こんばんは！ ＞リストボックスに抽出されたデータをクリック（または選択してコマンドボタン）すると・・・ 「リストボックスのデータをクリックすると」・・・にしてみました。 デザインモードにして、ListBox1をダブルクリックして↓のコードにしてみてください。 Private Sub ListBox1_Click() Dim c As Range Set c = Range("D:D").Find(what:=ListBox1.Value, LookIn:=xlValues, lookat:=xlWhole) Label1.Caption = Cells(c.Row, "B").Value Label2.Caption = Cells(c.Row, "E").Value End Sub ※　当然のことながらD列に重複データは存在しないという前提です。m(_ _)m
>部下が入力した情報をもとに、色々な内容を私で入力するのですが、私が入力した情報は部下に見せたくないからです。 このような場合は、サンプル2(MDB)に部下用のテーブルを作り部下側(MDEのほうが無難)にリンクテーブルをつくり、それに入力させるのがアクセスでは簡単です。 まあ、入力時にネットワーク環境にないとかで、どうしてもVBAでやりたいなら、(私はADOのほうがなれているのでADOで描くけど、DAO でも基本的には一緒だと思う)こんな感じでよいんだけど、どのタイミングでどのレコードを移すか、とか、いくつか、考えなくてはいけないことも出てくる。 Private Sub コマンド0_Click() Dim con1 As New ADODB.Connection Dim con2 As New ADODB.Connection Dim rst As New ADODB.Recordset Dim strDatabase As String Dim strSQL As String strDatabase = "db2.mdb" Set con1 = CurrentProject.Connection con2.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & "Data Source= " & strDatabase strSQL = "SELECT * FROM TEST" rst.Open strSQL, con2, adOpenKeyset, adLockOptimistic Do Until rst.EOF strSQL = "INSERT INTO TEST VALUES(" & rst.Fields(0) & ",'" & rst.Fields(1) & "')" Debug.Print strSQL con1.Execute strSQL rst.MoveNext Loop rst.Close Set rst = Nothing con2.Close Set con1 = Nothing Set con2 = Nothing End Sub strDatabase はコピー元のデータベースフルパスで、 最初のstrSQL　対照テーブル名の変更と必要であればwhere句でレコードの限定を、 loop内のstrSQL は入力テーブル名の変更と、デリミター等の調整 など変更が必要です。 処理終了時や、エラー発生時のメッセージ等は入れていません。 ちょろっと書いただけで、動作検証はしていませんが、多分動くと思います。
>("\", "htmlfile")のところを設定の仕方を教えていただけますでしょうか？ これはVBSでクリップボードのデータを何とか簡単に取得できないかと Googleりまくっただけです (^_^;) http://scripting.cocolog-nifty.com/blog/2010/04/ … >標準入力、や、標準エラー出力、の出力の仕方も教えていただけますでしょうか？ これもごめんなさい。そこまでスキル/経験が。。。 先達のご登場に期待しましょう。
ReadAll・ReadLine は Scripting.FilesystemObject を使っているのかな？ 案１ 変数BufにReadAllで取り込み Split(buf,vbcrlf) で配列変数に格納 Lbound ～ Ubound でループ 左4文字がabcdになっている行の処理 Joinしてファイルに書き込み が大雑把な流れです。 案２ 正規表現で・・・は割愛します。 今のコードが不明なのでこれにてゴメン。
スッキリと分かるようになりました。 以下は異常記録.accdbのパスをE:\folderU\異常記録.accdbにしてある場合のSQL文です。 そちらの環境に合わせて変更してください。 そのSQL文をメインデータ.accdbの新規クエリのSQLビューにコピペし 出来た更新クエリを走らせてみてください。 INSERT INTO 社内異常記録 ( 検査番号, 社名, 品名, 測定値 ) IN 'E:\folderU\異常記録.accdb' SELECT 検査番号, 社名, 品名, 測定値１ & '/' & 測定値２ AS 測定値 FROM 検査記録 WHERE 検査番号 NOT IN (SELECT 検査番号 FROM 社内異常記録 IN 'E:\folderU\異常記録.accdb'); なお、確認ですが 異常記録.accdb 　　社内異常記録 　　　　No オートナンバー型 主キー・インデックス有 　　　　検査番号　 テキスト型 インデックス無 　　　　社名　　　 同上 　　　　品名 　　　同上 　　　　測定値 同上 の検査番号フィールドには、メインデータ.accdbの検査番号が入るのですよね？ でしたら、データ型を長整数型にしてください。 また、念のため、インデックス有・重複なしに設定しておいた方が安全のように思えます。 あと、Noというフィールド名は適切でないので、IDなどに変更をお勧めします。
では、こういうこと？ Private Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean) Me.Label1.Caption = Sheets(1).Cells(Me.ListBox1.ListIndex + 1, 2) Me.Label2.Caption = Sheets(1).Cells(Me.ListBox1.ListIndex + 1, 4) End Sub Private Sub UserForm_Initialize() ListBox1.AddItem "い", 0 ListBox1.AddItem "ろ", 1 ListBox1.AddItem "は", 1 End Sub ヘルプで調べてみてください。 解決しないようなら、ここはいったん締め切ってしまって あなたが実際に行いたいこと、実際の状況（回答者が再現できるものであれば本物でなくとも可） を再度質問されては？
アプリの説明にapkの直リンクあるんですけど・・・一応コピペしときますね。 ---- 説明 こちらからDLしてください http://dnote.biz/lineeditor.apk">http://dnote.bi … このアプリはroot,sqlite3が必要です。 rootを取得していて実行しても機能しない場合はSQLite Installer for Rootを利用し、最新のsqliteをインストールしてください。
課題が１番左のシートと仮定し、２番目のシートに出力するサンプルです。 Sub myJoin() 　　Dim i As Long, j As Long, LastRow As Long 　　Dim Buf As String 　　 　　LastRow = Sheets(1).Cells(Rows.Count, 2).End(xlUp).Row 　　For i = 1 To LastRow + 1 　　　　If Sheets(1).Cells(i, 2) = "好物" Then 　　　　　　j = j + 1 　　　　　　Sheets(2).Cells(j, 1) = Sheets(1).Cells(i, 1) 　　　　　　If j > 1 Then 　　　　　　　　Sheets(2).Cells(j - 1, 2) = Mid(Buf, 3) 　　　　　　　　Buf = "" 　　　　　　End If 　　　　ElseIf i = LastRow + 1 Then 　　　　　　j = j + 1 　　　　　　Sheets(2).Cells(j - 1, 2) = Mid(Buf, 3) 　　　　Else 　　　　　　Buf = Buf & vbCrLf & Sheets(1).Cells(i, 2) 　　　　End If 　　Next End Sub 出来はイマイチ。。。
VBAで、データの入っている最終行の取得方法です。 Range(”B" & Rows.Count).End(Xlup).Row という方法があります。B列のシートの一番下から 上へ移動して、空白でなくなった行番号です。 Range("$B$5:$P$"& Range(”B" & Rows.Count).End(Xlup).Row).AdvancedFilter Action:=・・・ とかでは如何でしょうか。
xlBook2.Worksheets("DATA①").Copy after:=xlApp.Workbooks(xlBook1.Name).sheets(1) だとどうです？
Cells(i, 12) = Cells(i, 12) & Cells(i, 14).Text & "/" & Cells(i, 13).Text とかでも。
No.4です。 ＞ひとつは別シートから名称を参照し、もうひとつはその名称を元にやはり別シートから数値を参照しているという数式ですが前者は空白に後者はゼロという値が返ってきました。 ん～～～ 前回のコードはそのまま「値」を引っ張ってきていますので、 Sheet1のA2～F10セル結果そのものが「0」となっていませんか？ （参照先データが空白なので数式によって「0」が返っている） その場合はVBA云々ではなく、IF関数等で「0」を返さない数式にする必要があると思います。 具体的にどのような結果を返しているのか判らないので、 こちらで判断できるといえばこのくらいです。 ※　参考にならないかもしれませんが、 この程度でごめんなさいね。m(_ _)m
#1です。補足コメント有難うございました。 大変失礼しました。確かに組み合わせまで確定しないと意味ないですよね。 申し訳ないですm(_ _)m で、ちょっと考えてみました。・・・が、かなり難問ですね。 28人から4人ずつのチームを7組作る組合わせ 28C4*24C4*20C4*16C4*12C4*8C4*4C4　／　7！ ＝13,189,599,057,009,400 通り！ １京3189兆5990億5700万9400通り　・・・・　Orz というわけで、マクロを使用しても到底総当たりは無理。 （＃１で見た最頻値のチームだけを取り出して、マクロで総当たりの7組を作ろうとしましたがうまくいきませんでした。 あれこれ試行錯誤しましたがちょっと無理でした。） 結局、超ベタな方法を考えてみました。もはやマクロとは全く関係ないですが（汗。 生徒28人を、タイムの昇順に並べて、速い子から、A,B,C・・・X,Y,Z,a,b とします。 で、これを順に7チームに割り振っていく。 ①　各チームの1人目は　A～F　に。以下の図でいえば、上から下に。 ②　2人目は、下から上に、H～N　まで。 3人目、4人目も同様に。 A　N　O　b B　M　P　a C　L　Q　Z D　K　R　Y E　J　S　X F　I　T　W G　H　U　V 横につながった4人が、一チームです。 各人の測定タイムの散らばり具合にもよりますが、かなり均質化できると思います。 わたしの手元ダミーデータではほぼ同じタイムでした。 人名、タイムを当てはめて4人の合計タイムを見てみて下さい。 わたしの力ではお役にたてず申し訳ありません。大変失礼いたしました。m(_ _)m もっと詳しい方の回答が付くことを祈っています。
実際の業務での運用の場合ですが 準備 １、BookA　の別シート（仮に　設定と云う名前）を準備 ２、BookB　へのパスとファイル名を入れておく 　　仮に　 　　A　　　　　　　　　　　B 　ファイルへのパス　　　　Z:\ 　ファイル名　　　　　　　BookB.Xlsx この方が、後々、変更があった場合に、マクロを修正する事がなく使えます。 BookAのマクロ ①Book BのSheet2を開く　 ③列　D、E、F、Gの最終空セルに、BookAの所定のセルの値を入れる。 ④データをセーブし、Book Bを閉じる この様にした方が良いと思います。 Workbooks.Open Sheets("設定").Range("B2").Value & "\" & Sheets("設定").Rnage("B3").Value Sheets("Sheets2").Activate Gyou=Range("D" & Rows.Count).End(Xlup).Row+1 Range("D" & Gyou).Value=Thisworkbook.Sheets("Sheets2").Range(所定のセル1）.Value Range("E" & Gyou).Value=Thisworkbook.Sheets("Sheets2").Range(所定のセル2）.Value Range("F" & Gyou).Value=Thisworkbook.Sheets("Sheets2").Range(所定のセル3）.Value Range("G" & Gyou).Value=Thisworkbook.Sheets("Sheets2").Range(所定のセル4）.Value ActiveBook.Save ActiveBook.Close の様な流れ 実際には、 マクロを重複して操作できない様に コピー元のデータをクリアして、BookAも上書き保存してしまう。 再度、マクロを実行しても何も起こらない様にする 既に、BookBを誰かが開いていた場合 BookBが読み取り専用で開いてしまったら、メッセージを出して 何もせずに終了 ミスがあって、BookBを修正する時のルール などと発展させていきます。
最後に。＃１です。 とりあえず良かったですね。 今後はいろいろ知識を蓄積していかれるとよいと思います。 便利ですよ、知っとくと。 ＞初心者向けの本、本当の基礎からの本とか、ネットでとか見たり調べたり わたしも本当に最初のころは、初心者向けの本から入りました。 で、最初から順番に、その本に書いてあることを、そのまんま自分でやってみました。 コードを書き写して実行して、どんなふうに動くのか、自分で体感してみる。 とりあえず、よくわかんないところがあっても、書いてある通りに、まず真似てやってみました。 で、その本をサッと一周終えてみました。 なんとなくおぼろげにしか分かりませんでしたが、でもずいぶん基礎知識の構築には 役に立ちました。 あとは、今回のご質問のような、実際に使うものにいろいろ当てはめてみて。 けっこう、エラーは出ますよね。今回みたいに。そんなのをググりながらあれこれ調べて 知識を蓄積していきました。だんだん理解が深まっていったというか。 それと、マクロの自動記録なんかも使って、「どうやって書くのか」ってことも調べたり。 今でもまだまだ知らないことは一杯あるので、さらに蓄積は要るなあと思っています。 なお、今回のコードを色々研究されるなら、以下のパーツで成り立っています。 ご参照ください。学習済みならすみません。 ・変数の宣言と型・・・冒頭のDim のところ。Integer、String　なんかのところ ・配列　・・・　motohani のところ。 ・配列の要素　・・・　i=0 To Ubound(motohani)　のところ。 ・ループ　・・・　For　Next の部分 ・条件分岐　・・・　If　End If のところ ・検索　・・・　Findメソッド ・指定分ずらした位置の処理　・・・　Offsetプロパティ
説明上簡単なのでワークシートの図ですが 黒丸が「ある点」、 コントロールが色枠で囲った部分、 とします。 各コントロールの座標 Top、Height、Left、Width が得られるなら （プロパティで確認してみてください） Topで上下の起点、 Top + Height で上下の終点がわかるので 黒丸の座標と比較すればコントロールの上下の範囲内か判別できます。 左右も同様。 で、両者ともに範囲内なら 『ある点にコントロールがあるかどうか』が判別できるかと。 重なっている場合は ぴったんこの重なり、内包されている、部分的な重なり が考えられますが お互いのコントロールの左上、右上、左下、右下の座標を比較すれば 重なり具合も含めて判別できると考えられるのでは？ でも、#2 さんと同様、ちょっと ？
こんにちは！ すでに回答は出ていますので、参考程度で・・・ Sub Sample1() Dim i As Long For i = Cells(Rows.Count, "B").End(xlUp).Row To 3 Step -1 If Left(Cells(i, "B"), 2) <> Left(Cells(i - 1, "B"), 2) Then Rows(i & ":" & i + 1).Insert End If Next i End Sub こんな感じではどうでしょうか？m(_ _)m
コピペすると当方では Address: ～中略～ hl=ja&dirflg=d&sad … _ のようにおしまいが三点リーダーになってしまいます。 なので全角文字で載せてイミディエイトウィンドウで半角にしてもらおうと 思った次第。 hl=ja&dirflg=d&sad … _は hl=ja&dirflg=d&saddr=" _ です。
Debug.Print 反復時刻 がまずいですね。 たぶんVBAの仕様だと思いますが、日付型をPrintで表示するとき、時刻が0:00:00の場合は日付だけ表示して時刻は表示しないようになっているんでしょう。 常に時刻も表示したいなら、Format関数で書式を指定してください。 Debug.Print Format(反復時刻, "yyyy/mm/dd h:nn:ss")
＞上の値が良いか、0.1足した方が良いか・・・ですが、通常、 ＞エラーが一度出ると、以降、不整合で、気が付くまでエラーが続きます。 この部分が良くわからないですが 例えば、　０　とかありえない　数値にしてしまうのはダメなのでしょうか。 その上、条件付き書式の設定で ０の場合は、セルの塗りつぶし　と設定するとか ちなみに 式は =IF(COUNTIF('60min'!C$77:C$5000,C5880),VLOOKUP(C5880,'60min'!C$77:Q$5000,13,0)*$Q$6,0) とかでは
私だったらですが 在庫のブックのデータを チラシのブックの別シートに張り付けるマクロを考える （ Workbook_Openでも利用してチラシのブックを開いたら常に 　最新の在庫数になるようにするなど） チラシの在庫数などは、Vlookup関数で処理させます。
Excel VBA のお話？かな。 残念ながらリストビューコントロールは使ったことがありません。 どうやって取り込んでいるのでしょう？ 先達のご登場に期待しましょう。 あと、ちょっとだけ。 VBAのReplace関数にはヘルプを見ると 『compare 省略可能です。文字列式を評価するときに使用する文字列比較のモードを表す数値を指定します。 設定する値については、次の「設定値」を参照してください。』 ・・・とありますよ。 ワークシート関数には無さげ。 また、Option Compare ステートメントについても調べてみると、吉かも？ 以上ご参考まで。
バイナリでファイルポインタ操作したい場合は 基本的にはSeekでファイルポインタ操作することになります (アスキーファイルでも同じといえば同じ） バイオナリファイル扱いなら　　指定行まで飛んだり というのがそもそもありえない話です (テキストファイルならあり得る話ですが) 指定行に飛ばすといったことはできません 事前にバッファにデータを読み込んだうえで その行が先頭から何バイト目にあるかなどを判断したうえで Seekを使ってファイルポインタ動かすことになるかと思います
検索というモノをしたことがあるか？ 検索すれば、幾つも見つかるが・・・・・
商品が質問文の３種類しかないのであれば、以下のように書けば期待するイメージにはなります。 （手元にAccessがないので、このままで動くかどうかわかりません。LibreOffice Base では動きました） SELECT t0.売上日 AS 日付, NVL(t1.売上数, 0) AS 商品Ａ, NVL(t2.売上数, 0) AS 商品Ｂ, NVL(t3.売上数, 0) AS 商品Ｃ FROM (SELECT DISTINCT 売上日 FROM 売上) t0 LEFT OUTER JOIN (SELECT 売上日, SUM(数量) AS 売上数 FROM 売上 WHERE 商品 = '商品Ａ' GROUP BY 売上日) t1 ON t1.売上日 = t0.売上日 LEFT OUTER JOIN (SELECT 売上日, SUM(数量) AS 売上数 FROM 売上 WHERE 商品 = '商品Ｂ' GROUP BY 売上日) t2 ON t2.売上日 = t0.売上日 LEFT OUTER JOIN (SELECT 売上日, SUM(数量) AS 売上数 FROM 売上 WHERE 商品 = '商品Ｃ' GROUP BY 売上日) t3 ON t3.売上日 = t0.売上日 ORDER BY t0.売上日 商品の種類が多かったり可変の場合は対応できません。
No.1・3です。 ＞With Worksheets("Sheet2").Range("B2:B5000") ＞⇒ここのデータのある最終行までとする場合どうすればよいのでしょうか。 今回の数式に関しては参照先の範囲指定が必要になります。 Sheet1の最終行が判らないので、列全体を対象としても良いのですが、 それでは計算速度がかなり落ちてしまうため、とりあえずSheet1の20000行までの範囲としてみました。 （ワークシート関数の数式をそのまま使用する場合、セル番地が必要になりますので・・・） ※　Sheet1のデータは20000行まであってもなくても問題ありません。 Sub Sample4() Dim lastRow As Long With Worksheets("Sheet2") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row '//←Sheet2のA列最終行 With Range(.Cells(2, "B"), .Cells(lastRow, "B")) .Formula = "=IF(COUNTIFS(Sheet1!A$2:A$20000,A2,Sheet1!F$2:F$20000,""<>""),"""",""ひとつもない"")" .Value = .Value End With End With End Sub こんな感じではどうでしょうか？m(_ _)m
こんにちは。 #1の回答者です >エクセル起動→VBA起動→ 自動実行？（もし、自動実行だったら、それはとりあえずやめたほうがよいです） >c:\temp\251442.cvr >c:\temp\WERF123.tmp.hdmp ダンプして、その内容を読めればわかるらしいのですが、私は、やったことがありません。わかる人はわかるのでしょうけれども、いろいろツールも必要なようです。 >コードを取り出す作業の手前でエラーが発生して動かなくなります。 いずれにしても、取り出せないわけですよね。VBAのコードで、セルやオブジェクトを、コードの中で表記していませんか？いわゆるアンタッチャブルなところを触って、フリーズすることが多いですね。 私は、コードを取り出せない時は、一応、キャプチャーで画像を取ることがありますが、あまり役にたったことはありません。 ただ、私が調べる方法としては、Excelをセーフモードで立ち上げて、マクロを、ほとんど最初から、ステップモードで動かしてみます。これでダメなら諦めたほうがよいかもしれません。 p.s. 私は、VBAを実行しながら、ブレークポイントやStopを置いて修正しています。（^^;　でも、そういうコーディングは、尋常とは言えませんね。HTMLの場合ですが、未だ、ソースを読むレベルには至っていません。だから、[1．オブジェクトの中身に何が返っているか分からない。2.オブジェクトの型自体が分からない。]これらは、実行中でしか分からないからです。
＆、＄を型宣言文字といいます。 ＆は長整数型(Long)を示します。 $は文字列型(String)を示します。 つまり Dim R& と Dim R as Long は同じ意味です。 同様に Dim Path& と Dim Path as String は同じ意味になります。 ほかにも、%（整数型）、@（短精度浮動小数点）、＃（倍精度浮動小数点）などがあります。 しかしながら、このような表記（Dim R&のような表記）は、第三者にわかりにくいだけでなく、 自分でも何年か後に、あとで見たときに、判りにくくなるため推奨いたしません。 きちんとDim R as Longと記述することにより、その変数の型を明示したほうが、 プログラムがわかりやすくなり、バグが発生しにくくなります。
こんばんは。 If f.Attributes < 1024 Then　'特別なフォルダは除外 これだけで済むかは不明 '// Option Explicit Private myRange As Range Private FSO As Object Private Const DST As String = "C:\X\" '末尾には￥を入れる Sub FindAndCopy1() 　Const mPath = "C:\Z\"　 '末尾には￥を入れる 　Set myRange = Range("A2", Cells(Rows.Count, 1).End(xlUp))　'A列 　Set FSO = CreateObject("Scripting.FileSystemObject") 　FileSearchN mPath 　Set FSO = Nothing End Sub Sub FileSearchN(Path As String) 　　Dim buf As Variant 　　Dim f As Object 　　Dim ret As Variant 　　buf = Dir(Path & "\*.pdf") 　'拡張子 　　Do While buf <> "" 　　　　ret = Application.Match(buf, myRange, 0) 　　　　If IsNumeric(ret) Then 　　　　 If Not FSO.FileExists(DST & buf) Then 　　　　　 FSO.CopyFile Path & "\" & buf, DST 　　　　 End If 　　　　End If 　　　　buf = Dir() 　　　　DoEvents 　　Loop 　　With FSO 　　　　For Each f In .GetFolder(Path).SubFolders 　　　　　　If f.Attributes < 1024 Then　'特別なフォルダは除外 　　　　　　　Call FileSearchN(f.Path) 　　　　　　End If 　　　　　　DoEvents 　　　　Next f 　　End With End Sub
XMLHTTP を使います https://support.microsoft.com/ja-jp/kb/290591/ja
No1です。何度もすみません。修正です。 誤 c.resize(1,3) 正 c.offset(0,1).resize(1,3)
最終的に、データがどう並べばいいんですかね？そこが質問から読み取れないので… 例えば1行の始まりを必ず時刻にして、1行には時刻は一つしか存在しないようにしたいとか、もう少しやりたい事というか目指す形を具体的に示してもらえると、答える方はイメージしやすくなります。 闇雲に改行するだけでは、データがより扱いづらくなるだけのような予感がすることと、おそらくマクロを動員しなければ実現できないだろうなとは思いました。 これは全くの思い付きですが、一見無秩序に見えるけど、実は37個とかの半端な個数で区切ったら綺麗に並ぶとか、必ず特定データでレコードが終了するみたいな規則性はないですか？
私もコントロールを参照すれば・・・と思いますが、こんな風？ イミディエイトウィンドウに出力。 Private Sub コマンド21_Click() Dim rs As DAO.Recordset Dim i As Integer Set rs = Me.Recordset For i = 0 To rs.Fields.Count - 1 Debug.Print i, rs.Fields(i).Name, rs.Fields(i).Value Next Set rs = Nothing End Sub
前回回答したものです。今回のコードをもう少しわかりやすくしてみました。 Sub sample() Workbooks.Open Filename:= _ "\\192.168.30.11\nas1\00917397\デスクトップ\新しいフォルダー\課\医事課.xlsx" ThisWorkbook.ActiveSheet.Rnage("D4:N4”).Value=ActiveWorkbook.ActiveSheet.Range("T5:AD5").Value ActiveWorkbook.Close SaveChanges:=False End Sub ThisWorkBookは、このマクロを実行しているブックです。 ActiveWorkbookは、今開いていているブック（Workbooks.Openで実行した）です。 もう少し、わかりやすくししていますね。 Sub sample() Mypath＝"\\192.168.30.11\nas1\00917397\デスクトップ\新しいフォルダー\課” MyFile＝ "医事課.xlsx" ToCell＝”D4:N4” Workbooks.Open Filename:= Mypath & "\" & Myfile ThisWorkbook.ActiveSheet.Rnage(ToCell).Value=Range("T5:AD5").Value ActiveWorkbook.Close SaveChanges:=False End Sub とも書けます。 ファイルへのパスとファイル名を一旦、MypathとMyfileと云う変数に入れておきます。 張り付ける先のアドレスをTocellと云う変数に入れておきます。 上記のコードを繰り返す事になりますが、その際に、MyFileとToCellが変わるようにしましょう。 といっても、その内容を別のシートに準備する事になります。 仮に　シート名を　情報　として 　　A　　　　　B １　事務課　　D4:N4 ２　総務課　　D5:N5 ３　看護１A　D6:N6 ・・・・ これを、MyFileとToCellの変数に入るようにします。 Sub sample() Mypath＝"\\192.168.30.11\nas1\00917397\デスクトップ\新しいフォルダー\課” For i=2 To 11'2行目から411行目までデータがあるとして MyFile＝ Sheets("情報").Rnage("A" & i).Value ToCell＝ Sheets("情報").Rnage("B" & i).Value Workbooks.Open Filename:= Mypath & "\" & Myfile ThisWorkbook.ActiveSheet.Rnage(ToCell).Value=Range("T5:AD5").Value ActiveWorkbook.Close SaveChanges:=False Next End Sub こんな感じで、ご理解できるでしょうか。
こんばんは！ 一例です。 Sheet1のデータをSheet2に表示するとします。 尚、1行目は項目行で、データは2行目以降にあるとします。 標準モジュールです。 Sub Sample1() Dim i As Long, wS As Worksheet Set wS = Worksheets("Sheet1") With Worksheets("Sheet2") .Cells.ClearContents wS.Range("A1").Resize(, 4).Copy .Range("A1") For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row With .Cells(Rows.Count, "A").End(xlUp).Offset(1).Resize(wS.Cells(i, "D")) .Value = wS.Cells(i, "A") .Offset(, 1) = wS.Cells(i, "B") .Offset(, 2) = wS.Cells(i, "C") .Offset(, 3) = wS.Cells(i, "D") End With Next i End With End Sub ※　Sheet2のC列表示形式は日付にしておいてください。m(_ _)m
本当に、今日は複数のファイルからのデータの移動の質問多いですね。 私だったら 集計ファイルのBシートに、コピー元の情報一覧を作ります 　A　　　　　　　　　B　　　　　　C ファイルのパス　　ファイル名　コピー先 C:￥TEMP　　　　　看護1A　　　D4：N4 C:￥TEMP　　　　　看護2A　　　D5：N5 ・・・・ C:￥TEMP　　　　　看護9A　　　D12：N12 For i=2 to 11 Workbooks.Open Sheets("B").Range("A" & i).Value & "\" & Sheets("B").Range("B" & i).Value ThisWorkbook.Worksheets("A").Range(Thisworkbook.Sheets("B").range("C" & i).Value ).Value= Range("T5:AD5").Value ActiveWorkbook.Close SaveChanges:=False Next こんな感じで 2行目で指定したファイルを開く 2行目で指定した場所にT5:AD5の値を入れる ファイルを閉じる の繰り返し 検証はしていませんのでエラーが出たら修正しながら使ってください。
とりあえず、逃げ案ですが ＞ユーザーフォーム開きながらセルの操作ができないので ユーザーフォームを開くときに Userform1.Show vbmodeless と最後に　vbmodeless　を付けてみてください。 ユーザーフォームが開いた状態で、シートの操作が出来ます。 しかし、この方法は、パソコンに疎い方にとって便利かどうかが？です。 ちなみに、初めての方なのか、既に登録がある方なのかの判断は？ 基本的な業務の流れですが。 新規の顧客の場合 名簿に登録（関数ではなく、きちんと顧客管理の名簿を作る） ＊来場者のデータから顧客リストを作るのでなく 来客時に、IDで確認して、日々の来場者登録を行う。 エクセルで入力する際には、名簿のデータを活用する。 この作業の流れになるようにしましょう。
まずは 別のシートに、３０個のファイル名を準備しましょう。 　Ａ ファイル名 ・・・・ 次に、マクロの記録を開始して、一つのファイルに対して作業を 記録してみましょう。 そこで出来たマクロを提示して頂ければ 後は、準備したファイル名を使って30回、同じコードを走らせる 様に編集するだけで出来るでしょう。
＞じゃあマイクロソフトは.NETに関してどうやって金を稼いでるんだ？？ Expressは無料です。 とりあえず、使わせて普及を図る。 しかし、Expressでは機能が不足しており、もっと便利にしたいと思う。 上位バージョンを購入するしかなくなる。 ＭＳに限らず、その他のフリーソフトなども同様ですね どの様なものか使ってみなければ分からないのがソフト（アプリケーション） 基本機能版をフリーで使わせて、納得した上で有料版を購入させます。
> そのようなことは可能でしょうか それなりの処理を記述すれば可能です。 Ａ列には拡張子を含むファイル名が入っていると仮定します。 （ . の数は問わない） 以下は１つのファイル名を求めるだけのものです。 同じ処理を何回実行しても、同じファイル名にはならないと思います。 （求めたファイル名で随時ファイルを作成していたらの話ですけど･･･） 　　Z = "D:\Hogehoge\" 　　sA = Cells(2, "A").Value 　　i = InStrRev(sA, ".") 　　sC = Mid(sA, i) 　　sA = Z & Left(sA, i - 1) 　　sB = "" 　　i = 1 　　While (Dir(sA & sB & sC) <> "") 　　　　sB = "-" & i 　　　　i = i + 1 　　Wend 　　sA = sA & sB & sC ※ > 同じ名前のものでも処理が異なる のなら、 >　　sA = Z & Left(sA, i - 1) 部分で処理パターンを示すものを付加しても良いかも 　　sA = Z & Left(sA, i - 1) & "_処理A" とか 　　sA = Z & "処理A_" & Left(sA, i - 1) とかとか
言葉にするのが難しいですが msg = "" 'カウント For i = 1 To 9 For j = 1 To 9 の場合 msg = ""　がＦｏｒのループの外側にありますよね。 初期化が、最初の一回だけですので 繰り返しの文だけ、増えていきます。 'カウント For i = 1 To 9 msg = "" For j = 1 To 9 場合 msg = ""　がＦｏｒ　i　のループの内側にありますよね。 なので、iのループの度に msg = ""　が実行されるので、初期化される事になります。
こんにちは。 >ActiveSheet.Unprotect >Selection.Range(Cells(1, 1), Cells(1, 8)).Delete Shift:=xlShiftUp（範囲指定） 画像の「合計」の行の上がっていくことになると思います。空白行を作りたくない目的で、行のDeleteをしているのでしょうか？ 私の作ったものと考え方がよく似ています。以下の行削除のマクロは、今から10年ぐらい前に作ったもので、未だ、現在まで使っています。ただ、削除する前に、その行をコピーして、バックアップシート・Worksheets("バックアップ")に削除した記録を取っています。一度も、その残骸にフィードバックしたことはありませんが。 同じ行に一致したものへの削除ですが、まず、削除する前に、配列での確保がよいのではないかと思います。そうしないと、出納帳で削除するのは、一番後になります。 ※日付値の検索は、微妙な所があります。こちらは、Excel2010で作成しております。 以下の「 LookIn:=xlFormulas」の部分は、こちらでは成功していますが、他のバージョンでは分かりません。 '//昔から使っていたものなので、A65536が出てきています。 Sub TestMarco() 　Dim Rng As Range 　Dim Ar As Variant 　Dim sh As Worksheet 　Worksheets("出納帳").Unprotect 　Set Rng = ActiveCell.EntireRow.Range(Cells(1), Cells(8)) 　Ar = Rng.Value 　If MsgBox(Rng.Cells(1).Value & vbCrLf & "を削除してよろしいですか？", 32 + vbOKCancel) = vbCancel Then Exit Sub 　Rng.Copy Worksheets("バックアップ").Range("A65536").End(xlUp).Offset(1) 　Rng.Delete Shift:=xlShiftUp 　For Each sh In Worksheets 　　If sh.Name <> "出納帳" And sh.Name <> "バックアップ" Then 　　　'もしかしたら、sh.Unprotect が必要かもしれません。 　　　Call FindAll(sh, Ar) 　　End If 　Next End Sub Sub FindAll(sh As Worksheet, baseArray As Variant) 　Dim srchVal As Variant 　Dim c As Range 　Dim i As Long 　Dim Arbuf As Variant 　srchVal = baseArray(1, 2) '日付値で探す 　With sh 　　Set c = sh.Cells.Find( _ 　　What:=srchVal, _ 　　LookIn:=xlFormulas, _ 　　LookAt:=xlWhole, _ 　　SearchOrder:=xlByColumns) 　　If c Is Nothing Then Exit Sub 　　Arbuf = c.EntireRow.Cells(1).Resize(, 8) 　　For i = 1 To UBound(baseArray, 2) 　　If Arbuf(1, i) <> baseArray(1, i) Then Exit For 　　Next i 　　If i > UBound(baseArray, 2) Then '完全一致 　　　c.EntireRow.Cells(1).Resize(1, 8).Delete Shift:=xlShiftUp 　　End If 　End With 　Set c = Nothing End Sub '///
#2の回答者です。 >Rw = Range("B2").CurrentRegion.Rows.Count + 1 >の+1の意味を教えて頂けないでしょうか？ まあ、特殊な条件を言い始めればキリはありません。一応、データが四角形で埋まっていれば、2行目からということですから、最終行は、行幅がひとつ足りませんから、＋1　を加えればよいという話です。 こうした話を広げると「たら・れば」になり、その「たら・れば」を言い始めれば、現実を通り越して、どれが正しいか分からなくなります。以下のサイトで、CurrentRegion では、どうやっても、以下のEndプロパティのようには、最終行は取れないことを再度確認したことはありますが、それも、「たら・れば」です。 いずれにしても、ただ、2^20行目（つまり最終行）に行ってしまうことだけ避けられればよいと思います。データの空白によるエラー処理だけすれば、それはそれで十分だと思います。 『VBAを使って、最終行と最終列を見つける5つの方法』 http://www.thespreadsheetguru.com/blog/2014/7/7/ … ここの話を、『英語カテゴリ』(2015/02/05 #8914221)で書いたことがあります。その表をサンプルして、試してみるのもよいでしょう。（もう2つぐらいありますが。） それはともかく、これは今回の質問の要点とは違うはずで、私の#2で書いていたB列の内容の部分が、気になる所なのですが……。
動作確認はしていませんが Sub ボタン1_Click() For i=3 To 5 If Range("D" & i).Value="" Or Range("E" & i).Value="" Then Else Sheets("B").PrintOut From:=Range("D" & i).Value, To:=Range("E" & i).Value, Preview:=True End If Next End Sub こんな感じのことでしょうか。
この質問は、質問者さんがフィードバックするわけでもないし、回答側がいろんな想像をしながら、回答しているわけで、これも、その一つなんでしょうけれどもね。 でも、#3でもかきましたが、Perl を使えとまでは言いませんが、テキストファイルなら、grep で十分なのですね。windows用のgrep というのもあります。しかし、kwic(key word in context)のコンコーダンスを作る目的なら、話は違ってきます。 '//Wscript で、argumentは、ドラッグして入れてください。 '// Dim Matches Dim Match Dim objFso Dim objTxIn Dim TxIn Dim Tx Dim fname Dim buf Set objFso = CreateObject("Scripting.FileSystemObject") If WScript.Arguments.length =0 Then WScript.Echo "ファイルをドラッグして、このファイル名にDropしてください。" WScript.Quit End If fname =WScript.Arguments.Item(0) If objFso.GetExtensionName(fname) = "txt" Then Set objTxIn = objFso.OpenTextFile(fname) Tx = objTxIn.ReadAll() Else WScript.Echo "拡張子がtxtではありません。" WScript.Quit End If With CreateObject("VBScript.RegExp") .Pattern = "\b([\d,]{4,6})\b" .Global = True Set Matches = .Execute(Tx) For Each Match In Matches buf = buf & " " & CheckFigures(Match.Value) Next End With If Trim(buf) <> "" Then WScript.Echo buf End If Function CheckFigures(byval num) Dim num2 If IsNumeric(num) Then num2 = CLng(num) If num2 >=1024 And num2 <=65535 Then CheckFigures =num Else CheckFigures ="" End If End If End Function '///
For i = 1 To 9 msg = "" For j = 1 To 9 kake = i * j kake = Str(kake) msg = msg & " " & kake Next j MsgBox msg Next i ダイアロゴボックスじゃなく、ダイアログボックスです。
こんにちは。 エクセル VBAだと思いますが、シートに出して、そこで関数やソートなどと組合せて操作したほうが早いと思います。 もし、コードで行うなら、フォルダの中身自体をソートするのかは分かりませんが、まず、以下のようにフォルダとファイルを分離することでしょうね。そして、フォルダに、ソートアルゴリズムを通せばよいです。ただ、ややこしいし、今のところ、一つ下のフォルダーしか調べていません。 '// Sub TestMacro1() 　Dim fso As Object 　Dim strPath As String 　Dim strFolder As Variant 　Dim i As Long, n As Long, j As Long, l As Long 　Dim a() 　Dim strFile As Variant 　Dim strPathExcel() As String 　Dim inFiles() As Variant 　Dim varFol As Variant 　Dim x As Long, y As Variant 　Dim ar2 As Variant 　'******ユーザー設定********** 　Const blnTXT As Boolean = False 'フォルダのテキスト比較 　strPath = "C:\Users\Temp\" 'ユーザーフォルダー 　'**************************** 　'Cells.Clear 'シート全体を消す 　i = 0 　Set fso = CreateObject("Scripting.fileSystemObject") 　For Each strFolder In fso.getfolder(strPath).subfolders 　　ReDim Preserve a(i) 　　a(i) = strFolder.Path 　　i = i + 1 　Next strFolder 　 　Call Bubble_Sort(a(), blnTXT) 'バブルソート 　 　ReDim inFiles(UBound(a()), 1) 　 　For Each varFol In a() 　　For Each strFile In fso.getfolder(varFol).Files 　　　If InStr(strFile.Type, "Excel") > 0 Then 　　　　ReDim Preserve strPathExcel(l) 　　　　strPathExcel(l) = Dir(strFile.Path) 　　　　l = l + 1 　　　End If 　　Next strFile 　　inFiles(n, 0) = varFol 　　inFiles(n, 1) = strPathExcel() 　　n = n + 1 　　l = 0 　　Erase strPathExcel 　Next varFol 　i = 1: j = 1 　For x = 0 To UBound(inFiles) 　　Cells(i, 1).Value = inFiles(x, 0) 　　　 　　　ar2 = inFiles(x, 1) 　　　On Error Resume Next 　　　y = Empty 　　　y = UBound(ar2) 　　　On Error GoTo 0 　　　If Not IsEmpty(y) Then 　　　Cells(j, 2).Resize(y + 1).Value = Application.Transpose(ar2) 　　　j = i + UBound(ar2) + 1 + 1 　　　i = j 　　　End If 　Next x End Sub Sub Bubble_Sort(ByRef a(), Optional txt As Boolean = False) 'txt オプションは、text 比較の意味 　Dim u As Long 　Dim i As Long 　Dim j As Long 　Dim t As Variant 　Dim m As Variant, n As Variant 　u = UBound(a()) 　i = LBound(a()) 　Do While i < u 　　j = u 　　Do While j > i 　　 If txt Then 　　　m = Dir(a(j), vbDirectory) 　　　n = Dir(a(i), vbDirectory) 　　　Else 　　　m = Val(Dir(a(j), vbDirectory)) 　　　n = Val(Dir(a(i), vbDirectory)) 　　　End If 　　　If m < n Then　'判定　<昇順 　　　　t = a(i) 　　　　a(i) = a(j) 　　　　a(j) = t 　　　End If 　　　j = j - 1 　　Loop 　　i = i + 1 　Loop End Sub
＃６です。補足コメント拝見しました。 InputBox()関数は、文字列型 (String) の値を返します。 例えば何も入力しないで[OK/キャンセル/閉じる]確定した場合は、 ""＝[長さ０の文字列]です。 Val()関数は、数値として読めない値について、 数値 0 を返します。 　MsgBox Val("") 　MsgBox Val("abc") このふたつの例では、どちらも、数値 0 が返ります。 問題は、 　MsgBox Val("0") 本当の意味で"0"を入力した場合と、 上のふたつの文字列値だった場合との 区別を付けるには、 「いきなりInputBoxの戻り値をValで変換するのでは」 無理、ということです。 次に、 文字列値を返すInputBox()関数の戻り値を受ける変数は、 本来は、関数に合わせて文字列型 (String)です。 「InputBox の戻り値の格納はVariant型がお奨めです。」というのは、 第一に●文字列値を格納することが出来る 次に　●格納済の文字列値を数値型に変換して格納し直すことができる。 という理由からです。 （前スレの２番目のマクロでは、 　もう一点●戻り値のデータ型を判別に使える 　という利点も活用しています） > Variantはなんでも放り込んでいい関数だと認識です。 厳密には"なんでも"ではないのですが、さておき、 様々なデータ型を格納できる、ということは確かです。 ただ、漫然と何でもかんでもVariant型、という使い方は避けるべき、 というより、様々なデータ型を理解した上でVariant型を使うように、 教則本などでは初級での教え方として「Variant型を使うな」という やり方もあるのです。 Variant型を使った方が好い場面というのは、上記●で示した３点を理由に Variant型の本質的なメリットを発揮できる場合、です。 何故、InputBox()関数の戻り値を受ける変数が数値型でない方が良いのか、 については、 入力された文字列が、数値として読める文字列値であれば、 ＶＢＡが勝手にデータ型を型変換（キャスト）してくれて 無事に格納されるのですが、 Dim sugaku As Integer '数学の点 sugaku = InputBox("数学の点数を入れなさい") のように書いた時、 何も入力しないで[OK/キャンセル/閉じる]確定した場合、""＝[長さ０の文字列] その他の文字列を入力した場合、例えば、"abc" これらの数値として読めない文字列値ではキャストが働きませんから、 　　実行時エラー '13' : 　　型が一致しません。 というエラーに帰結します。 エラートラップを掛ければ、解決できますが、それよりはまだ、 Variant型を使う方が扱い易いのではないでしょうか。 InputBox()関数の戻り値をVariant型で受けた場合は、 IsNumeric()関数で、「数値として読めるかどうか」を判別することができます。 （この部分↑だけなら、String型でも良いのです） "0"なら、「数値として読める」 ""や"abc"なら、「数値として読めない」 という風に篩に掛けることができます。 > ＞If IsNumeric(sugaku) = False Then > 　　　　MsgBox "数値が入力されなかったのでキャンセル" > 　　　　Exit Sub > 　　End If > このExit Sub は、もうここでプログラムは終了します。の意味なのでしょうか。 はい、""や"abc"なら、数値として読めないから、 Exit Sub して（プロシージャを抜けて）、 Sub cmdsktuisi2_Click の処理を終了します。 > ＞ IsNumeric(kokugo) > IsNUmeric関数は、値が何も入ってないとき、０に返さず、Falseを返すことになる > のでしょうね。 はい。まさにその通りです。 余談ですが、 前スレで紹介した、Excelの InputBox メソッド（Variant型）の場合は、 入力するべきデータ型を予め指定しておくことが出来るので、 コード側で面倒な判別をする必要がありません。 数値を入力するように指定してあるとして、 　未入力では確定[OK]できません。 　[キャンセル/閉じる]の場合は、論理値のFalseを返します。 　それ以外の場合は必ず数値、です。 慣れてきたら、数値入力などにはInputBox()関数より扱い易いので、 いずれ余裕が出てきた頃にでも試してみると役に立つと思います。 補足への返信、以上です。
Visibleはその場で表示されなくなるだけで、表示内容に合せて自動で再配置されたりはしません。 お望みにことをしようとする場合、次のような方法が考えられます。 (1) 自動で再配置される仕組みを使う 　Dockで配置 　FlowLayoutPanelに配置　等 (2) 手動で変更 　順番にVisibleを調べて、最初にTrueだったものを最初のTopに、次にTrueだったものを次のTopに... (3) 下から順番にVisible=Falseにして、内容を書き換える 　2番目を消すなら、3番目のテキストを2番目に→4番目のテキストを3番目に→... 最後のTextBoxをVisible=Falseに 　消した内容を覚えておく必要があるなら、記録用の変数を用意する > それぞれのテキストをTopで位置を指定してます。（Topで細かく指定したい） なら(2)か(3)になります。 この「細かい指定」が「等間隔に整列」するためのものだったら、(1)を使いMargin等で調整が一番楽だと思います。
Webサービス自体は， ・System.Net.Httpを参照設定してSystem.Net.Http.HttpClientを使う (主に.NET 4.5〜) ・System.Net.WebRequestとSystem.Net.WebResponseを使う (.NET 1.0～) ・WCFで色々頑張る (できるらしいですが，やったことがないです) といった方法で，アクセスすることが出来ます。 # WCF以外は「HTTP/HTTPSでのアクセス方法」になります。 また，JSONなので，データの処理自体も一工夫必要になります。 ・JSON.NETをインストールして使う (NuGet利用可能) ・.csprojに手を加えてWindows.Data.Jsonを参照設定して使う ・DataContractJsonSerializerを使う (.NET 3.5～) といった方法を使うのが楽だと思います。
＃３補足コメントへの返信です。 > ダイアログボックスに全角数字を入れると全部「０です」ともどってきてしまいます。 全部？２例めのInputBox メソッドでは、そうはならない筈ですけれど。 InputBox メソッドをお奨めする理由は InputBox()関数は一見トッツキはいいけれど、 そういった諸々の、手間数が多くなるってこともあってなのですけれどね、、、。 全部、ではなくて、InputBox()関数については、ですね。 話をInputBox()関数に限ってお話します。 > 全角数字を数字と認識させない方法ありますか？ ＶＢＡにはそのような機能は特には用意されていません。 強いてやるなら、 StrConv()関数で文字列を半角に変換したものと、元々の文字列を 比較して同じであるかどうか判別することなら出来ますが、、、。 寧ろ、全角数字を数字として認識させる方を選ぶ場合が多いと思うので、 その方法を挙げておきます。 １） 関数を重ねることを嫌う向きも多いでしょうが、正確さを求めるなら 以下のように、文字列を一旦半角にしてからVal関数。 ' ' /// Private Sub cmdatai_Click()　'　InputBox()関数 Dim n As Variant '（セルに）代入された値　（の受け皿となる変数） 　　 ' ' 入力用インプットボックスを表示 　　 n = InputBox("整数を入れてください") 　　If IsNumeric(n) Then 　　　　n = Val(StrConv(n, vbNarrow)) 　　　　If n = 0 Then 　　　　　　MsgBox "０です" 　　　　ElseIf n Mod 2 = 1 Then 　　　　　　MsgBox "奇数です" 　　　　Else 　　　　　　MsgBox "偶数です" 　　　　End If 　　Else 　　　　MsgBox "整数を入力してください" 　　End If End Sub ' ' /// ２） 「数字を半角で入力するように」ということを実践出来ない相手に、 「必ず整数を入力せよ」と徹底できるとは思えませんが、 整数が入力されるなら、以下のように型変換関数を使った 強引なやり方もあります。 ' ' /// Private Sub cmdatai_Click()　'　InputBox()関数 Dim n As Variant '（セルに）代入された値　（の受け皿となる変数） 　　 ' ' 入力用インプットボックスを表示 　　 n = InputBox("整数を入れてください") 　　If IsNumeric(n) Then 　　　　n = CInt(n) 　　　　If n = 0 Then 　　　　　　MsgBox "０です" 　　　　ElseIf n Mod 2 = 1 Then 　　　　　　MsgBox "奇数です" 　　　　Else 　　　　　　MsgBox "偶数です" 　　　　End If 　　Else 　　　　MsgBox "整数を入力してください" 　　End If End Sub ' ' /// 一応、注意点として、 CInt()関数は、小数点以下を、偶数丸めで返します。 　　msgbox cint("59.5") 　　msgbox cint("60.5") どちらも、60 になってしまうので、整数に丸めるにしても 四捨五入でないことは、この例でお解りかと思います。 テストの点数ということですと、私の経験上、 問題作成者の配点ミスによって急きょ0.5点単位の採点になったことが幾度かありました。 そうでなくても、誤った入力なら誤った入力であることがハッキリするように、 整数かどうかのチェックをした方が無難だと思って＃３では２例めを掲げています。 「整数かどうかのチェック」はしないけど「全角数字入力には反応する」というのは、 私の感覚では釣り合いが取れていない印象は受けます。 そういう意味で、InputBox メソッドが使えるExcel環境で、 敢えてInputBox()関数を好んで選ぶ（多数派ですが）場合は、 性善なる入力に期待している、という意味合いが強いことだけは知っておいてください。 ＃３補足コメントへの返信は、以上です。
VBAが趣味ならもうちょっと頑張ってみればいいだけですが お仕事のようですから、手作業でさっさとやってしまったほうがいいでしょう。 １時間に１００ファイル処理すれば何時間かで終わります。 １日に１時間ほどやれば３日で３００ファイル終わります。 ＜方法＞ ファイルを１０個ほど開いておき、以下を１０回分繰り返します　 ファイル⇒　オプション　⇒　詳細設定　 　→　解像度（１５０、96 などを選択）　→　項目確認　→　上書き保存
No.1・3です。 ＞エクセルを閉じると消えてしまいます。良い方法があれば再度アドバイスお願いします というコトですが、質問に ＞普段はuserformが表示されていて とありますので、あるSheetをアクティブにすると自動でユーザーフォームが表示されるようになっているものだと思っていました。 操作するSheetにコマンドボタンを配置し、 ↓のようにユーザーフォームをご自身で表示させる方法はどうでしょうか？ Private Sub CommandButton1_Click() UserForm1.Show End Sub ※　UserForm1　はユーザーフォームの実際のオブジェクト名にしてください。m(_ _)m
例えば i=123 と書けば、123という数値です。 内部では、123を二進数にして保存します s="123" と書けば、123という文字列です。 内部では、"1" を表す数値、"2"を表す数値、"3"を表す数値、という形で保存されています。 ここで MsgBox s としても、123 と表示され、" " は付きません。 というように、プログラムで書いてあるものが、そのままの形で記録されるわけではありません。 Date型の # # は、それをDate型として扱うための仕組みです。文字列を " " で囲うのと同じ考えです。 Const a = 5/3/2015 と書いてしまうと、 5÷3÷2015 と解釈されて、日付にはなりません。 また、 "#5/3/2015#"や"5/3/2015"という文字列を保存しているわけではなく、その日付を表わす数値として記録しています(日付シリアル値) > '比較 > result = a <= dt1 日付と文字列は、型が違うので、本来は比較できません。 そこで(前回あった)暗黙の型変換が試されます。 詳しい資料が見付からなかったので、現象からの予想ですが result = a <= CDate(dt1) としているのでしょう。 CDateは、「日付として判断できる文字列」をDateに変換します。 ここで「日付として判断できる文字列」というのは 2015/3/5 2015年3月5日 5-May-2015 等の「VBA側で決まっている書式」に従ったものだけで、その中に #〜# は入っていない、ということです。 暗黙の型変換は便利なのですが、気をつけないと、自分の意思と違う変換になってしまいます。
#2です。コメント有難うございます。 すみません、先ほどの回答で、ひとつ訂正します。 ＞Offset で、1行0列ずれた範囲、つまり、A列を抜き、 ここですが、「つまり、1行目を抜き」　が正しいです。失礼しました m(_ _)m
値の型を変換することを「型変換」「キャスト」と言います。 型変換には、方法を明示するもの(CStrを使って文字列に変換、等)と、自動で行われる「暗黙の型変換」とがあります 暗黙の型変換の例 Dim i As Integer Dim d As Double i=10 d=i '暗黙の型変換: Integer→Doubleの変換が自動で行われる ' d=CDbl(i) ' (明示的な)型変換: 上記の暗黙の変換と同等 > VBAは勝手に文字列として認識してくれます。 というのは、この暗黙の型変換が行なわれるためです。 > 一般的にはどうなのでしょうか？ 暗黙の型変換にもルールが決まっていて、変換元、変換先によって、変換が行なわれないものもあります。 このルールは、言語やその実行環境毎に決まっています。 VBAでのルールはJavaでは使えません。
#1の回答者です。 この先のお話は、Excelカテゴリに移します。 Excelカテゴリには、最近、同じような回答を私自身がしてきた経緯があります。 ただし、こちらで出ていた質問内容は、そのまま活かさせていただきます。 よろしくお願いします。
>いくつフィルタボタンを作成し押しても重ね掛けできるようなコード のためには、それなりの労力・理解が必要です。 リンクの紹介だけですが、 http://www.f3.dion.ne.jp/~element/msaccess/AcTip …
No.4です。 ＞同じなのでSheet2 の方の()内は不要でした。 というコトですのでもう少し簡単に出来ます。 ↓のコードにしてみてください。 Sub Sample2() Dim i As Long, j As Long, wS As Worksheet Set wS = Worksheets(2) With Worksheets(1) For i = .Cells(Rows.Count, "C").End(xlUp).Row To 2 Step -1 For j = 18 To 2 Step -1 If j > 2 Then If .Cells(i, "C") = wS.Cells(j, "D") Then If .Cells(i - 1, "C") <> wS.Cells(j - 1, "D") Then .Rows(i).Insert .Cells(i, "C") = wS.Cells(j - 1, "D") i = i + 1 End If End If Else If .Cells(i + 1, "C") = wS.Range("D3") And .Cells(i, "C") <> wS.Range("D2") Then .Rows(i).Insert .Cells(i, "C") = wS.Range("D2") i = i + 1 End If End If Next j Next i End With End Sub ※　前回のコードでも大丈夫だと思いますが、 これでも同じ動きになると思います。m(_ _)m
確認事項１ ＞①Ａ列を最初にみて、文字列の　”０”　ｏｒ　”02”　を判断します ＞②Ａ列が2であれば、となりのセルＢ列をみます ＞　Ａ列が1であれば上に次に進む 上記の①と②は、つじつまが合いません。 ①Ａ列を最初にみて、文字列の　”１”　ｏｒ　”2”　を判断します と解釈します。 確認事項２ ＞⑤ Ｄ列の重量は按分させ、最後の部分でＲＯＵＮＤダウンさせたいです。　 重量８を4個で按分すると、２，２，２，２で問題ないですが、 重量６を4個で按分すると、２，２，２，０でしょうか？　・・・A案 それとも 重量６を4個で按分すると、２，２，１，１でしょうか？　・・・B案 とりあえず、B案と解釈します。 前回、tom04さんが回答されたソースに手を加えました。 -------------------------------------------------------------- Sub Sample1() Dim i As Long, cnt As Long, wS As Worksheet Dim amari As Long Dim sho As Long Dim juuryo As Long Set wS = Worksheets("Sheet1") With Worksheets("Sheet2") .Range("A:D").ClearContents wS.Range("A1:D1").Copy .Range("A1") For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row cnt = 0 If wS.Cells(i, "A") = 2 Then amari = wS.Cells(i, "D") Mod wS.Cells(i, "B") sho = wS.Cells(i, "D") \ wS.Cells(i, "B") Do Until cnt = wS.Cells(i, "B") cnt = cnt + 1 With .Cells(Rows.Count, "A").End(xlUp).Offset(1) .Value = wS.Cells(i, "A") .Offset(, 1) = 1 .Offset(, 2) = wS.Cells(i, "C") juuryo = sho If amari > 0 Then juuryo = juuryo + 1 amari = amari - 1 End If .Offset(, 3) = juuryo End With Loop Else .Cells(Rows.Count, "A").End(xlUp).Offset(1).Resize(, 4).Value = wS.Cells(i, "A").Resize(, 4).Value End If Next i .Activate MsgBox "処理完了" End With End Sub --------------------------------------------------------------
補足に回答します。 A13:A25は縦に並んでますが、Resize(, 13)はセル範囲を横方向に伸ばすプロパティです。最初は動いていた方が不思議です。セル範囲をコピーし、行列を入れ替えてペーストします。 WS2.Range("A13:A25").Copy WS1.Cells(.Row, "E").PasteSpecial Paste:=xlPasteValues, Transpose:=True WS2.Range("E13:E25").Copy WS1.Cells(.Row, "R").PasteSpecial Paste:=xlPasteValues, Transpose:=True WS2.Range("F13:F25").Copy WS1.Cells(.Row, "AE").PasteSpecial Paste:=xlPasteValues, Transpose:=True Application.CutCopyMode = False この場合、コピー先は先頭の１セルだけ書けば全部コピーされます。xlPaseValuesは「値のみ」、Transposeは「行列入れ替え」を意味します。ここを調べれば好みのペースト方法を選択出来るでしょう。 別な方法もあります。 For i=13 to 25 WS1.Cells(.Row, i-8).Value=WS2.Cells(i, "A").Value WS1.Cells(.Row, i+5).Value=WS2.Cells(i, "E").Value WS1.Cells(.Row, i+18).Value=WS2.Cells(i, "F").Value Next i 以下は既に済んでる事かもしれませんが、、、 私もあなたと同様、本来業務の効率アップのためにマクロを勉強しました。本業のプログラマではありません。片手間プログラマはマクロ作成に時間を割けません。作成時間を手作業に充てて終わるならマクロ不要だからです。上記の内容もResizeで動かないなら、 WS1.Cells(.Row, "E").Value = WS2.Range("A13").Value WS1.Cells(.Row, "F").Value = WS2.Range("A14").Value WS1.Cells(.Row, "G").Value = WS2.Range("A15").Value ・・・ と13×3=36行全部並べてさっさと終えるならその方が良いのです。ウマイ方法を考えるのはその後です。数学で言うところの別解です。ネットでは「同じ操作は２度繰り返さない」とかよく読みますが、それは本職のプログラマの話です。我々片手間プログラマは、まず動くモノを仕上げることです。改善はその後です。
＃１です。追加補足です。 眠りに付こうとした時に、最近他所の質問掲示板でご指摘を受けた、 私がよく忘れるメソッドのことを思い出して、試してみたら、 誤差のバラつきについては比較的簡単に改善されました。 要は、Excelに備わっている演算誤差補正機能を活用すれば 簡単に精度を高められるみたいです。 　　="2015/02/24 16:23:16"+"0:0:0.300"*i という数式をExcelに計算させる、というものです。 この方法だと、0.3秒を指す数値が、 3.47222E-06 3.47223E-06 という２種類の数値に絞れましたから、 これ以上の精度はExcelには無理なのかな？と思っています。 誤差がなくなることはないので、、、。 上記のExcel数式をExcelに問い合わせて計算させたのが、 以下のマクロです。 こんな訳の解らないマクロを使うこともないかも知れませんが、 ＶＢＡでまともにやるよりはExcelに計算させる方が より簡単に精度を高められた、という、参考情報です。 この件に限らず、時刻（特に日付＋時刻）の扱いは、 Excelに任せた方が安定的なのかも知れませんね。 > Forループを使って、0.3秒ずつ増やしていくようなことがしたいのですが > ミリ秒の扱い方がどうしても分かりません。 というご質問からすれば、予想外の話になっているかも知れませんが、 もし、お求めの答が見つけられないようでしたら、補足してみて下さい。 ' ' /// Sub Re8954373ExStr2Dbl() Const ミリ秒間隔 = 300　'　←0.3秒の場合 Dim aaa(256) As Double Dim bbb(256) As String Dim dtBasTime As Date Dim sInterval As String Dim sBasTime As String Dim sFml As String Dim i As Long 　　dtBasTime = DateSerial(2015, 2, 24) + TimeSerial(16, 23, 16) 　　sBasTime = """" & Format(dtBasTime, "yyyy/mm/dd hh:mm:ss") & """" 　　sInterval = """0:0:0." & ミリ秒間隔 & """" 　　sFml = sBasTime & "+" & sInterval & "*" 　　With Application 　　　　For i = 0 To 256 　　　　　　aaa(i) = .Evaluate(sFml & i) 　　　　　　bbb(i) = .Text(aaa(i), "yyyy_mmdd_hhmm_ss.000") 　　　　Next i 　　End With ' ' 以下、確認用。A1:B257に結果を返します。 　　Cells(1).Resize(257).Value = Application.Transpose(aaa()) 　　Cells(1).Resize(257).NumberFormat = "yyyy_mmdd_hhmm_ss.000" 　　Cells(2).Resize(257).Value = Application.Transpose(bbb()) End Sub ' ' ///
こんにちは。 この質問って、簡単ではないような気がしますね。 >プログラムで作成した新規シート、これに予めボタンなどが自動的に配置されている状態にできないか？ どういう手順内容か、書かれていないので、一番、むつかしいことも考えてしまいますね。 ボタンをつける話などは、それに比べたら、大したことはないのですが、新規のシートにボタンが配置さ、マクロを起動させるものとなると、さて、どうするかなっていう所なのです。 これを考えると、ボタンがどうということだけでなくなってしまいます。それで真っ先に思い浮かぶのは、予めテンプレートを作っておいて、それを実体化させる方法なのです。 アドインとか言い始めたら、キリがありませんしね。 VBAコードをVBAで書く方法もないわけではなのですが、それは、できるだけ避けたいのです。 こういうことを使って配置しても、ボタンのコードのほうをどうするか、っていうことです。 '// 'フォームボタン Sub TestAddButtn1() 　Dim x1 As Double, x2 As Double, y1 As Double, y2 As Double 　With ActiveSheet.Range("A1") 　　x1 = .Left 　　y1 = .Top 　　x2 = .Offset(, 2).Left 　　y2 = .Offset(2).Top 　End With 　With ActiveSheet.Buttons.Add(x1, y1, x2 - x1, y2 - y1) 　　.Text = "Frmボタン" 　End With End Sub 'OLE(ActiveX )ボタン Sub TestAddButtn2() 　Dim cmdBtn As OLEObject 　Dim x1 As Double, x2 As Double, y1 As Double, y2 As Double 　With ActiveSheet.Range("C1") 　　x1 = .Left 　　y1 = .Top 　　x2 = .Offset(, 2).Left 　　y2 = .Offset(2).Top 　End With 　Set cmdBtn = ActiveSheet.OLEObjects.Add(ClassType:="Forms.CommandButton.1") 　With cmdBtn 　　.Left = x1 　　.Top = y1 　　.Width = x2 - x1 　　.Height = y2 - y1 　　.Object.Caption = "Oleポタン" 　End With End Sub
こんばんは。 なるべく、分かりやすく、そして元のコードの雰囲気を残したつもりです。 元のコードは、もう少しテクニックが足りなかったところだったように思います。 '// Private Sub bd_year_DropButtonClick() 　Dim op As OLEObject 　Dim gName As String　'元号 　Dim Ar() As Variant　'配列用変数 　Dim i As Long, j As Long, k As Long, v As Long 　ReDim cmbYear(2, 2) 　cmbYear(0, 0) = "showa": cmbYear(0, 1) = 1: cmbYear(0, 2) = 64 　cmbYear(1, 0) = "heisei": cmbYear(1, 1) = 1: cmbYear(1, 2) = 30 　cmbYear(2, 0) = "seireki": cmbYear(2, 1) = 1925: cmbYear(2, 2) = 2020 　 　For Each op In Me.OLEObjects 　　If TypeName(op.Object) = "OptionButton" Then 　　　If op.Object.Value = True Then 　　　　gName = op.Name 　　　Exit For 　　　End If 　　End If 　Next 　i = Switch(gName = "showa", 0, gName = "heisei", 1, gName = "seireki", 2) 　 　j = cmbYear(i, 2) - cmbYear(i, 1) 　ReDim Ar(0 To j) 　k = 0 　For v = cmbYear(i, 1) To cmbYear(i, 2) 　 Ar(k) = v　　'配列を使う 　 k = k + 1 　Next v 　Me.bd_year.List = Ar()　'そのまま配列を入れる 　 End Sub
こんにちは。 以下、ＶＢＡのヘルプより引用です。 ｜Str 関数 ｜バリアント型 (内部処理形式 String の Variant) の値を返します。数式の値を文字列で表した値 (数字) で返す文字列処理関数です。 ｜構文 ｜Str(number) ｜引数 number には有効な数式を長整数型 (Long) で指定します。この引数は必ず指定します。 ｜解説 ｜数値を文字列に変換すると、戻り値の先頭に符号を表示するためのスペースが常に確保されます。数値が正の場合は、Str 関数の戻り値の先頭にスペースが挿入されます。このスペースはプラス記号を意味します。 ｜日付、時刻、通貨、ユーザー定義の書式などで数値を書式設定するときに、Format 関数を使います。Str 関数と異なり、Format 関数を使用して変換した場合は、引数 number の先頭にスペースは挿入されません。 ｜メモ Str 関数は、ピリオド (.) だけを有効な小数点記号として認識します。異なる小数点記号を使用する場合は、CStr 関数を使って数値を文字列に変換します。 引用ここまで。 > 戻り値の先頭に符号を表示するためのスペース が入ります。 Str(123) は、■ 123■ Str(-123) は、■-123■ という風に桁が揃うという特徴を活かしたい時や、 スペース区切りで正の数値を列挙させたい時などは、 Str()関数の特長を活かして使うことができます。 基本的に、引数も戻り値もVariant型です。 似て非なるものに、データ型変換関数としての CStr関数があります。 こちらは、戻り値がString型で、先頭にスペースは入りません。 数値（または数字文字列）を引数に数字文字列を返す点は共通です。 Empty値＝空の値をVariant型で引数にした場合の戻り値が Str関数とCStr関数とでは異なります。 例えば、セルＡ１が空白セルである時、 　　MsgBox Str(Cells(1, "A")) は、0 　　MsgBox CStr(Cells(1, "A")) は、長さ０の文字列 を返します。 Str関数、CStr関数、それぞれの特徴、違いを理解した上で、 目的や用途に合わせて使い分けてください。
はい、そういう理解で良いと思います。 重複するProcessID が同時に存在することは無いので これを手がかりに調べることになります。
>①　このプログラムのどこがおかしいのでしょうか？ Sub Test() Dim i As Integer Dim s1 As String 　　For i = 1 To 9 　　　s1 = Cells(i, 1).Value 　　　Cells(i, 2).Value = Left(s1, InStr(s1, "／") - 1) '「Len(s1) - 」が不要 　　Next i End Sub >②　次に、B列を新たに作らずに、A列に編集したデータを出したいのですが >　　どうすれば良いのでしょうか？ そのコーディングをそのまま使うなら Sub Test2() Dim i As Integer Dim s1 As String 　　For i = 1 To 9 　　　s1 = Cells(i, 1).Value 　　　Cells(i, 1).Value = Left(s1, InStr(s1, "／") - 1) 　　Next i End Sub
こんにちは。 例えば、 まずセルＡ１のコメントテキストを取得して、 改行（Lf）区切りでSplit関数に掛けて配列にしてから、 行を指定して、各行の文字列を取得するやり方。 Sub test() Dim sCmnt, arrS 　　sCmnt = Range("A1").NoteText 　　arrS = Split(sCmnt, vbLf) 　　MsgBox arrS(0)　'　１行め 　　MsgBox arrS(1)　'　２行め 　　MsgBox arrS(2)　'　３行め 　　MsgBox arrS(3)　'　４行め End Sub 例えば、バッサリ省略して、１行で 　　MsgBox Split(Range("A1").NoteText, vbLf)(1)　'　２行め のように書けなくもないです。
#2の回答者です。 回答の意味が違ったのでしょうか？ >年と月と日が変数として >与えられている場合にはどうしたら良いですか？ 私は、# ～# のような日付リテラル値というのは、なるべく使わないようにしています。 これは、ひとつのVB系の書法とかいうものですね。だから、DateValueも同じなのです。 年, 月, 日が与えられていれば、DateSerial(年, 月, 日)ですね。 決められた所に、決められたものを入れるほうが確かだと思います。 DateValue とか、Windowsのローカル設定に依存したはずですね。 まあ、日本とアメリカの場合は、年の部分だけですから、切り替わりますが。 ご質問の場合は、 （例：2015年2月24日16:23:16） 　　　dTimeStamp = DateSerial(2015, 2, 24) + _ 　　　TimeSerial(16, 23, 16)
こんばんは！ 元データには手を付けず、別Sheetに表示ではダメですか？ 元データがSheet1にあり、Sheet2に表示させる一例です。 尚、Sheet1のA列は「1」か「2」のどちらかだという前提です。 ↓のコードを標準モジュールにコピー＆ペーストしてマクロを実行してみてください。 Sub Sample1() Dim i As Long, cnt As Long, wS As Worksheet Set wS = Worksheets("Sheet1") With Worksheets("Sheet2") .Range("A:C").ClearContents wS.Range("A1:C1").Copy .Range("A1") For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row cnt = 0 If wS.Cells(i, "A") = 2 Then Do Until cnt = wS.Cells(i, "B") cnt = cnt + 1 With .Cells(Rows.Count, "A").End(xlUp).Offset(1) .Value = wS.Cells(i, "A") .Offset(, 1) = 1 .Offset(, 2) = wS.Cells(i, "C") End With Loop Else .Cells(Rows.Count, "A").End(xlUp).Offset(1).Resize(, 3).Value = wS.Cells(i, "A").Resize(, 3).Value End If Next i .Activate MsgBox "処理完了" End With End Sub こんなんではどうでしょうか？m(_ _)m
RichTextBoxは使えますか?
こんばんは！ SUMPRODUCT関数は配列数式ですので、列全体を参照範囲としてしまうと PCにとってはかなりの負担になります。 お使いのバージョンが不明なのですが、Excel2007以降のバージョンですと COUNTIFS関数が使用できます。 すなわちI10セルに =COUNTIFS($F:$F,I9,$G:$G,$H10) という数式を入れフィルハンドルでAC10セルまでコピー！ これで大丈夫だと思います。 どうしてもVBAでやりたい場合は Sub Sample1() With Range("I10:AC10") .Formula = "=COUNTIFS($F:$F,I9,$G:$G,$H10)" .Value = .Value End With End Sub くらいで大丈夫だと思います。 いかにもVBAらしくやれば Sub Sample2() Dim j As Long For j = 9 To 29 '//Ｉ列～AC列まで Cells(10, j) = WorksheetFunction.CountIfs(Range("F:F"), Cells(9, j), Range("G:G"), Range("H10")) Next j End Sub といった感じでですかね。m(_ _)m
どちらのリンク先もほとんど同じ内容です。 どちらでも32bit版Excelで機能しますが、異なるのは 43行目： ' ハンドルを閉じる。 44行目： Call CloseHandle(hdl) MSのではきちんと処理をしていない点です。 待機させるだけでしたらWSH でも十分かと思います。 Sub Test1() 'メモ帳を起動 With CreateObject("Wscript.Shell") .Run "C:\windows\system32\notepad.exe", 1, True 'ユーザーが手動でメモ帳を閉じるまで待機 End With MsgBox ("メモ帳が終了しました。") End Sub Sub Test2() 'コマンドプロンプトの終了待機、Ping は実処理の代役 With CreateObject("Wscript.Shell") .Run "%ComSpec% /c " & "ping 127.0.0.1 -n 10", 1, True End With MsgBox ("コマンドプロンプトが終了しました。") End Sub
印刷処理は大雑把ですが 印刷命令 ↓ 印刷用データ作成・プリンター用スプール領域に保存 ↓ プリンターはこのスプールを印刷します。 なので 印刷命令 ↓直後に "P"の削除 とすると、印刷されるべきデータの欠如や何らかのエラー発生が 考えたのですが・・・。 で、検証してみたところ・・・ Windows7 Access2010の場合では DoCmd.OpenReport ・・・・は同期的のようです。 OpenReportの処理が終了しないと次の行には進まない。 なので、 DoCmd.OpenReport stDocName, acViewNormal,・・・ Currentdb.Execute("更新クエリ名") で大丈夫と考えられます。 念のため、 標準モジュールの宣言部に 'ミリセカンドで停止します Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) とし、 Private Sub 印刷_Click() Me.Refresh Dim stDocName As String stDocName = "管理票" If Me.製品規格サブ.Form.FilterOn Then DoCmd.OpenReport stDocName, acViewNormal, , Me.製品規格サブ.Form.Filter & "AND 印刷='P'" Else DoCmd.OpenReport stDocName, acViewNormal End If Sleep 500 ’0.5秒の待機 currentdb.execute("更新クエリ名") Me.Refresh End Sub ですかね。 currentdb.execute("更新クエリ名") は直接SQL文でも。 currentdb.Execute("UPDATE そちらのテーブル名 SET 印刷=Null")
文字列表示書式を VB.NETのFormat関数はサポートしていないので Format(i,"##,0").PadLeft(3) といった具合に直してあげましょう
質問文では、Case 2 画像では、Case2 になってませんか？（半角スペースの有無） 休憩して気分転換が必要かも。
あまり詳しくはないので…； 画像表示・パスについて、こちらのページは参考になりませんでしょうか？ http://www.fk-plaza.jp/acs/TIPS/waza55.htm
方法が判ってしまうと、（期待する結果でなくて）非常に残念な話ですが、 インデントの部分を全角の空白でうめています。複数の連続した半角の空白の場合は、このサイト処理で１つの半角空白に変換されますが、全角の空白はそのままです。従って、インデントがきちんと行われているように見えます。しかし、それはそのように見えるだけで、そのソースをコピーして、 自分のソースに貼り付けると、全角の空白がソースに入り込みますので、コンパイルエラー（若しくは実行エラー）になります。自分のソースに貼り付けた後は、全角空白を半角の空白に変換してから使ってください。
ScriptingFilesystem で試してみましたが どんぐりの背比べ・・のような結果。 NAS上の１フォルダ中に３２０個のファイルがあるところでやってみました。 コピーしていませんので約４秒。 Option Explicit Private Declare Function GetTickCount Lib "kernel32" () As Long Sub てすと1() Dim f As Object, fDate As Date Dim FSO As FileSystemObject Dim Path1 As String, Path2 As String Dim fileName As String Dim 日付1指定 As Date, 日付2指定 As Date Dim tK As Long, i As Long tK = GetTickCount Set FSO = New FileSystemObject Path1 = "m:\" '元ファイルのフォルダパス Path2 = "" 'ダウンロード先のフォルダパス fileName = "A" 'コピーしたいファイル名 日付1指定 = #1/1/2010# 日付2指定 = #1/1/2015# For Each f In FSO.GetFolder(Path1).Files fDate = f.DateLastModified If fDate > 日付1指定 And fDate < 日付2指定 Then If f.Name Like "*" & fileName & "*" Then i = i + 1 'FSO.CopyFile f.Path, Path2, True End If End If Next f Set FSO = Nothing Debug.Print i, GetTickCount - tK End Sub FSO.CopyFile ではなく、VBA の FileCopy メソッドだとどうかな？ 目くそ鼻くそかもしれません。。。
VBAというよりExcel内でショートカットキーが動いている感じですね。 参照URL：http://www.tipsfound.com/Excel2013/01408.vbhtml Ctrl + F2 キーを押すと、ファイルタブの [印刷] タブの印刷プレビュー領域を表示します。 間にShift押しても反応してないようです。 Shift + F2 キーを押すと、セルのコメントを追加または編集します。
#4の回答者です。 あくまでも、#4で書いたのは、現在の個人的意見で、結論的なことを言うつもりはありません。 >将来的にVBAやVBで使えなくなる可能性があるので >Midを使った方が良い。 ずっと前に、VB.Net やC#に移行するという話があって、移行しやすいようにと考えて、いわゆる「忖度（そんたく）」して方針を合わせたつもりだったのですが、ここ数年、そういう事自体があやふやになってきたように思います。 >ただ、Midの仕様は時代遅れなものであり、(Variant型出力） これは確かですが、 >本来はMid$が生き残るべきである。　　　(String型出力） もう、これは、VB.Net では決まっていることですから、私たちがとやかく言っても始まりませんね。 論理的には、文字列を扱うのだから、出力自体は、String型でもよいのではないかとは思います。VB6系からVB.Net を後継とするべきではないかもしれませんが、VB.Netでの、同様の関数は、文字列（String型）の出力です。 私は、最初のリンク先のT's ware の内容は、速い・遅いだけの話には違いないのですが、人によっては、短絡的に「速い方がよい」という括りで価値観を決めてしまうことになりかねないと思います。 最近の話ですが、コンマ何秒の速さだけを求めることには、私は疑問に感ずることが多いです。そんなことを書いたら、相手の人は、1万回以上もループしているのだから当たり前だ、といわんばかりでした。そんな話は少しも聞いていないよ、というところですが、そういう場合は、コードは速いほうに越したことはない……、それはごもっともです。 しかし、そんな必要もない人、言い換えれば、そのような負担がない状況下では、その内部的な仕様がどうであれ、記述自体は、ノーマルなMid関数のままでもよいのでは、と考えるのです。こういう考え方を書くと、曖昧さがあるから、苛立つ人もいます。私は、どっちにしろとは、他人に対しても、自分に対しても使い分けろなんていうつもりはありません。ただ、$付き、$なし、どちらを書いても、そんなに困るものではないと思うのです。 本当の意味での、私たちの将来などは分からないけれど、今を最高のチューンしたものに仕上げると、返って、動きの取れないものになることも多いような気がします。
こんにちは。 表題通りのことをしたいのでしたら、それは、 シート上に配置したActiveX コントロールのテキストボックスを 使うのが普通のやり方のように思います。 一般的には「自らのファイル名」の保存ということ自体は 放っておいてもブックの属性として必然的に残るのですから、 コントロールに保存するというのは普通は必要のないことです。 ユーザーフォームは、 ブックが開いている間のユーザーフォームを読み込んでいる間だけ インスタンス（実体）を持っているというものですから、 ブックを上書き保存したとしても現在のユーザーフォームの状態を 保存できる訳ではありませんし、保存されるのは、 実行前（表示する前）のユーザーフォームの設計図だけです。 従って、同様のことを実現させるには、 ●ユーザーフォームのテキストボックスに対して 　プロパティページから初期値として「自らのファイル名」を設定しておく または、 ●標準モジジュールに /// Private Sub Auto_Open() 　　Userform1.TextBox1.Value = ThisWorkbook.Name 　　Userform1.Show ' vbModeless End Sub /// 　のように書いておき、ブックを開いた時に表示させる、 等の方法が考えられます。
No1です。 こんな感じになります。 http://www.max.hi-ho.ne.jp/happy/YNxv9g005.html
Access VBA リストボックス でGoogleと http://www.tsware.jp/tips/tips_009.htm や、もっと詳しく http://www.geocities.jp/cbc_vbnet/cnntrol/cbo.html など。
こんにちは。 前回のやりとりから読んでいました。失礼かもしれませんが、そんなに高度の話ではなさそうなのに、さっぱり、意図が分からずじまいで、そのやりとりの取っ掛かりさえ見当つきませんでした。私のマクロをみて、ローテクしかないと、揶揄する方もいるかもしれませんが、いくつかの疑問点を、もう少し状況を教えていただけませんか？だから、私などお話にならないとお思いでしたら、無視なさっても結構です。 なお、クリップボードに入れるワザとしては、この私でさえ、いくつか知っておりますが、ただ、どれもExcelにしろオブジェクトを使う作業過程で、オブジェクトの実体化の実質的な時間を加味すれば、[512*512]程度のファイルでは、よほどのことがない限りは、その差は大きくないはずです。1秒が1時間のように感じるなら別ですが。某氏が別の掲示板で、「（マクロの)実行は3秒、その開発は3日。」けだし名言です。 疑問点として ・バイナリデータとお書きになっていたけれど、 　「二次元配列データが入ったバイナリデータを読み込んで」 　まさか、バイナリファイルでもないでしょうし、バイナリデータを他に変換しているわけでもないはずです。その最初の取っ掛かりの部分が明らかになっていないように思います。こちらは、0から255までの数値の入った[512 * 512]のデータを想定しています。ここらが、最初のモヤモヤの発端です。 　 ・タブ区切りのファイルとして一時保存 　[512 * 512]のファイルを出力するなど、インポートも、エクスポートも、一瞬に近いはずです。それを入れ出しするというものなのでしょうか。CSVであろうが、TSVであろうが、あまり問題はないと思います。 　それに、インポート方法もいろいろあるはずです。[512 * 512]のデータのインポートなど、それほどに時間が掛かるはずもないし、テンポラリーファイルの何が問題なのかも不明です。加工があるというなら別ですが。 ・HDDに一時ファイルを生成せずに直接配列からクリップボードにコピーする方法 　仮に、テンポラリファイルであろうが、ファイル自体は存在しているし、クリップボードに格納する場合は、そのファイル自体を、クリップボードのとば口に持ってこなくてはいけなくてはいません。VBA等で、名指しでファイルに命令して、そんなに手間が掛かるとは思えません。 [オブジェクト生成](一部はの方法は、OS側が保持、しかし、命令手順が必要] 「クリップボード・オブジェクト」<- データ　[インポート] [物理的移動] [命令]-[ペーストのオブジェクトを確保] 「クリップボード・オブジェクト」->- データ　[エクスポート] このような手間を考えるなら、Excelへのインポートは、QueryTableひとつで十分だと思います。 Test1.txt　（TSVファイル）　サイズ 約1M 弱 出力はいうまでもありません。シートコピー・保存で十分です。（後に、多少の違いは見つかりました） 計測データ(timeGetTimeによる） Import: 488 /1000 sec　(以下　1000 secは省略） Emport: 456 二度目 EmportFile: 486 ImportFile: 540 '// Sub ImportFile() Dim Fname As String Dim objQT As QueryTable Fname = "TEXT;" & ThisWorkbook.Path & "\Test1.txt" 　Set objQT = ActiveSheet.QueryTables.Add(Fname, Range("A1")) 　　 With objQT 　　 .Name = "Test1" 　　 .TextFilePlatform = xlWindows　'2 　　 .TextFileColumnDataTypes = Array(1) 　　 .Refresh BackgroundQuery:=False 　　End With 　　objQT.Delete End Sub '// Sub ExportFile() '※ 　Dim myPath As String 　 myPath = ThisWorkbook.Path & "\" 　　ActiveSheet.Copy 　　With ActiveWorkbook 　　　.SaveAs myPath & "Test2.Txt", xlText 　　　.Close False 　　 End With End Sub '// ※再計算(Calculate）の他、Event についても注意が必要。割り込みさせられないようにする） 以下のような事は不要だと思います。 しかし、時間を計測すると、QueryTableの10分の1ぐらい速いけれど、これを判別するのは神の領域ではないでしょうか。 ClipBoardTest1: 62 '// Sub ClipBoardTest1() 'VBEditor 画面は必ず閉じてください。 　Dim Filename As String 　Dim buf 'Stringにはしないこと 　Filename = ThisWorkbook.Path & "\" & "Test1.txt" 　Set obj = CreateObject("HTMLfile") 　With CreateObject("Scripting.FileSystemObject").OpenTextFile(Filename) 　　buf = .ReadAll 　　.Close 　End With 　obj.parentWindow.clipboardData.SetData "text", buf 　 Range("A1").Select 　Application.SendKeys "^v" End Sub
ちゃんとした署名を使えば，自身をSigner.VerifyFileの対象にすることで，署名を確認できます。 コードサイニング証明書をちゃんと取得しようとすると結構な値段がしますが……。 MSDN: セキュリティと Windows Script Host https://msdn.microsoft.com/ja-jp/library/cc39252 … MSDN: VerifyFile メソッド https://msdn.microsoft.com/ja-jp/library/cc36439 … それ以外の方法であるならば，問題ないように構造を作るしかありません。 メールで使われるPGP/MIMEなどでは，text/plainであるテキストの末尾に署名を埋め込む方法を用意していますが，vbsでその方法は使えません。 なので，NTFSの代替ストリームに署名情報を入れる，などの方法をとる必要があるかと思います。 ただ，根本的にテキストである以上，改竄チェックも含めて改竄されると対抗策はないですが……。
For Each a In Selection.Areas ' a の為の配列を用意 For Each c In a.Rows ' c を配列に追加 Next Next
jisseki_copyの終了時のアクティブシート「週刊印刷」のまま、keikaku_copyを開始してるために起こるトラブルだと思います。keikaku_copyがご自身の意図通りに動いてないのでしょう。jisseki_copy開始時のシートと、keikaku_copy開始時のシートは本来は同一と思っていいのでしょうか？それならば以下のようにすれば解決する筈です。 Sub jisseki_keikaku_copy() Dim strdate As Date strdate = Cells(246, 2) 'Application.ScreenUpdating = False Range("b245:AI339").Copy Sheets("ｆｌｇ_data").Range("c1731").PasteSpecial _ Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False Sheets("ｆｌｇ_data").Cells(1730, 3) = strdate strdate = Cells(371, 2) 'Application.ScreenUpdating = False Range("B370:AI464").Copy Sheets("ｆｌｇ_data").Range("C3731")..PasteSpecial _ Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False Sheets("ｆｌｇ_data").Cells(3730, 3) = strdate Sheets("週間印刷").Select Range("A1").Select End Sub ２個のプロシージャを１個にまとめたのは当然として、最大の変更点はアクティブシートを変更せずに動作させてることです。Sheets("ｆｌｇ_data").Selectが１個もありません。こうすれば、１個目のマクロ開始時のシートが何か知りませんが、シート変更せずに後半のkeikakuだった部分も処理するため、あなたの意図通りに処理される筈です。 途中で変数strdateを使ってCells(246,2)の値をシートflg_dataのCells(1730,3)へ代入してますね。 よく見ると、変数strdateは単にコピーの仲介役をしてるだけです。strdateを使わずに直接 Sheets("ｆｌｇ_data").Cells(3730, 3) = Cells(246,2) でも可能です。 さらに加えるなら、２個のマクロは動作が同じです。編集するセルが異なるだけです。サブルーチン化して１個にまとめられます。これは今はやめときますが。 マクロを組む際の重要事項として、セルの前にシート指定が無い場合は、常にアクティブシートつまり今表示されてるシートが選ばれます。今動作中のCells( )の動作はどのシートのCellsなのかを、常に意識しながら編集してください。そして、編集後の動作チェックは１行ずつステップ動作で確認して下さい。VBEを起動しチェックしたいマクロにカーソルを置き、F8キーで１行ずつ動作可能です。チェックのためにApplication.ScreenUpdatingはコメントアウトしました。この一文はマクロ完成後につけるべきです。
配列順番は合わせる必要があります。 実質的に１から始まる配列を使いたい場合、モジュール最初のプロシージャの上に option base 1 を加えます。こうすると、配列の添え字の初期値が０でなく１になります。 逆順 同一サイズの配列Bを用意し For i=1 to 512 B(i)=A(513-i) next i
こんにちは。 > ThisWorkbook.Worksheets("Sheet1").Cells(5, 2) ＶＢＡから辿っていくと、 Excel.Application クラスの application.ThisWorkbook プロパティで取得された Workbook オブジェクトとしてのThisWorkbook ... ということになりますが、 要するにこれは【Excel】のオブジェクトです。 ユーザーフォームは【Excel】のオブジェクトではありません。 いうなれば【ＶＢＡ】側のオブジェクトです。 強いて書くとすれば（普通はこんなことしませんし必要ないです）、 　　VBAProject.UserForm1 のように、 このスクリプトが書かれたVBProject オブジェクト配下にある UserForm1 オブジェクトというような書き方はできます。 でも、自身のVBProjectに書いているのですから、 ワザワザ親オブジェクトを書いて指定する必要はありません。 というより、もし書いてあったら読んだ人は驚くと思います。 ただし、この場合のVBAProjectというのは、 クラスやプロパティではなく、変更可能なオブジェクト名です。 UserForm1 も同様にオブジェクト名です。 そういう意味では、 Excel.Application.ThisWorkbookという参照の仕方とは全く異なります。 よく誤解があるので書き添えますが、 VBProject のThisWorkbook モジュールというのも、 UserForm 等と同様、変更可能なオブジェクト名です。 どちらも正確には、（オブジェクト名というよりも） クラス名をユーザーが変更出来る、ということです。 Excel.Application.ThisWorkbookについては ThisWorkbookを含めてどのクラスも絶対的な名前なので 変更することはできません。
繰り返しになりますが >その１２ファイル目をエクスプローラでプロパティを見た時に >撮影日時は確認できますか？ 詳細タブの撮影日時が空白の場合はどうしようもありません。 取得に失敗した場合を考えてのサンプルです。 Sub てすと() Dim i As Long Dim strFiles() As String Dim strDate() As String Dim tmpFile As String Dim trgDir As String trgDir = "e:\tmp\" 'ファイルの在り処 tmpFile = Dir(trgDir & "*.jpg", vbNormal) Do Until tmpFile = "" ReDim Preserve strFiles(i) ReDim Preserve strDate(i) strFiles(i) = trgDir & tmpFile strDate(i) = Left(FileInfo(trgDir & tmpFile), 10) If strDate(i) <> "" Then '撮影日時が取得できなかった場合 strDate(i) = Format(CDate(strDate(i)), "yyyy\年m\月d\日") Else strDate(i) = "不明" End If i = i + 1 tmpFile = Dir Loop For i = LBound(strFiles) To UBound(strFiles) '確認用 Debug.Print i, strFiles(i), strDate(i) Next End Sub Function FileInfo(ByVal trgFile As String) As String Dim oSH As Object Dim oFS As Object Dim oFLD As Object Dim oF As Object Dim i As Long Dim sTime As String Dim NsTime As String Set oSH = CreateObject("Shell.Application") Set oFS = CreateObject("Scripting.FileSystemObject") Set oF = oFS.getfile(trgFile) Set oFLD = oSH.Namespace(oF.ParentFolder.Path) '12 は撮影日時指定のマジックナンバー、WindowsXP だと25、他は未検証 sTime = oFLD.GetDetailsOf(oFLD.ParseName(oF.Name), 12) For i = 1 To Len(sTime) 'ごみ取りのためのループ If Mid(sTime, i, 1) Like "[0-9,/ :]" Then NsTime = NsTime & Mid(sTime, i, 1) End If Next FileInfo = NsTime 'MsgBox "撮影日時=" & NsTime 'コメントアウトしました Set oFLD = Nothing: Set oF = Nothing: Set oFS = Nothing: Set oSH = Nothing End Function ※ここのサイトは補足・お礼の文字数が400文字に制限されているので VBA のコードなどのやり取りには不向きですね。。。
いくつか方法は考えられます。 １．キー操作、マウス操作のマクロで、コピペ作業を行う 　　ウィンドウの位置、GoogleSheets側の応答差異の考慮が必要で、結構面倒くさい 　　またそういった特殊なマクロへの知識が必要です ２．キー操作、マウス操作のマクロで、GoogleSheetsをエクスポートする 　　１よりは楽。ただし、エクスポートしたファイルをExcelに反映させるなりする別のマクロが必要 　　これも１と同様に特殊なマクロへの知識が必要です ３．Excel側のマクロでGoogleSheetを読みこむ 　　同じファイルを更新し続けているならkeyが固定されてて楽。 　　VB(VBA)へのそこそこ深い知識が必要です ４．GoogleSheets側のマクロ(GoogleScript)で集計やグラフ表示させる 　　GoogleScriptの理解が必要で日本語のドキュメントはほとんどありませんが、一番簡単。 　　最後にExcel形式でエクスポートしちゃえば終わりです。 VBAを利用されているなら１と２は論外だと思いますが、質問内容に「excelシートに値をコピペして」とあるので、３も４も実現させるのは厳しいイメージがあります。 ですが、VBのカテゴリに投稿されているので参考になるURLだけ置いていきます。 ３．VBA側で直接インポートするサンプル http://ramblings.mcpher.com/Home/excelquirks/get … 　認証関係についても丁寧に記載されているので、理解ができればすぐ導入できるかと ４．GoogleScript側でマクロを作る https://developers.google.com/apps-script/refere … https://sites.google.com/site/scriptsexamples/le … 　リファレンスとグラフ化マクロのサンプルです。VBというよりJavaやC#ライクなVBA
こんばんは。 「題名：BVAの変数宣言について」の方も、しばらく前に読みました。 今回のCurrency型にしても、結果的には同じような範疇の事物を扱っているわけです。 これが本当のプログラミングの基礎なのですが、経験がないと分かりにくいです。 誰にでも始まりはあるし、分からないこともあります。しかし、それも VBAを習って半年ですとか、1年目とか言っていられるうちはよいのですが、 だんだん、それも通用しなくなります。 原則的には、プログラミングでは、「小数点の計算が入ると、正しい結果にならない」ことが多い。 ということです。 >Fix 関数は小数部を切り捨てて返すのに対して、 >Int 関数は小数部を切り下げて返します。 私は、「切り下げる」という表現は知りません。 英語では、「切り下げる」とは、devalue と言いますが、意味自体が違います。 また、「切り捨て」のことを、round-downと言います。 Int は、切り捨て関数(round-down function)です。 そして、Fix は、整数部分だけを残すということでしょうね。 つまり、小数点位置を固定(fix)しておいて、整数の部分だけを返す方法です。 それから、VBAのRound関数が、銀行型丸めになるので、それ自体は、一般の算術計算では使えないということですね。でも、四捨五入のコードはご存じですか。 = Int(数値+0.5) = Int(v * 10 ^ n + 0.5) / 10 ^ n 'v は値, n は桁　(英語では、値はvalue, 桁はnumber of digit ） 「[OFFXP]VBAのRound関数について 」 http://support.microsoft.com/ja-jp/kb/418216/ja 「Round関数で四捨五入できない？！」 http://www.relief.jp/itnote/archives/003535.php なぜ、ところどころに英語を書くかというと、ルールの一つ「プログラミングは英語を使う」ということです。変な決まりですよね。プログラミング全部とは言いませんが、フランス人はフランス語を使うし、ドイツ人はドイツ語を使っても、あまり困らないのですが、日本人というよりも、アジア人は英語を使わせられる、という感じがしてきます。VB/VBAを開発したのは、アメリカ人ではなく、東欧の人なのにもっと変な話です。
ピボットテーブルでご希望のシートが出来ると思いますが 試されましたでしょうか。 一度、ピボットテーブルの設定をしてしまえば 次からは、更新を実行するだけですが。
> しかし、考えてみますと「AddHandler btn(i).Click, AddressOf プロシージャ」の記述があるプロシージャにはどういけばよいのでしょうか。あくまでも、Clickイベントなんですよね。 > …Handles btn().Click　なんて動くはずもないし…。どうか宜しくお願いします。 というのが何を意味しているかわかりませんが。 Private Sub btn_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btn1.click,btn2.click,btn3.click …… End Sub と書くのは Private Sub btn_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) …… End Sub 'Load等の必ず実行される場所に AddHandler btn1.click, AddressOf btn_Click AddHandler btn2.click, AddressOf btn_Click AddHandler btn3.click, AddressOf btn_Click とほぼ同等のことです。
>400文字 ありがとね。 少ないですねー。 「未完成でも良いからコードを見せて」とお願いしても 音沙汰なしになる場合が多いのですが、このせいだったのかな…。 本家のOKナンチャラは4000文字まで大丈夫っぽいんですけどね…。 （使い方のスクリーンショットを見ただけなので違うかも） 細かく考えることは大事です。バグを未然に防いでくれます。 それでは。
適切な代案もありますが、質問内容のとおりExcelに置き換えた場合を以下に示します。 要するに、配列の中に配列をぶち込んでるのとほとんど一緒です。 ExcelにはDaysInMonthという便利な関数がありません、代わりに適当に月の日数を算出しています やっつけ日数換算箇所については無視してください。 ’ 置き換えた場合 Sub Main() Dim sales(11) As Variant Dim mon As Integer　' monthでは関数Monthと被る為変更 Dim days() As Double ' DaysInMonthという便利な関数が無いので、それ用 ' 計算の基準を現在の年の1月1日にする Dim BaseDate As Date BaseDate = Year(Now) & "/1/1" For mon = 0 To 11 　' やっつけ日数換算　＆　days配列の要素数初期化 　ReDim days(CInt(DateDiff("d", BaseDate, DateAdd("m", 1, BaseDate))) - 1) 　sales(mon) = days 　' 基準日付を1か月インクリメント 　BaseDate = DateAdd("m", 1, BaseDate) Next mon ' データやりとり例、4月1日に99.9を格納、表示する sales(3)(0) = 99.9 Call MsgBox(sales(3)(0)) End Sub VBAでは配列の中に配列を作ることができません。（上記はVariant型で無理やり実現させている） 本来であれば、クラスの配列なり構造体の配列なり、値の操作が面倒ですがDictionaryやCollection、とした方が何かと分かりやすいかと思います。 ※ただし、DictionaryとCollectionはIndexが1から始まるのでややこしい 　しかもCollectionだと値の変更が面倒くさい
こんばんは！ ＞10.5をセルに入力したときに10:30という風に変換？表示させたいのですが 別セル表示でも良いのでしょうか？ 仮にA2セル以降にデータを入力しB2セル以降に表示させる場合は B2セルに =TIME(INT(A2),MOD(A2,1)*60,0) という数式を入れフィルハンドルで下へコピーしてみてください。 ※　入力した時点でそのセルで処理したい！という場合はVBAになってしまいますが、 一例です。 A列にデータを入力するとします。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）A列にデータを入力してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) 'この行から Dim myTime If Intersect(Target, Range("A:A")) Is Nothing Or Target.Count > 1 Then Exit Sub With Target If .Value > 0 Then If .Value <= 24 Then '24時までと限定★ Application.EnableEvents = False myTime = .Value .Value = TimeSerial(Int(myTime), (myTime - Int(myTime)) * 60, 0) .NumberFormatLocal = "h:mm" Application.EnableEvents = True Else MsgBox "入力値が不正です。" .ClearContents .Select End If End If End With End Sub 'この行まで ※　入力値は「24」以下に限定しています。 こんなんではどうでしょうか？m(_ _)m
枠線といえばセルの枠線しか思い当たりません。 枠線という「図形」は見当たらないので 誰も回答できないのだと思います。 　マクロの記録で、その図形を手作業で編集したときの記録をとれば 必要なヒントはすべて得られるはずです。 　VBAでしたら、他人のコードを探し回るより VBEのプロジェクトエクスプローラで調べたりMSDNサイトでプロパティ一覧を入手するのが簡単です。
こんばんは。 前後の内容がわからないので何ともいえませんが、 自分がそのタイミングで落としてしまう時は大抵ループしてしまっている時です＾＾； msgbox　を使うとどのタイミングまで進んでいるかわかりますので ちょくちょくデバッグしながら進めるといいと思います。 上手くいかない場合はパスを完全に指定して保存を試してみてくださいｂ
RecordSetで開いたときに http://support.microsoft.com/kb/834927/ja 並び順が保証されるのか気になったので、ADODB ではありませんけども。 Sub Test01() 　　Dim sLine As String 　　Dim FF As Integer 　　Dim B As Boolean 　　Const CsvPath As String = "E:\Sample.CSV" 　　Dim i As Long 　　Dim t As Date 　　 　　t = Now 　　FF = FreeFile 　　'入力ファイルを開く 　　Open CsvPath For Input Access Read As FF 　　 　　'入力ファイルがEOFになるまでのループ 　　Do Until EOF(FF) 　　　　i = i + 1 '行番号確認用 　　　　Line Input #FF, sLine 'sLineに１行読み込み、行位置は自動的に次へ 　　　　If B Then 　　　　　　Debug.Print i, sLine　　'イミディエイトウィンドウへ出力 　　　　End If 　　　　If InStr(sLine, "ピンポン") > 0 Then　　 　　　　'ここは実データに合わせてLeft(sLine,4)="ピンポン" とか適当に 　　　　　　B = True 　　　　Else 　　　　　　B = False 　　　　End If 　　Loop 　　 　　Close 'ファイルをすべて閉じる 　　DoEvents　　'これを入れないと進まない場合があったので 　　MsgBox CDate(Now - t) End Sub ※複数行に渡って連続して、ピンポン（”え”） が出て来る場合は考えてません。 ※結果報告をヨロシクね。
No.1です。 テキストボックスにリストボックスのデータを複数羅列したい！ という解釈で・・・ やり方だけですが、↓の画像のような感じにしてみました。 余計なお世話かもしれませんが、コマンドボタンをクリックすると C1セルにテキストボックスのデータを表示　→　ユーザーフォームを消す としています。 ユーザーフォームの　ListBox1　のプロパティのRowSourceは　A1:A10　として A1～A10セルをリスト候補としています。 Private Sub ListBox1_Click() With UserForm1 If .TextBox1 = "" Then .TextBox1 = .ListBox1 Else .TextBox1 = .TextBox1 & " , " & .ListBox1 End If .TextBox1.SetFocus End With End Sub Private Sub CommandButton1_Click() Range("C1") = TextBox1 Unload Me End Sub ※　最初の質問からの流れからいうと テキストボックスも編集可能にした方が良いと思いましたので 上記のようなコードにしてみました。m(_ _)m
No.1です。 A列のセルは条件付き書式によって色付けされている訳ですね？ Excel的には条件付き書式で色付けされているセルは判断できません。 ただし、お使いのバージョンがExcel2010以降のバージョンであれば「DisplayFormatオブジェクト」が使え、 条件付き書式でも見た目の色が判断できるようになりました。 お使いのバージョンが2010または2013の場合は↓のコードでマクロを実行してみてください。 （今回もA列2行目から「条件付き書式」でセルの色が付いているとします） Sub Sample2() Dim i As Long, N As Long, R As Long, G As Long, B As Long i = 1 Do i = i + 1 If Cells(i, "A").DisplayFormat.Interior.ColorIndex = xlNone Then Exit Do N = Cells(i, "A").DisplayFormat.Interior.Color B = Int(N / 65536) G = Int((N - B * 65536) / 265) R = Int(N - B * 65536 - G * 265) With Cells(i, "B") .Value = R .Offset(, 1) = B .Offset(, 2) = G End With Loop End Sub ※　Excel2007までの場合は別案を考える必要があります。 例えば別セルに手作業で色付きセルの表を作っておき（←条件付き書式で設定した色の数だけ） あるセルの条件が○の場合は手作業で色を付けたセルを参照、 そのセル色で前回のようなコードを考えるとか・・・ 他に良い方法があればごめんなさいね。m(_ _)m
簡単な例 対象のワークシートに以下のマクロを記載 質問内容のレベルでは、”リスト”という事に拘る必要性はなさそうです。 ’ワークシートに変更があったら実行されるイベント Private Sub Worksheet_Change(ByVal Target As Range) ' 変更された数(セル数)が1個の時以外は処理しない If Target.Count <> 1 Then Exit Sub End If ' 変更されたセルが、C列かつ、1行目～10行目の場合 If Target.Column = 3 And Target.Row >= 1 And Target.Row <= 10 Then ’ そのセルの値が”削除”の場合 If Target.Value = "削除" Then ' 同じ行のA列のセルを値をクリア ActiveSheet.Cells(Target.Row, 1).ClearContents 'ActiveSheet.Cells(Target.Row, 1).ClearFormats ' 書式 'ActiveSheet.Cells(Target.Row, 1).Clear ' すべてクリア End If End If End Sub
No.1・2です。 ＞またセルではなく行を押すと実行できるようにしたいとおもっています。 を見逃していました。 「行を押すと」というコトは、「行のどこかを選択するとその行のA列をアクティブにしたい！」 という意味でしょうか？ そうであれば　SelectionChangeイベントで可能ですが、これはおススメできません。 （他のセルが全く編集できなくなるため） 「行のどこかをダブルクリックするとその行のA列を選択する」という意味だと シートモジュールを↓にしてみてください。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Cells(Target.Row, "A").Select Cancel = True UserForm1.Show End Sub ※　的外れならごめんなさいね。m(_ _)m
No1です。すみません、わかりますね。間違えてました。 　　　「この部分の条件式または処理方法がわかりません。」 　　　Worksheets("Sheet2").Cells(i,2).value=lp.offset(0,1).value 失礼しました。
＞このように改行に種類があるのはタイプライターからの名残だと思うのですが ＞なぜいまだにこのような種類分けが残っているのでしょうか？ タイプライターというか、ディスプレイが非常に高価で紙に印字する端末の時代ですね。 ディスプレイ端末への過渡期には、両方の端末が使えないといけないので、ディスプレイ端末でもCRが行頭、LFが行送りという機能をそのまま持ちました。 Unix/Linuxの端末機能には、LF、CR、TAB、BS、VT、FFについて端末にコード送出後、次の文字を送るまでに少し時間を待つような機能が盲腸のように備わってますので、テレタイプ型端末（紙送りや印字ヘッド移動に時間が掛かる）でも大丈夫です。他にもテレタイプ型端末のための機能があります。 参考： http://linuxjm.sourceforge.jp/html/GNU_sh-utils/ … ＞同じアプリの中でLFやCRを使い分けるようなことがあるのでしょうか？ 行区切りという意味では、統一でしょうね。 画面制御という観点では使い分けることはあります。下記参照。 ＞改行というと下の行の左端から入力をスタートすることを指しますが ＞本来の意味である、真下や同じ行の一番左端に移動させるような使い方・使い分けが可能なアプリも＞存在するということでしょうか？ 例えば、Cで、 for(i=0; i<100; i++){ printf("%d\r", i); sleep(1); } printf("\n"); というプログラムを実行すると、行頭に戻って数字が上書きされて表示されます。 進行状況を表すためによく使われます。
byte型は0～255の数値のみです。つまり負の数は駄目です。一方をInteger型にすれば良いので、 c = Cint(a)-b ですね。 c = a+0-b でもいいけど(Interger型である0と演算することで、結果がInteger型になる)。
Runメソッドであれば、 WSH.run "%ComSpec% /c " & sCmd & " & pause",,True Execメソッドだと、pauseに対してキーインするのが出来ないので、 Set wExec = WSH.Exec("%ComSpec% /c " & sCmd & " & calc") とでもして、電卓を閉じることで、コマンドプロンプトを閉じる。 ただ、Execの場合は、画面に何も出ませんけど。 出力は、wExec.StdOut に出るので。
またまたお邪魔します。 ＞、「(5)」は5行目でフィルタをかける、「.Cells（6」の6は対象データの最初の行番号、ということで合ってますか？ はい！今回の配置の場合は「6」が実データの最初の行（コピー＆ペーストしたい最初の行）ですので 5行目でオートフィルタの設定を行いました。 普通は「項目行」でフィルタを掛けると思います。 （一般的には項目行のすぐ下からデータを入れると思いますので・・・） 試しに、項目行の下を1行以上空白行を作り項目行でオートフィルタの設定を行ってみてください。 キーとなる検索データが全く表示されなくなると思います。 尚、フィルタを設定する行の上側に全くデータ（項目）がない場合はエラーメッセージが表示されるはずです。 すなわち、データがある行のすぐ上の行が項目行でなくても項目行と実データ間の行でオートフィルタの設定は可能ですが、 結論として実データのすぐ上の行でオートフィルタの設定をする必要がある！と思います。 ※　項目行と実データ間に空白行がない場合は実データのどこかのセルを選択した状態でオートフィルタの設定は可能ですが 項目行と実データ間に空白行があり、実データのどこかのセルを選択　→　オートフィルタの設定 としてしまうと、Excel的には実データの1行目を項目行としてしまうようです。 ※　空白行とはその行に全くデータが入っていない！という意味です。 （1セルでも項目行の下にデータがあり、他のセルが空白の場合は問題ありません） 長々と書きましたがこの程度でどうでしょうか？m(_ _)m
(1)コンピュータの計算は有限の桁しか使えないので、どうしても誤差が出ます。 (特に√やπのような無理数) (2)座標には整数型を使っているので、この時点で実数→整数の変換による誤差があります。 小数点以下を丸めるため、 |e|<1.0 の誤差があります。 例えば r1 = Math.Sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)　 'r1=AB 中のSqrtの中の計算は、整数同士の加減乗算だけなので(桁溢れになるほどの大きな値でなければ)正確です。 ですが、 Sqrtで計算した段階で、 真の√((x2 - x1) ^ 2 + (y2 - y1) ^ 2) とは違います。(1) これをIntegerの変数r1に代入するので、Single→Integerの型変換が行われます。このときに小数点以下が切り捨てられます(2) x3 = 500 + r1 * Math.Cos(rd) 同様にrdは誤差を含みます。60π/360 を正確に表わすことはできません。 角度の誤差とCos(rd)自体の丸め誤差とが加わります。 その誤差を含むcos(rd)に、誤差を含むr1を掛けています。 これをx3に入れるので、また小数点以下が切り捨てられます。 と、たったこれだけの計算でも、誤差の発生が沢山あります。 詳しい対策は、「浮動小数点数 誤差 対策」とでも検索してみてください。 ひとまず、簡単なものは ○Singleではなく、有効数字の大きい Double型を使う。 　現在のPCでの計算なら、Singleを使う意味はありません(メモリサイズ以外) 　座標のx1,y1等もDoubleにします。 ○内部の計算用と、画面座標とを分けて考える 　変数x1,y1をDoubleにしましたが、DrawLineでは整数です。 　このような場合は、DrawLineに指定するときだけCInt等を使って整数にします。 ○定数は、用意されているがあったら使う 　πとして3.14159を使っていますが、これを 3.141592 とするだけで、cos,sinの値も結構変ってきます。なので、できるだけ誤差の少ないπを使いたいものです。 https://msdn.microsoft.com/ja-jp/library/system. … そこで、Math.PIを使うと、Doubleで表現したときに最もPiに近い値が既に用意されています。
こんばんは。 >2013でプログラムを走らせると、エラーに成りそのコントロールを認識してくれません。 >2013では　シートにActiveXコントロールは　貼り付けられないようです。 これは、#1様が述べた通り、2014.12.9アップデートの影響下にあるのだと思います。 >(VBAから　シート.orderInput_btn2.value = True　などと） これは、オン・オフの数値が違うからだと思います。xlOn は、1 ですが、xlOff は、－4146だからです。 Sub TestMarcro1() 　If Worksheets("Sheet1").OptionButtons(1) = xlOn Then 　　 MsgBox "OptionButton は、ON", vbInformation 　Else 　　　　MsgBox "OptionButton は、OFF", vbExclamation 　End If End Sub
> vb6.0vbstudio2010版にはあったのです。必要無くなったということですか？ 確認したところ、Visual Studio 2005, 2010, 2012のすべてで、Windowsフォームアプリケーションの作成では、Imageコントロールは存在しません。 VB6の時代は、ImageとPictureBoxの用途が異なりましたよね？(画像のストレッチとか) .NETからは、そんな差異など関係なくPictureBoxで表現します。 必要な命令およびプロパティを必要に応じて変更すれば、VB6自体のImage、PictureBoxの両方を表現することができます。 WPFアプリケーションでは、逆にPictureBoxは存在せず、Imageが存在します。 https://msdn.microsoft.com/ja-jp/library/ms75055 … https://msdn.microsoft.com/ja-jp/library/system. …(v=vs.110).aspx > あなたの「クラスにはあるけれど」が理解できませんが私にとってはまだ、先の課題でしょう。 Windowsフォームアプリケーションにおいて、PictureBoxはコンポーネントクラスであって、Imageは通常のクラスです。 https://msdn.microsoft.com/ja-jp/library/system. … (Componentクラスを継承していませんので、コンポーネントではありません。) 画像ファイルなどを内部ロジックにおいて制御する際に利用します。 簡単な例だと、以下ページのように。 http://dobon.net/vb/dotnet/graphics/drawimage.html > それにしても、あの編集画面　わからないことが沢山あります。 残念ですが、慣れでしょう。 しかし、操作もショートカットキーも覚えてしまえば、VB6よりは絶対的に便利になっています。
こんにちは。 >エクセルVBAのユーザーフォームだけ表示して >エクセルシートを非表示にすることってできますか？ 可能です。 昔の富士通のテキストには、そういうスタイルを奨励していたようですが、97当時、極めてExcelを不安定にさせるようでした。理由は、UserFormからの、ワークブックの終了の仕方に問題があったような気がしています。Application.Quit で必ず終了するならよいのですが、97時代はそうではなかったからです。 最近は、残念ながら、この手の状況は知りませんが、終了の仕方が、再びイレギュラーになってしまったようです。しかし、97時代とは事情が違い、セキュリティ上で、急には終了しないのだと思います。それに、昔は、ワークブック自体が壊れる危険性もありましたが、今は、構造上、そういう問題自体が少なくなっているのではないかと思います。 >ユーザーフォームも同時に消えてしまい、 >再度マクロの実行を行う必要がありますが、 >自動的に復帰することは可能ですか？ ユーザーフォームが出るという意味でしたら、でません。手動で再度起動しなければなりません。
少し修正。 標準モジュールには Private Declare Function sndPlaySound Lib "winmm.dll" Alias "sndPlaySoundA" _ 　　(ByVal lpszSoundName As String, ByVal uFlags As Long) As Long 　　Private Const SND_SYNC = &H0 '同期的、演奏が終了するまで呼び出し元に制御は戻りません。 　　Private Const SND_ASYNC = &H1 '非同期的、すぐに制御が戻ります。 　　Private Const SND_NODEFAULT = &H2 '指定したファイルが無い場合でも、既定の音を鳴らしません。 　　Private Const SND_LOOP = &H8 'ずっと繰り返し演奏します。 　　Private Const SND_NOSTOP = &H10 '既に演奏中であれば何もしません。 Sub playSound(Optional soundFile As String = "c:\windows\media\chimes.wav") 　　Dim retVal As Long 　　retVal = sndPlaySound(soundFile, SND_ASYNC + SND_NODEFAULT) End Sub Sub stopSound() 　　Dim retVal As Long 　　retVal = sndPlaySound(vbNullString, SND_NODEFAULT) End Sub としておいて、 実際に呼び出す場合は Private Sub Worksheet_SelectionChange(ByVal Target As Range) 　　If Target.Address = "$A$1" Then 　　　　Call playSound("C:\Windows\Media\Windows Exclamation.wav") 　　End If End Sub などとしておけば良いかと。 Call playSound とだけ指定すればチャイムが鳴ります。 （当方、Windows7 64bit ＆ Excel2010 32bit）
こんにちは。 > ExcelのVBAで、チェックボックス(ActiveXコントロール)を使用し、各セル毎に設定する方法を教えてください。 「初心者」となると、 ActiveXコントロールの扱いはまともにやるとなると結構難しいです。 易しい方法もありますが手数が掛かります。 もしもフォームコントロールのチェックボックスでも良ければ、 （ActiveXコントロールに比べてデザイン性・機能性は落ちますが） かなり簡単に出来ます。 なので、 ◆易しいけど手数が掛かる◆ActiveXコントロールを使用する例◆初級向き◆ ◆簡単な◆フォームコントロールを使用する例◆初心者向き◆ ◆少し難しい◆ActiveXコントロール＋クラスを使用する例◆初中級向き◆ の３例挙げておきます。 どれを奨めるでもないので、自分に合ったやり方を見つけてみてください。 その前に、処理内容に関する共通したポイントについて。 まず、チェックボックスをセルに貼り付けるような手順等で 正しい位置（コントロールの左上がセルから食み出さない位置） に配置してあるならば、 チェックボックスを配したセルのひとつ右のセルへの参照として 　checkbox.TopLeftCell.Offset(, 1) ...のように 一様な多数のチェックボックスに共通した記述が可能になります。 つまりこれは、チェックボックス毎ひとつひとつに セル範囲を指定する必要はない、ということです。 次に、現在の日付を定数値で設定するだけなら VBAにはDate()関数があるので 　checkbox.TopLeftCell.Offset(, 1).Value = Date のような記述が可能です。 > Selection.Value = Selection.Value > TRUEであれば→selection.value、FALSEであれば元の関数に戻す、が行える方法 Trueであれば現在の日付を定数値で、FalseであればExcel関数"=TODAY()"、 チェックボックスが押されて値が変わったタイミングで チェックボックスが配されたセルのひとつ右のセルに対して処理をする。 という記述は、条件判別さえ出来れば、さほど難しいものではないです。 問題は、多数あるチェックボックスと 一様な（隣のセルを操作するだけの）処理とを どのように連動させるか、という点に集約されます。 ◆易しいけど手数が掛かる◆ActiveXコントロールを使用する例◆初級向き◆ 配置済みのActiveX.チェックボックスはそのままで。 チェックボックス毎にひとつずつプロシージャを書きます。 ◆以下、チェックボックスを配置したシートの[シートモジュール] ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Private Sub CheckBox1_Change() 　　関数値変換 CheckBox1 End Sub Private Sub CheckBox2_Change() 　　関数値変換 CheckBox2 End Sub Private Sub CheckBox3_Change() 　　関数値変換 CheckBox3 End Sub ' ' …　CheckBoxの名前２ヶ所違うだけの同じ記述の繰り返し　… Private Sub CheckBox99_Change() 　　関数値変換 CheckBox99 End Sub ' ' ---------------------------------------- Private Sub 関数値変換(oCx As MSForms.CheckBox) 　　With oCx 　　　　If .Value = True Then 　　　　　　.TopLeftCell.Offset(, 1).Value = Date 　　　　Else 　　　　　　.TopLeftCell.Offset(, 1).Formula = "=today()" 　　　　End If 　　End With End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ プロシージャをコピーして複製を必要な数作り チェックボックスの名前を慎重に正確に書換えていく 作業が必要です。◆◆ ◆簡単な◆フォームコントロールを使用する例◆初心者向き◆ 配置済みのActiveX.チェックボックスはすべて破棄します。 ◆まず、[標準モジュール]に以下の記述をコピペしてシート名を正しく指定します。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Sub CheckBoxes_Change() 　　With Sheets("Sheet1").Shapes(Application.Caller)　'　★シート名を正しく指定！！ 　　　　If .DrawingObject.Value = 1 Then 　　　　　　.TopLeftCell.Offset(, 1).Value = Date 　　　　Else 　　　　　　.TopLeftCell.Offset(, 1).Formula = "=today()" 　　　　End If 　　End With End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ◆次に、B1セルにフォームコントロールのチェックボックスを挿入し 右クリックで[マクロの登録] →表示されたリストから"CheckBoxes_Change"をクリックして選択 →[ＯＫ]ボタン 必要なら、位置やサイズの微調整やキャプションや書式の変更を加える。 出来上がったチェックボックスをコピーし B2、B3、、、と順番に ＜次のセルを選択（クリック）して→貼付け＞を繰り返して 必要な数のチェックボックスを配置する。これだけでＯＫです。◆◆ ◆少し難しい◆ActiveXコントロール＋クラスを使用する例◆初中級向き◆ 配置済みのActiveX.チェックボックスはそのままで。 ◆まず、[ThisWorkbookモジュール]に以下の記述をコピペしてシート名を正しく指定します。 次回からブックを開いた時に自動で（または直接手動で） Workbook_Open イベントプロシージャを実行することで チェックボックスと一様な（隣のセルを操作するだけの）処理とを 連動させるようにＶＢＡが設定してくれます。 （デザインモード移行やエラー終了の場合は 　再度、Workbook_Openを実行して復旧する必要があります） ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Private cClass As Collection ' ' ---------------------------------------- Private Sub Workbook_Open() Dim o As OLEObject 　　Set cClass = New Collection 　　For Each o In Sheets("Sheet1").OLEObjects　'　★シート名を正しく指定！！ 　　　　If TypeName(o.Object) = "CheckBox" Then 　　　　　　If o.TopLeftCell.Column = 2 Then　'　★チェックボックスの列位置を正しく指定！！ 　　　　　　　　cClass.Add New Class1, o.Name 　　　　　　　　Call cClass(o.Name).SetEv(o.Object) 　　　　　　End If 　　　　End If 　　Next End Sub Private Sub Workbook_BeforeClose(Cancel As Boolean) Dim i As Long 　　If cClass Is Nothing Then Exit Sub 　　For i = 1 To cClass.Count 　　　　Call cClass(1).CancelEv 　　　　cClass.Remove 1 　　Next i 　　Set cClass = Nothing End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ◆次に、 ＶＢＥ（ＶＢＡ編集画面）で、 メニュー[挿入][クラスモジュール]→新しく[Class1モジュール]が挿入される [Class1モジュール]に以下の記述をコピペします。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Private WithEvents myCx As MSForms.CheckBox ' ' ---------------------------------------- Private Sub myCx_Change() 　　With myCx 　　　　If .Value = True Then 　　　　　　.TopLeftCell.Offset(, 1).Value = Date 　　　　Else 　　　　　　.TopLeftCell.Offset(, 1).Formula = "=today()" 　　　　End If 　　End With End Sub Sub SetEv(o As MSForms.CheckBox) 　　Set myCx = o End Sub Sub CancelEv() 　　Set myCx = Nothing End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 多数のコントロールに同じ処理を実行させるには このようにクラスモジュールを用いるのが有効です。◆◆ 以上です。
こんにちは。 んー、なんていうか、そういう処理をする場合は、 何でもかんでもＶＢＡの力技に任せるのではなくて、 ある程度、扱い易いシートデザインを用意しておくのが本筋とは思います。 例えば、実質的な主キーは、 A列とB列を連結（実戦では区切り文字を挟みます）したもの、なのですから、 予め、実質的な主キーをひとつのフィールドとして用意しておくとか、 それだけでもＶＢＡの処理は易しくなり、 ＶＢＡ側の設計も幅が出てきて易しくなります。 ＶＢＡだけでなくて全体の設計を見直した方がベターではあります。 色々事情はおありでしょうから、このことは先の話として、置いといて、 本題に直接的にお答えします。 要は、 同じ（ユニークでない）キーに対して、 複数のデータがあり、それらを、順番にピックアップして、 ひとつの表にまとめたい、ということだと理解しています。 これはこれで、'表計算'や'データベース'のアプリケーションにとっては、 例外的で苦手とする処理のひとつだったりして、 ＶＢＡ書くのも簡単ではないと思います。 とりあえず、 　★Dictionaryオブジェクト 　★Collectionオブジェクト 　★二次元配列 等、普通は初級では扱わないような手法で、 スクリプトを書くのが（私にとって）簡単な方法で一案、書いてみました。 実質的な主キーの扱いについては、 　.Cells(i, "A").Text & vbCr & .Cells(i, "B") のように、セルには入力できない改行文字を区切り文字を使って、 A列とB列を連結しています。 実質的な主キーに対応したデータを Dictionaryオブジェクトのアイテムに置いたCollectionオブジェクトに 追加したり削除したりして、 同じ（ユニークでない）キーに対応した複数のデータを順番に出力します。 技術的な解説は一度では難しいので省きますが、 ★マークを付けたキーワードについて、調べてみて、 その上でお尋ねになりたいことがあれば、ひとつひとつお応えします。 何をどうやっても難しい要求を実現するのは、難しい、 これは仕方ないことですが、少しでもマシ（技術的により簡単）な やり方を思いついたら、もしかしてまた回答するかもしれません。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Sub Re8929559() Dim objDict As Object　'　As Scripting.Dictionary　' Dim sTemp As String Dim d As Long Dim i As Long 　　Set objDict = CreateObject("Scripting.Dictionary")　'　= New Scripting.Dictionary 　　With Worksheets("Sheet1") 　　　　d = .Cells(Rows.Count, "A").End(xlUp).Row 　　　　For i = 2 To d 　　　　　　sTemp = .Cells(i, "A").Text & vbCr & .Cells(i, "B") 　　　　　　If VarType(objDict(sTemp)) = vbEmpty Then 　　　　　　　　Set objDict(sTemp) = New Collection 　　　　　　End If 　　　　　　objDict(sTemp).Add .Range(.Cells(i, "C"), .Cells(i, "D")).Value, CStr(objDict(sTemp).Count) 　　　　Next i 　　End With 　　Application.ScreenUpdating = False 　　With Worksheets("Sheet2") 　　　　d = .Cells(Rows.Count, "A").End(xlUp).Row 　　　　For i = 2 To d 　　　　　　sTemp = .Cells(i, "A").Text & vbCr & .Cells(i, "B") 　　　　　　If objDict.Exists(sTemp) Then 　　　　　　　　.Range(.Cells(i, "D"), .Cells(i, "E")).Value = objDict(sTemp)(1) 　　　　　　　　objDict(sTemp).Remove 1 　　　　　　End If 　　　　Next i 　　End With 　　Application.ScreenUpdating = True End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
エラーが出たとのことですが、実行環境によっては、型が違うのかもしれませんね。 デバッガでウォッチすれば、 ie.Document が実際にどんな型になっているか確認できるかと思います。 なお、 Dim doc As HTMLDocument を削除すると、暗黙的に Dim doc As Variant と宣言したのと同じ意味になります。 Variant型には、Objectを含めた様々な型のデータを格納できます。
で、結局、両者とも機能しなかったのでしょうか？ 結果報告を期待しています！ (-"-)
固定小数点数と浮動小数点数の説明が少しまずいようですね・・・ １．まず，現在のコンピュータの内部表現は全て２進数(0,1)です． 　　また，VBAの「数値」の記憶方式は固定長です． ２．固定小数点形式とは，小数点の位置が固定しています． 　　ただし，記憶節約のため小数点そのものは記憶データにはありません． 　　それにVBAやCでは固定小数点形式のデータは，整数型のみです． 　　だから，小数点の位置は右端で小数部は0桁です． 　　PL/I言語などでは，整数部Nbit小数部Mbitという形式があります． 　　ただし小数点は記憶データの中にはありません．小数点位置は 　　コンパイラとプログラマが知っていれば良いのですから． ３．浮動小数点形式は実数を符号，仮数部，指数部に分けて記憶する方式です． 　　-0.15625→(2進数)-0.00101→(2進浮動)[符号:-][仮数部:1.01]*２＾[指数部:-11] 　　として，[符号][指数部][仮数部] と並べた２進数を記憶します． 　　ただし，仮数部と指数部の順序や，指数部を下駄はかせ，仮数部を1bitケチ表現， 　　などの工夫をして記憶域の節約と大小比較が整数形式と同じになるようにしています． 　　ついでに double変数 d=1 (整数型)　など単なる代入に見えますが， 　　記憶形式の変換を伴いますので時間がかかります．d=1.0 とすべきです． 補足．浮動小数点数は仮数部が有限桁なので有効桁数はもちろん有限ですが， 　　　仮数部は「2進小数」なので，10進数小数で小数最下位桁が5以外の数は 　　　正確には表せません．なお，0は，指数部=0…0，仮数部＝0…0となってます． 　　　浮動小数点数は正負対称に表現できますが， 　　　整数＝2進固定小数点数は，2の補数表示という方式を使いますので 　　　16bitの場合-32768(=1111 1111 1111 1111)～+32767(=0111 1111 1111 1111) 　　　といったように負の数が１つ多く表現できます．
提供する側にとって変数がとりうる値を制限して使う側に明示できる。 使う側にとって変数が取りうる値がわかりやすいうえにデバッグ中に列挙名で変数に入っている値が見える。
こんにちは。 >Shellではなく、WScript.Shellでのやり方をできれば教えてください。 VBAと質問に書かれていたので、てっきりShellで済むと思いましたが……。 結局、内容が分からないままに、WSHに作り変えました。 以下では、「vbMinimizedFocus」を使いました。 VBAなら、書き換えてやってみてください。 Dim myPath Dim objWSH Dim objFS Dim strShellCommand Const vbHide = 0 Const vbNormalFocus =1 Const vbMinimizedFocus = 2 Const vbMaximizedFocus =3 Const vbNormalNoFocus = 4 Const vbMinimizedNoFocus = 6 Set objWSH = Wscript.CreateObject("Wscript.Shell") myPath = "C:\Temp\" objWSH.CurrentDirectory = myPath strShellCommand = "cmd /c ffmpeg -i sample1.avi sample1.mp4 2>&1 null" objWSH.Run strShellCommand, vbMinimizedFocus, True
Formにコマンドボタンを用意して Command1を押したらAのプログラムを書いて Command2を押したらBのプログラムを書きます。 本の最初のほうに書いてあると思います。
こんにちは。 お礼をいただいたので、少し補足しておくと、 >私の使ってる教科書はエクセル２０００対応で、分からないことがいっぱいでなかなか進まないので、 >新しいVBAの教科書を買ったほうがいいか、悩みだしていたところ http://www.start-macro.com/55/w/s025.html ここに、 「MS Officeのバージョンアップ （97/2000/2003→2007/2010/2013）によって、 エクセルは大幅変更あり！　マクロはほぼ変更なし！！」 とあります。 VBAに関しては、2000の資料はとても貴重ですから、なるべくなら手放さないようにしたほうがよいです。 おっしゃっている、Active X コントロールとフォームコントロールが、現代になって、まさか、メニューで、並列されるとは思いもよりませんでした。当時は、Active X　コントロールを押し出していたからです。私も掲示板で、もう無くなるのだから使うなと、何度か他者から指摘されたり、揶揄されたものの一つです。 つい最近も、ここのカテゴリに「ApplicationとWorksheetFunctionの違い」という質問がありましたが、直接ではありませんが、私に対してついたレスが、当時の混乱を彷彿させるものです。指摘する側はまったく根拠などないのでした。 なお、私が、Excel 2003で作ったマクロは、未だに、Excel 2010で、問題なく稼働しています。 ------------------------------------- 未だに残っている機能（私の知っている範囲で思いつくもの） 1.フォームコントロールとダイアログボックス（シート） 　（Microsoft が、ヘルプからなくしてしまいました。） 　フォームコントロールの詳しい説明書は、95(Ver.5)にしかありません。 　フォームコントロールは、本来は、ダイアログシートのダイアログ・ボックスで使うようになっています。 2. マクロ関数 　Microsoft のヘルプには、Excel 2000を境になくてしまいましたが、たぶん、英語などのバージョンは出ているはずです。分かりやすい日本語独自のヘルプファイルは、95時代を後に、まったく消えてしまいました。掲示板では、このテクニックは、さんざん叩かれました。マクロ関数の中には、配列を吐き出す関数もいくつかありますので、その配列を扱うテクニックだけが、現在も残っています。 Office 2007以降になって、あらたにマクロ関数を増やしました。 3. DDE通信 　さすがに、今の時代は、Active Xにその座を譲りましたが、古い計測機械には、まだ、存在しているかもしれません。このテクニックは探しても載っていないはずです。95時代のものです。現在もその機能は残っています。 　 4．他は、MS-DOS時代のテクニックを、Excelが継承しているということを知られていませんが、コマンド（メソッド）の中で、R1C1型を引数（バラメータ）にするもの。これを応用したのが、Excelのデータベース機能です。 ---------------------- 一部機能がなくなったり、かなり変わったのは、 1.メニューが、リボンになって、プログラミングの方法が一部変わったけれども、半分ぐらいは健在です。 2.つい最近知ったことで、Sort メソッドが消えました。その代わり、Sortオブジェクトになりました。 3．行数が変わったことで、65534を最終行にしていたものを、Rows.Count に書き換えることが多くなったこと。（きちんと書かれていれば、置換で置き換えられます） 4．Excel 2003から、一部の .NetFramework のコマンドが使えるようになりました。 5．配列による限度が変わったこと。Excel　2000のSUM関数の配列要素は5461 までが、Excel 2007の上限がなくなりました。しかし、VBAでは、元から、そのような大規模な行全体をまたがるような配列要素は作るべきではないはずです。 -------------------------- 私の気まぐれで、ちょっと羅列してみました。 私は、Excel 2000の時のVBA資料(プログラマーズガイド－MSDNサイトにはアーカイブスとして残っているかもしれません）は、私の持っている中では、一番、むつかしい内容です。たぶん集大成だったに違いないと思っています。 >専門書は高いですしね。 Excel 2000 などのMicrosoft の資料は、当時、1万円を越えていましたが、もうどこにも手に入らないのです。もしできれば、VB6の資料も、古本屋さんで目についたら、手に入れたほうがよいかもしれません。 ここに出ているのは全部英語版ですが、これらに相当するものは、日本語版で出ていたのです。 http://support2.microsoft.com/default.aspx?scid= … この日本語バージョンは、あまり長い間売られていた覚えがありません。今さら、無理して求めるものでもありませんが、VBAの資料は、古本屋さんでも、平積みの中に二束三文で出ていますが、その価値などは、知っている人しか、分かるはずがありませんね。
こんばんは。 ListViewの1列目に関しては、中揃えとか左揃えとかいう選択はなくて、全部左寄せになります。 >どこかのwebページにListViewのコマンドがまとめられていないでしょうか？ >検索してみたのですが意外と見つかりませんでしたので >知ってらっしゃったら教えてください。 こちらには、ListViewにトラブルがあったのですが、Microsoft のページが開きませんでした。 それでも、MSN側の過去のアカーカイブには、たぶん、残っているはずですがヒットしません。 もうしばらく探してはみますが、一両日中に返事がなかったら、なかったと思ってください。 私は、河西朝雄さんの「Visual Basic 6 中級編」あたりに全部のActiveX の説明が載っていて、 そちらで覚えたのですが、もう絶版ですしね。今は、段ボール箱の中に入ってすぐに出せません。 出してみたところで、あまり変わるわけではありませんが。
こんにちは。 今、VBAのレベルはどのぐらいですか？　1ヶ月目、2ヶ月目？ テキストは使っらっしゃいますか？ 初心者といっても、サブ・プロシージャに手を付けているのですから、ここまで来るには、それなりの勉強はしたはずです。初心者で、いきなりということはありえません。もし、いきなりでしたら、最初から順序よく勉強したほうがよいです。この問題の意図は分かりますが、回答者が答えてもしょうがないような気がします。 >なぜでしょうか。 分かりません。Null値の出る要素が見当たりません。何か、コードで見せられていない部分があると思われます。Null値は、一般的には、Variant型の変数に入りますが、自動的に入ることは私の記憶には覚えがありません。 ここの題材は、「モジュール変数」のことだと思います。しかし、それにしてはヘンなコードです。 ヒントだけ書いておきます。後は、ネットで知らべてください。 '// Sub 例題() Dim hen　as integer　 '変数　←モジュール変数にする Dim cnt　as integer　 'くりかえし回数　As が小文字、Integerの先頭の Iが小文字 hen = 1 cnt = 1　'←不要 MsgBox("処理前hen = " & hen ) For cnt = 1 to 10 　　call サブ Next cnt ～ End sub '----------------------------------------------------- sub サブ() MsgBox("サブhen = " & hen ) ～　　　'←ここに hen = hen +1 が入ったりする End sub '-----------------------------------------------------
質問があいまいすぎて、PC すら持っていない状況なのかとも想像できてしまいます。 以下、ご確認ください。 どんなデバイスでスクリーンショットを撮影したのか。 PC は持っているのか。 プリンターは持っているのか。 PC とプリンターはどうやって接続しているのか。 以下は想像です。 スマフォなどのデバイスのスクリーンショットを撮影したのであれば、スマフォのメールから PC のメールへ画像を添付して送信すれば PC で印刷可能です。 PC のスクリーンショットを撮影したのだけれど、自宅にプリンターがないのであれば、PC からセブンイレブンのネットプリント サービスに画像をアップロードして、最寄りのセブンイレブンにあるコピー機から印刷することができます。 （スマフォで撮影した画像であれば、スマフォ用のネットプリント アプリを通じて同様に印刷が可能です） PC から利用するネットプリント サービス http://www.printing.ne.jp/ スマフォ用アプリ https://itunes.apple.com/jp/app/netprint/id37235 … https://play.google.com/store/apps/details?id=jp …
vbsはよく分かりませんが、cmdkeyで資格情報を作成しRDPを接続する方法が紹介されています。 そこそこすぐに出来そうな？ Run mstsc.exe with specified username and password http://stackoverflow.com/questions/11296819/run- … Cmdkey https://technet.microsoft.com/ja-jp/library/cc75 …
こんにちは。 手順２通りです。 ２つとも実践した方が便利です。 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 メニュー[リボン]の空いた所を右クリック ↓ [リボンのユーザー設定] ↓ [メインタブ] 　[開発]にチェックを入れる 　[OK]ボタンで確定 ↓ メニュー[リボン]に[開発]タブが表示される ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ [開発]タブ ↓ 　[挿入] ↓ 　[コントロールの挿入]画面が表示される。 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 メニュー[リボン]の空いた所を右クリック ↓ [クイック アクセス ツールバーのユーザー設定] ↓ [コマンドの選択] ↓ 　[[開発]タブ] 　↓下に表示されるリストから 　　[コントロールの挿入]を選択 　　↓ 　　　[追加] 　　　[OK]ボタンで確定 ↓ [クイック アクセス ツールバー]に[コントロールの挿入]アイコンが表示される ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ [クイック アクセス ツールバー] ↓ 　[コントロールの挿入] ↓ 　コントロールの挿入画面が表示される。 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 [コントロールツールボックス]は廃止され、[コントロールの挿入]に変わりました。 [ツールバーコントロール]も[ActiveX コントロール]と呼ぶようになりました。 [コントロールの挿入]画面下側にある[ActiveX コントロール]のアイコンの中から、 ご希望のコントロールをクリックして挿入してください。
No1です。すみません、コピー＆値のみペーストを忘れてました。 End Subの上に下記を追加してください。 activecell.resize(1,6).copy activecell.PasteSpecial Paste:=xlPasteValues これをしないと翌日の処理で値が変わってしまいます。
> ご回答ありがとうございます。申し訳ございませんが、具体的にどのようなコードかご教示いただけますでしょうか。 xlsRange.Validation.Add(Excel.XlDVType.xlValidateList, Formula1:="東京、大阪、名古屋") 　　↓ xlsValidation = xlsRange.Validation xlsValidation.Add(Excel.XlDVType.xlValidateList, Formula1:="東京、大阪、名古屋")
こんばんは。 本来、Excelのデータベース系は、ぜんぶR1C1スタイルだと言っても過言ではありませんね。 以下のように、変換してあげないと、たぶん入らないと思います。 '// Sub ConvertFmlPro() 　Dim Rng As Range 　Dim strRng As String 　Dim sh As Worksheet 　Dim fml As String 　Dim pvt As PivotTable 　Set Rng = Range("Sheet1!A1:H2000") 'データ・シート名から入れてください。「ビックリマークで区切る」 　fml = Rng.Parent.Name & "!" & Rng.Address(1, 1, xlR1C1) 'R1C1型 　Set pvt = Worksheets("Sheet2").PivotTables(1) 　pvt.SourceData = fml 　Debug.Print pvt.SourceData　'確認用　　(Sheet1!R1C1:R2000C8) End Sub
64bit版のExcelじゃ多分動きません。おうちのExcelが64bitなので確認できてません、あしからず ApplicationオブジェクトのWindowActivate、WindowDeactivateそれぞれのイベントプロシージャにぶちこみ、AddInとして登録してしまえば楽じゃないですかね。 Applicationイベントハンドラについては http://support.microsoft.com/kb/213566/ja を参照 Escキーということで、 Alt（ATOKならではの誤爆防止） Ctrl（スタートメニューが開く誤爆防止） ついでにShiftも Alt+Escなんかは比較的便利なショートカットなので、使いたい場合はコメントアウトしたら良いです。 まぁもっとも簡単な解決策は、キーボード変えるという方法なんですが。 ノートなら外付けキーボードに、デスクトップならそんな変態染みたキーボードは捨ててしまえば・・ Private Declare Function RegisterHotKey Lib "user32" _ (ByVal hWnd As Long, _ ByVal id As Long, _ ByVal fsModifiers As Long, _ ByVal vk As Long) As Long Private Declare Function UnregisterHotKey Lib "user32" _ (ByVal hWnd As Long, _ ByVal id As Long) As Long Private Const VK_ESCAPE = &H1B Private Const MOD_ALT = &H1 Private Const MOD_CONTROL = &H2 Private lEsc As Long Private lAltEsc As Long Private lCtrlEsc As Long Sub HookEscKey() lEsc = 1 lAltEsc = 2 lCtrlEsc = 3 Call RegisterHotKey(0, lEsc, 0&, VK_ESCAPE ) Call RegisterHotKey(0, lAltEsc, MOD_ALT, VK_ESCAPE ) Call RegisterHotKey(0, lCtrlEsc, MOD_CONTROL, VK_ESCAPE ) End Sub Sub UnhookEscKey() Call UnregisterHotKey(0, lEsc) Call UnregisterHotKey(0, lAltEsc) Call UnregisterHotKey(0, lCtrlEsc) End Sub
こんにちは。 返事をつけるのが遅くなってしまいました。 最近は、ListViewはほとんど使っていません。 私の分かる範囲ですと、イベントで、以下のようにすればよいと思います。 '// Private Sub ListView1_OLEDragDrop(Data As MSComctlLib.DataObject, _ 　　　　　　　　　　　　　　　　　Effect As Long, Button As Integer, _ 　　　　　　　　　　　　　　　　 Shift As Integer, x As Single, y As Single) With Me 　 　　.ListView1.ListItems.Clear 　　 If Data.Files.Count < 1 Then Exit Sub 　　 .ListView1.Font.Size = 12　　'←ここ 　End With 　End Sub '//
＃１-２です。補足・お礼、拝見しました。 > 自分なりに理解に努力しましたが、難しいので理解できませんでした。 > でも、少しずつ出来るよう続けていこうと思います。 ということなので、少しでも理解の援けになるよう解説を書いてみました。 また、少しでも解り易いものになるよう、再度書き換えました（動作仕様は全く一緒）。 すぐに解ろうとしないでも、少しずつ、時間が経てば深まるものに期待していていいです。 無理して返事しないで構いませんから、またいつかここで、お会いしましょう。 前提として、相対参照の仕方を確認してみて下さい。 　　Range("A10").Range("F1").Select　'　→　F10　を選択 　　Range("A10").Range("H2").Select　'　→　H11 　　Range("A10").Range("BC2").Select　'　→　BC11 　　Range("A12").Range("F1").Select　'　→　F12 　　Range("A12").Range("H2").Select　'　→　H13 　　Range("A12").Range("BC2").Select　'　→　BC13 上の相対参照の例に照らして考えると、 '10''12'　の部分を Dim nLevelRow As Long　'　各ブロック毎の相対参照基準行位置（10,12,14,...）"F11"なら10,"BC11"なら10→12 で表現します。 "F1"H1""BC2"...　の部分を相対参照セルアドレスとして ' ' セル選択の順番を定義した内の筆頭にあるセルアドレス："F1" Private sRelativeRefOrg As String Dim sRelativeRefPrev As String　'　値変更されたセルのアドレス（'Ａ列基準行セル'への相対参照） Dim sRelativeRefNext As String　'　次に選択するべきセルのアドレスを（'Ａ列基準行セル'への相対参照） 等のように表現しています。 処理の流れとしては、 F10（Range("A10").Range("F1")）の値が変更されたなら。 H10（Range("A10").Range("H1")）を選択する、という場合 "F1"を辞書で調べると"H1"が返ってくる、というようなこと（対応付け） をする目的で、Dictinary（辞書）オブジェクトを使っています。 BC11（Range("A10").Range("BC2")）の値が変更されたなら。 F12（Range("A12").Range("F1")）を選択する、という場合 "BC2"を辞書で調べると"F1"が返ってくる。"F1"返ってきたら、 基準行位置（10）を次のブロックの基準行位置（12）に変更する。 技術的なポイントとしてその他、 イベントプロシージャ（Worksheet_Change）の基本的な扱い 配列変数やSplit関数の基本的な扱い 等もチェックしてみて下さい。 以下、差し替えてお使い下さい。 ' ' /// Option Explicit ' '　' 相対参照で　セル選択の順番を定義（配列の元データ）（セル範囲参照文字列） Const SREF = "F1,H1,F2,H2,O1,Q1,O2,Q2,X1,Z1,X2,Z2,AG1,AI1,AG2,AI2,AP1,AR1,AP2,AR2,AZ1,BC1,AZ2,BC2" ' ' 値変更されたセルアドレスを'Ａ列基準行セル'への相対参照で渡すと、 ' ' 次に選択するべきセルのアドレスを'Ａ列基準行セル'への相対参照で返す ' ' Dictinary（辞書）オブジェクト Private oDict As Object　'　Scripting.Dictionary ' ' セル選択の順番を定義した内の筆頭にあるセルアドレス："F1" ' ' （次に選択するべき相対参照セルアドレスが"F1"に一致したならば、 ' ' 　基準行位置を次のブロックの基準行位置に変更する為に必要） Private sRelativeRefOrg As String Private Sub Worksheet_Change(ByVal Target As Range)　'　値変更時に発生するイベント Dim arrRelativeRef() As String　'　定義されたセル選択の順番を格納する配列（相対参照のアドレス） Dim sRelativeRefPrev As String　'　値変更されたセルのアドレス（'Ａ列基準行セル'への相対参照） Dim sRelativeRefNext As String　'　次に選択するべきセルのアドレスを（'Ａ列基準行セル'への相対参照） Dim nLevelRow As Long　'　各ブロック毎の相対参照基準行位置（10,12,14,...）"F11"なら10,"BC11"なら10→12 Dim nUBound As Long　'　配列の大きさ（要素数より１少ない数） Dim i As Long　'　ループ用 　　If Target.Count > 1 Then Exit Sub　'　値変更されたセルの数が１より大きければ処理を抜ける 　　If Target.Row < 10 Then Exit Sub　'　値変更されたセルの行位置が１０未満ならば処理を抜ける 　　' ' 値変更されたセルが定義されたセルの列に該当しなければ処理を抜ける 　　If Intersect(Target, Range(SREF).EntireColumn) Is Nothing Then Exit Sub 　　' ' Dictinary（辞書）オブジェクトが未設定なら（初めてこの記述を実行する時） 　　' ' Dictinary（辞書）オブジェクトの実体を作成し、格納する 　　' ' F1→H1,H1→F2,F2→H2,...BC2→（次のブロックの）F1、のように対応関係を呼び出す為のもの 　　If oDict Is Nothing Then 　　　　Set oDict = CreateObject("Scripting.Dictionary")　'　インスタンス生成 　　　　arrRelativeRef() = Split(SREF, ",")　'　定義されたセル選択の順番（相対参照のアドレス）を配列に格納 　　　　' ' セル選択の順番を定義した内の筆頭にあるセルアドレス："F1" 　　　　' ' （次に選択するべき相対参照セルアドレスが"F1"に一致したならば、 　　　　' ' 　基準行位置を次のブロックの基準行位置に変更する為に必要） 　　　　sRelativeRefOrg = arrRelativeRef(0) 　　　　nUBound = UBound(arrRelativeRef())　'　配列の大きさ（要素数より１少ない数） 　　　　For i = 0 To nUBound - 1 　　　　　　oDict(arrRelativeRef(i)) = arrRelativeRef(i + 1)　'　辞書に追加　F1→H1,H1→F2,F2→H2,... 　　　　Next i 　　　　oDict(arrRelativeRef(nUBound)) = arrRelativeRef(0)　' 辞書に追加　 BC2→（次のブロックの）F1 　　End If 　　' ' 値変更されたセルの行位置を取得して偶数に丸める（10→10,11→10,11→11,12→11,...） 　　nLevelRow = Target.Row And Not 1　'　　各ブロック毎の相対参照基準行位置 　　' ' 値変更されたセルの'基準行位置'分上のセルのアドレスを相対参照として取得 　　sRelativeRefPrev = Target.Offset(1 - nLevelRow).Address(0, 0) 　　' ' 値変更されたセルの相対参照アドレスが辞書に登録されていなければ処理を抜ける 　　If Not oDict.Exists(sRelativeRefPrev) Then Exit Sub 　　' ' 辞書を参照して、 　　' ' 値変更されたセルの相対参照アドレス　に対応した 　　' ' 次に選択するべき相対参照セルアドレス　を取得 　　sRelativeRefNext = oDict(sRelativeRefPrev) 　　' ' 次に選択するべき相対参照セルアドレスが"F1"に一致したならば、 　　' ' 基準行位置を次のブロックの基準行位置（２行下）に変更する 　　If sRelativeRefNext = sRelativeRefOrg Then nLevelRow = nLevelRow + 2 　　Application.EnableEvents = False　'　Worksheet_SelectionChangeイベントを発生させないように抑止 　　' ' 'Ａ列基準行セル'　からみて 　　' ' 次に選択するべき相対参照セルアドレス　の位置にあるセルを選択する 　　Cells(nLevelRow, "A").Range(sRelativeRefNext).Select 　　Application.EnableEvents = True　'　イベント再開 End Sub
こんにちは。 配列出力で作ってみましたが、だいたい、1万件ぐらいはストレスなしで可能だと思います。 基本的には、並べ替えをした後の状態を元に作られています。 また、会社名も日付も時間も、最初に出てきた順ですから、 出力した後に、並べ替えが必要になることもあります。 ダブリに関しては、後に出てきたものが優先されます。 時間の精度は、時間:分までですから、それ以下は認識されません '//標準モジュールを前提としています。 Sub TestMacro() 　Dim rng As Range 　Dim rngRw As Range 　Dim arDH As Variant 　Dim arCO As Variant 　Dim arArea As Variant 　Dim c As Range 　Dim i As Long, j As Long, k As Long 　Dim t As String 　'***************************** 　'初期設定と準備 　Const SRC As Variant = "A1" 'データの左上端 　Const DST As Variant = "G1" '出力先 'Sheet2!A1 も可能です。 　 　Set rng = Range(SRC).Offset(1) 　Set rngRw = Range(rng, Cells(Rows.Count, rng.Column).End(xlUp)) 　'***************************** 　If Not Intersect(Range(DST), rngRw.CurrentRegion) Is Nothing Then 　　MsgBox SRC & "を含む、元のデータを消去しようとしています。" & vbCrLf & _ 　　"定数 [DST]の設定の間違いです。要修正 ", 48 　　Exit Sub 　End If 　Range(DST).CurrentRegion.ClearContents '出力先のデータを削除 　For Each c In rngRw '日と時間 　　t = Format(c.Value, "yymmdd") & "," & Hour(c.Offset(, 1).Value) & ":" & Minute(c.Offset(0, 1).Value) 　　If IsArray(arDH) = False Then 　　　ReDim arDH(i) 　　　arDH(i) = t 　　　i = i + 1 　　ElseIf UBound(Filter(arDH, t)) < 0 Then 　　　ReDim Preserve arDH(i) 　　　arDH(i) = t 　　　i = i + 1 　　End If 　Next c 　i = 0 　For Each c In rngRw.Offset(, 2) '会社 　　If IsArray(arCO) = False Then 　　　ReDim arCO(i) 　　　arCO(i) = Trim(c.Value) 　　　i = i + 1 　　ElseIf UBound(Filter(arCO, c.Value)) < 0 Then 　　　ReDim Preserve arCO(i) 　　　arCO(i) = Trim(c.Value) 　　　i = i + 1 　　End If 　Next c 　ReDim arArea(UBound(arDH), UBound(arCO) + 2) 　For Each c In rngRw 　　j = Application.Match(Format(c.Value, "yymmdd") & "," _ 　　& Hour(c.Offset(, 1).Value) & ":" & _ 　　Minute(c.Offset(, 1).Value), arDH, 0) 　　If IsError(j) Then MsgBox "マクロの時間部分の調整が必要です。", 64: Exit Sub 　　k = Application.Match(c.Offset(, 2).Value, arCO, 0) 　　arArea(j - 1, 0) = c.Text 　　arArea(j - 1, 1) = c.Offset(, 1).Text 　　arArea(j - 1, k + 1) = c.Offset(, 3).Value 　Next 　 　'貼り付け 　Range(DST).Resize(, 2).Value = Array("日付", "時間") 　Range(DST).Offset(, 2).Resize(, UBound(arCO) + 1).Value = arCO 　Range(DST).Offset(1).Resize(UBound(arArea) + 1, UBound(arArea, 2) + 1).Value = arArea End Sub '//
すべてのメンバーアクセスによって取得されるCOMオブジェクトは解放する必要があります。 プロパティやインデクサから取得する場合でもこれは例外ではないです。 例えば， > xlsWookBook = xlsApp.Workbooks.Open(strPath) は，xlsApp.Workbooksを最後に解放できるように書く必要があります。 なお，.xlsx形式であれば，OOXMLとして読み書きした方が楽な場合も多いです。 nugetでEPPlusなどをインストールしてしまえば，COMの場合とそれほど代わらない書き方ができますし。
こんにちは。 私は、しばらくVBAも離れていたので、もう一度、復習を兼ねて総ざらえしてみました。 すでに#1様がご説明がありましたが、統計的にみて、小数点演算の約7割ぐらいに、浮動小数点誤差が発生しますので、小数点(時間計算を含む）は、それなりの方策を取らなくてはなりません。これは、VB6のマニュアルには載っているのですが、Excel VBAでは、私自身は、あまり見たことがありません。しかし、表計算の表の部分でも、同じことが起こっています。 概ね、VBプログラミングで教わる方法は、 固定小数点法, 整数変換法 の二点だと思います 固定小数点法というのは、出てきた小数点の数字をそのまま扱うことです。 Currency やCDec などの十進数計算もこの部類に入ります。 計算スピードも速いそうです。 a = 1.03: b = 1.001 mData = CCur(a) - CCur(b) mData = CDec(a) - CDec(b) mData = Format(a - b, "0.000")　'←？ また、このような固定小数点法もあります。 mData = 1.03@ - 1.001　'リテラルに直接@を付けます。 整数変換法というのは、本来、整数値では誤差がでませんので、10の小数点の桁数を掛けて整数にします。しかし、そのまま、整数にすると間違うこともあるので、丸めます。 mData = (Int(a * 10 ^ 3 + 0.5) - Int(b * 10 ^ 3 + 0.5)) / 10 ^ 3 こんな計算です。Intは、負数の計算には使えませんので、Fix関数を用いることも可能です。 また、VBAには、ワークシート関数以外には、小数点を丸めるためのRound関数がありませんから、 このような方法になります。 http://dobon.net/vb/dotnet/beginner/floatingpoin … http://support.microsoft.com/kb/214118/ja
#2の回答者です。 単に古い書き方だけではありませんね。 この実際その違いを知って使っているわけですから、それを闇雲に、古いという理由だけで、 没にしてしまうという理屈は成り立ちません。実際のエラーの違いを認識すべきでしょうね。 #2の　Sub TestMacro()が、なぜ、正しい結果を出さないか分かるなら、この問題は解決しているはずです。 エラーが出ないものならともかく、ワークシート関数の多くは、いろんな理由でエラーを返します。 それを単なるOn Error Resume Nextだけでは、失敗します。 WorksheetFunction で完全移行しているなら、誰もApplication.XXXX(関数)　などはしません。実際のVBAをやっていない人には、分からない話だと思います。
こんばんは。 もしかしたら思ったようにいかない可能性があります。 単純に考える人もいますが、長くやってみないと見えてこない部分もあるはずです。 私自身、こういうものは、知っているだけに気後れがしてしまいます。 簡単なことを難しく考えているようには見えますが、意外に、この種のものは、むつかしいです。 これを土台に、いろいろ試してみてください。 以下は、ユーザーフォームのコマンドボタンにつけるものです。 >すべてのエクセルウィンドウを、最小化した状態で(見えなければ良い)、 この部分は、どうするかお任せになります。 なせなら、それは、今回の質問内容とは別の問題のように思うからです。 以下は、おかしな部分があるような疑念がわくはずですが、以前、同様のものを何度も繰り返して、Excel 2007以上では、Excel のアプリケーションが終わらない現象があります。それで、このようなコードになりました。(別の掲示板では、この内容を間違いだと決めつけた人がいますが、Quit と　Saveが逆にするのは、古くからの手法です） また、名前を付けていないブックは、名前を付けて保存するか、捨ててしまうか、どちらかになります。 ThisWorkbookを最後にしないと、このような場合は、UserFormを立ち上げたままですと、途中で終了させると、ハングやクラッシュする可能性があります。 '// Private Sub CommandButton1_Click() 　Dim wb As Workbook 　Dim fn As Variant 　For Each wb In Application.Workbooks 　　If wb.Name Like "Book#*" Then 　　　fn = Application.Dialogs(xlDialogSaveAs).Show 　　　If Not VarType(fn) = vbBoolean Then 　　　　wb.SaveAs fn 　　　　wb.Close False 　　　Else 　　　　wb.Close False 　　　End If 　　ElseIf Not (wb.Name = ThisWorkbook.Name Or wb.Name Like "PERONAL.*") Then 　　　If wb.Saved = False Then 　　　　wb.Save 　　　End If 　　　wb.Close False 　　End If 　Next 　Call SettingBack(ThisWorkbook.Windows(1)) 　If ThisWorkbook.Saved = False Then 　　Application.Quit 　　ThisWorkbook.Close True　'ここは、逆で可能なのです。 　Else 　　Application.Quit 　　ThisWorkbook.Close 　End If 　Application.Quit 'これでも閉じなければ、下のコードも活かしてください。 　'Application.Quit　'予備 End Sub Sub SettingBack(wb As Window) 　　Dim cb As Object 　　On Error Resume Next 　　With wb.Windows(1) 　　　　.DisplayGridlines = True '罫線を表示 　　　　.DisplayHeadings = True '行列番号を表示 　　　　.DisplayOutline = True 'アウトライン記号を表示 　　　　.DisplayWorkbookTabs = True 'シート見出しを表示 　　　　Application.CommandBars("Worksheet Menu Bar").Enabled = True 'メニューを表示 　　　　For Each cb In Application.CommandBars 'ツールバー 　　　　　 cb.Enabled = True 　　　　Next 　　　　Application.DisplayFormulaBar = True '数式バーの非表示 　　　　Application.DisplayStatusBar = True 'ステータスバー 　　End With 　　On Error GoTo 0 End Sub '//
"/C /c rd/s/q" なぜか /c が二回書かれてますよ。 いずれにせよ、使用中のファイルは消せないので、全削除は無理です。
普通は ・PC2で「呼び出しボタン待受プログラム」を実行する ・PC１の呼び出しボタンが押されると、PC2の「待受プログラム」に伝わり、メッセージボックスが立ち上がる とします 通信方法にも ・PC2がPC1からの通信を待つ ・PC2が定期的にPC1の状態を確認しにいく ・上記2つで、直接通信するのではなく、第三者となる「サーバー」を経由する 等があります
簡単な方法では，Comparisonを引数にとるSortメソッドを使います。 https://msdn.microsoft.com/ja-jp/library/w56d4y5z(v=vs.100).aspx list.Sort(Function (x, y) String.Compare(x.strA, y.strA)) 何箇所でも行うのであれば，IComaprer(Of aaa)を実装したクラスを用意して，そのインスタンスを渡すとよいでしょう。 ただし，元のプログラムでは，listに入っている要素が全て同じオブジェクトのインスタンスになっています。 Addする要素は，それぞれ別々にNewした要素にしないといけません。 現在のコードで，2回Addした直後にブレークポイントをおいて，listの各要素のフィールドの値を見てみるとよいでしょう。
- の位置が問題、かなぁ（以下の URL の『ハイフンの使用』節）。 https://msdn.microsoft.com/ja-jp/library/swf8kax … 先頭か末尾にしてみたらどうなりますか?
こんにちは。 >実行したところ、「Sheet2のデータを完全に取得していません」で止まります。 >前回補足の通り、1日当たりのC列への入力は一定でなく、数個から１００数十個になります。 「入金データを完全に取得していません。」のエラーメッセージは、シート2のC列の番号を拾っていないか、D列の入金日(ひとつしかない）を取得していないか、どちらかだ、という意味です。 C列の番号については100個でも1,000個でも可能です。数の問題ではありません。 C列の番号には、書式パターンの選別があります。 たぶん、サンプルと実際では、内容が違うものだと思われます。 書式パターンを正確におっしゃっていただければ、直しますが、そのパターンを非公開だとおっしゃられるなら、それはそれで方法を変えるか、VBAのヘルプやインターネットで「Like演算子」を調べ、ご自身で作っていただくことになります。 Like "#*-#*-#*"　は、Like 演算子といい、英語で、◎◎のようだという意味があります。 [#] は、数字の意味で、[*] は、その後、何でもあり、ということです。これは、Excel側で、書式でそうなるように作られていても、表示上の文字で判定します。 　If .Cells(i, 3).Text Like "#*-#*-#*" Then　'というのは、以下のように選別します。 「3-4-2」　OK 「12-51-5」　OK 「1a-3b-5」　OK ----------------- 「5」　NG 「a1-5-c」　NG 「1-5」　NG ということです。不要なデータを入り込ませないためです。入り込めば、見つかりません、となります。 その部分を、 　Like "?*-?*-?*" 　とすれば、「a1-5-c」　の書式パターンは通るようになりますが、他のNGパターンは通りません。 事前に、不要データを避けるエラー回避の方法もあります。簡単にいうと、CountIf 関数を利用するのですが、後からもう一度調べますので、できるだけ避けたいものです。 該当する部分のコード 　　For i = 2 To .Cells(Rows.Count, 3).End(xlUp).Row 'C列二行目から 　　'C列は、行の最後まで入れる 　　　ReDim Preserve Nos(j) 　　　If .Cells(i, 3).Text Like "#*-#*-#*" Then　'←ここの部分。 　　　　Set Nos(j) = .Cells(i, 3) 　　　　j = j + 1 　　　End If 　　Next i また、D列は、 番号　　入金日 3-4-2　 1-1-2　 1-1-3　入金日 1-2-7　H27.1.10 ひとつ拾ったら、もうそれ以上は入れないようになっています。 　　For i = 2 To .Cells(Rows.Count, 4).End(xlUp).Row 'D列二行目から 　　　If .Cells(i, 4).Text Like "H##*" Then 　　　　rcDate = .Cells(i, 4).Text '日付は一つしか入らない 　　　　Exit For　'←もうデータ探さないということ。 　　　End If 　　Next i
環境変数を利用してみては？ https://msdn.microsoft.com/ja-jp/library/96xafke …
こんにちは。 Excel VBA だとすれば、このようなイベントになります。 たぶん、アスキー文字のみになるはずですが、このようなコードです。 Private Sub TextBox1_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger) 　　If KeyAscii.Value = 97 Then KeyAscii.Value = 122 'a ->z 　　If KeyAscii.Value = 65 Then KeyAscii.Value = 90 'A->Z End Sub
こんにちは。 簡単な場合は、Like演算子を使います。 複雑な場合は、正規表現を使います。 Dim strA As String strA = "1" If strA Like "[A-Za-z]" Then　'大文字小文字は分けます。 　MsgBox "hit!" End If "[A-z]"とすると、一部記号が混じります。 アルファベットが含まれているか、チェックする場合。 strA Like "*[A-Za-z]*" アルファベットが一つも含まれていない場合は、 strA Like "*[^A-Za-z]*"
こんばんは。 >もちろんWebサイトを直接コピーしてExcelシートに貼り付け、という方法は私も存じております。が、それではちょっと難しいのです。 >.filesフォルダの中にある画像(商品価格を画像にしたもの)を取り出す、ということをしたいのです。 えっ! それは、ここのスレでは一度もでていない話だと思います。 まったく違う内容だと思いますが。むろん、私なら、VBAで可能かもしれませんが、あえて面倒なことをする気にもなりません。 ダウンローダーを使えば、何十個でも、何百個でも、種別に選別して数分でダウロードできます。 以下はアマゾンサイトのあるページを、ダウンローダーでみたjpg/pngのファイル一覧です。 「ダウンローダー　フリー」とでもググればいくつか出てきます。たぶん、ソフトウェアには、Malware は入っていないと思いますが、この種のものは、余計なものをインストールされることがありますから、十分に気をつけてインストールしてください。
Windowsフォームだと、MVVMもどきなことすると追いづらくなるだけですから、ムリしてなんでもかんでも切り離す必要ないのでは。 そもそもそういう思想のデザイナーではありませんので。 そのため、少なからず『ビジネスロジック』がイベント配下に実装しなければならないわけですから、 処理をカテゴライズしてクラス化すればいいのでは。 フォーム内に含まれるイベント配下の処理およびメソッドでは、UIの変化、 クラスのメソッドを呼び出し、および結果によるUIの変化。 他は全部ロジッククラス。 場合に応じてdelegateなども利用すれば宜しいかと。 Form1 　└Form1Logic 　　　├DTO_A 　　　└DAO_A 　　　　　└EntityA Form2 　└Form2Logic 　　　├DTO_A 　　　└DAO_A 　　　　　└EntityA Form3 　├Form1Logic 　　　├DTO_A 　│　└DAO_A 　│　　　└EntityA 　└Form3Logic 　　　├DTO_B 　　　└DAO_B 　　　　　│EntityA 　　　　　└EntityB みたいな。
こんにちは。 #2の回答者です。 最初に、VBAにおいては、バージョンによって他の問題は発生しますが、個別のウィンドウには、ほとんど、バージョンに関係ないと思います。 ただし、他のOfficeのバージョンとの共存については、VBAにおいては、使用に関して保証されていませんし、不具合がある可能性もありますから、それは了解していただきたいと思います。 >「標準モジュールのウィンドウです。」 コード・ペインのことですね。他は位置関係が移動しないのでしょうか。すべてリセットされてしまうということですが、今の情報だけなら、#2の回答で間違いないと思います。たまに、間違って、最大化のところをクリックしてしまうことがあります。そうすると、フローティング状態になってしまいます。 コード・ペイン(ウィンドウ）は最大化していなければ、バラバラになってしまいます。 そうでない場合については、今の段階では、なんとも言えません。
こんばんは。 >有効数字で四捨五入するマクロをVBAで作りたいのですが 有効桁数が3桁の計算をしないさい、ということだったら、古典的な問題ですね。昔、やった覚えがあります。ただし、文中の引用先の知恵袋の質問は、理由の分からないリクエストが多すぎるように感じます。 ご質問のイレギュラーな部分としては、有効桁数が、二桁になっています。 というとで、条件が変わっています。 0.012345679　→　0.012 0.098765432　→　0.099 それと、これは、Format の問題ですから、これもイレギュラーです。 0.0900654321 → 0.090 なお、以下のマクロでは、有効桁数を優先しているので、 0.000912456　→　0.00091　となり、 負数は、以下のようになります。 -0.090065432 　→　-0.090　となります。 >WorksheetFunctionを使わずに行いたいのですが 引用先の事ですね。ユーザー定義関数としては、プログラミングとしての用をなしていないように見受けられました。 以下はExcelのA列の1行目からの計算です。右隣のセルに出力します。 '// Sub Test01() Dim c As Range Dim buf As Variant For Each c In Range("A1", Cells(Rows.Count, 1).End(xlUp)) 　If VarType(c.Value) = vbDouble Then 　　If c.Value >= 0.1 Then 　　　c.Offset(, 1).Value = UpperGetNum(c.Value, 3) 　　Else 　　　 buf = UpperGetNum(c.Value, 2) 　　　 If Len(CStr(Abs(buf))) <= 4 Then 　　　　 c.Offset(, 1).NumberFormat = "0.000" 　　　　 c.Offset(, 1).Value = buf 　　　 Else 　　　　 c.Offset(, 1).Value = buf 　　　 End If 　　End If 　End If Next End Sub ''ユーザー定義関数 Function UpperGetNum(n, dgt) 'n は計算の数値, dgtは桁数 二つのパラメータは意図的にVariant型 Dim sg As Integer Dim k As Integer Dim i As Integer Dim a As Double 　sg = Sgn(n) '符号 　n = Abs(n)　'絶対値 　k = Int(Log(Abs(n)) / Log(10#))　'桁 　i = (k + 1) - dgt 　a = Int(n / 10 ^ i + 0.5)　'四捨五入 　UpperGetNum = sg * (a * 10 ^ i) End Function '// >あとテキストデータに出力した際に >0.001などが1E-3のようになってしまいますが >指数表記か標準表記かを選択するにはどうしたら良いですか？ テキストデータに出力という意味には、いろいろありますから、それだけではっきり分かりません。 Format(x, "0.000")　これも、テキスト出力です。 1E-3　になるのは、特別に書式設定されていなければ、セル幅を広げれば、数値的に出るはずです。セル上で、データ型のキャスティングでも行われているというのでしたら、 明示的に、　ActiveCell.NumberFormat ="0.000"　 としてから、 ActiveCell.Value =0.001 として、数値出力すればよいはずです。(数値入力よりも、NumberFormat が先ならないと、補正処理が働いて、値が変動することがあったと思います。) >Format(x, "0.000") >のようにすると、0.1が0.100のようになってしまうのですがどうしたら良いですか？ それは、最初のご質問提示の 0.0900654321 → 0.090 とは、矛盾しているように感じます。何か、明確な条件がなくては、排除することができません。 丸める必要がないものは、If 文に条件をつければよいでしょう。 例えば、IF 値*1000 - INT関数(値 *1000) =0 なら、そのままに出力するとかすればよいと思います。
2003の時の話ですがまれにldbファイルが残ったままの時がありましたので、いまでもそのような状態なのかもしれません。 ただ、テーブルのレコードを排他的に処理するように設定(デフォルトの設定はそうなっているかもしれません)しておけば、別に同時に同じテーブルを開いて別レコードを編集することに問題はないと思います。ただし、該当レコードの前後のレコードも排他的になっていたので、その部分は編集ができなくなります。かなり昔なのであいまいな記憶ですが、レコードの排他処理をしていない場合は、同一レコードを編集したときには後から編集を終了した側に他の人が編集し変更を加えた旨の警告が出て、自分の変更を有効にするかクリップボードにコピーするかの選択肢が出たと思います。 もし、laccdbの有無でアクセスの可否決定をしているのでしたらレコード単位の排他処理でよろしいのではないかと思います。
No.1です。 投稿後気になったので、再び顔を出しました。 VBAで！というご希望なので、もしかして同じ日に「役割」の重複があるのでしょうか？ その場合は関数では難しいので、やはりVBAになってしまうと思います。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から Dim i As Long, j As Long, c As Range, wS As Worksheet Set wS = Worksheets("Sheet1") With Worksheets("Sheet2") .Range("B2:AF15").ClearContents For j = 2 To wS.Cells(1, Columns.Count).End(xlToLeft).Column 'B列～1行目データが入っている最終列まで For i = 2 To 15 '2行目～15行目まで '▼　Sheet1のi行・j列にデータがあれば、Sheet2のA列何行目のデータと一致するか？ If wS.Cells(i, j) <> "" Then Set c = .Range("A:A").Find(what:=wS.Cells(i, j), LookIn:=xlValues, lookat:=xlWhole) '▼　Sheet2の一致した行のj列が空白の場合は、Sheet1のi行・A列データをそのまま表示 'そうでない場合は今あるデータと「半角スペース」と新たにSheet1のi行・A列データを追加表示 With .Cells(c.Row, j) If .Value = "" Then .Value = wS.Cells(i, "A") Else .Value = .Value & " " & wS.Cells(i, "A") End If End With End If Next i Next j .Columns.AutoFit End With End Sub 'この行まで ※　関数でないのでデータ変更があるたびに マクロを実行する必要があります。m(_ _)m
こんにちは。 UserFormで気をつけることは、時間で保有してしまうと、24時間以内ですから、それを越えたりする時は、文字で保管しなければなりません。今回はそうでないかもしれませんが、最初から文字列にしています。一応、汎用性のために、保有する変数は、Variant ですから間違えないようにしてください。 一応、UserFormモジュール全部を書いておきます。 '// Dim TimeA　'モジュール変数(Variant型) Dim TimeB Private Sub TextBox1_AfterUpdate() 　If IsNumeric(TextBox1.Value) Then 　　TimeA = TextBox1.Value 　Else 　　MsgBox "時間を入れてください。", 48 　　TextBox1.Value = "" 　End If End Sub Private Sub TextBox2_AfterUpdate() 　If IsNumeric(TextBox2.Value) And Val(TextBox2.Value) < 60 Then 　　TimeA = TimeA & ":" & TextBox2.Value 　Else 　　MsgBox "分を入れてください。(59分まで)", 48 　　TextBox2.Value = "" 　End If End Sub Private Sub TextBox3_AfterUpdate() 　If IsNumeric(TextBox3.Value) Then 　　TimeB = TextBox3.Value 　Else 　　MsgBox "時間を入れてください。", 48 　　TextBox3.Value = "" 　End If End Sub Private Sub TextBox4_AfterUpdate() 　If IsNumeric(TextBox4.Value) And Val(TextBox4.Value) < 60 Then 　　TimeB = TimeB & ":" & TextBox4.Value 　Else 　　MsgBox "分を入れてください。(59分まで)", 48 　　TextBox4.Value = "" 　End If End Sub Private Sub CommandButton1_Click() Dim i As Long 　If TimeA <> "" And TimeB <> "" Then 　　ActiveSheet.Range("A1").Value = TimeA 　　ActiveSheet.Range("B1").Value = TimeB 　　tima = "": TimeB = "" 　　For i = 1 To 4 　　　Me.Controls("TextBox" & i).Value = "" 　　Next 　Else '二つの変数が空の場合。 　　ActiveSheet.Range("A1").ClearContents 　　ActiveSheet.Range("B1").ClearContents 　End If End Sub '//
#2の回答者です。 >うまくいきません。ちなみにオフィースバージョンは２００３です、標準モジュールにコピーして使用しましたが動きません。 うまくいかなかったというのは、全然、処理しなかったのか、それとも、エラーが発生したのか、どちらでしょうか。 >ファンクションもそのまま貼り付けたのが良くなかったのでしょうか？生年月日はF3:F187ではなくE3:E187にして使用しました。よろしくお願いします。 別に、2003でも、問題ない初歩的レベルの内容ですし、そのまま二つセットで、標準モジュールに貼り付けして構いません。データがあったら、その3列右に出力しますから、E列対象なら、H列に「☆」が返ることを意味しています。しかし、#2の中でも、誤動作について、ちょっと触れましたが、問題になるのは、その生年月日自体の中身がシリアル値でなければ、話が全然変わってきます。その場合は、一旦、シリアル値に戻さなくてはなりません。 こちらからでは、見えない部分の注意点を事細かには申すこともできませんので、それだけは、確認してください。また、主要な点に、デバッグのタブの中などの、「ブレークポイント」を設けて、ローカル・ウィンドウで、きちんと値が返っているか、見てもよいかと思います。 なお、#3さんのコードは、数式自体を、どこか空いている計算列に、「☆」を出して、それを、ループで、然るべき所に「☆」を置いても構わないはずです。こちらで試してみましたが、私のコードとの違いはありませんでした。この辺りは、必ず、その場所に式を置かなければならないわけではありませんので、臨機応変に考えてください。私は、基本的にはコードが完成品でしたら、誰のでも構いません。
こんにちは。 >このページで外部資源を用いないと変数を保存できないことを教えていただきました。 Out of Question にはなりますが、前回の回答者のベストアンサーさんとは別に、値や文字列を残す場合は、一般的に、Office VBAでは、初級レベルで、カスタム・プロパティに保存すると教わります。レジストリやそれ以外にもありますが、そんなマニアックな方法はお勧めしません。 >subの中で別のsubを呼び出すかたちになってしまいます。 >subを入れ子にせずに、subを連続で使う方法はありますか？ まず、それの何が悪いのでしょう。VB系の基本でしょう？ >sub 3を作成し、そこにsub1とsub2を入れるというのも無しです。 このままの内容では、いわゆる、子供たちの「●●ごっこ」です。 そうでなければ、構造化プログラミングの否定です。 そういう場合、どうしてもというなら、オブジェクトに組み込みこませ、インスタンスを生成することにはなるでしょう。しかし、もう少し、VB系の基礎的な知識を身につけられたほうがよいのではありませんか？前回の質問からすれば、UserFormの問題でしょう。UserFormに、Subプロシージャを呼び出すということはあまりしませんが、なぜ、Subプロシージャ(一般的には標準モジュールに置きます)を呼び出す意味さえ、分かっていらっしゃらないようです。 その目的に反する問題が出てきて、初めて、人に理解できる質問だと思いますね。
「プログラムを終了しても保存」ならばレジストリに保存しておくしかありません。 あまりオススメはしませんが。 http://officetanaka.net/excel/vba/tips/tips43.htm
No.4です。 前回のコードではエラーになりマクロが止まってしまいます。 最後から5行目の ＞wS.Range(Columns(3), Columns(lastCol)).Delete を ＞Range(wS.Columns(3), wS.Columns(lastCol)).Delete に変更してください。 どうも失礼しました。m(_ _)m
こんにちは。 パスワードの解析の話は、それを言い始めるとなんでもありになってしまいますから、一応、この場では、Out of Topic にしますが、最後の方で、すこし触れます。 >パスワードを知っている管理者の人だけが全て見ることができて、 >パスワードを知らない一般の人は、BとDの行だけが見えないようにしたいのです。 今、その種のマクロを思い出しました。かなり昔のもので、私のオリジナルではありません。 ただ、正確には思い出せませんが、こんな内容だったと思います。 まず、「隠しシート」を作ります。 その「隠しシート」に、どこか、とんでもない所に、B列データとD列データを置きます。[便宜的に、隠しシートのB1 とD1からにしました] 次に、どこか、適当(なるべく下の方に)に、True とでも、入れます。[便宜的に、$G$1にします] 実際は、Excelの'イースターエッグ'のような分からない所に置きます。 また、「隠しシート」の名称は、なるべく類推しにくいものや最初に空白を入れるとがよいと思います。 そうしたら、「閲覧シート」のB1から、 =IF(隠しシート!$G$1,"",隠しシート!B1) で、データのある分だけ、フィルハンドル・コピーをします。 D列も同様で、 =IF(隠しシート!$G$1,"",隠しシート!D1) 同じようにします。 次に、書式設定－保護タブ　で、ロックと表示しない、両方にチェックを入れてください。 次に、VBEditor 画面を開きます。 「隠しシート」のプロジェクト・ウィンドウで選び、プロパティの中の、 Visibleの項目で、:-2 - xlSheetVeryHidden に変更し、 プロジェクト・ウィンドウを右クリックなどして、 プロジェクト・プロパティを出し、[保護タブ]をクリック、 プロジェクトのロックにチェックを入れ、パスワードを入れます。 こうして出来上がったら、今度は、変更履歴はオンにしておいて、校閲でパスワード付きシートの保護と、ブックの保護をします。 これで出来上がりです。 昔、私が出会ったプロテクトの一種です。 >管理者が５という列を挿入したら、 >一般の人のものも、５という列が挿入されるようにしたいのです。 これは、ちょっと違う話です。というのは、管理者側が、基本的に、ブックやシートを加工中の部分を見せるなら、もうセキュリティなどないに等しいのです。 以前にも経験があるけれども、この手の内容の記事は、他人から煽られることがあります。それに乗って、セキュリティに関してのノウハウを書きすぎたりする人間がいます。逆に、それを別の解除に利用する輩が出ることがあります。私は、見かけた記事は、OkWaveに頼んで、削除依頼することがあります。 ただ、常識的な機能で使う限り、そのプロテクトを破る人間などは、おおよそ見当が付きますから、後は、それなりの編集や閲覧記録を取れば、誰がやったかはすぐに分かってしまいます。 もちろん、マクロを使いこなせる人なら、この程度のものは、そのデータを抜き出すことなど、たやすいことです。ただ、一般の人は分かりません。また、シートを、VeryHiddenにしてあると、どこにも、その名称は出てきません。むろん、暗号化されていないブックでは、解析ツールなどでは簡単です。 この程度でも、プロテクト破りは、衆人環視の会社ではできるとは思えません。それができるような会社なら、情報は垂れ流しのはずです。それゆえに、またデータの持ち出しに気をつけるべきなのです。 それに対する単純な防衛方法もいくつかあります。例えば、別のブックを作り「隠しシート」に、隠しデータを移し、ブックをアドイン型に変更してしまってしまうのです。他にも、ありますが、この手の内容は、中途のままで後は、ご自身が考えてもらうようにします。 とは言え、いわゆる「頭の黒いネズミ」は、会社の気風にもよるものだと思います。 今は、セキュリティに関しては、「デジタル署名付き」、「パワード付き暗号化」、「最終版」、「IRM」などの選択もあります。それらを組み合わせてもよいかと思います。
回答No.1 です。 回答No.1のコード、間違えました。『ディクショナリを作る』 ほうで "0001", "日本" を２回入れてますね。後のほうは "0003", "フランス" の間違いです。 大丈夫だとは思いますが、念のため訂正です。
こんにちは。 Set objWshShell = WScript.CreateObject("WScript.Shell") を使って、 objWshShell.AppActivate "Microsoft PowerPoint", True で、いかがでしょうか。
＞それでは一般的なコマンドラインソフトの実行結果を変数に代入するにはどうしたら良いでしょうか？ 一般的なコマンドラインソフトの実行結果は、標準出力に出るので、プログラムに間違いは無いと思います。 grepをフルパスにしてみるとか。
VBだけでやると面倒ですが，コマンドラインから， XCOPY H:\ K:\ /T /E あたりでできるかと。 空のディレクトリをコピーしないのであれば/Eを/Sに。
こんにちは。 すでに回答は出ていますから、こちらは、今の段階では、こちらもコードを出すのは混乱するだけですから、言葉だけにします。 >csvデータの取込は作ることが出来たのですが、エクセルファイルをcsvデータのように取込することは出来ないでしょうか？ 前の回答者とは違う方法で、できると言えば、出来ますが、それが、一体、どのようなものかをご希望なさっているかにもよります。 例えば、CSVファイルをExcelで、そのまま開けたり、TextQueryでインポートするとか、いろいろな方法があります。 また、DAOやADOを使う方法や、ダイレクトにセル名指しで吸い上げる方法さえあります。(←これはお勧めしません、書く側が面倒だからです。（^^;) >取込したいエクセルファイルのシートが複数にわかれていて、全シートの情報を取込したいと考えているので、・・ というのは、一つのシートにということでしょうか。曖昧なので、ここらは意味が分かりません。 >一番工数が少なく済む方法 あまり、マクロに工程数というものは、関係ないように思います。自動で動いているのですから。 当たり前ですが、エラー処理を無視すれば、工程数は減りますね。 もし、すでに、他の回答者さんで、満足されているなら、こちらは無視なさってよいです。
先の回答者さんの ObjIE.Document.Body.runtimeStyle.Zoom = ZoomRate については、<body> に対して style="zoom:70%" を指定するような操作のため 表示するページによって結果が異なる場合があるかと思われます。 IEの拡大表示機能を利用する場合は上記処理の部分を以下のように変更します。 Const OLECMDID_OPTICAL_ZOOM = 63 Const OLECMDEXECOPT_DODEFAULT = 0 ZoomRate = 70 '整数で拡大率を指定します ObjIE.ExecWB OLECMDID_OPTICAL_ZOOM, OLECMDEXECOPT_DODEFAULT, CLng(ZoomRate) ExecWBで操作できる項目についてはOLECMDID列挙体に定義されているので 以下のページが参考になるかもしれません。 https://msdn.microsoft.com/en-us/library/ms69126 … 以上、ご参考になれば幸いです。
こんにちは。お邪魔します。 > マイクロソフトの前回の問題と関係するのでしょうか？ 2014/12/9のOfficeセキュリティ更新プログラムによるActiveXコントロールの一連の不具合のことでしょうか？ http://support.microsoft.com/kb/2553154 だとすると、対策はお済みでしょうか？ http://support.microsoft.com/kb/3025036/ja それでも尚「CommandButton21問題」 （従来のコントロール名の後ろに"2"が付いた名前に変更された為コントロールの付番が"21"から始まるように見える） 等、未だ解決していない問題が幾つか残っているようですが、、、。 今回の問題の原因については、2014/12/9のアップデートであると、 特定できるまでの情報がありませんので、ハッキリとした回答は出来ません。 現在お使いのWindowsやOfficeのバージョン？、それぞれ32or64ビット？、 2003で作成したブックを2007以降のバージョン[Excel 97-2003 ブック (*.xls)]形式で保存し直しているのかどうか？、 それとも[Excel 97-2003 テンプレート (*.xlt)]なのか？ コピー元のシートにはFrameコントロール上にコントロールを配置しているか？、 等によっても、違いが出てくるのではないでしょうか。 > サンプルとして用意した当番表のシートを実際の月当番表を作成するときに、シートのコピーをして作成します。シートはコピーされたのですが、そのシートに張り付けた印刷ボタン（クリックすると自動印刷）が今まで一緒にコピーされたのですが、コピーされません。 2014/12/9のアップデートが原因である場合、 「シートはコピー出来るのにコントロールだけコピーできない」 という現象は、私の方では確認出来ませんし、ちょっと考えにくいです。 「コントロールだけコピーできない」という 現象そのものは、以前からよく質問される課題ですので、まずは定番の手順で確認をしてみてください。 Excelのオプション設定を、気づかない内に、 （コントロールをコピーしないように）変更してしまっていた場合 （もし、そうでなければ、オプション設定や警告ダイアログに関する言及がある筈です） というのが、質問された多くのケースで原因となっていたこと、です。 XL2003なら 　　[ツール]→[オプション]→[編集] 　　↓[□オブジェクトをセルとともに切り取り、コピー、並べ替える] XL2010なら 　　[ファイル]タブ→[オプション]→[詳細設定]→[切り取り、コピー、貼り付け] 　　↓[□挿入したオブジェクトをセルと共に切り取り、コピー、並べ替えを行う(_O)] の、チェックを外れていまっているのを、チェックし直す、 または、いずれのバージョンでも、VBAから、 　　Application.CopyObjectsWithCells = True を実行する 等の手順で、シートのコピー時にコントロールもコピーされる状態に通常は戻せます。 "シートはコピーされたのですが、そのシートに張り付けた印刷ボタン...が...コピーされません。" という説明からすると、以上の確認が先決です。 > コピーされていた古いファイルでしても同様です。 この記述の意味が私には汲み取れていません。ですので、もし見当違いでしたら、すみません。 が、状況に依っては、以上の手当てで解決する可能性もあるのかと。 次に、質問文の説明とは食い違うので、余談、ということになりますが、 「コントロールごとシートのコピーはされるがコントロールが機能しない」 というケースだった場合の話ですと、、、 MSForms.exd削除済みのWin7/Xl2010x64で、XL2003で作成した旧いブックをコピー元にして 　　Workbooks.Open Filename:=""コピー元ブック名.xls" 　　With Workbooks("コピー先ブック名.xlsm") 　　　　Workbooks("コピー元ブック名.xls").Worksheets("コピー元シート名").Copy After:=.Worksheets(.Worksheets.Count) 　　End With というような記述を実行して確かめましたが、 （コピー元ブックでは[セキュリティ]の警告が表示されたままになるものの） シートもActiveXコントロール（昔のツールバーコントロール）も見た目上は複製されました。 但し、コピー後の新しいシート上ではActiveXコントロールが機能しません。 これを機能させる為の応急処置としては、以下の手順。 　　[ファイル]タブ→[オプション]→[セキュリティセンター]→[セキュリティセンターの設定] 　　↓[ActiveXの設定] 　　　↓[□先に確認メッセージを表示してから、初期化に危険が伴うコントロールには制限を強化し、初期化しても安全なコントロールには最低限の制限を適用して有効にする(_R)] 　　　にチェックが入っているものを替えて 　　　↓[□確認メッセージを表示せずに、すべてのコントロールを制限なしに有効にする（推奨しません。危険なコントトールが実行される可能性があります）(_E)] 　　　をチェックしておいてから、シートをコピーするマクロを実行します。 これで、コピー直後からActiveXコントロールが機能するようになりますが、 説明にもある通り、セキュリティ上の不安は拭えない状態での、暫定的な対応ということになりますから、 セキュリティ環境の確認を含めて、よく検討した上で採否を見極めるようにしてください。 あくまでも暫定的な対策として、例えば急いで処理したい時の一時的な方法として紹介しているだけです。 ＭＳ側で今後対策の予定があるかどうか、この他により安全な方法があるかどうか、 私には、解りませんし、知り得る立場でもありません。 ただ元々がセキュリティ対策としての改編だったことを考えると、 ActiveXコントロールの新旧バージョン間の互換については、 新たなＭＳによる積極的な対策対応について（少なくとも至近では） 期待できないものだとは私は思っています。 〓抜本的な対策〓としては、 新しいバージョン側で新規に[名前を付けて保存]（作成し直す）ことを、 どこかのタイミングで検討した方がよいのかも知れません。 その方が確実なのとすぐに結果が欲しかったので、無駄になるかも知れないとは思いつつ、 私の周辺では新バージョン導入直後に、 （場合によっては警告ダイアログ上で[コンテンツの有効化]ボタン等を経て） 〓[Excel 97-2003 ブック (*.xls)]を現行の[Excel マクロ有効ブック (*.xlsm)]に書換えて〓、 対策しました（ActiveXコントロールの互換の問題は以前からありましたから）。 なので、今回の問題を再現することも私の環境では簡単ではないので、 確度の高い話は出来ませんが、今の私としては、このような回答になります。 最後に、 「Frameコントロール上に配置したコントロールだけが消えてしまう」 ということでしたらば （Frameコントロールは本来ボタンを配置する為のものではないので話が違うでしょうけれど） 私が今知っている限りでは、新しいバージョンのブックとして、 改めてコントロールを挿入し直す、という方法ぐらいしかないように思います。 尚もお困りでしたら、補足欄にでも書いてみて下さい。
回答No.1です。 やっと質問の意味がわかりました。 テンプレートに表示される「テキストファイル」は、画面 (フォーム)ではありません。従って「Windows フォーム」 や「ダイアログ」のように表示させることはできません。 A. テンプレートで画面(フォーム・ダイアログ)扱いのもの 　Windowsフォーム、ダイアログ、エクスプローラフォーム 　MDI親フォーム、情報ボックス 　　…など。他にも名前に「フォーム」と付くものはこちら B. テンプレートで画面(フォーム・ダイアログ)扱いではないもの 　クラス、モジュール、インターフェイス、設定ファイル、 　テキストファイル、アイコンファイル 　　…など。「ファイル」と名前が付くものは全てこちら A. に分類されるものは画面(フォーム)として表示させることが できますが、B. に分類されるものはできません。 テキストファイルの内容を表示させるためには、質問者さんが 調べたとおり 　・Process.Start を使ってメモ帳などに表示 　・テキストを読み込んで、コントロールまたはメッセージ 　　ダイアログに表示 のどちらかしか方法がありません。
「続いて順次」と言うのはどういう意味？ 間をおかずに続けて処理すれば無意味ですよね。 Enterを押す度に次の文字をコピーするのなら、 set /p <NUL="山"|clip set /p ="川"|clip set /a ="谷"|clip 10秒ごとにコピーするなら、 set /p <NUL="山"|clip timeout /t 10 set /p <NUL="川"|clip timeout /t 10 set /a <NUL="谷"|clip
こんにちは。 >i = nyuryokubox()　　 この部分は、いずれにしても、参照できませんね。 おそらく、既存のTextBpxで、ボタンで生成するTextBoxの数でしたら、nyuryokubox.Value や.Text　プロパティだと思います。それは、配列です。 > For i = 1 To i i は、ループのカウンターに使っているのですから、i 自体は、数値型で、To (定数)ですから、別の変数(例：j = nyuryokubox.value として、For i = To j など)にしないと、ループは完成しません。初歩的なミスだと思います。 それから、TextBoxのプロパティ等を調べてみましたが、マクロから、オブジェクト名を変更できなかったようですから、D1.Text は使えませんね。 Controls("D1").Text　等でしかないようです。 登録_Click() Dim obj As Object Dim i As Long 　　With Worksheets("keyplan") 　　　　For Each obj In Me.Controls 　　　　If obj.Name Like "D#" Then 'Dの付いた名前を探す 　　　　　i = i + 1 　　　　 .Cells(30, i + 3).Value = Controls("D" & i).Text 　　　　End If 　　　　Next 　　 End With 　End Sub
こんにちは。 >S:\未完成\data\DA00001146.xls　'8-3型ではない 質問に書かれたコードは間違いないはずですが、実際にうまくいかない場合、ロング・ネームになっていたり、空白が入ったりした場合、 """C:\Users\UserName\My Documents\Excel\経理\""" のように、「""」で、くくってあげなくてはなりません。
まずは、VB.NETでの配列の正体を知っておいた方がよいでしょう。 http://msdn.microsoft.com/ja-jp/library/dd314345 … 特に > 3-3-3 参照型としての配列変数 から下をよく読んで理解してください。 > Dim Hairetsu() As String は、Stringの配列を覚えることができる変数Hairetsuを用意するだけで、配列の実体は用意されません。 上記URLの「図 3-11 Nothing が代入されるのは、あくまで配列変数 D 自体」が近い状態です。 この図の「配列の実体」が最初から存在しない、というものです。 > Public Sub aaa(ByRef a() As String) > a(0) = "Test" '←正常の場合と、エラーの場合 ※ 念の為、仮引数の名前を変えました。 このsubを aaa(Hairetsu) と呼び出した場合、 Hairetsu() しただけの場合は、a = Nothing となっています。 よって、 a(0) は Nothing(0) ということになり、そんなものは無いのでエラーになります。 ※ エラーメッセージはちゃんと読みましょう。 ※ 質問するなら、ただ「エラーになります」では対処しようがありません。 ※ 正確なエラーメッセージを記載るようにしましょう。 ※ 例えば、そのエラーは ※ 「 NullReferenceException "オブジェクトのインスタンスを指定する必要がある部分に null 値が指定されています" 」 ※ とか表示されていませんでしたか? 対策ですが、いくつもあるので、目的によって選択することになります。 ○ aaa内で Nothingだったら処理を中止するようなコードにする 例) if a is Nothing then exit sub ○呼び出し元で、Hairetuをredimしてからaaaを呼び出す。 ○aaa内でredim する。仮引数aはByRefになっているので、呼び出し元の変数が変更される。 　※ なお、参照型の特性として「a(0) = "Test" 」だけなら、ByVal a でも同じ「配列の実体」にアクセスすることになります。 ○ sub aaaではなく、 function aaa() as String() 等といった配列も返す関数にする ○ List(of T) 等の可変長で配列っぽく使えるクラスを使う
例外は登録されていないエラー種別なので、厳密には何が起きているか判りません。 ただ、Callで起きる場合の大半は型があっていないことが原因なので、 引数か関数そのもの型を確認してキャストしてみてください
#2の回答者ですが、 VBAとはいうものの、何のVBAか分かりませんでしたから、あくまでも、Excelを想定していました。 >同項目が１０個あり、延べ労働時間の合計を表示するところも作りました。（textbox6) この件については、数とTextBoxの関係が、良く分からなかったせいもあるのですが、私の場合、それぞれの合計値を、モジュールスコープの変数を増やしておけば可能です。 私の場合は、TextBox4の入力で自動計算させるように出来ていますが、そうでない場合は、ボタンに切り替えればよいです。計算式は、TextBox4の中にあります。 >１行の計算が出来たのですが >他９行の計算式は回答ただいた式をコピーして『textbox』数字を変更していけばよろしいのでしょうか？ 私は、他人のコードの解説はしませんが、もし、「Excel」でしたら、一旦、ワークシート側のセルで計算させて、そのセルの計算値を、Textプロパティで拾い上げるようにしたほうが、複雑にならなくてよいかもしれません。確か、Excelでは、セルとリンクさせることが出来たと思います。 あくまでも、ひとつの提案です。
こんにちは。 一応、画像を見て作りましたが、条件が違っていたら、以下のコードは動きません。 A.xlsm 側のファイルの拡張子は任意（画像では読み取れません)ですが、B.xlsmは、マクロ搭載ですから、xlsmの拡張子になります。こちらは、Excel 2010 で開発しましたが、別のブックでは、Findメソッドがまったく検索できないようでしたので、やむを得ず、ワークシート関数のMatchを使いました。 また、A.xlsmの[総括]シートの日付欄は、A:B列連結になっている必要があります。 他には、B.xlsm のシートのそれぞれのCommandButtonは、必ず、A列の[日付セル]よりも行として上に出てはいけません。例えば、[1月1日]は、A3から始まっていますから、少なくとも、CommandButtonは、C3の上辺より下になくてはなりません。その位置で、A列の日付を読取ります。 '//B.xlsm のSheets(1)のマクロコードです。 Private Sub CommandButton1_Click() 　Call ButtonProgs(CommandButton1) End Sub Private Sub CommandButton2_Click() 　Call ButtonProgs(CommandButton2) End Sub Sub ButtonProgs(obj As Object) Dim i As Variant Dim j As Long Dim c As Variant j = obj.TopLeftCell.Row Set c = Cells(j, 1).MergeArea.Cells(1) m = c.Address With Workbooks("A.xlsm").Worksheets("総括")　'ブック名に注意 　i = Application.Match(c, .Columns(1), 0) 　　If IsError(i) = False Then 　　　c.Offset(, 1).Resize(5, 2).Copy .Cells(i + 1, 1)　'コピー　5行の設定になっています。 　　Else 　　　MsgBox Format(c.Value, "mm/dd") & " が見つかりません。", 48 　　End If End With End Sub '//
こんにちは。 >できればVBAコードを入力して自動実行したいのですが。 ふつうは、タスクスケジューラーで、オートメーションにして組みますが、そうでなければ、OnTimeメソッドを利用します。ただ、Excelは開きっぱなしになりますが、できないわけではありません。 しかし、私自身などは、手動でタスクスケジューラーを設定しますが、コマンドプロンプトのATコマンドを使うことも可能です。その時に、現在開いているExcelとぶつからないために、Excelとは別にオートメーションにして、立ち上げた時に、マクロ（モジュール)を呼ぶようにしてます。標準モジュールが分離してしまうはずですから、ThisWorksheetなどのオブジェクトモジュールにするか、コードを呼び出しするか、どちらかに作ります。 ですから、バッチよりも、VBScriptなどで、立ち上げ自体はプログラムをくんだほうが安全です。 手数は複雑に見えますが、わかっている人なら、意外に簡単に出来てしまいます。 問題点は、ほとんどありませんが、土日や祭日は動かないようにすることも必要です。（パソコンが動いている限りですが。) スケジュール(タスク)を登録する http://officetanaka.net/other/extra/tips14.htm なお、文末の田中氏の疑問は、Userと管理者モードの違いだと思います。実行ファイルは、Excelファイル直接ではなく、VBScriptで組んでしまえば、まったく問題は出ません。
音を消すには TextBoxのKeyPressイベントにて Private Sub TextBox2_KeyPress(sender as Object, e as KeyPressEventArgs) Handles TExtBox2.KeyPress 　　if e.KeyChar = vbCr then 　　　　e.Handled = True 　　End if End Sub を記述します TextBox2のMultiLineを Falseに設定して見ましょう MultiLineがTrueで質問のコードだと 前回入力した 改行文字(vbCrLf)が TextBox2に残っているために 文字列『3』と文字列『vbCrLf＋3』では 同じでないので『不正解』が表示されているのです
mitarashiです。シリーズで回答させていただきながら、当方も勉強してきましたが、そろそろ追い越されそうな雰囲気ですね。お望みの事は分かりかねます。検索して見つかるのは、32bitカラーのGraphicsを質問文中にもあるGdipCreateBitmapFromScan0で作成した32bitのbitmapから作成する方法です。 myumyu1234さんが行われているのは、個々のPixelの透明度の変更の様なので、GdipBitmapLockBitsをお使いなのでしょうか。 回答にはなっておりませんが、前回のhttp://oshiete.goo.ne.jp/qa/8880161.htmlへの回答のコードがどうも分かり難いと思っていましたが、どうやら冗長らしいので、その部分を修正し、24->32bitへの変更も盛り込んだコードを投稿させていただきます。 なお、32bitをサポートしているPNGでの保存に変更しています。 構造体、API宣言は、下記が追加になります。 Public Const CLSID_PNG As String = "{557CF406-1A04-11D3-9A73-0000F81EF32E}" Public Declare Function GdipGraphicsClear Lib "gdiplus" (ByVal graphics As Long, ByVal lColor As Long) As Long Sub test() Dim IID_IDispatch As GUID Dim udtInput As GdiplusStartupInput Dim lngToken As Long, lngStatus As Long Dim pGraphics As Long Dim pSrcBmp As Long, pDstBmp As Long Dim lngWidth As Long, lngHeight As Long Dim srcPath As String, dstPath As String Const myDpi As Long = 300 srcPath = GetDesktopPath & "\sample1.jpg" dstPath = GetDesktopPath & "\sample2.png" ' 初期化 udtInput.GdiplusVersion = 1 If GdiplusStartup(lngToken, udtInput, ByVal 0&) <> 0 Then Exit Sub End If ' 画像の読みこみ If GdipCreateBitmapFromFile(ByVal StrPtr(srcPath), pSrcBmp) <> 0 Then GdiplusShutdown lngToken Exit Sub End If ' 元画像サイズの取得 GdipGetImageWidth pSrcBmp, lngWidth GdipGetImageHeight pSrcBmp, lngHeight ' コピー先Bitmap作成 lngStatus = GdipCreateBitmapFromScan0(lngWidth, lngHeight, 0, PixelFormat32bppARGB, ByVal 0&, pDstBmp) 'dpiの指定 lngStatus = GdipBitmapSetResolution(pDstBmp, myDpi, myDpi) If lngStatus = 0 Then ' コピー用Graphics作成 If GdipGetImageGraphicsContext(pDstBmp, pGraphics) = 0 Then '白で初期化（検索してみつかったコードは大抵含んでいたので追加） GdipGraphicsClear pGraphics, &HFFFFFFFF ' イメージのコピー GdipDrawImageRectI pGraphics, pSrcBmp, 0, 0, lngWidth, lngHeight 'Graphicsの始末 GdipDeleteGraphics pGraphics 'PNGで保存 Call GdipSaveImageToFile(pDstBmp, StrPtr(dstPath), ConvCLSID(CLSID_PNG), ByVal 0&) End If GdipDisposeImage pDstBmp End If GdipDisposeImage pSrcBmp GdiplusShutdown lngToken End Sub
Navigate メソッドで呼び出したページの読み込みが完了する前に 内容を取得しようとしているからです。（Navigate メソッドは ページの取得要求を出したら、ページが実際に取得されるのを待た ずに即処理が返ってくる仕様です） よって『ページが取得されるのを待つ処理』を、きちんと自分で 実装しないとうまく動きません。SHDocVw.InternetExplorer の ReadyState プロパティについて調べてみてください。 ※ なお、VB.NET での IE 利用であれば、SHDocVw ではなく 　 WebBrowser クラスのほうが使いやすいですよ。
正規表現の例 Dim 正規表現 As Object Dim 項目集合 As Object Dim 項目個別 As Object Dim 文字列 As String '★テスト用の文字列を設定 文字列 = " AAA BBB" & vbTab & "CCC PP" '★正規表現のインスタンス化 Set 正規表現 = CreateObject("VBScript.RegExp") '★プロパティの設定 正規表現.Global = True 正規表現.Pattern = "\S+" '★正規表現による項目集合の作成 Set 項目集合 = 正規表現.Execute(文字列) '★項目集合から個別項目を順次処理する For Each 項目個別 In 項目集合 　　'★個別項目を表示 Debug.Print 項目個別.Value Next プロパティの意味 1.Global 　文字列全体を処理するかどうかを決める。 　Trueにすると全文字列を処理する。 　Falseにすると、最初に一致した文字列を処理して 　終了する。 2.Pattern 　正規表現の本文 　"\S+"は「空白(タブも含む)でない1個以上の文字列」 　と言う意味です。漢字の空白も含めるたい時は 　"[^　\s]+"となります。後者の意味は「漢字空白、及び 　空白(タブも含む)以外の1個以上の文字列」です。 　これで分かるように”\S”と”\s”は反対の意味になっています。 　また、"[]"は「内部の文字のいすれかに該当」ということで、 　”[]の^”は否定を示します。"+"は「1個以上」ですね。 　
こんにちは。 A1セルクリックのみカレンダー表示するには > If Target.Count <> 1 Then Exit Sub > ' A列以外は無視(今回サンプルの例) > If Target.Column <> 1 Then Exit Sub この代わりに、以下を入れればよいのではないでしょうか。 If Target.Address <> "$A$1" Then Exit Sub
こんばんは！ 一例です。 Sheet1のシートモジュールにしてください。 （Changeイベントにしています） Private Sub Worksheet_Change(ByVal Target As Range) Dim c As Range, wS As Worksheet Set wS = Worksheets("Sheet2") If Target.Address = "$A$1" Then Set c = wS.Range("B:B").Find(what:=Target, LookIn:=xlFormulas, lookat:=xlWhole) If Not c Is Nothing Then c.Offset(1, -1).Resize(3, 3).Copy Range("A2") Else MsgBox "該当データなし" End If End If End Sub こんな感じではどうでしょうか？m(_ _)m
こんばんは。 これは、CurrentRegionで、囲まれる四角の中のデータを出力するものです。 出力場所は、Excelのデフォルト・フォルダか、マクロを動かしているファイルのフォルダーです。 出力ファイル名は、「Output.txt」 例えば、こんな風にすることです。不具合があれば、また考えます。 '// Sub Test1() 　Dim rng As Range 　Dim fNo As Integer 　Dim r As Variant 　Dim c As Variant 　Set rng = Range("A1").CurrentRegion 　'rng.Select '範囲の確認用 　fNo = FreeFile() 　Open "Output.txt" For Output As #fNo '<--FreeFile()から。 　For Each r In rng.Rows 　　For Each c In r.Cells 　　　buf = buf & "," & c.Text　'<-このように、Textプロパティを使います。セパレータは「,」カンマ区切り 　　Next c 　　Print #fNo, Mid(buf, 2) 　　buf = "" 　Next r 　Close #fNo End Sub '//
こんにちは。 返事が遅くなりました。 マクロ自体は早速作ってしまったのですが、オヤっと思って、確認の必要がありました。 そして、そのままになってしまい、申し訳ありません。 使い方としては、必要な場所を、まず範囲設定してから、以下のマクロの実行をすれば、前にあった罫線などは削除されて、新たに線を引きます。ポイント（角)という考え方ではなく、あくまでも、セル（連結を含む)部分の左下と右上を結ぶように出来ています。実務的には、右クリック・イベントに設けるのが一番便利かと思います。 '// Sub TestLine() Dim shp As Shape 　For Each shp In ActiveSheet.Shapes 　　If Not Intersect(Selection, shp.TopLeftCell) Is Nothing Then 　　　 shp.Delete 　　End If 　Next 　Call SetLine(Selection) End Sub Function SetLine(rng As Range) Dim Lf As Double, Tp As Double, Wd As Double, Ht As Double Dim x1 As Double, y1 As Double, x2 As Double, y2 As Double With rng 　 Lf = .Cells(1).Left 　 Tp = .Cells(1).Top 　 Wd = .Cells(1, .Columns.Count + 1).Left - .Cells(1).Left 　 Ht = .Cells(.Rows.Count + 1, 1).Top - .Cells(1).Top End With 　x2 = Lf + Wd: y2 = Tp 　x1 = Lf: y1 = Tp + Ht With ActiveSheet.Shapes.AddLine(x1, y1, x2, y2).DrawingObject 　　.ShapeRange.Fill.Visible = msoFalse 　　.ShapeRange.Line.Weight = 0.75 　　.ShapeRange.Line.DashStyle = msoLineSolid 　　.ShapeRange.Line.Style = msoLineSingle 　　.ShapeRange.Line.Transparency = 0# End With End Function '//
まとめファイルに以下のマクロを書いて実行します。 ・店舗ファイル名は　「店舗1.xls～店舗19.xls」としてます（数字は半角)。 ・店舗ファイルとまとめファイルは同一フォルダにある、とします。 機能 各店舗ファイルの中の全シートを参照し、まとめファイルの同一名シートにコピーします。 Sub Macro1() Dim WSname As String Dim i As Long, j As Long For i = 1 To 19 Workbooks.Open Filename:=ThisWorkbook.Path & "\店舗" & i & ".xls" For j = 1 To Worksheets.Count WSname = Worksheets(j).Name 　　　　　　On Error Resume Next Worksheets(WSname).Range(Cells(59, i + 2), Cells(68, i + 2)).Copy Destination:=ThisWorkbook.Worksheet(WSname).Range(Cells(59, i + 2), Cells(68, i + 2)) Next j ActiveWorkbook.Close SaveChanges:=False Next i End Sub
昔のことでうろ覚えですが、xl2003以前でグラフの系列にワークシートを介さないで値を設定する際に、データ数の制約回避のために、どこかで見つけて来て使った事があります。 http://oshiete.goo.ne.jp/qa/6368497.html #4で、 For i = 1 To rs.RecordCount arrayX(i, 1) = rs.Fields(1) arrayY(i, 1) = rs.Fields(2) rs.MoveNext Next i ThisWorkbook.Names.Add Name:="Date", RefersTo:=arrayX ThisWorkbook.Names.Add Name:="Rate", RefersTo:=arrayY てな事をやっています。 時間もないので詳しく見ておりませんが、ご参考まで。
vbacを使うとか。 「いげ太の日記: Ariawase v0.6.0 解説（vbac 編）」 http://igeta-diary.blogspot.jp/2014/03/what-is-v …
こんにちは。 >このマクロを使用してまとめたシートの数値の部分……（中略)……を変更するとコピー元……の数値も同じように変わるというものを作りたいです。 できそうな気はするのですが、なんとなく釈然としない部分も残ります。 ご自身は、まだ、マクロの実力は初級レベルだと思います。ご自身が後先考えないで作り上げてしまった後で、その先は、こうしたいけれども、どうしたらよいか振れられても、こちらが、最初から作るならともかく、付け足しでは格好が付かないのです。掲示しているマクロは、あまり意味をなしません。 >いろいろと調べましたが手も足も出ませんでした。 手も足も出ないのではなく、そういうのはなかった、ということではありませんか？ イベント(Worksheet_Change)か、元データの各々の範囲を、名前登録しておいて、位置関係を明確にして処理するということは想像つきますが、コピー先のデータから、元データを変更するのは、かなり特異な常識的ではない考え方だなって思います。 それから、 > Sheets(1).Columns("C:D").Delete > Sheets(1).Columns("F:G").Delete > Sheets(1).Columns("G:O").Delete これは、本来は、列を非表示程度にすればよいのですが、削除してしまっていますから、元のデータからの位置関係を壊すことになるだろうな、と感じました。 今のところ、私がみた雑感程度にしかコメントできません。お役に立てなくてすみません。
#3の構造体、API宣言等です。 Public Type GdiplusStartupInput GdiplusVersion As Long DebugEventCallback As Long SuppressBackgroundThread As Long SuppressExternalCodecs As Long End Type Public Type GUID Data1 As Long Data2 As Integer Data3 As Integer Data4(0 To 7) As Byte End Type Public Type EncoderParameter GUID As GUID NumberOfValues As Long Type As Long Value As Long End Type Public Type EncoderParameters Count As Long Parameter(15) As EncoderParameter End Type Public Const CLSID_JPEG As String = "{557CF401-1A04-11D3-9A73-0000F81EF32E}" Public Const CLSID_QUALITY As String = "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}" Public Declare Function GdipCreateBitmapFromFile Lib "gdiplus" _ (FileName As Any, bitmap As Long) As Long Public Declare Function GdipCreateBitmapFromGraphics Lib "gdiplus" _ (ByVal Width As Long, ByVal Height As Long, _ ByVal Target As Long, bitmap As Long) As Long Public Declare Function GdipDeleteGraphics Lib "gdiplus" _ (ByVal graphics As Long) As Long Public Declare Function GdipDisposeImage Lib "gdiplus" _ (ByVal image As Long) As Long Public Declare Function GdipDrawImageRectI Lib "gdiplus" _ (ByVal graphics As Long, ByVal image As Long, _ ByVal x As Long, ByVal y As Long, _ ByVal Width As Long, ByVal Height As Long) As Long Public Declare Function GdipGetImageGraphicsContext Lib "gdiplus" _ (ByVal image As Long, graphics As Long) As Long Public Declare Function GdipGetImageHeight Lib "gdiplus" _ (ByVal image As Long, Height As Long) As Long Public Declare Function GdipGetImageWidth Lib "gdiplus" _ (ByVal image As Long, Width As Long) As Long Public Declare Function GdipSaveImageToFile Lib "gdiplus" ( _ ByVal image As Long, _ ByVal FileName As Long, _ ByRef clsidEncoder As GUID, _ ByVal encoderParams As Any) As Long Public Declare Sub GdiplusShutdown Lib "gdiplus" _ (ByVal token As Long) Public Declare Function GdiplusStartup Lib "gdiplus" _ (token As Long, pInput As GdiplusStartupInput, _ pOutput As Any) As Long Public Declare Function GdipBitmapSetResolution Lib "gdiplus" (ByVal bitmap As Long, ByVal xdpi As Single, ByVal ydpi As Single) As Long Public Declare Function CLSIDFromString Lib "ole32.dll" ( _ ByVal lpszCLSID As Long, _ ByRef pCLSID As GUID) As Long
こんにちは。 全体像が書かれていない中で、途中の抜き出しで質問だから、なかなか口を挟みにくいのですが、#1～#3さんの回答とそのご質問者さんの反応をみていて、 「スマートな方法」というリクエストは、私には、抽象的でよく理解できませんが、VBAは、中身を見せることがありませんから、それなりに動けばよいような気がします。コードで、Coolと言わせるなんて、並大抵ではありません。 >wordのマクロだと >"[\(]([0-9]{1,2})[\)]" まあ、それは、正確にはWordのマクロではなく検索コマンドの一部ですが、Excelでは、必要とあれば、正規表現を使いますね。途中まで書いて、読み落としていたのですが、配列に入れるわけですね。 '// Dim buf As String Dim myArray() As String Dim i As Long Dim Matches As Object Dim Match As Object i = -1 buf = "ログソース" With CreateObject("VBScript.RegExp") 　.Pattern = "\shref=""(http:[^""""]+)"　 　'パターンの正しい方法は知らない。以前、最短マッチ法の指摘はされたけれど、VBScriptではやっぱりうまくない。 　.Global = True 　.MultiLine = True 　Set Matches = .Execute(buf) 　For Each Match In Matches 　 i = i + 1 　 ReDim Preserve myArray(i) 　　myArray(i) = Match.SubMatches(0) 　Next Match End With '// でも、一つだけ取り出すつもりなら、狙いを定めた後は、実際、Instr 関数や　Mid 関数の方が楽ではないかな。だから、使い方によっては、Splitで大雑把に切っておいて、そこにHTTPアドレスが一つであるなら、後はループすれば、以下でも有効のはずです。実際、その方が多いかもしれませんね。 i = InStr(1, buf, "href=""http", vbTextCompare) j = InStr(i + i + Len("href="""), buf, """") PickUP = Mid(buf, i + Len("href="""), j - i - Len("href=""")) この通り3行で足りてしまうのです。
>結局のところ、VBAでやるなら全てのテキストデータを一度配列に読み込ませた後に、 >replace関数で全ての文字列を置換後に再度テキストデータとして >出力するしかないということでしょうか？ VBAに限らず置換前と置換後のバイト数が異なるなら一度読み込んで出力し直すしかありません。
見えている部分で \\u3084\\u307e\\u3060\\u305f\\u308d\\u3046 ↑ これが”やまだたろう”（UTF-16のコード） なので ”あいうえお”があるとすると \\3042\\3044\\3046\\3048\\304A ↑ こんな感じの表示になっていると思う
EnableEventsはOn,Offの操作でするのがよさそうですね。noname#157639
hyokoyamaさん はじめまして。 単純に基本的なことが理解できていないかと思います。 「objIE.Document」とは何かの値を返すと思っているのでしょうか？ 　※InStr(1, objIE.Document, "Market")　という命令なので 　　おそらくHTMLの文字列をイメージしているのだと思います。 「objIE.Document」はIEオブジェクトのドキュメントクラスです。 クラスなのでメソッド・プロパティが使用できます。 hyokoyamaさんがイメージした【HTML】を取得したいのなら 　objIE.Document.body.innerHTML で取得できます。 その他にも 　objIE.Document.body.innerText　にすると表示する文字列だけ取得できます。 よってプログラムの修正は以下のようになります。 　MarketPosition = InStr(1, objIE.Document, "Market") 　DollarPosition = InStr(marketPosition, objIE.Document, "$") 　ActiveCell.Offset(0, 6) = Mid(objIE.Document, DollarPosition + 1, 4)　 　　　　　　　　　　　　　　　↓ 　MarketPosition = InStr(1, objIE.Document.body.innerHTML, "Market") 　DollarPosition = InStr(marketPosition, objIE.Document.body.innerHTML, "$") 　ActiveCell.Offset(0, 6) = Mid(objIE.Document.body.innerHTML, DollarPosition + 1, 4)　 試してみて下さい。
スタイルシートを利用していてもtextareaのタグが存在するはずですが 具体的に何処のサイトの何処に対しての処理を行いたいかの提示はムリですか？
MVCでいえばViewにあたるFormにModelの役割もさせようとしてるのが、そもそもの間違いかと。 データはModelに持たせておいてFormの初期表示時にはModelを参照して表示、キャンセル時も同様。
1秒程度であれば、BackgroundWorkerを使う必要はない Label2.Visible=True Label2.Refresh()　'Label2を描画 '1秒かかる処理 Label2.Visible=False
ネットワークドライブに置いているソースのフォルダにある ビルドされたＷＥＢシステムの「dll」ファイルがあると思いますが それを　右クリック　→　プロパティ　と開いて 「ブロックを解除する」 で改善されるか試してみてください もし改善されても新たにソースに変更を加えるたびに デバッグで同じ症状がでるようであれば 毎回ブロック解除するか ポリシーレベルでの対策をしなくてはいけないかもしれません
どちらも一緒で、省略するかしないかの違いかと。 あえて入れる理由としては、変数が配列であることを意識しやすくなるためかと。
Visaul Studio .NET にはそのような機能はありません。 バックアップ目的などでプロジェクトを複製したい場合は エクスプローラでプロジェクトフォルダごとコピーするのが 常套手段です。
こんにちは。 >何故でしょうか… 1. .Pattern = "^【[(1)-(20)](\d*/\d*)" この中で、エラーが起きています。 #1の方も書いていらっしゃいますが、「(1)-(20)」の意味が分かりません。 ついでに、「(\d*/\d*)」も論理的には、(\d+/\d+)　になるのではないかと想像しています。 ・被検索値の数例を挙げてください。それを見ない限りは、分かりません。 2. If ans > 0 Then オブジェクトは、数値ではありませんから、ans.Count になります。 　If ans.Count > 0 Then 3．If Len(ans(0).submatches(0)) > 0 Then 基本的には、これはいらないはずです。文字列を検索してヒットしたものですから、If ans.Count >0 で済んでいます。
方法はいくつか挙げられます (1)について 横に広がる幅がある程度決まっている場合 　・クラスまたは構造体を作る 　　　内容もほぼ決まっているなら構造体作って、構造体のコレクション作ってそこにぶち込めば操作は楽かと 　　　インターフェイスを作るのが手間ですが、作ってしまえばメンテナンスも楽です 　・事前に配列を確保してしまう 　　　配列の確保だけでメモリを食います。まだコレクションの中にコレクションを作る方がマシかも 横に広がる幅が不定、または大きい場合 　データ構造自体に難があると思います。 (2)について 　Object型の配列変数を作り、そこに(1)の値をループでセットし 　そのRangeオブジェクトをシートに渡せば良いです。 　ループを使わずに、となると最初からObject型で扱えば書き込み先のサイズと一致していたら問題は出ないはずです (3)について 　(1)のクラス・構造体・コレクションでループで特定の要素のみクリア・・で済みます 質問の(1)にあるようなコード（配列を広げた際に条件判定して値を入れている）を見るに データ用のクラスを作成するのが一番良いかと
VB6のサンプルを見て分からない、ということは言語を変えた所で実現させるのは非常に困難な可能性大です VB(VBA)の知識が無いという前提で回答すると http://www.asahi-net.or.jp/~ef2o-inue/vba_k/sub0 … 上記URLで基本的なインターフェイスの作り方は書いてあるので 作った箇所にしたい処理を作るだけで良いです。 セルの値取得や、値をバイトに変換等は検索すれば山ほどサンプルコードが出てくるので割愛します。 やること自体は、単純なAPIプログラミングです。 公式にあるサンプルコードがAPIの宣言とか一通り書いてくれているので、そのまま利用するだけ ざっくり書きましたが、D2XX_Module.bas内の Public fMainForm As DEMO_EEPROM Sub Main() Set fMainForm = New DEMO_EEPROM fMainForm.Show End Sub 上記4行だけ消すなりコメントアウトし、Excelに標準モジュール作って貼り付ければ下準備はできています。 あとは自分のやりたい処理を書くだけです。 まったく別のデバイスにはなりますが、Excelでやるというニッチなサンプルとして http://www.contec.co.jp/product/special/pcmeasur … こういうのがあります。デバイス自体別モノですが、処理の仕方は似ていますし Excelでのインターフェイスは参考になるかと思います。 また、便宜上マイコンと呼びますが、マイコンの処理の手続きが分からない場合は 付属のプログラミングガイドを読んでください。 VBもマイコン制御の知識も両方無い場合は、イチから全て誰かの手助けが無いとできない状態と等しく 回答しようがありません。
こんにちは もしご質問の内容が、詳細を知られたくなくて簡略化したものでなければ 【SQL文1】 SELECT A,B,C FROM テーブル１ WHERE 条件文１ DB1 = SQL文1の実行結果 【SQL文2】 SELECT A,B,C FROM テーブル１ WHERE 条件文２ DB2 = SQL文2の実行結果 をまとめて、 【SQL文1】 SELECT A,B,C FROM テーブル１ WHERE 条件文１ OR　条件文２ DB1 = SQL文1の実行結果 とすれば、どちらかの条件に当てはまるものを一括で取り出せます。
No2です。 書き忘れてましたが以下の部分 Range("A1").Offset(cnt, 0).Value = Obj.GetFolder(f).Name Offsetを利用してますが、何か特別に理由がなければ(以下ご存知かもしれませんが) 処理速度の速い順(といっても、操作を100万回実施して秒単位での差だったりするようですが) A列指定の場合 Cells(cnt, 1).Value←右側の引数は、1はA列、2はB列というように列を数値で表します。変数でもOKです。 Cells(cnt, "A").Value Range("A" & cnt).Value←この書き方は悪評を買ったりしてます。 といった感じでOffsetを利用しなくてもセル指定に変数が使えます。 ただし、最初のcnt = 0はcnt = 1にしておかないとエラーになります。
分は nn で出力できます。 hh:mm:ss は hh:nn:ss と書くことができます。
以下、マイクロソフトより引用です。 ******************************** 解決方法 1 「現象 1」に記載されている問題を解決するには、クライアント コンピューター上のキャッシュされたバージョンのコントロール タイプ ライブラリ (エクステンダー ファイル) を削除します。ハード ディスクで ".exd" というファイル名拡張子が付いたファイルを検索し、見つかったすべての MSForms.exd ファイルを削除します。これを行うには、次の手順を実行します。 エクスプローラーで、%TEMP% フォルダーを開き、すべてのサブフォルダーで "MSForms.exd" を検索します。 そのファイルが見つかったすべてのインスタンスを削除します。これにはすべてのサブフォルダーが含まれます。 注: 次に VBA を使用するときに、新しいコントロールを使用すると、.exd ファイルは自動的に再作成されます。これらのエクステンダー ファイルはユーザーのプロファイルの下にあり、また次のフォルダーのような別の場所に存在することもあります。 %appdata%\microsoft\forms %temp%\excel8.0 %temp%\word8.0 %temp%\PPT11.0 %temp%\vbe 参考URL：http://support2.microsoft.com/kb/3025036/ja
No3です。参考までに データを削除するので、No3のコードでは念のためにシートを指定するようにしています。 (なお、A列にはyyyy/mm/dd 09:00:00のような形式のデータしか入っていないものとしてます) With Sheets("現実のシート名") とシートをシート名で指定してするようにしていますが、シートの指定にはシート名で指定する方法以外に 左端からの順番で指定する例 With Sheets(1) シート名が変わってもコードを変更しなくてもよいが、順番が変わるとコードを変更しなくてはいけない オブジェクト名で指定する例 With Sheet1 シート名が変わっても順番が変わつてもコードを変更しなくてよい。 という指定の方法があります。 詳細な説明は以下のページ(シートを開く説明ですが)を参考にしてください。 http://officetanaka.net/excel/vba/sheet/sheet01. …
「五十音順にソート」というのが漢字交じりの文字列なら、簡単にはいきません。 たとえば単純なコード比較だと「恵子」（けいこ）は「恵」（めぐみ）の後ろになってしまいます。 一般的には、漢字→かな(ローマ字)変換プログラムの「KAKASI 」を使うと思いますが、同システムをクライアントかサーバかにインストールしなければなりません。 http://kakasi.namazu.org/index.html.ja Windowsでの使用例は http://hp.vector.co.jp/authors/VA041117/ja7uhv/K … あたり
> できれば、後半の方も教えていただけないでしょうか？ 自分のトコだと動作してるみたいです。 強いて言うなら、 folPathの宣言はVariant型でないと、Namespace関数が受け取らないみたい。 1) Dim folPath As String 　　↓ Dim folPath As Variant そうすれば、Namespace関数に渡せるみたい。 2) Set objFol = objShell.Namespace("～") 　　↓ Set objFol = objShell.Namespace(folPath) と、folpathに入るフォルダ名の「\」は重ねずに、末尾にも付けない。 マイドキュメントなんかの仮想フォルダは指定不可。 3) folPath = "C:\hoge\hoge" とか？ 後は参考URLのソースをインデントや改行位置修正しただけです。 -- > irfanviewでEXIF情報を保持したまま > 再圧縮をかけたものは ちょっと、どういう操作なのか分かりません。 適当なExif情報持ったファイルが手元に無いですが、普通の画像で名前を付けて保存で圧縮率変えたものは、ファイルサイズは取得できました。 > なぜかうまくいかないのですがなぜでしょうか？ よくよく試すと、動作はするけどタイトルのみ出力され、ファイルの情報が出力されていませんでした。 見てみると、JpegExifオブジェクトに最初にファイル名渡す際に、フルパスが渡っていませんでした。 たまたま画像とExcelファイルをカレントフォルダで実行していたとかなら動作していたとか。 質問者さんの環境で、再圧縮したファイルが別のフォルダに出力されてるとかなら、タイトルのみで何も出力されないかも。 If objJpeg.InitSet(fileName) >= 0 Then 　　↓ If objJpeg.InitSet(tFolder & fileName) >= 0 Then だと、どうでしょう？
mitarashiです。ひょっとしてこういう事がご希望だったのでしょうか？新規作成をやってみました。ご参考まで。 Private Declare Function GdipCreateBitmapFromScan0 Lib "gdiplus.dll" (ByVal nWidth As Long, ByVal Height As Long, ByVal stride As Long, ByVal PixelFormat As Long, scan0 As Any, nBitmap As Long) As Long Sub make8bitIndexedBitmap() Dim GDIsi As GdiplusStartupInput, gToken As Long, pBitmap As Long Dim bmpData As BitmapData Dim lrect As RECT Dim x As Long, y As Long Dim lWidth As Single, lHeight As Single Dim buf(0) As Byte Dim strOutName As String Dim encBMP As UUID Dim paletteSize As Long Dim palette As ColorPalette Dim i As Long Dim strBGR As String Dim myARGB As Long GDIsi.GdiplusVersion = 1& GdiplusStartup gToken, GDIsi lWidth = 200: lHeight = 100 Call GdipCreateBitmapFromScan0(lWidth, lHeight, 0, PixelFormat8bppIndexed, ByVal 0&, pBitmap) lrect.Top = 0: lrect.Left = 0 lrect.Bottom = CLng(lHeight): lrect.Right = CLng(lWidth) If GdipBitmapLockBits(pBitmap, lrect, ImageLockMode.ReadWrite, PixelFormat8bppIndexed, bmpData) <> 0 Then Exit Sub End If For x = 0 To lWidth - 1 For y = 0 To lHeight - 1 buf(0) = y \ 10 MoveMemory ByVal bmpData.scan0 + (y * bmpData.stride) + x, buf(0), 1 Next y Next x Call GdipBitmapUnlockBits(pBitmap, bmpData) 'Palette設定 Call GdipGetImagePaletteSize(pBitmap, paletteSize) Call GdipGetImagePalette(pBitmap, palette, paletteSize) 'Range("A1:P16")のセルの色からPaletteの色を設定する For i = 0 To 255 strBGR = Hex(ActiveSheet.Cells((i \ 16) + 1, (i Mod 16) + 1).Interior.Color) strBGR = Right("000000" & strBGR, 6) myARGB = CLng("&H" & "FF" & Mid(strBGR, 5, 2) & Mid(strBGR, 3, 2) & Mid(strBGR, 1, 2)) palette.Entries(i) = myARGB Next i Call GdipSetImagePalette(pBitmap, palette) 'BMP保存 strOutName = GetDesktopPath & "\make8bitIndexed.bmp" CLSIDFromString StrPtr("{557CF400-1A04-11D3-9A73-0000F81EF32E}"), encBMP Call GdipSaveImageToFile(pBitmap, StrPtr(strOutName), encBMP, ByVal 0&) GdipDisposeImage pBitmap GdiplusShutdown gToken End Sub
こんにちは。 私は、別案というよりも、コーディングの基本の基本ですが、On Error トラップ（On Error Goto xx) というものは、最後につけるもので、製作中にトラップを置いたら、どこでエラーが出たか分かりません。 出来上がっている場合は、デバッグのステップインで、短い場合は、どこでマクロが飛ぶのか調べます。もしくは、ブレークポイントを段階的につけていき、どこまでは、OKか調べます。 コンパイル後に起こるのですから、[実行時エラー]だと思いますから、それなり見当はつくはずです。 もう一つ、コーディングの基本的なことですが、コードの行数は増やさずに、サブルーチンを増やすことです。一般的には、100行以下と言われています。 私は、ずっと、そのようにしてきています。
http://oshiete.goo.ne.jp/qa/8852322.html (http://oshiete.goo.ne.jp/qa/8852322.html) で回答した者ですが、実はあの#1-2のコードには前半があって、ファイルからセル色に取り込んでいるのです。その部分を投稿しますので改造して下さい。 '(2) ファイルから画像を読み込みbitmapオブジェクトに変換する If GdipCreateBitmapFromFile(ByVal StrPtr(strInName), pSrcBitmap) <> 0 Then Exit Sub End If '(3)　読み込んだ画像のサイズを取得 '画素数は480x360程度でないと、書式が多すぎるというエラーが発生する GdipGetImageWidth pSrcBitmap, lngWidth GdipGetImageHeight pSrcBitmap, lngHeight '(4)　bitmapオブジェクトから1画素ずつ読み込んで、エクセルのセルのColorに設定 'GDI+から取得する色は透明度を含むARGBであるが、セルに設定する場合はBGRに変換する必要がある Application.ScreenUpdating = False For y = 0 To lngHeight - 1 For x = 0 To lngWidth - 1 '画素の色を取り出し、文字列に変換する 'ビットシフトは面倒そうなので、スピードは犠牲にして？文字列に変換して処理 GdipBitmapGetPixel pSrcBitmap, x, y, myARGB strARGB = Hex(myARGB&) With ActiveSheet Range(.Cells(1, 1), .Cells(1, lngWidth)).ColumnWidth = 1.63 'ARGB->BGRに変換してセル色に変換 .Cells(y + 1, x + 1).Interior.color = RGB(CInt("&H" & Mid(strARGB, 3, 2)), CInt("&H" & Mid(strARGB, 5, 2)), CInt("&H" & Mid(strARGB, 7, 2))) End With Next x Next y Application.ScreenUpdating = True >これらの変数はLongとして定義されていて、 >型が配列ではないのですが >どのようにして扱えば良いのでしょうか？ ここでのimage、pDstBitmapは「ハンドル」と言われるものです。画像ファイルが読み込まれ、ビットマップオブジェクトが生成された時に、Windowsによってつけられた管理番号といった感じでしょうか。 ついでに、先のQAのARGBのオーバーフローについてですが、下記をご参照下さい。 http://support.microsoft.com/kb/189323/en-us 機械翻訳したページもありますが、よけいに分かり難いような... http://support.microsoft.com/kb/189323
No.4です。 ＞ただ、○○町という住所の管轄はA支店とB支店両方という場合があります。 というコトですので・・・ 前回と同じような方法ですが、Sheet2の表の作り方次第でコードは変わってきます。 Sheet2の表は↓の画像のような感じにしてみました。（最大2つの支店としています） 今回もSheet2の表はA列の文字数の昇順に並び替えをしておいてください。 （○○町と東○○町といった感じの町名を区別するため） 標準モジュールです。 Sub Sample2() Dim i As Long, lastRow As Long, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") Application.ScreenUpdating = False lastRow = .Cells(Rows.Count, "A").End(xlUp).Row For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row .Range("A1").AutoFilter field:=2, Criteria1:="*" & wS.Cells(i, "A") & "*" If .Cells(Rows.Count, "A").End(xlUp).Row > 1 Then Range(.Cells(2, "C"), .Cells(lastRow, "C")).SpecialCells(xlCellTypeVisible).Value = _ Trim(wS.Cells(i, "B") & " " & wS.Cells(i, "C")) End If Next i .AutoFilterMode = False Application.ScreenUpdating = True End With End Sub こんな感じではどうでしょうか？m(_ _)m
>12月10日（水）の更新後、Excel2013ではActiveXコントロールのコマンドボタンが使用できなくなったと思いますが < これは当方は対処済みなので、ほぼ普通に使えているつもりです。 セルに入力できるということは UserForm1.Show vbModeless になっているわけですね。 doeventsを入れてみたらどうでしょう。 それともまだ対処していない状態での話なのですか。 　 セキュリティ面のことで使用できなくされたらしいのですが 私の場合は C:\Users\○○\AppData\Local\Temp　の中を削除したら普通に使えるようになりました。 セキュリティ面は・・・・・・気になりますが使えないのも困るので・・・。
回答No.1 です。 ○effect 引数, AllowedEffects というのはどのように 　して使うのでしょうか？ ここから先は私もサンプル組んで検証しないことには 何とも言えません。しかし、私としてもこれ以上は時間を 割きにくいので、これで私はギブアップにさせてください。 なお、回答No.3さんのアドバイスも問題解決案としては 魅力的なアイディアですよ。
確認ですが、 トランザクションを掛けているConnectionはcn インサートを行っているConnectionはcneになっていますが これは投稿時の間違いですか？
こんにちは 質問者さまと同じ環境で同じ不具合が発生しましたが 以下のQAの内容で解決しました。 http://oshiete.goo.ne.jp/qa/8854280.html
忘れてました。 > ４．受信内容をラベルに表示 新しいデータを表示する度にラベルをrefreshしていますか。
EXCEL等で 000　　　"000"　　　000,000　　　"000,000 と言う文字列データを入力してCSVに書き出すと 000,"""000""","000,000","""000,000" と言うCSVファイルが出力されます。 これを取り込んだ場合、データは 000　　　"000"　　　000,000　　　"000,000 の４つにならなければなりません。 ＞今は、「000」で取得しているのを、 ＞ 「"000"」で取得したいのです。 では、CSVファイルに「"""000"""」って書かれていたら、つまり、EXCELで「"000"」と言う文字列を入力していたら、どういう文字列になるべきか、考えてみましょう。 正解は「"000"」でしょうか？それとも「""000""」でしょうか？ 単純に ＞'配列に格納 ＞stArrayData = Split(データ, ",") では「データとしてカンマを入力したとき」に正常に動作しません。 http://excel-ubara.com/excelvba5/EXCEL111.html の最初のサンプルも「データの中の"や,を考慮してないサンプル」であり、貴方のプログラムと同じで、正常に動作しません。 同じページの２番目のサンプルが「データの中の"や,を考慮しているサンプル」で、この２番目のサンプルのように作らないと、データを正常に読み込めません。 EXCEL等で 000　　　"000"　　　000,000　　　"000,000 と言う４つの文字列データを入力してCSVに書き出して 000,"""000""","000,000","""000,000" と言うCSVファイルを作り、このCSVファイルを読み込んで、元通り４つの 000　　　"000"　　　000,000　　　"000,000 と言うデータが取り込めれば「正常」です。 もちろん「自分で勝手に”を付け足す」なんて事はやってはいけません。 そんなことをしたら、元々のデータに”があったのか、それとも貴方が勝手に付け足したのか、判らなくなってしまいます。
#1-3です。 型変換をVBAに頼り過ぎだと存じます。 真面目にやるべきでしょう。 簡単な例で試してみました。ご参考まで。 Sub test() Dim myR As Byte, myG As Byte, myB As Byte Dim myRGB As Long myR = 255 myG = 255 myB = 255 myRGB = myR & myG & myB Debug.Print Hex(myRGB) '->F36E2D7　白にならない End Sub Sub test2() Dim myR As Byte, myG As Byte, myB As Byte Dim myRGB As Long myR = 255 myG = 255 myB = 255 myRGB = CLng("&H" & Hex(myR) & Hex(myG) & Hex(myB)) Debug.Print Hex(myRGB) '-> FFFFFF End Sub Sub test3() Dim myR As Long, myG As Long, myB As Long 'Byte型だとmyR * &H10000のところでオーバーフロー Dim myRGB As Long myR = 255 myG = 255 myB = 255 myRGB = myR * &H10000 + myG * &H100 + myB Debug.Print Hex(myRGB) '->FFFFFF End Sub
CSVの場合、カンマを含むデータは「”（ダブルクォート）」で囲う事になっていますが、取り込み対象のCSVはそのようになっていますか？
>これらをスッキリさせることは可能でしょうか？？ こんな感じでは Dim OpenFileName As String Dim wb As Workbook, v(9), ret As Variant Dim GYOU As Long, i As Long, j As Long OpenFileName = Application.GetOpenFilename("Microsoft Excelブック,*.xls*") Set wb = Workbooks.Open(OpenFileName) For Each ret In Array("B4", "F4", "I4", "C9", "E8", "I9", "D12", "E11", "C14", "I14") 　　v(i) = wb.ActiveSheet.Range(ret).Value 　　i = i + 1 Next wb.Close With ThisWorkbook.ActiveSheet 　　GYOU = .Range("A" & Rows.Count).End(xlUp).Row + 1 　　For Each ret In Array(1, 4, 6, 3, 8, 28, 13, 14, 15, 16) 　　　　.Cells(GYOU, ret).Value = v(j) 　　　　j = j + 1 　　Next End With
こんにちは。 >どちらの方がメモリを使わなくて済むのでしょうか。 実際、測ったことがないので分かりません。しかし、実際の所、大きな差はでないと思います。その変数の合算だろうというしかありません。 ユーザー定義型変数とは、Type ステートメントを使うということでしょうから、要するに、個別に変数を渡す煩雑さや、その順番や独自の名前をつけることで、その変数のカテゴリの忘れを避けることだと思います。 しかし、実際には、Win32 API関数や多数のパラメータ（引数)を多く使う関数などに、ワンパッケージとして用いる場合が多いのだと思います。
＃１です。再度。 > 「Rst.FindFirst "名称コード" & " = " & "' 101 "'」という記述 そもそもこの記述は何かを参考になさってるのでしょうか。 このサイトへの転記ミスかお尋ねした部分が補足では確定してない。 転記ミスでは無いなら参考にした「何か」そのものの誤記ではありませんか？ Rst.FindFirst に続く右側（引数）ですが 必要としている条件を記述する部分です。 質問文からは「名称コードが値[101]に等しいもの」と読めます。 （101の前後に半角スペースがあるのが気になりますが） 新たな疑問ですが、「名称コード」のデータ型は何ですか？ 値そのものをクォーテーションで囲もうとしているからには 文字型（＝テキスト型）で合ってますか？ 「いや、数値型でした」だったら 条件のために値101をクォーテーションで囲む必要はなく、 ＶＢＡのコード記述のためにダブルクォーテーションで囲むだけなので Rst.FindFirst "名称コード" & " = " & "101” になります。 「はい、文字型です」なら、「クォーテーションで囲むこと」は 必要ですが、囲む文字のルールがあります。 クォーテーションとして使えるのは 「’」シングルクォーテーション（アポストロフィ）か 「”」ダブルクォーテーション のどちらか。 （他は割愛） シングル・ダブル何れの場合も「値の両端を同じもので囲む」ので 引数は「名称コード = ’101’」か「名称コード = "101”」の どちらかになります。 ところが質問で「入力できない」とおっしゃってる >「Rst.FindFirst "名称コード" & " = " & "' 101 "'」 では、両端を囲おうとしているのは「”（Shift＋2）’（Shift＋7） で囲む」ですから もし記述できたとしても実行時にはエラーになります。 動作確認をしてみて下さい。 シングルでなら >「Rst.FindFirst "名称コード" & " = " & "' 101 "'」 を Rst.FindFirst "名称コード" & " = " & "'101'” へ変更し実行。 「ダブルクォーテーションで囲いたい亅にこだわるなら 101の両端を”（Shift＋7）×３で囲って Rst.FindFirst "名称コード" & " = " & ”””101””” と変更し実行してみて下さい。 「文字列中に”を記述するには”を２回続ける」という ＶＢＡのルールがあります。 最後の&に続く９文字は 1～1 文字列記述の始まりの” 2～3 文字列中に”を表すための”” 4～6 値101 7～8 文字列中に”を表すための”” 9～9 文字列記述の終りの” で。 最後にもう一度 成し遂げたいことは 「”’101”’」（Shift+2、Shift+7、101、Shift+2、Shift+7）にこだわること なのか ＶＢＡを実行できるようにすること のどちらなのでしょうか？
XOR を使うとか。
google先生で「VB.net　VBS　戻り値」あたりで検索すると、 一番トップに参考URLのサイトが出てきたんですが、どうでしょうか。 参考URL：http://up-up-everyday.cocolog-nifty.com/wanco_pr …
こんにちは。 やってみていないので、正確な話ではありませんが、この場合は、Excelの上位互換や下位互換の話とは違うような気がします。 コードをみると、なんとなく違和感を感じます。 理由は、マージンの設定をし直しているからです。私の記憶では、一旦、シートのページを設定したら、それを動かさないようにする、というのが基本だったような気がします。 つまり、一旦、試し印刷でマージン・サイズなどを合わせたら、後はマクロでマージン等の設定をいじらないことだと思います。その設定は、ブックに残されるはずですから、そのシートを使う時には、同じ設定が使えるのだったと思うのです。むろん、マクロで設定できるに越したことはありません。 もう一つは、CentimetersToPoints　を使っていることですね。 Excelの印刷の設定というのは、VBのような物理的な設定ではなく、論理計算なので、この計算は、おそらく、丸めが発生しているはずです。InchesToPointsの方が正確なはずです。 要点をまとめると、設定そのものは、手動で設定し、2010と2007で合わせ、その後、マクロではいじらない、もしくは、各バージョンで、実際の印刷に使われた設定を用いる、ということです。 なお、細かいことですが、バージョンによって、枝番がありますから、Val(Application.Version) で数値化し分岐させます。
#2です。過分なお言葉をいただき恐縮です。 既存の楕円がちょこっと動く現象は確認できませんでしたが（当方xl2010です） Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) の中に、 Cancel = True を加える方が紛れが少ないと思います。 この場合、Wクリックによりセルが編集状態になるのをCancelする働きをします。 ご参考まで。 ＜参考＞「VBA Cancel=true」で検索すると、多数見つかります http://www.excel.studio-kazu.jp/kw/2009081222365 … イベントのカスタマイズのコードは初めてみました... http://www.ken3.org/vba/backno/vba060.html フォームを閉じるボタンのキャンセル等に使いますね
このようなマクロを組むことから考えて、一通りの使い方デバッグ等は御存知と思います。Iserrorの判定はどちらになってますか？おそらく全部エラー、つまりvlookupで該当なしになってるのかと思います。だとすると疑問点は ・在庫シートB列の商品コードと、売買明細A列の商品コードは同一？前後に半角スペースや改行コードがあるとか。 ・.Me.商品コード.Valueというのは見かけない使い方です。特別な処理をしてませんか？
＞追加情報:レポートのロードに失敗しました。 とあるので、レポートファイルのパスを間違っている可能性が高い。
こんにちは！ Excelだとして・・・ No.1さんと同じ疑問を持ちつつやってみました。 ↓の画像のようにA列1行目から文字列データがあり、B1セルに結果を表示させるとします。 ↓のコードでマクロを試してみてください。 Sub Sample1() Dim i As Long, k As Long, lastRow As Long, cnt As Long Dim str As String, buf As String Application.ScreenUpdating = False lastRow = Cells(Rows.Count, "A").End(xlUp).Row Range(Cells(1, "A"), Cells(lastRow, "A")).Copy Range("D1") Range(Cells(1, "E"), Cells(lastRow, "E")).Formula = "=LEN(D1)" Range("D1").CurrentRegion.Sort key1:=Range("E1"), order1:=xlDescending, Header:=xlNo For k = 1 To Len(Range("D1")) cnt = 1 For i = 2 To lastRow str = Mid(Range("D1"), k, 1) If InStr(Cells(i, "D"), str) > 0 Then cnt = cnt + 1 End If Next i If cnt = lastRow And InStr(buf, str) = 0 Then buf = buf & str End If Next k Range("B1") = buf Range("D:E").Clear Application.ScreenUpdating = True End Sub こんな感じではどうでしょうか？m(_ _)m
データの並んでいる行番号をmyRowにしておくので、好きな行番号を記入してください。 sub Macro1() Dim LastColumn As Long, myRow As Long Dim Txtbx1 As Long, Txtbx2 As Long, Flag As Long Dim myRange As Range Dim i As Long, j As Long myRow=2 Flag=0 LastColumn=Cells(myRow, Columns.Count).End(xltoLeft).Column For i=Txtbx1 to Txtbx2 For j=1 to LastColumn if Cells(myRow, j).Value=i then If Flag=0 then set myRange=Cells(myRow, j) Flag=1 Else set myRange=Union(myRange, Cells(myRow, j)) End if End if Next j Next i myRange.Select End sub
No.2です。 たびたびごめんなさい。 投稿後気づきました。 前回のコード内の数式はもっと簡単な数式で大丈夫でしたね。 ＞.Formula = "=IF(OR(A2="""",A2<>2),"""",""公"")" の行を ＞.Formula = "=IF(A2=2,""公"","""")" に変更してください。 どうも失礼しました。m(_ _)m
http://oshiete.goo.ne.jp/qa/7429212.html
APIを駆使したとしても 天文学的な計算で算出していることには違いが無いので 「微妙な境界線」の場合には カレンダー屋さんの悲劇は避けられません。
>使っているユーザーさんはプログラム開発とは無縁のかた でしたら １番目はユーザーさんにとってはハードルが高いかなと思います。 それに何をしでかすか分かりません。(^_^;) ３番目は現在の設定値を確認するにもVBAコードが必要です。 （１年に１回でしたらユーザーさんは（多分あなたも）マクロに書いていたのを忘れています） （あまり触らせたくない場合などには有効だとは思いますけど） なので、泥臭いかもしれませんが、 ２番目の方法が確認もしやすくて良いかなと？思います。 入力してほしいセルのバックカラーを変えておいて その近くに、入力例と簡単な説明を置いとけば・・・。 いずれの方法でも 実際に使うユーザーにもよりますが 半角/全角、西暦/和暦、桁数、などのフォーマット 適切でない年などの誤入力 ファイルの存在有無 などのチェックが必要になって来るかもです。＋シート保護とか。。。 私からは以上です。
> Disposeしないコマンド(Cmd42)の使い回しに問題はありませんか？ 動けばいいのであれば、「正常に削除・更新されます」という答えが出ていますね。 品質の観点から問題はあるでしょう。 (1)関数の外で宣言した変数を使いまわしている。 変数のスコープが適切でない。 42が意味不明。 (2)インスタンスを使いまわして、ExecuteNonQueryを4回実行している。 気持ち悪いけど、MSDNにサンプルが載っているし問題ないのかな？ 当方では、Commandのインスタンスを使いまわすことはしません。 http://msdn.microsoft.com/ja-jp/library/2k2hy99x(v=vs.110).aspx?cs-save-lang=1&cs-lang=csharp#code-snippet-1 http://ja.wikipedia.org/wiki/ソフトウェア品質
１番目の文字列を含めて色付きアンダーラインを設定してから実行すれば １文字目のものについて取得できます。 コードを書くときは適当に書いてもだめですから、 ピリオド（.）を打ってそのなかから適切なものを選択すれば下記のようにいくつかのことがわかります。 MsgBox .Font.UnderlineColor.SchemeColor MsgBox .Font.UnderlineColor.RGB MsgBox .Font.UnderlineStyle 前回のレスの通り、すべての文字について調べないといけないので面倒です。 当方はやる気がしないのでご自分で、さらにfor each を使って面倒な判定を設定して取得してください。
1つ見つかったら、「その続きから検索」すればよいのです。 InStrで先頭を見付け、そのあとの7文字を取り出したら、次は何文字目からInStrすればよいのか、わかりますね? そして、「指定した位置以降の文字列」はどうすればよいか、わかりますね(midを使っているくらいですか)? 別解として、正規表現を使って、一致する箇所全てを抽出する、という方法があります。
Call test だとだめですか？
こんにちは ＞下記のようにしてもカーソルが点滅しません。その解決方法を教えてください。 との事でございますが。 早速ですが、 以下の２点の方法を、提案させて頂きます。 +++++++++++++++++ Public Class Form1 '"指定されたウィンドウをキーボードフォーカスを持つウィンドウにする。"API 'http://nienie.com/~masapico/api_SetFocus.html のページより引用 Declare Function SetFocus Lib "user32" (ByVal hWnd As IntPtr) As Integer Private Sub Form1_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load '■この方法では失敗する。 'TextBox1.Focus() ''■方法１。TabIndexを最初にする。 'TextBox1.TabIndex = 0 '■方法２。API関数を使用する。 Call SetFocus(TextBox1.Handle) End Sub End Class +++++++++++++++++ 尚、私は、VB2008の環境にて動作確認を行っています。 なので、 他の環境や、私の勘違いで、ご希望の動作が得られなければ、 申し訳ございません。 また、コード中のコメントに示させて頂いたURLのサイト様の情報を引用しておりますので、 あわせてご覧いただけると幸いでございます。 以上 ありがとうございました。 参考URL：http://nienie.com/~masapico/api_SetFocus.html
PL/I のコメントについて軽く調べてみたところ、要するに C 言語のコメントとおなじ形式のようですから、一からプログラミングせずにフリーソフトで C のコメント削除するものを探した方が速いと思いますよ。 http://search.vector.co.jp/vsearch/vsearch.php?k … というか、上記の Vector 検索結果の中に言語を問わないコメント除去ソフトが混じってますね。 ……でも、ソース内容のヒントになるだろうにコメントをなんで除去するんだろう。開いたときにコメントとして表示されないからコード本体と見分けがつかないというなら、エディタのPL/Iファイルの拡張子に対する設定でコメントとして表示するようにしてやればいいのに……
出来ます。 全てのバーコードリーダーがそうなのかは知りませんが、当方が使ったことが有るの物はバーコードを読み込むとその値をアクティブセルに入力し、アクティブセルが直ぐ下のセルに移動しました。 つまり、キーボードから値を入力しEnterを押したのと同じ動き。 ＃最近のUSB接続の物なら恐らく同様だと思います。 これで図書IDリストを作れば、蔵書リストとの付き合せもCountif関数程度で事足りるでしょう。 丁度こんな感じです↓ https://www.technical.jp/barcode/handbook2/chapt …
こちらでは動きましたが Win7(32bit) Excel2013 Application.Run "'C:\Users\○△◇\Documents\Book1.xlsm'!Test"
スクリプトを32bit版ファイラーから試すと問題ありませんでした。 が、Explorer （64bitで動作）から試すと同じエラーになりました。 Explorer 64bit で動作 ↓ Wscript も64bitが呼ばれる ↓ ADODB の64bit版は存在しないのでエラー発生の流れかと思います。 （Win7 64bit & Office 2010 64bit でもほんの少しだけ確認） なので、 http://d.hatena.ne.jp/KenKens/20140312/1394641831 の中ほどにあるように32bit版で起動しなおすようにすれば解決するものと思われます。
格子をBitmapに描画して PictureBoxのBackgroundImageに設定して グラフのビットマップを Imageプロパティに設定すれば 希望通りになると思いますよ
うちのExcel2013では反映されるんだけどなんでかな。 後は、新しいファイルに要る分だけコピペするくらいしか思いつかない。
End Sub の前に Label1(1).ZOrder 0 を入れてみてください
参考に Option Explicit Dim objRE Dim strOpenFile Dim objFSO Dim objTextStream Dim strText Dim myMatches Dim myMatch Dim myTotal Set objRE = CreateObject("VBScript.RegExp") objRE.Pattern = "\d+" objRE.Global = True strOpenFile = "C:\**********\Test.txt" Set objFSO = CreateObject("Scripting.FileSystemObject") Set objTextStream = objFSO.OpenTextFile(strOpenFile, 1) Do Until objTextStream.AtEndOfLine = True 　　strText = objTextStream.ReadLine 　　Set myMatches = objRE.Execute(strText) 　　For Each myMatch In myMatches 　　　　myTotal=myTotal + CLng(myMatch.Value) 　　Next Loop objTextStream.Close WScript.Echo "合計 " & myTotal Set objFSO = Nothing Set objTextStream = Nothing Set objRE = Nothing
ご希望のソート順のクエリを作り、そのクエリを指定する。 DoCmd.TransferText acExportDelim, , "テーブルをソートするクエリ名", CSV_File_Full_Path
プロジェクトの読込でエラーが出ているのですから、その後なにをやっても無駄です。まともなexeが作成されるわけがありません。 ＞気にせず、OKを押し、コードの内容を変更したあと（※変更しなくても）、 プロジェクトの上書き保存をしたあと 気にしましょうよ。エラーを内包した状態でまともなexeが作成できるはずがありません。そのプロジェクトを上書き保存してしまうとエラーを許容したプロジェクトとなってしまいますのでそのプロジェクトファイルはただのゴミファイル群となり再利用も出来なくなります。 オリジナルのプロジェクトファイルを持ってきて、それが正常に開くことが最低の条件です。プログラムの修正や変更はその後の話です。 ＞GPIB、I/O、ActiveXコンポーネントの環境下 このプロジェクトを開くための環境がそのPCに整ってません。 GPIB、I/Oに関連するDLL/OCXファイルが必要ですActiveXコンポーネントはファイル以外にもレジストリへの登録が必要です。 つまり、ターゲットマシンと同じ実行環境をプログラムを変更しようとしているPCにも整えることが必要です。 具体的にはGPIB、I/Oのドライバのインストール、独自のActiveXコンポーネントがあるならそれらのレジストリへの登録。 なお、エラー無視して上書きしてしまったプロジェクトはもう使えませんので注意してください。
>あと、拡張子を抜いたパス名を取得することは可能ですか？ >("C:\xxxx\yyyy.txt") の場合 ("C:\xxxx\yyyy") >を取得したいのですが。 [例1] Dim myPath As String myPath = "C:\xxxx\yyyy.txt" With CreateObject("Scripting.FileSystemObject") 　　MsgBox .GetParentFolderName(myPath) & "\" & .GetBaseName(myPath) End With [例2]InStrRev関数を使って Dim myPath As String, n As Long myPath = "C:\xxxx\yyyy.txt" n = InStrRev(myPath, ".") MsgBox Left(myPath, n - 1)
VBA IDEにはショートカットキーのカスタマイズ機能はなさそうですね。 すでにある機能でExcelやWordの[Ctrl]Y相当の機能を呼び出すには、[Alt]E R と言うキーストロークでやるしかないのでは？
「VB Form1_DragDrop」で検索してみてください。 下記などが参考になると思います。 http://blog.livedoor.jp/akf0/archives/51252181.h …
推測による所などもあり明確な回答ではありませんが、一部について回答します。 便宜上、質問項目を上から順に番号付けて記載します。 (1)および(2)について。 Visual Studio Express 2013 には3種類のバージョンがありますが、(1)のリンク先に示される Web Developer に相当するのは「Express 2013 for Web」というバージョンです。 このバージョンを利用しているでしょうか？ # 当方はfor Webをインストールしていないので、それを使えばできるのかどうかははっきりとはわかりませんが。。 (3)について。 VBS (VBScript) を利用するのであればexeにはできません。 VBSはその名の通りスクリプトとして実行する目的のものですので、そもそもexeなどのバイナリを作らずに実行したい場合に使うものです。 exeにしたいのならば、たとえばVB.NETなどを利用を検討する必要があります。 (そして個人的には、VB.NETを使うぐらいならC#をおすすめしますが。VB.NETと基本的にプログラムの作り方は同じで、書きやすさが断然上だと思うので。あくまで個人的主観による。) (4)について。 リンク先にも書かれていますが、その手順は製品版のVisual Studioを利用する場合のものかと思います。 製品版のVisual StudioはExpressのように種類が分かれていないため、C++のプロジェクトを流用してスクリプトデバッガを起動することなどが出来るのだと思います。 ちなみに、当方の手元では「Visual Studio Express 2013 for Windows Desktop」がインストールしてあるのですが、これにはスクリプトデバッガは含まれていないようです。 # コマンドラインから「wscript //x script.vbs」のようにしてもVS2013が選択肢に出てこないので、たぶん。 そのため、「for Windows Desktop」バージョンでメイクファイルプロジェクトを利用しても同じことをするのは不可能そうです。
プロジェクト→参照設定と進んでください。 このなかに『参照不可』の項目がありませんか。 この問題は、 測定器そのものではなく、 測定器の動作に必要なドライバあるいはライブラリが質問者様のPCに存在しないために発生します。 実際に動作しているPCと同じライブラリをインストールすれば解決します。 GP-IBにて通信ということはおそらく、 USB→GP-IBか、PCI→GP-IBの変換器を使用していると思われます。 これらはそのメーカーのHPより入手できると思われます。
#1,2です。KenKen_SP様には失礼して、改造部分のコードを提示させていただきます。Win7Home(64) xl2010(32) で試しています。 出典：http://oshiete.goo.ne.jp/qa/5124395.html ' // Bitmapオブジェクトからファイルへ書き出し Public Function SaveImageToFile( _ ByVal hBmp As OLE_HANDLE, _ ByVal sFilename As String, _ Optional ByVal sFormat As String = "JPG", _ Optional ByVal nQuarity As Long = 60 _ ) As Boolean '@ sFormat : BMP, JPG, GIF, TIF, PNG '@ nQuality: 0-100(0:高圧縮低画質, 100:低圧縮高画質, Jpg のみ有効) Dim sEncoderStr As String Dim nStatus As Long Select Case UCase$(sFormat) Case "JPG": sEncoderStr = ENCODER_JPG Case "GIF": sEncoderStr = ENCODER_GIF Case "TIF": sEncoderStr = ENCODER_TIF Case "PNG": sEncoderStr = ENCODER_PNG Case Else: sEncoderStr = ENCODER_BMP End Select Dim uEncoderParams As EncoderParameters ' Jpeg のクオリティー設定 If UCase$(sFormat) = "JPG" Then nQuarity = Abs(nQuarity) If nQuarity > 100 Then nQuarity = 100 uEncoderParams.count = 1 With uEncoderParams.Parameter(0) .GUID = pvToCLSID(QUALITY_PARAMS) .TypeAPI = 4 ' Type Long .Value = VarPtr(nQuarity) .NumberOfValues = 1 End With End If ' 保存処理 If UCase$(sFormat) = "JPG" Then nStatus = GdipSaveImageToFile(hBmp, _ StrPtr(sFilename), _ pvToCLSID(sEncoderStr), _ VarPtr(uEncoderParams)) Else nStatus = GdipSaveImageToFile(hBmp, _ StrPtr(sFilename), _ pvToCLSID(sEncoderStr), _ ByVal 0&) End If SaveImageToFile = CBool(nStatus = 0) Call GdipDisposeImage(hBmp) End Function ' // サンプル Sub Sample() Dim hBmp As OLE_HANDLE Dim file1 As String file1 = GetDesktopPath & "\Hydrangeas.bmp" ' GDI+ を初期化する If GDIplus_Initialize() = False Then MsgBox "GDI+ を初期化できません", vbCritical Exit Sub End If '変換元ファイル読込 If GdipCreateBitmapFromFile(ByVal StrPtr(file1), hBmp) <> 0 Then Gdiplus_Shutdown Exit Sub End If ' 保存(JPEG でクオリティー30の場合） If SaveImageToFile(hBmp, GetDesktopPath & "\sample.jpg", "jpg", 30) = False Then MsgBox "保存に失敗", vbCritical Else MsgBox "保存に成功", vbInformation End If ' GDI+ を終了させる（必ず呼び出すこと） Call Gdiplus_Shutdown End Sub 'テスト用 Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function
プロパティでは設定できないようです。 下記のコードを標準モジュールとuserformにそれぞれ貼り付けたところ、 実現できました。 http://shoji.blog1.fc2.com/blog-entry-48.html を参考に、Public Const LWA_ALPHAだけをいじったものです。 (標準モジュール) Public Declare Function FindWindow Lib "user32" _ Alias "FindWindowA" _ (ByVal classname As Any, ByVal winname As Any) As Long Public Declare Function SetWindowLong Lib "user32" _ Alias "SetWindowLongA" _ (ByVal hwnd&, ByVal idx&, ByVal style&) As Long Public Declare Function GetWindowLong Lib "user32" _ Alias "GetWindowLongA" _ (ByVal hwnd&, ByVal idx&) As Long Public Declare Function SetLayeredWindowAttributes Lib "user32" _ (ByVal hwnd&, ByVal crKey As Long, _ ByVal bAlpha As Long, ByVal dwFlags As Long) As Long Public Const GWL_EXSTYLE = (-20) Public Const WS_EX_TOOLWINDOW = &H80 Public Const WS_EX_LAYERED = &H80000 Public Const LWA_COLORKEY = 1 Public Const LWA_ALPHA = 255 Sub test() UserForm1.Show End Sub (フォーム) Private Sub UserForm_Initialize() hwnd& = FindWindow("ThunderDFrame", Me.Caption) If hwnd& <> 0& Then SetWindowLong hwnd&, GWL_EXSTYLE, _ GetWindowLong(hwnd&, GWL_EXSTYLE) Or WS_EX_LAYERED SetLayeredWindowAttributes hwnd&, 0, 192, LWA_ALPHA End If End Sub 参考URL：http://shoji.blog1.fc2.com/blog-entry-48.html
時刻は24時間を1とする値じゃなかったかな？ 現状のまま、ZISA の値を0．25にして実行したらどうなります？ 6時間ズレの結果になるなら間違いない
アプリ側で 取得するためのインターフェースが用意されていないのであれば無理かも … VB6とかでWordを対象としてやるなら dim obj as Variant set obj = GetObject(,"word.application") if not obj is nothing then 　　MsgBox obj.Documents(1).FullName end if といった具合で … obj が Word Documentsが Word側で用意したプロパティ FullNameが文書へのパス
【回答No.1でほぼ解決】 横から失礼！介入した理由は、それはtom04氏の最初の回答がスーパー正解だと思うからです。 ＜私のテストでは問題なし！＞ tom04氏の最初の回答の考え方とコードとをそのまんまコピペしてテスト。すると、全く問題なく動きましたよ。 Private Sub Worksheet_Change(ByVal Target As Range) 　　With Cells(Target.Row, "K") 　　　　If (Cells(Target.Row, "J") = 0) Then 　　　　　　If .Font.Color = RGB(0, 0, 0) Then 　　　　　　　　.Value = Now() 　　　　　　　　.NumberFormatLocal = "hh:mm" 　　　　　　　　.Font.Color = RGB(1, 1, 1) 　　　　　　End If 　　　　Else 　　　　　　If Len(.Value & "") > 0 Then 　　　　　　　　.Value = "" 　　　　　　　　.Font.Color = RGB(0, 0, 0) 　　　　　　End If 　　　　End If 　　End With End Sub ＜J列が新たに’0’になったのを知る手がかり＝文字色＞ 　これには、時刻の表示色を利用します。 J=0 AND 文字色=RGB(1, 1, 1)・・・表示更新不要 J=0 AND 文字色=RGB(0, 0, 0)・・・Now()を表示 J<>0の時は、時刻が表示されている場合に限って表示を消して文字色を初期化します。 これで、必要最低限のExcelとのアクセスで目的を達成できると思いますよ。
こちらで Wendy02 さんが二つ挙げられています。 http://oshiete.goo.ne.jp/qa/2008661.html あとは、Workbook_open か Auto_open で指定するとかでは？ 検証してはいませんが、SendKeys だと タイミング的に微妙かも知れません。
iかjがゼロになってませんか？ デバックモードでカーソル当てると値を確認出来ます。
まずは、グラフ作成や凡例設定、軸設定まで自動マクロで作成してください。一からソースコードを入力するよりずっと楽です。もちろんctrl+m等で起動出来るようにします。出来たソースコードを見るなりネット検索なりすれば、各パラメータの意味が分かります。どのパラメータを変数入力すればいいか判別し、そこをi, j, kに変えるのです。 以下のような追加が必要になります。 Sub Macro1() 'これは最初からあります Dim i As Long, j As Long, k As Long '使う変数の型宣言（Longは整数） i=Range("A1") j=Range("A2") k=cells(rows.count,1).end(xlup).row-i　 '表の左上 '望みのi,j値をセルA1～A2に記入しておけば、ここで値が代入されます。 '変更すれば別セルにも出来ます。 'この後、自動マクロで作成したコードが続く 'グラフの設定部分の数値をi,j,kに変更する End Sub
ここに有るんとちゃう？ http://book.mynavi.jp/support/bookmook/vbapro/ac … の「ファイルをダウンロード」から vba_access.zip
止まった時に、黄色くなってる行の strPath にカーソル乗せたら 値が見えますよ。 ＃５さんの言われるよう、パスのどれかが存在してないハズ 画面下側のイミディエイトウインドウ内で Print strPath でもＯＫ 同じように、Print i って入力して何行目なのかも確認
> 「実行時エラー1004　アプリケーション定義またはオブジェクト定義のエラーです」 > というエラーが出てきました。 コードの中のsheet1を正しい名前に変更しましたでしょうか。 コードを表示した画面の左側のペインで表示されているツリー上で Sheet1(シート) となっているシートの場合、コードでは With Sheets("シート")にしてください。通常の画面の下のタブに表示されているシート名になります。 > 現在A1には見出しが入っているので、A1を除いて並び替えは可能でしょうか？ Sub example3() Dim BRow As Long With Sheets("シート") .Activate BRow = .Range("A" & Rows.Count).End(xlUp).Row - 1 .Range("A2:BI" & BRow).Sort Key1:=.Range("A2"), order1:=xlAscending .Range("XX2").Formula = "=A2 & (IF(COUNTIF(OFFSET($A$2,0,0,ROW(A1),1),A2)-1=0,"""", -(COUNTIF(OFFSET($A$2,0,0,ROW(A1),1),A2)-1)))" .Range("XX2").Copy .Range("XX2").Resize(BRow, 1).PasteSpecial Paste:=xlPasteFormulas .Range("A2:A" & BRow).Value = .Range("XX2:XX" & BRow).Value .Range("XX2").Resize(BRow, 1).ClearContents .Range("A1").Select End With End Sub
こんばんは！ Bブックが開いているかどうかによってコードが変わってきますが・・・ とりあえず開いていなくても対応できるようにしてみました。 Aブックの標準モジュールに↓のコードをコピー＆ペーストしてマクロを実行してみてください。 尚、Aブックの aシート　のA1セルからデータはあるという前提です。 Sub Sample1() Dim i As Long, k As Integer, myPath As String, fN As String Dim wS As Worksheet, myFlg As Boolean myPath = "保存場所\" fN = "B.xlsx" Set wS = ThisWorkbook.Worksheets("a") For k = 1 To Workbooks.Count If Workbooks(k).Name = fN Then myFlg = True Exit For End If Next k If myFlg = False Then Workbooks.Open myPath & fN End If For i = 1 To wS.Cells(Rows.Count, "A").End(xlUp).Row Workbooks(fN).Worksheets("b").Cells(i, "B") = Left(wS.Cells(i, "A"), 6) If wS.Cells(i, "A") = "" Then Exit For Next i End Sub ※　コード内の「保存場所」の部分は、Bブックのプロパティの「場所」から確認して フルパスを入力してください。 こんなんではどうでしょうか？m(_ _)m
こんばんは！ 一例です。 標準モジュールに↓のコードをコピー＆ペーストしてみてください。 Sub Sample1() Worksheets("Sheet1").Range("A1:C3").Copy Workbooks.Open "ファイルの保存場所\集計.xlsx" ActiveWorkbook.Worksheets("Sheet1").Cells(Rows.Count, "A").End(xlUp).Offset(1).Select Selection.PasteSpecial Paste:=xlPasteValues Application.CutCopyMode = False End Sub ※　コード内の「ファイルの保存場所」の部分は 「集計」ブックのプロパティから確認してフルパスを入力してください。 ※　「集計」ブックが開いていないという前提のコードですので、開いている場合はエラーになります。 「集計」ブックが開いている場合 ＞Workbooks.Open "ファイルの保存場所\集計.xlsx" の1行を ＞Workbooks("集計.xlsx").Activate に変更してください。 ※　「集計」ブックのA列最終行以降にコピー＆ペーストするようにしていますので コピー元のA2～A3セルには空白セルはないとします。 （空白セルがあると行がずれてしまいます）m(_ _)m
元の値が０なので取得できないと勘違いしたのでしょう。 下記のように自分で指定してみればわかります。 Sub test() 　Dim wkbWorksheets As Worksheet 　Dim wksShapes As Shape For Each wkbWorksheets In ActiveWorkbook.Worksheets For Each wksShapes In wkbWorksheets.Shapes With wksShapes.TextFrame2.TextRange.Characters .Font.Spacing = 5 .Font.Kerning = 10 MsgBox .Font.Kerning MsgBox .Font.Spacing End With Next wksShapes Next wkbWorksheets End Sub
こんな感じ Sub ボタン1_Click() For i = 1 To 50 If Range("A" & i).Value = "" Then Range("B" & i).Value = "" Range("C" & i).Value = "" Range("D" & i).Value = "" Range("E" & i).Value = "" Else Range("B" & i).Value = "い" Range("C" & i).Value = "う" Range("D" & i).Value = "え" Range("E" & i).Value = "お" End If Next End Sub
「tiff圧縮」というのはわかりませんが tiffに変換保存するだけなら officeのpublisher　VBAでできます。 ThisDocument.ActiveView.ActivePage.Shapes.AddPicture("c:\Users\●●\Pictures\無題.bmp", msoFalse, msoTrue, 100, 50).Select Selection.ShapeRange.SaveAsPicture "c:\test\publisher.tif", pbPictureResolutionDesktopPrint_150dpi
見落としていました。 　　　　　　　　.DownBars.Format.Fill.ForeColor.RGB = RGB(128, 0, 0) ' 陰線の塗り潰し色　赤系 > 陰線の塗り潰しを黒以外で指定する方法は、 見つけいたのを忘れていました。 > 陰陽線（枠を除く）の幅を指定する方法は、 間接的には出来るみたいですが、直接の方法はやっぱり解りません。 それでは、ここら辺で、、、。
失礼しました。 以下のコードは「文字か、数字かで判断する場合」で置き換えたものになります。 補足の問題点を修正いたしましたのでご確認お願いします。 結果の問題点 １．7行目の文字を削除してしまった。 　→　削除処理判定flagが正常に行われていなかったため修正しました。 ２．9行目から最終行の間の削除処理が行われていない。 　→　"["から8文字シフトした後、行末までの文字数が10文字無い場合に 　　　次の行を跨ぎ処理をしていましたので修正しました。 　→　末尾まで10文字確保できない場合『[8:31:25 | 8:31:2』などはスキップされます。 気になること・・・ 補足にてご提示の元の文面には以下の統一性がありません。 「を編集しました」と「編集しました」や「]」の有無など行によって結果が異なります。 現在の処理は"["を検索した位置より8文字右へシフトしたところから10文字を抜出し 抜き出した文字が特定文字「数値, ,:,/」であれば削除、それ以外ではればそのまま。 8文字シフトした位置から末尾までで10文字取得できなければ次の"["を検索・・・ としております。 ■VBAコード Sub sample() '変数を宣言 Dim lmoji As String, lVal As String, cVal As String Dim aa As String, pp As String, a As String, p As String Dim flag As Boolean Dim i As Integer 　　'検索文字を指定 　　lmoji = "[" 　　'カーソルを先頭へ 　　Selection.HomeKey Unit:=wdStory 　　Application.ScreenUpdating = False 　　'メイン処理 　　Do 　　　　'検索条件を設定 　　　　With Selection.Find 　　　　　　.Forward = True 　　　　　　.ClearFormatting 　　　　　　.MatchWholeWord = True 　　　　　　.MatchCase = False 　　　　　　.Wrap = wdFindContinue 　　　　　　'lmojiを検索 　　　　　　If .Execute(FindText:=lmoji, Forward:=True, Format:=True) = True Then 　　　　　　　　'行、頁位置を取得 　　　　　　　　aa = Selection.Information(wdFirstCharacterLineNumber) 　　　　　　　　pp = Selection.Information(wdActiveEndPageNumber) 　　　　　　　　'末尾までの対象文字を10文字分取得可能か判定 　　　　　　　　Selection.EndKey Unit:=wdLine, Extend:=wdExtend 　　　　　　　　If Len(Selection) - 9 < 10 Then 　　　　　　　　　　flag = False 　　　　　　　　Else 　　　　　　　　　　'文字列の取得 　　　　　　　　　　Selection.MoveLeft Unit:=wdCharacter, Count:=1 　　　　　　　　　　Selection.MoveRight Unit:=wdCharacter, Count:=8 　　　　　　　　　　Selection.MoveRight Unit:=wdCharacter, Count:=10, Extend:=wdExtend 　　　　　　　　　　lVal = Selection 　　　　　　　　　　flag = True 　　　　　　　　End If 　　　　　　End If 　　　　　　'開始位置ならループ終了 　　　　　　If a = aa And p = pp Then Exit Do 　　　　　　'末尾まで10文字確保できない場合は処理をスキップ 　　　　　　If flag Then 　　　　　　　　'文字を取得して判定 　　　　　　　　For i = 1 To Len(lVal) 　　　　　　　　　　cVal = Mid(lVal, i, 1) 　　　　　　　　　　If IsNumeric(cVal) Then 　　　　　　　　　　　　'数値の場合 　　　　　　　　　　　　flag = True 　　　　　　　　　　Else 　　　　　　　　　　　　'文字の場合 　　　　　　　　　　　　If cVal = ":" Or cVal = "|" Or cVal = " " Then 　　　　　　　　　　　　　　flag = True 　　　　　　　　　　　　Else 　　　　　　　　　　　　　　flag = False 　　　　　　　　　　　　End If 　　　　　　　　　　End If 　　　　　　　　　　If flag = False Then Exit For 　　　　　　　　Next i 　　　　　　　　'対象文字の削除 　　　　　　　　If flag Then 　　　　　　　　　　Selection.Delete Unit:=wdCharacter 　　　　　　　　　　flag = False 　　　　　　　　End If 　　　　　　End If 　　　　　　'初期位置を記録 　　　　　　If a = "" Then a = aa: p = pp 　　　　　　'検索位置をシフト 　　　　　　.Parent.Move Count:=1 　　　　End With 　　　　DoEvents 　　Loop 　　Application.ScreenUpdating = True 　　Selection.Find.ClearFormatting End Sub
組み込み関数では 無いので 自前で関数を作ることになるかと … Function AbcToNum(ss as String) as String 　　dim b() as Byte, n as integer, w as string 　　' バイト型の配列に変換 　　b = strconv(ss, vbFromUnicode) 　　for n= 0 to ubound(b) 　　　　' ABCDEFGHI を 123456789 に変換 　　　　if b(n) >= &H41 and b(n) < &H4a then 　　　　　　b(n) = b(n) - &H10 　　　　end if 　　next 　　' 文字列に戻す 　　w = strconv(b,vbUnicode) 　　AbcToNum = w End Function 逆の変換ならば if文の条件変更と b(n)に&H10を加算に変更で出来ます 　　　　if b(n) >= &H31 and b(n) < &H3a then 　　　　　　b(n) = b(n) + &H10 　　　　end if
& "WHERE 年月 = " & Me.年月.Value & " " _ & "AND 材料顧客コード = " & Me.材料顧客コード.Value & " " _ & "AND 現場コード = " & Me.現場コード.Value データ型はすべて数値型なのでしょうか？ふと気になりました。
こんにちは。 前提。 行高、列幅が統一されているとして、 ' ' まず、６行４列のセル範囲の　 ' ' 　幅　xSize ' ' 　高さ　ySize ' ' を採っておく。 　　With Range("A2:D7") 　　　　xSize = .Width 　　　　ySize = .Height 　　End With ' ' 次に、 ' ' チャートオブジェクトを配置する位置を ' ' チャートオブジェクトの.Left、.Top、を ' ' セルの.Left、.Top、に合わせるようにする。 　　For i = 1 To 4 　　　　For j = 1 To 4 　　　　　　LA = LA + 1 　　　　　　With ActiveSheet.ChartObjects.Add( _ 　　　　　　　　　　Left:=Cells((j - 1) * 4 + 1).Left, _ 　　　　　　　　　　Top:=Cells((i - 1) * 12 + 2, 1).Top, _ 　　　　　　　　　　Width:=xSize, _ 　　　　　　　　　　Height:=ySize) 　　　　　　　　.Name = "GF" & LA 　　　　　　　　With .Chart 　　　　　　　　　　.ChartType = xlLine 　　　　　　　　　　.SetSourceData Source:=GFDT(LA), PlotBy:=xlColumns 　　　　　　　　End With 　　　　　　End With 　　　　Next j 　　Next i 以上のようなやり方が現状に対する直接的な対策になります。 チャートオブジェクトを配置する法則性の説明が詳しくないので、 こちらで推理した仮の想定として、 水平位置は、 　Ａ列、Ｅ列、Ｉ列、Ｍ列、 　のように、４列ステップ、 垂直位置は、、 　行２、行１４、行２６、行３９、 　のように、２行目を先頭に、１２行ステップ という設定で組んでいます。 いずれにしても、セル範囲に合わせてチャートオブジェクトを配置する ことは簡単に動作確認できるので、 後は、列、行、のステップ数と先頭位置を、狙いに合わせて修正してください。 　　 * 4 + 1 の意味は、４列ステップ、先頭は１列め、 　　 * 12 + 2 の意味は、１２行ステップ、先頭は２行め、 という要領です。 配列変数 GFDT については、こちらでは中身が解りませんが、 正しく、セル範囲への参照がなされているものとします。 尚、こちらで追加した変数xSize, ySize について、 変数宣言をする場合にはSingle型を指定してください。 "行高、列幅が統一されている" という前提も、こちらの推測でしかありませんが、もし違っている場合でも ニーズさえ詳らかならば対策は難しくはないので、 包括的に補足して貰えれば、再度レスします。 以上です。 追伸。 たぶん、結果を確認しながら作業をやり直したりすることになるでしょうから、 簡単に 今回のマクロで作成したチャートオブジェクトを 削除するマクロを添えておきますね。 Sub DeleteCharts() Dim o As ChartObject 　　For Each o In ActiveSheet.ChartObjects 　　　　If o.Name Like "GF*" Then o.Delete 　　Next End Sub
IE 8 以降はセッションが共有されますね。 iexplore.exe -noframemerging とすると新規セッションとなるようですが、開発中のプログラムで IE をどのように起動させようとしているのかがわからないので参考程度にしてください。 ちなみに IE 10 で実験したらうまくいきました。 http://blogs.technet.com/b/jpieblog/archive/2013 …
＃３を再び訂正 共通部分の前半出力判定条件に不都合あり 　　' ブレーク判定１：前行と現在行を比較する 　　' 　処理が必要なのは「初回」または「20社単位名が変わる」 　　' 　つまりカウンタが0の時、なので条件を追加。 　　' 　※初回は見出し行≠データ１行目であること 　　' 20社の場合 　　If nCount = 0 or Range("E" & i - 1).Text <> Range("E" & i ).Text Then 　　' 1社の場合 ''''If nCount = 0 or Range("E" & i - 1).Text & "|" & Range("F" & i - 1).Text <> Range("E" & i ) & "|" & Range("F" & i ).Text Then
PictureBoxで透過処理を行うのであれば BackColorプロパティを Color.TransParentに変更します 次に 設定する画像を Bitmapオブジェクトで構築して MakeTransparentメソッドで 何色を透明にしたいか設定します 次に 透過画像の背景になるコントロールの ControlsコレクションにAddします PictureBoxの Locationを適切な位置に変更すれば 希望の動作になるかと … ' 透過画像を用意 Dim bmp as new Bitmap("透過画像のパス") ' 透過色を設定 bmp.MakeTransparent(bmp.GetPixel(0,0)) ' コントロールの背景色を透過に設定 PictureBox2.BackColor = TransParent ' 透過画像を設定 PictureBox2.Image = bmp ' ここまでが初期設定 ' 背景になるPictureBoxに 前景のコントロールを追加 if PictureBox1.Controls.Contains(PictureBox2) = false then 　　PictureBox1.Controls.add(PictureBox2) End if ' 前景の描画位置を設定 PictureBox2.Location = new Point( PictureBox1.Width / 2, PictureBox1.Height / 2) といった具合です
#1です。無いなら自分でこしらえてみました。xl2010で試しています。 Web Safe ColorをUserFormに表示して色を選択し、ActiveCellに着色します。 簡単なカレンダーフォームとして作ったものを改造したので、冗長な箇所があります。Indexを設定していますが、ここでは活用していなかったりします。フォームの幅の下限が決まってしまうのが寂しい...枠を表示しないと自由が利きますが、こんどは閉じる手段を考える必要が出てきたり、面倒なのでここまでにしておきます。 ☆標準モジュール Sub test() UserForm1.Show vbModeless End Sub ☆UserForm1モジュール コントロールは何も置きません。サイズも自動で設定します。 Dim myClsIndex As Integer 'ラベルコントロールの番号 Dim labelArray() As LabelCtrl 'ラベルコントロールの配列 Const labelWidth As Single = 10 Const labelHeight As Single = 10 Private Sub UserForm_Initialize() Dim colorArray As Variant Dim i As Long, j As Long, k As Long Dim strColor As String Dim labelTop As Single, labelLeft As Single Dim xFrame As Single, yFrame As Single xFrame = Me.Width - Me.InsideWidth yFrame = Me.Height - Me.InsideHeight colorArray = Array("00", "33", "66", "99", "CC", "FF") myClsIndex = 0 'ユーザーフォームの設定 With Me .caption = "色選択" .Width = labelWidth * UBound(colorArray) + xFrame .Height = labelHeight * (UBound(colorArray) + 1) ^ 2 + yFrame End With 'ラベルコントロールの配列生成 labelTop = 0 For i = 0 To UBound(colorArray) For j = 0 To UBound(colorArray) For k = 0 To UBound(colorArray) strColor = colorArray(i) & colorArray(j) & colorArray(k) labelLeft = labelWidth * k Call addLabel(labelLeft, labelTop, CLng("&H" & strColor)) Next k labelTop = labelTop + labelHeight Next j Next i End Sub 'ラベルコントロール配列のクリックイベントで起動されるルーチン Public Sub labelClicked(getColor As Long) ActiveCell.Interior.Color = getColor End Sub 'ラベルの追加 Private Function addLabel(labelLeft As Single, labelTop As Single, myColor As Long) As Integer Dim myLabel As MSForms.Label Set myLabel = Me.Controls.Add("Forms.Label.1", , False) myClsIndex = myClsIndex + 1 With myLabel .top = labelTop .left = labelLeft .Height = labelHeight .Width = labelWidth .BackColor = myColor .visible = True End With ReDim Preserve labelArray(1 To myClsIndex) Set labelArray(myClsIndex) = New LabelCtrl Set labelArray(myClsIndex).parent = Me labelArray(myClsIndex).S_SetLabel myLabel, myClsIndex End Function ☆クラスモジュールLabelCtrl Private WithEvents myLabel As MSForms.Label Private myIndex As Integer Private myParent As Object '親UserForm Public Sub S_SetLabel(newLabel As MSForms.Label, index As Integer) Set myLabel = newLabel myIndex = index End Sub Private Sub myLabel_Click() Call Me.parent.labelClicked(myLabel.BackColor) End Sub Public Property Get parent() As Object Set parent = myParent End Property Public Property Set parent(newParent As Object) Set myParent = newParent End Property
ついでに、cmdMkFolder もフォルダの存在有無で フォルダを作成するようにしておきます。 Sub cmdMkFolder(ByVal strPath, ByVal strDirName As String) 　　Dim obj As Object 　　Dim strFolder As String 　　Set obj = CreateObject("Scripting.FileSystemObject") 　　If Dir(strPath & "\" & strDirName, vbDirectory) = "" Then 　　　　strFolder = obj.BuildPath(strPath, strDirName) 　　　　obj.CreateFolder strFolder 　　End If 　　Set obj = Nothing End Sub ところで、作成したフォルダの中に http://oshiete.goo.ne.jp/qa/8796473.html でのファイルを作成するということならば、 このようにフォルダとファイルを 作成するコードを別々にするのではなく、 一つにしたコードにしたほうがいいのでは？
　すみません。もう一か所書き換えていたのにうっかりコピーし忘れていました。 With wksShapes.TextFrame2.TextRange.Characters MsgBox .Font.UnderlineStyle Excel　２００７でも確認しました。
問題ありません。 ご自分でテストしてみればすぐにわかる話だと思うのですが、Windows 8.1 搭載のタブレットはこれから導入するってことですかね。
　いつまでも回答がつかないのはなぜだと思いますか？ マクロの記録で必要なことはわかるので あとはそれを少し編集するだけでできることだからです。 　
エクセルの定数ではなく MsoTextUnderlineType 列挙体が近いようです。（日本語のヘルプが見つからなかった） Name／Value／Description msoNoUnderline／0／Specifies no underline. msoUnderlineDashHeavyLine／8／Specifies a dash underline. msoUnderlineDashLine／7／Specifies a dash line underline. msoUnderlineDashLongHeavyLine／10／Specifies a long heavy line underline. msoUnderlineDashLongLine／9／Specifies a dashed long line underline. msoUnderlineDotDashHeavyLine／12／Specifies a dot dash heavy line underline. msoUnderlineDotDashLine／11／Specifies a dot dash line underline. msoUnderlineDotDotDashHeavyLine／14／Specifies a dot dot dash heavy line underline. msoUnderlineDotDotDashLine／13／Specifies a dot dot dash line underline. msoUnderlineDottedHeavyLine／6／Specifies a dotted heavy line underline. msoUnderlineDottedLine／5／Specifies a dotted line underline. msoUnderlineDoubleLine／3／Specifies a double line underline. msoUnderlineHeavyLine／4／Specifies a heavy line underline. msoUnderlineMixed／-2／Specifies a mixed of underline types. msoUnderlineSingleLine／2／Specifies a single line underline. msoUnderlineWavyDoubleLine／17／Specifies a wavy double line underline. msoUnderlineWavyHeavyLine／16／Specifies a wavy heavy line underline. msoUnderlineWavyLine／15／Specifies a wavy line underline. msoUnderlineWords／1／Specifies underlining words.
Windows フォームアプリケーションを前提とします。 プロジェクトを右クリック→プロパティ→参照→インポートされた名前空間 に System.Windows.Formsのチェックが外れてるならいれる。 Microsoft.Office.Interopのチェックが入ってるなら外す。 Microsoft.Office.Interop.Excelのチェックが入ってるなら外す。 コードは Imports Microsoft.Office.Interop です。 > Dim oXls As Excel.Application：Excel.Applicationにエラー ここで指定したいApplicationクラスは、Microsoft.Office.Interop.Excel.Applicationクラスだし、 > Label14.Location = New Point(350, 100) ここは、System.Drawing.Pointクラスです。 名前空間の設定や記述周りが悪くて Applicationクラスを、System.Windows.Forms.Applicationクラス、 Pointクラスを、Microsoft.Office.Interop.Excel.Pointクラスと 認識されているなどとしか思えません。 もしでしたら、名前空間について理解を深めたら良いかと思います。
こんにちは。 >本日エクセルVBAエキスパートのスタンダードを取得いたしました。 高い受験料を払って、せっかく取得したのに、水をさすようで恐縮なのですが、試験で資格はとれても、システム自体の設計の経験もないようですと、少し弱い気がします。資格としては、前は、スタンダードの上にプロフェショナルという資格もありましたが、廃止されてしまいました。 #2の方が言うとおりで、C#でもなければ、VB.Net でもなく、お勧めは「C/C++」ですね。 ただし、いきなりですと、挫折することも多いと思います。 ある有名な方（インストラクターではない）で、Office のVBAのプログラミングで、月に何百万の稼いでいる人はいても、VBAのみでなく、Officeのプログラミングのベテランさんは、CやJavaの経験者が多いのです。ちなみに、その方は、まったく別な職業でも生活できるはずですが、特に、Excelがお好きなようです。結構、こういう業界には、そういうExcel好きの方も多いようです。 他に、『Excelでお仕事!』の井上さんのように、特別な業務で覚えたものを、プログラミングに投影しているようで、一般の人の学ぶ経路とはまったく違う人もいるようです。むろん、彼のコードの内容は、今では古くなってしまいましたが、他の著名な方たちのように、VBAにどっぷりとハマってしまい、独特のテクニックから抜け出せない人もいます。 VB.Net が良いのか悪いのかというよりも、#1の方の「初心者向け」というのは極論で、オブジェクト指向にはなっています。VB.Net もC#も、その裏の.NET Frameworkがあるわけです。しかし、VB系の悲哀というのか、VBの開発者のC.シモン氏がMSを辞めたこともあって、MS側の過去のものに対する扱いは、結構むごいような気がします。開発チームとしては、VB系は現存していますが、C#側のほうが、後発な上に、他のメジャーな言語を参考にしているせいか、テクニック的にも機能的にも上になってしまっていると思います。 >VBAを学んでいるとC＃に比べVB.NETは多少は習得し易いでしょうか。 VBAを習っていても、VB.Net ということですと、個人的には、どうかなって思います。 旧Visual Basicからというならば、習得しやすいとは言えます。 しかしVB.Net は、VBAというよりか、旧Visual Basicと大幅に違う所がありますね。旧Visual Basicを使っていた方なら、入りやすい部分も多いのですが、思わぬところで、その違いに戸惑ってしまいます。
(1)Alt+F11でVBEを開き、挿入→標準モジュール (2)作成された標準モジュールへ以下のVBAコードを貼付 (3)コード内の以下の箇所を該当のシート名に合わせて修正 　　　'対象のシートを設定 　　　Set mySt(0) = Worksheets("Sheet1")　←元データのシート 　　　Set mySt(1) = Worksheets("Sheet2")　←表示先のシート (4)Alt+F11でVBEを閉じ、Alt+F8で「sample」マクロを実行 ※補足 処理中で使用している区切り文字列について 元データのA列（ID）に「;」「,」を含む場合は正常に動作しません。 含む可能性がある場合は、コード内の以下の箇所をそれぞれ元データで使用していない 文字列に変更してください。（key(0)とkey(1)は別の文字列としてください） 　　　key(0) = ";": key(1) = "," ■VBAコード Sub sample() '変数を宣言 Dim mySt(1) As Worksheet, key(1) As String Dim bsData() As Variant, myData() As Variant Dim i As Long, j As Long, cnt As Long Dim names() As String, buf As Variant Dim tar As Range, flag As Boolean '対象のシートを設定 Set mySt(0) = Worksheets("Sheet1") Set mySt(1) = Worksheets("Sheet2") '区切り文字（必要であれば変更） key(0) = ";": key(1) = "," '配列にデータを格納 With mySt(0) 　　bsData = .Range(.Cells(1, "A"), .Cells(Rows.Count, "C").End(xlUp)) End With '重複しない名前の配列を作成 For i = 1 To UBound(bsData, 1) 　　flag = True 　　If Sgn(names) <> 0 Then 　　　　For j = 0 To UBound(names, 2) 　　　　　　If names(0, j) = bsData(i, 1) Then 　　　　　　　　flag = False 　　　　　　　　Exit For 　　　　　　End If 　　　　Next j 　　End If 　　If flag Then 　　　　If Sgn(names) = 0 Then 　　　　　　ReDim names(1, 1) 　　　　Else 　　　　　　ReDim Preserve names(1, UBound(names, 2) + 1) 　　　　End If 　　　　names(0, UBound(names, 2)) = bsData(i, 1) 　　End If Next i '名前配列へ同名のデータを集約 For i = 1 To UBound(names, 2) 　　For j = 1 To UBound(bsData, 1) 　　　　If bsData(j, 1) = names(0, i) Then 　　　　　　names(1, i) = names(1, i) & bsData(j, 2) & key(1) & bsData(j, 3) & key(0) 　　　　End If 　　Next j Next i 'シートへ書き出し Application.ScreenUpdating = False With mySt(1) 　　.Cells.ClearContents 　　For i = 1 To UBound(names, 2) 　　　　buf = Split(names(1, i), key(0)) 　　　　For j = 0 To UBound(buf) - 1 　　　　　　If j Mod 3 = 0 Then 　　　　　　　　cnt = cnt + 1 　　　　　　　　Set tar = .Cells(cnt, "A") 　　　　　　　　tar = names(0, i) 　　　　　　End If 　　　　　　tar.Offset(0, (j Mod 3) * 2 + 1) = Left(buf(j), InStr(1, buf(j), key(1)) - 1) 　　　　　　tar.Offset(0, (j Mod 3) * 2 + 2) = Right(buf(j), Len(buf(j)) - InStr(1, buf(j), key(1))) 　　　　Next j 　　Next i End With Application.ScreenUpdating = True '終了 MsgBox "終了" End Sub
'ADOのレコードセットを使用 Sub testMain() 　　Dim myCon As New ADODB.Connection 　　Dim FileName As String 　　Dim rs1 As New ADODB.Recordset 　　Dim rs2 As New ADODB.Recordset 　　Dim rs3 As New ADODB.Recordset 　　Dim conStr As String 　　Dim strSQL1 As String 　　Dim strSQL2 As String 　　Dim strSQL3 As String 　　Dim dic1 As Object 　　Dim dic2 As Object 　　Dim buf1 As Variant 　　Dim buf2 As Variant 　　Dim i As Long 　　Dim j As Long 　　Dim fso As Object 　　Dim strPath As String 　　Set dic1 = CreateObject("Scripting.Dictionary") 　　Set dic2 = CreateObject("Scripting.Dictionary") 　　strSQL1 = "SELECT 大分類 FROM [Sheet1$] GROUP BY 大分類" 　　strSQL2 = "SELECT * FROM [Sheet1$]" 　　strSQL3 = "SELECT * FROM [Sheet1$]" 　　'カレントフォルダのパス 　　strPath = ThisWorkbook.Path 　　'接続先のExcelファイル(質問の場合は現在のファイル) 　　FileName = ThisWorkbook.FullName 　　conStr = "Provider=Microsoft.Jet.OLEDB.4.0;" & _ 　　　　　　　"Extended Properties=Excel 8.0;" & _ 　　　　　　　"Data Source=" & FileName 　　'接続 　　myCon.Open conStr 　　'レコードセットを開く 　　rs1.Open strSQL1, myCon, adOpenStatic, adLockReadOnly 　　rs2.Open strSQL2, myCon, adOpenStatic, adLockReadOnly 　　rs3.Open strSQL2, myCon, adOpenStatic, adLockReadOnly 　　If rs1.RecordCount > 0 Then 　　　　rs1.MoveFirst 　　　　Do Until rs1.EOF 　　　　　　If Not IsNull(rs1!大分類) Then 　　　　　　　　'フォルダ作成 　　　　　　　　Call cmdMkDir(rs1!大分類) 　　　　　　　　'中分類の取得 　　　　　　　　If rs2.RecordCount > 0 Then 　　　　　　　　　　rs2.MoveFirst 　　　　　　　　　　Do Until rs2.EOF 　　　　　　　　　　　　'大分類と同じ分類の中分類を検索 　　　　　　　　　　　　If rs2!大分類 = rs1!大分類 Then 　　　　　　　　　　　　　　If Not IsNull(rs2!中分類) Then 　　　　　　　　　　　　　　　　buf1 = rs2!中分類 　　　　　　　　　　　　　　　　If Not dic1.exists(buf1) Then 　　　　　　　　　　　　　　　　　　'検索済みの中分類をDictionaryに格納 　　　　　　　　　　　　　　　　　　dic1.Add buf1, buf1 　　　　　　　　　　　　　　　　　　'中分類ファイルの作成 　　　　　　　　　　　　　　　　　　Call cmdMakeChuFile(strPath & "\" & rs1!大分類, buf1) 　　　　　　　　　　　　　　　　　　'小分類の取得 　　　　　　　　　　　　　　　　　　rs3.MoveFirst 　　　　　　　　　　　　　　　　　　Do Until rs3.EOF 　　　　　　　　　　　　　　　　　　'大分類および中分類が同じ小分離の検索 　　　　　　　　　　　　　　　　　　If rs2!大分類 = rs3!大分類 And buf1 = rs3!中分類 Then 　　　　　　　　　　　　　　　　　　　　If Not IsNull(rs3!小分類) Then 　　　　　　　　　　　　　　　　　　　　　　buf2 = rs3!小分類 　　　　　　　　　　　　　　　　　　　　　　If Not dic2.exists(buf2) Then 　　　　　　　　　　　　　　　　　　　　　　　　'検索済みの小分類をDictionaryに格納 　　　　　　　　　　　　　　　　　　　　　　　　dic2.Add buf2, buf2 　　　　　　　　　　　　　　　　　　　　　　　　'小分類ファイルの作成 　　　　　　　　　　　　　　　　　　　　　　　　Call cmdMakeShoFile(strPath & "\" & rs1!大分類, buf2) 　　　　　　　　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　　　　　'変数とDictionaryの初期化 　　　　　　　　　　　　　　　　　　buf2 = "" 　　　　　　　　　　　　　　　　　　dic2.RemoveAll 　　　　　　　　　　　　　　　　　'次のレコードに移動 　　　　　　　　　　　　　　　　　rs3.MoveNext 　　　　　　　　　　　　　　　　　Loop 　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　End If 　　　　　　　　　　'次のレコードに移動 　　　　　　　　　　rs2.MoveNext 　　　　　　　　　　Loop 　　　　　　　　End If 　　　　　　　　'変数とDictionaryの初期化 　　　　　　　　buf1 = "" 　　　　　　　　dic1.RemoveAll 　　　　　　End If 　　　　　　'次のレコードに移動 　　　　　　rs1.MoveNext 　　　　Loop 　　End If 　　'後始末 (オブジェクトの破棄が主) 　　rs1.Close: Set rs1 = Nothing 　　rs2.Close: Set rs2 = Nothing 　　rs3.Close: Set rs3 = Nothing 　　myCon.Close: Set myCon = Nothing 　　Set dic1 = Nothing 　　Set dic2 = Nothing End Sub Sub cmdMkDir(ByVal strDir As String) 　　Dim obj As Object 　　Dim strPath As String 　　Dim strFolder As String 　　Set obj = CreateObject("Scripting.FileSystemObject") 　　strPath = ThisWorkbook.Path 　　strFolder = obj.BuildPath(strPath, strDir) 　　obj.CreateFolder strFolder 　　Set obj = Nothing End Sub Sub cmdMakeChuFile(ByVal strPath As String, ByVal strFileName As String) 　　Dim strFile As String 　　strFile = strPath & "\" & strFileName & ".html" 　　Open strFile For Output As #1 　　Print #1, "<html>" 　　Print #1, "中分類ファイル" & "-------" & strPath & "-------" & strFileName 　　Print #1, "</html>" 　　Close #1 End Sub Sub cmdMakeShoFile(ByVal strPath As String, ByVal strFileName As String) 　　Dim strFile As String 　　strFile = strPath & "\" & strFileName & ".html" 　　Open strFile For Output As #1 　　Print #1, "<html>" 　　Print #1, "小分類ファイル" & "-------" & strPath & "-------" & strFileName 　　Print #1, "</html>" 　　Close #1 End Sub
Dir(フルパスファイル名） ファイルの存在を調べ、あればファイル名（パス無し）を返します。 Sub W() Dim ファイル名 As String, fpFilename As String Dim 列番号 As Long 列番号 = 4 Do While Cells(2, 列番号).Value <> "" ファイル名 = Cells(2, 列番号).Value fpFilename="D:\学校\データ\" & ファイル名 & ".xlsx" If Dir(fpFilename)<>""　then Workbooks.Open fpFilename Range("A2:A1000").Copy Application.DisplayAlerts = False ActiveWorkbook.Close ThisWorkbook.Activate ActiveSheet.Paste Cells(5, 列番号) end if 列番号 = 列番号 + 1 Loop End Sub 質問とは関係ありませんが、ちょっと便利な使い方があります。詳細はググって下さい。
変数[ファイル名]がstring型のため、activateが使用できない状態です。 Workbooks(ファイル名).activate でactiveにできると思います。 また、別の方法ですが、追加した箇所を削除し(元に戻し)、代わりに、下記の一文を入れてみてください。 Application.DisplayAlerts = False これで「クリップボードに～」は表示されなくなります。
これでは？ Sub 連続シート作成() 　　For Each 対象セル In Selection 　　　　Sheets("マスタ").Copy After:=ActiveSheet 　　　　ActiveSheet.Name = 対象セル.Value 　　Next 対象セル End Sub
>※グラフは全部で１０個作成（データはすべて違う）するのですが、９個目だけバグが出てしまう >　バグ・・・項目軸が複数選択される (1)ベースとなるデータに差異が無いかの確認と、差異による処理内容への影響 (2)Debug.Print RngData.AddressなどをFor内に入れて、ブレークポイントをいれてから実行 (3)ステップ実行で各変数値が正常であるか確認 異常を試してみてください。
シートやセルに対する操作のように直接扱いませんが・・・ フォームのあるブックに値を受け取りフォームに値をセットするプロシージャを用意し、 別のブックからそのプロシージャへ書き込む値を渡す方法です。 以下の設定を【Book1】【Book2】でして頂き、 【Book1】の「Sample1」を実行してください。 【Book1】 (1)以下のコードを標準モジュールへ記述 　　Sub Sample1() 　　　　Dim msg As String 　　　　msg = "入力する文字列" 　　　　'変数msgを引数としてBook2のSample2を実行 　　　　Application.Run "Book2!Sample2", msg 　　End Sub 【Book2】 (1)UserForm1を作成してTextBox1コントロールを配置 (2)以下のコードを標準モジュールへ記述 　　Sub sample2(msg As String) 　　　　Load UserForm1 　　　　'受け取った引数をTextBox1にセット 　　　　UserForm1.TextBox1.Value = msg 　　　　UserForm1.Show 　　End Sub
１回目のループ終了時の「列番号＝列番号＋１」結果は「D」になりますか？おそらくならないと思います。エラー発生時にデバッグを押した後、列番号のところにカーソルを合わせると値表示がされるので、確認出来ます。 これが原因ならば、以下のように対策すればOKです。 Sub W() Dim ファイル名 As String Dim 列番号 As Long 列番号 = 3 Do While Cells(5,列番号).Value <> "" ファイル名 = Cells(5,列番号).Value Workbooks.Open "D:\学校\データ\" & ファイル名 & ".xlsx" Range("A2:A5").Copy ActiveWorkbook.Close ThisWorkbook.Activate ActiveSheet.Paste Cells(6,列番号) 列番号 = 列番号 + 1 Loop End Sub 要は列番号をアルファベットでなく整数に変更し、セル表現をRangeからCellsに変更します。
http://dobon.net/vb/dotnet/process/standardoutpu … devconの出力を文字列で取り込んで、その文字列を解析して必要なデータを取得するばいいのでは?
>ただいま、最終的に行いたい図を添付しましたので >一度、ご確認いただけますでしょうか？ 添付画像確認致しました。 画像からは列番号（記号）/行番号が読み取れないので具体的なコードは記述できません。 また、図1と図2の様式については一致している項目が「納入先」、 近そうな項目が「LOT」「lot No」、「品名」「銘柄」、「数量」「個数」、 新規の項目が「出荷日」「荷姿」「合計」など 作業的に「転記」ではなく「集計」に近いようですが。 >現在のコードをもとにして、応用し添付画像の様に >マクロを組みたいのですが、どこを変更すれば >実現可能でしょうか？ 上記（添付画像でいう黄色背景色の部分をコピーする）目的では、 ベースとするご提示して頂いている「S_書込」プロシージャでは程遠いですね。 ご提示のコードは今回の目的で作成されたものとは全くの別物でしょうか。 詳細な仕様を元に初めから作られたほうが早い気がいたしますが。 上記理由により具体案ではありませんが・・・ 今回の画像のように転々とした値を別の場所に転記する場合はコピーではなく以下のように記述します。 Worksheets("Sheet2").Range("A2") = Worksheets("Sheet1").Range("B8") 　→ Sheet2のA2セルにSheet1のB8セルの値を入れる まとまった範囲を代入する場合は配列変数に格納してから纏めて入れる方法もあります。 Dim myRange As Variant 　→　配列変数を用意 myRange = Worksheets("Sheet1").Range("G8:L8") 　→　Sheet1のG8:L8セルを配列変数に格納 Worksheets("Sheet2").Range("B2:G2") = myRange 　→　Sheet2のB2:G2セルに配列変数を格納 セルアドレスの指定方法について、以下のコードはどれもA2セルを意味します。 　　Range("A2") 　　i=2: Range("A" & i) 　　Cells(2, 1) 　　Cells(2, "A") 　　Range(Cells(2, 1)) 　　Range(Cells(2, 1).Address) No1の回答を元に最終行値を取得し上記記述方法と組み合わせて 目的のセルを対象に上記方法で個々に項目を代入する処理を淡々と記述すればよいかと思います。
参考に Sub Test() 　　Dim c As Range, Bunnrui As String 　　Dim i As Long, j As Long 　　For Each c In Range("C2", Cells(Rows.Count, "C").End(xlUp)) 　　　　If c.Value <> Bunnrui Then 　　　　　　Bunnrui = c.Value 　　　　　　i = 1: j = 1 　　　　ElseIf i >= 20 Then 　　　　　　i = 1: j = j + 1 　　　　Else 　　　　　　i = i + 1 　　　　End If 　　　　c.Offset(, 1).Value = c.Value & Format(j, "00") 　　　　c.Offset(, 2).Value = c.Value & Chr(64 + i) 　　Next End Sub
ExcelのVBAだったら簡単にできますが、普通のVBからだと手間が余分に必要です。以下がズバリの操作を行っているサンプルです。 http://homepage2.nifty.com/nonnon/SoftSample/VB. … また、上記サンプルでセルの位置を指定するのに使われているRangeオブジェクトは、以下のExcel VBAの解説をあたってください。RangeとCellsの組み合わせで指定されたセルを操作するので、ここを理解しないと先に進めないはずです。 http://www.asahi-net.or.jp/~ef2o-inue/vba_k/sub0 …
なお、テーブルに列[住所不一致]列がなくても、クエリにて回答3と同じ方法で不一致レコードは抜き出せます。それが、最適解かも知れませんね。
HTML部分は自力で頑張って下さい。 カウンタはForループの添字[i]から１を引くことで求められます。 if の条件に AND （i - 1）Mod 20 ) = 0 を加えて下さい。 小生、タブレットの手書き入力なので「全文書いて」にはお応えしかねまする。
> 他の処理と関連させたいので、ＶＢＡでなければならないのです。 後出しじゃん。 http://oshiete.goo.ne.jp/qa/8786862.html の＃１さんの回答で良いのでは？ > どうにか自分でやろうとしたのですが、できませんでした。 上記回答の「最終行判定方法はイヤでループ判定でやりたい」？ なら、現在のコードを開示して下さい
VBAにしなくとも普通に関数でよいのではないかと。 Sub Macro1() Dim myRow As Long myRow = Cells(Rows.Count, "A").End(xlUp).Row Range(Range("B2"), Range("B" & myRow)).Formula = _ "=IF(COUNTIF(Sheet2!A:A,A2),VLOOKUP(A2,Sheet2!A:B,2,FALSE),"""")" End Sub
Sub 県名の列作成() Dim i As Long For i = 2 To Cells(Rows.Count, "B").End(xlUp).Row Range("D" & i).Value = Left(Range("B" & i), 3) Next i End Sub ではどうでしょうか。 Cells(Rows.Count, "B").End(xlUp).Rowで B列の入力されている最終行までにしています。 途中に空白があっても最後まで実行されます。
訂正です。 上側のコードですが、Addressが抜けておりました。 申し訳ありません。 またMeは不要です。Meはユーザーフォーム等で自身のフォームなどを対象にする場合に用います。 現在のワークシートを対象にするのであれば、Activesheet.Rangeとしてください。 Cells(cnt, n - 3) = WorksheetFunction.Sum( _ 　　Range( _ 　　　　"cr" & cnt & ":" & _ 　　　　Range("cr" & cnt).Offset(Range("CR6") * -1, 1).Address _ 　　) _ ) またn及びcntの値は正しいですか？cntが3以下または nが3以下ですと、エクセルの取り扱えるセル範囲外となりますのでエラーとなります。 以下のテストコードで動作致します。 （合計対象範囲はCR1：CS4となり、結果はCQ4セルに出力されます） Sub sample1() Dim cnt As Long, n As Long cnt = 4 n = 98 Cells(cnt, n - 3) = WorksheetFunction.Sum( _ 　　Range( _ 　　　　"cr" & cnt & ":" & _ 　　　　Range("cr" & cnt).Offset(Range("CR6") * -1, 1).Address _ 　　) _ ) End Sub Sub sample2() Dim cnt As Long, n As Long cnt = 4 n = 98 Cells(cnt, n - 3) = WorksheetFunction.Sum( _ 　　Range( _ 　　　　Cells(cnt, "cr"), _ 　　　　Range("cr" & cnt).Offset(Range("CR6") * -1, 1) _ 　　) _ ) End Sub
excelとのことですので、VBAですね。 単純に複数のコントロールを変数を用いて指定し、プロパティを設定するだけなら、Controlsコレクションを使用します。 http://www.moug.net/tech/exvba/0140013.html ですが、 今回ご提示の質問のように、チェンジイベントをまとめて記述するには以下のような方法があります。 http://oshiete.goo.ne.jp/qa/8747288.html
こんばんは！ 細かい配置まで検証する気力がありませんが・・・ ＞Grp1~10をB7に、yamada10xをC7に抽出するように変更 ＞Grp1~10をJ7に、yamada4xをK7に抽出するように変更 と ＞Sheet1のyamada10xとyamada4xのセルBの位置をセルCに移動させたい場合なのですが の件に関しては、↓の画像のような配置と解釈しています。 尚、 ＞空けておいた３行に罫線が設定してしまい、繰り上がってきます。 ＞これは wS2.Cells(k, (i - 2) * 8 + 2).Resize(, 2).Delete shift:=xlUp ＞重複しているセルの削除が関係しているのですか？？？ はい！その通りです。 文章だけでは、お手元にある表の細かいレイアウトは全く判りませんので （もちろん質問にもそんなコトは書いてないので）そこまでの対処はしていません。 とりあえず今判っている問題点だけを考慮しもう一度コードにしてみました。 （削除したセルは追加して下側のセルのレイアウトに影響を与えないようにしています） Sub Sample4() Dim i As Long, j As Long, k As Long, lastRow As Long, lastCol As Long Dim wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") Application.ScreenUpdating = False If wS2.Range("A1") = "" Then wS2.Range("A1") = "ダミー" End If lastRow = wS2.UsedRange.Rows.Count '▼7行目が項目行？なので7行目で最終列取得 lastCol = wS2.Cells(7, Columns.Count).End(xlToLeft).Column If lastRow > 6 Then For j = 2 To lastCol Step 8 Range(wS2.Cells(7, j), wS2.Cells(lastRow, j + 1)).ClearContents Next j End If '★←追加 With Worksheets("Sheet1") '▼Sheet1の項目行は5行目？ If .Range("A5") = "" Then .Range("A5") = "ダミー" End If '▼C列で最終行取得 lastRow = .Cells(Rows.Count, "C").End(xlUp).Row '▼C列でフィルタ（重複なしでSheet3のA1セルに貼り付け） Range(.Cells(5, "C"), .Cells(lastRow, "C")).AdvancedFilter Action:=xlFilterCopy, copytorange:=wS3.Range("A1"), unique:=True '▼Sheet3の2行目～最終行まで For i = 2 To wS3.Cells(Rows.Count, "A").End(xlUp).Row '▼Sheet2の7行目に項目表示 wS2.Cells(7, (i - 2) * 8 + 2) = .Range("AA5") '▼「○○の合計数」という表示形式ではなく、データそのまま wS2.Cells(7, (i - 2) * 8 + 3) = wS3.Cells(i, "A") '▼Sheet1の5行目のC列でオートフィルタ（Sheet3のi行A列でフィルタを掛ける） .Rows(5).AutoFilter field:=3, Criteria1:=wS3.Cells(i, "A") '▼AA列の表示されているデータをSheet2の8行目、(i-2)*8+2　列に貼り付け Range(.Cells(6, "AA"), .Cells(lastRow, "AA")).SpecialCells(xlCellTypeVisible).Copy wS2.Cells(8, (i - 2) * 8 + 2) wS3.Range("C:C").Clear For k = wS2.Cells(Rows.Count, (i - 2) * 8 + 2).End(xlUp).Row To 8 Step -1 wS2.Cells(k, (i - 2) * 8 + 3) = WorksheetFunction.CountIfs(.Range("AA:AA"), wS2.Cells(k, (i - 2) * 8 + 2), .Range("C:C"), _ wS2.Cells(7, (i - 2) * 8 + 3)) If WorksheetFunction.CountIf(wS2.Columns((i - 2) * 8 + 2), wS2.Cells(k, (i - 2) * 8 + 2)) > 1 Or _ wS2.Cells(k, (i - 2) * 8 + 3) = 0 Then wS2.Cells(k, (i - 2) * 8 + 2).Resize(, 2).Delete shift:=xlUp '▼削除したセルの1行下を挿入 wS2.Cells(k + 1, (i - 2) * 8 + 2).Resize(, 2).Insert shift:=xlDown End If Next k Next i wS2.Columns.AutoFit wS2.Cells.Replace what:="ダミー", replacement:="", lookat:=xlWhole .Cells.Replace what:="ダミー", replacement:="", lookat:=xlWhole wS3.Cells.Clear .AutoFilterMode = False End With '▼Sheet2のB7セルと連続しているセルに格子の罫線 wS2.Range("B7").CurrentRegion.Borders.LineStyle = xlContinuous Application.ScreenUpdating = True End Sub ※　今までのコードで行・列合わせは理解の方法は理解できたと思いますので、 後はご自身で頑張ってみてください。m(_ _)m
どこかのセルに =sumif(B1:B5,1,A1:A5) 1の合計 =sumif(B1:B5,2,A1:A5) 2の合計 これだけです。 マクロの文法やら実行方法やら覚えるよりずっと楽で応用も利きます。マクロは毎回毎回同じ操作を延々続ける人にとっては手間を省いてもらえますが、マクロを書くのは面倒です。一回ポッキリの使用には適しません。
こちらで解決するかも（charset の指定）？ 文字化けするのは、YAHOO.BBの携帯だけで発生するのか 特定のWEBページのテキストでだけ発生するのか オブジェクトの値ではなくて手打ちのテキストでも発生するか なども確認する必要があるかも？です。 当方テスト環境は作れないので、ここまで。 メモしとこ CDO.Messageによるメール送信 http://serialty.blog117.fc2.com/blog-entry-10.html
特殊ディレクトリの取得方法は以下ページのようにしてください。 http://dobon.net/vb/dotnet/file/getfolderpath.html
> たとえば、「現在の状態をコードとして表示する」なんてことでもいいんですが・・ > 現在のフォームの状態、どこかにないんですかねぇ。 それはコンパイラされたアセンブリの実行中の動作結果であって、開発上のソースにはどこにもありません。 > ご紹介いただいてる「変換.zip」というのはどういうものなんですか？ Excelでの変換方法です。 単純に説明しづらいので、アップローダを利用してあげてます。
DOUGLAS_ です。 > 早速試してみたのですがエラー表示が出て先に進めませんでした。 　ここで躓かれているようでしたら、ちょっと後が心配ですが。。。 myPath = Environ("USERPROFILE") & "\Desktop\Hoge\" の行で、作成された htmlファイル の保存場所を指定しています。 　上の例ではデスクトップに「Hoge」というフォルダを予め作成しておかなければ、「パスが見つかりません。」となるのは当然です。 　ですから、「Environ("USERPROFILE") & "\Desktop\Hoge\"」の部分を、oshiete100goo さんが、実際に htmlファイル を保存したいと思っていらっしゃるフォルダのフルパスに書き換えてください。 　ただし、一番最後に「\」を付けてくださいね。 例） myPath = "C:\Users\user\Documents\Hoge\" myPath = "D:\oshiete100goo\html\"
No.1です。 結局、行・列合わせだけの問題だと思います。 質問ではSheet1のB列は2種類だけですが、何種類あっても対応できるようにしてみました。 Sheet2の他の列に数式などが入っていてはいけませんので、 D:E列・I：J列・N:O列・・・と5列おきに操作しています。 Sub Sample3() Dim i As Long, j As Long, k As Long, lastRow As Long, lastCol As Long Dim wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") Application.ScreenUpdating = False If wS2.Range("A1") = "" Then wS2.Range("A1") = "ダミー" End If lastRow = wS2.UsedRange.Rows.Count lastCol = wS2.Cells(10, Columns.Count).End(xlToLeft).Column If lastRow > 9 Then For j = 4 To lastCol Step 5 Range(wS2.Cells(10, j), wS2.Cells(lastRow, j + 1)).ClearContents Next j End If With Worksheets("Sheet1") If .Range("A4") = "" Then .Range("A4") = "ダミー" End If lastRow = .Cells(Rows.Count, "B").End(xlUp).Row Range(.Cells(4, "B"), .Cells(lastRow, "B")).AdvancedFilter Action:=xlFilterCopy, copytorange:=wS3.Range("A1"), unique:=True '★ For i = 2 To wS3.Cells(Rows.Count, "A").End(xlUp).Row wS2.Cells(10, (i - 2) * 5 + 4) = .Range("F4") wS2.Cells(10, (i - 2) * 5 + 5) = wS3.Cells(i, "A") wS2.Cells(10, (i - 2) * 5 + 5).NumberFormatLocal = "@の合計数" .Range("A4").AutoFilter field:=2, Criteria1:=wS3.Cells(i, "A") Range(.Cells(5, "F"), .Cells(lastRow, "F")).SpecialCells(xlCellTypeVisible).Copy wS2.Cells(11, (i - 2) * 5 + 4) For k = wS2.Cells(Rows.Count, (i - 2) * 5 + 4).End(xlUp).Row To 11 Step -1 wS2.Cells(k, (i - 2) * 5 + 5) = WorksheetFunction.CountIfs(.Range("F:F"), wS2.Cells(k, (i - 2) * 5 + 4), .Range("B:B"), _ wS2.Cells(10, (i - 2) * 5 + 5)) If WorksheetFunction.CountIf(wS2.Columns((i - 2) * 5 + 4), wS2.Cells(k, (i - 2) * 5 + 4)) > 1 Then wS2.Cells(k, (i - 2) * 5 + 4).Resize(, 2).Delete shift:=xlUp End If Next k Next i wS2.Columns.AutoFit wS2.Cells.Replace what:="ダミー", replacement:="", lookat:=xlWhole .Cells.Replace what:="ダミー", replacement:="", lookat:=xlWhole wS3.Cells.Clear .AutoFilterMode = False End With Application.ScreenUpdating = True End Sub 今度はどうでしょうか？m(_ _)m
> このエラーの原因はなんでしょうか？解決方法を教えてください。 シート名とリストで選択しているようですが、半角スペース区切りを期待しているようですね。 半角スペースの右側。ちゃんとシート名と一致してますか？
> 2000行くらいのデータ数なので、ループを使うと重くなります。 > フォルダ検索を再帰処理で行っているため、これ以上速度を落とすことはできません。 失礼な話ですね。 補足、ということは、これを読んでどうにかして欲しい、ということなのでしょうけれど、 文句を言う前に何をやりたいのか具体的に示したらどうですか？ > 2000行 その程度で重くなるのは、設計の問題ですから、そちらで見直してください。 > フォルダ検索を再帰処理で行っているため その処理が遅くて困っている、ということと、件の質問と どのような関係があって、何を訊きたいのですか？ 2000行程度で、"重く"なる状態、ということは、 少なくともExcel2007以降のバージョンだということは想像できます。 でも、想像をどれだけ膨らませても、あなたの望むものを書くことは出来ません。 具体的な条件に合わせて"重くならないよう"手当てすることは出来ますが、 漠然と汎用的な万能薬のようなものを期待されているのでしたら、 残念ながら、そのようなものはありません。 強いて言えば、オートフィルそのものが遅いのですから、 設計も見直しから始めることになるのでしょう。 > オートフィルをした場合、 > 範囲内のセル全てに処理が適応されません という質問に対する応えとしては、＃１の内容以上に書くことはありません。 条件を後出しにして、わざわざ解決を遠避けて楽しんでおられるのでしたら、 或いは、ご自分の置かれた状況や抱えている問題を説明することが出来ないのでしたら、 質問するより先に調べてみてはいかがですか？ このサイト内でも、関連していそうなQAは多数あると思いますよ。 そういうスレを読むことで、あなたが必要とする解決策を手に入れる為には、 どのように質問を組み立てていけばいいのか、とか、 どうすればご自身のなさりたいことを伝えることができるのか、とか、 探ってみるなり、既存の質問・回答を参考にご自身で応用するなり、 何れにしても、もう少し考えてから 仕切り直したほうがよいのではないかと思います。 具体的な回答を付けるのに必要十分な補足でもあれば、解決へのお手伝いはします。 しかし、対話的でなく、尚、挑発的なやりとりしか出来ないのでしたら、 私には引き受けられることはありませんので、退席することになるでしょう。 尚も解決を望まれるようでしたら、ちゃんとした補足をしてください。
＃３-５,７、ｃｊです。＃７お礼欄へのレスです。 > 動作確認の準備ですが１，２迄で出来きました > ３、のコピー＆ペーストする場所ですが、コード表示画面にてユーザーフォームを表示し、そのユーザーフォーム内の部分をダブルクリックして、表示された画面にコードをコピー＆ペーストすればよいのでしょうか？、ペーストしたコードの初めの１０行ほどが赤字になっています、何処かおかしいでしょうか 大丈夫です。ご指摘の状況は異常ではありません。 "そのユーザーフォーム内の部分をダブルクリック"すると、 Private Sub UserForm_Click() End Sub が表示されますよね？その画面（コードペイン）の記述をすべて消してから、 ＃７のコードを貼り付けます。 "ペーストしたコードの初めの１０行ほどが赤字になっています" おかしくないですから安心してください。 #Ifから#End Ifまで、これは条件付きコンパイルというもので、 Excelのバージョン環境によって、どこかしら構文エラーで赤い字にはなりますが、 VBAはそれらの記述を読み飛ばしますから、動作には影響ないです。 そもそもは、様々なバージョンに自動的に対応させる為の記述です。 気にせずに動作確認して貰っても問題ない筈です。 もし気になるようでしたら、赤い字で書かれている行を 削除しちゃっても構いませんので。 赤い字を削除した場合は、その前後の #If VBA7 Then #Else #End If の３か所についても、消しちゃって構いません。 取り急ぎの返答でした。
サラッと検索したら出てきました。 もちろん使ったことがないのでご自分で試してみてください。 .NET diff class http://d.hatena.ne.jp/siokoshou/20070315
VBAによる対応となります。 対象のシートタブを右クリックしてコードの表示を選び、 最下のVBAコードを貼り付けてください。 セルに値が入力されるとグラフの参照範囲が変わります。 ■コードの修正 以下のコードでは、対象のグラフ名が「グラフ 11」であり、 変更するセル範囲がB列1行目から最終行までとしています。 (1)対象のグラフ名を変更する場合 　　If .ChartObjects(i).Name = "グラフ 11" Then 　　「グラフ 11」の部分を修正してください。 (2)再設定するセル範囲を変更する場合 　　Range(Cells(1, "B"), Cells(Rows.Count, "B").End(xlUp)) 　　→Cells(1, "B")が開始セルになります。 　　　　Cells(行番号, "列記号")の様式で記述 　　→Cells(Rows.Count, "B").End(xlUp)が終了セルになります。 　　　　Cells(Rows.Count, "列記号").End(xlUp)の様式で記述 ■VBAコード Private Sub Worksheet_Change(ByVal Target As Range) With ActiveSheet For i = 1 To .ChartObjects.Count 　　'変更対象のグラフ名を設定 　　If .ChartObjects(i).Name = "グラフ 11" Then 　　　　'グラフの参照範囲をB1:B最終行に変更 　　　　.ChartObjects(i).Chart.SetSourceData Source:= _ 　　　　　　Range(Cells(1, "B"), Cells(Rows.Count, "B").End(xlUp)) 　　　　Exit For 　　End If Next i End With End Sub
Visual Basicの勉強に際しては、 Excelの関数式の理解から始めることをお勧めします。 いきなり、Visual Basicでは荷が重いと思います。 関数式のヘルプを読み下せれば、 Visual Basicのヘルプを読み下す能力が向上します。 両方のヘルプが理解できれば、参考書は不要です。 Visual Basicの参考書というのは、つまるところはヘルプの解説書です。 Visual Basicのヘルプは、通常のインストールではインストールされていません。 ExcelのVBAにアクセスし、ヘルプをクリックするとインストールの方法を指示してくれます。 Excelのインストール用CDが必要です。 Visual Basicの勉強とは直接的には関係ありませんが、 Visual Basicにてプログラム(マクロ)を作るということは、 PCに特定の処理方法(製作者がやりたいこと)を実行させるということなのです。 従って、処理方法を具体的に論理展開できる能力が欠かせません。 私は国語能力(論理展開能力)の向上こそが、最も重要と考えます。 また、Visual Basicは英語で記述しますので、英語を理解することも大事です。(英会話ではありません。) 国語能力(論理展開能力)の向上の最も効果的な手法は、小説等の読書です。 中１ならば、漱石の小説がいいのでは。
他回答にあるLastrowは、エクセルで用意されてる最終行つまりセル「CU最終行」までジャンプし、上へ向かってデータのあるセルを見つけ、その行番号を示すものです。この方法の利点は、途中に空白セルがあっても影響を受けずデータのある最終行を取得できる事です。CU列限定ですが。 あなたの望みと合致しますか？質問文にある「文字列と空白が交互にある」のは分かりますが、文字列のある最終行が欲しいのか、あるいは空白行は選択せず飛ばしたいのかどちらですか？後者は少々面倒です。
レジストリへの書き込み、読み込み、削除を行う http://dobon.net/vb/dotnet/system/registrykey.html
まずは、ＶＢ（ビジュアルベーシック）て何？ これについて説明しておきますね。 http://oshiete.goo.ne.jp/qa/1431672.html http://oshiete.goo.ne.jp/qa/1252366.html を参考にしてください。 実は、目的に応じてＶＢはいくつもあるのです。 ただ文法が同じと云うだけで使い方など全く違います。 まずは、小手初めに、ご自身のパソコンで使ってみてください。 もし、Ｏｆｆｉｃｅ製品がインストールされているのであれば エクセルＶＢＡが手っ取り早いでしょう。 Ｏｆｆｉｃｅモインストールされていなければ ＶＢＡで勉強しても良いでしょう。 エクセルＶＢＡで良ければ http://www.eurus.dti.ne.jp/yoneyama/Excel/vba/in … のサイトでもよく見て勉強してみてください。 有料の講習会であれば、アビバなど多数あります。 無料となると、ネット上で独学するか 親しい友人でＶＢに詳しい人に教えていただく事になると思います。 実は、私も独学で学んだ一人です。 頑張ってみてください。
こんばんは！ COUNTIFS関数で対応できそうですが、VBAでの方法をご希望というコトですので 一例です。 Sheet3を作業用のSheetとして使用していますので、Sheet3は使用していない状態にしておいてください。 Sheet1のA列データが何種類あっても対応できるようにしてみました。 標準モジュールです。 Sub Sample1() Dim i As Long, k As Long, lastRow As Long, wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") Application.ScreenUpdating = False wS2.Cells.Clear With Worksheets("Sheet1") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row .Range("A:A").AdvancedFilter Action:=xlFilterCopy, copytorange:=wS3.Range("A1"), unique:=True For i = 2 To wS3.Cells(Rows.Count, "A").End(xlUp).Row .Range("A1").AutoFilter field:=1, Criteria1:=wS3.Cells(i, "A") wS2.Cells(1, (i - 1) * 2 - 1) = wS3.Cells(i, "A") & "の合計数" wS2.Cells(1, (i - 1) * 2) = "Ｇｒｐ番号" Range(.Cells(2, "B"), .Cells(lastRow, "B")).SpecialCells(xlCellTypeVisible).Copy wS2.Cells(2, (i - 1) * 2) For k = wS2.Cells(Rows.Count, (i - 1) * 2).End(xlUp).Row To 2 Step -1 wS2.Cells(k, (i - 1) * 2 - 1) = WorksheetFunction.CountIfs(.Range("A:A"), wS3.Cells(i, "A"), _ .Range("B:B"), wS2.Cells(k, (i - 1) * 2)) If WorksheetFunction.CountIf(wS2.Columns((i - 1) * 2), wS2.Cells(k, (i - 1) * 2)) > 1 Then wS2.Cells(k, (i - 1) * 2 - 1).Resize(, 2).Delete shift:=xlUp End If Next k Next i wS2.Columns.AutoFit wS2.Range("A1").CurrentRegion.Borders.LineStyle = xlContinuous wS3.Cells.Clear .AutoFilterMode = False End With Application.ScreenUpdating = True End Sub こんな感じではどうでしょうか？m(_ _)m
インストーラを自作する能力がない、へなちょこプログラマは、数十万円のインストーラ作成ソフトを買うのだけど、 それでも、アンインストール前に入力画面を出すのは無理っぽい。 http://www.freeml.com/msi/1409/latest
ウィルスだと「マルチプロセスにしてお互いを監視させる」とかありますね。 一定の条件で監視をしないようにさせれば良いのでは。
＃１です。お礼欄拝見しました。 > variant型も、購入した本で極力使うなと書いてあったもので、なんとなく意識から外れていまして、 > 当たり前ですが、（極力）というからには使う機会があるのですね。 ＶＢＡ内部での演算に関しては、 ハッキリとデータ型が特定できるものは適切な型を選ぶべきです。 Variant方を避ける理由として、 　・使用するメモリが大きい 　・演算が（適切な型に比べると）比べると遅い ここら辺の理由は、現代的には一般的ＰＣスペックの向上とともに 以前ほどには説得力ない気もしますが、無駄は無いに越したことはないです。 でも、これからもＶＢＡを勉強するのでしたら、 　・上達が遅くなる という理由が大きくなります。 Variant型は、どんなデータ型でも格納できる、というものなので、 例えば、Variant/Double とか Variant/Long とか Variant/String とか 内部にはしっかりデータ型が指定されて格納されるものなのです。 ここをキチンと理解しておかないと、Variant型の方が却って難しい場面もあります。 例えば、小数点数を扱うデータ型には、 Single、Double、Currency、Date、等がありますが、中身は同じ小数点数ですから、 これらを異種相互に演算したり、代入したり、することも条件付きで可能です。 そんな時、どのデータ型で演算するのか、 本来的なプログラムではデータ型を変換して揃えないと エラーになって計算出来ないものでも、 "気を利かせて"、"器用に"、"無難に"、演算してくれるのがVariantです。 しかし、見方を変えると、"勝手に"データ型を変えてしまうこともあるので、 こちらの意図を見抜いて適切な型を選ぶ機能は無いので、 そういった特性を正しく理解していないと、 部分的な演算は通っても、型のキャストのせいで、その後の処理でエラーになる というような場合も出てきます。 そういう観点からすると、 初級の初めぐらいの学習者にとっては、問題になることもなく、 ただただその重宝さを享受して、次々に書く経験を増やせる点でメリットがあるけれど、 そろそろ中級ともなれば、却って扱いが難しくなってきます。 何より、あらゆるデータ型を理解しなければ、Variant型を使いこなすことも出来ませんし、 その上でVariant型の特性を理解するのも容易ではないです。 なので、まずはともかく、Variant型以外を覚えて貰わないと、 Variant型の使い方の話は出来ない、という意味で、 初級の初めを過ぎたら、極力使うな、という教え方になります。 実際は、Variant型でなければならないケースも多数ある訳ですが、 今は、そういうことに拘って停滞しちゃうよりは、 記憶の内にだけ留めて前に進んだ方がいいですし、 この課題は、今考えるのでなく後回しにした方が、 この課題への理解を深めるまでの近道になるんだと思います。 私が＃１で書いた Dim myRecess As Variant については、 部分的には、文字列値を格納していますから、 String型でも、コードは問題なく通ります。 また、格納したいのは、日付時刻型なのですから、 Date型に格納するのが、本来的・教科書的・基本的、な、やり方です。 （時刻値の扱いは掘り下げると書き切れないので略） では何故わざわざVariant型を選んだかというと、 ＃１にも軽く説明しましたが、セル範囲には文字列型で出力した方が 手間が省けるという、ご都合的・実戦的・応用的、な、方法論 （＋視覚的に解り易い記述を選んだ）です。 ここまでは、何故文字列値なのかという説明で、 Variant型の変数であっても、内部的には、Variant/String型になっています。 この値を演算（加・減算）することがあるなら、 myRecess = CDate(myRecess) のように１行加えて、 本来のVariant/Date型に型変換してやるだけで済むので、 都合により一時的にString型にしますが、 いつでもDate型に型変換してくださいね、 という意味でもあり、受け皿としてはVariant型を選ぶことになったのです。 また、他の観点から、 日付時刻に関するＶＢＡの関数の戻り値は軒並みVariant型ですし、 セル範囲の値等とＶＢＡ変数とのデータのやりとりも基本的にVariant型を使います。 個人的に最近は、時刻のみのデータはなるべくVariant、日付を含む場合はDate を使うようにしてデータ型変換関数と組み合わせるようにしています。 でもまぁＶＢＡは様々な書き方を許容するように作られている面もあって、 教本での教え方と、私（やここで回答する人）の教え方が、 一致する可能性は低いですから、 > 未然に混乱を避ける意味もある 解らなくなったら、今手にしている教本を終わらせることを優先した方がいいです。 質問掲示板も使いよう、、、です。 一応、疑問にはお応えするべきと思ったので説明を書きましたが、 先にも述べたように、以上のことは軽くスルーしてくれた方が吉、 （記憶の隅に置いといてくれるなら尚）私としてもベターです。 > Swichは知らなかったので勉強になります。ファイルサイズが増えていくようなら、このような短い記述の方が処理が軽くなったりするのでしょうか。こういった関数を積極的に使えるように、勉強を重ねたいと思います。 ファイルサイズの差は、看過できるレベル、でしょう（誤差のレベルと言ってもいい）。 処理速度という面では（テストしてませんが）関数をひとつ余計に使う訳ですから、 こちらもメリットは無い筈です。 ですので、Switch関数については、 今からワザワザ覚えるほどのものではない、というニュアンスで書いたつもりだったのです。 まぁ、タイプする文字数が少ない、ということは、仕事が早く片付く訳ですから、 状況によってはメリットありそうです。 マクロといっても繰り返し実行するものばかりではなくて、 例えば、新しいシートを作成する仕事など、一度しか使わないから早く簡単に書きたい場合 もありますし、デバッグ用、テスト用のコードとかもサクッと終らせたいですよね。 行数が少ないということは、昨今の小さなモニター環境での作業には有利でしょう。 ＴＰＯによっては使いでがあるとか、人によってはそういう回答をするかも、 という程度のものです。 > TimeValue関数は、やはり時間の表示もしてくれるみたいなのですが、時刻と時間を区別しなくても問題ないということですか？ まず、 "時刻と時間を区別"については、基本的にExceもＶＢＡも内部的には区別しないものと考えて下さい。 > myTime = LAST_TIME - STAR_TIME これは形式的に、時間 = 時刻 - 時刻 という計算をしているわけです。 この文脈では時間は時刻として扱われます。 "時刻と時間を区別"する必要があるのは、 セルに時間を表示する場合、や、 ExcelまたはＶＢＡで文字列として時間を得たい場合、に限られます。 例えば、セルＡ１に勤務時間を合計した「123時間45分」を意味する値が入っているとして、 （内部的には 1900/1/1 0:00:00 を１とした 1900/1/5 3:45:00 という日付時刻値です） "123:45"のように表示したい場合は、 [セルの書式設定][表示形式][分類][ユーザー定義][種類]に、[h]:mm のように指定するとか。 例えば、関数を使って他のセルに文字列として"123:45"を返したい時は、 　=TEXT(A1,"[h]:mm") とか。 例えば、ＶＢＡでセルＡ１の値から、文字列値"123:45"を取得するには、 　rtn = WorksheetFunction.Text(Cells(1, 1).Value, "[h]:m") とか。 「表示する文字列」　と　「値」　との違いを意識するようにしましょう。 意味が解らないようでしたら、 セルに表示されている文字列、と、数式バーに設定されている値、は、 違っていることがある、ということを時々思い出してみてください。 今は理解出来なくても、その内スーッと呑み込めるようになるでしょう。 > "TimeValue関数は、やはり時間の表示もしてくれるみたい" 表示は関係ないので、ちょっと意図が汲めませんでした。 ＶＢＡのヘルプでTimeValue関数を引くと、 "時刻を表すバリアント型 (内部処理形式 Date の Variant) の値を返します。" と書かれています。 > 私がFormatでわざわざ時刻を指定してしまっていた。という認識でよいのでしょうか。 幾つか勘違いされていますが切り口として一点だけ説明します。 TimeValue関数は、文字列値を渡して日付値を返しますが、 Format関数は、この場合なら日付値を渡して文字列値を返します。 ExcelのTEXT関数と似た機能を持ちます。 主な使い方としては、数値（日付値も中身は数値です）を 指定した書式の文字列値にする、といった感じです。 例えば、セルＡ２の値が日付値 2015/1/2 3:45 だったとして、 "15/01/02 03:45"という書式を適用した文字列を返す場合には、 　MsgBox Format(Range("A2").Value, "yy/mm/dd hh:mm") などの様に使います。 以上で文字数制限4000文字。
> (2)Range("A1:C5,E1:G5") ⇒　？？？ Union(Range(Cells(1, 1), Cells(5, 3)), Range(Cells(1, 5), Cells(5, 7))) でいかがでしょう。
一例ですが Sub kigoumade() Range("DK30").Activate Do Until ActiveCell.Value = "※※" Range("BR" & ActiveCell.Row & ":EE" & ActiveCell.Row).UnMerge Range("BR" & ActiveCell.Row & ":EE" & ActiveCell.Row).Clear ActiveCell.Offset(1).Activate Loop End Sub では如何でしょうか。
No3の具体例として 1,2,3,4,5,6,7 8,9,10,11,12,13,14 15 ↑こんなデータの場合元のコードでエラーになります。 また 1,2,3,4,5,6,7 8,9,10,11,12,13,14 ,15,,,,, ↑こんなデータの場合、元のコードだと最後の改行がないとエラーになります。No4さんと逆ですね。 1,2,3,4,5,6,7 8,9,10,11,12,13,14 ↑こんなデータだと改行は関係なく元のコードでもエラーになりません。 ちなみに、どのデータでもNo3のコードに変更すればエラーにはなりません。ただし2013の結果です。
＞その稼働しない動作はデバイスの状態変更(有効から無効)にする動作です。 デバイスに停止命令を送っているAPI関数から、どういう戻り値が返って来るか表示してみましょう。 「デバイスに対するアクセス権なし」とか「デバイスに対するファンクション番号エラー」とか、色々なエラーが返されている可能性があります。 それ以前に、API関数が正常終了したかエラー終了したかくらいは調べましょう。 あと、もしかしたら「無効化しても、勝手にすぐに有効化しちゃってる」と言う可能性も捨て切れませんし、そもそも「無効化できないデバイス」なのかも。
http://www.atmarkit.co.jp/bbs/phpBB/viewtopic.ph … もしこのような状況で、プロシージャ名が全角であることが起因し、プロシージャ名の 変更が行えないなら、別プロシージャを作成してラップすればいいと思います。 また、こちらのように、プロシージャ名にパラメータまで設定しているなら外してください。 http://otn.oracle.co.jp/forum/message.jspa?messa …
No2です。 度々申し訳ありません。 コードの修正になります。 1つ目の「■VBAコード」（速度向上版ではない方）において、 　(1) 「i = 1」を「m = 1」にしてください。 　(2) 「Exit Sub」を削除してください。
もともとB列に旧商品名があってそれをC列に代入してB列の旧商品を新商品に変換するという動作でしたら たとえば Range("C" & i).Value=Range("B" & i).Value と必要な分だけループか検索かで代入しておいて あとは B列の商品名をreplaceで書き換えたらいかがでしょう。 > また、VBAについて初心者向けにわかりやすく解説しているサイト エクセル vbaで検索したら色々出てきますのでご自身にあったページを参考にしてみてください。 たとえば http://www.eurus.dti.ne.jp/~yoneyama/Excel/vba/ とか http://officetanaka.net/ とか http://www.happy2-island.com/excelsmile/ などいかがでしょう。 基本的に「エクセル vba やりたいこと(たとえばファイルを開くとか)」で検索すると解説しているページが結果として出てきますので、その中で分かりやすいページを見つけるのもいいかと思います。
http://www.atmarkit.co.jp/fdotnet/dotnettips/105 … http://build.sharpdevelop.net/BuildArtefacts/#IL … デバッグビルドのexeなら、コメントも戻ると思います。
こんにちは！ ＞B列に８月21日から９月20日まで入力されてます。 というコトはB30から翌月の20までのシリアル値が入っているというコトですよね？ 余計なお世話かもしれませんが、 月始まりが大の月の場合は問題なく31行分のデータだとと思いますが、 小の月の場合は31行分ではなく30行分（2月の場合は28もしくは、29行分）のデータになるのではないでしょうか？ （途中に空白セルがない場合） それらを考慮したうえでのコードの一例です。 Sub Sample1() Dim lastRow As Long, c As Range Set c = Range("B30").End(xlDown) '←B列最終行を取得 If c.Row < 30 + Range("BW28") - 1 Then '←30はB30の行番号 lastRow = c.Row Else lastRow = 30 + Range("BW28") - 1 End If Range("B30:B" & lastRow).Resize(, 66).Select End Sub こんな感じをご希望なのでしょうかね？m(_ _)m
＞そのタイミングなのですがどのようなプログラムになるか簡単なソースやサイトがあれば教えていただきたいです。 そういう「サンプル」は存在しません。 デバイスの仕様、そのデバイスをコントロールするドライバの仕様に合わせ「仕様通りにプログラミングするしかない」です。
> 税率も表示させたいのですがどうすればいいでしょうか。 書き出し部分を変更します。 税率は、配列argの４列目、つまりarg(x,4）に格納しています。 ただし、大小比較のために無税は０（ゼロ）値として格納していますので、「無税」表示とするなら書き出しの時に戻す必要があります。 ～～～ 　　While　arg(aln,　1)　>　0 　　　　Cells(30　+　aln,　1)　=　arg(aln,　1) 　　　　Cells(30　+　aln,　2)　=　arg(aln,　3) 　　　　If　（arg(aln,　4)＝0）　then　　　　　　　'//ここから税率の書き出し 　　　　　Cells(30　+　aln,　3)　=　"無税"　　　'　値が0％の時に無税に変換する。 　　　　Else 　　　　　Cells(30　+　aln,　3)　=　arg(aln,　4)　　'　税率数値を書き出す。 　　　　End If　　　　　　　　　　　　　　　　　　　　'ここまで//　　 　　　　Cells(30　+　aln,　4)　=　arg(aln,　5) 　　　　Cells(30　+　aln,　5)　=　arg(aln,　6) 　　　　aln　=　aln　+　1 　　Wend ～～～ なお、 　Cells(30　+　aln,　□) の□部分は、回答4の通り、結合セルの先頭列にあわせて変更ください。　
> なので、終わった工事の行を選択し、1クリックで塗りつぶすボタンを作りたいのです。 選択した範囲 = Selection 選択した範囲の行 = Selection.EntireRow 選択した範囲の行 の A:N = Range("A:N (" & Selection.EntireRow.Address(0, 0) & ")") Sub Re8762667od() Dim c As Range 　　If TypeName(Selection) <> "Range" Then Exit Sub 　　For Each c In Range("A:N (" & Selection.EntireRow.Address(0, 0) & ")") 　　　　If c.MergeArea(1).Interior.ColorIndex = xlColorIndexNone Then 　　　　　　c.MergeArea.Interior.Color = 16777164 　　　　End If 　　Next End Sub > なので、終わった工事の行を選択し、1クリックで塗りつぶすボタンを作りたいのです。 > この黄色のセルだけ塗りつぶさず、他のセルを塗りつぶしたいのです。 黄色 = 65535 = vbYellow Sub Re8762667od2() Dim c As Range 　　If TypeName(Selection) <> "Range" Then Exit Sub 　　For Each c In Range("A:N (" & Selection.EntireRow.Address(0, 0) & ")") 　　　　If c.MergeArea(1).Interior.Color <> vbYellow Then 　　　　　　c.MergeArea.Interior.Color = 16777164 　　　　End If 　　Next End Sub
ざっくり書くとこんな感じ １．テキストファイルをシーケンシャルファイルして開く ２．行単位で読み込む処理をＥＯＦまで繰返す。EOFなら６へ ３．１行読めたら、キーワードを含むか判断し、含まれるなら４へ、含まれないら５へ ４．：（コロン）でブった切る。切った右側を利用。 ５．３へ戻る ６．ファイルを閉じる ・４はSplit関数でセパレータ文字にコロンを指定。配列の２項目がソレ しかし ・４で見つけたデータは「どう保存」するのかな？ ・コロンは全半角の何れかに統一されてる？
ここは [技術者向] コンピューター > プログラミング > Visual Basic というカテゴリなので，それに沿って回答します。 System.IO.File.StreamWriterのコンストラクタの第一引数にファイル名を指定できるので， そこに"○○.sql"と指定するだけでよいです。 ref) http://msdn.microsoft.com/ja-jp/library/fysy0a4b(v=vs.110).aspx このコンストラクタ自体はBCLに存在するようなので， CLIの実装がCLR (.NET Framework)でなく，例えばmonoであっても存在します。 ref) http://docs.go-mono.com/?link=C%3aSystem.IO.Stre …(System.String)
フォームアプリケーションをサービスに登録することはできません。 ログインしていない状態でも動作させたいなら、タスクスケジューラーに『スタートアップ時』で登録すればいいかもしれません。 http://ameblo.jp/parallel-line/entry-11071840143 … ログインした際にということならば、ログインユーザーのスタートアップにショートカットを入れておけば済むでしょう。 Windows7の場合、対象フォルダは以下です。(すべてのプログラム→スタートアップに、ショートカットをドラッグしてもいいですが) C:\Users\ユーザー名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
こんばんは！ 横からお邪魔します。 ＞D2-H2,D5-H5,D8-H8などのもともとA-CのとなりにあったセルデータをれぞれのセルA-Dに500人分動かすのが最終目標ですが、 ＞一括で3行飛びで移動させるための・・・ 結局2・5・8・・・行目のA～C列データを削除してその行の残りのデータを左詰めにすれば良いのでしょうか？ そうであれば↓のコードを試してみてください。 Sub Sample1() Dim i As Long Application.ScreenUpdating = False For i = 2 To 501 Step 3 Cells(i, "A").Resize(, 3).Delete shift:=xlToLeft Next i Application.ScreenUpdating = True End Sub こんな感じをご希望だったのでしょうかね？m(_ _)m
#1です。 「これとは別に・・・」 何を言っているやら。 ちゃんと色も変わるように作ってあるはずだが、何が不足なんでしょうね。 誰かが作ったものをそのまま使うということではなくて、それを参考にして自分で調べ、考えるのでなければ、思うようなことはできないね。全部誰かに作ってもらうというのであれば、それ相当の対価が必要と思うが。
すでに曲が取り込まれていて どれかの曲が選択または再生または一時停止しているときに userformを閉じると何番目かを取得（表示）します。 　（リスト中の曲名を再生中の曲名で検索しています。） 　（エラー処理してありません） Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer) Dim i As Long, nm As String, lstct As Long, lstnum As Long lstct = Me.WindowsMediaPlayer1.currentPlaylist.Count nm = Me.WindowsMediaPlayer1.currentMedia.Name For i = 0 To lstct - 1 If nm = Me.WindowsMediaPlayer1.currentPlaylist.Item(i).Name Then lstnum = i End If Next MsgBox lstnum + 1 & "番目" End Sub
散漫に不正確なこと書いちゃったせいで、余計に煩わせてしまい すみません。 修正ありがとうございました。 　　ｃｊ　拝
こんにちは。 > セルに色がついています 条件付き書式での、背景色の塗りつぶし、のことですね。 Excelのバージョンが2010以降であれば、 かなり簡単に出来ます。 Sub Re8753545() Dim c As Range 　　For Each c In Range("A2:G6") 　　　　If c.DisplayFormat.Interior.ColorIndex <> xlColorIndexNone Then 　　　　　　c.Value = Empty 　　　　End If 　　Next End Sub 但し、見た目に色が付いていないようでも、実は白く塗り潰している、 なんて場合も、"色のついたセル"と看做すよりありませんから、注意が必要です。 もし、Excelのバージョンが上記に該当しない場合は、 各バージョンごとにそれぞれ対応が異なりますし、非常に複雑になります。 なので、少し考え方を変えた方が汎用的にうまくいくと思います。 例示が具体的・現実的なものであれば、 １列め（A1:G1）をループして、セルの値が"土"または"日"ならば、 そのセルのひとつ下から、５行分の範囲の値をクリアする、 という方法でも、同じ結果が得られます。 Sub Re8753545c() Dim c As Range 　　For Each c In Range("A1:G1") 　　　　If c.Value Like "*[土日]*" Then 　　　　　　c.Offset(1).Resize(5).ClearContents 　　　　End If 　　Next End Sub 他にも方法はありますが、 このように、直接的に条件判別する方がＶＢＡとしては正当なアプローチですし、 上に書いたような但し書きも無用になります。
＃２-３、ｃｊです。＃２お礼欄拝見しました。 > アドオンで、設定セル（5個ほど）にネット経由でデータの変更が有るたびに送り込まれます。 お返事頂いてありがとうございます。 そういうことなら、理解できます。 ただ、それはそれで、"普通"ではない"特殊"な条件な訳ですから、 "セル式の計算"という簡単な説明で済まされるものではないですし、 当初の質問文から、明示しておいた方が、より有用な回答が得られ易かったのだと思います。 まぁ、なんとなくDDE絡みの話かも？とか想像できなくもなかったのですが。 とりあえず、 Worksheet_Calculate と Application_AfterCalculate との違いは ヘルプで確認してみてください。 これが役に立つかどうか、こちらでは未確認ですが、 ＃２-３で、役に立つことがもしあるとすれば、_AfterCalculate とリンクを張ったページぐらい だと思います。 テスト環境を整えて、きちんとレスしようと思ったのですが、 株価RSSは私の環境（Excel2010x64）で使えるものがない（あるにはあるけど他の理由でNG） ので、断念しました。 １、２年前にRSSに同期をとるVBAサンプルコードが紹介された書籍が出ていたように思いますが、書名が思い出せません。 たぶん、情報をお持ちの方は多数いらっしゃる筈ですから、 要件を整理して、質問建て直した方が、解決が近づくかも知れませんね。 RSSの具体名をタイトルにも掲げるとかして、重要度の高い情報（条件）が 目立つように質問すれば、いいことあるかも、です。 OnTime メソッドについての現状説明については、正直、よく解りませんでした。 あらためて考えてみましたが、 OnTime メソッドって、 １．予定した時刻に指定のプロシージャを実行する。 ２．待機中のキューを先に実行させる。（＃２での説明主旨） ３．非同期処理との連携で時刻が過ぎたら処理をキャンセルする という使い方がメインなんだと思います。 この内、関連ありそうなのは２.３．ですが、 非同期・同期を問わず、外部オブジェクトを扱う際には、決定的な解決策になる場合も多いので、 この際、色々試してみるのも、無駄になることはないと思います。 ただ、RSSの処理の完了のタイミングをとったり、ワークシートの再計算終了のタイミングをとったり、 ということには、やはり役には立たないかな、とは思います。 あらためて、返信ありがとうございました。 解決に届くことを、そして、ご健闘をお祈りいたします。
これに思い当たりますか？ 「ブックの共有を設定した時点でシートの保護と解除は出来なくなり」 そのメッセージが表示されるようです。 直接的な修正方法はないらしく、 「ブックの共有の設定前に　数式のセルのみ保護をかけるしかないと思います。」 だそうです。 http://oshiete.goo.ne.jp/qa/4171186.html
こんな事を書くと答えにならないかもしれませんが。 うまくいった時の結果は、シート数が３０００枚ですよね。 エクセルのシート最大数はヴァージョンにもよりますが 多くはメモリーで決まるようです。 メモリーなので、貼り付けているシートの内容も影響します。 つまり、やろうとしていることに無理があると思います。 試しに、シートを追加して、内容をコピーするVBAを実行してみましたが 途中途中で挙動不審になり、終了したシートを確認していったら １０２枚目に、編集できないシートがありました。 考え方ですが、他のブックの内容を、データとして 一枚のシートへひたすら縦方向へ追加していく方法を検討してみてください。 エクセルでシートを増やしていくデータの管理はパソコンに負担ですし その手のデータでは集計もグラフも作れないでしょう。
＃１です > While(Not rs.EOF) > 　　rsTo.AddNew > 　　rsTo!SBN = rs!SBN > 　　・・・ > 　　rsTo.Update > 　　rs.MoveNext > Wend ここのところの rsTo は、AddNew / Update しかしていないので DAO / ADO 区別ありません。 Dim rsTo As DAO.Recordset と記述して、メニューの「デバッグ」→「コンパイル」してみて エラーにならなければ、DAO が使えます。（以下雰囲気） Set rs = adoCON.Execute(sqlstr) CurrentDb.Execute "DELETE FROM SAMPLE_T;" Set rsTo = CurrentDb.OpenRecordset("SAMPLE_T") While (Not rs.EOF) 　　rsTo.AddNew 　　rsTo!SBN = rs!SBN 　　・・・ 　　rsTo.Update 　　rs.MoveNext Wend rs.Close rsTo.Close また、 Dim rsTo As New ADODB.Recordset でコンパイルエラーでなければ ADO が使えます（以下雰囲気） Set rs = adoCON.Execute(sqlstr) CurrentProject.Connection.Execute "DELETE FROM SAMPLE_T;" rsTo.Open "SAMPLE_T", CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic While (Not rs.EOF) 　　rsTo.AddNew 　　rsTo!SBN = rs!SBN 　　・・・ 　　rsTo.Update 　　rs.MoveNext Wend rs.Close rsTo.Close ※ コンパイルエラーでも、使いたいのであれば、参照設定で追加すれば良いと思います ※ 参照設定しなくても、質問者さんの様に（チョッと修正） Dim cn As Object Dim rsTO As Object Set cn = CurrentProject.Connection Set rsTO = CreateObject("ADODB.Recordset") rsTO.Open "SAMPLE_T", cn, adOpenForwardOnly, adLockOptimistic　' ★ Object 宣言しておいて、CreateObject("ADODB.Recordset") することでも同じなのですが adOpenForwardOnly　とか　adLockOptimistic　の様な定数部分の記述で苦労すると思います。 Dim rsTO As ADODB.Recordset としておけば、 Set rsTO = CreateObject("ADODB.Recordset") ↓部分は、 Set rsTO = New ADODB.Recordset で良いですし、 Dim rsTO As New ADODB.Recordset としておけば、Set rsTO =　・・・　自体不要です
社内で出来る人が居ないなら、この機会に勉強してはどうですか？私もプログラマではなく、仕事上の必要から勉強した片手間VBAです。1年位ですよ。 ただし、手広くやり過ぎるとマクロ係みたいになって本業から外されるリスクがあるのでご注意を。
まず，MySqlConnectionStringBuilderはMySqlConnectionで利用するためのConnectionStringを， 各種プロパティを設定することで作っていくためのクラスです。 そして，PropertyGridは，対話的にインスタンスのプロパティを設定していくことができるコントロールです。 今回のものは，これらを組み合わせて，ConnectionStringを対話的に作成するためのものになります。 Server, User Id, Passwordなどを入力して，対象サーバーに接続できる文字列を作って， 間違いの無いConnectionStringを作れるかどうか確認してみるのが目的です。 ただ，何度も書いていますが，CLI，つまりはmysqlコマンドから接続できていますか。 先にも書きましたが，エラーメッセージが出る状況は， サーバーが存在しなかったり，ファイアウォールで接続を拒否された時のものです。 MySqlConnectionで接続する前に，mysqlコマンドで接続できることを確認した方がよいですよ。
多分以下の質問での回答をもとにエラーの出る Print を削った結果なのでしょうが、削った Print が文字を書く命令なのに削ったらただ「書く文字列を作っただけ」になってしまいます。 http://oshiete.goo.ne.jp/qa/8744888.html やるべきは削除ではなく以下の質問の回答で示された Print から DrawString への変更です。 http://oshiete.goo.ne.jp/qa/8744147.html ……でも、こうやってグラフを軸込みで自力で書くことに労力を割くよりも、グラフを描くことがお仕事の Chart コンポーネントを使った方が後々楽だと思います。 （グラフの値域を変えてくれ、グラフサイズって変えられませんかあっちのソフトでは変えられるでしょ、etc....） 上記 1 番目の質問のタイトル「vb6で覚えたことがｖｂ2010で活かせれない。。」ですが、残念なことにこれは活かせなくて当たり前なんです。 VB は .NET が導入されたことによってクラスライブラリが大きく変わりました。それは上記 2 番目の質問での修正前と修正後を比較すればよくわかると思います。 だから、今の VB はコードの見た目がよく似た昔とは別の言語と考えた方がいいですよ。
こんにちは。 ご提示のサンプルですが、当方のVBA7x64環境でも （実行の度に無条件で必ず）Excelの異常終了を再現できました。 この問題の解決については、私の力量を越えていますので、 情報提供、という形でお応えします。 『APPS PRO > VBA Tips > How Can I Locate a Specific Child Window Handle?』 http://www.appspro.com/Tips/VBA%20Tips.htm こちらのページの一番下の[EnumChildWindows]をクリックすると x32|x64両方対応のサンプルコードが入手できます。 そのままこちらで試してみた処、 （このサンプルは、ThisWorkbook.Windows(1)のハンドル'だけ'を取得するものなので） エラーにはなりませんでした。 コールバック関数側で、条件分岐を書き換えてみたり、 無条件でWindowClassやWindowTitleを取得するよう試みたりして、 約30（重複を含む）の子ウィンドウのウィンドウハンドルが取得出来る所までは確認しましたが、 すべてを取得出来ていないか、うまく終了させることが出来ていないか、どちらかで、 完全な動作を確認するには至りませんでした。 デバッグのヒントにはなりそうな気はしますので、サンプル試してみては如何でしょう。 もしうまく行く方法があるとすれば、 WindowClassとWindowTitleでの条件分岐を整理して、 適切に列挙を終了させることになるような気がしています。 例えばThisWorkbook.Windows(1)のWindowClassとWindowTitleが確認できたら、 （そこから数えてx番目の子ウィンドウで、、、x = 0 かも？） コールバック関数の戻りを0にして列挙を終了する、、、、みたいな？ 或いは、特定の子ウィンドウに限定できるなら、同様にうまく扱えるようにも思えます。 実践的には、同じハンドルが重複して戻る場合があることを考慮して、 ハンドル列挙の受け皿としてCollectionオブジェクト等を用いることになるかと思いますが、 もしかしたら、この戻り値の重複についてもチェックしてみた方がいいのかも？？知れません。 参考になるか解りませんが、以上です。
> エラーの内容： 公開メンバー 'btn' は型 'HTMLFormElementClass' に見つかりませんでした btnというClassは標準では持っていないと思いますが、ご自分で作られたのでしょうか。 そうだとしますと、目的のサイトの方でbtnというIDが変更されたのではないでしょうか。
Printってのが何をしたいのかわからないので放置しておきます。 最近のVisualBasicでは変数の宣言をしないと行けないので文頭に Dim j As Integer, CurrentY As Integer, CurrentX As Integer Dim strB As String と入れておけばPrint以外のエラーはなくなります。
＃１、ｃｊです。お礼欄拝見しました。 > まだ開いて無いファイルだからコレクションには入ってないという事ですね。 はい、その認識で合っています。 一般的なコレクション（コレクションオブジェクト）の扱いとしては、 一段階めで、新しいオブジェクトのインスタンス（実体）を生成してから 次の段階で collection.Add Key:="name", Item:=newobject のような書式でコレクションに追加します。 Workbooks.Open Filename:="filename.xls" の場合は、オブジェクトの実体を生成すると同時に、 コレクションへの追加をしています。 > だからこそworksheetにはないopenやcloseメソッドがあると。 誤解のないように補足しておきますが、 Workbooks.Open Filename:="filename.xls" これは、Workbooks コレクションのOpen メソッドです。 Workbooks("filename.xls").Close これは、Workbook オブジェクトのClose メソッドです。 （Workbooks コレクションには、すべてのブックを閉じるClose メソッドがありますが、 　これは、現在ではほぼ使われることのないもの、いわばレガシーです。） Workbooks("filename.xls") は、 Workbooks.Item("filename.xls") の省略形ですが、 例外なくWorkbook オブジェクトを参照します。 「Workbooks」だけならWorkbooks コレクション、 「Workbooks()」と括弧が付いた部分を含めて、それは （Workbooks コレクションのItemとしての）Workbook オブジェクトであって、 必然的に、Workbooks コレクションのメソッドは使用できません。 Open メソッド、と、Close メソッドとでは、処理対象（Parent）が別物なのです。 以上、補足として追記しておきます。
CurrentX/Yは VB6.0頃の命令です .NETの場合 DrawStringを使います Dim g as Graphics = Graphics.FromHwnd(me.Handle) g.DrawString( "おはよう",me.Font, Brushes.Black, 110, 70) g.Dispose() といった具合です
こんにちは！ ＞if(A1=A2,"一致","一致しない")という関数をしてみると、なんと「一致しない」でした 見た目は同じに見えても、やはり何かが違うのだと思います。 一番怪しいのは半角・全角の違いのような気がします。 別列に　ASC関数で半角で表示させ、それを比較してみてはどうでしょうか？ （余分はスペースなどがある場合はTRIM関数などを使ってみる） 他の原因ならごめんなさいね。m(_ _)m
リンク更新をしないなら 変更前 Workbooks.open filename:=Flnmfp(i) 変更後 Workbooks.open filename:=Flnmfp(i), UpdateLinks:=0 メッセージが出る理由は、開こうとするファイルが他のどこかのファイルにリンクを張っていて、開く時にリンク先ファイルを参照しようとするからです。更新をせずに前回保存時の状態で開くなら、0です。 参考URL：http://www.moug.net/tech/exvba/0060049.html
>>コマンドについて、参考となる本やサイトがあれば、お教えください。 初心者のばあい、大きな書店で、いろいろ立ち読みして、自分に合ったものを選ぶのが一番ですよ。
はじめまして、通るすがるともうします。グラフを描くに簡単な方法として、zgraphというものがありますが このコントロールを使ってはいかがでしょうか？ http://blog.livedoor.jp/akf0/archives/51309517.h …
たぶん勘違いがあるようなので エクセルがインストールされているパソコンであれば エクセルＶＢＡが使えます。 但し、インストールされた初期状態であれば 開発のリボンが非表示になっているので リボンのオプションに　チェックをいれて表示させれば ＶＢエディターなど簡単に使えます。 ワードでも同じです。 購入すべきは　ＶＢＡの本だったと思います。 http://excelvba.pc-users.net/ 等を参考にしていただければ、本を購入しなくても 大丈夫かと思います。
IVSに限りませんが，.NET上で「一文字」単位で処理する場合には，StringInfoクラスが使えます。 http://msdn.microsoft.com/ja-jp/library/System.G … で，C#のコードになりますが，IVSまわりで正しく動作することを確認した報告があります。 http://social.msdn.microsoft.com/Forums/ja-JP/68 …
こんにちは。 ご提示のExcel数式は、そちらの望み通りに書けているものとして、 =IF(DATEDIF(E3,TODAY(),"Y")>80,"大型中止","OK") この数式を行のみ相対参照で列は絶対参照でしていしたい、ということだとすると、 VBAでは、 NewDataRow = Cells(Rows.Count, "J").End(xlUp).Row + 1 Range("J" & NewDataRow).FormulaR1C1Local = "=IF(DATEDIF(RC5,TODAY(),""Y"")>80,""大型中止"",""OK"")" のように設定します。
こんばんは！ すでに的確な回答が出ていますので、余計なお世話かもしれませんが・・・ お示しの数式の場合途中に空白セルがなければ問題ないのですが、 万一空白セルがあっても対応できる方法の一例です。 表示したいセルに =INDIRECT("データ2!A"&MAX(IF(データ2!A1:A3000<>"",ROW(A1:A3000)))) これは配列数式になってしまいますので、Ctrl+Shift+Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　表示したいセルを選択　→　数式バー内に貼り付け　→　そのまま（編集かのうなまま） Ctrl+Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 ※　とりあえず「データ2」Sheetの3000行まで対応できる数式です。 配列数式はPCにかなりの負担を掛けますので、もう少し行数を増やしても大丈夫ですが、 極端にデータ量が多い場合はおススメしません。m(_ _)m
Option Explicit On Option Strict On Option Infer Off Option Compare Binary Imports System Imports System.Drawing Imports System.Collections.Generic Public Class Q8738210 Inherits System.Windows.Forms.Form Private textbox1 As System.Windows.Forms.TextBox Sub New () textbox1 = New System.Windows.Forms.TextBox () textbox1.Font = new Font ("IPAmj明朝", 48) ' 配列初期化子、拡張メソッド・ラムダ式といろんな文法が登場している。 ' VBにはエスケープシーケンスがダブルクオートくらいしかないから。 ' 注目はChar.ConvertFromUtf32だ。リファレンスを見て、このメソッドが例外を投げるケースはどんな場合か確認しておこうね。 ' http://msdn.microsoft.com/en-us/library/system.c … ' その他、こちらも例外の範囲を確認しておこう。 ' http://msdn.microsoft.com/en-us/library/microsof … ' http://www.atmarkit.co.jp/fdotnet/dotnettips/107 … ' ついでにこいつも読んでおく ' http://codezine.jp/article/detail/1592 ' http://ja.wikipedia.org/wiki/UTF-8#.E3.82.B5.E3. … textbox1.Text = (New List(Of Integer) From {&H82B1I, &HE0103I}).Aggregate("", Function(ByVal str As String, ByVal ch As Integer) (str & Char.ConvertFromUtf32(ch).ToString())) Me.Controls.Add (textbox1) ' 後で読む(回答に反映する気はない) ' http://msdn.microsoft.com/en-us/library/1k20k614 … ' http://msdn.microsoft.com/en-us/library/system.g … End Sub Public Shared Sub Main() Dim f As Q8738210 = New Q8738210 () f.ShowDialog () End Sub End Class
シートを非表示のままではそのシートに関するマクロはエラーになります。 そこで、普段非表示にしているシートでマクロを実行するには マクロの中でシート操作を実行するときだけシートを表示させて、 シート操作が終わったらまたシートを非表示にするという方法を使います。 実行したい動作の前後にSheets("Sheet2").Visibleで表示・非表示を挿入します。 Sheets("Sheet2").Visible = True（シートを表示する） さらに画面がちらちらするを止めるには Application.ScreenUpdating = False　とします。（画面の更新をしない） 貴殿のマクロに付け加えると以下のようになります。 Sub b1ab1() ' b1ab1 Macro Application.ScreenUpdating = False　'画面の更新をしない Sheets("Sheet2").Visible = True　　'シート２を表示 Sheets("Sheet2").Select Range("AK48:AP56").Select Selection.Copy Sheets("ダクト制作単品図").Select ActiveSheet.Paste Sheets("Sheet2").Visible = False　　'シート２を非表示 Application.ScreenUpdating = True　'画面の更新する End Sub 貴殿の実用上問題ないのかもしれませんが、 上のマクロは「ダクト制作単品図」シート上のアクティブなセル（選択してあるセル）なら どこにでもペーストされてしまうので ペーストするセル（またはレンジ）も指定する方がいいように思われます。
直接ファイルのURLからダウンロード処理をすれば、わざわざダイアログを開かなくても簡単な気がしますが。 ファイルのダウンロードの方法について詳しく解説してあるサイトがありましたのでこちらを参考にされてはいかがですか。 参考URL：http://www.vba-ie.net/element/subroutine-filedow …
ソリューションのディレクトリ名は手作業で変更する必要があります。 というか， ・ソリューション名とソリューションのディレクトリ名 ・プロジェクト名とプロジェクトのディレクトリ名 には全く関連がありません。 ただし，プロジェクトのディレクトリ名を変更したい場合は， 一度プロジェクトをソリューションから外した上でディレクトリ名を変更し， 再度ソリューションに追加する必要があります。
・VS2012_WDX_JPN.iso 　一旦これをダウンロードすれば、あとはインターネットにつながっていない状態でもインストールできる。 　ただし、ダウンロードしたファイルを使ってインストールDVDを焼くか仮想ドライブにマウントしないといけない。 　また、インストールに必要になる可能性のあるデータがすべて含まれているためデータ量が多く、ダウンロードに時間がかかる。 ・wdexpress_full.exe 　インストールの設定とその実行だけをするプログラムで、インストールに必要なファイルはその都度ダウンロードしてくる。 　本当にインストールに必要なファイルだけをダウンロードするので上記よりデータ量が少なくなり、インストール時のダウンロード時間も短くなる。 　ただし、当然インストール時とコンポーネント修正時にインターネットにつながっている必要がある。 というわけで、ダウンロードに膨大な時間をかける無駄をとるか、インストール時やコンポーネント修正時にインターネットにつながなくてはならない制約をとるか、どちらかを選んでください。
変数をパブリック宣言しておいて 名前ではなく変数そのものを渡してあげれば。 Public AryVal() GET_FILE = wscript.scriptfullname '"sample.txt" SET objFs = CreateObject("Scripting.FileSystemObject") ' 動的配列セット Call Array_Set(AryVal,GET_FILE) ・・・以下は冒頭の質問と同じなので省略しました。
No.1です。 前回のコードでは5行目（最初の行）がヒットした場合、ちゃんと動きませんので ↓のコードに変更してください。 Private Sub CommandButton1_Click() Dim c As Range Set c = Range("B:B").Find(what:=TextBox1, LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then If c.Row > 5 Then '★　この行追加 Rows(5 & ":" & c.Row - 1).Hidden = True End If Else MsgBox "該当データなし" End If End Sub どうも失礼しました。m(_ _)m
何となくZipファイルの更新日付を見ると直されてるのではと思います。 http://detail.chiebukuro.yahoo.co.jp/qa/question … http://www.impressjapan.jp/books/3384_4
締め切ったのに追いかけるようですみません。 今日会社で他の調べごとをしていた時にPhoneticプロパティというのがあるのをみつけました。ワークシート関数のPhoneticを呼び出すコードよりPhoneticプロパティを利用した方がベストかもしれません。ただし、現状で問題があるというわけではありませんので、次回同じような処理をするときはプロパティを採用してみてください。 Worksheets("リスト").Cells(r + 1, "c") = WorksheetFunction.Phonetic(h) ↓ Worksheets("リスト").Cells(r + 1, "c") = h.Phonetic.Text
以下のようにIFで商品Cの場合とそれ以外を分岐してやればいけると思います。 If ActiveCell.Value=商品名Ｃ Then With Worksheets("sheet3") 各セルへデータのコピーのコード .Printout End With else With Worksheets("sheet2") .Range("A6").value=ActiveCell.Offset(0,0).Value .Range("D6").value=ActiveCell.Offset(0,1).Value .Range("G9").value=ActiveCell.Offset(0,2).Value .Range("J9").value=ActiveCell.Offset(0,3).Value .Printout End With End If
お困りの様子なので、誰かに助けてもらいたい気持ちは分かりますが、 やはり質問する場所なので、不明点を解決するような内容を投稿された方が良いと思います。 別の回答者からもExcelマクロのサイトが紹介されているようなので、 頑張ってください。 ただ、一つ助言として、面白いサービスがありますのでリンクを貼っておきます。 <http://coconala.com/services/3811> 500円で色々な依頼を受けてくれるようです。 参考URL：http://coconala.com/services/3811
Visualbasicはないようですが、まずはドットインストールで いいのではないでしょうか？ BASIC入門 (全11回) Excel VBA入門 (全19回) Java入門 (全23回) JavaScript入門 (全24回) などが無料動画配信されています。 参考URL：http://dotinstall.com/
こんな感じでしょうかね。 秒の四捨五入は意図をくみ取れなかったので考えていません。 そちらで何とかしてください。 他の部分（日付をまたがる場合、再生時間を取得できないファイルの場合）は 多分、大丈夫かな？と。Windows7で簡単なテストは行いました。 Dim objParam Set objParam = WScript.Arguments 'D&Dでの読み込みを可能にする Dim objFS Set objFS = WScript.CreateObject("Scripting.FileSystemObject") ' 引数の全ファイルについてファイル名を変更する Dim objFile Dim dtRecordStart Dim i Dim newName For i = 0 To objParam.Count - 1 If objFs.FileExists(objParam(i)) Then Set objFile = objFS.getFile(objParam(i)) dtRecordStart = GetDuration(objParam(i)) 'ExtendedProperty用 'dtRecordStart = GetDuration2(objParam(i)) 'GetDetailsOf用 If dtRecordStart <> 0 Then dtRecordStart = objFile.DateLastModified - (dtRecordStart / 3600 / 24) newName = Right("0" & CStr(Hour(dtRecordStart)), 2) & Right("0" & CStr(Minute(dtRecordStart)), 2) objFile.Name = objFS.getBaseName(objFile) & "-" & newName & "." & objFS.getExtensionName(objFile) End If Set objFile = Nothing End If Next Set objFS = Nothing Set objParam = Nothing Function GetDuration(filePath) '再生時間の秒数を求めます Const FMTID_AudioSummaryInformation = "{64440490-4C8B-11D1-8B70-080036B11A03}" Dim objShell, objFolder, objItem Dim tmpStr tmpStr = Left(filePath, InStrRev(filePath, "\", -1, vbTextCompare)) '親フォルダを求めて Set objShell = CreateObject("Shell.Application") Set objFolder = objShell.Namespace(tmpStr) tmpStr = Mid(filePath, InStrRev(filePath, "\", -1, vbTextCompare) + 1) '拡張子を含めたファイル名のみを求めて For Each objItem In objFolder.Items If StrComp(objItem.Name, tmpStr, vbTextCompare) = 0 Then 'アイテムの名前とファイル名が同じなら GetDuration = CDbl(objItem.ExtendedProperty("Duration")) GetDuration = Int(GetDuration / 1000 / 1000 / 10) Exit For End If Next 'オブジェクトの解放未処理 End Function Function GetDuration2(filePath) Dim objShell Dim objFS, objFolder, objFile Dim tmpStr Set objShell = CreateObject("Shell.Application") Set objFS = CreateObject("Scripting.FileSystemObject") Set objFile = objFS.getFile(filePath) Set objFolder = objShell.Namespace(objFile.ParentFolder.Path) tmpStr = objFolder.GetDetailsOf(objFolder.ParseName(objFile.Name), 27) 'WindowsXPなら、27 → 21 If tmpStr = "" Then GetDuration2 = 0 Else GetDuration2 = CDbl(CDate(tmpStr) * 3600 * 24) '文字列型の時間を日付時刻型にしてから秒数を求めています End If 'オブジェクトの解放未処理 End Function
マップするセルの対応、ファイル名の変換ルールを具体的に述べよ、う、、、
多分 コンボボックスのClickイベントで選択が正しいのかを判定しているのでしょう 対処療法ですが タイマーオブジェクトをフォームに貼り付けて タイマーの EnabledをFalseに設定しておきます Intervalは 100程度にします Clickイベントの中の判定部分に if hanntei = ダメ then timer1.Enabled = true end if Timer1のTimerイベントで combo1.text = "test" Timer1.Enabled = false といった具合にしてみましょう
こんばんは！ ＞VLOOKUP的な機能 とありますので、一例です。 画面左下のG6セルがChangeするSheet見出し上で右クリック　→　コードの表示　→　VBE画面に ↓のコードをコピー＆ペースト　→　Excel画面に戻り、G6セルのデータを色々変更してみてください。 尚、結果を表示させるセルは同じSheetのA2セルとした場合です。 Private Sub Worksheet_Change(ByVal Target As Range) 'この行から Dim c As Range If Target.Address = "$G$6" Then Set c = Worksheets("マスタ2").Range("A:A").Find(what:=Target, LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then Range("A2") = c.Offset(, 1) '←A2セルに表示 Else MsgBox "該当データなし" End If End If End Sub 'この行まで ※　コード内の「A2]部分は実際に表示させたいセル番地にしてください。m(_ _)m
数千件のデータならOracleのリンクテーブルを作成して Select文をサブクエリとしたInsert文1回で挿入してしまう のが一般的かと思います。 Recordsetに入れてあるデータでは、接続情報もテーブルの 情報も違いますので、1行1行ループで回してデータを取り出し、 処理していく事になるかと思います。 Accessをよく使う方はDoCmd.TransferDatabaseを使うのでは ないかと思いますが、慣れていない人はInsert文を1行1行編集 すればいいと思います。
>後からもっと別のいい方法があったりで、遠回りしている気がします。 勉強とか成長とは、そういったものです。 失敗の繰り返しだから身に付きます。 あとは、エクセルとか詳しい人との交流は如何でしょうか。 こちらのサイト等も利用できると思います。 ほかの職場の方などおられましたら、一緒に悩んでみてはいかがでしょう。 思わぬヒントを得ることができます。 ＶＢＡの勉強も必要ですが、目的を達成するためのアルゴリズムを知ることが重要です。 10人にプログラムを作らせると10種類のプラグラムが出来るという人もいます。 とりあえず、目的が達成できれば、どれでも合格なのですが 少しでもシンプルにパソコンに負担をかけずに動かしたいという所に個人差が生まれます。
>If Target = Range("C6") Then このコードですと、Target（変更されたセルの値）がセルC6の値と同じであれば処理をするという事になります。 >C6の内容に応じて、セルに式を設定する 以下のようにTarget.Address（変更されたセルのアドレス）が「C6」であるかを判定する必要があります。 　　If Target.Address = "$C$6" Then 　　　　　　　　　　又は 　　If Target.Address(False, False) = "C6" Then >Range("I11").Formula～Range("J14").Formula = "=C8" 「=C7」や「=C8」を絶対参照とし、セル範囲「Range("I11:I14")」を挿入先として指定することで以下のように出来ます。 　　Range("I11:I14").Formula = "=$C$7" 　　Range("J11:J14").Formula = "=$C$8" >Range("I11").Formula = ""～Range("J14").Formula = "" 数式を消すのであれば""を代入するのではなく、ClearContents（値の削除）で良いかと。 >Worksheet_Chang >セルに式を設定する Worksheet_Changイベントはユーザーが変更（入力やコピー）した場合に発生しますが、 VBAコード内で値を変更した場合にも発生します。 ですので、セルの値をVBAコードで変更する前にイベントを一時的に停止する処理 と、最後にイベントを再開する処理を追加してください。 　　Application.EnableEvents = False　'イベント停止 　　　　　　　～　セル変更処理　～ 　　Application.EnableEvents = True　'イベント再開 >If 条件式 Then 真の場合の処理 Else 偽の場合の処理 End If 上記If文において、偽の場合の処理が無い場合は「Else 偽の場合の処理」を省略できます 以上をふまえると以下のようになります。 ■VBAコード Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address(False, False) = "C6" Then 　　Application.EnableEvents = False 　　If Range("C6").Value = "する" Then 　　　　Range("I11:I14").Formula = "=$C$7" 　　　　Range("J11:J14").Formula = "=$C$8" 　　Else 　　　　Range("I11:J14").ClearContents 　　End If 　　Application.EnableEvents = True End If End Sub
シート名はそれぞれ「Sheet1」「Sheet2」とします。 以下の式は両シートともA1から提示の様式でデータが入っているとして、 Sheet1の「D1」から下へSheet2のC列のデータを持ってきます。 Sheet1のD1セルに以下の数式を入力して下へオートフィルしてください。 =OFFSET(Sheet2!$A$1,MATCH(TIME(TEXT(B1,"HH"),0,0),Sheet2!B:B,0)-1,2)
VBAは「URLDownloadToFile」のことを知らないから定義する必要があります。 以下のコードを先頭に付け加えてください。 Private Declare Function URLDownloadToFile Lib "urlmon" Alias _ "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, ByVal _ szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long あとURLの指定方法、間違えていますよ GetImageFile "http://toyota.jp/sp/image/e_bn/FCV_20140625.jpg", "FCV_20140625.jpg" としてください。 おそらくマイドキュメントに保存されるかと。
こんばんは！ 色々書き方はあると思いますが、 ワークシート関数を使用せずにユーザー定義関数を！というコトですので、 一例です。 Function heikin(myRng As Range) Dim c As Range Dim cnt As Long Dim myVal As Variant For Each c In myRng If c <> "" And IsNumeric(c) Then cnt = cnt + 1 myVal = myVal + c End If Next c heikin = myVal / cnt End Function こんな感じではどうでしょうか？m(_ _)m
「Dim HelpFile As File」 が FileSystemObject の File であるなら Microsoft Scripting Runtime への参照設定がされていると思うので Dim FNmDic As Variant Set FNmDic = CreateObject("Scripting.Dictionary") を Dim FNmDic As Scripting.Dictionary Set FNmDic = New Scripting.Dictionary とすることができる。 ここからが本題。 FNmDic.Add Left(HelpFile.Name, 3), HelpFile.Path この 1行に時間が掛かっているとして、それが Scripting.Dictionary のせい (FNmDic.Add) なのか、Scripting.File のせい (HelpFile.Name や HelpFile.Path) のせいなのか、それとも両者をこの書き方にすると遅くなるのか、切り分けてみたらよいともいます。 Dim fso As Scripting.FileSystemObject Set fso = New Scripting.FileSystemObject Dim HelpFile As Scripting.File Set HelpFile = fso.GetFile("ファイル パスの文字列") Dim hKey As String Dim hValue As String hKey = Left(HelpFile.Name, 3) hValue = HelpFile.Path Dim FNmDic As Scripting.Dictionary Set FNmDic = New Scripting.Dictionary FNmDic.Add hKey, hValue Add への引数に File オブジェクトを使わないようにしてみた。 hKey や hValue に値を入れる箇所が遅くなるのか、相変わらず Add が遅いのかが分かると思う。
ShowDialog メソッドの使い方が違ってない？ バージョン情報ToolStripMenuItem というコントロールが配置されているフォーム (仮に MainForm) があって、そこから AboutBox1 フォームを呼び出すんだよね。 [対象のフォーム インスタンス].ShowDialog([オーナー]) という書き方になります。 つまり Dim aboutForm As New AboutBox1 aboutForm.ShowDialog(Me) と書きます。 ただし VB の場合はインスタンス作成を暗黙的に行う人もいるので AboutBox1.ShowDialog(Me) とだけ書く人もいます。
Excel VBA ですよね。。。 System.Data.SqlClient.SqlConnection System.Data.SqlClient.SqlCommand これ、VBA で利用できないでしょ？ これは .NET Framework 用でしょ
続けてお邪魔します。 （1）について・・・ 前回のコードは7行目の項目が最終列まで空白セルなしに入っているという前提のコードでしたので 途中に空白セルがあると連続しているセルまでしか表示されないと思います。 （2）の ＞Ａ、Ｂ、Ｅ以外に職種が増えてしまった場合は ＞どうしたらいいでしょうか・・・ 「一覧」Sheetにデータ追加があり、「職種名」のSheetがない場合は新たにSheetを追加して 同じ操作をするようにしてみました。 前回のコードは削除して↓のコードを標準モジュールにコピー＆ペーストしてマクロを実行してみてください。 尚、「一覧」Sheetはシート見出しの一番左側に配置してあるとします。 Sub Sample2() Dim i As Long, k As Long Dim lastRow As Long, lastCol As Long, endRow As Long, endCol As Long Dim str As String, wS As Worksheet, myFlg As Boolean Application.ScreenUpdating = False With Worksheets("一覧") .Activate lastRow = .Cells(Rows.Count, "B").End(xlUp).Row lastCol = .UsedRange.Columns.Count endCol = lastCol + 1 Range(.Cells(7, "B"), .Cells(lastRow, "B")).AdvancedFilter Action:=xlFilterCopy, _ copytorange:=.Cells(1, endCol), unique:=True For i = 2 To Cells(Rows.Count, endCol).End(xlUp).Row str = .Cells(i, endCol) For k = 2 To Worksheets.Count If Worksheets(k).Name = str Then myFlg = True Exit For End If Next k If myFlg = False Then Worksheets.Add after:=Worksheets(Worksheets.Count) Worksheets(Worksheets.Count).Name = str End If Set wS = Worksheets(str) wS.Cells.Clear .Rows(7).AutoFilter field:=2, Criteria1:=str If .Cells(Rows.Count, "B").End(xlUp).Row > 7 Then Range(.Cells(7, "A"), .Cells(lastRow, lastCol)).SpecialCells(xlCellTypeVisible).Copy wS.Range("A1") endRow = wS.Cells(Rows.Count, "B").End(xlUp).Row Range(wS.Cells(1, "A"), wS.Cells(endRow, lastCol)).Sort key1:=wS.Range("D1"), order1:=xlAscending, Header:=xlYes wS.Columns.AutoFit End If myFlg = False Next i .AutoFilterMode = False .Columns(endCol).Delete End With Application.ScreenUpdating = True End Sub こんなんではどうでしょうか？m(_ _)m
エクセル的だなと思いつつ、無理矢理やってみましたが、こんな事で良いのでしょうか？自分ならオートメーションでExcelを操作して入れてやろうといった方向に走ったと思います。 Sub test() Dim mySQL As String mySQL = "SELECT Table1.[フィールド1], Table1.[フィールド2], Table1.[フィールド3], Null AS [作成日 exportDate] FROM Table1;" mySQL = Replace(mySQL, "exportDate", Format(Date, "yyyy/mm/dd")) Application.CurrentDb.CreateQueryDef "Q_test", mySQL DoCmd.TransferSpreadsheet acExport, acSpreadsheetTypeExcel12Xml, "Q_test", GetDesktopPath & "\qtest.xlsx" Application.CurrentDb.QueryDefs.Delete "Q_test" End Sub Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function
> 特定フォルダにある、iniファイルを セクションなんかが指定されている、Windowsやレジストリエディタで扱えるしっかりとしたiniファイルなのか？単に拡張子が.iniのファイルなのか？で話が違います。 前者と仮定して、 > それ以外に何か方法はありますでしょうか？ WindowsAPIのWritePrivateProfileStringを使うとかが真っ当だと思います。 なっちゃんのプログラミングTips: INIファイルの読み書き http://natchan-develop.seesaa.net/article/111204 … WritePrivateProfileStringはWindowsに用意されている、セクション名やキー名を指定してiniファイルへ書き込みを行うためのインターフェースです。 Replaceの処理の中身でForやMidみたいな関数が使われてるなんて事考える必要が無いのと同様に、WritePrivateProfileStringの中で置換がどうとかって事は考える必要が無いです。 -- > と変更するのは > 1行ずつ読み込み、Replaceで出来ると思うのですが > iniファイルとなると特別なのか、調べてみても良く分かりません。 いわゆるWindowsで扱うiniファイルであれば、一応フォーマットが定まっています。 通常、iniファイルにアクセス、値の書き込みを行う場合、セクション名、キー名で対象の値を指定します。 セクション名が違って、同じキー名の複数の値をまとめて変更しちゃうなんて事は望ましくないです。 自分で書き出したデータを.xlsとか.docって拡張子にしたら紛らわしいのと一緒で、独自の処理するのであれば別の拡張子にしとくのが良いです。 INIファイル - Wikipedia http://ja.wikipedia.org/wiki/INI%E3%83%95%E3%82% …
System.Console.Beep http://www.atmarkit.co.jp/fdotnet/dotnettips/440 …
Split関数を使って文字列を分解する。
＃６です ＃７さんの結果を参考に Samp3 を書き換えました Public Sub Samp5() 　　Dim dic As Object 　　Dim iRow As Long, i As Long 　　Dim v As Variant 　　Application.ScreenUpdating = False 　　Set dic = CreateObject("Scripting.Dictionary") 　　With Range("B1", Cells(Rows.Count, "B").End(xlUp)) 　　　　v = .Value 　　　　For iRow = UBound(v) To 1 Step -1 　　　　　　i = dic.Count 　　　　　　dic(v(iRow, 1)) = Null 　　　　　　If (i = dic.Count) Then v(iRow, 1) = Empty 　　　　Next 　　　　.Value = v 　　　　On Error Resume Next 　　　　.SpecialCells(xlCellTypeBlanks).EntireRow.Delete 　　End With 　　Set dic = Nothing 　　Application.ScreenUpdating = True End Sub 同じデータではありませんが、８１２．５秒 → １１３秒まで短縮されました。 ちなみに、私の方のサンプルデータでは、１６秒 → ２．７秒に。
こんにちは。 以下の２つのイベントの内のどちらかひとつ、を使います。 Private Sub TextBox1_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer) 　　If KeyCode = vbKeyF1 Then 　　　　MsgBox "F1キー" 　　End If End Sub ' Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer) 　　If KeyCode = vbKeyF1 Then 　　　　MsgBox "F1キー" 　　End If End Sub 参考に。 ＶＢＥ画面から、F2キー、で、オブジェクトブラウザを開き、 KeyCodeを検索すれば、MSForms.ReturnIntegerの一覧が見られます。 （MSFormsのコントロールを使った後でないと表示されませんが） 以上です。
Private Sub Command1_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single) 　　Command1.Drag End Sub Private Sub Command2_DragDrop(Source As Control, X As Single, Y As Single) 　　Dim strTmp As String 　　strTmp = Command2.Caption 　　Command2.Caption = Source.Caption 　　Source.Caption = strTmp End Sub
基本的なものは以下になると思います Public Sub Samp1() 　　Dim r As Range 　　Dim sS As String, sW As String 　　Dim iPos As Long 　　sS = "ABBA" 　　For Each r In Range("A1:A1000") 　　　　sW = r.Value 　　　　iPos = 1 　　　　Do While (iPos < Len(sW)) 　　　　　　iPos = InStr(iPos, sW, sS) 　　　　　　If (iPos = 0) Then Exit Do 　　　　　　r.Characters(iPos, Len(sS)).Font.ColorIndex = 3 　　　　　　iPos = iPos + Len(sS) 　　　　Loop 　　Next End Sub InStr をヘルプで見てみると、１つ目の引数は何文字目から探すか・・・ なので、１文字目から探して・・・あったらその位置が返ってくるので その位置から、検索文字数分の色を指定・・・ 次を探す時には、その位置に検索文字数を加算した所から・・・ 上記、検索文字 "ABBA" で、見つかった位置が 2 なら、次は 2 + 4 = 6 文字目から > 経緯としては検索した文字がヒットしたらその文字の色を変更したい 事をやってみると、雰囲気以下に Public Sub Samp2() 　　Dim r As Range 　　Dim sAddr As String 　　Dim sS As String, sW As String 　　Dim iPos As Long 　　sS = "ABBA" 　　Set r = Cells.Find(sS, LookAt:=xlPart) 　　If (Not r Is Nothing) Then 　　　　sAddr = r.Address 　　　　Do 　　　　　　sW = r.Value 　　　　　　iPos = 1 　　　　　　Do While (iPos < Len(sW)) 　　　　　　　　iPos = InStr(iPos, sW, sS) 　　　　　　　　If (iPos = 0) Then Exit Do 　　　　　　　　r.Characters(iPos, Len(sS)).Font.ColorIndex = 3 　　　　　　　　iPos = iPos + Len(sS) 　　　　　　Loop 　　　　　　Set r = Cells.FindNext(r) 　　　　Loop While (r.Address <> sAddr) 　　End If End Sub 今見ているシート全体を対象に、部分一致で検索し、なければ終わり・・・ あればセルのアドレスを覚えておいて、色付け処理 次のを求めて、覚えていたアドレスと同じなら処理を抜ける
以下の要件で作ってみました。（当方、Excel2010です） ・入力順の制御をするセルの個数は制限しない。 ・制御するセル番地をプログラム内に入れない。 ・制御するセルを登録しやすくする。 ・結合セルも可とする。 ・基本的な移動順は上から下、左から右とする。（戻るときに必要） ・セルを移動するキー 　　Enterキー、４つの方向キー、Tabキー、Shife+Tabキー 　　セルを移動させたキーよりも移動後のセルで制御する 　　方向キーの右、下はEnterキー、Tabキーと同じ 　　方向キーの左、上はShift+Tabキー ・シートの保護・非保護には依存しないようにする。 ・入力順の制御のオンオフを可能にする。 ●最初に入力順の制御を行うシートで、開発タブ＞挿入＞フォームコントロールでチェックボックスを1つシート上に配置し、右クリック＞コントトールの書式設定＞コントロールタブ＞リンクするセルを「$H$1」にして、チェックボックスはオフにしてください。マクロが「$H$1」になっているからです。後で修正してください。 入力用のマクロが動き出すと修正ができなくなるので、このチェックボックスのオン・オフでマクロを制御します。 ●下記のマクロをシートのコードウィンドウに貼り付け、最初の行の「AdrJump」の右に動かすセルを「,」で区切って順に記入します。結合セルの場合はその左上のセル番地になります。数の制限はありませんがほどほどに。この登録データで環状リストを作ります。 ●最初の時点は、編集した後、チェックボックスをオンにしてマクロを実行するとエラーが起きる可能性があります。VBE画面でマクロを中断し、「setEnableEvents」を実行してください。以降、エラーは起きないはずです。 ●今のマクロは添付図での入力用の設定になっています。 シートのコードウィンドウに貼り付けます。 '□□□　入力セルを順に書く　□□□ Const AdrJump As String = "C2,C4,C5,F5,D7,D8,D10" Dim Jmp1() As String　　'飛び先のセル（今） Dim Jmp2() As String　　'飛び先のセル（前） Dim DownUp As Integer '戻るか進むか（1:戻る、2:進む） Private Sub Worksheet_SelectionChange(ByVal Target As Range) 　　If Range("H1") = False Then Exit Sub 　　Application.EnableEvents = False 　　Jmp1 = Split(getAdr(Target), ",") 　　If Jmp1(0) = "" Then 　　　　'前に進むか戻るかを判定 　　　　DownUp = 1 - (Range(Jmp2(0)).Row < Target.Row Or _ 　　　　　　　　　　 Range(Jmp2(0)).Column < Target.Column) 　　　　 　　　　Jmp1 = Split(getAdr(Range(Jmp2(DownUp))), ",") 　　　　Range(Jmp2(DownUp)).Select: Jmp2 = Jmp1 　　Else 　　　　Jmp1 = Split(getAdr(Range(Jmp1(0))), ","): Jmp2 = Jmp1 　　End If 　　Application.EnableEvents = True End Sub '選択セル(結合セルも可)によってどこに移動するか候補を決める Function getAdr(Tgt As Range) As String 　　Dim wk() As String, i As Integer 　　 　　wk = Split("," & AdrJump & ",", ",") 　　wk(0) = wk(UBound(wk) - 1) '環状リスト（最初） 　　wk(UBound(wk)) = wk(1)　　 '環状リスト（最後） 　　 　　getAdr = ",," 　　For i = 1 To UBound(wk) - 1 　　　　If Tgt.Range("A1").Address(0, 0) = wk(i) Then 　　　　　　getAdr = wk(i) & "," & wk(i - 1) & "," & wk(i + 1) 　　　　　　Exit For 　　　　End If 　　Next End Function '最初、編集時エラーが発生したらこのプロシージャを実行する Sub setEnableEvents() 　　Erase Jmp1 　　Erase Jmp2 　　Application.EnableEvents = True End Sub
一応関数案ですが Ｋ列に =SUM(LEN(A1:J1)-LEN(SUBSTITUTE(A1:J1,"a",""))) と入れて　Ctrl+Shift+Enter　で決定して配列関数にする L列も同様 =SUM(LEN(A1:D1)-LEN(SUBSTITUTE(A1:D1,"b",""))) で 下へコピーではだめですか？
すいません、書き忘れました。 SortedDictionaryはクイックソートになります。 並び替えをオリジナルにする場合はIComparerインターフェイスを利用してください。
出来れば、新規追加の質問は新たに投稿し直してください。 時間経過により回答が締め切られているため、 この文面はサポートにより追加して頂いております。 >更に欲を出したと言うのは、『同じモジュール内に、同じく >「ブックBの"仕入*"の特定セルからの値取得後、 >Sheet1のB1にcnt値を書き出す」というコードについてです。 追加で書出す「値」とは、売上*と同様に特定セル（合計値）を 合計した値という意味と捉えて回答致します。 「売上*」シートのA10セルを集計してcnt(0)へ合計し、 「仕入*」シートのB10セルを集計してcnt(1)へ合計します。 Sheet1のセルA1,B1に合計値「cnt(0)及びcnt(1)」を書き出します。 以下のコードで差替えて、ご利用ください。 ■VBAコード Sub 別ブックの合計() '型宣言 Dim fpath As String Dim tbook As Workbook Dim i As Integer Dim cnt(1) As Double 'ファイルを指定 fpath = Application.GetOpenFilename("全てのファイル(*.*),*.*") '指定したファイルを開く Set tbook = Workbooks.Open(fpath) 'シートの数だけ繰り返し For i = 1 To tbook.Sheets.Count 　　'条件に一致したシート名を対象に処理 　　If tbook.Sheets(i).Name Like "売上*" Then 　　　　'対象のシートのセルA10より値を取得し、変数cnt(0)に加算 　　　　cnt(0) = cnt(0) + tbook.Sheets(i).Range("A10").Value 　　End If 　　If tbook.Sheets(i).Name Like "仕入*" Then 　　　　'対象のシートのセルB10より値を取得し、変数cnt(1)に加算 　　　　cnt(1) = cnt(1) + tbook.Sheets(i).Range("B10").Value 　　End If Next i 'ブックを閉じる tbook.Close 'Sheet1のセルA1,B1に合計値を書き出し ThisWorkbook.Sheets("Sheet1").Range("A1").Value = cnt(0) ThisWorkbook.Sheets("Sheet1").Range("B1").Value = cnt(1) End Sub
その >春分の日の決定や月齢の決定は、面倒な計算が必要で、 >ぶっちゃけ「関数やVBで簡単に出来るような代物ではない」ですよ。 を可能にしてしまったのが、#2 さんが紹介されているリンクです。＼(^o^)／ ダウンロードして解凍すると中に、旧暦.bas がありますので これをExcelのVBE画面にてインポートします。 標準モジュールにインポートされますので あとは六曜をワークシートに表示するために、ユーザー定義関数を作成します。 インポートされたモジュールの後にでも付け加えてください。 Function wsRokuyou(Rg As Range) As String On Error GoTo errH Dim wDate As Date If Not IsDate(Rg.Value) Then wsRokuyou = "" Exit Function End If wDate = Rg.Value If Year(wDate) <= 1950 Or Year(wDate) >= 2050 Then wsRokuyou = "計算範囲外" Exit Function End If Call Calc_Kyureki(Year(wDate), Month(wDate), Day(wDate)) wsRokuyou = Kyureki.QRokuyou Exit Function errH: wsRokuyou = "不明" End Function あとは一般の関数と同様にA列に日付があればB列に、=wsrokuyou(A1) などとするだけです。 確認用サイト http://www.ajnet.ne.jp/dairy/ Private Function JD2YMDT(JD As Double) As String の所が変だったのでここだけ誤魔化しています。（二十四節気でエラーになります） 'JD2YMDT = Trim(Str(GYear)) & "/" & Trim(Str(Gmonth)) & "/" & Trim(Str(Gday)) & " " & _ Trim(Str(Ghour)) & ":" & Trim(Str(Gminute)) & ":" & Trim(Str(Gsecond)) '2005年などに、2005/5/21 7:37:60 になるためにパッチ JD2YMDT = Trim(Str(GYear)) & "/" & Trim(Str(Gmonth)) & "/" & Trim(Str(Gday)) & " " & _ Format(TimeSerial(Ghour, Gminute, Gsecond), "h:n:s")
おっと失礼。 閉じるのでしたね。 すみません。VB6 は持ち合わせていないので VBAですが、ファイルを誰が使用中か調べるために以前巡り合ったところが残ってました。 http://blogs.technet.com/b/heyscriptingguy/archi … VBSなのでVB6にも移植は簡単かと思います。 ただ、強制的に閉じるのはトラブルの元なので リンク先のように使用者を調べて、鈴木さーん閉じてぇ！と叫んだ方が・・・。 （共有フォルダ上のファイルの場合ですよね？ 　Windows系のファイルサーバーなら有効でしょうけど、 　Linux の Samba とかだと未検証です）
VBAを使わなくても条件付き書式で十分では？ 勉強のためにVBAを使いたいというのなら別ですが……。
はっきり言ってないです。 NULL可能なフィールド以外は必ず値を入れなければなりません。 VALUESの場合はフィールド名も書かなければなりません。 SQL自体をループで生成することはできます。 例えばフィールド名が"X001"、"X002"、…、"X100"ならば 以下の通りです。 SQL = "INSERT INTO TABLE VALUES" For I = 1 To 100 　　SQL = SQL & IIf(I = 1, "(", ",") 　　SQL = SQL & "'" & Me.Controls("TextBox" & I) & "'" 　　SQL = SQL & " AS X" & Fromat(I, "000") Next SQL = SQL & ")" 同様のフィールドが100個あるというのはテーブルの設計が オカシイと思いますよ。親－子の関係のテーブルを考えるのが 本筋でしょう。
基本VB知りません（なのでエラーチェックなども一切行っていません） Windowsフォームアプリケーションだとして Formに Button1　 Button2　 TextBox1　Label1 を配置した状態にして 1. Button1クリックイベントに 　　　Label1.Text = Math.Sqrt(Val(TextBox1.Text)).ToString() 2. Button1クリックイベントに 　　　Label1.Text = "" で動くのは確認(VisualStudio 2010 Proにて)
VBAでExcelオブジェクトを操作する場合は、オブジェクト(CellやRangeなど)の参照は 時間がかかる為、極力少ない方がベターです。 また、Rangeの文字列指定による参照はパフォーマンスをかなり落とすので、利用しない事がベターです。 色々いじるセルがあるようですから、恐らく、下記ようにして、予め対象行の対象セルを 全部Rangeに入れておいて、そのオブジェクトを使いまわす、がいいかもしれません。 Dim CellSetGroup1 As Range Dim CellSetGroup2 As Range Set CellSetGroup1 = Range(Cells(line, 1), Cells(line, 6)) ' A列～F列 Set CellSetGroup2 = Range(Cells(line, 10), Cells(line, 15)) ' J列～O列 MsgBox CellSetGroup1(1).Value ' A1の値を出力 みたいな。 いじってて他に思ったのは、以下の点です。 　・プロシージャを分けて、責任範疇を狭める。 　・マジックナンバーは行わない。 　　5とか7って言われてもどこの列を参照しているのか不透明です。 　　全て必要な列はenumを利用するなどして定義するべきでしょう。 　・Line、MaxRowの型が数値型ではない。正しい型宣言にするべき。 　・リテラル文字は定数定義に変えるべき。 　　"輸入Parts"とか"A2:R20000"とか。 以下、それっぽくリファクタしたコードです。動くのかどうか知りませんし、 何をどうしたいのか理解した上でいじったわけではないので、もっと色んな場所で 改善の余地があると思います。 Private Sub データUPDATE輸入_Click() On Error GoTo Exception Dim line As Long Dim maxRow As Long ActiveSheet.Unprotect Sheets("Invoice").Select line = 5 Do Until Cells(line, 7).Value = "" ' 他のセルを考慮した値出力 Call putJudgeCells(line) ' E列 Call putPreviousCellValue(line, 5) ' 輸入シート関係 Call putSearchCellValue(line) '「Unit price」の計算・円建と外貨建が合わさったインボイスの場合の合計金額 If Cells(line, 14).Value = "" Then Cells(line, 13).Value = Cells(line, 17).Value * Cells(line, 33).Value / Cells(line, 7).Value Else Cells(line, 17).Value = Application.WorksheetFunction.RoundDown(Cells(line, 14).Value * Cells(line, 16), 0) Cells(line, 15).Value = Cells(line, 16).Value * Cells(line, 33).Value / Cells(line, 7).Value End If 'T.Invoice Priceの計算 Cells(line, 23).Value = Application.WorksheetFunction.Sum(Cells(line, 17), Cells(line, 18), Cells(line, 19), Cells(line, 20), Cells(line, 21), Cells(line, 22)) '次の行に移り最後の行まで検索 line = line + 1 Loop Exit Sub Exception: Call MsgBox(Err.Description) End Sub '/** ' * 他セル値を考慮するセルの値を出力を行う ' * @param row 行 ' * @param column 列 ' */ Private Sub putJudgeCells(row As Long) ' A, B, C, D, H, AD列 For Each column In Array(1, 2, 3, 4, 12, 30) Call putJudgeCellValue(row, CLng(column)) Next End Sub '/** ' * 他セル値を考慮して値を出力する ' * @param row 行 ' * @param column 列 ' */ Private Sub putJudgeCellValue(row As Long, column As Long) ' 5行目のセル判断 With Cells(row, column) If Cells(5, column).Value = "" Then .Value = "" Exit Sub End If End With Call putPreviousCellValue(row, column) End Sub '/** ' * 対象セルの前行セルから値を出力する ' * @param row 行 ' * @param column 列 ' */ Private Sub putPreviousCellValue(row As Long, column As Long) With Cells(row, column) If .Value = "" Then .Value = .Offset(-1, 0).Value End If End With End Sub '/** ' * 輸入シートから検索を行い、セルの値を出力する ' * @param row 行 ' * @param column 列 ' */ Private Sub putSearchCellValue(row As Long) Dim maps(1 To 3) As Variant maps(1) = Array(6, 2) maps(2) = Array(26, 3) maps(3) = Array(39, 18) For Each map In maps With Cells(row, CLng(map(0))) .Value = getInWareHouse(line, map(1)) If .Value = "" Then .Value = "データがありません" ' F列の場合、輸入シートにセルコピー If map(0) = 6 Then Call copyUnmatchKey(row) End If End If End With Next End Sub '/** ' * E5の値から「輸入シート」から対象データを検索する ' * @param row 行 ' * @param targetColumn 取得列 ' */ Private Function getInWareHouse(row As Long, targetColumn As Long) As String On Error GoTo Exception getInWareHouse = Application.WorksheetFunction.VLookup( _ Cells(row, 5).Value, Worksheets("輸入Parts").Range("A2:R20000"), targetColumn, False) Exit Function Exception: If Err.Number = 1004 Then getInWareHouse = "" Exit Function Else Call Err.Raise(Err.Number, Err.Source, Err.Description, Err.HelpFile, Err.HelpContext) End If End Function '/** ' * 輸入シート不一致の場合、輸入シートにコピーする ' * @param row 行 ' */ Private Sub copyUnmatchKey(row As Long) Dim maxRow As Long Cells(row, 5).Copy maxRow = Worksheets("輸入Parts").Range("A1").End(xlDown).row + 1 Worksheets("輸入Parts").Range("A" & maxRow).PasteSpecial Paste:=xlPasteValues End Sub
＞輸入Partsのシートからコピーして商品内容確認のシートのセルB17に貼り付けたいです。 ふむふむ。 ＞Maxrow = Worksheets("商品内容確認").Range("B17").End(xlDown).Row + 1 ＞Worksheets("商品内容確認").Range("B" & Maxrow).PasteSpecial Paste:=xlPasteValues '値を貼り付け 何これ。B17に貼り付く訳ないじゃん。 「B列の一番最後を探して、一番最後の行の次の行」に貼り付けようとしてるじゃん。 どっかのマクロを参考にしたんだろうけど、何やってるかも判らずに使ったら、思い通りに動く訳ないじゃんか。 あと、ペーストする時は、ペースト先のワークシートを選択してからペーストしないとエラーになるので、ペーストされずにエラーになって、そのエラーも On Error Resume Next で「エラー無視して次に進め」ってやってるから、結果的に「何も貼り付かない」よ。 On Error Resume Next ってのは「完成してちゃんと動作するまで、決して使ってはならない」のよ。 未完成なのにこんなの入れたら「エラーが出てもエラー表示しない」から「何かエラーが起きても、無かったことになる」ので、自分のプログラムミスに気付けないし、動作しない原因も判らなくなる。 とにかく「初心者はOn Errorは絶対に使うな」って事。使っても良いのは「完成した後」だけ。 とりあえずOn Error Resume Nextをコメントにして（頭に ' （Shift+7）を付ける）実行してみな。何で動かないかが一発で判るから。
レスが付かないので おそらくダメでしょう ＷＥＢクエリーは　取得だけで　送信機能は無いですから。 で、日付設定、表示　ボタンを押した後、アドレスは変わりますか？ 変われば、エラー処理ルーチンで　新しい　アドレスをＷＥＢクエリーに送り込めば、何とか 変わらなければ、基本無理。 エラーの起きた所だけ　別処理で、 ＩＥを起動して、ＩＥで情報を取得　ＩＥ経由でボタンを押すような処理が必要。 その状態で　ＷＥＢクエリーにアドレス送り込んで、上手く日付が変わってくれていれば、以降そのままで良いでしょうし。反応が無いようなら、 ＩＥから　情報を取得するより　方法は無いかと・・・・ こんな感じ Set IE = CreateObject("internetExplorer.application") url = yobiurl With IE .Navigate url .Visible = True 目的の　ＨＰ表示させて * * * in_str = "**********" If InStr(IE.document.Title, in_str) < 1 Then タイトルで正しいか判断して kihon.Cells(3, 39) = "エラー" & Minute(Now) & "分" Exit Sub End If strBody = IE.document.Body.innerText 文章を　読み込んで 目的の所に・・・・
aaa.txtがそもそも存在する必要がないのであれば，リソースとして保持すればよいです。 プロジェクトのプロパティを開いてファイルとして追加すればよいでしょう。 例示されたものであれば，File.WriteAllBytesと組み合わせてできます。 ref) http://msdn.microsoft.com/ja-jp/library/system.i … ref) http://msdn.microsoft.com/ja-jp/library/9za7fxc7(v=vs.110).aspx 実際に行っているのが，ファイルのコピーのようなそもそもShellを呼び出す必要な処理でないものではなく， 別のアプリケーションを起動する引数であるような，対象が実際にファイルである必要があるのであれば， ファイルを出力ディレクトリにコピーする設定にしておき， Assembly.GetEntryAssembly().Locationを元にパスを組み立てるのが簡単です。 ref) http://msdn.microsoft.com/ja-jp/library/system.r … ref) http://msdn.microsoft.com/ja-jp/library/system.r … ref) http://msdn.microsoft.com/ja-jp/library/system.i … ref) http://msdn.microsoft.com/ja-jp/library/fyy7a5kt … または，リソースに保持してPath.GetTempFileNameに出力してしまってもよいでしょう。 ref) http://msdn.microsoft.com/ja-jp/library/system.i …
こんにちは。 EXCELに関するご質問として、お応えします。 直接的な答えとしては、 =SUMIF(INDIRECT("損益!M"&Q25&":M"&Q26),">0",INDIRECT("損益!M"&Q25&":M"&Q26)) または一般的に、 =SUMIF(INDIRECT("損益!M"&Q25&":M"&Q26),">0") というような結果をお求めなのかと思います。 SUMIF()関数の引数については、 第一引数と第三引数が同一のセル範囲を参照する場合、 第三引数を省略するのが通常です。 仮に、第三引数を指定する必要がある場合は、そちらも[セル範囲]を指定する必要がありますから、 [セル参照を表す文字列]を指定するのは誤りということになります。 INDIRECT()関数の引数には、ひとつ、セル参照を表す文字列を指定します。 構文上、INDIRECT()の括弧の中に、カンマで区切った複数の引数を指定するのは誤りです。 別シート上の（単一ではない）セル参照を表す方法の基本例ですが、 　損益!A2:A11 のように、 　「シート名」！「起点セル」：「終点セル」 という書式で書いた方が、演算上のロスも無く、エラーを起こす機会も減ります。 　損益!A2:損益!A11 のように書いても多くの場合で同じ結果を返すので、絶対にダメ、とまでは言いませんが。 ご質問冒頭の数式については、 =SUM(INDIRECT("損益!M"&P25&":M"&P26))です。 この書き方の場合、P25,P26が両方とも未入力だった場合に =SUM(損益!M:M)の計算結果を返します。 例えば、 =SUM(INDIRECT("損益!M"&P25&":損益!M"&P26))のような指定をしてしまうと、 =SUM(損益!M:損益!M)という数式は成立しませんから、必然的に#REF!を返すことになります。 以上、ご参考まで。
度重なり申し訳ありません。 先ほどの回答に追記しておけばよかったのですが、 作業用シートにオートシェイプで「実行」や「検索」などを作成し、マクロを登録することで 入力→オートシェイプクリックでマクロを実行できるため、より手軽にご利用できるかと思います。 （作業用シートを印刷するとのことですので、 　印刷設定を印刷しないにすると良いと思います） http://www.konomiti.com/vba01_1.html →ボタンからマクロを実行できるようにする。（マクロの登録） が参考になるかと思います。 今回のマクロは No2の添付画像にありますとおり、「*いか」で検索しますと「すいか」のようにワイルドカード検索（「*」を用いた検索）が行えます。 現状においてワイルドカードで複数一致する名前がある場合、一番初めに一致するものしか検索されない問題点があります。 （「*いか」でワイルドカード検索をした場合、「すいか」「するめいか」などが名簿にあると一致対象となりますが、今回のコードでは初めにヒットする「すいか」の行しか取得されません。） おまけ機能の「del」を入れることで指定行の削除は、ワイルドカード検索を行った場合適用されません。
TextBox1とLabel1はForm1上の好きな位置に配置してください。 Public Class Form1 Private Sub TextBox1_TextChanged(sender As Object, e As EventArgs) Handles TextBox1.TextChanged If IsNumeric(TextBox1.Text) Then Label1.Text = Math.Sqrt(TextBox1.Text) Else Label1.Text = "" End If End Sub End Class
http://dobon.net/vb/dotnet/process/getprocesses. …
No.3です。 一応確認ですが、VBであって、VBAではないのですよね？ その上で、学習のため、あえてLenやMid関数を使って２進→10進変換をすると。 その場合、下記のような感じになります。そうじゃないときはどちらにも変換の関数やクラスがありますので、そっちを使ってください。 ※入力された文字が半角の0か1だけかどうかのチェックやエラー処理は省略しています。 Dim BinT As String = TextBox1.Text Dim TLen As Integer = Len(BinT) Dim Ans As Integer = 0 For i = 0 To TLen - 1 Ans += Mid(BinT, TLen - i, 1) * (2 ^ i) Next Label3.Text = Ans Mid関数で文字列の右から順に数値を取り出し、それに　2^(桁-1）を乗算、それを加算、という繰り返しです。 2^0=1なので、iは0スタートとし、そのためにストップは桁数（文字数）-1としています。
ちょっと確認していませんが > .Radio_btn1.Checked = True　　’ここへくるとbuttonのeventが発生, イベントは節制しますが、実際に対応するルーチンが実行されるのは、このSubを抜けた後だったように思います。 デバッガでステップ実行したらどうなってますか?
うーん。 依存モジュールにも問題なし、ということですね。 自分の場合は、Win2008R2サーバでのBASP21使用で、IISの再インストールで突然動作しなくなり（それまでは動いていた）、顧客に状況を説明して、Basp21pro 64bitを購入してもらったのですが、いまでも納得でない問題です。もちろん、Basp21pro 64bitは一発で動作し、不具合は起きていません。 サーバ動作の場合はなんとなく事情はわかるのですが、クライアントサイド・VBA経由でそういう変化が出ることは非常に考えにくいです。 経緯を拝見する限り、送信時に限定された処理（送信文面のエンコード変換や添付のための内部メモリバッファ操作）のようで、障害の切り分けは難しいですね。 また、現状正常動作しているマシンが、何らかの原因で動作しなくなることもあるかと思います。 BASP21は公式に「64bit未対応」をうたっていますので、64bitならproを買え、ということなのでしょうか。 ちょっと高いけど。 答えになってなくてすいません。
以下の様な感じでよろしいかと思います。 Sub macro() Dim F As Variant F = Application.GetOpenFilename("画像ファイル (*.jpg),*.jpg)") If F = False Then Exit Sub With ActiveCell ActiveSheet.Shapes.AddPicture F, False, True, .Left, .Top, .Width, .Height End With End Sub
>しかし、新名にも空白が入っている場合に、 >どういうクォーテーションを入れたら良いのか、 >あれこれ試しましたが、うまく行きませんでした。 >重ねてのお尋ねで恐縮ですが、ご教授ください。 なにをどうあれこれ試したのでしょうか？ パソコンをはじめて触る方なのでしょうか。 そうだとしても、それくらいは自分で考えられるようになったほうがいいと思うのですが。 「ren "c:\users\me\desktop\data\旧名.txt" "新名.txt"」 こういう内容の文字列にすればいいわけです。ということはコードは cmd = "ren ""c:\users\me\desktop\data\" & 旧名 & """ """ & 新名 & """" でしょ。
もしかしてファイル名の「0001」とあるセルは、実際に入力されているのは1で、書式で0001と表示していて、さらにブックを開くときは↓こんな感じのコード何じゃないですか？ Workbooks.Open Filename:="C:\顧客データ\" & Range("C4").Value & ".xls" その場合、セルに入っているのは「0001」ではなく「1」ですので、Valueで取り出すのは「1」ですから、1.xlsを開こうとしています。 Workbooks.Open Filename:="C:\顧客データ\" & Range("C4").Text & ".xls" こんな感じにValueではなく、Textにしてみて下さい。
SQLを使ってデータアクセスするのではなくて、SQL Serverに接続してデータを取得したいのですね。私はあんまり詳しくないんですが、どうもADODBオブジェクトを利用するようですね。こんな感じでやるようです。 Dim con As ADODB.Connection Dim rs As ADODB.Recordset Set con = New ADODB.Connection con.connectionString = "Provider=プロバイダ.1;Data Source=データソース;Initial Catalog=データベース; Trusted_Connection=yes;" con.Open Set rs = New ADODB.Recordset rs.ActiveConnection = con rs.Source = "SELECT * FROM テーブル" rs.Open Range(レンジ).CopyFromRecordset rs rs.Close con.Close 実際やってないので、ADODBについて調べてみてください。
Option Explicit Sub Goose() Dim Co(0 To 10) Dim Poo As Integer Dim Boo As Integer 'データ範囲（例えばE列） Poo = 5 Co(0) = 0 For Boo = 0 To 9 Co(Boo + 1) = WorksheetFunction.CountIf(Columns(Poo), "<" & (Boo + 1)) Cells(Boo + 2, "B").Value = Co(Boo + 1) - Co(Boo) Cells(Boo + 2, "A").Value = Boo & "～" & Boo & ".999" Next Cells(12, "B").Value = WorksheetFunction.CountIf(Columns(Poo), ">=10") Cells(12, "A").Value = "10～" MsgBox ("Gattyonn!!") End Sub
んーと、ただ単に > ・split関数にて動的配列へ格納 した直後に内容が空の要素を除去すればよさそうに見えるのですが、それでは何か問題があるのでしょうか。
手詰まりなのでGoogleと http://masahiror.hatenadiary.jp/entry/20111201/v … あのVBSの行頭に、Call runasCheck() とし、 Private Function saveXL(ByRef BookCount) 中略 End Function の後にリンク先の、Function runasCheck() ・・・をつなげ保存。 セキュリティレベルは元に戻して VBSを実行してみてください。 『管理者として実行』出来ているのは確認できましたが、 これでダメなら降参です。
ACCESSというアプリケーションは、 フロントエンド部分 バックエンド部分（Het OLEDBデータベースエンジン） データベースファイル（MDB） の3つから出来ています。 VS（Visual Studio）を使う場合、Jet OLEDBはVisual Studioに含まれていますので、ACCESSは特に不要です。MDBファイルさえあれば良いです。 MDBファイルは、ACCESSで使用されているもので、データが入っていてもかまいません。またVS側から挿入・編集・削除することももちろん可能です。 SQL文は、VSがJetOLEDBを通してMDBを読みだす際に使用しますが、VSには複数のDAO（データベース・アクセス・オブジェクト）があって、その中の最も低水準のアクセス手段がSQLの直書きです。 新しいものになるほど、ウィザードだけでほとんどSQLの記述を必要としないようになります。 （その場合でも、細かいDB操作などのためにSQLによるアクセスは可能になってます） Jet OLEDBは、現在、VisualStudioが使用できるデータベースの中で最も低レベルのものであり、DAOの中にはすでにJet OLEDBをサポートしていないものも多いです。 VSからJet OLEDBを使うには、古い順に SQLCommand（VS2003） DataAdapter（VS2003） TableAdapter（VS2005） 3つの方法があり、これ以上新しい LINQ for SQL（VS2008 SP） Entity Framework（VS2008 SP） ではJet OLEDBはサポート外です。 これから学習されるのであれば、古臭いSQLCommandなど使用せず、最低でもTableAdapterによる利用です。 ネット上にあるリソースはほとんどSQLCommandを使ったケーースなので、この書籍が一押しです。 http://www.amazon.co.jp/Microsoft-Visual-Studio- …
FORTRANのOPEN命令の引数の意味が判らないのであれば、先ずそのFORTRANの取説あるいは文法書を見ないことには始まらない。 昔使っていたFORTRAN（VAX FORTRAN）には「form='BINARY'」や「convert='BIG_ENDIAN'」といったオプションはなかったので、 正確には判らないが、私の経験から ◎FORTRAN側 (1) FORTRANでのREAL変数は、4バイト実数です。（8バイト、又は16バイトの可能性もある） (2) ファイルを'BINARY'指定でOPENしているので、ファイルに書き込まれているデータはバイナリ形式（メモリ内部形式）と推測できる。 (3) ファイルを'BIG_ENDIAN'指定でOPENしているので、ファイルに書き込まれているバイナリデータはビッグエンディアン形式と推測できる。 ※　これは非常に厄介な状態です。なぜならWindows系の言語ではリトルエンディアンが普通なので、バイトの順番を入れ替えて読まないといけない。 ◎Windows側 (1) バイナリファイルなのでエンコードは関係ない。（エンコードはテキストファイルの時のみ使う） (2) ファイルから１変数分の4バイトをByte配列に読込む。（FORTRANのREALのサイズにより8または16の可能性あり） (3) 読みこんだ4バイトの順番を入れ替える。 (4) 4バイトのByte配列を実数に変換する。 (5) ２～４をデータの個数分繰り返す。 ※　ただし、FORTRANのREALのデータ形式と、VB.NETのSingleのデータ形式が同じとは限らないので正しく変換できないかもしれない。 ※　また、ファイルサイスが572バイトだと、読み込もうとしているデータとサイズが合わないのも気になる。 サンプル（ファイル名等は合わせてください） 　　Dim fs As New FileStream("c:\test.bin", FileMode.Open, FileAccess.Read) 　　Dim buf(3) As Byte ' データ格納用配列（REALが8バイトならbuf(7)にする） 　　Dim fWork As Single ' 実数データ（REALが8バイトならDoubleにする） 　　Dim readSize As Integer ' Readメソッドで読み込んだバイト数 　　Dim i As Integer 　　For i = 0 To 16 　　　　readSize = fs.Read(buf, 0, buf.Length) 　　　　Array.Reverse(buf) 　　　　fWork = BitConverter.ToSingle(buf, 0) 　　　　Console.WriteLine(fWork.ToString()) 　　Next i 　　fs.Close()
> Const Chr1 As String = "GN " 「GN」の後にスペースが入っているのが原因でしょう。 ただ、ここを直すだけでは「N=12jikl 」と言う文字列を取り出すことになりますのでMid関数の開始位置を調整してください。
以下のVBAコード内の「\\ネットワークフォルダパス\」を変更してからご利用ください。 ■VBAコード Option Explicit Sub csv保存() '変数宣言 Dim filePath As String Dim i As Long, j As Long Dim fileNo As Integer Dim dpath As String Dim gyou As String '*****初期値設定 'ネットワークパスを指定（最後は「\」） dpath = "\\ネットワークフォルダパス\" 'ダイアログ表示 filePath = Application.GetSaveAsFilename( _ InitialFileName:=dpath & "売上表" _ , FileFilter:="CSVファイル(*.csv),*.csv") If filePath = "False" Then Exit Sub '*****出力処理 fileNo = FreeFile 'ファイル開く Open filePath For Output As #fileNo '最終行までループ For i = 1 To Selection.Rows.Count gyou = "" For j = 1 To Selection.Columns.Count If j > 1 Then gyou = gyou & "," gyou = gyou & Selection.Cells(i, j).Value Next j Print #fileNo, gyou Next i 'ファイル閉じる Close #fileNo End Sub ■フォルダを毎回指定する場合 >1.csvの保存フォルダを指定したい の指定方法で定数でなくユーザーにフォルダを毎回選択させる場合は 「初期値設定」の中の「dpath = "\\ネットワークフォルダパス\"」 の箇所を以下のように変更してください。 With Application.FileDialog(msoFileDialogFolderPicker) If .Show = True Then dpath = .SelectedItems(1) & "\" End If End With
質問の意味をとらえきれていないかと思いますが参考にしてください。 まず、表題の「ExcelでVBAを利用してオートシェイプ情報取得」と最初にある「Excelのオートシェイプをテキストデータに変化するVBAを作成したいです」が異なることを言っているように思えます。『情報取得』と『変化』です。「テキストデータに変化する」がどんな意味なのか分からないからかもしれません。テキストデータに「円」と書かれていたら「図形の円」にする？ ＞このようなオートシェイプの情報をうまく拾う方法、テキストデータと紐づける方法はありませんでしょうか これは、 　１．オートシェイプの情報をうまく拾う方法 　２．テキストデータと紐づける方法 の２つでしょうか 「１．オートシェイプの情報をうまく拾う方法」については参考にモジュールを作ってみました。 「２．テキストデータと紐づける方法」については、 　オートシェイプの情報がどのようなものか分からないですが、オートシェイプのテキストをセルを参照する形式にしてみてはどうでしょうか。添付図の場合、「楕円」のテキストは「=A11」で「明日は」になります。オートシェイプのテキストの算式を使った登録は「セル参照」のみで、複雑な計算式は登録できないのでこのようにしています。複雑な内容を登録したい場合はセル側で整形したりしています。 登録内容を変えたいときはセルの内容を変更します。 ＞Excelのオートシェイプをテキストデータに変化するVBAを作成したいです。ただし対象となるオートシェイプは複数のオートシェイプがグループ化されたグループオブジェクトになっています 　「テキストデータに変化する」がどんな意味なのか分かりませんが、「オートシェイプの情報をうまく拾う方法」として、グループ化された複数のオートシェイプから左から順にテキストを取り出して1行目に表示してみました。VBAでテキストを拾ってくる例です。オートシェイプの位置を変えれば再度マクロを実行すれば出力が変わります。 ＞具体的な操作としては複数のオートシェイプオブジェクトを横に並べたイメージダイアグラムを作成し、それらにそって対応するテキストを配置していきたいというものです 　この説明から、先にグループ化された複数のオートシェイプ（テキスト入力済み）があり、そのテキストを順に表示するのかなと考えた次第です。 「シートのコードウィンドウ」 グループ化されたオートシェイプを選択して実行します。 添付図にはコマンドボタンがありますが、ボタンから実行する場合は、コマンドボタンの「TakeFocuusOnClick」プロパティを「False」にしてください。 Sub オートシェイプのテキスト出力() 　　Dim shp As Shape 'オートシェイプ 　　Dim i As Integer, j As Integer 'カウンタ 　　Dim n As Integer　　'オートシェイプの個数 　　Dim potLeft() As Single 'オートシェイプの左位置 　　Dim Sort() As Integer　　'オートシェイプの左位置の順 　　On Error GoTo ErrorTrp 　　 　　With Selection.ShapeRange 　　　　If .Type = msoGroup Then 'グループ化されていたら 　　　　　　n = .GroupItems.Count 　　　　　　ReDim potLeft(n), Sort(n) 　　　　　　 　　　　　　For i = 1 To n 　　　　　　　　potLeft(i) = .GroupItems(i).Left 　　　　　　　　Sort(i) = 1 　　　　　　　　For j = 1 To i - 1 '左位置を取り込んでソート 　　　　　　　　　　If potLeft(j) >= potLeft(i) Then 　　　　　　　　　　　　Sort(j) = Sort(j) + 1 　　　　　　　　　　Else 　　　　　　　　　　　　Sort(i) = Sort(i) + 1 　　　　　　　　　　End If 　　　　　　　　Next 　　　　　　Next 　　　　End If 　　 　　　　For i = 1 To n 　　　　　　For j = 1 To n　　'ソート順に出力する 　　　　　　　　If Sort(j) = i Then 　　　　　　　　　　Exit For 　　　　　　　　End If 　　　　　　Next 　　　　　　'1行目に順に出力 　　　　　　Cells(1, i) = .GroupItems(j).DrawingObject.Characters.Text 　　　　Next 　　End With 　　Exit Sub ErrorTrp: End Sub
http://www.asahi-net.or.jp/~ef2o-inue/menu/menu0 … こちらもどうぞ。
＞Workbooks(dy & ".xls").Sheets("data").Select アクティブになってないブックは、シートを選択できません。 Workbooks(dy & ".xls").Activate Workbooks(dy & ".xls").Sheets("data").Select として、一旦、見に行くブックをアクティブにして、選びたいシートをアクティブにしなければなりません。 その後、元のブックをアクティブにし直さないと Worksheets("data").Activate は、どのブックのdataシートをアクティブにするか判りませんので、これの前に、元のブックをアクティブにしないと、期待した結果になりません。 元のブック（実行しているマクロが入っているブック）をアクティブにするには ThisWorkbook.Activate を実行します。
あくまで元のファイル上でVBを実行しているので、異なるWorkbookを操作する時は、ちゃんとWorkboooksで指定してあげないとだめですよ。 ようは、上記のVBで、Sheets("data").Selectと指定したところで、元EXCELの「data」というシートを選択しようとするだけです。 それ以降も同様、すべて元EXCELに対して実行しているから何も起こらないんです。 だって、元EXCELの1行目には日付なんてはいってないんでしょうからね。 コード的には、ちゃんとworkbookをActivateして、ActiveWrokbook.Sheets("data").Select のようにつねにActiveWorkbookやActiveSheetを指定して書くか、Workbooks("ファイル名").Sheets("data").SelectのようにWorkbooksを指定して実行するのが良いと思います。 ご参考まで。
＞たとえば、A1:D3に入力してあるデータをA4:D6へ移したい場合、これで切り取りはできないのでコピぺをすると思うのですが、A1:D3を範囲選択してA4:D6へ移動させた場合、A1:D3が切り取られた状態と同じにあると思います。 やはり、カット禁止のようにメッセージBOXを表示させる方法がよいのでしょうか？ コピーだと、A1:D3のデータはそのまま残っていないとおかしいですよね。行や列を削除すれば見かけ上移動する事になるとは思いますが。 シート保護されてるのに、同一シートでペースト出来るようにされてるのでしょうか？ 保護したいデータに誤ってペースト出来る状態の方が問題となるのではないかと感じます。 ペースト禁止範囲をＶＢＡで設定する必要はないのでしょうか。
ボタンを置いてクリックしたら動くマクロは作れるんでしょ？ D1のボタンなら1行目、D2のボタンなら2行目でしょ？ 例えば下のようなイメージかな？ Private Sub CommandButton1_Click() 　　記録 1　'1行目のボタンクリック End Sub Private Sub CommandButton2_Click() 　　記録 2　'2行目のボタンクリック End Sub >Declare Sub Sleep Lib "kernel32" (ByVal ミリ秒 As Long) これはWindowsのAPIの定義です。APIを使うという宣言 だけで、このまま記述しておくだけです。 これは(General)、つまり、モジュールの最初の部分でのみ 記述できます。 サンプルの中で、Sleep 1 という部分で実行しています。 因みに、イミディエイトウィンドウ(分からない時はCtrl+G)で Sleep 1000と入力してEnterキーを押すと、1秒間、フリーズ します。 尚、Declareの宣言は標準モジュールに記述してください。 ボタンクリック時のマクロはシートやブック等のオブジェクトの 中のマクロなので、ここに記述する時はPrivateが必要です。 しかし、Privateだと他のオブジェクトに属する処理の中では 使用できません。同じく、「記録」というプロシージャも 標準モジュールに置いてください。 「記録」にはPrivateを記述していないので、自動的にGlobalに なり、他の手続きからも参照できます。オブジェクトに置くと、 Sheet1.記録 のようにオブジェクト修飾が必要になります。 まぁ、この辺の事情は分からなくてもイイですけど、ボタンの イベント以外は「標準モジュールに書く」だけ覚えて下さい。 あと、CSVファイルを参照する時は直接開かないで、コピーを とり、これをExcelで開きます。直接開くと書き込みロックが かかるので、オペレータさんの方のExcelがフリーズします。
ここらへん http://msdn.microsoft.com/ja-jp/library/cc738592(v=ws.10).aspx http://itpro.nikkeibp.co.jp/article/COLUMN/20060 …
ユニークリスト取得にどの手段が一番速いか試してみた事がありますが、CountIfは数十万件になるとリソース不足で止まってしまいました。当方の試した中で最も速かったのは、配列に取り込んでから、連想配列で重複チェックするものでした。 今回のケースに置き換えて試してみましたが、20万件のデータで、0.5秒弱かかりました。(Core i5 3.2GHz,xl2010-32bit) （もっとも、ウン万件のデータに色をつけてスクロールして探すという行為はとても時間がかかるので、別の目印を考えた方が良いとは思います） Declare Function GetTickCount Lib "kernel32" () As Long Const maxRow As Long = 200000 '時間を測定するために余分なコードが入っています。#3さんのコードをご参照下さい。 Sub checkOverlap() Dim targetRange As Range Dim i As Long Dim buf As Variant Dim myDic As Object Dim myKey As String Dim StartTime As Long StartTime = GetTickCount Application.ScreenUpdating = False Set targetRange = Sheets(1).Range("H3:H" & maxRow) targetRange.Interior.Color = vbRed buf = targetRange.Value Set myDic = CreateObject("Scripting.Dictionary") For i = 1 To UBound(buf, 1) myKey = CStr(buf(i, 1)) If Not myDic.exists(myKey) Then targetRange.Cells(i, 1).Interior.ColorIndex = xlNone myDic.Add myKey, "" End If Next i Application.ScreenUpdating = True Debug.Print GetTickCount - StartTime End Sub '物好きな方のために、所定個数のサンプルデータを作成するコード Sub makeSampleData() Dim targetRange As Range Application.ScreenUpdating = False Set targetRange = Sheets(1).Range("H3:H" & maxRow) targetRange.Formula = "=int(10000*rand())+1" targetRange.Value = targetRange.Value Application.ScreenUpdating = True End Sub 連想配列は言語によっては標準で持っている機能ですが、VBAの場合はDictionaryオブジェクトというのを使う必要があります。「VBA Dictionary」で検索してみて下さい。下記は一例です。 http://www.eurus.dti.ne.jp/~yoneyama/Excel/vba/v …
> 別ブックにまとめ用のフォーマットを作成してあるので、その中のシートにまとめたいのですが、できま > すか？ そのまとめ用の別ブックにVBAをコードし、まとめる必要のあるブックを、VBAからopenすればいいだけだと思います。 http://officetanaka.net/excel/vba/file/file05.htm
「タイトル行が常にある」と言う場合は 　　GYO = 1 　　' EOFまで繰り返す 　　Do Until objTS.AtEndOfStream を 　　'タイトル行の分を空読みする 　　objTS.ReadLine 　　GYO = 1 　　' EOFまで繰り返す 　　Do Until objTS.AtEndOfStream に変えるだけ。 「タイトル行があるか無いか判らない場合」には、１行目を読み込んで、それがタイトルなのかデータなのか判断する必要がありますが、判断は「人間にしか出来ない」ので、プログラムで書く事が出来ません。 「まるでタイトル行のように見えるデータ」や「まるでデータのように見えるタイトル行」とかがあるので「人間が見て判断する以外、どうしようもない」です。 どうしてもプログラムで判断したいなら「１つ目のフィールドは必ず数値なので、１行目の最初のフィールドが数値に変換できない文字列になっていたら、それはタイトル行とみなす」など、何らかの「プログラム可能なデータの規則性」が必要です。
>それを全て手前に表示する方法はありますでしょうか。 おかしくない？？ モニターを　フォームの数だけに分割して　そのサイズにフォーム大きさを指定して、そのフォームの開く位置を指定するって事？？
こんばんは！ それぞれのテキストボックスのプロパティ　→　Tabindex　を確認してみてください。 何も指定がない場合は ユーザーフォームを立ち上げた段階でTabindexが「0」のテクストボックスが　SetFocus　されます。 後はEnterを押すたびに　1　→　2　→　3　・・・と順に入力可能な状態になるはずです。m(_ _)m
＃４のひとも言ってますが 質問者が希望する「比較のルール」が不明なのです。 ＞文字列には半角も全角もあって数字もあります ということですが ・アルファベットの大文字と小文字は区別するのか？同一とみなすのか？（"A"と"a"） ・アルファベットの半角と全角は区別するのか？同一とみなすのか？（"A"と"Ａ"） ・カタカナとひらがなは区別するのか？同一とみなすのか？（"ア"と"あ"） ・アルファベットと数字ではどちらが大きいとするのか？ など、いろいろな比較ルールが考えられます。
DateTime.Today.Day で今日の日の値が取れるのでそれが 15 未満か否かで判定してください。 http://msdn.microsoft.com/ja-jp/library/system.d …(v=vs.110).aspx ……っと、上は 15 日ちょうどを False とする場合ですので、True とする場合は判定法を「15 以下か否か」にしてください。
本来は 　If number Is Nothing Then の部分でエラーになるのですが(Variant型変数であるnumberの内部処理形式がStringのため)、 　On Error Resume Next が書かれているためにエラーが無視され、 結果的に条件分岐が正常に行われていないようです。 個人番号が1文字も入力されていなかったら関数を抜ける、という動作がしたいのでしょうか？ InputBoxに何も入力しなかった場合はNothingではなく空文字列が返ってくるので、 　If number = "" Then と書いてくださいな。
> 今度はRangeクラスのselectメソッドが失敗しました > と言われてしまいました、、、 「Range Select 失敗」といったキーワードで検索してみるとすぐ出てくる情報ですが、 セルを選択状態にするには、そのセルを含むシートがアクティブになっている必要があります。 With wskyu 　.Activate 'シートをアクティブにする 　.Range("P7:AQ7, ……").Select 　(略) End With
で、現状の具体的なコードはどうなってんの？ VB6は持ち合わせていませんが、親戚？のVBAなら Function myMax(ParamArray aryX() As Variant) As Variant '要素の中で最大値を求めます。myMax(null,5,10,3) → 10 Dim v As Variant For Each v In aryX If IsEmpty(myMax) Or IsNull(myMax) Or v > myMax Then myMax = v End If Next 'Debug.Print TypeName(myMax) End Function ご参考まで。
私は、デフォルト設定から変更する場合は、主にコードで設定しています。 ただ、デザイナで変更しても、InitializeComponent 内に自動でコードが 書かれます。そういった意味では、プロパティウインドウで設定しても 自分でコードを書かないだけで、コードで設定しているとも言えます。 ところが、この自動で書かれているコードには独自のルールがあるようで、 プロパティのデフォルト値と同じであると省略されたり、コードに書かれる コントロールの順も不定な部分があります。また、開発環境の解像度などの 影響を受けて、プロパティ値が自動調整される事があります。 そういった諸々の事情から、企業で開発するプロジェクトでの保守性や、 別プロジェクトへの再利用性に劣ります。 自前のコードで書いてあると、そこが自動で変更される事は無い(実行時に 調整される事はあっても)ので、意図して値を変更した事が明確に履歴管理 でき、また、そのコードで1回十分にテストしておけば、そのまま安心して 他プロジェクトに流用できます。また、複数プロジェクトで、どのプロパティ を流用して、どのプロパティは流用しなかったか(つまり、どの機能を実装し、 どの機能は実装しなかったか)といった差分比較も簡単になります。 少し特殊な事例としては、画面上に規則正しくコントロールが並んでいる時に その位置や初期値を関数で設定した事があります。一度設定するだけなら デザイナ上で設定しても手間は変わらないか、むしろ関数化するほうが時間が 掛かるかもしれませんが、何度も調整したり、変更が予想される場合は 少しの変更で調整できて便利でした。 以上のような経験から、 デザイナ上で調整するのは、位置と、タブ順・コントロール名くらいで、 他のプロパティは基本的には自前のコードで設定するようになりました。
該当フォルダの参照権を持つアカウントの ユーザとパスワードが分かっていれば可能です。 特定の利用者にしか権限を与えないフォルダに システム情報を記録して、一般ユーザから保護 するという仕組みはよく見られる手法です。 LogonUserで権限ユーザのトーケンを取得し、 ImpersonateLoggedOnUseで偽装します。偽装中は フォルダを参照できます。 その後、RevertToSelfで偽装を終わり、処理後、 CloseHandleでトーケンを閉じます。 以下、サンプルです。 Const LOGON32_LOGON_INTERACTIVE As Long = 2 Const LOGON32_PROVIDER_DEFAULT As Long = 0 Declare Function LogonUser Lib "Advapi32" Alias "LogonUserA" _ 　　　　(ByVal ユーザ As String, _ 　　　　 ByVal ドメイン As String, _ 　　　　 ByVal パスワード As String, _ 　　　　 ByVal タイプ As Long, _ 　　　　 ByVal プロバイダ As Long, _ 　　　　 ByRef トーケン As Long) As Long Declare Function ImpersonateLoggedOnUser Lib "Advapi32" _ 　　　　(ByVal トーケン As Long) As Long Declare Function RevertToSelf Lib "Advapi32" () As Long Declare Function CloseHandle Lib "kernel32" _ 　　　　(ByVal ハンドル As Long) As Long Sub サンプル() Dim トーケン As Long Dim 処理結果 As Long '★トーケン取得 処理結果 = LogonUser("uuuu", ".", "pppp" _ 　　　　　　　　　, LOGON32_LOGON_INTERACTIVE _ 　　　　　　　　　, LOGON32_PROVIDER_DEFAULT _ 　　　　　　　　　, トーケン) If 処理結果 = 0 Then 　　　　MsgBox "ログオンできない" 　　　　Exit Sub End If '★偽装開始 ImpersonateLoggedOnUser トーケン '== '= ここで該当フォルダの処理を行う '== '★偽装終了 RevertToSelf '★トーケン解放 CloseHandle トーケン End Sub ※上記はローカルアカウントのuuuu/ppppの例です。 但し、フォルダ毎に権限者が誰か調べたりする 必要があります。尚、権限が設定されていないと、 Administratorでも何も出来ません。 これも調べる方法、破る方法はあるんですが、さすがに セキュリティに関することなので、一般公開できません。 ここまでするよりはエラーハンドリングで逃げたほうが マシかも知れませんね。
事前にドライブをマウントしておけば参照できるのでは？
再度失礼します。 htmlの<div>の中のテキストを取得する場合のサンプルです。 Public Class Form1 Const UR As String = "http://oshiete.goo.ne.jp/qa/8628598.html" Private Sub F() Handles MyBase.Shown WebBrowser1.Navigate(UR) End Sub Private Sub WebBrowser1_DocumentCompleted(sender As Object, e As WebBrowserDocumentCompletedEventArgs) Handles WebBrowser1.DocumentCompleted '読み込まれたUrlが一致した場合 If UR = e.Url.ToString Then For Each htm As HtmlElement In WebBrowser1.Document.GetElementsByTagName("div") TextBox1.Text &= htm.InnerText & vbNewLine Next End If End Sub End Class
Dim f1 As New Form1() Me.Hide() f1.Show() でできそうな気もしますが，そもそも設計をやり直す方がよいと思います。 リロードではなく，プロパティを再設定をすれば良いのですから。 # データバインドしているならば，大元のデータソースを入れ替えれば全部が変わる。
フォルダーを一括で指定することは難しかったと思います。多分普通はできません。 行いことがほぼ分かったので、モジュールを書いてみました。 ○フォルダーの指定は最初の年月と最後の年月から計算しています。 　年月の取り込みは検討してください。今はモジュール内に書いています。 　また、フォルダーのパスも書いています。変更してください。 ○連続の年月指定でなく任意の年月指定の場合はフォルダーを一つずつ選択しシートに書いたり、シートに記入した年月を処理すればこのモジュールで対応できると思います。 ○ファイルの処理はDirを使って順次処理しています（ファイル名を出力しているだけです）。 　ファイル名を配列に格納とかはしていません。 シートのコードウィンドウです。これはコマンドボタンで動かしています。 Private Sub CommandButton1_Click() 　　Dim strPath As String　　　　 'フォルダーパス 　　　　strPath = "L:\999_Test\" 'フォルダー名をセット 　　 　　Dim fromYear As Integer, fromMonth As Integer '開始年月 　　Dim toYear As Integer, toMonth As Integer　　 '終了年月 　　Dim ym As Integer　　　　　　　　　　　　　　 '月カウンタ 　　Dim Folder As String　　　　　　　　　　　　 '個別フォルダー 　　　　fromYear = 2014: fromMonth = 3 　　　　toYear = 2014: toMonth = 5 　　　　 　　Dim fileName As String　　 'ファイル名 　　 　　'最初から月を進める 　　For ym = 0 To toYear * 12 + toMonth - (fromYear * 12 + fromMonth) 　　　　Folder = Format(DateSerial(fromYear, fromMonth + ym, 1), "yyyymm") 　　　　'ファイルを開く 　　　　fileName = Dir(strPath & Folder & "\" & "*.*") 　　　　While fileName <> "" 　　　　　　 　　　　　　MsgBox fileName 'ここが実際の処理 　　　　　　 　　　　　　fileName = Dir 　　　　Wend 　　Next End Sub
はい 「ADO.NET パフォーマンスの向上」 http://msdn.microsoft.com/ja-jp/library/ff647768 … 「1 つの処理について Fill または Update を使う場合は接続を明示的に開かない。」 と書いてあります。
こんにちは！ ＞ある文字列を探し、その値がある行番号を知りたい ご質問の内容だとHLOOKUP関数等は適当ではないと思います HLOOKUP関数は指定した範囲で1行目データを検索値として、その列の何行目を返すか？という関数になります。 すなわち「何行目」はご自身で決める必要があります。 知りたいのは何行目にあるか？ですよね？ 色々やり方はあると思いますが、 ↓の画像のようなレイアウトだとG2セルに =SUMPRODUCT((A1:E6=G1)*ROW(A1:A6)) という数式を入れています。 画像で「つ」は範囲指定内の4行目にありますので、「4」という結果が返っています。 （データ範囲内に重複はない！という条件です） ※　的外れならごめんなさいね。m(_ _)m
> 初回の画面表示が遅い原因 NW先にデータがある場合、どうやら一旦ローカルのメモリ上に持ってきてると思います。 タスクマネージャのネットーワークを監視すると、１回目と２回目では トラフィックが大きく異なることを確認できると思います。
「次のステートメントの設定」 1)ブレークポイントで一旦止めてから、次に止めたい行に カーソルを合わせる。 2)デバッグ(D)メニューから「次のステートメントの設定」 を選択。またはCtr+F9
例えば、 Dim DAY As String Dim WEEK As String Dim MONTH As String DAY = "日" WEEK = "週" MONTH = "月" みたいな事をしていたとして、Dictionaryを使って下記の様に してはどうでしょうか？ Dim strHoge As String strHoge = "DAY,日/WEEK,週/MONTH,月" Dim x() As String Dim y() As String Dim z As New Dictionary Dim ixLoop As Integer x = Split(strHoge, "/") For ixLoop = 0 To UBound(x) y = Split(x(ixLoop), ",") ReDim Preserve y(1) z.Add y(0), y(1) Next MsgBox z.Count MsgBox z("WEEK") & vbCrLf & z("MONTH") まぁこれだと、 WEEK = "週" ってしていたのが、 z("WEEK") = "週" になってしまいますが・・・ ※参照設定で、[Microsoft Scripting Runtime]をチェックしておきます もし参照設定しない場合は、 Dim z As New Dictionary の部分を、 Dim z As Object Set z = CreateObject("Scripting.Dictionary") にして下さい また、<strHoge = "DAY,日/WEEK,週/MONTH,月">の部分がものすごく長くなる場合は、 strHoge = "DAY,日/WEEK,週/MONTH,月" & _ "/YEAR,年" の様に複数行に分けるか、 strHoge = "DAY,日/WEEK,週/MONTH,月" strHoge = strHoge & "/YEAR,年" みたいにしても良いかと思います
プログラムの書かれたファイルを見ましたが、その76行目（冒頭で自己レスされている行）が本当にそこに書いてある通りならば、そこの td タグの style 属性の二重引用符が閉じていないようです。 というか、この質問は（プログラミング言語は Visual Basic ですが） Microsoft ASP でされた方がよかったのではないかと思いますし、 > 自動ログインできるようにできないか と言ってくる責任者はセキュリティを軽視している問題社員にしか見えません。
「シート1、シート2、共にデータがA列～R列(1列目～18列目)にあり、行数は不定。ただしA列に空白はないものとする」 という前提であれば、 Dim GYO1 As Long Dim GYO2 As Long GYO1=Worksheets("Sheet1").Cells(Rows.Count, 1).End(xlUp).Row GYO2=Worksheets("Sheet2").Cells(Rows.Count, 1).End(xlUp).Row With Worksheets("Sheet1") .Range(.Cells(GYO1,1), .Cells(GYO1,18)).Copy End With Worksheets("Sheet2").Cells(GYO2 +1,1).PasteSpecial
> できればfile2を適当な名前で作った時にも値を持ってこられるようにしたいのですが、、、 もし、エクセルのファイルをfile1とfile2の2個しか開いていないのでしたら For i = 1 To Workbooks.Count If ThisWorkbook.Name <> Workbooks(i).Name Then file2 = Workbooks(i).Name End If Next i とすることで、どのようなファイル名でも対応できます。 複数開いている場合には、何をもってfile2だと判断できるのかによって対応が違ってきます。 たとえば、ファイル名に一定のワードを必ず入れてもらうようにするのでしたら、同じような感じで For i = 1 To Workbooks.Count If Workbooks(i).Name Like "*一定のワード*" Then file2 = Workbooks(i).Name End If Next i で対応できます。 もし、フォルダの中で一番新しいファイルと決まっているのでしたら i = 1 ChDir ThisWorkbook.Path f = Dir("*.*") file2 = f Do While f <> "" buf = f If FileDateTime(file2) < FileDateTime(buf) Then file2 = buf End If i = i + 1 f = Dir() Loop などのような手段があります。 > 参照という言い方が悪かったかもしれません(・・;) > 新たに作るfile2にはfile1で必要な値がいくらかあり、 > それを持ってきたいのです Range("A1") = Workbooks(file2).Sheets("Sheet1").Range("A1") みたいな感じでfile2の内容をfile1に持ってこれます。同一ファイルのセルの値をセルに代入するのと同じでWorkbooks(file2)でファイル名を追加するだけです。
DoEventsではなくSleepを入れる。 '定義 Public Sub Sleep Lib "kernel32" (ByVal ミリ秒 As Long) プログラムの所々に"Sleep 1"を入れる。 タスクマネージャで見ると、入れる前と、入れた後では CPU使用率が全く異なることが分かると思います。 これはOS依存の問題ではなく、Windows下における プログラムの「配慮」の問題です。
> SELECT A.請求先コード 請求先CD, B.会社名 請求先名, > GROUP BY A.請求先コード, B.会社名 > ORDER BY A.請求先コード GROUP BY 1, 2 ORDER BY 1 としたらどうなりますか？ SELECTで別名付けたなら、Whereでも統一したほうが良いかも。
C:\REAL\SYSFILE"を編集して"C:\REAL\SYSFILE_NEW"を作成（コード省略） SYSFILE_NEWを読み込んで最終行の番号を取得（コード省略） 　　　　　　↑ この部分に問題があるのでは？ どうやってるのかわからないんですが、例えばファイルを閉じてないためCopyFileでファイルが取得できないとか、そういったことはないでしょうか。
またまたお邪魔します。 ＞保護を前提に再度教えて頂けないでしょうか？ というコトですので、もう一度コードを変えてください。 尚、F3～G36セルは編集可能にする場合です。 下準備としてF3～G36セルを範囲指定　→　右クリック　→　セルの書式設定　→　「保護」タブで 「ロック」に入っているチェックを外してください。 （他のセルも編集可能にしたい場合は同様の操作をしておきます。） その後Sheetの保護を行ってください。 今までのSheetモジュールはすべて消去して↓のコードにします。 Private Sub Worksheet_Change(ByVal Target As Range) Dim c As Range If Intersect(Target, Range("F3:F36")) Is Nothing Or Target.Count > 1 Then Exit Sub ActiveSheet.Unprotect With Target Set c = Range("I:I").Find(what:=.Value, LookIn:=xlValues, lookat:=xlWhole) If c Is Nothing Then .Resize(, 2).Font.ColorIndex = xlAutomatic Else .Resize(, 2).Font.ColorIndex = 3 End If End With ActiveSheet.Protect End Sub これでF3～G36セルと「ロック」にチェックが入っていないセルだけが編集可能になり、その他のセルは編集できなくなります。 尚、Sheetの保護の保護でパスワードを設定している場合、仮にパスワードが　aaa　だとすると ＞ActiveSheet.Unprotect の行を ＞ActiveSheet.Unprotect Password:="aaa" ＞ActiveSheet.Protect の行を ＞ActiveSheet.Protect Password:="aaa" としてやります。m(_ _)m
表を作り直してVlookupで十分です。 VBAでやるなら↓ MsgBox Application.WorksheetFunction.VLookup(225000, Range("A:B"), 2)
http://excel.style-mods.net/tips_vba/tips_vba_6_ … ' グラフのタイトルを設定 ActiveChart.Axes(xlCategory, xlPrimary).HasTitle = True ActiveChart.Axes(xlCategory, xlPrimary).AxisTitle.Characters.Text = "ｎ回目" ' グラフのタイトルを設定 ActiveChart.Axes(xlValue, xlPrimary).HasTitle = True ActiveChart.Axes(xlValue, xlPrimary).AxisTitle.Characters.Text = "n%" こういった書き方で良いらしいです？
失礼しました。 2行目が開始行であるところを、1行目からと見間違え、 ご質問者の文章と画像が1行ズレていると勘違いしておりました。 ですが、C5、C6に1が入っていないように見えますが。 【関数で処理】 A2セルに「=IF(COUNTA(D$2:D2)=0,"",COUNTA(D$2:D2))」を入力して C6までオートフィル（コピー）してください。 【VBAで処理】 (1)エクセル関数を使用するなら Sub test1() Dim cnt As Long, i As Long, j As Long For i = 1 To 3 For j = 2 To 6 Cells(j, i).ClearContents cnt = WorksheetFunction.CountA(Range(Cells(1, i + 3), Cells(j, i + 3))) If cnt > 0 Then Cells(j, i) = cnt Next j Next i End Sub (2)数えるなら Sub test2() Dim cnt As Long, i As Long, j As Long, l As Long For i = 1 To 3 For j = 2 To 6 Cells(j, i).ClearContents For l = 1 To j If Cells(l, i + 3) <> "" Then Cells(j, i) = Cells(j, i) + 1 End If Next l Next j Next i End Sub
こちらを参考にしてみてください。 http://home.att.ne.jp/zeta/gen/excel/c04p07.htm
2値という意味では先の回答者の方の通りBooleanでいいと思いますが、 VBでのBooleanのルールは ・0 は偽 (False) になり、0 以外の値はすべて真 (True) ・Booleanを数値に変換すると偽 (False) は 0、真 (True) は -1 です。 数値の意味が重要なら素直に数値型を使えばいいと思います。 その際Byte型を使う意味はほとんどありません。0から255まで 入るので2値に制限できないという意味で、他の数値型と 変わらないと思います。 そうなるとOSとの合性でIntegerでいいと思います。 Byte型の方が僅かながらメモリの節約になる可能性もあると 思いますが、現在の大量メモリを使用するパソコンの設計では ほぼ意味がありません。 工夫するならEnumでゼロとイチを宣言して、その変数には その2つの値が入る事を明示すれば、他人が見ても分かり易い 設計になるかもしれません。
While True ' 1バイト読み込み readSize = src.Read(buf, 0, BUFSIZE) ' 読み込むものが無ければ終了 If readSize = 0 Then Exit While ' 書き込み dest.Write(buf, 0, BUFSIZE) ' 改行コード書き込み dest.Write(new Byte(){&H0D, &H0A}, 0, 2) End While
VBA というか VSScript で検索すれば探しやすいと思います。 「VBScript IE プロキシ 設定」 とか 自身でやったことはないので具体的な方法はご自分で確認していただくことになりますが、ざっと見たところレジストリを操作するようですね。
アクティブセル位置から上すべての値（数式ではない）が入力されているセルを数えるとして。 Sub macro() With ActiveCell MsgBox .Offset(1 - .Row).Resize(.Row - 1).SpecialCells(xlCellTypeConstants).Cells.Count End With End Sub 数値のみ数えるのであれば、Count関数がベストです。（文字も混ざっているなら、CountA関数を使います。） Sub macro2() With ActiveCell MsgBox WorksheetFunction.Count(.Offset(1 - .Row).Resize(.Row - 1)) End With End Sub
向き不向きはともかくとして、作るのは可能でしょう。権利関係も、個人的に楽しんでいる限りに於いては問題ありません。 10年くらい前でしたかね、VBAでゲームを作る事が流行った時期が有り、指南本なども出版されました。私もそうした書籍に触発されてゲームプログラミングにハマった一人ですが、VBAの性能ならば、一昔前の、ファミコン時代のゲームくらいならば、結構作ることが出来ます。ただ、根気がいります。面倒くさい設定とか、地味な作業が色々ありますので。１つのゲームをバッチリ完成させるのに１年以上掛かる事もあります。気力・集中力など個人の限界や、「飽き」、という厄介な問題にも直面します。凝った内容にすればするほど、途中で挫折する危険性も高まります。 それと、VBAは高速アクションやスクロールは得意ではないので、スピード感溢れる本格的なゲームを志向するなら、それ向きの他の言語を選ぶ道も考えなくてはなりません。が、半年の経験ということであれば、このままVBAで取り組んでみて損はないと思います。
Dim objShell Set objShell = CreateObject("WScript.Shell") objShell.Run """C:\Program Files\Mozilla Firefox\firefox.exe"" ""http://★★★/" & Sid & """", vbNormalFocus, False Set objShell = Nothing という感じでしょうか。 Firefoxの実行ファイルのパスは、お使いの環境に合わせて変更してください。 WshShell.Runメソッドについて http://msdn.microsoft.com/ja-jp/library/cc364421 … Firefoxのコマンドラインオプションについて https://developer.mozilla.org/ja/docs/Mozilla/Co …
提示されたのは、どのような環境で記述されたものなのでしょうか。 > Dim raCommentFind As Range がエラーになっていない？であれば、Excel は参照設定されているのでしょう。 参照設定しているのであれば、 > Dim oCommentXLS As Object > Dim oCommentXLSWorkbook As Object > Dim oSheet As Object 部分は、 Dim oCommentXLS As Excel.Application Dim oCommentXLSWorkbook As Excel.Workbook Dim oSheet As Excel.Worksheet と記述しておけば、例えば、oSheet と記述した後に . を入力すると、候補が表示され便利です。 また、 > Set oCommentXLS = CreateObject("Excel.Application") する必要はなく、 Set oCommentXLS = New Excel.Application で事済みます。 また、Excel で良く使う Application は、oCommentXLS にあたるので 　Application.WorksheetFunction ↓ 　oCommentXLS.WorksheetFunction 参照設定していないのであれば、xlValues　xlWhole　等の Excel での定数は定義しておく必要があります。 また、Cells　Range を記述する時には、誰の下で・・・を指定します。 　Cells.Find( → oSheet.Cells.Find( 　Range("A1　→ oSheet.Range("A1 余談） 参照設定すれば Cells　Range はそのまま記述しても動くようですが、 誰の下で・・・を指定しておいた方が良いかも 以下、Excel を参照設定してある環境で実行してみます。 Public Sub test1() 　　Dim oApp As Excel.Application 　　Set oApp = New Excel.Application 　　oApp.Visible = True 　　oApp.Workbooks.Add 　　oApp.Range("B2") = "ABCD" ' Range("B2") = "ABCD" でも同じ結果に 　　Set oApp = Nothing End Sub ※ Application 直下に Range 記述しているので、アクティブブックのアクティブシートが隠れているようですが、 さて、以下での ★ は、どこに記述されるのでしょう Public Sub test2() 　　Dim oApp1 As Excel.Application 　　Dim oApp2 As Excel.Application 　　Set oApp1 = New Excel.Application 　　Set oApp2 = New Excel.Application 　　oApp1.Visible = True 　　oApp2.Visible = True 　　oApp1.Workbooks.Add 　　oApp2.Workbooks.Add 　　oApp1.Range("B2") = "ABCD" 　　oApp2.Range("B2") = "abcd" 　　Range("C2") = "1234" ' ★ 　　Set oApp1 = Nothing 　　Set oApp2 = Nothing End Sub Public Sub test3() 　　Dim oApp As Excel.Application 　　Set oApp = New Excel.Application 　　oApp.Visible = True 　　oApp.Workbooks.Add 　　oApp.Range("B2") = "ABCD" 　　Set oApp = Nothing 　　Set oApp = New Excel.Application 　　oApp.Visible = True 　　oApp.Workbooks.Add 　　oApp.Range("B2") = "abcd" 　　Range("C2") = "1234" ' ★ 　　Set oApp = Nothing End Sub ※ エラーになる場合もありますね。 エラーにならない時には、どちらも 1234 の左側は ABCD でしたね （Vista + Access2007 にて）
こちらの セル内の改行コードに注意 http://officetanaka.net/excel/vba/tips/tips89.htm のSumple2を読んでもらえば あなたの謎の改行の正体を確認できるハズです。 または制御文字が表示できるテキストエディタとかで。 Excelの場合ならセル（項目）内改行はLFですが 他のアプリでは項目内改行がCRLFの場合もあります。 で、 正規表現で抜き出そうとしましたが、あえなく撃沈 orz テストに使用したのは以下９行をCSV保存したものです。 "りん ご",1,150,150 "バナナ",10,200,"1,022,000" "メ ロン","1,000","2,000","2,000,000" "パイ ナッ プル","-1,000",0.123,"100,000" 探した結果 http://excel-ubara.com/EXCEL/EXCEL119.html でダブルクォーテーション内に『改行』があっても 上手に処理してくれるようです。
ReDimのヘルプより メモ 宣言した変数がモジュール レベルまたはプロシージャ レベルにない場合、 ReDim ステートメントは宣言ステートメントと同様の働きをします。同じ名前を 持つほかの変数が後で作成されると、その変数の適用範囲 (スコープ) が広く、 Option Explicit ステートメントが指定されている場合でも、 ReDim ステートメントは後で作成された変数を参照し、コンパイル エラーは発生しません。 このような名前の競合を避けるには、ReDim ステートメントは宣言ステートメント として使わず、配列を再定義するためだけに使用します。 と、ありますので宣言なしでRedimはしない方がいいでしょうね。 バグの温床になりそうな気配です。
その消える手前で、UserFormから他のUserFormを呼び出したり していませんか？別のUserFormを閉じた時にまれに呼び出したFormが 一緒に消える現象があります。 UserForm1のコード なにかしらの処理 UserForm2.Show このフォームを閉じるとUserForm1が一緒に消える場合がある DoEvents DoEvents End SUb DoEventsを２つ書くとどうでしょうか。 別のフォームなんて呼びだしていなよという場合は、これには当てはまりませんので ご容赦を。
VBとはちょっと違いますが、Excel-VBAでは、WorksheetFunction.Radiansで度をラジアンに、WorksheetFunction.Degreesでラジアンを度に変換できます。これは、Excelのワークシート関数にRadiansやDegreesが存在し、それをVBAで利用できる設計のためです。 ところで、プログラミングの古典的な位置付けにあるＢＡＳＩＣ言語でも、三角関数の引数にはラジアンが使われており、かなり昔から、その分野では弧度法が用いられていた事が伺えます。 中学校の学習内容には微積分やプログラミングは入っていないので、直感的に解りやすい（アナログの丸い時計などに当てはめて考えやすい）度数法が優先して教えられるのでしょう。 内容が高度になるにつれ、弧度法のほうがスタンダードという扱いになるんじゃないかと思います。
VBAですよね。 でしたら、変数をワークシート上にいちいち書き出すように プログラムを直して、プログラムを分割すればいいんです。 要はパブリック変数の代わりにワークシートを使うってことです。 Excelは広大なワークシートがありますから、その辺は使い まくっても全然問題なしです。 正常に動作すれば、書き出し、読み取りをコメントアウトして コピペすれば済みます。
PC-9801のシリアルポートの速度は、DiskBasicから設定はできません。メモリスイッチで設定します。（switch.n88が付いている） また、5インチのデータはプログラムソースですか？　テキストファイルですか？　バイナリファイルですか？ プログラムソースなら、BASICでLoadして、「COM1:」にアスキーSAVEすれば良い。 テキストファイル（バイナリファイル）なら、ファイルを１バイトずつ読み込んで、16進2桁にしてシリアルポートに出力するようなプログラムを、BASICで作る必要があります。　この場合、受信側にも受信したデータを16進2桁から１バイトに戻してファイルに出力するするプログラムを用意する必要があります。
試してみたところ、GOM Playerでは 　SendKeys "G" → Shift+G 　SendKeys "g" → G として認識されるようです。
入力ファイルの各バイトを ただ単純に16進数表記で出力するプログラムです。 適当に改造すれば目的のこともできるでしょう。 ======================================== ' インデントに全角空白を使っています。要削除。 Class Bin2HexText 　Shared Sub main(ByVal args As String()) 　　Dim srcName As String = args(0) ' 入力ファイル名 　　Dim destName As String = args(1) ' 出力ファイル名 　　Dim BUFSIZE As Integer = 2048 ' 1度に処理するサイズ 　　Dim buf(BUFSIZE) As Byte ' 読み込み用バッファ 　　Dim readSize As Integer ' Readメソッドで読み込んだバイト数 　　Using src As New System.IO.FileStream( _ 　　　　srcName, System.IO.FileMode.Open, System.IO.FileAccess.Read) 　　　' 出力ファイルはテキストファイルとして扱う 　　　Using dest As New System.IO.StreamWriter( _ 　　　　　destName, False, System.Text.Encoding.GetEncoding("shift_jis")) 　　　　While True 　　　　　readSize = src.Read(buf, 0, BUFSIZE) ' 読み込み 　　　　　If readSize = 0 Then 　　　　　　Exit While ' 完了 　　　　　End If 　　　　　For i As Integer = 0 To readSize - 1 　　　　　　　' Byte型数値を16進数表記(文字列)に変換して出力 　　　　　　　dest.Write( String.Format("{0:X2} ", buf(i)) ) 　　　　　Next 　　　　End While 　　　End Using 　　End Using 　End Sub End Class
動きます。 標準モジュール内で標準モジュールを利用することも可能ですし、 クラスは標準モジュール内で利用することが当たり前や前提ということはありません。 但し、標準モジュールと違うところは、クラスが一旦破棄されれば、クラス内で利用している クラスも操作できなくなるという点です。 (デストラクタで内部のクラスは解放すべきだし、改めてインスタンス化するなどの必要が出てくる) それだと困るなら、内部で利用するものは、スタティックなクラスとして作るなど、考えが 必要です。(いわゆるシングルトンな設計でクラスを作るなど)
if 式1 or 式2 then と書けば、見えてくると思いますよ。さすれば、 式1は、　aaa=0　で 式2は、　1 だと言うことが判ります。 式1が成立するのは、 aaa の値が 0　の場合のみ。 式2が成立するのは、常にです。なぜなら、式が1だからです。 イミディエイトウインドウで、1が何を意味するのかを調べて表示している画像を添付しています。そこには、 ?CBool(1) True つまり、1と書いた式は、常に真であるということです。 以上で、理解してもらえたかな。
> .Range("H" & i).Copy.wsDetail.Range ("D24") > .Range("L" & i).Copy.wsDetail.Range ("H24") > .Range("N" & i).Copy.wsDetail.Range ("L24") この3行の"Copy"と"wsDetail"の間にあるピリオドを半角スペースに直してください。
最新のバージョンの動作は知らないけど、 CommandBarsコレクションの中を羅列して対応するボタンを見つけて、 Executeしてやれば2003まではできてた。 http://www.moug.net/tech/exvba/0150053.html
C#しか書けないけど、こんな感じ //変換表を作成 byte[] convList = new byte[256]; for (byte i = 0; i <= 255; i++) { convList[i] = (byte)((i << 3) & 255 | (i >> 5)); } using (FileStream reader = new FileStream(～)) using (FileStream writer = new FileStream(～)) { while (true) { int c = reader.ReadByte(); if (c == -1) break; writer.WriteByte(convList[c]); } }
問題が出た経験はないですね。 Access 2010 にバージョンアップした時に全角のプロシージャ名が壊れた経験がありますが、2010 を出発点とするなら問題ないと思います。 入力を変換確定させるまでインテリセンスの候補に出ないとかの細かなデメリットはありますが、半角アルファベットで変数名の名前付けに迷ったり、変な名前を使われるよりはメリットがあると思います。 "全角文字を使う" というよりは "日本語を使う" というルールの方が分かりやすいかな？ 本当の敵は "ローマ字読みの変数名を使いたがる人" だと思う・・・
No5の訂正です。 MyRow = .Range("B" & Rows.Count).End(xlUp).Row + 1 新しい最終行を追加した後にこのコードを追加するので最後の+1は不要でした。 あと、既存の式でカウントされているセルですが、そのセルをコピーしてそのまま「値貼り付け」してしまえば計算しない分軽くなると思います。
おかしな所は見当たらないですね。 こちらでも検索してみましたが、ソートするフィールドの型によってもその実行時エラーが 発生するみたいですね。（メモ型らしいですけど） 直接的な解決策ではありませんが、ORDER BY句を指定するのはダメですか？ Sub test() Dim cn As ADODB.Connection'ここでNewするのはやめましょう。 Dim rs As ADODB.Recordset Set cn = New ADODB.Connection Set rs = New ADODB.Recordset Set cn = CurrentProject.Connection 'rs.CursorLocation = adUseClient 不要 rs.Open "SELECT * FROM Q1 ORDER BY 受付日 DESC ;", cn, adOpenStatic, adLockPessimistic For i = 1 To rs.RecordCount recordsetを取得してから並び替える必要があるならダメですが、そうでないなら ORDER BY句で対応された方がいいのではないでしょうか。 Q1（クエリ）に例えば受付日が昇順に設定されていても、ADOで開く時のORDER BY句が優先されます。
おっとぉ～！ ＞別のシートとかUserForm上からも動作ができる様にしたいの 一番簡単なのは標準モジュールのコードを↓のコードにしてみてください。 Sub Sample3() Dim lastRow As Long, cnt As Long, c As Range, myFlg As Boolean With Worksheets("Sheet1") '←この行を追加。「Sheet1」は操作したいSheetのSheet名に！ If .Range("H1") = "" Then .Range("H1") = "ダミー" End If For lastRow = 3 To .UsedRange.Rows.Count If .Cells(lastRow, "H").Borders(xlEdgeBottom).Weight = 4 Then myFlg = True Exit For End If Next lastRow If myFlg = True Then .Activate Range(.Cells(3, "H"), .Cells(lastRow, "I")).Select For Each c In Selection If c.Interior.ColorIndex <> xlNone Then cnt = cnt + 1 End If Next c MsgBox Format(cnt / Selection.Count, "0.00%") Else MsgBox "下線が太線のセルはありません" End If If .Range("H1") = "ダミー" Then .Range("H1").ClearContents End If End With '←この行を追加 End Sub 次にUserFormのコマンドボタンのコードを Call Sample3 の1行だけにすれば何とかご希望通りにならないでしょうか？m（_ _）m
ttp://download.microsoft.com/download/A/1/1/A11D789B-E29F-499B-BCC1-1D149B0B27BE/jpn_vs_2005_Pro_90_Trial.img これっぽい感じですが2.8Gあるようですし、 当方WiMax環境の為、未検証。 念のためウィルスチェックなどはかけてから利用されますように。 インストール時に評価版のキー入力が必要だったかは忘れました。 ご参考まで 参考URL：http://wp.me/p3hqmG-7nV
> Result = Application.WorksheetFunction.Average(.Range("D2:D&i")) i = 2のときは"D2:D2", i = 3のときは"D2:D3"……というようなことがしたいのでしょうか？ それなら 　Result = Application.WorksheetFunction.Average(.Range("D2:D" & i)) と書く必要があります。
b1 b2 b3 b4 b5 b6 b7 b8 というビット並びを3ビット右回転すると、 b6 b7 b8 b1 b2 b3 b4 b5 となるわけだから、 b6 b7 b8 0 0 0 0 0 と 0 0 0 b1 b2 b3 b4 b5 を加算すれば求められる。 上は下位3ビットを5ビット左にシフトしているし、下は上位5ビットを右に3ビットシフトしている。 5=8-3と考えれば、左の場合と同様な処理方法が見えてくるはず。
ご報告ありがとうございました。 >2時間かかる検索もあります。 MsgWaitForMultipleObjectsを出した意図はDoEventsだけのループだと負荷が高くなるからなのですが、 使われないなら、Sleep APIぐらいは挟んでおいた方がいいですよ。 >検索したい設計書にはExcel、Word、PDF等があり、 了解です。 >WindowObject 不必要にVariant型を使うと遅くなるので固有型の方がいいのでは。
こんばんは！ データ　→　「区切り位置」の方法でなく、 A列のシリアル値そのものを利用する方法です。 B列に日付・C列に時刻データを表示させるとします。 Sub Sample1() Dim lastRow As Long lastRow = Cells(Rows.Count, "A").End(xlUp).Row With Range(Cells(2, "B"), Cells(lastRow, "B")) .Formula = "=INT(A2)" .Value = .Value .NumberFormatLocal = "yyyy/m/d" End With With Range(Cells(2, "C"), Cells(lastRow, "C")) .Formula = "=MOD(A2,1)" .Value = .Value .NumberFormatLocal = "h:mm:ss" End With End Sub こんな感じではどうでしょうか？m（_ _）m
なるほど。No3 mt2008さんの回答がスマートですね。 1行目にも対応できるようにB1からオートフィルするとして =IF(AND(ROW()=1,A1<>"",A2=""),A1,IF(AND(A1<>"",A2=""),SUM(INDIRECT("A1:A"&ROW()))-SUM(INDIRECT("B1:B"&ROW()-1)),"")) て感じでしょうかね。
ThisWorkbook.DialogSheets.Add ThisWorkbook.DialogSheets.Item(1).Show ' "dialog1").Show ThisWorkbook.DialogSheets.Delete
Office ソリューションのエラーのトラブルシューティングに同様なトラブルの対処方法が記載されていましたのでご参考まで。 http://msdn.microsoft.com/ja-jp/library/h8c469ey … 上記サイトの抜粋 既存のブックに基づいて Excel ブック プロジェクトを作成するときに発生するエラー 既存のブックに基づいて Excel ブック プロジェクトを作成する場合は、次のエラーが一緒に表示される可能性があります。 Excel から: "プライバシーに関する注意: このドキュメントには、マクロ、ActiveX コントロール、XML 拡張パックの情報、または Web コンポーネントが含まれています。 これらにはドキュメント検査機能で削除することができない個人情報が含まれる場合があります。" Visual Studio から: "デザイナーが読み込みに失敗しました。" これらのエラーは、ドキュメント検査機能を使用して削除した個人情報を含むブックに基づいてプロジェクトを作成しようとすると発生することがあります。 このエラーを回避するには、プロジェクトを作成する前に、次の手順を実行します。 Excel でブックを開きます。 Excel で、セキュリティ センターを開きます。 [プライバシー オプション] タブで、[ファイルを保存するときにファイルのプロパティから個人情報を削除する] チェック ボックスをオフにします。 ブックを保存して、Excel を閉じます。 セキュリテーセンターはエクセルのオプション→セキュリティーセンターの設定で表示させるようです。
LoadPictureはgifやpngには対応していませんので、最近のWindowsなら標準で持っているGDI+という機能を用いています。なるべく元の形に添わせました。簡便さ優先で毎回GDI+のオブジェクトを生成しているので、重たいと思います。ご参考まで。 （訳の分からないものを使うのは嫌という場合は、他の回答者様の回答をお待ち下さい。）Windows7Home(64bit),xl2010で試しています。 Private Type GdiplusStartupInput GdiplusVersion As Long DebugEventCallback As Long SuppressBackgroundThread As Long SuppressExternalCodecs As Long End Type Private Declare Function GdipCreateBitmapFromFile Lib "Gdiplus" (FileName As Any, bitmap As Long) As Long Private Declare Function GdipDisposeImage Lib "Gdiplus" (ByVal Image As Long) As Long Private Declare Function GdipGetImageHeight Lib "Gdiplus" (ByVal Image As Long, Height As Long) As Long Private Declare Function GdipGetImageWidth Lib "Gdiplus" (ByVal Image As Long, Width As Long) As Long Private Declare Sub GdiplusShutdown Lib "Gdiplus" (ByVal token As Long) Private Declare Function GdiplusStartup Lib "Gdiplus" (token As Long, pInput As GdiplusStartupInput, pOutput As Any) As Long Function GetImageSize(ByVal f As File, ByRef x As Long, ByRef y As Long) As Boolean Dim udtInput As GdiplusStartupInput Dim lngToken As Long, lngStatus As Long Dim pSrcBmp As Long, pDstBmp As Long Dim lngWidth As Long, lngHeight As Long Dim srcPath As String srcPath = f.Path udtInput.GdiplusVersion = 1 If GdiplusStartup(lngToken, udtInput, ByVal 0&) <> 0 Then GetImageSize = False Exit Function End If If GdipCreateBitmapFromFile(ByVal StrPtr(srcPath), pSrcBmp) <> 0 Then GdiplusShutdown lngToken GetImageSize = False Exit Function End If GdipGetImageWidth pSrcBmp, lngWidth GdipGetImageHeight pSrcBmp, lngHeight x = lngWidth y = lngHeight GdipDisposeImage pSrcBmp GdiplusShutdown lngToken GetImageSize = True End Function Sub main() Dim FSO As New FileSystemObject Dim FLD As Folder Dim FLE As File Dim FF As File Dim x As Long Dim y As Long Dim myCnt As Long Set FLD = FSO.GetFolder(GetDesktopPath & "\picsizetest") For Each FF In FLD.Files If GetImageSize(FF, x, y) Then myCnt = myCnt + 1 Cells(myCnt, "A").Value = FF.Name Cells(myCnt, "B").Value = x Cells(myCnt, "C").Value = y End If Next FF End Sub 'パスの伏せ字をなくすためデスクトップ上のフォルダーとしています Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function
無いのであれば何とかするしか無いですね。 　vbaで問題とされているのは符号ビット付き変数なので、読んだ値が負の数であれば補正してやれば良いでしょう。 　入れ先の変数は unsigned short や unsigned long で溢れない Currency にすれば良いと思います。また、運用上、2GBを超えないとか制限できるならば long で構わないですよね。
ご参考までに。 VBSでの 16進文字列からバイト配列に変換 のコード例 参考URL：https://gist.github.com/beckorz/11206586
Typeステートメントは、ユーザー定義型変数を宣言する際に使います。 これが無くてもプログラムを組む上で何ら不都合はありませんが、知っておくと、より効率良く、洗練されたコードを書くのに役立ちます。 ある情報を扱うにあたって、その情報に関する属性がたくさんある時に、それらをひとつひとつ別の変数に格納していては、手間が掛かり、効率も悪いですよね。 そこで、大きな分類でひとくくりにして、複数の属性をまとめて面倒みてしまおうというのが、ユーザー定義型変数です。Ｃ言語では構造体とも呼ばれます。 例えば、ゲームプログラムでは、敵キャラの属性に関するデータがたくさん必要になる場合があります。名前やレベルやＸ座標やＹ座標…といった具合に。これらを、 EnCharaName EnCharaLv EnCharaX EnCharaY などの変数で個々に管理しても別に問題は無いのですが、より効率良いコーディングを考えるならば、EnCharaでひとくくりにしてしまい、一括管理するほうがスマートです。 Type Prm '宣言 Name As String Lv As Long X As Long Y As Long End Type '宣言の締め 'サブプロシージャ Dim EnChara(n) As Prm With EnChara(n) .Name = xxx .Lv = 1 .X =10 .Y =15 End With という感じにすれば、EnCharaに関する色々な属性を、Withでひとまとめに処理する事が出来、見通しの良いプログラムにすることができます。 小規模で、変数も少ないコードでは、あまり利用価値を実感出来ませんが、内容が大きく複雑になるにつれ、構造体の出番は増えると思います。
まず、VBには VB6以前とVB.net以降の大きく2つがあります。Excelで使われている VBAや、スクリプトで使われるVBScriptは、どちらかと言えばVB6系です。 Basicでは、 代入は「命令」です。 「 = 演算子による式」であるC言語とは異なります。 正式には Let 変数=値 という Let命令 が代入を行う命令で、 = だけなのは、Letを省略したものです。 VB6では、この他に「オブジェクト」というものがあり、オブジェクトと変数を関連付けるには Let ではなく Set 命令を使います。このSetは省略できません。メリットが無くても、Setを使うしかありません。 VB.net以降では、 オブジェクトの代入にSetを使わなくなりました。 SetはプロパティのSetterの宣言に使用されています。 With は、指定したオブジェクトの要素に簡単にアクセスするためのものです。 objA.fieldA = 0 objA.fieldB = 1 objA.fieldC = 2 と With objA .fieldA = 0 .fieldB = 1 .fieldC = 2 End With とは、ほぼ等価です。
以下の参照リンクから最新のパッケージマネージャを当てても治りませんか？ 参考； ｈｔｔｐ：／／stackoverflow.com/questions/12226530/unable-to-load-the-native-components-of-sql-server-compact-corresponding-to-the ｈｔｔｐ：／／ は小文字にしてください。 参考URL：http://www.microsoft.com/en-us/download/details. …
ＩＥの仕様が完全に変わっていますから http://msdn.microsoft.com/ja-jp/library/ie/dn384 …(v=vs.85).aspx ドキュメントの概念が変わりましたから、致命傷です 社内的なら　そのサイトに入って　ツールから互換設定すれば　1回設定するだけでとりあえず（Ver12　まで持つかは不明なれど）動くはずです。
No7の続き なお、(4)のところでは、二つの変数にリストボックスの 名前と選択された項目をシンクロさせながら格納して いますが、この場合、二つの変数ではなく、二次元配列、 ユーザ定義型などいろいろ方法はあります。あるいは 場合によってはテーブルにデータを書き込み、 レコードセットオブジェクトを利用してデータのやりとりを する場合もあります。 二つの変数には、 リストボックスの名前を取得することにより、テーブルの フィールドの名前を確定できるので、 　　Right(ctl.Name, Len(ctl.Name) - 3) というコードを使います。つまり、リストボックス(ctl)の名前(ctl.Name) の右から(Right)リストボックスの名前の長さから(Len(ctl.Name)　3文字 取り除いた(Len(ctl.Name) - 3)文字列がこれに該当します。 また、 　　ctl.Column(1, varItm) はリストボックスのコントロールソースにテーブルの 二つのフィールドを指定しているので、データとして 必要なフィールドが二番目にあるので、1を指定しています。 リストボックスの項目の並びのインデックスは0から 始まるので二番目は1ということになります。 コードの終わりあたりの、 　　　　If strFilter <> "" Then 　　　　　　strFilter = strFilter & " OR [" & varNa(j) & "] In (" & varSp(j) & ")" 　　　　Else 　　　　　　strFilter = strFilter & "[" & varNa(j) & "] In (" & varSp(j) & ")" 　　　　End If は、フィルタをかけるのに必要な、In句を作成するためのコードです。 たとえば、 　　　　[製品] In('A','C') OR [カテゴリ] In('2','5') のような、文字列の作成のためのコードです。If文で分岐があるのは変数strFilter が空の場合は、たとえば、上記の例でいうと、ORをくっつけないで、 　　　　[製品] In('A','C') を格納し、空でない場合は、半角の空白とORをくっつけて 　　　　 OR [カテゴリ] In('2','5') とし、 　　　　[製品] In('A','C') OR [カテゴリ] In('2','5') という文字列にしています。 　　　　 以上です。わからないところがあれば補足してください。
ObjIE.document.Forms(0).Submit を ObjIE.document.Forms(0).Click では試されました？
拡張メソッド http://www.atmarkit.co.jp/fdotnet/csharp30/cshar …
サンプルコードは公式の方法とは限らないので，まずはAPI Documentationを探す必要があります。 ・Google Drive Googleの開発者向けのポータルは https://developers.google.com/ になります。ここから， [Google Apps] - [Application APIs] - [Drive API] と進むことで，Google Driveの開発者向けページに行くことができます。 そして，選択肢が[iOS], [Web], [Android]ですが，今回は[Web]を選択します。 あとは，そこに情報がいろいろ載っています。 [Quickstart] - [.NET]には，ファイルのアップロード方法も載っています。 ・Yahooボックス 最近APIがリリースされています。 http://techblog.yahoo.co.jp/web/box/Box-release/ 上記ページからのリンクで，情報はだいたい揃うようです。 ・Dropbox Droopboxの開発者向けのページは https://www.dropbox.com/developers になります。ざっと読んだ感じだと， [Core API] - [Documentation] に，HTTP通信でのアップロード方法 (/files_put) が載っているため，これに沿って行えばアップロードできそうです。 ・OneDrive 例示されていませんでしたが……。 OneDriveの開発者向けのページは http://msdn.microsoft.com/onedrive/ で，MSDNでは http://msdn.microsoft.com/en-us/library/dn641952 … になります。 Windows Store Appsを作るのでなければ，[Reference] - [REST reference]の項を見ながら作ることになるかと思います。 ・iCloud 同じく例示されていませんでしたが，調査しました。 が，Apple Client以外からのアクセスのための方法を，公式に提示してはいないようでした。
vba csv 読み込み　でググると多量に事例が出てきますよ。項目数が一定でないcsvを読む時の基本は変数にInputで直読みせず、Variant型の可変配列で受け、Split関数で切り分けるやり方になります。 その一例 http://www.moug.net/tech/exvba/0060086.html
＃５です 回答付けようか迷ったのですが・・・ コードだけでも、文字数制限に引っ掛かる様で・・・ ここに回答を記述できないので、ブログの方に記事としてあげました。 自身のブログのURL/キーワードの提示は規約によりできませんので、探してみてください。 辿ってみたりいろいろと・・・・ 失礼しました
こんにちは！ 一例です。 表示したいセルに =INDEX(A1:A1000,MIN(IF(A1:A1000<>"",ROW(A1:A1000)))) これは配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　表示したいセルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 これを右方向にフィルハンドルで3列分コピーしてみてください。 ※　列にデータが全くない場合は「0」が表示されます。m（_ _）m
こんにちは！ 画像が小さくて詳細が判らないのですが、 Sheet1のE列には　平成24年度　のように文字列で12行ずつ年度が入力されているとし、 Sheet2のE2セルには　Sheet1のE列データが入るとして、 Sheet2のA3セルに =IF(COUNTIF(Sheet1!$E:$E,$E2),SUM(OFFSET(Sheet1!$A$1,MATCH($E2,Sheet1!$E:$E,0)-1,COLUMN(A1),12)),"") という数式を入れフィルハンドルで右へ3列分コピーではどうでしょうか？m（_ _）m
回答１は取り消していないです。 > WebBrowser　から　WebClient　へ認証が引き渡せるのか？ WebBrowserが、Cookie認証チケットを受け取っているので WebClientに渡す必要があります。
こんにちは！ No.1さんの方法が間違いがなくて良いと思います。 どうしても質問通りのようなコトをやりたい場合は、VBAでもできますが、 「置換」操作が一番簡単だと思います。 仮にA列に数式が入っている場合 A列すべてを範囲指定　→　ctrl＋Hキー　→　「検索する文字列」に　A　と入力　→　「置換後の文字列」に　B　と入力　→　「すべて置換」 これで完了です。 ※　注意点　※　 万一数式内に =AB○のようにAが含まれる数式がある場合、すべて置換されてしまいます。m（_ _）m
http://support.microsoft.com/kb/982995/ja http://news.mynavi.jp/column/windows/141/
> data(i).class1-.class2-.class3の順でソートを行いたい の意味が不明確ですが、class1のほうが重要視される、という意味だとすると 簡単には、Class1が上位の桁、Class2が中位の桁、Class3が下位の桁、を表していると考えることです。 なので、大小比較の部分を if data(i).class1>data(j).class1 then → data(i)はdata(j)より大きい else if data(i).class1<data(j).class1 then → data(i)はdata(j)より小さい else if data(i).class1=data(j).class1 then　（実際はif以降は必要ない） 　→ data(i)とdata(j)のclass1は同じ大きさなので、 　　　class2をこれまでと同様にして大小比較する 　　　　　もし、class2も同じなら、class3を比較する end if と置き換えればよいです。
・Visual Studio 2013 が Professional 以上の場合 Support Pack 9 (v. 13.0.9.1312) をダウンロードして実行する。 ・Visual Studio 2013 が Express の場合 無い。 あと、 > Visual Studio 2013ですが、 > Crystal Reportsが利用できるダウングレード版が > 先日はSAPよりリリースされたようです。 というのは誤解を招く記述です。 SAP がリリースしているのは Crystal Reports 入りの Visual Studio ではなく、Visual Studio で Crystal Reports のコンポーネントを利用可能にする機能を追加するアドオン（およびランタイムのインストーラー）です。Visual Studio 自体は別に入手する必要があります。
パスの結合には，文字列を連結するのではなく，System.IO.PathクラスのCombineメソッドを利用します。 ※参考URLには.NET 4のMSDNのURLを記述しています。最新版である.NET 4.5のMSDNは解説部分が訳されていないので。 参考URL：http://msdn.microsoft.com/ja-jp/library/fyy7a5kt(v=vs.100).aspx
こんばんは！ ＞F1のセルが2014/5/6なので・・・ 「こどもの日」は5月5日でお示しの配列だとE列になり、F列は振替休日だと思います。 それはさておいて、↓の画像のようなデータをSheet2に作成しておくとします。 Sheet1の1行目にシリアル値が入っているとしてのコードです。 標準モジュールです。 Sub Sample1() Dim i As Long, j As Long, lastRow As Long, lastCol As Long Dim str As String, c As Range, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") lastRow = .UsedRange.Rows.Count lastCol = .UsedRange.Columns.Count If lastRow > 1 Then Range(.Cells(2, 1), .Cells(lastRow, lastCol)).ClearContents End If For j = 1 To lastCol Set c = wS.Cells.Find(what:=.Cells(1, j), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then str = wS.Cells(c.Row, "A") For i = 1 To Len(str) With .Cells(2 * i + 1, j) .Value = Mid(str, i, 1) .HorizontalAlignment = xlCenter End With Next i End If Next j End With End Sub ※　関数でないのでSheet1のデータ変更があるたびにマクロを実行する必要があります。m(_ _)m
できるかどうかわかりませんが、 if　Worksheets("Sheet1").Range("A1").ShrinkToFit = True　then 　Msgbox　"ShrinkToFitはTrueだよ！" Else 　Msgbox　"ShrinkToFitはFalseだよ！" End　if とかですかね…？
見出し設定にしているのだったら、 Wordで目次を作ってコピーしていったほうが早いのでは？ http://www.eurus.dti.ne.jp/~yoneyama/Word/ouyou/ … http://hamachan.info/win7/word/mokuji1.html とりあえず、WordとExcelのバージョンが欲しいですね。
これでしょうか。 http://nienie.com/~masapico/doc_FuncPtr.html
コンボボックスで名前の選択ができて、テキストボックスに名前が抽出できているのでしたら、、 コンボボックスのプロパティーで「すべて」タグ　の列数　を２にして　名前と住所が表示できるようにしておきます。 そして　おなじくプロパティーの 「データ」タブの連結列を　２にすると、２列目の　住所がテキストボックスに表示されます。 「データ：タブの連結列を　１にすると　1列目の　名前が表示されます。
DataGridViewが異なるだけで、同じ処理を行うなら 下記のように、処理対象のDataGridViewを表す変数を宣言して その変数に対して処理を行えば、異なるDataGridViewのイベントを共通化出来ます。 Dim dgv As DataGridView = CType(sender, DataGridView)
http://www.gan.st/gan/blog/index.php?itemid=3860
新人研修の課題か何かですか？即ち、本カテゴリであるVB(VBA)を使うことが主目的ですか？ そうではなく実運用を考えているのなら、まずは作成方針を明確にすることの方が重要と思います。 　・グループウェアの備品管理機能を活用しないのはなぜか 　・管理者はどう考えているのか？ どのくらいの締め付けレベル(申請/上長検認/管理部門承認等)にする？ 　・どのくらいの管理工数を見込んでいるのか？ 　・今までの管理方法はどうしてたのか？ 　・利用者の方々に今までの管理方法の不満、改善要望とかを聴いて回る #備品棚に貸し出しノートを置いておけば十分では無いのでしょうか。電源が無くても不自由しませんし…
前半に、元データ = Range("D1:D3087")という記述があり、後半に、文字数 = Len(元データ)とあります。これを翻訳すると、D1～D3087の"範囲"の"文字数を"数えよ、というおかしな命令になります。これが、「型が合わない」というエラーになる原因です。 Lenを使う理由がよく解りませんが、Lenは、1個の文字列データが「何文字か」という事を数える関数で、「何個あるか」を数えるものではありません。 ですから、Len(たくさんのデータ)としても、Len(データの入ってる範囲)としてもエラーになります。 さて、具体的な解決策ですが、今回のように、セルD1～D3087という決まった範囲を参照する場合には、それをひとかたまりの「オブジェクト」として管理するのが定番です。 そして、そのオブジェクトからひとつずつデータを拾い上げて、加工なりなんなりするには、For Eachを使います。 取り出す１個１個のデータを、「個々のデータ(n)」と名付けるとすると、 Dim 元データ As Range Dim 個々のデータ(3087) As String Dim 番号 As Long Set 元データ = [D1:D3087] For Each i In 元データ 番号 = 番号 + 1 個々のデータ(番号) = i.value 'データの加工処理 Next i という感じのコードになります。
この方法が最善とは思いません 一例として ＞クローズ時に、ほぼフリーズします。 フリーズとはPCが固まるフリーズではなくて アプリがエラー出してすっ飛ぶんですよね（多分） それとも飛びもせずプロセス残ったまま反応しなくなるのでしょうか？ 以下は すっ飛んでるんだろうと仮定して書いています メイン（ボタン）処理で ・クローズ前に スレッドに対して終了要求フラグを立てる ・スレッドが終了するまで待つ（フラグでもシグナルでも確認はいくつか考えられます） ・ポートクローズ処理を行う ・スレッドでは終了フラグを監視して動作（現状多分ポーリングループしてるんでしょう） 　するように変更する ・スレッド終了フラグを立てる といった形でいいのでは？ もしくは実質のオープン・クロース処理自体をスレッド内に記載してもいいかと メイン側処理とスレッド側処理で同期取れればどんな形でもいいかと思います 同期が取れてないからタイミングによってクローズ後にデータ読みに行って アプリがすっ飛ぶということではないかと思います テキストボックスの更新自体が問題の本質ではないと思いますよ (データ読みに行って更新されるからこそ表示してるんでは？）
＞1.1で開発された対応プログラムは、やはり1.1が無いと ＞基本windows7では動かないのでしょうか。 Win7では本来 .Net1.1 自体がサポートされていませんので それらのインストールや動作確認は自己責任で行ってくださいということになります 参考に http://www.atmarkit.co.jp/fdotnet/dotnettips/934 …
フォルダ中にあるエクセルファイルの一覧を取得する。 エクセルファイルを開く。 売上シート内の各セルを読み取る。 明細表に書き込む。 以上のどこがわからないのか明確にしたほうがアドバイスを受けやすいのでは？
Bの幅については…RowHeadersWidthプロパティですかね。 http://msdn.microsoft.com/ja-jp/library/system.w … RowHeadersWidthSizeModeプロパティなどにも影響されるかも知れません。 http://msdn.microsoft.com/ja-jp/library/system.w … 境界線の幅も関係しますかねぇ。 スクロールバーの幅については VerticalScrollBarプロパティでScrollBarクラスのインスタンスを取得して、 Widthプロパティで取れませんかね？ きっちり納めたい。 というのも判らなくはありませんが…多少の余白は残しておいたほうがよくないですかね？ 列の幅を変更できないようにしているならいいかもしれませんけど。
No.1の回答者です。 No.2の回答でスキルがないので分からないと書きましたが、スキル向上 のために調べてみるとWordマクロでもLeft関数が使えるようですね。 これを利用して、先頭の文字列が2文字以上でも検索できるものを用意しました。 Sub test6_DeleteParagraph() ' test5_の改良版 Dim para As Paragraph Dim Npara As Variant Dim LeftString As String For Each para In ActiveDocument.Paragraphs ' 指定文字があったら段落として選択 　With para 　' 左から2文字目までの文字列を指定 　LeftString = Left(para, 2) 　　If LeftString = "|v" Then 　　　.Range.Select 　　　Npara = para ' 選択範囲を次の段落まで拡張 　　　With Npara 　　　　.Expand Unit:=wdParagraph 　　　　.MoveEnd Unit:=wdParagraph, Count:=1 　　　　.Delete 　　　End With 　　End If 　End With Next End Sub マクロの中の　LeftString = Left(para, 2)　で段落内の左から2文字 を取得して、指定文字列と取得した文字列が一致した段落と次の段落を 削除するようにしたものです。 たぶん、この回答で希望していることができると思います。 この質問に回答することで、少しですがスキルが向上したので、私個人として 勉強になりました。
> 1日1回ならタスクスケジューラでもOKかもしれませんが、8時間だったり、別のプログラムでは12時間毎だったりと、 > 指定の時間に作業をするのに便利だったもので、Application.OnTime　はけっこう使ってしまいました。 > > 何か代替方法があるといいのですが… 代替方法も何も、そのものずばり一定時間おきに繰り返す設定もできるのですが。 http://www.atmarkit.co.jp/fwin2k/win2ktips/1332r …
それぞれの最後、つまりExecuteNonQuery()の発行後、Dispose()すれば問題ありません。 が、どうせ同じインスタンスを利用するならば、2回目以降はCommandTextプロパティに設定されている クエリを変更して発行、その後Dispose()でも良いでしょう。 また、移行ということで、元々問題ないのでしょうが、問題があるようならば プリペアドステートメントによる発行を推奨します。(SQLインジェクション対策) Accessはクエリキャッシュ機構はないでしょうから、パフォーマンスは変わらないでしょうけど。 http://msdn.microsoft.com/ja-jp/library/vstudio/ …(v=vs.100).aspx
VBAのメモリ解放は『ガベージコレクション』任せなので、メモリリークの心配はナイです。 基本的に、Nothingの代入は必要ありませんよ。 ・ガベージコレクション＠wikipedia http://ja.wikipedia.org/wiki/%E3%82%AC%E3%83%99% … ・VBのオブジェクト解放＠MSDN http://msdn.microsoft.com/ja-jp/library/cc440884 … C言語とかやるなら、"とにかく解放する"癖つけとくのも良いですが。
下記サイトを参考にして、以下の点を修正すれば動きます。 3. Dim MyFSO As New FileSystemObject 　→　VBAでこの書き方は多分NGだと思います。下記を参考にしてみてください。 　　　http://officetanaka.net/excel/vba/filesystemobje … 11. Folderpath = ThisWorkbook & "\Cells(i, 1).value" 　→ThisWorkbookだけだと、何も取れないと思います。ここはThisWorkbook.Pathでは？ 　→"\Cells(i, 1).value"　""の中は文字列の扱いなので、これだとファイル名がCells(i, 1).valueに 　　なってしまいます。 　　文字列として付加したいのは「\」なので、 　　"\" & Cells(i, 1).Value 　　こういう形になるはず。 13. MyFSO.CreateFolder Path:=Folderpath 　→　これも、下記を参考にしてみてください。 　　　http://officetanaka.net/excel/vba/filesystemobje … ご自分で勉強されようとしているようなので、あえて完成形のコードは掲載しないでおきます。
http://detail.chiebukuro.yahoo.co.jp/qa/question … 上記リンクが参考になるのかな？と思います。
　ごめんなさい。 　内容が詳しく分からなかったので、なんとなく回答してみます。 　とりあえずMIDの使い方ですが、 　MID("文字列", 開始位置, 文字数) と指定します。 　たとえばA1セルの文字列が　"あいうえお"　だった場合 　dim str as string 　str = MID(Range("A1"), 2, 3) 　とすると、str には文字列　"いうえ" が返ります。 　ですが、もし 　　＞セルBB2に　=IF(AW2="",VLOOKUP(LEFT(N2,2),商品マスタ!$M$21:$N$67,2,0)) これでうまくいっているのであれば、 　dim LastRow as long 　LastRow = Cells(rows.count, 49).end(xlup).row '49=AW列　それの最終行を取得 　Range("BB2").Select 　Range("BB2:BB" & LastRow).FormulaR1C1 = _ 　　"=IF(RC[-5]="",VLOOKUP(LEFT(RC[-40],2),商品マスタ!$M$21:$N$67,2,0)) としてみるのはどうでしょう？ 　検証してないので、うまくいくかは分かりません・・・ 　解説 　前述の通り検証してないのでもしかしたら文法が間違えているところがあるかもしれませんが・・・ 　VBAでエクセルの関数を使うためには、(1)　WorkseetFanction 　数式を使うためには、(2)　formula を使います。 　この場合、変数に値を格納して云々というなら(1)を使うのでしょうが、 VLOOKUPを数式として扱うので、(2)でやってます。 （かなり大雑把な説明なので、細かく言うと違いますが・・・） 　次に、R1C1　とは、相対参照です。 　R　は行。　C　は列。 　選択しているセルから、どの方向にどれだけ離れているか、 と考えると分かりやすいかと思います。 　"BB２"から、行数(2)は変わらず、列数だけが変わっているので、 "AW"列は、"BB"列より　-5 "N"列は"BB"列より -40　です。 　そして最終行は、”AW"(=49列目)を参考に取得しています。 　あとは、もともとあったIF～VLOOKUP文を、BB列にAW列の最終行まで記述しています。 　うまく動かなかったらゴメンナサイ。
>>EXPRESSは複数台で利用することはできないのでしょうか？ もちろん、複数台から利用できます。 データベースを使ったプログラミングは、なかなか難しい面があります。 私は、マイクロソフト公式解説書の「プログラミングMicrosoft ADO.NET」を読んで、やっとプログラミングができました。 書店で、データベースを解説した書籍やネットの解説を読まれて勉強されればいいと思います。
stsbarLabel1.Text="処理中" と書いたからといって直ちに表示される訳では ありません。 同様の現象がよく見られるのがループ中に ループカウント 等を表示した場合です。 従って、stsbarLabel1.Text="処理中" と書いた直後の行で stsStrip1.Refresh() 　　　又は、 Application.DoEvents() を実行して、強制的に書き換えて見て下さい。 但し、ループ中 に強制的に書き換え処理を頻繁に行うと画面がちらつく事に なり別の対策が必要になります。 因みに、VB.net（Visual Studio Express）を使用しています。 では通じません。 Visual Basic のバージョンを明記するなら正確に書いて下さい。 VBのバージョン・製品名の一覧 http://hanatyan.sakura.ne.jp/patio/read.cgi?mode …
Windows7 & Excel2010 と WindowsXP & Excel2002 の両方で再現しました。 クリップボードを出してみました。 内容自体は同じように見えますが、アイコンは変わっています。 データの持ち方の何かが違うらしいことしか分かりませんでした。 セルに abc<table border=1><tr><td>A</td><td>B</td></tr><tr><td>C</td><td>D</td></tr></table> と入力出来た後で、 そのセルをコピペしてもテキストエディタからのコピペとは異なり、 表にはなりませんね。 abc<*table 後略 とすると文字列として貼り付けできましたが 謎の残るExcelのお節介機能？です。
　簡単なところから回答いたします。 > なぜか送信受信ともに，まったくおなじメールが2通作成されてしまいます。 　これは、 oMsg.Configuration.Fields.Update oMsg.Send がダブっているからです。 　参考にされた サイト にも２回は書いてありません。 　コーディング をされる際に、誤ってコピペでもされたのでしょうが、メール送信スクリプト などを書かれるときには、細心の注意が必要です。 ●CDO.Messageによるメール送信 http://serialty.blog117.fc2.com/blog-entry-10.html のように、[With ステートメント] を使ったり、長い文字列を strConfigurationField ="http://schemas.microsoft.com/cdo/configuration/" というように、定数に代入したりして、コード の可読性を高める工夫をされることをお薦めします。 -------------------------------------------------- >「最新のファイルを添付して送信」することはできないでしょうか？ 　お示しの コード で添付ファイルを決定しているのは、 　　For Each F In Fl.Files 　　　　If F.Name > NewFile Then 　　　　　　NewFile = F.Name 　　　　End If 　　Next の部分ですが、これは、strPath フォルダ 内の ファイルを、名前順に巡回（For ～ Next ループ）して、最後の ファイル を NewFile に代入しています。 　従いまして、NewFile に代入されるのは、「前から置いてある別のファイル」ではなくて、名前の昇順に並べた場合の最後の ファイル ということになります。 　「最新のファイル」を特定するためには、strPath フォルダ 内の ファイル の更新日時や作成日時を検証して、最も新しいものを NewFile に代入するということになりますが、手っ取り早いのは、 oMsg.Send した後で、添付ファイル を別の フォルダ（例えば「送信フォルダ」の下に「送信済み」フォルダ でも作っておいて、そこ）に移動するのが良いかと存じます。 -------------------------------------------------- > どこを直せばいいでしょうか？ 　私は hotmail 環境がありませんので、試しようがありませんが、ＷＥＢ でいろいろと検索してみますと、 ・CreateObject("CDO.Message") は万能ではない。 ・スパム防止策で Microsoft ができないようにしている。 というような意見が見受けられます。 　一方、 ●[Template] Send SMTP email with Visual Basic Script (vbs) from Command Prompt using CDO（[テンプレート] CDOを使用して、コマンドプロンプトからVisual Basicスクリプト（VBS）でSMTP電子メールを送信） http://www.unix.com/windows-dos-issues-discussio … には、live.com からでも メール が送れる スクリプト というような感じで書かれていますので、こちらをご参考になさってみてください。 　ただし、ウィキペディア（http://ja.wikipedia.org/wiki/Hotmail）には、 > Hotmail（ホットメール）は、MSNが提供していた(過去形)Webメールサービスである。 と書かれており、Microsoft としても仕様の変更を頻繁に行なっているようですので、何とも申せませんねぇ。。。
いろいろというほどは方法は無く限られるような気がします。 以下を参考にして見て下さい。 http://gallery.technet.microsoft.com/scriptcente … 上記スクリプトでは、NameでANDを取っていますがこれを無くせば全てのOUとなります。 要は、objectCategoryがorganizationalUnitなオブジェクトを全て取得するということですね。 参考までにPower Shellのケースを記載しておきます。 DCのOSが何かわかりませんが、Power Shellが使えるのならこちらのほうが何かと簡単だと思います。 OU一覧取得なら一行で済みます。 Get-ADOrganizationalUnit -Filter * 一覧をDNだけにしたいならこんな感じ。 Get-ADOrganizationalUnit -Filter * | Format-List -Property DistinguishedName
プロシージャを抜けると作成されたキャレットが破棄されるように仕様が変更されたようで RichTextBox1_Enter イベントで作成するとすぐにRichTextBox1_GotFocus イベントが発生し その時点で破棄されるので、一瞬しか確認できないのです。 どうしてもなら、RichTextBox1_GotFocus イベントで作成すると次のイベントが発生するまでは 破棄されませんので表示されるようになります。 但しキー入力やマウスダウンイベントが発生すると破棄されるので、キーアップイベントと マウスアップイベントにも書いておく必要があります。 (ダウン イベント書くと直後にアップ イベントが発生するのですぐに破棄される事になり表示されません) テキストボックスとRichTextBox とその辺の仕様が違う理由については、よく知りません(調べていない)
No1です。 おそらく勘違いをなさっていると思いますが、 「空きメモリー」＝「電気だけ食って何の役にも立っていないメモリー」 です。 OSしか動いていない状態だと空きはかなりあるでしょうけど、プログラムがそれなりに動いている状態だと、高速化のためには空きメモリーゼロが理想的。とはいえ全くゼロだと急なメモリ使用変動に追いつけないので、空きは要りますが、数百MB空いていれば十分です。 アプリケーションプログラムが使っていないメモリーは余らせておくのは無駄なので、WindowsOSが、キャッシュやバッファに有効利用します。 普通は、必要なメモリサイズ ＞ 物理メモリサイズ なので、足りない分をディスクを使って何とかします。とはいえ、足りなすぎるとメモリアクセスがディスクアクセスばかりになり大変遅くなる。 No1に書いたように、Windows7でOfficeをがんがん使うには4GBはやや不足です。 Excelのコミットサイズはどれだけですか？？？
UIロケールの言語 (=表示言語) に合わせてメッセージが変わるはずですが……。 強制的に行うなら，Mainメソッドの先頭に Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo("en"); とか Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo("en-US"); とか書くと，例外のエラーメッセージも英語化されます。
ぎゃっはっはぁ～～！ なかなか解決しませんね。 ＞イメージとしてシート2以降の表示は、 ＞元データA列→新シートA列（1行目のタイトルも表示） ＞元データI列→新シートB列（〃） ＞元データL列→新シートC列（〃） ＞元データS列→新シートD列（〃） ＞元データV列→新シートE列（〃） 結局元データSheetのA・I・L・S・V列のデータだけを 新規SheetのA～E列に項目行も含めて表示させればよい訳ですよね？ コピー元の範囲と貼り付け先のセル番地だけの問題だと思います。 Sub Sample4() Dim k As Long, lastRow As Long, wS As Worksheet, wS2 As Worksheet Application.DisplayAlerts = False If Worksheets.Count > 1 Then For k = Worksheets.Count To 2 Step -1 Worksheets(k).Delete Next k End If With Worksheets(1) lastRow = .Cells(Rows.Count, "A").End(xlUp).Row .Range("A:A").Insert With Range(.Cells(2, "A"), .Cells(lastRow, "A")) .Formula = "=M2&T2" .Value = .Value End With Worksheets.Add after:=Worksheets(1) Set wS2 = Worksheets(Worksheets.Count) Range(.Cells(1, "A"), .Cells(lastRow, "A")).AdvancedFilter Action:=xlFilterInPlace, unique:=True .Range("A:A").Copy wS2.Range("A1") .ShowAllData For k = 2 To wS2.Cells(Rows.Count, "A").End(xlUp).Row .Range("A:A").AutoFilter field:=1, Criteria1:=wS2.Cells(k, "A") Worksheets.Add after:=Worksheets(Worksheets.Count) Set wS = Worksheets(Worksheets.Count) '↓★ココから変更 .Cells(1, "B").Resize(lastRow).SpecialCells(xlCellTypeVisible).Copy wS.Range("A1") .Cells(1, "J").Resize(lastRow).SpecialCells(xlCellTypeVisible).Copy wS.Range("B1") .Cells(1, "M").Resize(lastRow).SpecialCells(xlCellTypeVisible).Copy wS.Range("C1") .Cells(1, "T").Resize(lastRow).SpecialCells(xlCellTypeVisible).Copy wS.Range("D1") .Cells(1, "W").Resize(lastRow).SpecialCells(xlCellTypeVisible).Copy wS.Range("E1") '↑★ココまで wS.Name = wS2.Cells(k, "A") wS.Columns.AutoFit Next k .AutoFilterMode = False .Range("A:A").Delete wS2.Delete End With Application.DisplayAlerts = True End Sub これで何とかご希望通りになるでしょうか？m(_ _)m
>ListCountを用いて、その都度行数を取得し、行の最後に追加していく・・・ その都度列数(ColumnCount)が変わることは検証していません >Union(.Cells(2, 2), .Range(.Cells(2, 4), .Cells(2, 6))) 同じ行リストが追加されるのでは Dim rngTemp1 As Range, c As Range, v As Variant Dim i As Long, j As Long, k As Long, n As Long With Sheets("Sheet1") 　　.Activate 　　Set rngTemp1 = Union(.Cells(2, 2), .Range(.Cells(2, 4), .Cells(2, 6))) End With n = rngTemp1.Count With Me.ListBox1 　　.ColumnCount = n 　　ReDim v(.ListCount, 1 To n) 　　For i = 0 To .ListCount - 1 　　　　For j = 1 To .ColumnCount 　　　　　　v(i, j) = .List(i, j - 1) 　　　　Next 　　Next 　　For Each c In rngTemp1 　　　　k = k + 1 　　　　v(.ListCount, k) = c.Value 　　Next 　　.List = v End With
>フォーム選択で、ブックのアクティブ状態が切り替わらないように ユーザーフォームをモードレスで表示では UserForm1.Show (vbModeless)
log(AA) / log(10)
こんにちは！ 一例です。 コマンドボタンのオブジェクト名は実際のオブジェクト名にしてください。 シートモジュールで Private Sub CommandButton1_Click() Range("B5").Resize(, 4).Interior.Color = xlNone Range("C5").Interior.Color = vbBlue End Sub Private Sub CommandButton2_Click() Range("B5").Resize(, 4).Interior.Color = xlNone Range("D5").Interior.Color = vbGreen End Sub Private Sub CommandButton3_Click() Range("B5").Resize(, 4).Interior.Color = xlNone Range("E5").Interior.Color = vbYellow End Sub Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$A$2" Then If IsDate(Target) Then Range("B5").Resize(, 4).Interior.Color = xlNone Range("B5").Interior.Color = vbRed End If End If End Sub ではどうでしょうか？ ＞どこの作業まで実施したのかわかるようにしたいのですが・・・ とありますので、 もしかしてすでに色がついているセルの色はそのまま残しておきたい場合は 各コマンドボタンのコード内の ＞Range("B5").Resize(, 4).Interior.Color = xlNone の1行を削除してください。m（_ _）m
こんにちは。 Windowsのバージョンが異なるようなので、その分、確度の低い話になってしまいますが、 エラーは再現できました。原因については下記■■マークの辺りを読んで下さい。 ご提示のコードを修正することで期待通りに動くことは確かめましたので、 以下で、確認、修正、するべきポイントを挙げておきます。 //////////// CC = ThisWorkbook.Name CC = Left(CC, Len(CC) - 4) ブック名.xls　ならば、CCは "ブック名"　ですが、 ブック名.xlsx　ならば、CCは "ブック名."　（ドットが余計）になってしまいます。 Set BBB = AAA.CreateShortcut(DD & "\" & CC & ".lnk") ここ↑の引数が、DD & "\ブック名..lnk")のように"."ドットが重なっていないか、 確認してください。 確実に"ブック名"だけを採るなら CC = Left(CC, InStrRev(CC, ".") - 1) '★一番右にある"."のひとつ前までの文字列 のように書きます。 //////////// AA = ThisWorkbook.Path .... DD = Left(AA, 2) & "Documents and Settings\All Users\スタート メニュー\プログラム\スタートアップ" AAの中身は、"C:\....."とか"D:\....."等のドライブ名で始まっているフォルダパスです。 ThisWorkbookが保存されたドライブとスタートアップフォルダのドライブが同じだという前提 が有効だとすれば、ですが、Left(AA, 2)では、"\"が抜けてしまいますね。■■ たぶんこれがエラーの原因と思われます。 DD = Left(AA, 3) & "Documents ..... とか、 DD = Left(AA, 2) & "\Documents ..... なのでは？ スタートアップフォルダのドライブが勝手に変わることはないですし、 逆にThisWorkbookがどのドライブ配下にあるかは簡単に変えることが出来てしまいます。 なので、ここは、 DD = "C:\Documents and Settings\All Users\スタート メニュー\プログラム\スタートアップ" などのようにドライブ名を含めて決め打ちした方が安全なのではないかと思いますが、如何でしょう。 //////////// 念の為、スタートアップ"フォルダのパスが、実際にお使いの環境に存在しているか、 エクスプローラ等で確認しておいた方がいいかも、です。 因みに、当方の環境では、 DD = "C:\Users\ユーザー名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup" を指定することで、上述の修正と合わせれば、 正しくショートカットが設定できることと、 PC起動時にExcelアプリケーションとThisWorkbookが立ち上がること、 を確認しました。
＃２-３、ｃｊです。 ＃２お礼欄拝見しました。 まず、お詫びです。 ＃２-３に書いた内容は、私の勝手な読み違え（勘違い→思い込み）で、 ウィンドウの分割を適用した場合のことを書いていました。 新しいウィンドウを開いた場合のことで言えば、 確かに、ひとつのコマンドボタンについて、その動作は、ひとつのウィンドウに限られます。 また、前提が違っていたせいで、 非アクティブなウィンドウ上のコントロールを一度のクリックで操作できる ようにしたいという要望であると、二重に勘違いしていました。 すみませんでした。m(__)m 従って、＃２お礼欄でご提示の疑問点については、 すべて前提を間違えた私の問題であって、 > こちらの操作上のミスなどが有りましたら そちらで確認されていることはに、誤りはありません。重ねて申し訳ないです。 "[TakeFocusOnClick]の値をTrueからFalseに設定変更"し場合についてですが、 フォーカスを持つかどうかの違いから派生して、 フォーカスを持っている時＝押した後、 「見た目の変更」としては、コマンドボタンのテキストフレームに四角い枠が破線で表示され、フォーカスを持っていることを示唆します。 また、この場合（次の操作でコマンドボタン以外を選択するまで） Excelのツールバー等のメニューの多くが（グレイアウトして）無効になってしまいます。 > 実際の操作の場合、フォーカスが動いてから操作できれば十分だと思っています。 > しかし現状では、activeXコントロールのボタンの場合、全く動きません。どうしたらいいのでしょうか。 あらためてお応えしますが、これは仕様上の動作でして、 ユーザーの通常の操作や設定によって、お望み通りに出来るようなものではないです。 このまま無責任に終ってしまうのも悲しいので、と、 何か方法は無いかとずっと格闘しているのですが、色々試してはみたものの、 十分な形のものを提示するのは未だ、難しいです。 コマンドボタンを複製したものを元のコマンドボタンに重なる位置に配置して、 ウィンドウ毎に有効なコマンドボタンを切り替える、というアイディアで、 ２つのウィンドウ、ひとつのシート、（元々）ひとつコマンドボタン、 で実現する（２つのウィンドウでコマンドボタンを機能させる）処までは概ね出来ました。 ２つのコマンドボタンを見かけ上ひとつのコマンドボタンとして、 それぞれに対応したウィンドウで操作出来るようにする、というものです。 特別な処理をする訳でもないのですが、汎用性を持たせることに躓いています。 「２つのウィンドウ、ひとつのシート、（元々）ひとつコマンドボタン」 というような限定的な条件なら、実用出来そうな見込みでいます。 コマンドボタン切り替えの部分のプロットは、こんな感じです。 Private Sub Workbook_WindowActivate(ByVal Wn As Window) If モジュール変数キャンセルフラグ Then Exit Sub With Wn.ActiveSheet Select Case .Name Case "Sheet1" Select Case Wn.WindowNumber Case 1 .OLEObjects("CommandButton1").SendToBack Case 2 .OLEObjects("CommandButton2").SendToBack End Select End Select End With End Sub 後は、Workbook_Openイベントで、 コマンドボタンの有効ウィンドウを設定する （Window:1で"CommandButton2"を有効に、Window:2で"CommandButton1"を有効に、） 処理との組み合わせ、調整です。 今の処、後々のメンテナンスを見通して開発できるレベルではないですし、 決してスマートな方法でもなく、まだどうなるか解りませんけれど、 もう暫く闘ってみようかと個人的に思っています。 スレッドを締切るのでしたら、それはそれで、私としては構いません。 またご迷惑を掛ける結果に終るかも知れませんから、 質問者さんの思いのままにお任せします。 そこまでしてActiveXコントロールを使う必要はない、という判断もあると思いますし、 その方が普通だとも思います。 とりあえず、以上です。 お騒がせしてしまって本当にすみませんでした。p
C言語のように条件コンパイルというのがあります。 #If AA Private Sub Workbook_Open() プログラム本体 End Sub #End If このように記述し、VBAProjectのプロパティで、 「条件付きコンパイル引数」の所でAA=1とすれば プロシージャはコンパイルされ、AA=0とすれば プロシージャはコンパイルされず、存在しない ものとして扱われます。
試したわけではありませんが http://msdn.microsoft.com/ja-jp/library/ff196047 … セルに値代入後かな？に （コードを端折られているので特定できません。） そちらでお考えになってください。 do while Application.CalculationState <> xlDone sleep 200 loop で待機 http://msdn.microsoft.com/ja-jp/library/ff821508(v=office.15).aspx を余計なイベントが発生しないように適当なところに挟み込む （必要があるかどうかは、そちらで確認してください） あと、位取りに「．」を使うのは止めてください。 21,000 余計なところで思考がストップしてしまいました (^_^;) 日本語環境でないPCでしたらご容赦。
なーんか変ですね。 バージョンが微妙に異なりますが 当方（WinXP & Excel2002 とWin7 & Excel2010）ではエラーになりませんでした。 変数宣言の４行は修正するとしても解決には至らないような気がします。 社PCで互換パックを使用して、xlsm 形式を開いているとか。 http://support.microsoft.com/kb/923505/ja 自PC・社PCで、デバッグ→コンパイルが通るかどうか。 ツール → 参照設定 で参照不可になっているものがないか。 を調べてみては？ 以上でも解決しないとなると、 社PCで新規XLSファイルにシートをコピペ、コードもコピペで 何とかなるかも？
下記のように表示されればいいのですよね？ 　http://www.hanatyan.sakura.ne.jp/charttest1.gif どのように設定されてどのようにうまくいかなかったのでしょうか？ Formatプロパティを使ったのなら、基本的な使い方をしましたか？ (時間で表示したいなら、データやFormat は日付型にしているのか) 参考URL：http://www.hanatyan.sakura.ne.jp/vb2005/vb2013ch …
＃３、お礼欄へのレスです。 > 追記いただいたコードを実行してみたところ、終了しては「マクロを有効にしますか？」の画面が表示される・・・という繰り返しになってしまいました。 Excel 2000、2003、2010、と３つの環境で、セキュリティレベルを変えながら動作確認していますが、 ご指摘のような状況は再現できませんでした。 原因を特定することはできませんが、他のイベントプロシージャを間接的に呼び出していたり、 何かしら、こちらから見えない記述が影響しているものと思われます。 > 実現したいことは「閉じたらその選択したものだけ閉じる」「開いたときはユーザーフォームだけが表示される」というごくシンプルなことなのです。 はい、＃３は専ら、そのシンプルな要求に必要最低限の手数でお応えしたものです。 （Private Sub CommandButton99_Clickは保険のようなものです。） 動作の確認方法として、＃３の記述を新規のブックに貼り付け、ユーザーフォームとコントロールを追加して 試してみては、、、と思います。 ＃３でも書きましたが、こちらとしては奨めるものでもないので、 諦めるのでしたら、特に返信頂かなくても結構ですが、 その場合は、本件質問を未解決のまま締切にしてください。 お役に立てなかったようで、すみません。
本社がAccess2000なら、これかも？ Access ファイルを最適化すると NTFS アクセス許可がリセットされる http://support.microsoft.com/default.aspx?scid=k … （確かAccess2000では修正されなかったような？かすかな記憶です。間違いかも） なので >本社サーバーのアクセスファイルのデーターファイルのアクセス権限を見れば解決するでしょうか？ 解決するかもしれません。 実際に診てみないことには何とも言えませんけど。 あと、 >テーブルの数値を5％から8％に書き換えました。 で過去のデータも反映されてしまった・・とか 消費税率変更前後での赤伝処理（購入時５％、返品時８％になってしまう）は 大丈夫なんでしょうかね？
vbprojファイルの中から、対象となるDLLのファイル名を検索してください。 私はUnEditorをインストールしているので、YokkaGrepでよくファイル内の文字列を検索していますが、 対象拡張子のファイル内から、対象文字列を検索できるツールを利用すれば調べやすいでしょう。
WebBrowser.Document.Body.innerHTMLで取れる http://www.atmarkit.co.jp/fdotnet/dotnettips/687 …
VBScriptについては門外漢なので、どこが問題なのか知りませんが。 WordのVB関連についての参考サイトだけ紹介しますね。 Document.SaveAs メソッド http://msdn.microsoft.com/ja-jp/library/microsof … MsoEncoding Enumeration http://msdn.microsoft.com/ja-jp/library/microsof … Document.SaveAs2 メソッド http://msdn.microsoft.com/ja-jp/library/ff836084(v=office.15).aspx Word VBA ファイル操作　 テキスト・ファイルの文字コード変換 http://makoto-watanabe.main.jp/WordVba_file.html … msoEncodingUTF7で指定できませんか？
上記、コーディングであれば、該当するデータないのではないかと思われます。 オートフィルターでselectしたデータをコピーするのであれば、 １．A5 でなく、A5:F99　とデータの範囲を指定すべきかと思います。 ２．フィールドが6を指定しているので、A列から数えてF列にある"フィルタ請求年1"と"フィルタ請求年2"を 　　selectするのではないでしょうか。 よって、下記のように訂正すれば出来るのではないかと思われます。 Worksheets("コピー元").Range("A5:F99").AutoFilter Field:=6, Criteria1:="フィルタ請求年1", Operator:=xlOr, Criteria2:="フィルタ請求年2", VISIBLEDROPDOWN:=True 書かれている範囲で思い付くのは以上です。
> ですが・・・起動時にWindows のサイズが極端に大きかったり、小さかったり、意味不明なエラー > メッセージが表示されたりで、XPアプリの難しさを痛感しております。 WindowsXP、Windows7でウィンドウサイズやフォントの文字幅？などは異なりますので、 当然見た目も変わってきますよ。 エラーについてはそのエラーメッセージを見てみないとわかりませんが、環境依存によって、 Windows7で検証しているPCでは満たされていて、WindowsXPで検証しているPCでは満たされていないがために 発生するものではないでしょうか？ Googleなどでメッセージの最初の何文字かで検索したら解決するかもしれませんね。 逆に0x00000000みたいなコードやハンドラがどうのこうのと言ってる場合、動作環境が満たされておらずエラーが発生しているにも関わらず、それをキャッチしていないが為に発生していると思われるので、デバッグした方が良いでしょう。
こんにちは。 > を、起動していると必ず「インデックスが範囲内にありません」 > といった内容のエラーが表示されます。 エラーメッセージは先頭にあるエラーナンバーを添えて、 正確な文言を提示するように心がけましょう。 エラーメッセージのダイアログには、多くの場合 [デバッグ]というボタンが表示されます。 このボタンの有無も解決に役立つ情報のひとつです。 [デバッグ]ボタンを押すことができるタイプのエラーなら、 ボタンを押すことでデバッグモードに切り替えることが出来ます。 エラーの原因となっている記述が行ごと、VBE上でハイライトされますから、 不適切な記述上の誤りを特定する作業から始めることになります。 エラーの原因となっている記述が判れば、 （或いは判らない場合でも） 次に、エラーナンバーやエラーメッセージを頼りに、 記述内容の誤りを確認します。 恐らく ーーーーーーーーーーーーーーーーーーーー ！ 実行時エラー '9'： インデックスが有効範囲にありません。 ーーーーーーーーーーーーーーーーーーーー というエラーなのだと思います。 この場合だと、例えばWorkbooks(引数)のような書き方の 括弧の内側の引数に不適切な指定をしている可能性が大です。 いわゆる「インデックス」だったり「名前」だったり「オブジェクト名」だったりの指定に誤りがないか 確認する作業が必要です。 [デバッグ]ボタンが表示されないタイプのエラーの場合は、 実際の作業でどんなことをしたタイミングでエラーになったか、 という情報が頼りです。 ユーザーフォームモジュールに書かれた各種のイベントプロシージャの内、 どのプロシージャが呼び出されたタイミングでエラーになったのか、、、 そこから辿っていけばある程度、原因となる記述を（最悪でもプロシージャ単位で）特定することが可能です。 例えば、CommandButton1をクリックした場合に発生するなら、 CommandButton1_Clickの記述をチェックします。 ご自分で記述内容の誤りを見つけることが出来ない場合は、問題の箇所の記述を提示する必要があります。 今回の問題が解決してからでも、デバッグについて勉強してみてください。 コーディングとデバッグは、「料理と洗い物（食器洗い）」のような関係と考えてください。、 差し当たり、怪しいイベントプロシージャの先頭に、 　　Stop と一行Stop ステートメントを一時的に書き加えておいて、 実行時にデバッグモードに切り替わり、Stopの行がハイライトされますから、 その状態から、キーボードのF8キーを繰り返し押すことで、 コードを１行ずつ実行します。 Excelブック関連のオブジェクトを処理している限りでは、殆どの場合、 デバッグモードでもエラーを再現できますから、 どの行がエラーなのか、確認するのは難しいことではありません。 > ユーザーフォームで使用するファイルの表示中に > そのようなエラー画面が出てきても仕方がないと思うのですが、 仕方がない、なんてことはありません。 どんな処理をしている時のエラーなのか、ということが判らないと 何も言えません。 そもそも不可能な処理をしようとしている？というような意味なら、 処理の仕方そのものを再検討するべきです。 > ユーザーフォームはマルチ画面を作成したので マルチページコントロールを使っているのかな？という所までは察することが出来ますが、 > ファイルは「出力ファイルC」も出すことができる仕様です。 これはちょっと理解できません。 尚、もしかして"ユーザーフォームはマルチ画面"というのが、 ユーザーフォームを複数、同時に表示する、という意味でしたらば、 別の観点からの話も必要ですが、ここでは触れません。 > また、「出力ファイルA」「出力ファイルC」は > コンボボックスで選択した西暦がファイルの先頭に付くので > （例：2014_出力ファイルA.xls） > 必ず同じファイル名が出力されるとは限りません。 以前のご質問に私がお応えしたものでは、ブックやシートについて 存在しないものを指定した場合のエラー回避は出来ていたと思いますから、 恐らくまだ見ぬ記述に原因があるのでしょうけれど。 今回チェックするべき記述としては、 WorkBooks()、Sheets()、など、 括弧の中に指定した値が適切かどうかが主です。 　　WorkBooks.Open "フォルダパス\ブック名.xls" と、ブックを開く時はフルネームでも、 既に開いているブックを参照する時は 　　WorkBooks("ブック名.xls").Sheets("シート名")..... のようにショートネームで指定する必要がある、とか。 　　WorkBooks.Open "フォルダパス\ブック名.xls" を二重に開こうとしている、とか。 逆に、どこかで 　　WorkBooks("ブック名.xls").Close しているのに 　　WorkBooks("ブック名.xls").Sheets("シート名")..... のような呼び出しをしているとか。 単に、フォルダ名やファイル名の指定と実際の名前に細かな相違があるとか、 ファイル名の文字列の整形に失敗しているとか、 変数に名前を格納するのを忘れている箇所がある、とか。 一応参考にして、疑いの目で客観的に見直すようにしてみてください。 > なので、そのようなエラーが表示されないようにしたいのですが可能でしょうか？ > また、特別なコードは記述していないのですが、 > なのでボタンとかコンボボックスのコードを書けばよいのか・・・という感じなのですが、 > どのように対処すればよいかわかりません。 問題の切り分けに努め、エラーの原因となる記述を付き止めて、 その記述の直し方を相談する、というのが理想的ではありますが、 場合によっては丸ごと提示しないと解らないこともあるでしょう。 また、何らかの記述を書き加える前は問題なく動作していた、 というような記憶も重要な手がかりになりますし、 コーディング中にデバッグや動作確認をマメに行うようにできれば、 問題を先送りすることも減ります。 > それと、出力したファイルの内容を確認するためにアクティブには、 > ユーザーフォーム画面を終了させるしかならず、 > そもそもそうゆう仕様なのかがわかりません。 ユーザーフォームを閉じた方が、（画面を広く使え）シートの内容を確認し易いですから、 閉じることに支障がないなら閉じる方が良いという考え方が多いと思います。 ユーザーフォームを閉じたくない場合は、 ユーザーフォームの表示方法をモードレスにしておけばいいです。 具体的には、 　UserForm.Show に引数をしていして 　UserForm.Show vbModeless のようにします。 但し、モーダル表示を前提にデザインされたUserFormが そのままモードレス表示で完全に機能するとは限りません。 この点は簡単に説明できるものではありませんので、 実際に、そして具体的に経験する中で習得するしかありません。 > ユーザーフォームを作成するのは初めてなので初心者丸出しで > お恥ずかしい限りなのですが、 > どなたかアドバイスいただけますと幸いです。 > こんな抽象的ですが、どうお伝えすればよいのかがそもそもわからず困っていて、 > それに時間もなく頭を抱えているので > お手柔らかに願います。 "お手柔らか"なレスというのが、どんなものかってそれは人それぞれだと思いますが、 抽象的な質問文を今は書いていたとしても、この前よりは解り易い、とか、 次はもっと具体的、とか、そういうのを見ることができれば、 こちらにとっては、やりがいにも繋がります。 エラーもデバッグも、初心者とか、関係ないです。 今でも私は毎日のようにエラー（バグ）と格闘していますし、 エラーを出して解決した数だけ自分のスキルが上がるものとさえ思っています。 "間違い探しゲーム"のようなものだったりする訳ですが、 ＱＡ掲示板を介して回答する立場では、具体物が見えないもどかしさで力及ばぬ場面も多かったり、 質問者さんも客観的な観察をすることが出来なくて迷い、さぞ心細いことでしょう。 ですが、問題点を特定（限定）することさえできれば、解決できないことはありませんから、 "間違い探しゲーム"、頑張ってみてください。
こんばんは！ 一例です。 Dim c As Range, str As String str = Format(Range("A1"), "aaaa") Set c = Range("C1:H1").Find(what:=str, LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then '←念のため Cells(2, c.Column).Resize(10).Copy Range("A2") End If こんな感じではどうでしょうか？ ※　画像では土曜日までのようですので、H列までの検索としています。m(_ _)m
あー、僕たちはエスパーじゃないんだから書いたコードを示さずに「想定したとおりに動きません」と言われても困るなぁ、うん。 というわけで、ボタンを押したときの処理コードと再描画時のコードの提示を補足でお願いいたします。
こんばんは！ VBAになりますが、一例です。 元データはSheet1にあり、Sheet1の1行目はシリアル値になっているとします。 そして祝日データはSheet2に作成してあるという前提です。 標準モジュールに↓のコードをコピー＆ペーストしてマクロを実行してみてください。 Sub 赤ライン() Dim lastRow As Long, j As Long, c As Range, r As Range, myRange As Range, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") .Lines.Delete lastRow = .Cells(Rows.Count, "A").End(xlUp).Row For j = 2 To .Cells(1, Columns.Count).End(xlToLeft).Column Set myRange = wS.Cells.Find(what:=.Cells(1, j), LookIn:=xlValues, lookat:=xlWhole) If Not myRange Is Nothing Or WorksheetFunction.Weekday(.Cells(1, j), 2) > 5 Then Set c = .Cells(3, j) Set r = .Cells(lastRow, j) With .Shapes.AddLine(c.Left + c.Width / 2, c.Top, r.Left + r.Width / 2, r.Top + r.Height).Line .ForeColor.RGB = vbRed .Weight = 3 End With End If Next j End With End Sub ※　データ変更があるたびにマクロを実行する必要があります。 尚、お使いのバージョンがExcel2010以降の場合は、条件付き書式でセルに色がついている場合の判断が可能です。 もしExcel2010以降の場合は↓のコードでも大丈夫だと思います。 （この場合祝日データは参照する必要はなく、Sheet1の3行目に色がついている場合に赤線が表示されます） Sub Excel2010以降の場合() Dim lastRow As Long, j As Long, c As Range, r As Range, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") .Lines.Delete lastRow = .Cells(Rows.Count, "A").End(xlUp).Row For j = 2 To .Cells(1, Columns.Count).End(xlToLeft).Column If .Cells(3, j).DisplayFormat.Interior.ColorIndex <> xlNone Then Set c = Cells(3, j) Set r = Cells(lastRow, j) With .Shapes.AddLine(c.Left + c.Width / 2, c.Top, r.Left + r.Width / 2, r.Top + r.Height).Line .ForeColor.RGB = vbRed .Weight = 3 End With End If Next j End With End Sub こんな感じではどうでしょうか？m(_ _)m
Return Me.ProcessTabKey(e.KeyCode) を2箇所共 Return Notiong に変更するとセルが移動しない様です。
Dim Flg As Integer = -1 '0だと見つかった場合と見つからない場合の区別ができないので、-1にしました For Each tb As TabPage In Me.TabControl1.TabPages 　If tb.Tag = 123 Then 　　Flg = Me.TabControl1.IndexOf(tb) 　　Exit For 　End If Next
レコードセットをOpenした時にレコードが一件もないとBOF,EOFは共にTrueになります。 無条件にUpDateするのではなく、レコードが取得出来た場合にだけ更新します。 もしRsのEOFがFalseなら If Rs.EOF = False Then ' Not Rs.EOF と同義 　　rs("日時") = Now() 　　rs.Update Else 　　Msgbox "該当するレコードがありません。" End If 上記はコードでは仮に10件のレコードが該当しても更新するのは先頭のレコード 一件だけです。もし、そのSelect文で複数レコードを更新するなら rs.Open "SELECT * FROM Tログイン WHERE サイト名='" & サイト名 & "'", cn, adOpenStatic, adLockOptimistic If Not Rs.EOF Then 　　Do While Not Rs.EOF 　　　　rs("日時") = Now() 　　　　rs.Update 　　　　Rs.MoveNext '次のレコードへ移動。カーソルがレコードの終端に来るとEOFはTrueになる 　　Loop Else 　　Msgbox "該当するレコードがありません。" End If
ツールボックスの中身はフォームに配置する部品ですので、 フォームデザイン画面でのみ中身が表示され、コード エディタが表示されている間はそのような表示になって 居ますが、そういうことではないのでしょうか？ 表示メッセージはイマイチな気もしますが、問題は発生して いないのでは？
とりあえず getRange = "=INDEX(確認用データ,H89,d)" は getRange = "=INDEX(確認用データ,H89," & d & ")" だけど INDEX関数は INDEX(範囲,行番号,列番号）なので d = "_" & a & "月"　と文字を入れることがおかしい。 加えて a = Sheets("集計用").Range("B87").Value ・・・ Sheets("集計用").Range("C89").Formula = getRange とB87の値に応じて、集計用のシートのC89の関数を変えるくらいだった 元々から C89に入れる関数を考えれば良いと思うのですが。 VBAで処理する必要性が？です。
> Excel VBA(userForm)上ではうまく動いてくれませんでした、、、。 こちらではちゃんと動いていますが…… コードの場所によっては 　Me.Controls → フォーム名.Controls に変える必要があります。 何かエラーメッセージが出るのですか？
SelectNodesメソッドは、指定されたxPathにマッチするノードのリストを取得するメソッドです。 MsgBox TypeName(objPrice)を実行すると分かりますが、IXMLDOMNodeList型のオブジェクトが返ってきます。 objPrice.lengthで要素数が取得でき、 objPrice(0).textで1番目の要素の内容が取得できます。
http://www.happy2-island.com/vbs/cafe02/capter00 … http://officetanaka.net/Excel/vba/filesystemobje … http://officetanaka.net/Excel/vba/filesystemobje … http://officetanaka.net/Excel/vba/filesystemobje …
こんにちは。 SaveFileName = Application.GetSaveAsFilename(InitialFileName:=FileName, FileFilter:="Excel ブック, *.xlsx") Win7/Xl2010では、こんな風にすればいけるかと。 互換の問題は私には解り兼ねますが、最悪でもApplication.Version等で分岐は可能かと。
minminwamidori さん 変数と定数が理解できていないような気がします。 例）SubName の値がおかしくなります。 　　SubName = "vTgYear + i & _ファイルA.xls" 　　　　→　"vTgYear + i & _ファイルA.xls"　がそのままSubName に設定されます。 　　SubName = vTgYear + i & "ファイルA.xls" 　　　　→　"2001ファイルA.xls"　がSubName に設定されます。 以下、プログラムを修正（命令数をコンパクトにしてあります）しました。 　vTgYear = ComboBox1.Value 　For I = -1 To 1 　　Workbooks.Open Filename:=ThisWorkbook & "\3フォルダC\結果ファイルC.xls" 　　SubName = vTgYear + I & "ファイルA.xls" 　　Workbooks.Open Filename:=ThisWorkbook.Path & "\1フォルダA\" & SubName 　　 　　 (実行コード中略) 　Next I ご確認下さい。
画像を圧縮するのではなく、スリムにするという考えはどうでしょうか。 圧縮の目的が、メール送信可能なサイズまで小さくするということであり、 画像の鮮明度(くっきり度)を必要としないものであれば、スリム化する事をお勧めします。 その手法は、次の通りです。 (1)ExcelのSheetsに画像ファイルを貼り付けます。 (2)その画像を切り取り→貼り付け位置を選択→形式を選択して貼り付け→図(JPEG)　にて貼り付けます。 この段階で画像は60%程度にスリムなっています。 (3)このExcelを、名前を付けて保存→Webページ形式で保存します。 (4)すると、保存したファイルは、html形式で保存され、 貼付した画像は保存したファイルと同じフォルダに、[保存したファイルと同じ名前.files]というフォルダが作成され、 その中に貼り付けた画像がスリム化された状態で(ファイルとして)保存されます。 この段階の画像ファイルは95%以上スリムになっています。 (5)html形式のファイルの処理や[保存したファイルと同じ名前.files]の名前の変更等の処理をします。 これをマクロで記述すればスリム化された画像ファイルを手に入れる事が出来ます。 スリム化の意味 板(画像)に沢山の穴を開けるという意味ですが、 遠目には元の形に見えるということです。 穴開板ですから、鮮明度(くっきり度)が低下します。 ことさらに鮮明度(くっきり度)が不要な画像には最適です。 95%以上穴を開けても、見た目は元のものとあまり変わり映えしません。
二重ループ廻して、ループ終了後にメッセージだすのであれば細かな処理は難しいかも。 strage1（旧）、strage2（新）に加え、差分シート（Storage3？)を設けるのはどうでしょう。 Set myCheck = Sheets("storage3") If IsEmpty(myold.Cells(j, i)) And Not IsEmpty(mynew.Cells(j, i)) Then 　　myCheck.Cells(j, i) = mynew.Cells(j, i) & "が追加になりました" ElseIf Not IsEmpty(myold.Cells(j, i)) And IsEmpty(mynew.Cells(j, i)) Then 　　myCheck.Cells(j, i) = myold.Cells(j, i) & "がキャンセルになりました" ElseIf myold.Cells(j, i) <> mynew.Cells(j, i) Then 　　myCheck.Cells(j, i) = myold.Cells(j, i).Value & "から" & mynew.Cells(j, i) & "に変更しました" のように。 で 　　　　Next 　　Next 　　MsgBox myMsg End Sub を 　　　　Next i 　　Next j 　　''''MsgBox myMsg 　　call 区分識別3 End Sub にする。 なお > j = 5 > For j = j To 35 > i = 6 > 　　For i = i To 8 は For j = 5 To 35 　　For i = 6 To 8 で良いですよ。
こんにちは。 まず、 fmPictureAlignmentCenter　　と書くべきところを　　fmpictueralignmentcenter graphimage4　　と書くべきところを　　grphimage4 ２カ所、これはコンパイルエラーで弾かれますね。 ActiveSheet.ChartObjects(1).Chart.Export graphimage2 が２カ所にありますが、２つめは、 ActiveSheet.ChartObjects(1).Chart.Export graphimage3 という意図で書かれたものとお察しします。 もっとも、定数に設定する値が共通ならば、 ３種類の定数を宣言する必要はなく、ひとつの定数にした方が解り易いと思います。 指定したファイルパスでエクスポートして、処理後に毎度Killステートメントで削除している訳ですから、 パスを共通のものにしておいて問題ないです。 /// コードを読めば、どんな動作をするかはだいたい理解できるものですが、 どんなことがやりたいのか、こちらに伝わってくるかどうかは、また別の問題です。 MultiPage1_Change イベントって、UserForm上で手動で【ページを切り替えた時】、 という意味ですから、 ３ページめを表示中に、３ページめ（のタブ）を、クリックしたとしても。 MultiPage1_Change イベントは呼び出されません。 クリックした時、ということなら、 Private Sub MultiPage1_Click(ByVal Index As Long) イベント もありますが、 これは、タブ以外の所（ページ下部）をクリックしても発生しますから、 処理内容から考えて、案外扱い難いものになるでしょう。 /// ３ページ分のグラフイメージなら、一気に読込・表示してしまってもいいと思いますが、 如何でしょう。 例えば、Private Sub UserForm_Activate() や Private Sub UserForm_Initialize() イベントで一気に、とか、 専用のボタンを設けておいて、Private Sub CommandButton1_Click() イベントで一気に、とか、 そういう感じの例示をひとつ挙げておきます。※１ 次に、 MultiPage1_Change イベントの意味を理解して貰った上で、 「現在表示されていないページを表示しようとするタイミングで」 都度都度、新たに表示しようとしているページの分だけ、読込・表示する例を挙げておきます。※２ ただ、ページを切り替える度に忙しくグラフを更新する必要がある、とは思えないので、 今想像できる範囲では、※２は、そちらのニーズに応えるものではないと考えてはいます。 ※１と※２の共存は不要です。どちらかひとつを選んで使うことになります。 /// グラフ作成手順、書き換えています。 すべて、Sheets("記録")に対して処理します。 .Cells(5 + i * 3, "A") という記述で、A8,A11,A14を参照しています。 .ChartObjects.Count でグラフの有無を確認する意味が解らなかったので外しています。 /// ' ' ※１ /// Private Sub UserForm_Activate()　　'　　8506000 ' ' Private Sub UserForm_Initialize() ' ' Private Sub CommandButton1_Click() 　　Dim i As Long 　　Const graphimage As String = "C:\Users\user\Pictures\Graph.bmp" 　　Application.ScreenUpdating = False 　　With Sheets("記録") 　　　　.Select 　　　　For i = 1 To 3 　　　　　　.Shapes.AddChart(xlLineMarkers).Select 　　　　　　On Error Resume Next 　　　　　　ActiveChart.SetSourceData Source:=.Cells(5 + i * 3, "A").CurrentRegion, PlotBy:=xlRows 　　　　　　On Error GoTo 0 　　　　　　ActiveChart.Export graphimage 　　　　　　If Dir(graphimage) <> "" Then 　　　　　　　　With Controls("Image" & i) 　　　　　　　　　　.PictureSizeMode = fmPictureSizeModeStretch 　　　　　　　　　　.PictureAlignment = fmPictureAlignmentCenter 　　　　　　　　　　.BorderStyle = fmBorderStyleNone 　　　　　　　　　　.Picture = LoadPicture(graphimage) 　　　　　　　　End With 　　　　　　　　Kill graphimage 　　　　　　End If 　　　　Next i 　　　　.ChartObjects.Delete 　　End With 　　MultiPage1.Value = 0 　　Application.ScreenUpdating = True End Sub ' ' /// ' ' ※２ /// Private Sub MultiPage1_Change()　　'　　8506000 　　Dim nIdx As Long 　　Const graphimage As String = "C:\Users\user\Pictures\Graph.bmp" 　　nIdx = MultiPage1.Value + 1 　　Application.ScreenUpdating = False 　　With Sheets("記録") 　　　　.Select 　　　　.Shapes.AddChart(xlLineMarkers).Select 　　　　On Error Resume Next 　　　　ActiveChart.SetSourceData Source:=.Cells(5 + nIdx * 3, "A").CurrentRegion, PlotBy:=xlRows 　　　　On Error GoTo 0 　　　　ActiveChart.Export graphimage 　　　　If Dir(graphimage) <> "" Then 　　　　　　With Controls("Image" & nIdx) 　　　　　　　　.PictureSizeMode = fmPictureSizeModeStretch 　　　　　　　　.PictureAlignment = fmPictureAlignmentCenter 　　　　　　　　.BorderStyle = fmBorderStyleNone 　　　　　　　　.Picture = LoadPicture(graphimage) 　　　　　　End With 　　　　　　Kill graphimage 　　　　End If 　　　　.ChartObjects.Delete 　　End With '　　MultiPage1.Value = 0 　　Application.ScreenUpdating = True End Sub ' ' ///
とりあえず下記で111,222,333が取得できました。ご参考まで。 当方、Windows7Home64bit/xl2010です。 環境は異なりますが、MSXML3あたりでも動くコードだと思います。 コード中XPATHはItemLookupResponseなのに、テストデータの方はItemSearchResponseになっていますが大丈夫ですか？ 'MSXML6に参照設定 Sub test() Dim XML As New MSXML2.DOMDocument60 Dim xmlItems As IXMLDOMNodeList Dim objPrice As IXMLDOMNode XML.async = False ' XML.validateOnParse = False ' XML.resolveExternals = False ' XML.preserveWhiteSpace = True XML.Load GetDesktopPath & "\test.xml" 'お示しのデータをコピペして保存 Set xmlItems = XML.SelectNodes("ItemSearchResponse/Items/Item") For Each objPrice In xmlItems ' ASIN If Not objPrice.SelectSingleNode("ASIN") Is Nothing Then Debug.Print objPrice.SelectSingleNode("ASIN").Text End If Next '直接ASINまで指定しても良いと思うが... ' Set xmlItems = XML.SelectNodes("ItemSearchResponse/Items/Item/ASIN") ' If xmlItems.Length > 0 Then ' For Each objPrice In xmlItems ' Debug.Print objPrice.Text ' Next ' End If Set XML = Nothing End Sub Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function
System.Data.SqlClient名前空間にあるクラスはSQL Serverに対して利用するクラスです。 ref) http://msdn.microsoft.com/ja-jp/library/System.D … OLE DBデータソースにアクセスするには，System.Data.OleDb名前空間にあるクラスを利用します。 ref) http://msdn.microsoft.com/ja-jp/library/system.d …
' ' ///（３／投稿を３分割しています。） ' ' ■■■4_フォルダD 　　sWbkSubName = "4_フォルダD\" & vTgYear & "_ファイルD.xls"　 '　● 　　sShtName = "dateD"　'　● 　　On Error Resume Next 　　Set sht元データ = Workbooks.Open(sMyDir & sWbkSubName).Sheets(sShtName) 　　On Error GoTo 0 　　If sht元データ Is Nothing Then 　　　　sMsg = sMsg & vbLf & "ブック◆" & sWbkSubName & vbLf & vbTab & "◆シート◆" & sShtName 　　Else 　　　　With sht元データ ' ' 8) 地域A男 [2007_ファイルD.xls]dateD!E8:E26→A広域!N7:N25 　　　　　　shtA広域.Range("N7:N25").Value = .Range("E8:E26").Value　'　● ' ' 16) 地域A女 [2007_ファイルD.xls]dateD!E8:E26→A広域!N26:N44 　　　　　　shtA広域.Range("N26:N44").Value = .Range("E8:E26").Value　'　● ' ' 24) 地域B男 [2007_ファイルD.xls]dateD!E8:E26→A広域!N51:N69 　　　　　　shtA広域.Range("N51:N69").Value = .Range("E8:E26").Value　'　● ' ' 32) 地域B女 [2007_ファイルD.xls]dateD!E8:E26→A広域!N70:N88 　　　　　　shtA広域.Range("N70:N88").Value = .Range("E8:E26").Value　'　● ' ' 40) 地域C男 [2007_ファイルD.xls]dateD!E8:E26→B広域!N7:N25 　　　　　　shtB広域.Range("N7:N25").Value = .Range("E8:E26").Value　'　● ' ' 48) 地域C女 [2007_ファイルD.xls]dateD!E8:E26→B広域!N26:N44 　　　　　　shtB広域.Range("N26:N44").Value = .Range("E8:E26").Value　'　● 　　　　　　.Parent.Close SaveChanges:=False 　　　　End With 　　　　Set sht元データ = Nothing 　　End If 　　' ' "ファイルC_2006～2008年結果.xls"形式の名前を付け保存する 　　Application.DisplayAlerts = False 　　wbk結果.SaveAs Filename:=sMyDir & "5_フォルダE\" & ComboBox1.Value & "_ファイルE.xls" '　　● 　　Application.DisplayAlerts = True 　　With Application 　　　　.ScreenUpdating = True 　　　　.Calculation = xlCalculationAutomatic 　　End With 　　Set shtA広域 = Nothing:　　Set shtB広域 = Nothing:　　Set wbk結果 = Nothing 　　If sMsg = "" Then 　　　　MsgBox Label1.Caption & vbLf & "処理完了", vbInformation 　　Else 　　　　MsgBox sMsg & vbLf & "開くことが出来ませんでした", vbExclamation 　　End If End Sub ' ' /// 以上です。
とりあえず、ご提示の説明を読み込み、整理する所まで一応出来ましたが、 添付画像からは読み取れる情報が殆どなかったので、自信はありません。 差し当たり、 コピー元のシート名が確認できません。 "地域A"、"地域B"　というコメントがついている場合は、 　　ブック"yyyy_ファイルX.xls"　の　シート"A広域"　の　各指定セル範囲を元に 　　ブック"ファイルE_結果.xls"　の　シート"A広域"　の　各指定セル範囲へ転記 "地域C"　というコメントがついている場合は、 　　ブック"yyyy_ファイルX.xls"　の　シート"B広域"　の　各指定セル範囲を元に 　　ブック"ファイルE_結果.xls"　の　シート"B広域"　の　各指定セル範囲へ転記 要するに転記元と転記先でシート名は同じ？ という要領なのかな？と、想像していますが、合っていますか？ 合っていれば、形を持ったものがイメージでき、書き始める見通しは立ちます。 もし違っていたら、さらに詳しく説明が必要です。 コピー元はひとつのシート、ということだったり？すると、 なんか おかしなことになっています。 例えば 詳細な説明の１件目の 　　'地域A男性　「2006_ファイルA.xls」のC5～C23を「ファイルE_結果.xls」の(A広域)D7～D25にコピー と、１３件目の 　　'地域C男性　「2006_ファイルA.xls」のC5～C23を「ファイルE_結果.xls」の(B広域)D7～D25にコピー の２件について、 元データは同じ、な訳ないですよね？ どの道、私は、サンプルブック一通り作ってからでないとコードを書きませんから、 補足を待って、サンプルブックを作ってから、、、になります。 納期は大丈夫ですか？
こんにちは。 苦労しているみたいですね。 > 締め切りが近くとても焦っています。 お気持ちは解りますが、ここは落ち着いて、 あなたのやりたいことを、要件を整理することから始めましょう。 あなたの手元にあるワークブックもワークシートも、 こちらからは見えていませんから、 今回の説明では「何を」「どこに」「どのように」という具体的な説明がないと、 残念ながら着手できません。 > 編集したい内容としては、 > 出力する「ファイルC」に複数のシートがあるので、 "3_フォルダC\ファイルC_結果.xls"という名前のブックには複数のシートがある事だけは解りました。 が、 > それぞれのシートを指定して値をコピーしたいのです。 > でも、別のシート名の指定がうまくいきません。 > シートはフォーマットが決まったものが配置されているのですが、 > 1つのシートごとに数が異なります。 ... > 　　(3)範囲がどの結果の範囲に対しても同一の場合がある このままでは、何をしたいか伝わりません。 それぞれのシートの名前が解りませんし、 具体的に「何を」「どこに」「どのように」"値をコピーしたい"のか、 融通が利かないパソコン君でも迷わず処理できるように、 オーダーを整理して投稿し直してください。 お急ぎということなので、私よりも早い回答が得やすいように、 この質問は一旦未解決のまま締切にして、新たに質問を建て直すことをお勧めします。 やるべきことが理解出来れば、できるだけ回答するようにしますけれど、 私以外の方にも参与して貰えるように書いた方がいいと思います。 とりあえず、お役に立てず、すみません。
こんにちは。 前スレ（http://oshiete.goo.ne.jp/qa/8500168.html）に続き回答します。 とりあえず、 Private Sub ComboBox1_DropButtonClick() については、削除した方が、要求に合っている筈です。 Private Sub UserForm_Initialize() Private Sub ComboBox1_Change() は、そのままでも問題なく動作することを確認しました。 UserForm_Initializeイベントは、 UserFormを最初に読み込むタイミング、 平たく言うと、UserFormを最初に作成する（呼び出す）タイミング、に発生します。 その後でUserFormが表示されます。 UserForm_InitializeイベントでComboBoxのリストを設定したならば、 UserFormを閉じたり、UnLoadするか、VBAプロジェクトがリセットされる （UserFormの閉じるボタン、UnLoad UserForm1 を実行、VBEのリセットボタンを押したりエラー発生時にそのまま終了した場合等） までは、リストの内容が保持されます。 なので通常は、UserForm_InitializeイベントでComboBoxのリストを設定したならば、 UserFormが開いている間にリストを再設定する必要はない筈です。 もし必要あるとすれば、UserFormが開いている間に、 リストの元になる"対象年"のセル範囲データを編集・更新している場合が考えられますが、 設問からして、UserFormが開いている間に"対象年"を増やす、なんてことはないでしょうから、 リストの設定についてはUserForm_Initializeイベントで完結しているものと考えて、 他のプロシージャで余計なことをしない様に頭の中を切り替えた方が良いのだと思います。 > クリックするとリストの内容がコンボボックスをクリックした分だけ繰り返してしまうことがあります。 この問題は、ComboBox1_DropButtonClickイベントを削除することで解決します。 ComboBoxのリスト設定、と、 ComboBoxの値が変更されたタイミングでLabel1のキャプションを変更する、 ということについて、必要最低限の記述は、こんな感じです。 ' ' /// Private Sub UserForm_Initialize() 　　Dim sh As Worksheet 　　Set sh = Worksheets("対象年") 　　 　　Dim i As Integer 　　Dim lastRow As Integer 　　lastRow = sh.Cells(Rows.Count, 1).End(xlUp).Row 　　With ComboBox1 　　　　For i = 2 To lastRow 　　　　　　If sh.Cells(i, 1) <> "" Then 　　　　　　　　.AddItem sh.Cells(i, 1) 　　　　　　End If 　　　　Next i 　　End With End Sub ' ' /// Private Sub ComboBox1_Change() 　　Dim vTgYear As Variant 　　vTgYear = ComboBox1.Value 　　If vTgYear = "" Then 　　　　Label1.Caption = "" 　　Else 　　　　Label1.Caption = vTgYear - 1 & "～" & vTgYear + 1 & "年" 　　End If End Sub ' ' /// 以上、ご提示の記述を元に、一部削除、一部修正しています。 /////// 前スレとの関連で気になっているのですが、 大前提として、UserFormの中身はUserFormが開いている間しか保持されません。 例えば、ComboBoxのリストから　2007　を選択したとして、 その状態をComboBoxが記憶してくれるようなことはありません。 無論、ブックを上書き保存しても同じことです。 この点、前スレで説明した、シート上に配置したActiveXコントロールとは、 全く勝手が違いますので、少しフォローしておきます。 一番解り易く簡単そうな方法は、ComboBoxの値が更新される度に、どこかのセルに記録しておく方法です。 例えば、仮に、"対象年"シートのセルＢ１を割り当てて例を示すと、以下のようになります。 ' ' /// Private Sub UserForm_Initialize() 　　Dim sh As Worksheet 　　Set sh = Worksheets("対象年") 　　Dim i As Integer 　　Dim lastRow As Integer 　　lastRow = sh.Cells(Rows.Count, 1).End(xlUp).Row 　　With ComboBox1 　　　　For i = 2 To lastRow 　　　　　　If sh.Cells(i, 1) <> "" Then 　　　　　　　　.AddItem sh.Cells(i, 1) 　　　　　　End If 　　　　Next i 　　　　.Value = sh.Cells(2, "B") 　　End With End Sub ' ' /// Private Sub ComboBox1_Change() 　　Dim vTgYear As Variant 　　vTgYear = ComboBox1.Value 　　With Worksheets("対象年").Cells(2, "B") 　　　　If .Value <> Val(vTgYear) Then .Value = vTgYear 　　End With 　　If vTgYear = "" Then 　　　　Label1.Caption = "" 　　Else 　　　　Label1.Caption = vTgYear - 1 & "～" & vTgYear + 1 & "年" 　　End If End Sub ' ' /// 以上です。
No.1・2です。 ＞実コードは ＞KeyIdValue = jpWS.Cells(jpWsRow, JANCol).Value ＞m = Application.Match(KeyIdValue, usWS.Columns(JANCol), 0) ＞という感じでセルを参照しています。。。 文字列ではうまくいって、数値でエラーになるというコトですね？ 変数　KeyIdValue　の型は何で宣言しているのか不明ですので、いっそのこと 変数に代入せず、MATCH関数の中に直接セルを入れてみてはどうでしょうか？ 仮に参照セルが　B3セルだとすると ＞m = Application.Match(Range("B3"), usWS.Columns(JANCol), 0) のような感じで・・・ 他の変数の型も念のため確認した方が良いと思います。 部分的なコードだけでの回答ですので、これでもダメならごめんなさいね。m（_ _）m
ずばりのサンプルがここにあります http://www.red.oit-net.jp/tatsuya/vb/Outlook.htm
こんにちは。 > ファイルを閉じた後に再度開いてもコンボボックスの中に値があるようにするにはどうしたらよいのか、 真っ先に解決に向かいましょう。 ご提示の２つのプロシージャは使いません。無効にする必要があります。 （資料として残すなら、コメントブロックしておきます） その他にもComboBox1のリストを設定するプロシージャがある場合はすべて無効にします。 ComboBox1　のListFillRangeを指定します。 ◆手順◆ １）Excelをデザインモードに切り替え。 　　　VBE画面のメニューバー[Sub/ユーザーフォームの実行ボタン]の右横辺りに、 　　　三角定規みたいなアイコンの[デザインモード]ボタンがあるので、これをクリックして凹んだ状態にします。 ２）（ComboBox1が配置された）シートを表示し、（ComboBox1）を右クリック 　　　表示されたポップアップの中から ３）[プロパティ]を選択 　　　表示されたプロパティウィンドウの中の ４）[ListFillRange]というプロパティ（項目）の右横の値を入力する欄（空欄）に 　　　リストの元になるデータ（テーブル）のアドレスをExcel数式のセル参照の要領で 　　　「マクロ!A1:A14」とか「マクロ!A2:A15」のように"A1形式"で指定してEnterキーで確定します。 　　　（例は、リストの元データのシート名が"マクロ"、1999から2012（14件）の例です。） 　　　今の時点で必要なだけの大きさで指定しておきます。 ５）Excelのデザインモードを解除。 　　　手順１）で凹ませた[デザインモード]ボタンを再度クリックして元に戻します。 ６）実際にComboBox1のリストを選択してComboBox1の値をしていします。 ７）ブックを上書き保存。 手順、以上です。 あとは、年に１回、年次を増やす時に、上述の手順で、ListFillRangeを指定し直します。 /////// 少しアドバイス。 通常は、リストの変更を忙しく繰り返すようなことはしません。 何か特別な事情があってのことなら、その事情についてよく考えて、相談すればいいと思います。 リストを変更する、ということは、選択した値も変えることになり兼ねないですし、 リストをクリア（ComboBox1.Clear）しないで.AddItemするのは、リストの重複を招くことになります。 それと、Private Sub ComboBox1_DropButtonClick()　というイベントプロシージャですが、 「選択項目のリストをドロップダウンで表示するか、または非表示にすると発生します。」 と、こちらも随分忙しいイベントなので、扱いは難しいですし、用途も限られます。 多分、このイベントに手を付けたことが今回一番の間違いです。 ComboBox1については、Private Sub ComboBox1_Change()　ぐらいで済ませられる内容のようにお見受けします。 /////// 今回の回答では、ActiveXのComboBoxコントロールについて、 固定のリストと指定した値を保持するように ListFillRangeプロパティの扱いを説明しました。 他にも方法は色々ありますが、こちらに伝えられている限りの"必要" に対しては、この方法で"十分"かと考えます。 つまり。一番簡単な（そして保守的な）解決策です。 リストの設定に関して、都度都度.AddItemしなければならない"必要" があるということでしたら、補足欄にでも書いてみてください。 理由がこちらにも理解出来内容でしたら、改めて対応します。 オマケ。 ' ' /// Private Sub ComboBox1_Change() 　　Dim vTgYear As Variant 　　vTgYear = ComboBox1.Value 　　Label1.Caption = vTgYear - 1 & "～" & vTgYear + 1 & "年" End Sub ' ' /// 以上です。
appはAccessのApplicationオブジェクトという認識でよろしいでしょうか？ > If app.Run("AcsMdl"( Strdata, pData) = False) Then Application.Runメソッドの構文は 　Application.Run("関数名", 引数1, 引数2, ……) です。 従って、 　If app.Run("AcsMdl", Strdata, pData) = False Then と書く必要があります。 参考URL：http://msdn.microsoft.com/ja-jp/library/ff193559 …
Target.Column、Target.Rowを使いましょう。 If Target.Address = "$B$2" Then Set ret = Workbooks("抽出.xlsm").Sheets("抽出元").Range("A:A") _ .Find(ActiveSheet.Range("B2").Value) ActiveSheet.Range("C2").Value = ret.Offset(0, 5).Value ActiveSheet.Range("D2").Value = ret.Offset(0, 6).Value ActiveSheet.Range("E2").Value = ret.Offset(0, 7).Value ActiveSheet.Range("F2").Value = ret.Offset(0, 4).Value ActiveSheet.Range("G2").Value = ret.Offset(0, 2).Value ActiveSheet.Range("H2").Value = ret.Offset(0, 8).Value ActiveSheet.Range("I2").Value = ret.Offset(0, 9).Value ActiveSheet.Range("J2").Value = ret.Offset(0, 10).Value を If Target.Coulmn = 2 Then Set ret = Workbooks("抽出.xlsm").Sheets("抽出元").Range("A:A") _ .Find(Target.Value) ActiveSheet.Cells(Target.Row, Target.Column + 1).Value = ret.Offset(0, 5).Value ActiveSheet.Cells(Target.Row, Target.Column + 2).Value = ret.Offset(0, 6).Value ActiveSheet.Cells(Target.Row, Target.Column + 3).Value = ret.Offset(0, 7).Value ActiveSheet.Cells(Target.Row, Target.Column + 4).Value = ret.Offset(0, 4).Value ActiveSheet.Cells(Target.Row, Target.Column + 5).Value = ret.Offset(0, 2).Value ActiveSheet.Cells(Target.Row, Target.Column + 6).Value = ret.Offset(0, 8).Value ActiveSheet.Cells(Target.Row, Target.Column + 7).Value = ret.Offset(0, 9).Value ActiveSheet.Cells(Target.Row, Target.Column + 8).Value = ret.Offset(0, 10).Value にしましょう。
> でも、For文で回した方が処理時間が３倍程度短くできそうです。 ToArrayで時間がかかっちゃいますからねぇ。 時間を気にするならFor文で回すのが確実です。 どうしてもワンライナーで、ということなら、 　bytA.Select(Function(b, i) bytA(i) = bytA(i) Or bytB(i)).GetEnumerator() と書くこともできますが……
コードの先頭部分がないので見当違いかもしれませんが 実行時バインディングにしているのなら ?xlAscending 1 ?xlSortNormal 0 ?xlTopToBottom 1 ?xlPinYin 1 にそれぞれExcelの定数を変更してみては？ 事前バインディングにもかかわらずエラーになる場合は不明です。
5行目から始まるなら、終わりは39行ですね？ For ２個もいりません。F5:H39の範囲を選んで、For Eachすればそれでいいです。 Sub renban() Dim i As Range, x As Long x = 0 For Each i In [F5:H39] x = x + 1: i.Value = x Next End Sub
No1です 今見直していたら余計な行がありました。 Set ExcelApp = WScript.CreateObject("Excel.Application") これを2回書いてしまっているのでどちらか消して下さい。
修正案です。ご参考まで。 Sub 何を書き換えたかMsgBox() Dim i As Integer Dim myMsg As String For i = 1 To 15 If Sheets("strage1").Cells(i, 1).Value <> Sheets("strage2").Cells(i, 1).Value Then myMsg = myMsg & Sheets("strage2").Cells(i, 1).Value & "から" & Sheets("strage1").Cells(i, 1).Value & "に変更しました" & vbCrLf Sheets("strage2").Cells(i, 1).Value = Sheets("strage1").Cells(i, 1) End If Next i If myMsg <> Empty Then MsgBox myMsg Else MsgBox "変更はありません" End If End Sub メッセージボックスの修正については＃１の方の通りです。 修正箇所が無い場合はメッセージボックスは空白になってしまいますので、空白の場合は「変更ありません」としました。 ワークシート名が多く書き込むのであれば、ワークシート名も変数にした方がコードの書き込みが楽になります。 例として dim ws1,ws2 as worksheet set ws1=worksheets("strage1") set ws2=worksheets("strage2") if ws1.cells(i,1).value<> ws2.cells(i,1).value then
＞それより上（つまり、Long以上）であった場合にも、 このコードは使えますでしょうか。 \、Modはやや特殊な演算子なので整数型という制限があります。 他には論理演算子も整数型を対象とした演算子です。 その他の演算子(+,-,*,/ など)は全ての型で使用できます。
既に手遅れかな。 移動して構わないならローカルにコピーして編集する。
これは変数のスコープの問題ではありません。 一度DimまたはRedimで定義した配列は Redimで要素数を変更出来るのは最後尾にある次元の要素数だけです。 (Public pubTMP() の()付きで配列宣言しましょう） 上記の通り(2,2)から(3,3)へはRedim出来ません。 (2,2)から(2,3) 3次元配列だと(2,2,2)から(2,2,3)という具合です。 これらを踏まえると、必要なサイズ（1次元目の要素数）を何らかの方法で取得しておいて 初めのRedimで定義しましょう。2次元目の要素数は必要な時にRedimすれば良いでしょう。 i = 1次元目の必要なサイズ Redim pubTMP(i,2) 2次元目の要素数を一つ上げる時 ReDim Preserve pubTMP(i, Ubound(pubTMP, 2) + 1) どうしても1次元目を増やしたいんだ！という事であれば 配列に配列を格納するジャグ配列というものがあるので（使い方は難しいですけど） 興味があれば調べてみて下さい。うまくジャグ配列が使えればお望みの事は実現出来ます。
> ワークシートからユーザーフォームを表示させた場合の現象です。 そうではなく、モードレスにしているのでは？ http://detail.chiebukuro.yahoo.co.jp/qa/question …
使用している拡張機能の構文からするとおそらく以下のページを参照されたのでしょう。 http://srcedit.pekori.jp/tool/re.html しかし、そのページには > 当ツールの正規表現エンジンはVBScriptのRegExpオブジェクトですが、 > 一部の表現は拡張機能でオリジナルとなっています。 と書いてあり、あなたが使えないと相談された拡張機能はその中に含まれます。 このページの大元をたどると以下のページにあたります。 http://srcedit.pekori.jp/tool/excelre.html このページを読めばわかる通り、ページの筆者はExcelのアドインとして正規表現ツールを提供しており、先ほどのページはそのツールで使える正規表現の説明です。 つまり、この筆者が作成した正規表現ツールのVBScriptのRegExpからの拡張機能を、マイクロソフトがVBScript RegExpに追加した「正規表現の標準規格」（あればの話ですが）からの拡張機能と誤解されての質問と思われます。
#2です。 DoEvents文を実行すると、溜まっていた各種イベントが実行されます。 これに伴い、イベントプロシージャ(VBA)が実行されたり、セルの 内容が変化することもあります。極端な例ではプロセスの終了も 起こり得ます。本来の処理が中途で終わってしまったり、実行条件の 共通変数の内容が変化する可能性があります。このような事象が発生 することを承知の上で使うなら良いのです。 「何でDoEventsがいけないの？」と質問されるということはこの辺の 事情をご存じないのではないでしょうか？ 故に「勧めない」と申し上げたのです。 尚、Sleepを入れないと、CPUタイムスライスを浪費して全体の パフォーマンスに甚大な悪影響が出ます。 SleepはVBAではDeclarationsで以下のように定義します。 Declare Sub Sleep Lib "kernel32" (ByVal 休止時間 As Long) 【使用例】 Do Until we.Status 　　DoEvents 　　Sleep 1 '1ミリ秒休止 Loop Sleepを入れないと、CPU使用率は100%近くになるはずです。 Sleepを入れると、CPU使用率はほぼ0です。 尚、Runメソッドで待機をTrueにすれば、上記の問題は起きません。
＞ただ、私は、VBAコードで処理する方法ないしは、サンプルコードなどがほしかった 「マクロの記録」で記録したコードは、まぎれも無い「VBAコード」です。 基礎になる部分を「マクロの記録」で作り、固定になっている部分を変数に書き換えるとかすれば、それがそのまま「VBAコードで処理する方法」になります。 また、「マクロの記録」で基礎になる部分を作れば、それがそのまま「サンプルコード」になります。 「VBAのコードと、マクロの記録で作られたマクロは、別物では？」って言う先入感があると、上記のような事実に気付けません。 「実は、VBAのコードと、マクロの記録で作られたマクロは、同じ物なのだ」って事に気付けば、マクロの記録を応用して自分でサンプルコードを手に入れる事が可能だし、マクロの記録を応用して自分でVBAコードで処理する方法を手に入れられます。 質問者さんは「欲しいのはソレじゃない」って思っているでしょうけど、実は「マクロの記録で手に入る物」が「貴方が欲しがってた物」なんですよ。 「マクロの記録」って、名前が悪いです。これって「VBAコードの記録」って名前に変えた方が良いと思う。
＃１、２、ｃｊです。 ＃２に追記です。 設問が詳しくないので迷いますが、 やはり、「3_フォルダC」に保存する、ということでしたら、 　　' ' "ファイルC_2006～2008年結果.xls"形式の名前を付け保存して閉じる 　　sht結果.Parent.Close SaveChanges:=True, Filename:=sMyDir & "3_フォルダC\" & ComboBox1.Value & "_ファイルC.xls" '　　● という風になります。 追記、以上です。
全然関係ないけど、文字列の中にダブルクォートを書く時は「""」と書くだけで良いです。 例えば Range("F1").Formula = "=IF(D4="""","""",DBCS(PHONETIC(D4)))" のように。 式の「"ABCD""EFGH"」は「ABCD"EFGH」になります。 なので「=IF(D4="","",DBCS(PHONETIC(D4)))」と書きたい時は「"=IF(D4="""","""",DBCS(PHONETIC(D4)))"」と書きます。
DataGrigView のセル入力チェック処理は CellEndEdit ではなく CellValidating を 使用するのが普通です。 以下にサンプルがあるので参考にしてください。 http://dobon.net/vb/dotnet/datagridview/cellvali …
815Bは＜ー＞を示しています。 その次の文字は＜＆＞。これは8195となります。 当方の環境ではこれが表示されます。 実行時エラーの表示、申し訳ありません。 エラー内容から察するに、strRECには5文字しか格納されていないようです。 つまり・・・ 1文字目：" 2文字目：c 3文字目：c 4文字目：c 5文字目：ー 6文字目は存在していないのでエラーとなります。 Line Inputは一行単位で（厳密にはCr、あるいはCrLfまで）読み取ります。 5文字で読み取りが終了していることを考えると、 見えない何かは”Cr”や”CrLf”の可能性があります。 今回の場合、直感ですがCrの可能性があります。 この文字コードが邪魔しているため、正しく読み取れないものと考えます。 この場合、意図と違った結果が得られてしまいます。 検証方法として、以下のソースコードを試してみてください。 Dim fn As Integer fn = FreeFile() Dim testFile As String testFile = ActiveWorkbook.Path & "\loadtest.txt" Open testFile For Binary As #fn Dim sizeOfFile As Long sizeOfFile = LOF(fn) Dim stringBuffer As String stringBuffer = String(sizeOfFile, vbNullChar) Get #fn, , stringBuffer Close #fn Dim lineOfFile() As String lineOfFile() = Split(stringBuffer, vbCr) このとき、LineOfFileの配列数がどうなるか。 期待されるのは 0："aaa","3" 1："cccー＆","4" 2："bbb","5" ですが、症状から察すると 0："aaa","3" 1："cccー 2： 3：＆","4" 4："bbb","5" 3以降は必ずしもこうなるとは限りませんが・・・。 これに近いもの、と思います。 対応方法 対応1.このファイルを出力しているソフトの担当者に連絡する。 対応2.上記検証用コードを少し書き換える 前） lineOfFile() = Split(stringBuffer, vbCr) 後） lineOfFile() = Split(stringBuffer, vbCrLf) Dim i As Integer For i = 0 To UBound(lineOfFile) lineOfFile(i) = Replace(lineOfFile(i), vbCr, "") Cells(i, 1).Value = lineOfFile(i) Next i これで、希望に近い結果になるのではないでしょうか。
> 実は私はVBAがわかりません。そのため、JAVAの > コードをVBAに作り変えるための方法がわかりません。 改めて質問のコードを見て気づいたのですが、このコー ドは java ではなく、javascript ですね？ VBA を動かすソフトウェア(EXCELなど)は当然ブラウザ ではありませんので、このようなコードを実現するため には、VBAからブラウザを制御するためのコードを色々 と作る必要があり、それはこの狭い回答欄に『無償で』 回答できるレベルを超えます。 横着せず VBA を学習してください。 VBA からブラウザを制御するための参考サイトは提示 しておきます。 http://vba-code.net/ie/
2003だとエラーは出ずに正常に動きました。 以下のコードにしてみたらかがでしょうか Shapes("Check Box 1").ControlFormat.Value = 1 TrueだとエラーでFalseはOkでした。
こんにちは。 http://www016.upp.so-net.ne.jp/cheetah/xlvba/Exc … に「複数のブックを集計する」というのがありますが、この方法はいかがでしょうか。 参考URL：http://www016.upp.so-net.ne.jp/cheetah/xlvba/Exc …
＞マクロを使う場合はどのような方法が良いのでしょうか。 データには、一行目には項目（フィールド名）が入っていて 2行目からデータが入っているものとします。 エクセルの機能にある　フィルターオプションの機能を使えば 一挙に、希望したデータが抽出できます。 http://www.eurus.dti.ne.jp/yoneyama/Excel/filter … を参考に勉強してみてください。 マクロについても最後に説明されています。 エクセル2007以上では リボンのデータ フィルター＝＞詳細設定で フィルターオプションの設定に入ります。
SaveAs を何回も行なったので、 保存すべきファイルと今開いているファイルが 別物となったのでエラーが発生したと推測します。 OLD への保存は SaveCopyAs でファイルコピー 元ファイルの更新は Save で保存 とすれば如何でしょうか
> １．プロジェクトにクラスを追加 別プロジェクトにする(Windowsフォームコントロールライブラリ) http://msdn.microsoft.com/ja-jp/library/w2a8y03d(v=vs.110).aspx
イベントドリブンでやるのはいかがでしょうか。 イベントを捕捉するためにクラスモジュールに記述する必要があります。 簡便にクラスモジュールである、シートモジュールに記述して試してみました。 'Microsoft Internet Control 'Microsoft HTML Object Library 'に参照設定 Public WithEvents ie As WebBrowser Sub test() Set ie = CreateObject("InternetExplorer.Application") ie.Visible = True ie.navigate "http://www.hoge^3.jp/" 'ありそうもないURL End Sub '下記でエラーがトラップできます '但しGoogle Tool Bar アドインが有効だと、検索画面に移ってしまってNavigateErrorになりませんでした。 Private Sub ie_NavigateError(ByVal pDisp As Object, URL As Variant, Frame As Variant, StatusCode As Variant, Cancel As Boolean) Debug.Print pDisp.Name Debug.Print URL Debug.Print Frame Debug.Print StatusCode Cancel = True End Sub 'NavigateErrorと、エラーコードについてはこちら 'http://msdn.microsoft.com/en-us/library/bb268221(v=vs.85).aspx 'http://msdn.microsoft.com/en-us/library/bb268233(v=vs.85).aspx 首尾良く読込完了のイベントDocumentComplete、NavigateComplete2等は下記をご参照下さい。 http://d.hatena.ne.jp/dayflower/20070926/1190787 … こちらもご参考まで。 http://okwave.jp/qa/q8434979.html
> A列で上から順番に値を入力されています。 > そういうパターンに対応できる形にしたいです。 > A列の空白以外のセルの数を取得したりするやり方はわかります。 なら Select Case でやらなくてもいいんじゃないでしょうか？ たとえば配列や Collection などを使うとか。 あとはそれをループさせ、ループの中で 1度でもヒットしたところでフラグを立ててループを脱出する。 その後にフラグの状態に合わせて処理を 2分割する。 Collection なら Add メソッドで簡単に要素を追加できるし For Each でループできる。 Dim cellValues As New Collection cellValues.Add Item:="セルの値", Key:="キー情報" Dim cellValue As Variant For Each cellValue In cellValues 　　If hoge = cellValue Then 　　　　flag = True 　　　　Exit For 　　End If Next If flag Then 　　処理 Else 　　処理 End If
対策としては、CreateObjectを繰り返さない。 CreateObjectで作成したオブジェクトを使いまわす。 http://www.ken3.org/guchi/backno/guchi205.html
クリックするのは、<li>の中にある<a>だから、 objtag.getElementsByTagName('A')[0].click もしくは objtag.firstChild.click
数字にしてるから消えるのであって文字列データで扱えば消えません （数字への変換は必要に応じて自前でやってください）
http://www016.upp.so-net.ne.jp/cheetah/xlvba/Exc … に書いてある方法はどうでしょうか。 Set wb1 = Application.Workbooks.Add Set wb2 = Application.Workbooks.Add のところを Set wb1 = Application.Workbooks.Open(Filename:="ファイル名") Set wb1 = Application.Workbooks.Open(Filename:="ファイル名") のように書き換えれば出来ると思います。 参考URL：http://www016.upp.so-net.ne.jp/cheetah/xlvba/Exc …
サードパーティの有料コンポーネントを使うとか。 MultiRowがお勧め。 http://www.grapecity.com/tools/categories/dotnet
Format関数のヘルプを見てもらえばわかることですが この書式指定では、時間部分は24時間制の2ケタです。 Select Case Format(TimecoluConv, "HH:mm:ss") Case "08:00:00" ESColumn = 2 Case "08:10:00" ESColumn = 3 Case "08:20:00" ESColumn = 4 ・・・ End Select End Function
試してみてください。 MsgBox WebBrowser1.LocationURL これでよければ TextBox1.Value = WebBrowser1.LocationURL
fName=app.getsaveAsFilename(・・・ If fName <> fale Then 保存処理 ・・・ の感じで。詳しくはExcelのVBAでGetSaveAｓFileNameメソッドを。
エラーに対する答えではないですが 業務用のマシンなら、マイクロの自動アップデートを　ＯＳ、エクセルとも、全部止めてしまうことを考えたほうがよろしいかと・・・ そのマシンがネット環境をどうでも使うなら、セキュリティーなどの関係でアップデートも必要かもしれませんが
大文字でなく小文字であれば 以下のように修正します。 =IF(AND(AND(G5<>"x", H5<>"x"),I5<>"x"), "WWP-" & TEXT(ROUNDDOWN((ROW()-1)/10,0)+1, "000"),"")
参照設定で、ADOにチェックがあり、かつ、DAOより上にありますか？
案１：No1さんの書いたようにシートにデータを入れて、そのシートを非表示にしておく。 案２：a(0) = "AAA"のようなプログラムを生成する。 VBAで書いてもいいし、バッチ処理でやるなら、下記のBATファイルを実行して出力ファイル内容をコピペ。 @echo off set N=0 (for /f "delims= eol=" %%A in (データの入ったファイル名) do call :sub "%%~A") >出力ファイル.txt goto :EOF :sub echo A^(%N%^)=%1 set /a N+=1 goto :EOF
(1)CSVを取込し、値で添付のようなフォーマットに貼り付けしたい 　6行目でいうと、CSVのそれぞれの以下のセルの値がエクセル表の以下のセルに 　値で貼り付くようになります。 　※エクセル表は5行目がタイトル行になります。 　※コピー後の貼り付けは値で貼りつけしたい 　 エクセルには、CSVのファイルのデータ接続という機能があります。 データ＝＞テキストファイル＝＞ファイル　＝＞取り込み先のセルなどを設定すると 次回からは、更新を行うだけになります。 カットと貼り付けという発想から離れましょう。 　　　　 エクセル表　B6 C6 D6 E6 F6 G6 　CSV　 　A2 B2 E2 F2 I2 L2 縦横入れ替えの貼り付けですよね。先に説明した方法で別のシートへデータの取り込み 印刷したいシートへ縦横入れ替えで貼り付け、或いは関数を配置 (2)昇順に並び変えをしたい 　G列は数字になりますので、昇順で並び変えをしたい 関数を使った場合は、一度、値に入れ替えて エクセルの並び替えを実行 (3)値が入っている範囲で印刷をしたい。 　CSV取込によりセットした値の印刷範囲で自動で印刷するようにしたいです。 表では罫線があるので、データが入っているセルに罫線が入るように設定すれば 如何でしょうか。 勝手に、必要な部分だけが印刷されると思います。 上記の事が手動で出来るようになったら、マクロの記録で一気にマクロ化してください。 VBにこだわる前に、エクセルの機能を全面的に使いこなす事が簡単です。
ログインボックスはiframeにしているみたいですね。 iframeのソースURLは 　https://aff.valuecommerce.ne.jp/?type=2 ですので、そちらのページのソースコードを参照してください。
>正規版のCrystalReportsを購入するすると >VisualStudioでCrystalReportsのレポート表示を >することができるプログラム開発ができるのですか？ 可能です。 簡単なレポートであればVS無しで開発することも可能です。 http://global.sap.com/japan/solutions/sap-crysta … バージョン別の対応状況についてはSAPに問い合わせるなどしてください。
#1です。 ということで、 Sub test() Dim a(1000, 1000) As Variant, b As Variant 'ここは配列にデータを入れるコード b = a ReDim Preserve b(1000, 0)　　　'1次元にする datanum = WorksheetFunction.CountA(a)　　　'全データ数 dim1 = WorksheetFunction.CountA(b)　　　　'第1添え字のデータ数=第1添え字の最大値+1 dim2 = datanum / dim1 - 1　　　第2添え字の最大値 Debug.Print dim1 - 1, dim2 End Sub というのではどうでしょう。
>>縦に並んでいるデータベースの値を横に並べたく思っています。 そうなるように、読み込んだデータをプログラムで加工してセットすればいいんじゃあないですか？
そういう症状は見たこと(遭遇したこと)ありませんが……。 とりあえず、私ならフォントキャッシュ削除して再起動してみますかね。
切り出し後のサイズの配列bを作って、bにaの値をコピーしてから Put #1,b すりゃ良い。 ・Option Base 0の場合 //a(256,256)の配列の添え字は0～255。 //b(206,206)の配列の添え字は0～205。 Dim b(206,206) As Integer For x = 50 To 255 For y = 50 To 255 b(y - 50,x - 50) = a(y,x) Next Next Put #1,b ・Option Base 1の場合 //a(256,256)の配列の添え字は1～256。 //b(206,206)の配列の添え字は1～206。 Dim b(206,206) As Integer For x = 51 To 256 For y = 51 To 256 b(y - 50,x - 50) = a(y,x) Next Next Put #1,b 要らないのは、５０行５０列分なのか、５１列５１行なのか、良く判らん。 質問文では、Option Baseを0のつもりで書いている部分と1のつもりで書いている部分がゴッチャになってて訳が判らなくなっているので、自分でもう少し整理してみよう。
＞と書くと、定義が重複しているというエラーが表示されてうまくいきません。 VBAは、C++のような「変数スコープ」がありませんから、ブロック内で変数定義する事は出来ません。 ＞これはどうすれば良いでしょうか？ 一番最初に Dim AIyy As Variant と書けばオッケー。 Variant型の変数には、Doubleの値も、Longの値も、Stringの値も、Dateの値も、どんな型の値でも好きに代入できます。
　Excel2003を所有していないため、動作確認が出来ておりませんが、おそらく次の様なVBAのマクロで大丈夫だと思います。 Sub Macro1() Dim ans As Long ans = Application.WorksheetFunction.CountIf(Columns("S:S"), "*test*") Range("AC1").Value = ans End Sub
No.2 です。 > 読み込みファイルから、ヘッダ部位を配列a(30)に読み込んで、 > バイナリ部位をb(256)に読み込んだとします。 > どうやって、テキストデータとバイナリデータを合体させれば > 良いですか？ すいません、『やりたいこと』を読み違えていました。 ヘッダ部位、バイナリ部位の両方とも同じファイルに出力 したいということですね。 以下の手順で行けると思います。 　1. 書込ファイルにテキストでヘッダを出力 　2. 書込ファイルをバイナリモードで OPEN 　3. 出力位置を末尾に移動 (SEEK を使います) 　　　http://homepage1.nifty.com/MADIA/vb/vb_bbs2/2005 … 　4. バイナリ部位をファイルに出力 # ヘッダ部分をテキスト出力せずに、１文字づつASC関数で # ASCIIコードに変換して全部バイナリ出力するという方法も # 考えられます。
> Sub sample()のところでp(500,500)の各配列に1か0を代入していますが、 > 0～255までのカラーを使いたい場合には、 > With RGBQUAD(0)で0～255まで全て定義する必要があるのでしょうか？ 先の回答で示したページをよく読んでください。 > 変数kを0から7まで繰り返して、* 2 ^ (7 - k)を足していく操作が理解できないのですが > 何をやっているのでしょうか？ 実際にそのコードを実行し、数値を変更したりしてどのような画像が出来上がるのか試してみてください。理解しなくても関係の無いところだと思われますが。 > また、式の中で「\」マークが出てきますがこれは何を意味しているのでしょうか？ 実際にご自身で計算式を作って試してみればわかることです。 以下の2行を実行してみてください。 Debug.Print 10 \ 3 Debug.Print 10 / 3 演算子 http://www.officepro.jp/excelvba/basic/index6.html 何もせず示したページもろくに読まないで質問ばかりするのはやめましょう。時間の無駄です。
＞C2,D2が選択された時にもオプションボタンが出て・・・ ということは、 ＞設問をC列に、回答欄をD列に設定した10問程の・・・ の場合もあるということでしょうか？ ActiveCell.Column　で選択した列の番号がでます。 A列を選択した場合 ActiveCell.Column　は　１ C列を選択した場合 ActiveCell.Column　は　３ ですので Private Sub CommandButton1_Click() j = ActiveCell.Column + 1 i = ActiveCell.Row If OptionButton1.Value = True Then Worksheets(1).Cells(i,j).Value = OptionButton1.Caption ElseIf OptionButton2.Value = True Then Worksheets(1).Cells(i,j).Value = OptionButton2.Caption End If End Sub 　 選択した列の一つ右側に結果が入ると思いますが。
残念ながら、Visual Basic .net は門外漢です。。 前回のリンクも別件で調べていた時に遭遇したものです。 スタートアップに「管理者として実行」したいアプリがあったので 調べた時に参考になったのは http://www44.atwiki.jp/a2z_izm/pages/38.html http://naotendo.blog96.fc2.com/?no=1132 です。 VBSの話ですが、あなたのプログラムのインストーラで 同じようなことを行うものを制作されれば・・・と思います。 あるいは妥協して上記リンクに沿った形にするか。 なお、これもリンクだけですが タスク スケジューラを登録するサンプル(VB.NET) http://homepage2.nifty.com/nonnon/SoftSample/VB. … が貴重な情報となるかと。 私が使わせてもらっている、CCleaner もタスクスケジューラに VBSの場合と似たようなこと？をしていますね。 私がお手伝いできるのは此処までです。
As Objectである必要はあるのですか。 言語機能としてメソッドのオーバーロードがあるのですから，本質的には各型ごとにオーバーロードを用意するのがよいと思います。 そもそも，「空白」というのは文字列，つまりはStringでの話であって，一般の型に使える話ではありませんが。 ' String型は特殊でString.IsNullOrWhiteSpaceを利用 Function Abc (ByVal s As String) As Boolean     Return String.IsNullOrWhiteSpace(s) End Function ' Bit型は受け付けない Function Abc (ByVal bAs Bit) As Boolean     Throw New InvalidOperationException() End Function ' String/Bit型は専用のメソッドで処理，それ以外はNothingかどうかを返す Function Abc (ByVal o As Object) As Object     If o Is String Then         Return Abc(DirectCast(o, String))     End If     If o Is Bit Then         Return Abc(DirectCast(o, Bit)     End If     Return o Is Nothing End Function
こんにちは。 RemovePersonalInformation プロパティで操作できる個人情報というのも非常に限定的ではありますが、、、。 お訊ねに対するこちらの理解が十分ではないかも知れませんが、 ブックのファイルプロパティの［作成者］などは、変更・削除可能です。 ［前回保存者］は、上書き保存時にのみ、変更のみ可能です。 ですので、これについては、"ブック保存前に個人情報を削除"という訳には行きません。 他に方法がない、と断言できるほどの情報は持ち合わせていませんが、私は知りません。 以下は、ファイルをアップロードする時等に個人的に使っていたものに手を加えたものです。 少しでも参考になることがあればいいのですが、、、。 ' ' ///ブックのファイルプロパティについて ' ' ///　［作成者］［会社］を削除 ' ' ///　［前回保存者］は、削除出来ないので、 ' ' ///　一旦、ユーザー名を（スペース等に）変更して ' ' ///　そのまま上書き保存することで、ユーザー名を晒さない Sub Re8465798a() 　　Dim sUser As String 　　sUser = Application.UserName 　　Application.UserName = " "　　'　　Empty不可！（仮に半角スペースを指定） On Error GoTo ErrOut_ 　　With ActiveWorkbook　'　With Workbooks("ブック名")　'　With ThisWorkbook　'　With Me 　　　　With .BuiltinDocumentProperties 　　　　　　.Item("Author").Value = Empty　　'　　［作成者］ '　　　　　　.Item("Last Author").Value = Empty　　'　　［前回保存者］消せない！上書き時に再設定される！ 　　　　　　.Item("Company").Value = Empty　　'　　［会社］ 　　　　End With 　　　　.Save 　　End With ErrOut_: 　　Application.UserName = sUser End Sub 因みに、 [ドキュメント検査]の実行結果から、一部個人情報の削除を実行した際に マクロの記録を録ってみたら、RemoveDocumentInformation メソッド というのがあることに気が付きました。 マクロの記録で得られたコードが以下。 　　ActiveWorkbook.RemoveDocumentInformation (xlRDIPrinterPath) 　　ActiveWorkbook.RemoveDocumentInformation (xlRDIDocumentProperties) こちらで色々試すのはご勘弁、ということで、ヘルプの引用を最後に掲げて置きます。 因みの因みに、こちらxl2010では、未保存データがあったとしても、 保存を促されるのを無視して、[ドキュメント検査]を実行可能でした。 お望みに適わない話になってしまっているようでしたら、適当にスルーしてください。 ＜以下、引用＞ Excel 開発者用リファレンス ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Workbook.RemoveDocumentInformation メソッド 指定された種類の情報をすべてブックから削除します。 バージョン情報 追加バージョン: Excel 2007 構文 式.RemoveDocumentInformation(RemoveDocInfoType) 式 Workbook オブジェクトを表す変数です。 パラメーター 名前 必須/オプション データ型 説明 RemoveDocInfoType 必須 XlRemoveDocInfoType 削除される情報の種類を指定します。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ XlRemoveDocInfoType 列挙 ドキュメント情報から削除するタイプ情報を指定します。 バージョン情報 追加バージョン: Excel 2007 名前 値 説明 xlRDIAll 99 文書情報をすべて削除します。 xlRDIComments 1 文書情報からコメントを削除します。 xlRDIContentType 16 文書情報からコンテンツ タイプのデータを削除します。 xlRDIDefinedNameComments 18 定義済みの名前を削除します。文書情報からのコメントです。 xlRDIDocumentManagementPolicy 15 文書情報から文書管理ポリシーを削除します。 xlRDIDocumentProperties 8 文書情報から文書プロパティを削除します。 xlRDIDocumentServerProperties 14 文書情報からサーバー プロパティを削除します。 xlRDIDocumentWorkspace 10 文書情報からワークスペース データを削除します。 xlRDIEmailHeader 5 文書情報からメール ヘッダーを削除します。 xlRDIInactiveDataConnections 19 文書情報から無効なデータ接続を削除します。 xlRDIInkAnnotations 11 文書情報からインク注釈を削除します。 xlRDIPrinterPath 20 文書情報からプリンターのパスを削除します。 xlRDIPublishInfo 13 文書情報から発行情報を削除します。 xlRDIRemovePersonalInformation 4 文書情報から個人情報を削除します。 xlRDIRoutingSlip 6 文書情報から回覧先を削除します。 xlRDIScenarioComments 12 文書情報からシナリオのコメントを削除します。 xlRDISendForReview 7 文書情報から [校閲者へ送信] 情報を削除します。 © 2010 Microsoft Corporation. All rights reserved. ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
手っ取り早いのは、 bをvariantで宣言して、 b=a とするのが一番手っ取り早いかと。
私もやってみました 操作として、A列のどこかに「ネコ」と入力したら、 その横、B列に日付を、C列にｘ匹　を表示するものです。 フォルダの対象ファイル一覧を作った後、直近から Open 探す方法なので ファイル数が多ければ、それなりに遅くなると思います。 ファイル内の解釈は、 １行づつ読み込みます 「・」が無い行はスキップ 「・」があれば、「・」区切りの最後を「、」区切りで その区切ったものがA列に入力されたものだったら・・・・ という流れになっています。 （ベタな処理と思います） Private Sub Worksheet_Change(ByVal Target As Range) 　Dim sKey As String 　Dim oFso As Object 　Dim sS As String 　Dim sBuf As String 　Dim sAry() As String 　Dim v As Variant 　Const CPATH = "D:\Hoge\日別訪問動物\" 　Const CCHKMOJI = "・" 　Const CSEPMOJI = "、" 　Const adVarChar = 200 　Const adUseClient = 3 　Const adOpenStatic = 3 　Const adLockOptimistic = 3 　With Target 　　If ((.Count <> 1) Or (.Column <> 1)) Then Exit Sub 　　sKey = .Value 　　If (Len(sKey) = 0) Then Exit Sub 　　Application.EnableEvents = False 　　.Offset(, 1) = "" 　　.Offset(, 2) = "" 　　Application.EnableEvents = True 　End With 　Set oFso = CreateObject("Scripting.FileSystemObject") 　With CreateObject("ADODB.Recordset") 　　.Fields.Append "F1", adVarChar, 255 　　.CursorLocation = adUseClient 　　.CursorType = adOpenStatic 　　.LockType = adLockOptimistic 　　.Open 　　For Each v In oFso.GetFolder(CPATH).Files 　　　If (oFso.GetExtensionName(v.Name) = "txt") Then 　　　　sS = oFso.GetBaseName(v.Name) 　　　　If ((Len(sS) = 8) And (Not sS Like "*[!0-9]*")) Then 　　　　　.AddNew 　　　　　.Fields(0) = v.Name 　　　　　.Update 　　　　End If 　　　End If 　　Next 　　If (.RecordCount > 0) Then 　　　.Sort = "F1 DESC" 　　　Do While (Not .EOF) 　　　　sS = .Fields(0) 　　　　With oFso.OpenTextFile(CPATH & sS) 　　　　　Do While (Not .AtEndOfStream) 　　　　　　sBuf = .ReadLine 　　　　　　If ((InStr(sBuf, CCHKMOJI) > 0) _ 　　　　　　　And (InStr(sBuf, sKey) > 0)) Then 　　　　　　　sAry = Split(Trim(sBuf), CCHKMOJI) 　　　　　　　For Each v In Split(sAry(UBound(sAry)), CSEPMOJI) 　　　　　　　　If (v = sKey) Then 　　　　　　　　　Application.EnableEvents = False 　　　　　　　　　With Target 　　　　　　　　　　.Offset(, 1) = Format(oFso.GetBaseName(sS), "@@@@/@@/@@") 　　　　　　　　　　.Offset(, 2) = sAry(0) 　　　　　　　　　End With 　　　　　　　　　Application.EnableEvents = True 　　　　　　　　　Exit For 　　　　　　　　End If 　　　　　　　Next 　　　　　　　If (Not IsEmpty(v)) Then Exit Do 　　　　　　End If 　　　　　Loop 　　　　　.Close 　　　　End With 　　　　If (Not IsEmpty(v)) Then Exit Do 　　　　.MoveNext 　　　Loop 　　End If 　　.Close 　End With 　Set oFso = Nothing End Sub
momonga1119さん 正規表現を使った方が良いかと思います。 　　Dim cmds() As String 　　cmds = System.Environment.GetCommandLineArgs() 　　Dim strKEY As String 　　Dim strテーブル名 As String 　　Dim mc As System.Text.RegularExpressions.MatchCollection 　　mc = System.Text.RegularExpressions.Regex.Matches(cmds(2), _ 　　 　　 　　"KEY=(.*?)($|\)|/) ") 　　If mc.Count >= 1 Then strKEY = mc(0).Groups(1).Value 　　mc = System.Text.RegularExpressions.Regex.Matches(cmds(2), _ 　　 　　 　　"テーブル名=(.*?)($|\)|/)") 　　If mc.Count >= 1 Then strテーブル名 = mc(0).Groups(1).Value 注）KEY=○○○/ KEYは英大文字での対応です。 　　もし小文字の対応もしたければ、以下のように変更して下さい。 　　mc = System.Text.RegularExpressions.Regex.Matches(cmds(2), _ 　　 　　"KEY=(.*?)($|\)|/) ", _ 　　 　　System.Text.RegularExpressions.RegexOptions.IgnoreCase) お試し下さい。 　　　
Call ComboBox1_Change() でいいです。
「Goに行ってはGoに従え」 他の言語の手法を無理に持ってこない、というのが、プログラミングのコツだと思っています。 Cでは、純粋な「文字」という型がありません。 char は整数の一つであって、「文字」ではありません。 VBでは、純粋な文字を表現するための型があります。数値で代用する必要がありません。 A という文字には、もともと番号なんてありません。65というのは、ASCIIで決めたものです。 「iDataの数値が"A"のASCIIコードだったら」という意味を明確に表わしているのは、VBの方では。 また、最近の言語は、いろんな最適化が行われます。 下手なチューニングは逆効果、ということもあります。 VBでは、数値も「オブジェクト」です。Cの数値のような高速性を求めてはいけません。 iDataも、CharやStringする方が簡単、とかはないですか?
BackGroudWorkerを併用して、チェックが外れたらキャンセルイベントで中止にするのはどうですか？
> 受け取った引数が("SomeEXE.exe", "hoge.txt fuga.txt piyo.txt")となっていますが、 > この"hoge.txt fuga.txt piyo.txt"をxとyといった変数に別々に格納したいのですが・・・。 > ｘにhoge.txt fuga.txt > ｙにpiyo.txt > といった感じです。 　Process.Start("SomeEXE.exe", "hoge.txt fuga.txt piyo.txt") としたとき、Mainメソッドに渡される引数は 　CmdArgs(0) → "hoge.txt" 　CmdArgs(1) → "fuga.txt" 　CmdArgs(2) → "piyo.txt" になります。(スペース区切り) 　Process.Start("SomeEXE.exe", """hoge.txt fuga.txt"" piyo.txt") //←ひとまとめにしたい引数はダブルクォーテーション(")で囲う とすると、Mainメソッドに渡される引数は 　CmdArgs(0) → "hoge.txt fuga.txt" 　CmdArgs(1) → "piyo.txt" になります。
＞VB6でトグルボタンを使いたい CheckBoxのStyleプロパティを[1-グラフィックス]に設定すればトグルボタンと同じ振る舞いをするようになります。 また、OptionButtonのStyleプロパティを[1-グラフィックス]に設定すればラジオボタンとして機能します。
失礼しました。 途中までですが以下でどうでしょう？ メニューの挿入から標準モジュールに張り付けてお試しください。 data1 ～data10 のシートがすでにある前提です。 Sub 取り込みメイン() Dim FileList() As Variant, tmpName As Variant Dim i As Integer With Application.FileDialog(msoFileDialogFilePicker) .AllowMultiSelect = True .InitialFileName = Environ("userProfile") & "\desktop" .Filters.Clear .Filters.Add "CSVファイル", "*.csv" .Filters.Add "すべてのファイル", "*.*" .FilterIndex = 1 If CBool(.Show) Then '選択ファイルのパスの格納 ReDim Preserve FileList(.SelectedItems.Count - 1) For Each tmpName In .SelectedItems FileList(i) = tmpName i = i + 1 Next Else MsgBox "選択ファイルが無いので中止しました" Exit Sub End If End With For i = LBound(FileList) To UBound(FileList) 'Debug.Print FileList(i), i Call 取り込みSheet(FileList(i), i + 1) Next End Sub Private Sub 取り込みSheet(ByVal MyFileName As String, ByVal MyFileNo As Integer) Worksheets("data" & CStr(MyFileNo)).Select Cells.Delete '必要に応じて不要かも Range("A1").Select With ActiveSheet.QueryTables.Add(Connection:= _ "TEXT;" & MyFileName, Destination:=Range("$A$1")) .Name = "cell" & CStr(MyFileNo) 'cell1～cell10 まで名前 .FieldNames = True .RowNumbers = False .FillAdjacentFormulas = False .PreserveFormatting = True .RefreshOnFileOpen = False .RefreshStyle = xlInsertDeleteCells .SavePassword = False .SaveData = True .AdjustColumnWidth = True .RefreshPeriod = 0 .TextFilePromptOnRefresh = False .TextFilePlatform = 932 .TextFileStartRow = 1 .TextFileParseType = xlDelimited .TextFileTextQualifier = xlTextQualifierDoubleQuote .TextFileConsecutiveDelimiter = False .TextFileTabDelimiter = True .TextFileSemicolonDelimiter = False .TextFileCommaDelimiter = True .TextFileSpaceDelimiter = False .TextFileColumnDataTypes = Array(1, 1, 1, 1, 1, 1) .TextFileTrailingMinusNumbers = True .Refresh BackgroundQuery:=False End With ' Range("E2:E400").Select ' Selection.Copy ' Sheets("計算").Select ' ActiveWindow.SmallScroll Down:=-16 ' Range("e4").Select ' ActiveSheet.Paste End Sub なお、最後のコメントアウト部分の６行が不明です。 data1～data10シートのE列を計算シートに転記されているようですが 計算シートはE4から始まって？ 各data1～data10の行は2～400で固定？
C7に数値を入れたら、人を検索し 反映させるという考えで良いんですかね？ このプログラムでやっていることは上記方法と同じだと思います。 前回の収支をトータル収支に置き換えることが出来ませんが、 それ以外はこれで大丈夫かと。 B7　　=IF(VLOOKUP(A7,$B$2:$C$3,2)<>"",VLOOKUP(A7,$B$2:$C$3,2),"") D7　=IF(OR(B7="",C7=""),"",SUM(B7:C7)) 合っているかはわかりませんが、参考まで。
質問にうまく答えられるかどうか。 >なぜ、このような式が考えられるのでしょうか？ >wkDateTime = StrDate + StrTime - TimeSerial(0, i, 0) 　↓ 時間の計算については、"Excel シリアル値"で検索してください。 この式の時間計算で、 - TimeSerial(0, i, 0)してあるのは 次の繰り返しのコードで、最初に5分加算するようになっているので、 そのぶんを引いてあります。 >If j Mod c = 0 Then >wkDateTime = wkDateTime + TimeSerial(0, i, 0) >End If 　↓ この部分はJが0,8,16...のとき、つまり8回に一度加算するようにしています。 >If TimeValue(wkDateTime) > StrTime - TimeValue("00:01") And _ >TimeValue(wkDateTime) < EndTime + TimeValue("00:01") Then 　↓ この部分は、"8時30分から12時までの間で"両端含むの処理を、 これを"8時29分から12時01分までの間で"両端含まずの処理に変えてあります。 なぜこのような処理にしたかというと、 時間の比較の=(等号)で痛い目にあったので、 マイルールで、時間の比較は、大小比較(<,>)にしています。 上記の理由 エクセルのシートに入れた時間の表示形式を標準にする その数値の一番下の桁の値をを変える そのセルの表示形式を時間に変える 見た目は同じでも、実際は違う値になっている このようなことは、オートフィルで時間を作っているとたまにある。
理屈はわかるけど、VBAなんかじゃ逆立ちしても無理 １．そもそも、ブログへのリモート投稿に、xml-rpcのような「低次元の」APIは使わない。 BloggerAPIや、Meta WeblogAPIを使うのが常識。それでも手の込んだ処理は大変。 ２．ExcelVBAに、満足に動くxml-rpcモジュールがあるとは聞いたことがない。 ３．相手がWordPressやMovableTypeならいざ知らず、国産のコンシューマブログがきちんと汎用APIに対応している？？？ １と２は、VBAでなく、VB.NETやC#を使えば可能です。 ３は知らないけど、乗り換えたほうがきっと早いです。 道具と場所を選ぼう。
VBを介さないで、FFFTP等のツールでならうまく行くのですか？
VBS なら正規表現が標準で使えるはずですので 「行単位にパターンマッチを行い、全ての該当部分を抜き出し」 が一番簡単でしょう。 正規表現: \bB=\"(.*?)\" http://msdn.microsoft.com/ja-jp/library/cc392020 … 全ての該当部分を対象 http://msdn.microsoft.com/ja-jp/library/cc392451 … パターンマッチ http://msdn.microsoft.com/ja-jp/library/cc392389 … マッチ毎に繰り返し http://msdn.microsoft.com/ja-jp/library/cc392214 … 該当部分(1番目の正規表現グループ)を抜き出す http://msdn.microsoft.com/ja-jp/library/cc392216 …
#2です。 >ファイル名中にスペースがある画像を取り込めず 僅かばかりの試験ではありますが、当方の環境(Windows7Home-64bit, xl2010-32bit）では再現されませんでしたのでお知らせします。
有償のツールしかないと思ってましたが、フリーのツールもあるみたいです。 http://ouranos.sakura.ne.jp/wordpress/2012/05/17 …
No.1．2です。 たびたびごめんなさい。 各地域ごとで男女別の合計が必要なのですね！ 前回は単に総合計だけでしたので、無視して↓のコードにしてください。 今回もSheet3を作業用のSheetとして使用しています。 Sheet1のデータは2行目以降にあるとします。 Sub Sample2() Dim i As Long, j As Long, k As Long, endRow As Long Dim c As Range, myRange As Range, wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") Application.ScreenUpdating = False endRow = wS1.Cells(Rows.Count, "A").End(xlUp).Row wS2.Cells.Clear With Worksheets("Sheet3") wS1.Range("A:A").AdvancedFilter Action:=xlFilterInPlace, unique:=True wS1.Range("A:A").SpecialCells(xlCellTypeVisible).Copy .Range("A1") wS1.ShowAllData wS1.Range("B1").Resize(, 6).Copy .Range("C1") .Range("I1") = "合計" .Range("A1").Sort key1:=.Range("A1"), order1:=xlAscending, Header:=xlYes For k = 2 To 14 .Cells(k, "B") = (k - 2) * 5 + 40 Next k .Cells(15, "D") = "合計" Set myRange = .Range("C2:H14") For i = 2 To .Cells(Rows.Count, "A").End(xlUp).Row .Range("C1") = .Cells(i, "A") wS1.Range("A1").AutoFilter field:=1, Criteria1:=.Cells(i, "A") wS1.Range("A1").AutoFilter field:=2, Criteria1:="1" .Range("C15") = .Cells(i, "A") & "男性" Range(wS1.Cells(1, "A"), wS1.Cells(endRow, "G")).SpecialCells(xlCellTypeVisible).Copy .Range("J1") For k = 2 To 14 Set c = .Range("L:L").Find(what:=.Cells(k, "B"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then .Cells(c.Row, "K").Resize(, 6).Copy .Cells(k, "C") Else .Cells(k, "C") = 1 .Cells(k, "D") = .Cells(k, "B") End If Next k With .Range("I2:I14") .Formula = "=SUM(E2:H2)" .Value = .Value End With With .Range("E15:I15") .Formula = "=SUM(E2:E14)" .Value = .Value End With .Range("C1:I15").Copy wS2.Cells(Rows.Count, "A").End(xlUp).Offset(1) .Range("J1:P14").ClearContents myRange.ClearContents wS1.Range("A1").AutoFilter field:=1, Criteria1:=.Cells(i, "A") wS1.Range("A1").AutoFilter field:=2, Criteria1:="2" .Range("C15") = .Cells(i, "A") & "女性" Range(wS1.Cells(1, "A"), wS1.Cells(endRow, "G")).SpecialCells(xlCellTypeVisible).Copy .Range("J1") For k = 2 To 14 Set c = .Range("L:L").Find(what:=.Cells(k, "B"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then .Cells(c.Row, "K").Resize(, 6).Copy .Cells(k, "C") Else .Cells(k, "C") = 2 .Cells(k, "D") = .Cells(k, "B") End If Next k With .Range("I2:I14") .Formula = "=SUM(E2:H2)" .Value = .Value End With With .Range("E15:I15") .Formula = "=SUM(E2:E14)" .Value = .Value End With .Range("C2:I15").Copy wS2.Cells(Rows.Count, "A").End(xlUp).Offset(1) .Range("J1:P14").ClearContents myRange.ClearContents Next i wS1.AutoFilterMode = False .Cells.Clear End With With wS2.Range("A:A") .Replace what:=1, replacement:="男性", lookat:=xlWhole .Replace what:=2, replacement:="女性", lookat:=xlWhole End With With wS2 .Rows(1).Delete .Range("A1").CurrentRegion.Borders.LineStyle = xlContinuous .Columns.AutoFit End With Application.ScreenUpdating = True wS2.Select MsgBox "処理完了" End Sub ※　すべての地域を羅列するようにしていますので、 時間を要すると思います。m(_ _)m
>>シート名が参照できない、というエラー（#REF）がでてしまうのですが、この点は、どう解消されましたか? 知識不足で申し訳ございません。。 それは、そのシートが無い、シート名が無いか、正しく指定していないということだと思います。 純粋に雛形となるエクセルファイルの作り方の問題だと思います。 あるいは、プログラムに誤りがあるってことでしょうね。
>>動的に作成するということでしょうか？ いえ、新しいコントロールのソースを作製、コンパイルして作るってことですから、動的ではありません。
ここと [ACC2003] MDB のレコードの並び順について http://support.microsoft.com/kb/834927/ja ここを読んで テーブルデータの並び順 http://www.naboki.net/access/achell/achell-03.html 見た目の順番で・・などというのは通用しないので ORDER BY 句で指定出来るようにテーブルのデザイン変更が必要かもですね。
publicやprivate, protectedの違いは理解しておられますか？ まだなら、先にそれらの学習をしてください。
VBA の <> は ≠ を表わす比較演算子です。 Java では != に相当します。 ですが。 VBAの 比較演算子は、 Javaでの Equals メソッドのような意味で「等しい/等しくない」を判定します。 a != "A" と ! a.Equals("A") との違いは大丈夫ですね? ついでに。 VBA の = には、Javaでの = , == (または Equalsメソッド) 2通りの使い方があって、文脈で使い分けられています。 if c=0 then ～ end if → if (c=0) {～} などとしないように注意いましょう
入力された値を「"何からの場所"に保存・起動時に読み出し」です。 "何からの場所"には、 VBの初期からある「iniファイル」と 「レジストリ」とがあります。 「VB　iniファイル　レジストリ　保存」で検索するとサンプルが探せるはずです。
Excelのバージョンは古いですが、 保存済みのクエリを指定してレコードセットを 開く場合、フィルタをかけるならば、 たとえば、住所録で住所が「東京」の 住所を求める場合、 Dim cn As New ADODB.Connection Dim rs As New ADODB.Recordset Dim varAdo As Variant Dim i As Long Dim varSheet As Variant 　　varAdo = ActiveWorkbook.Path & "\sample1.mdb" 　　cn.ConnectionString = "provider=Microsoft.jet.OLEDB.4.0;" _ 　　　　　　　　& "Data Source=" & varAdo & "" 　　cn.Open 　　rs.Source = "Q住所録" 　　rs.Filter = "[住所] = '東京'" 　　rs.CursorType = adOpenDynamic 　　rs.ActiveConnection = cn 　　rs.Open 　　varSheet = ActiveSheet.Name 　　i = 5 　　Do Until rs.EOF 　　　　With Worksheets(varSheet) 　　　　 　.Cells(i, 1).Value = rs!ID 　　　　 　.Cells(i, 2).Value = rs!名前 　　　　　 .Cells(i, 3).Value = rs!住所 　　　　 　.Cells(i, 4).Value = rs!年齢 　　　　End With 　　　　i = i + 1 　　　　rs.MoveNext 　　Loop 　　rs.Close: Set rs = Nothing 　　cn.Close: Set cn = Nothing のようにしてクエリをレコードセットとして開きます。
１）既に回答が付いてますが..... AppActivate Application.Caption の替わりに Application.Visible = True でも可能です。 ２）こちらはNo.1さんと考え方が違っていて、シートの"a1"セルの状態でセットしています。 "東京"でも"大阪"でもない時は○の状態で起動します。 Private Sub UserForm_Initialize() Debug.Print Range("a1").Value If Range("a1").Value = "東京" Then OptionButton1.Value = True End If If Range("a1").Value = "大阪" Then OptionButton2.Value = True End If End Sub
１は、シートの保護(ロック)。２は、画像のプロパティで、セルに合わせてサイズ変更をON。 ・・・で、それぞれ可能です。 AutoFilterそのものはソートとフィルタリングをするだけなので、そういう機能を持ってません。
イベントの中でReturnなりExit Subなりすればいいのでは？ Private Sub Button1_Click(ByVal sender As Object, ByVal e As EventArgs) Handles Button1.Click 　If MsgBox("CSVファイル出力しますか？", vbYesNo, "テスト") <> vbYes 　　Return 'またはExit Sub 　End if 　'CSV出力処理 End Sub
体温値の個数の上限が無いのが問題ですね。 Collectionオブジェクトを使われてはいかがですか 標準モジュールにパブリック変数として宣言 配列の添え字が患者No.になります 　　Public AA(100) As New Collection コレクションに体温値を追加 　　AA(患者No).Add(体温値) 患者No.25に体温値36.2℃を追加する場合は 　　AA(25).Add(36.2) 現在の体温値の数 　　Num = AA(25).Count 12番目の体温値を得る 　　Temp = AA(25).Item(12) 最後に測定した体温値を得る 　　Temp = AA(25).Item(AA(25).Count) Collection(コレクション)オブジェクトの詳しい使い方などはヘルプを参照してください。 また、ネット上にも解説サイトが沢山ありますので検索してください。
#3です。 最初のご質問は、当方のコレクションを組み合わせれば実現できますが、Clipboardを何度も経由して美しく無いです。Bitmap->StdPictureのコードはゴロゴロしていますが、その逆が分かりません。実は凄く簡単な事だったりして．．． Public Const PICTYPE_BITMAP = 1 Public Const CF_BITMAP = 2 Public Const IMAGE_BITMAP = 0 Public Const LR_COPYRETURNORG = &H4 Public Declare Function OpenClipboard Lib "user32" (ByVal hWnd As Long) As Long Public Declare Function CloseClipboard Lib "user32" () As Long Public Declare Function EmptyClipboard Lib "user32" () As Long Public Declare Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As Long) As Long Public Declare Function CopyImage Lib "user32" (ByVal handle As Long, ByVal un1 As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal un2 As Long) As Long Public Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long Sub test() Dim p As Object Dim fileName As String fileName = "C:\Users\??????\Desktop\hoge.jpg" On Error Resume Next Set p = LoadPicture(fileName) If Err.Number <> 0 Then MsgBox Err.Description 'ピクチャが不正です。 Else CopyBitmapPictureToCB p 'ClipboardのBitmapのPictureからはBMP形式でしか貼り付けられない ActiveSheet.Paste 'ファイルの巨大化防止のため一旦CutしてJPEG貼り付け ActiveSheet.Cut ActiveSheet.PasteSpecial Format:="図 (JPEG)", Link:=False, DisplayAsIcon:=False End If On Error GoTo 0 End Sub Private Function CopyBitmapPictureToCB(ByVal pic As Object) As Boolean Dim hBmp As Long If pic Is Nothing Then Exit Function If pic.Type <> PICTYPE_BITMAP Then Exit Function hBmp = pic.handle hBmp = CopyImage(hBmp, IMAGE_BITMAP, 0, 0, LR_COPYRETURNORG) If hBmp = 0 Then Exit Function If OpenClipboard(0) Then EmptyClipboard If SetClipboardData(CF_BITMAP, hBmp) Then hBmp = 0 CopyBitmapPictureToCB = True End If CloseClipboard End If If hBmp Then DeleteObject hBmp End Function 後ろのご質問の方は当方が眺めた範囲では、TextFrame等で持っている訳ではなさそうでした。それ以上は分かりかねます。
こんにちは。 ExcelのApplicationウィンドウのサイズ指定、という理解でいます。 残念ながらApplicationのウィンドウを固定する直接的な方法は用意されていませんので、 以下のサンプルを応用するのが直接的な解決策に当たるかと思います。 ' ' ///　Applicationウィンドウの表示サイズ指定 Sub Re8441362() 1　　With Application 2　　　　.WindowState = xlNormal 3　　　　.Top = 100　　'　　不要なら当行削除 4　　　　.Left = 150　　 '　　不要なら当行削除 5　　　　.Height = 300 6　　　　.Width = 500 7　　End With End Sub ' ' ///　Applicationウィンドウの最大化 Sub AppWnd最大化() 8　　Application.WindowState = xlMaximized End Sub ' ' ///　Applicationウィンドウの標準化 Sub AppWnd指定サイズ化() 9　　Application.WindowState = xlNormal End Sub ' '　1　With ステートメントでApplicationオブジェクトをブロック化 ' '　2　Applicationのウィンドウサイズを標準化（最大化及び最小化を解除） ' '　3　Applicationウィンドウのトップ座標を指定 ' '　4　Applicationウィンドウのレフト座標を指定 ' '　5　Applicationウィンドウの高さを指定 ' '　6　Applicationウィンドウの幅を指定 ' '　7　With ステートメントを閉じる ' '　8　Applicationのウィンドウサイズを最大化 ' '　9　Applicationのウィンドウサイズを標準化（最大化及び最小化を解除） ' '　　　最後に設定した.Top.Left.Height.Widthが踏襲される ' '　行ラベル「1-9」は解説の為のもの。実践では不要。 ' '　まず、Sub Re8441362()を実行してApplicationウィンドウ各プロパティを設定。 ' '　Sub AppWnd最大化()はApplicationウィンドウを最大化するもの。 ' '　上記の順に実行後はSub AppWnd指定サイズ化()で指定のウィンドウ状態に戻す。 /// "任意のサイズに固定したい"の"固定"という言葉に込められた意味が 序の場合は一意ではありませんが、 例えば、 「Excel（またはBook）を開く度に指定のウィンドウサイズで開きたい」 とか 「Excel（またはBook）を最後に設定したウィンドウサイズで開きたい」 等の場合は、それぞれ目的に適したイベントプロシージャから、 上記のサンプル（または同等の処理）を実行するように応用することになります。 そちらで難しいようでしたら補足してみてください。 条件が詳らかなら一度は追加にお応えします。 以上です。
はじめまして。 表示する順序は[form1]⇒[form2]でしょうか。 もしそうなら、form2をNewする際に、form1のdatagridViewのオブジェクトを 渡してしまってはどうでしょうか。 おそらくそれでform2からform1のdatagridViewを操作できると思います。 <例> ○form1側 　Dim frm as new form2(Me.datagridview) 　frm.show ○form2側 　 Private parent_datagridview as DataGridView 　Public Sub New(Byval datagridview as DataGridView) 　　　　' この呼び出しは、Windows フォーム デザイナで必要です。 　　　　　InitializeComponent() 　　　' InitializeComponent() 呼び出しの後で初期化を追加します 　　　　Me.parent_datagridview = parent_datagridview End Sub いかがでしょうか。
仕様が固まっているときに私が良く使うのは、 クラス丸ごとシリアル化 http://dobon.net/vb/dotnet/file/xmlserializer.html 自分のアプリケーションでしか使わないなら、セクション やキーすらも面倒。使いたい形のままで保存です。 お手軽だけど、バージョンアップしてドンドン設定が 追加されていく場合は、過去のデータを引き継ぐところ とかもコーディングが必要になってくるかも。 .configファイルはEXEのあるフォルダに置くと思うので、 読み取り専用の設定で使ってます。UAC対策が必須となって きていますので。 ＩＮＩファイルの利点の１つは、ユーザに直接編集して もらえる可能性が高いという点だと思っています。 ＸＭＬでは「ごちゃごちゃタグが付いたら分かり難い」 って言われてＩＮＩファイルを採用した.NETのシステム 開発も経験しました。結局お金を出してくれる人が決めた 仕様次第ですし、素人の方にはタグが付いただけで敷居が 高くなるんですよね。。。そういう意味ではＩＮＩファイル の方が優秀かもしれません。 まぁ、設定画面もフォームで作ってアプリケーションから 設定させる想定なのかもしれませんが。
こんばんは！ Sheetモジュールになりますので、 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面に ↓のコードをコピー＆ペーストしてA1セルにデータを入力してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$A$1" Then If Target = 111 Then MsgBox "○○" End If End If End Sub 次にA1～A3セルに場合は Private Sub Worksheet_Change(ByVal Target As Range) If Intersect(Target, Range("A1:A3")) Is Nothing Or Target.Count <> 1 Then Exit Sub If Target = 111 Then MsgBox "○○" End If End Sub こんな感じではどうでしょうか？ ※　両方ともChangeイベントになりますので、同居はできません。 どちらか一方のコードで試してみてください。m(_ _)m
>、実はそのアルゴリズムを習得するのが、プログラミング上最も時間や労力を裂かなければならない部分なのでしょうか？ 本質はそうだと思います。 ただ、それぞれの言語ごとの決まり事を覚えるのにも労力がかかり、障害になるのは確かでしょうね。
あとね、ペーストが無いよ。 copyしただけじゃダメ。クリップボードへコピーした「内容」をどこかに「貼付」しないと。 Endwithの次行がソレだったんだろうけど。 再度、「マクロの記録」でコードを自動生成させたほうが良さそう。
まずはピクチャーボックスに画像を表示しましょう http://homepage1.nifty.com/rucio/main/shokyu/jug … 次は右クリックのイベントを受けます http://homepage1.nifty.com/rucio/main/technique/ …
breakで一番内側のswitch, for, while, do whileの制御を抜けます。 for(i=0; i<10; i++){ 　if(i=5){ 　　break; 　} } 　
*: 最長一致 *?: 最短一致 *+: 後戻りしない最長一致 というようなバリエーションが、あります。 * に対してと同じように、?、{m,n} にも同じバリエーションがあります。
まず、これ、Visual Basicのカテゴリーに投稿されていますが、 Visual Basic ではありませんよね? Visual Basicで無いのなら、具体的な言語を書いてもらわないと困ります。 「プログラムの終了」だと「アプリケーション全部の終了」と受け取れます。 そうなると、折角変更したtextbox.textを読む時間もなく画面から消えてしまうことになるのですが、それでいいのですか? 具体的に「終了」させたいのはどこなのでしょうか? try節だけを抜ける(goto ednfinishと同等にする)のなら ・catchと同じ処理をしているのだから、 throw で例外を投げてcatchで処理させる ・try { do{～}while(false) } catch{} のように、tryの中を「1回しか実行しないループ」にして、breakで「ループを抜ける」 ・finallyが無い、かつ、endnfinishの後ろに処理が無い、 なら、 return ・そもそも、こんな大きなtryが必要なのか、A!=Bの判定はここでなければならないのか、等、処理全体の流れを再検討する 等が考えられます。
int a = 1; // AW6の値 int b = 2; // チーム!H51の値 int c = 3; // チーム!G51の値 int d = 0: // 結果格納場所 if (a <= b) { 　if (a >= c) { 　　d = 0; 　} else { 　　d = a - c; } else { 　d = a - b; } もしくは d = a <= b ? (a >= c ? 0 : a - c) : a - b;
SerialPort1_DataReceivedイベントは、シリアルポートに最初の１バイト目が受信された時に発生する。 だから、SerialPort1.BytesToReadを取得した瞬間は、まだデータを受信中の可能性がある。 実際に読込んだバイト数は、SerialPort1.Read()の戻り値で確認できる。
> すべてのキー行のセルの値が一致する列同士を比較 する方法があるのですが、 dfでそれを例示すれば良いのに。 「配列に格納して比較」ということなら、UsedRangeでは無く、 御自身で範囲選択して、Selectionを指定するとか。
こんばんは .NET VBでCSVファイルの処理をする場合はReadLineとSplitはコンビで使用することが多いです。 Do Untilは基本的なループですので、今回はReadLineとSplit、Do Untilでサンプルを作成しました。 ＞一行目を飛ばし line = reader.ReadLine を一行いれて何もしなければ、やり過ごせます(一行とばし） サンプルのｃｓｖファイルの内容は 一行目,100 二行目,200 三行目,300 四行目,400 五行目,500 にしてます。 Public Class Form1 Private Sub f() Handles MyClass.Shown Dim reader As New IO.StreamReader("C:\test\test.txt", System.Text.Encoding.GetEncoding("shift-jis")) Dim line As String 'ファイルの一行 Dim itm() As String '行の項目の配列 line = reader.ReadLine '一行読んで何もしない line = reader.ReadLine '次の一行を読む Do Until IsNothing(line) 'lineがなくなるまでループ itm = line.Split(",") 'カンマで区切る 'ListBoxに表示 ListBox1.Items.Add(itm(0) & "は" & itm(1)) line = reader.ReadLine '次の一行を読む Loop reader.Close() End Sub End Class ReadAllLinesを使うと配列になりますので簡単ですが、基本はReadLineを使ってループしながら配列の項目を処理していく方法です。
> getElementsByIdでも同じメッセージが出ます。 getElementByIdというメソッドはありますが、getElementsByIdというメソッドはありません。 getElementById → 単一の要素を返すので単数形(Element) getElementsByTagName → 配列を返すので複数形(Elements) 打ち間違えはありませんか？ 以下を【コピペして】試してください。 For Each a In ie.Document.getElementsByTagName("A") urls.Add a.href Next
質問サイトでは頻繁に「一括」でというのを目にしますが PCは人間の頭で思っていることをそのまま実行できるわけではありません。 １つづつチェックをしなければなりませんが、PCなら一瞬で終わります。 コードを考えて試行確認する時間をかけるよりも、私なら手作業でやります。 画像の数がどれくらいあるのかわかりませんが、 ２つのファイルを並べて作業すれば１～２時間でできるのでは？ 下のshp.Type = msoPictureで判定してみて不具合があればまた考え直してみてください。 他ファイルへのコピーは自分で考えてみてください。 Sub test1() Dim shp As Shape Dim i As Long For i = 1 To ActivePresentation.Slides.Count With ActivePresentation.Slides(i) For Each shp In .Shapes If shp.Type = msoPicture Then MsgBox i & " " & shp.Name　'確認 End If Next End With Next End Sub
VB Editor メニュー [ツール]-[VBA Project のプロパティ] を選択してプロパティを表示させる。 [保護] のタブを選択し、[プロジェクトを表示用にロックする] にチェックを入れ、パスワードを入力。 こうすると VB Editor までは表示されるが、プロジェクトの中身を開こうとするとパスワードを求められるようになる。 ショートカットキーで VB Editor を表示させるとエラーになる件は、どういう状況なのか不明なので回答は割愛させていただきます。
[テキストボックスをアクティブにする方法]って、、、 ただフォーカスを移動しておけばいいだけのように思いますが。 TextBox1.Focus()
スタイルとしてvbMsgBoxHelpButtonを指定した場合、表示されるボタンに「ヘルプ」ボタンが追加されます。 つまり、同時にスタイルとしてvbYesNoCancelなどを指定した場合にはその3個+ヘルプの1個で合計4個のボタンが表示されます。 ……ということが以下のURLから読み取れるけど、これで合ってるかな？ http://msdn.microsoft.com/ja-jp/library/cc343997 …
本番データでも確認されたのでしょうか？ 当方、きれいな一貫性のある統一されたフォーマットではない場合が ありましてあの時は本当に手こずりました。 ODBCの場合は、OSの32/64bit × Officeの32/64bit の組み合わせに 応じたDSNの変更をする必要がある場合があります。 回答しましたのはOLEDBによるものなので、 その心配は無い筈です。 Excel2007/2010なら問題ないかと思います。2013は未検証です。 ※たまに間違ったことを言いますので鵜呑みにしないでくださいまし。
>最初のNo=3 最後のNo=4 という風に知らせるようにしたいです。 例を見る限りでは　最後のNo=5 では Private Sub CommandButton2_Click() 　　Dim myDic As Object 　　Dim c As Range 　　Dim myStr As String, mykey As String 　　Dim v As Variant 　　Set myDic = CreateObject("Scripting.Dictionary") 　　With Worksheets("Sheet1") 　　　　For Each c In .Range("A1", .Cells(Rows.Count, "A").End(xlUp)) 　　　　　　myStr = c.Offset(, 1).Value & "と" & c.Offset(, 2).Value 　　　　　　If myDic(myStr) = "" Then 　　　　　　　　myDic(myStr) = c.Value 　　　　　　Else 　　　　　　　　myDic(myStr) = myDic(myStr) & vbCrLf & c.Value 　　　　　　End If 　　　　Next 　　End With 　　mykey = Me.ComboBox1.Text & "と" & Me.ComboBox2.Text 　　If myDic.Exists(mykey) Then 　　　　v = Split(myDic.Item(mykey), vbCrLf) 　　　　MsgBox "最初のNo=" & v(0) & vbCrLf & _ 　　　　　　"最後のNo=" & v(UBound(v)) 　　Else 　　　　MsgBox mykey & " は、見つかりません。", 16 　　End If 　　Set myDic = Nothing End Sub
多分、回答ではないです。。。 Windows7 なら 「パスとしてコピー」ではダメ？ http://technet.microsoft.com/ja-jp/windows/win7_ … notnot さんの回答のように、SendTo フォルダに置くとか？ http://oshiete.goo.ne.jp/qa/7534884.html VBS自体、ウィンドウを持たないので、HTA でそれっぽくしてやって そこへドラッグ・・ということ？ これに関しては分かりませんです。 退散退散
SQL*Plusをドコで動かしたのか、にもよるのかも。 サーバのポートが閉塞されているのかも。 参考URL：http://otndnld.oracle.co.jp/document/products/or …
despite0614様 はじめまして。 やはり細かく文字をチェックするのは正規表現が良いと思います。 If Not (System.Text.RegularExpressions.Regex.IsMatch _ 　　　　　(TextBox1.Text, "^[-+]?[0-9]+(\.[0-9]+$|$)")) Then 　　MsgBox("不正な値です", vbExclamation, "ERROR") End If または If Not (System.Text.RegularExpressions.Regex.IsMatch _ 　　　　　(TextBox1.Text, "^[-+]?\d+(\.\d+$|$)")) Then 　　MsgBox("不正な値です", vbExclamation, "ERROR") End If 文字のチェック内容を簡単に説明すると ・先頭は(+ または -) が「あるか」または「ないか」 ・次は必ず数字が１文字以上ある ・その後は 　小数点があれば必ず１文字以上の数字がある　または 　何もない（文字が終わり） 正規表現を勉強すれば、入力文字を簡単に細かくチェックできます。　
（１） >マルチページが埋め込まれているExcelファイル を閉じるためには、下記の記述が必要です。 ThisWorkbook.Close SaveChanges:=False (あるいはTrue) （２） EXCEL.EXEを終了させるためには、下記の記述が必要です。 Application.Quit 他に開いているExcelファイルがあれば、（１）を実行し、 ThisWorkBookのみであれば、（２）を実行するようにすれば よろしいかと思います。 ちなみに、ThisWorkBookを閉じる前に Application.Visible = True を設定した方がよろしいかと思います。
こんばんは！ 一例です。 ↓の画像で左側がSheet1で右側がSheet2とします。 尚、Sheet3を作業用のSheetとして使用していますので、Sheet3は全く使用していない状態にしておいてください。 標準モジュールです。 Sub Sample1() Dim i As Long, cnt As Long, endRow As Long, wS1 As Worksheet, wS2 As Worksheet, wS3 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") Application.ScreenUpdating = False wS2.Cells.ClearContents wS1.Range("A:A").AdvancedFilter Action:=xlFilterInPlace, unique:=True wS1.Range("A:A").Copy wS3.Range("A1") wS3.Range("A:A").Sort key1:=wS3.Range("A1"), order1:=xlAscending, Header:=xlYes wS1.ShowAllData For i = 2 To wS3.Cells(Rows.Count, "A").End(xlUp).Row wS1.Range("A1").CurrentRegion.AutoFilter field:=1, Criteria1:=wS3.Cells(i, "A") wS1.Range("B:F").Copy wS3.Range("B1") endRow = wS3.Cells(Rows.Count, "B").End(xlUp).Row Range(wS3.Cells(1, "B"), wS3.Cells(endRow, "F")).Sort key1:=wS3.Range("B1"), order1:=xlAscending, Header:=xlYes, _ key2:=wS3.Range("C1"), order1:=xlAscending, Header:=xlYes wS3.Range("B1") = wS3.Cells(i, "A") endRow = wS3.Cells(Rows.Count, "B").End(xlUp).Row If wS2.Cells(Rows.Count, "A").End(xlUp).Row > 1 Then cnt = wS2.Cells(Rows.Count, "A").End(xlUp).Row + 1 Else cnt = 1 End If Range(wS3.Cells(1, "B"), wS3.Cells(endRow, "F")).Copy wS2.Cells(cnt, "A") Next i With wS2.Range("A:A") .Replace what:=1, replacement:="男性", lookat:=xlWhole .Replace what:=2, replacement:="女性", lookat:=xlWhole End With wS1.AutoFilterMode = False wS3.Cells.Clear Application.ScreenUpdating = True MsgBox "処理完了" End Sub こんな感じではどうでしょうか？m(_ _)m
「"0" & Hex(buf)」でできる文字列の右側2文字を取ればOKです。 S_JIS = Right("0" & Hex(buf), 2) "0" & Hex(255) → "0FF" 右側2文字を取ると"FF" "0" & Hex(5) → "05" 右側2文字を取ると"05"
No.2です。 質問の意味を勘違いしていました。申し訳ありません。 No.1の方のおっしゃる通りだと思います。 他の方法としては、メールの表題・添付ファイルごとに受信時刻(objMsg.SentOn)を記憶しておき、受け取ったメールの受信時刻が新しい場合のみ保存するようにしてはどうでしょうか。
shintoshin258さん こんにちは。 多分、皆さん誰も何が問題かわからないと思います。 失礼ですが、VBAは初心者ですか？ 問題点が絞られているのなら、ご自身でセルB3の内容を確かめれば良いことだけです。 回答者はセルB3に何が入っているのか分かりませんので… 【一応質問に対しての回答ですが】 「ThisWorkbook.Sheet1.Range("B3").Value」が正しいですか？とのことだと思います。 完璧に正しいです。 Sheet1が初期のままで、修正していなければOKのはずです。 確認するとしたら、VBE画面の左にツリーでVBAProject--Sheet1(Sheet1)になっていると思います。 括弧の中がシートタブの名前で、左側のSheet1がオブジェクト名です。 【問題があればデバッグすれば良いです】 イミディエイト（ウィンドウ）があるかと思います。…表示されていなければctrl+Gで表示して下さい。 そこで　? ThisWorkbook.Sheet1.Range("B3").Value と入力して　Enterを押せばセルB3の 値が表示されると思います。 その値を確認して下さい。 注）？　は　Print と同じです。 ちなみに「ChDir "C:\Users\H1250-201\Desktop"」の命令を実行していますが、意味がないです。 Workbooks.Open Filename:="C:\Users…とフルパスを指定していますので、Chdirは必要ありません。 またまた「ちなみに」となりますが、 「ChDir "D:　…」も意味がありません。 ChDirを行う前に【ChDrive "D" 】をしないと意味がありません。 申し訳ありませんが、もし初心者の方なら一つずつ命令の意味や作用を丁寧に理解しないと、無駄で雑で分かりにくいプログラムになってしまいます。 頑張って勉強して下さい。　
どちらにせよ言っていることがめちゃくちゃです。 WebBrowserからのリクエストに対して指定したレスポンスを返したいということであれば、 HTTPサーバ(目的によってはプロキシサーバ)を立ててください。 (今の知識では少し難しいかもしれませんが……)
クリックした直後は画面の更新が完了していないのでエラーが発生します。 画面が完了するまでの時間はネットワークの込み具合などによって大きく変わりますので、固定した時間待つのではなく、IE.Busy や IE.Document.ReadyState などをチェックするようにしてください。 Webページによってはそれでもうまくいかない場合がありますので、臨機応変に工夫が必要となります。
VBEを使って、ある程度マクロを書いている　という前提でお話します。 ・モジュールとは書くトコです。 いつもは『標準モジュール』に書いていると思います。 ココは自由に書いていい場所なんで「どこのシートから呼び出してもいいですよ」ということです。「他のブックからもジャンジャン呼び出して下さい」ということです。 ブック…(エクセルファイルのことを「ブック」と言います) -- ・オブジェクトとはブックとかシートとかのことです。 ゲームで出てくる、木のオブジェクトとかオブジェクト破壊とかいう言葉と同じです。セルとかもオブジェクトの一部です。まぁ部品という意味です。 -- ・イベントとは、何か操作をした瞬間に(勝手に)動かしますよ。ってマクロです。 膝のお皿を叩くと「ピコンッ」て(絶対)足が動いてしまうのがイベントです。 足を自分で動かすのが普通のマクロです。 -- ThisWorkbookというモジュールに書くと、ブックが開いた時や閉じた時、保存した時に動くイベントとなります。 各シート名のモジュール(Sheet1(Sheet1)とか)に書くと、そのシートを開いた時やシート内のセルを変更した時に動くイベントになります。 それぞれVBEの「標準モジュール」の上の「Microsoft Excel Objects」というフォルダにあります。 ココにマクロを書いてもいいんです。 -- 「イベントを利用するマクロはオブジェクトのモジュールに記述する」 　↓ 「なんかした時に勝手に動くマクロは、標準モジュールじゃなくてシートとかのモジュールに書いてね」
あ、しまった。 frag初期化するの忘れてました。 ■修正版 ------- Sub sample() Dim u As Integer, o As Integer, c As Range, frag As Boolean Application.Calculate For u = 2 To 3 For o = 7 To 2000 frag = False If Cells(u, o) = "" Then Range("G2").Select Range("G2").End(xlToRight).Select If Selection.Value <> "" Then ActiveCell.Resize(6, 5).Select For Each c In Selection If c.Value <> "" Then frag = True Exit For End If Next If Not frag Then Exit Sub End If Else Exit Sub End If Selection.Cut Range("B2").Select Range("B2").End(xlDown).Select ActiveCell.Offset(1).Select ActiveSheet.Paste End If Next o Next u End Sub
”Nextに対するForがありません。”とでます。 なぜこうなるのか教えてください。 に対する回答は出ていますが、 G2～列2000の間が空白になるまで、 　下記の処理を続けるようにしたいと思っています。 は大丈夫？ Ｆｏｒ　と　Ｄｏの二重のループも必要？ For i = 7 To 2000 Step 5 If Cells(2, i) = "" Then Exit For Cells(2, i).Select ActiveCell.CurrentRegion.Resize(6, 5).Select Selection.Cut Range("B2").End(xlDown).Select ActiveCell.Offset(1).Select ActiveSheet.Paste Next i Cells(2, i).Select ActiveCell.CurrentRegion.Resize(6, 5).Select Selection.Cut も Cells(2, i).CurrentRegion.Resize(6, 5).Cut と１行にまとめたりも出来ます。
With ActiveSheet.Buttons.Add(0, 0, 100, 100) .Name = "シェイプ名" .Caption = "ボタンに表示する文字列" .OnAction = "マクロ名" .Characters.Text = "ボタンに表示する文字列"　'これでもいい .Font.Name = "ＭＳ ゴシック"　'フォント .Font.ColorIndex = 3　'フォントカラー .Font.Size = 20　'フォントサイズ End With -- With ActiveSheet.Shapes("シェイプ名") .Font.ColorIndex = 10 End With だと動かないのに、 ActiveSheet.Shapes("シェイプ名").Select With Selection .Font.ColorIndex = 10 End With だと動くのはよく分からないけど…。 -- ・フォームボタンでは背景色は変えられないそうです。 http://q.hatena.ne.jp/1195523296
#5です。 getElementsByClassNameはIE9以降しか使えないそうです。 IEも9以降からようやく世間並みになってきている様ですね。とはいっても、VBAからActiveXとして利用するには、他に選択肢はありません。 JavaScriptであれば、IE8以下でgetElementsByClassNameを代替するライブラリが多々あるそうですが、VBAから使うにはそういう訳にもいきません。下記リンクの記事の関数はVBAに載せ替えられそうな気がします。IE8以下しか使えない事情がある場合のご参考まで．．． http://t87r.wordpress.com/2011/02/13/getelements …
Sub 当期(cellno1 As Long, cellno2 As Long, cellno3 As Long, kamoku As String, karikatakamoku As String, kasikatakamoku As String, tekiyou As String, kurikosi As Long) の引数が、足りていません 後、このサブのend ifが一つ足りません。
textBox1.SelectedText = button1.Text のようなコードでできると思います。 この場合、カーソル位置は挿入文字の直後に置かれて選択長はなしになるので、 キーボードからの入力と"ほぼ"同じ動作になります。 ※Undo等はできないので厳密には同じになりません。 参照URLも合わせてご参考ださい。 参考URL：http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.90).aspx?cs-lang=vb
試しにやってみました。ご参考まで。 'Unicodeの文字コードを調べる Sub test() Dim buf As String Dim i As Long buf = Range("A1").Value For i = 1 To Len(buf) Debug.Print Hex(AscW(Mid(buf, i, 1))) Next i End Sub 'C77C 'BCF8 Sub test2() Dim buf As String buf = ChrW(&HC77C) & ChrW(&HBCF8) Range("A1").Value = Replace(Range("A1").Value, buf, "日本") End Sub 'VBEでの表記はやめてセルに入れた値を用いる案 Sub test3() Range("A1").Value = Replace(Range("A1").Value, Range("A2").Value, "日本") End Sub
こんにちは ＞WebBrowser1をキャプチャ WebBrowserはキャプチャすると何かと問題が発生します。 サンプルを作成しましたが、おそらくフレームなどのタグがあるとNGになると思います。 サンプルではスタートアップフォームをMDIParent1にしてあります。 MDIParent1のコードの一番したに下記のコードを追加します。 Private Sub MDIParent1_Shown(sender As Object, e As EventArgs) Handles MyBase.Shown Dim f1 As New Form1 Me.IsMdiContainer = True f1.MdiParent = Me f1.Show() End Sub Class Form1側 Public Class Form1 Private Sub f() Handles MyBase.Shown WebBrowser1.Navigate("http://oshiete.goo.ne.jp/qa/8408324.html") End Sub Private Declare Function PrintWindow Lib "User32" (ByVal hWnd As IntPtr, ByVal hdcBlt As IntPtr, ByVal nFlags As Integer) As Boolean Private Sub キャプチャToolStripMenuItem_Click(sender As Object, e As EventArgs) Handles キャプチャToolStripMenuItem.Click 'Bitmapオブジェクトを作成 Dim space As New Bitmap(WebBrowser1.Width, WebBrowser1.Height) '画像をbmpに代入 Using bmp As Graphics = Graphics.FromImage(space) Dim hDC As IntPtr = bmp.GetHdc() PrintWindow(WebBrowser1.Handle, hDC, 0) bmp.ReleaseHdc(hDC) End Using '保存 space.Save("C:\test\web.bmp") space.Dispose() End Sub 'ファイルの表示 Private Sub 表示ToolStripMenuItem_Click(sender As Object, e As EventArgs) Handles 表示ToolStripMenuItem.Click Process.Start("C:\test\web.bmp") End Sub End Class
>色がついたセル(土・日・祝)のE行に”０”を自動で入力したいと考えています。 http://oshiete.goo.ne.jp/qa/8404255.html こちらの関連なのでお答えしますが、毎回マクロボタンを押して実行するのではなく 日付が変われば自動的に実行されるようにしてみましょう まず日付ですが上記のスレッドで示された （Ａ６からＡ３６までに2013/12/28などの情報があります） とのことなので、まずA6には2013/12/1などと入力できるようにしておき A7セル以降は上のセル+1(=A6+1)の数式をいれてA6の値が変われば A36までの日付が変わるようにしておきましょう。 今回は、特定のセル(A6)の値が変われば自動的にマクロが実行される Changeイベントを使います。コードを書く場所は標準モジュールではなく シートモジュールに書きます。(シートモジュールはご自分でググってください。) Private Sub Worksheet_Change(ByVal Target As Range) 　　Dim c As Range 　　'A6セル以外は値が変わってもマクロは起動しません 　　If Target.Address <> "$A$6" Then Exit Sub 　　'前回の直線を削除 　　Me.Lines.Delete 　　'前回の○印を消去 　　Range("E6:E36").ClearContents 　　For Each c In Range("B6:B36") 　　　　If Weekday(c.Offset(, -1).Value) = 7 Or _ 　　　　　　　　Weekday(c.Offset(, -1).Value) = 1 Or _ 　　　　　　　　Application.CountIf(Worksheets("Sheet2").Range("B2:B72"), c.Offset(, -1)) = 1 Then 　　　　　　With ActiveSheet.Shapes.AddLine(c.Left, c.Top + c.Height / 2, c.Offset(, 13).Left, c.Top + c.Height / 2) 　　　　　　　　.Line.ForeColor.SchemeColor = 10 　　　　　　End With 　　　　　　c.Offset(, 3).Value = "○" 　　　　End If 　　Next End Sub
■iが3の時に処理を止めてVBEなどで状況を知りたい For i = 1 To 10 If i = 3 Then Stop Next ■iが3の時にForを抜けて、その後の処理をしたい For i = 1 To 10 If i = 3 Then Exit For Next ■iが3の時にマクロ(sub)を抜けたい For i = 1 To 10 If i = 3 Then Exit Sub Next ■iが3の時に呼び出し元も全部抜けたい For i = 1 To 10 If i = 3 Then End Next
>祝日は、違うシートに書き出して、条件に=COUNTIF(シート名!$B$2:$B$72,$A6)=1 >（Ｂ２：Ｂ７２まで祝日等のデータあり）を入れています。 Dim c As Range '前回の直線を削除 ActiveSheet.Lines.Delete For Each c In Range("B6:B36") 　　If Weekday(c.Offset(, -1).Value) = 7 Or _ 　　　　　　Weekday(c.Offset(, -1).Value) = 1 Or _ 　　　　　　Application.CountIf(Worksheets("シート名").Range("B2:B72"), c.Offset(, -1)) = 1 Then 　　　　With ActiveSheet.Shapes.AddLine(c.Left, c.Top + c.Height / 2, c.Offset(, 13).Left, c.Top + c.Height / 2) 　　　　　　.Line.ForeColor.SchemeColor = 10 　　　　End With 　　End If Next
Excel2007や2003で作ったShapes(クリップアート、図形、ワードアート)を含むファイルを Excel2010で開くと保存できなくなることがあります。 該当すると思われるShapesを削除すると保存できるようになります。 そのShapesは作りなおすしかありませんが…。
VBのバージョン書いてないからアレだけど。 CSVを読み込むどうこうは関係ない。 「一定時刻にイベントを発生させるためにはどうすれば良いか？」でしょう。 Timerコントロール(VB6),Timerコンポーネント(VB2008) じゃないですか？
akichan1jp さん こんにちは。 次のプログラムでできると思います。 Sub test() 　TEMP = Worksheets("Sheet1").Range("C3") 　ReDim BIN(Len(TEMP) / 2 - 1) As Byte 　For I = 1 To Len(TEMP) Step 2 　　　BIN((I - 1) / 2) = Val("&H" & Mid(TEMP, I, 2)) 　Next I 　Open "1.BIN" For Binary As #1 　Put #1, , BIN 　Close #1 End Sub 注）"1.BIN"は事前に削除した方が安全です。 　　例えばファイルの大きさが小さくなると、前のファイルの大きさがに維持されてしまいます。 　　ご注意ください。 ご確認下さい。
モジュールのコピー（インポート）、削除をコードで記述すると下記のようになります。 ご参考まで。 Sub impmodule() '任意のフォルダにあるモジュールファイル Module1.bas をプロジェクトにインポートする ThisWorkbook.VBProject.VBComponents.Import "C:\work\Module1.bas" ThisWorkbook.Save End Sub Sub delmodule() 'プロジェクト内にあるモジュール Module1 を削除する ThisWorkbook.VBProject.VBComponents.Remove ThisWorkbook.VBProject.VBComponents("Module1") ThisWorkbook.Save End Sub
指定のセルをC3とし、そのシート名をAA あるフォルダ名をXXX、画像ファイルをYYYとして 構文を書きます。参考にして下さい。 Sheets(AA).Select Range("C3").Select Sheets(AA).Pictures.Insert(XXX & "\" & YYY) 貼付した画像のサイズを調整したい場合 Sheets(AA).Pictures.Insert(XXX & "\" & YYY).Select とし、 Selection.ShapeRange.Height=375(画像の縦長) Selection.ShapeRange.Width=250(画像の横長) とすれば任意のサイズに調整出来ます。 貼付位置をセルとせず、所定の位置(シート最左上を原点として、) Selection.ShapeRange.IncrementTop=400 Selection.ShapeRange.IncrementLeft=300 「375,250,400,300」はピクセル値でmmではありません。 予め位置とサイズを定めるためのサンプルを作り、 次の構文で位置とサイズを確認すること(ピクセル値)も出来ます。 Dim ZZZ,T,L,H,W For Each ZZZ In Sheets(AA).Shapes T = ZZZ.Top L = ZZZ.Left H = ZZZ.Height W = ZZZ.Width Next
vbLfだけでいいのですか？ それなら 　IN_名称 = IN_名称.Replace(vbLf, "") で削除できそうな気がしますが、いかがでしょう？ vbCrも削除するなら 　IN_名称 = IN_名称.Replace(vbCr, "").Replace(vbLf, "") で。
#2のかたの回答でよいかと思いますが、一点、気になり投稿しました。 それは、「入力された値が数字(0～9）かそうじゃないか判定」の意味が、 例えば以下のような値をＯＫとするかどうかです。 (1)　+12345　　　　　　　・・・先頭に＋の符号付 (2)　-12345　　　　　　　・・・先頭に－の符号付 (3)　12345678901　　　　　・・・１１桁の数字 (1)、(2)は、int.TryParseを使用するとＯＫ（数字）となります。 (3)は、int.TryParseを使用するとＮＧ（数字以外）となります。 もし、上記の結果があなたの望んだ結果出れば、特に問題ありません。（以降は読み捨ててください） しかしながら、数字（0～9）かどうかの観点で考えると、(1)(2)はＮＧであり、(3)はＯＫとなります。 もし、(1)(2)をＮＧとし(3)をＯＫとしたいなら、int.TryParseを使用してはいけません。 そもそも、int.TryParseは、文字列をint型の整数に変換できるか否かのチェックをおこなう機能です。 従って、+12345は、正の12345であり、-12345は負の12345の為、int型の数値に変換可能です。 12345678901は、11桁の数字の為、int型の整数に変換できません。 int型整数が格納できる数値の範囲は、-2147483648～+2147483647です。 従って、11桁の数字は格納できないため、TryParseでエラーとなります。 では、(1)(2)をＮＧとし(3)をＯＫとする為には、どうするかというと、 #1のかたのように正規表現を使用します。以下、正規表現を使用したコードです。 ------------------------------------- Regex reg = new Regex(@"^\d+$"); string str = "+12345"; bool ui = reg.IsMatch(str); if (ui == true) { Console.WriteLine("<"+str+">OK"); } else { Console.WriteLine("<"+str+">NG"); } str = "12345678901"; ui = reg.IsMatch(str); if (ui == true) { Console.WriteLine("<"+str+">OK"); } else { Console.WriteLine("<"+str+">NG"); } ------------------------------------- 実行結果 <+12345>NG <12345678901>OK 上記の正規表現は、文字列が数字（0～9）のみで構成され（＋，－はＮＧ）、 数字が1文字以上であれば、ＯＫとなります。（何桁であってもＯＫです）
セルが編集中のとき、VBAの制御が及ばないので、お望み通りの事は難しいと思いますが、 ワークシートにチェックボックスと、テキストボックスを一個ずつ置いて、 セルが編集状態になる前にクリップボードに、テキストボックスの内容を転送しておき、 セルの編集中にCtrl+Vのショートカットで貼り付けられる様にするという案はいかがでしょうか。 チェックボックスは上記操作のOn-Off用です。 実用にはSelection_ChangeのEventが有効になるセル範囲を設定する必要があると思いますが、アイデアの提示に止めます。 Microsoft Forms 2.0 Object Libraryを参照設定要です。下記リンク先をご覧下さい。 http://officetanaka.net/excel/vba/tips/tips20.htm '☆Sheetモジュール Private Sub Worksheet_SelectionChange(ByVal Target As Range) Dim buf As String Dim CB As New DataObject If Me.CheckBox1.Value = False Then Exit Sub If Me.TextBox1.Value = "" Then Exit Sub With Me .CheckBox1.Top = Target.Top .TextBox1.Top = Target.Offset(2, 0).Top buf = Me.TextBox1.Value End With With CB .SetText buf .PutInClipboard End With End Sub
AELAFAYQDIZ さん こんにちは。 確かに中断のキーが効く場合と効かない場合がありますね。 私もはっきりしていません。 単純には「キーボードを受け付けない状態の処理をしている」とのことだと思います。 よって「何故効かないのか」では無く「効く」ようにできないかをを考えたほうが良いかも知れません。 、 １．ループ命令の中の「DoEvents」を追加する。 　　DoEventsを入れることにより、キーボード入力を受け付けるようになります。 　　　Sub TEST() 　　　　Do 　　　　　DoEvents 　　　　Loop 　　　End Sub ２．中断の方法を選ぶ 　中断には３種類あるかと思います。 　　・Escキーによる中断 　　・Ctrl + Break キー　による中断 　　・VBEの中断ボタン　による中断 　「Escキー」より「Ctrl + Break キー」の方が一般的で中断が効きやすいと思います。 以上、色々と試してみて下さい。
No3の補足です 単語が見つかったらそれ以上探さなくていいわけでExit Forが抜けてました。 If InStr(Range("B" & i).Value, c.Value) Then 'Hrefを設定する。 Exit For End If
ActiveCell左右に空白があるのかないのかで結果が違ってきますが。 一応、２つパターンで Sub ボタン1_Click() '左右に空白があって、空白の手前の列 MsgBox ActiveCell.End(xlToRight).Column MsgBox ActiveCell.End(xlToLeft).Column '空白があっても最も右の列 MsgBox Cells(ActiveCell.Row, 1).End(xlToRight).Column 'Ａ列が空白で、最も左側の列 MsgBox Cells(ActiveCell.Row, Columns.Count).End(xlToLeft).Column End Sub
VBAじゃなくってVBの記事なんですけど、 http://msdn.microsoft.com/ja-jp/library/thwcx436(v=vs.90).aspx の「書式」のところに > 文字列の 1 文字として二重引用符を含める場合は、二重引用符を 2 つ続けて ("") 記述する必要があります。 VBAのヘルプの文字列のところに同様のことが書いてないでしょうか？
Sub Sample() Dim nStart As Variant Dim nEnd As Variant nStart = Time() ’24時をまたぐならNow（） nEnd = Time（) ’24時をまたぐならＮｏｗ() Debug.Print format(nEnd) - nStart， ”[m]分ss秒”) End Sub か
「顧客データの金額」をどのようにデータとして持っていて、金額計算フォームを使ってどのように「顧客データの金額」を計算しているかによって対応方法が変わってきます。 ・データテーブルの構成、クエリの構成やフォームの構成がどのようになっているのか 。 ・「顧客データの金額」は、税込み金額のみをデータとして持っているのか、税抜き金額と税込み金額を両方データとして持っているか。 ・金額計算のフォームで、税抜き金額と税率から税込み金額を計算するのか。 金額計算のフォームにチェックボックスを追加したとのことですが、 チェックボックスのON/OFFで税率の切り替えを行って、「顧客データの金額」の表示を切り替えるだけなのであれば、下記の例で確認ができると思います。 ・金額計算のフォーム上にテキストボックス（非連結）を追加で貼り付けする。 　テキストボックスのラベルは仮に「税込み金額」とでも設定する。 ・「税込み金額」テキストボックスのプロパティで、コントロールソースに下記のような計算式（税込み金額の計算式）を入力する。 =[税抜き金額]*IIf([チェックボックス].Value,1.08,1.05)) 詳細な情報が不足しているため、踏み込んで具体的な案を示すことが困難ですが、多少なりとも ご参考になれば幸いです。
原因は、CursorLocation が規定値の adUseServer になっているので Rs.Filter してしまうと 正しく動いてくれません。 Set cn = CurrentProject.Connection rs.CursorLocation = adUseClient '←追加 rs.Open "テーブル", cn, adOpenKeyset, adLockOptimistic とするか Filter ではなく rs.Open "SELECT * FROM テーブル WHERE 店名 ='" & str店名 & "' and URL ='未'", cn, adOpenKeyset, adLockOptimistic 'rs.Filter = "(店名 = '" & str店名 & "') And (URL = '未')" とSQL中にWHERE句で指定します。 でも、更新クエリで片づけたほうが良さそうにも思えます。 UPDATE テーブル SET テーブル.URL = 'http' WHERE [テーブル].URL='未' AND [テーブル].店名='来々軒';
意味が通じれば何でも構わないのかもしれない・・・のかもです。 が 基本は押さえておきたいのなら↓ http://homepage1.nifty.com/tabotabo/ccc/kigo.htm # はシャープ（♯）ではないです。 フラット（♭）が「なんで俺はキーボードに無いの？」と気を悪くしています。 でも、MS社のAccess2010のVBAのヘルプにも 『倍精度浮動小数点数型の型宣言文字はシャープ記号 (#) です。』 としっかり載っているくらいですから。。。 (^_^;)
基本的には#1の方のいわれる通りなんですがProにはOfficeの使用権は付いていません。 付いてくるのはその2つ上のPremiumから。 またMSDN使うならボリュームライセンスの方がお得です。 もし学生さんならDreamSpark利用する手もありますし http://msdn.microsoft.com/ja-jp/hh455217.aspx 起業支援向けのBizSparkというのもあります。 http://www.microsoft.com/ja-jp/mic/bizspark/
IE11と言う事で「拡張保護モード」が有効になってるのではないでしょうか。 無効にされるとか。
ファイル名が fileC.gif～fileN なら Sub Test() 　　Dim c As Range 　　Dim myPath As String 　　Dim FileName As String 　　Rows("4:4").Insert Shift:=xlDown, CopyOrigin:=xlFormatFromLeftOrAbove 　　Selection.RowHeight = 150# 　　myPath = "E:\FolderA\" 　　For Each c In Range("C4:N4") 　　　　FileName = "file" & Left(c.Address(0, 0), 1) & ".gif" 　　　　With ActiveSheet.Shapes.AddPicture( _ 　　　　　　FileName:=myPath & FileName, _ 　　　　　　LinkToFile:=True, _ 　　　　　　SaveWithDocument:=False, _ 　　　　　　Left:=0, Top:=0, Width:=0, Height:=0) 　　　　　　.ScaleHeight 1!, True 　　　　　　.ScaleWidth 1!, True 　　　　　　.LockAspectRatio = True 　　　　　　.Locked = False 　　　　　　.Left = c.Left 　　　　　　.Top = c.Top 　　　　End With 　　Next End Sub
こんばんは！ 一例です。 Sub Sample1() Dim i As Long For i = Cells(Rows.Count, "A").End(xlUp).Row To 1 Step -1 If Not Cells(i, "A") Like "[一-黑]" Then Cells(i, "A").Delete shift:=xlUp End If Next i End Sub こんな感じではどうでしょうか？m(_ _)m
> where　名前=　"＋　MjstrSimei　ではだめなのでしょうか？ SQL実行前に、メッセージボックス等でSQLを表示するようにしてみてください。 その書き方では、望むSQLが発行されていないことがわかります。 "where 名前= " + MjstrSimei → where 名前= 太郎 "where 名前= '" + MstrSimei + "'" → where 名前= '太郎'
#2です。 プリンター名決め打ちで良ければもっと簡単な方法がある事が判明しました。 alternativePrinter = getPrinterPort("Microsoft Office Document Image Writer") のところは、お手元のPCにインストールされているプリンタを設定する必要があります。ダミーで使用するだけで、実際には印刷させません。 Sub MakePdf2() Dim sh As Worksheet Dim objAbDist As Object Dim strDefaultPrinter As String Dim printerList() As String Dim i As Long Dim acrobatPrinter As String, alternativePrinter As String Const destFolder As String = "E:\pdfTest" acrobatPrinter = getPrinterPort("Adobe PDF") alternativePrinter = getPrinterPort("Microsoft Office Document Image Writer") Set objAbDist = CreateObject("PdfDistiller.PdfDistiller.1") strDefaultPrinter = Application.ActivePrinter Set sh = ActiveSheet Application.ActivePrinter = alternativePrinter Application.ActivePrinter = acrobatPrinter Application.ScreenUpdating = False sh.PrintOut Copies:=1, preview:=False, _ printtofile:=True, Collate:=True, prtofilename:=GetDesktopPath & "\temp.ps" objAbDist.FileToPDF GetDesktopPath & "\temp.ps", destFolder & "\" & sh.Range("A1").Value & ".pdf", vbNullString If Dir(destFolder & "\" & sh.Range("A1").Value & ".pdf") <> "" Then Kill destFolder & "\" & sh.Range("A1").Value & ".log" Application.ActivePrinter = strDefaultPrinter Kill GetDesktopPath & "\temp.ps" Application.ScreenUpdating = True End Sub Function getPrinterPort(printerName As String) Dim WshShell As Object Dim regValue As String Dim buf As String Set WshShell = CreateObject("WScript.Shell") On Error Resume Next regValue = WshShell.regread("HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Devices\" & printerName) If IsNull(regValue) Then getPrinterPort = "" Exit Function End If On Error GoTo 0 buf = Replace(regValue, "winspool,", "") buf = printerName & " on " & buf getPrinterPort = buf Set WshShell = Nothing End Function Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function
どこで躓いているのか具体的にわかりませんが、他ファイルを開いて参照したい場合でも、やることは手作業ですることとほぼ同じです。 注意点が一つだけあって、「今アクティブなワークブックか」「今作業対象としたいワークブック/シートはどれか」というのをわかりやすくするための「目印」をつけることだけです。 以下のような感じだと思います。 '現在のブックと作業シート（Sheet1)をセット Set MyBook = ActiveWorkbook Set Mysheet = MyBook.Worksheets("Sheet1") Set Acsheet = ActiveSheet: 'アクティブシート（=フォームのボタンがあるシート） 'CSVのブックと対象シートをセット。 Set SubBook = Workbooks.Open("C:\test.csv"): 'ファイル/ディレクトリはダミー Set Subsheet = SubBook.Worksheets(1): 'CSVをExcelで開いた場合はシートは一つしかない=インデックスは1 'Sheet1のセルの値を全クリア Mysheet.Cells.Clear 'CSVのデータをSheet1に全コピー Subsheet.Cells.Copy Mysheet.Cells 'CSVを閉じる。 SubBook.Close 'ターゲットをボタンのあるシートに戻す。 Acsheet.Activate 以上ですが、テストはコピーしたファイルで行ってください。
Dim i As Integer Dim c As Integer Dim j As Integer j = 1 For i = 1 To 100 c = InStr(1, Cells(i, 1), "GAZOU") If c > 0 Then '見つかった Cells(i, 1) = Replace(Cells(i, 1), "GAZOU", "G" & j, , 1) j = j + 1 i = i - 1 DoEvents End If Next i こんな感じでしょうか。
> Workbooks.Open Dir+"\"+B.xlsm これエラーになりませんか? DirもDir関数があるので紛らわしいと思いますから MyFileName = MyDir & "\B.xlsm" Workbooks.Open MyFileName にしてみてください。
こちらでは再現しないのではっきりとしたことは言えませんが、 xlSheet2がNothingになっているか、 xlSheet2.Cells(I_COUNT2, 1)がNothingになっているかのどちらかです。 なぜそうなってしまっているかはわかりませんが、 他のファイルで試しても同様ですか？
Elldoradoさん 私は今Visual Studio 2013を使用しており、WIN7 64Bitで問題が出ていなくて、適切な回答ができません。 ただネットで調べると「環境設定(ディレクトリパス)が引き継がれているため…」とのことのようです。 以下のURLが参考になるかも知れません。 一度確認してみたらどうでしょうか？ http://hare.oops.jp/devlog/archives/2010/08/trac …
ループするのは必須でしょうか 追加クエリ１つでできそうですけど Dim sSql As String sSql = "INSERT INTO [作業用_▲入金DB] " _ 　　　& "SELECT * FROM ▲入金 WHERE ▲入金.請求先ID IN " _ 　　　& "(SELECT [請求先ID(13)] FROM 作業用請求先ID);" CurrentDb.Execute sSql ※ メモ帳に書いただけなので、綴りとか動作未検証
まず、Shell.Application のCopyHere ですが これがちょっと気がかりです CopyHere メソッドから Zip ファイルを処理することはできません http://support.microsoft.com/kb/2679832/ja >エクスプローラーから、ユーザー操作以外の方法で ZIP ファイルを扱うことは想定されていません。 >CopyHere メソッドを使用して ZIP ファイルからファイルを取り出したり、ZIP >ファイルにファイルを格納したりすることもサポート対象外となります。 当方Windows7 & Office2010で問題なく処理されていますが、 サポート外なので自己責任でということでしょう。 自分自身や身内の部署くらいなら構わないのでは？と思います。 パスワード付きZIP作成は、OSには準備されていないようです。 （7では、8は分かりません。私が知らないだけかもしれない・・・） なので外部のDLLを使用することになりそうです。 7z 形式でファイルをもらって解凍できなかったことがありまして その時に見つけたサイトです。 http://hatenachips.blog34.fc2.com/blog-entry-376 … サンプルコードを載せてられたり解説もされています。 そちらと当方の環境が異なるのでサイトの紹介のみとさせてください。
LOOKUP関数
これでどうかな Ws2.Range(Ws2.Cells(2, 2), Ws2.Cells(132, 134)).ClearContents '****修正 Ws2.Range(Ws2.Cells(134, 2), Ws2.Cells(264, 134)).ClearContents '****修正 With Ws2 Set SCode = .Range(.Cells(1, 1), .Cells(1, 134)) '****修正 ' ↑ここはこのように書いていただいたのから、 ' 指定の死因分類があったためシートから参照するようコードを変えています。 ' 手元にファイルが無くてかけないのが初心者の情けないところです。 ' 申し訳ありません。※シートは同一ファイル内におくようにしています。 End With r = 2 Do While Ws1.Cells(r, 1).Value <> "" If Ws1.Cells(r, 4).Value = Ws2.Cells(1, 1).Value Then If Ws1.Cells(r, 1).Value = 1 Then i = 2 '****修正 ElseIf Ws1.Cells(r, 1).Value = 2 Then i = 134 End If 'With Ws2 'Set Nenrei = .Range(.Cells(i, 1), .Cells(i + 130, 1)) 'End With 'j = i + Wsf.Match(Ws1.Cells(r, 3).Value, Nenrei, 0) - 1 j = i + Ws1.Cells(r, 3).Value '****お好みで修正 On Error Resume Next '対象死因分類がないときエラーになるので k = Wsf.Match(Ws1.Cells(r, 2).Value, SCode, 0) If Err.Number Then k = Range("EC1").Offset(, 1).Column 'k = 134 '****直前のコードでもこのコードも同じです。お好みで End If On Error GoTo 0 Ws2.Cells(j, k).Value = Ws2.Cells(j, k).Value + 1 Else End If
シェアウエアの秀丸エディタを使っていますが、grepコマンドの実行で簡単にファイル名一覧、対応行の表示、置換等が出来ます。 複数ディレクトリ、下位ディレクトリのサーチ等の指定も可能です。 数十年来使っていますが、信頼度や高速性、大容量ファイルサポートなど十分以上です。 その他==>コマンド一覧==>検索系==>grepの実行　 　で辿れますが、キー割り当てをしておけばワンアクションでgrep機能を実行可能です。 フルバージョンがお試し用としてダウンロード使用可能です。 http://www.forest.impress.co.jp/library/software … サポートフォーラムやユーザー作成のマクロ等も充実しています。 数百MBオーダーのファイルアクセス、サーチ、旧版とのファイル同士の比較などが簡単に出来ます。 http://www.maruo.co.jp/hidesoft/ http://hide.maruo.co.jp/lib/macro/index.html その他にはbutterfly_search.exe, grepreplace.exe 等も便利に使えると思われます。 フリーソフトですが、窓の杜のサイトのソフトは十分信頼して良いのではないでしょうか。 butterfly_search.exeはテキスト情報:単語等のインデックスを最初に作りますが、その後のサーチはすごく高速です。 http://www.d1.dion.ne.jp/~h_tomo/ http://www.forest.impress.co.jp/library/software …
[例1] Dim i As Long With Sheet1.Range("A1:A3") 　　For i = .Cells.Count To 1 Step -1 　　　　MsgBox .Item(i).Value 　　Next End With [例2] Dim i As Long For i = 3 To 1 Step -1 　　MsgBox Cells(i, "A").Value Next
すいません、読み込んだテキストファイルの内容を記入し忘れました。 3月,21件 4月,10件 5月,11件 6月,5件 7月,8件 8月,15件 上記のようになっています。
必ず、１０回で０が７回ということでしょうか？ 　Ａ　　　Ｂ =Rand()　0 =Rand()　0 =Rand()　0 =Rand()　0 ・・・ =Rand()　0 =Rand()　1 =Rand()　1 =Rand()　2 と対応表を準備します =VLOOKUP(SMALL(A:A,ROW(A1)),A$1:B$10,2,FALSE) と入れて、下へ１０行分コピー 再計算（Ｆ９）を押すと必ず　0が７個 １が２個、２が１個になるはずです。
『Standard』はサポートしてないみたいですよ 『Professional』以上のグレードが必要なようです http://msdn.microsoft.com/ja-jp/library/ms225542(v=vs.90).aspx
ご提示のコードでは再現されますが、下記コードはCell.Countは1を与え、MsgBoxも一回しか表示されません。正常動作です。 理屈は分かりませんが、ユーザー定義関数内でMsgBoxという行為に無理があるのではないでしょうか。 Sub test() Dim c As Range Debug.Print Range("A1:A2").SpecialCells(xlCellTypeConstants, xlNumbers).Cells.Count For Each c In Range("A1:A2").SpecialCells(xlCellTypeConstants, xlNumbers) MsgBox c.Value Next End Sub ところで、A列全体を対象にしたときとても遅いという件について試してみました。 Private Declare Function GetTickCount Lib "kernel32" () As Long Sub test2() Dim c As Range Dim cnt As Long Dim myVal As Variant Dim buf As Variant Dim startTime As Long Dim i As Long myVal = 1 For Each c In Columns(1).Cells If c.Value = myVal Then cnt = cnt + 1 Next c Debug.Print "Cellにアクセス", GetTickCount - startTime, cnt startTime = GetTickCount cnt = 0 buf = Columns(1).Value For i = 1 To UBound(buf, 1) 'xl2010なので 1048576 行 If buf(i, 1) = myVal Then cnt = cnt + 1 Next i Debug.Print "配列に入れてアクセス", GetTickCount - startTime, cnt End Sub 結果　時間の単位はmsecです。 Cellにアクセス 11625412 1 配列に入れてアクセス 94 1 Cellにアクセス 11628891 1 配列に入れてアクセス 78 1 速度差15万倍という結果でした。 ご参考まで。
マクロを実行毎にコピペで１ページ分を増加させたいという事であれば下記方法で可能だと思います。 ご参考まで。 Sub ページを追加() Dim myRange As Range Dim Maxrow, i, j As Long 'データがあるセル範囲の最終行番号を取得 Set myRange = ActiveSheet.UsedRange Maxrow = myRange.Row + myRange.Rows.Count - 1 '現在ページ数を計算 i = Application.RoundUp((Maxrow - 8) / 43, 0) 'ペーストを開始する行番号を計算 j = i * 43 + 9 Rows("9:51").Select Selection.Copy Rows(j).Select ActiveSheet.Paste End Sub
SendKeys.Sendメソッドの引数は 文字列ですので SendKeys.Send("%{F4}") といった具合に ""でくくってやればいいと思いますよ
Shownイベントなど Form1がフォーカスを受け取った後に行えば希望通りになると思います
ユーザー設定リストを最初のキー以外で使用したいというご趣旨でしょうか。 下記に、機械翻訳の疲れる記事があります。 http://support.microsoft.com/kb/151346/ja 要するに一発でやろうとしないで、ユーザー設定リストによる並び替えは最後に単独でやれという記事ですが、 VBAで行うのなら、何回に分けてやろうと楽勝だと思いますので問題ないと思いますがいかがでしょうか。
#2です。 重複削除が出来ないそうですが、その部分はWarabi-0212さんが作成されたもので、 Set currentCell = Worksheets("貼り付け用用マクロ").Range("A1")を Set currentCell = ws.Range("A3")に変更しただけです。 削除できない理由として考えられるのは、currentCell がA1のままかつ、A1又はA2が空白であればDo～Loopを抜けてしまうので、行削除がされない可能性はあります。 私はcurrentCellをA3から開始するように変更していますが、A1のままという事はありませんか？ コードを全てコピペすれば動くはずのですが。 下記方法でも可能だと思います。 Sub Sample02() Dim i, Maxrow As Long Dim ws As Worksheet 'ワークシート名を変数wsに格納 Set ws = Worksheets("sheet1") 'A列の最終行取得 Maxrow = ws.Cells(Rows.Count, "A").End(xlUp).Row 'セルA3以下を降順ソート ws.Range(Cells(3, "A"), Cells(Maxrow, "A")) _ .Sort key1:=ws.Range("A3"), order1:=xlAscending 'A3以降の重複行を削除 With ws.Range("A3") For i = .CurrentRegion.Rows.Count To 1 Step -1 If .Offset(i, 0) = .Offset(i - 1, 0) Then .Offset(i, 0).EntireRow.Delete Next i End With End Sub
＞ＶＬＯＯＫＵＰで行おうと試行錯誤しましたが、 ＞Ａ列の上段に002と入れた時に001が読み出せなかったり Vlookup関数の最後に検索方法の指定があるのをご存知ですか。 例えの式ですが =VLOOKUP(D1,A:B,2,FALSE) と =VLOOKUP(D1,A:B,2,TRUE) では、使い方が違ってきます。 上の式では、検索値で完全一致で検索しまうので、 A列が順番に並んでいなくても大丈夫です。 下の式では、近似一致なので A列が順番に並んでいる必要があります。
人気の無い元コードを書いた（切り貼りした）者です http://oshiete.goo.ne.jp/qa/8346776.html こんなのをみつけました。 http://support.microsoft.com/kb/891594/ja VBA側の問題ではなさそうですね。 MSのサイトの情報も時々リニューアルと称して消えてしまいますので、記しておきます。 試して無いので結果が出たら教えて下さい。 スプールに時間がかかる様になるかもしれませんので、Sleepのところのmsec数を調節願います。 >回避策 >ドキュメントを確実に順番通り印刷するためには >・「全ページ分のデータをスプールしてから 印刷データをプリンタに送る」 >・「スプールされたドキュメントを最初に印刷する」 >を ON に設定します。 なお、Windows7のサポートサイトを見ろと表示されたので、検索してみましたが見当たりませんでした。 Windows7の設定ダイアログの画像を添付いたします。
#1です。 'Vectorでダウンロードしてきたアイコンです→Vectorさんでダウンロードしてきたカーソルです。 が正しいです。 照れ隠しに検索してみると、カーソルが作れるフリーソフトが沢山ありそうですが、 下記の記事をみると、32x32ドットの範囲内で、好きなサイズのカーソルが出来そうな雰囲気です。画像が無いところは透明扱いで、設定したホットスポットがポイントする点になるという事の様ですね。ご参考まで。 http://www.hm.h555.net/~irom/ssb_help/ssb_help_p …
>エクセルでもVBでもFor～Nextが使える事はわかったのですが ちょっとVisualBasicに入るのが早かったかもしれませんね。 参考までに http://excelvba.pc-users.net/ のサイトにある 第５章　プログラムの基礎 第６章　プログラム制御文 第９章　ユーザーフォーム 第１０章コントロール と http://excel-ubara.com/excelvba1/EXCELVBA380.html 等にあるファイルの操作 http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub0 … データベース接続などを理解した後に、 VisualBasicを見てみるともう少しわかりやすかったかもしれませんね。 エクセルのＶＢＡとＶＢ６の違い エクセル　シートと可視出来る状態でデータが保存できる。 ＶＢ６　　別途、データのファイルを準備する必要がある。 元々の目的が違うの、この部分で、使い方に大きな違いが出てきます。 概略ですが エクセルでは データの内容がシート上確認できるので、初心者でも作り易い。 配布した際に、Ｏｆｆｉｃｅがインストールされている必要あり（微妙ですがバァージョンの違いの問題もあり） ファイル操作（Windowsの操作）なども出来るが、わざわざエクセルを起動しなければならない。 こんな所を念頭に置いて、エクセルで操作するか、ＶＢで行うかの判断をしてもらえば良いと思います。
http://msdn.microsoft.com/ja-jp/library/system.i … > 新しいファイルを作成し、内容をそのファイルに書き込んだ後、ファイルを閉じます。 既存のターゲット ファイルは上書きされます。 とあります。「データが上書きされてしまい,一番最後に送られてきた数字しか記録されません。」とは正しい動作です。 続けて書きたいのなら 方法1: IO.File.ReadAllTextでファイルから全部読む→新しいデータを加える→IO.File.WriteAllTextでファイルに書き込む 方法2: AppendAllTextメソッドを使う http://msdn.microsoft.com/ja-jp/library/ms143357 … あと、RecvStrに改行文字が入っていない場合は、改行文字を付けたす必要があります。
通常、作成したプログラムは、インストーラを作成して配布します。 でも、Expressでは、インストーラ作成機能はないと、このサイトの他のＱＡには書かれていました。 たぶん、Expressは勉強用で、いろんな方に配布する機能は省かれているのではないでしょうか？ 有償バージョンの開発環境でインストーラを作成して配布すれば「必要なファイルが入っていない場合に自動的にダウンロードをする」といった事が可能になると思います。
コンパイルとは。 簡単に言うと、プログラムを実行指せる環境に持って行くことです。 exeファイルの作成なんかがそうですね。 条件付きコンパイルとは。 ちょっと文法がわからないのですが、おそらくこんな感じで書くのでしょうか？ #If _DEBUG Then Print "デバッグ中だよー" #End If デバッグモードで起動した場合、「デバッグ中だよー」と表示されそれ以外なら表示されません。 例えばプログラムを配布するためにリリースコンパイル（exe出力とか）したものには表示されないということですね。
> AccessibleObjectFromWindow > でオブジェクトが取得できません。 リンク先はVB用なのでVBA用に直さないと。UI Automationでいいのでは。
例外発生時はスタックトレースをログファイルにでも出力するように作ってはどうですか？ その方が逆アセンブルするよりもデバッグがしやすいと思うのですが……。 参考URL：http://dobon.net/vb/dotnet/programing/unhandlede …
できます。 Public Sub test() Dim obj As ClassLibrary1.Class1 Set obj = New ClassLibrary1.Class1 Dim resut As ClassLibrary1.ResultClass Set result = obj.Show() Call MsgBox(result.Result1 & ", " & result.Result2 & ", " & CStr(result.Result3)) End Sub
書かれているうちで，手動によるDispose対象になるのはSqlConnectionだけですね。 コントロールは親がDisposeされるとそのままDisposeされるので。 で，IDisposableなインスタンスが自分の管理下にある場合， ・不要になったらDisposeを呼び出す ・IDisposableなインスタンスは必要最小限の範囲で使う のがよいと思います。 SqlConnectionに関しては，コネクションプーリングに任せて必要な時のみ開いて閉じればよいでしょう。 # SqlConnectionに関して，Poolingはデフォルトtrue。 このため， using (var connection = new SqlConnection(connectionString)) { connection.Open(); /* DataAdapter使ってDataTableに値を流し込む */ } と，単一メソッドの中で開いて閉じることになります。
バイナリ形式の読み書きにEBICDICも何もありませんが その4バイト以降は正常なデータなのでしょうか？ ・それ以後のデータは正常なのか異常データどっち？ ・データが正常だとして（多分こっちだと思うが）4バイト＋124バイトの形で出力されるのか 　4バイト＋128バイトの形で出力されるのかどっち？ どこかで間違ったコード書いてるんでしょうが ソースコードの記載がないので判断することができません
dim dv as DataView dim rd as DataTableReader DataTable2 = DataTable1.Clone ' 1）選択条件から DataViewを生成して dv = new DataView( DataTable1, "条件", "ソート", DataViewRowState.CurrentRows) ’2）ToTableで DataTableを生成し これを引数にDataTableReaderを生成 rd = new DataTableReader(dv.ToTable()) '3）Loadメソッドで 行データを取り込み DataTable2.Load( rd ) rd.Close といった具合でできますよ
Me.代表者メールアドレス　は存在しますか？ それから、このコードはドコに書いてありますか？ 　　「Me」だからフォーム上のはずですが、標準モジュールじゃないでしょうね？
On Error Resume Next 'for文の外でok For I = 1 To 18 ’シート名リストは適当 Sheets("メニュー").range("a1").(3 + I, 0 ).Value = sheets(i).name. ' 現在開いているシート名を取得す Next i を実行してみて。 シートの順位が変わるなら、取得し直しでしょう。
続けてお邪魔します。 ＞もう少し簡単なプログラムがあれば・・・ というコトですが、この程度しか思いつきませんので、 前回のコードとその説明を加えたものをもう一度載せてみます。 Sub Sample1() '変数の宣言 Dim k As Long, cnt As Long, str As String, c As Range 'C・D列の消去 Range("C:D").ClearContents 'A1セルの1文字目～最終文字まで For k = 1 To Len(Range("A1")) '一文字ずつを変数（str）に格納 str = Mid(Range("A1"), k, 1) 'もしstrが「漢字」であれば・・・（おそらくすべての漢字が網羅されていると思います） If str Like "[一-黑]" Then 'C列に「str」が存在するかどうか確認 Set c = Range("C:C").Find(what:=str, LookIn:=xlValues, lookat:=xlWhole) 'もしC列に「str」がなければ If c Is Nothing Then 'cnt（表示用の行番号として使用）を1つずつ増やす cnt = cnt + 1 '←最初は「1」となる 'C列の「cnt」行の With Cells(cnt, "C") '値はstrを代入 .Value = str 'その右隣りのセルに「1」を代入 .Offset(, 1) = 1 End With 'そうでない場合は Else 'C列にstrがある行の右隣りの値は、入力済みの数値に1をプラス c.Offset(, 1) = c.Offset(, 1) + 1 End If End If '次のk（文字）へ！←（A1セルの最後の文字まで一文字ずつ順にループ） Next k 'C列最終行の2行下のセルの With Cells(Rows.Count, "C").End(xlUp).Offset(2) '値は「総数」に .Value = "総数" 'その右隣りのセルはD列数値の合計を！ .Offset(, 1) = WorksheetFunction.Sum(Range("D:D")) End With End Sub ※　一応上記のような考え方でのコードです。 この程度でよろしいでしょうかね？m(_ _)m
ちょっと様子がわからないのですが、デバッグモードだからってことでしょうか？ もしそうなら、修正後に画面の上にある「■」を押してから実行してみたら動作するはずです。
> マクロを実行してみたのですが、 > 何も起こりませんでした。 > エラーが出てデバッグするところもありませんでした。 まじでか。ん～。もちろんこれは対象のSheet1とSheet2があるExcelブックで標準モジュールを追加しなてそちらにマクロを書き込まないと駄目だぜ。多分その辺は大丈夫だと思うんだけど。 本当はこんな事言いたくないんだが、ここは「こういう事をするマクロを作ってください」というサイトではなく「こういう事をしたいのだがどういうマクロをかけば良いのか分からないからアドバイスください」というサイトだ。つまり、最終的にマクロを作るのはあなたであって、あなたが私やもう一人の回答者さんのマクロを参考にしつつ自分でやらなきゃ身につかないぜ。 まずは得られた回答から各マクロで何をやっているのか、どうしてここにIｆが来るのか、何と何の値を比較しているのか、など分かる範囲からでいいから読んで解釈してみる、マクロと対象データが目の前にあるのだからステップ実行してなぜ自分の意図通りの結果にならないのか確かめる、など、マクロの修正を要求する前にできることはいくらでもあるんじゃないか。 本気で「こういう事をするマクロを作ってください」と思っていたならばここじゃなくてクラウドワークスでも行ってください。
＜このデータを10行ずつ、BOOK2のシート名（QW-1）～（QW-100）の指定セル・・・ この構成自体が良くないです。 むやみにシートを増やしても使いにくだけですよ。 構成でいえば １、全てのデータが縦方向に蓄積されているデータシート ２、希望の内容を抽出する抽出シート の２枚構成で考え直してみてください。 例ですが データをA～Dの４列に追加して行くようなVBAでも準備する。 抽出のシートの　上部分にセルに　QW-1　とか現在のシート名にあたる項目を 入力するセルを配置 １６行目から以下に、入力した内容に応じて希望のデータが表示される関数を考える。 シートを横へ探して移動するより、はるかに使いやすくなります。 一度、会社の担当者、上司（？）の方へ相談してみてください。 この手の間違ったやり方を続けていくとだんだん複雑になり、最後は破たんします。
Access2010で確認しました。 番号がダブルクォートで囲まれていないと質問のようになりますね。 一度、外部データの取り込みからウィザードで進めていって その際にデータ型を指定します。 この時にインポート定義を適当な名前で保存すれば 次回からは、DoCmd.transferText の SpecificationName で指定してあげれば スムースにインポートできるようになります。 http://www.tsware.jp/tips/tips_528.htm なお、OKWAVEとその提携サイトでは、個人情報のチェックを自動的に行っているようで 電話番号やメールアドレスと判断できなくもないモノが文中に含まれていると 『現在、サポートで内容を確認中です。』 となってしまいます。 とっても『賢い』（愚鈍）なのでご注意を。
> 2012にしたほうがいいのか、このまま2010でいいのか > 2012をインストールして重かった場合、2012をアンインストールして今使っている2010に戻せるのか 両方入れとけばいいじゃん。 VisualStudio は 2010 がインストールされているところに 2012 をインストールしても 2010 がアンインストールされることはありません。
＞別のパスワードでロックされているファイルを このファイルには何が入っているのでしょうか。 ＞複数のファイルがあるので 複数のブックにまたがる処理ならば、話はガラリと変わり、そもそものコードが変わってきます。 そもそも元データは、複数のブックに散らばっているのですか？ あるいは、疾病コードの一覧はそのパスワードがかかっているブックに既にあるのですか。 ＶＢＡを勉強中、とのことでしたが、このようなコードを自らで書いたことはありますか。 そうするとお分かりだと思いますが、このようなコードを構築する際には、一番最初に、その大枠というか、枠組みをしっかり組んでから取り掛からねば、正しいものはできません。 最初の質問にもありましたが、「マクロで処理するように指示された」とのことなので、全く分かっていない者にこのような指示を出すことはなかろうと、基本的に理解されていることを前提に回答したつもりです。 最初に構築すべき枠組みとはいろいろあります。 今回のように複数のブックにまたがる処理なのか、単一ブックで済むのか、とか、 繰り返し使用するコードなのか、そうでないのか、 （今回の処理が終わってしまえば用済みなのか、あるいは、来月も同じようなＣＳＶを渡されて処理をするのか。もしそうならば、いちいちモジュールをコピペするのもナンセンスなので、あなたのＰＣのPERSONAL.XLS（＝個人用マクロブック）　にコードを書いたほうが使い勝手はよさそう） あなただけが使用するコードなのか、他者も使用することがありうるのか、 （他者が使用することもあるならば、想定外の操作をした場合など、エラー発生時の対応や注意喚起なども施さねばならない） など、いろいろあります。 このサイトでの質問ですので、どうしても断片的な情報から推測して回答しましたので、わたしの説明も拙くて申し訳なかったのですが、2回目に回答したDictionaryオブジェクトのコードは、あくまで、132種類の疾病コードの一覧をお持ちではないということを前提に、それを抽出することを目的としています。 Sheet100に書き出したのがそれです。 それが抽出できたら、あとはそれをSheet2以降の集計シートにコピペすれば済むかと思ったのです。 仮に市区町村コードが50種類あったとします。 Sheet2～Sheet51 は、それぞれの市区町村ごとの集計シート。 それぞれの、B1～EC1 と　B134～EC134 に、疾病コードの一覧をコピペすれば、集計シートのフォーマットは完成します。 （それと、縦軸には年齢ですね） なので、ここはご自身で対応いただけるかと思ったので割愛しました。 シートインデックス（２～51）で、For Next で回せばできますよね。 ただ、このコードもどう書くか皆目見当がつかない、ご自身でままならない、ということですと、残念ながらちょっと厳しいと思うので、この指示を出した上司に報告してください。 ************************************************************************ いちおう私の理解では以下のことをされたいのだと思います。 契約者の情報が入っている3万近いレコード。 これがシート１に入っている。 市区町村ごとにシートを分け、それぞれの市区町村ごとに、男女別に分けたうえで、縦軸：年齢、横軸：疾病コードでマトリクス状に集計したい。 そのためには、 シート２以降に、縦軸、横軸を設けた入力フォーマットを作成する必要がある。 132種類ある疾病コードの一覧がないので、それを作成し、シート2以降にコピペして、集計シートを作る。 そのあとに、最初の回答で書いた、集計マクロを実行する。 という流れかと。 なので、他ブックは関連しないと思っていました。 もう少し詳しい記載が必要です。 一部分だけしかお力になれてなくて申し訳ありませんが、いまいちど、コードを書く前に必要事項を整理してみてください。
では、 C:\Users\Desktop\移動元 という空っぽのフォルダがあったとして ここにZipファイルを解凍した。 サブフォルダが幾つかとそれぞれのフォルダに複数のファイルが出来た。 Zipファイルを除きすべてのファイルをC:\Users\Desktop\移動先フォルダのルートに 移動したい。 という解釈であっているとして・・。 Sub test02() 　　Dim oFs As Object 　　Dim oDir As Object 　　Dim oFile As Object 　　Dim FromDir As String 　　Dim ToDir As String 　　 　　FromDir = "C:\Users\Desktop\移動元" 　　ToDir = "C:\Users\Desktop\移動先\" '\を忘れずに 　　 　　Set oFs = CreateObject("Scripting.FileSystemObject") 　　Set oDir = oFs.getfolder(FromDir) 　　Set oFile = oDir.Files 　　 　　If oFs.FolderExists(FromDir) = False Then 　　　　MsgBox "送り元が見つかりません" 　　　　GoTo atoShimatu 　　End If 　　 　　If oFs.FolderExists(ToDir) = False Then 　　　　If MsgBox("送り先フォルダが見つかりません。作成しますか？", vbYesNo) = vbNo Then 　　　　　　GoTo atoShimatu 　　　　Else 　　　　　　oFs.createFolder (ToDir) 　　　　End If 　　End If 　　 　　If oFs.getfolder(ToDir).Size <> 0 Then 　　　　MsgBox ToDir & "にはファイルが残ってます。取りあえず中止。" 　　　　GoTo atoShimatu 　　End If 　　 　　Call moveFiles(oDir.Path, ToDir) 　　Exit Sub atoShimatu: 　　Set oFile = Nothing 　　Set oDir = Nothing 　　Set oFs = Nothing End Sub Private Sub moveFiles(oDirPath As String, toDirPath As String) 　　Dim oFs As Object 　　Dim oDir As Object 　　Dim oFile As Object 　　Dim FromDir As String 　　Dim ToDir As String 　　 　　Set oFs = CreateObject("Scripting.FileSystemObject") 　　Set oDir = oFs.getfolder(oDirPath) 　　Set oFile = oDir.Files 　　 　　For Each oFile In oDir.Files 　　　　If oFs.GetExtensionName(oFile) <> "zip" Then 　　　　　　'Debug.Print "FileName = ", oFile.Path, oFile.Name '確認用 　　　　　　'oFs.MoveFile oFile, ToDirPath '本番用(移動)？はこちら 　　　　　　oFs.CopyFile oFile, toDirPath, False '確認用、 　　　　　　'最後のFalseは既存ファイルがあればエラーになります 　　　　End If 　　Next 　　 　　For Each oDir In oDir.SubFolders 　　　　'Debug.Print "folder = ", oDir.Name, oDir.Attributes ’確認用 　　　　Call moveFiles(oDir.Path, toDirPath) 　　Next 　　　　 　　Set oFile = Nothing 　　Set oDir = Nothing 　　Set oFs = Nothing End Sub ※Zipファイルを解凍してできたサブフォルダ内に同名のファイルがあった場合を考えると oFs.CopyFile の方が安全かも？です。 絶対にありえない！確証があれば構いません。 （もし、存在した場合の処理は考えていません (^_^;) ） test02 を実行してみてください。 moveFiles が実際の処理を行っています。 検証が不十分かと思いますので念入りに！
Ｎｏ．１です。 ＞TextBox2に出力するにはどうしたら良いですか? TextBox2.AppendText(m.Result("${moji}") + ControlChars.CrLf) 'テキストボックス２に出力 こちらに変更してみてください。
こんにちは http://office.microsoft.com/ja-jp/access-help/HA … ＳＱＬを編集すれば可能なようですが、私は使ったことがありません。 個人的には、「複数値を持つフィールド」自体を使わないというのが良いと思いますが、、、
objIE.Document.all.oil これだと、idによる検索なので見つかりません。 nameで検索するには objIE.Document.all.getElementsByName("oil")
VB6での例です。 現在のキャレットの位置に"あ"を挿入します。 文字が選択されている場合は選択文字が"あ"と置き換えられます。 Private Sub Command1_Click() Text1.SelText = "あ" End Sub 備考： キャレットの位置は SelStart プロパティー 選択範囲は SelStart, SelLength プロパティー
Public Class Form2 Protected Overrides Function ProcessCmdKey(ByRef msg As Message, keyData As Keys) As Boolean If keyData = Keys.Control + Keys.F4 Then ' 握りつぶす！ Return True End If Return MyBase.ProcessCmdKey(msg, keyData) End Function End Class
Enterキーが押されたかの フラグを準備して KeyPressイベントとKeyDownイベントで処理します Dim bEnterKey as Boolaen ' 引数省略 Private Sub KeyPress(...) Handles TextBox1.KeyPress 　　if bEnterKey then 　　　　e.Handled = TRUE 　　end if 　　bEnterKey = FALSE End sub Private Sub KeyDown(...) handles TextBox1.KeyDown 　　if not bEnterKey then 　　　　if e.KeyCode = Keys.Enter then 　　　　　　' 本来なら[alt][ctrl][shift]の併用もチェックしたほうが望ましい 　　　　　　bEnterKey = True 　　　　end if 　　end if End Sub といった具合でしょう
管理者権限のあるコマンドプロンプトでregsvr32の登録を行ってみても同じですか？ それでだめなら、VB6ランタイムのインストールを行ってみてください。 http://www.microsoft.com/ja-jp/download/details. …
ＣＳＶファイルをシーケンシャルファイルで読んで、カンマで分解。 VB6も2010でも動くはず dim strBuffer as string Dim nFile as integer Dim strArray() as string Dim nArray as long nFile = freefile() open "C:¥hogehoge.csv" for input as #nfile While not(eof(nfile)) Line Input ＃nFile, strBuffer Strarray=split(strbuffer,",") narray=ubound(strArray()) if nArray> 3 Then debug.print strarray(0), strarray(2)) ’ここでデータを利用 end if wend Close タブレット手書き入力なので文字の大小不統一はお許し下さい
理想は全ファイルになるのですが、そんなことされても、困ります。 プログラム作っていれば、デバグは必ずやらなければならない作業です。 今後の訓練のためにも、御自身でやることをお勧めします。 まずは、どこでエラーが発生しているか特定しましょう。 デバガでブレークポイント→ステップ実行で一つずつたしかめたり、MsgBoxやTrace,Debug等で変数の内容や進行状況を出力したりして、どこまで正常で何処でエラーになるかを絞りこんでいきます http://dobon.net/vb/dotnet/vb6/debugprint.html また、理由はわかっています。 どこかで「Nothingであってはならない箇所がNothingになっている」ということです。 前に例示した「変数が初期値のまま」以外にも様々な原因があります。 ・Nothingが期待されない引数にNothingが使われている A.methodA(B) ' B=Nothingになっている ・戻り値がNothingになる可能性のあるFunctionで、戻ってきたNothingをそのまま使ってしまっている A=funcA() ' ここでNothingが戻ることがある A.methodA() ' そのまま使うと、Nothing.methodA を呼び出そうとしてエラー ・Option Explicit Off の状態で、変数名を間違えている→新規変数として扱われ、その初期値Nothingになる
継承もとのForm1にある cmdCloseのModifiersは『Private』のままでしょうか？ それとも Form2などでも参照等ができるように 『Protected』に変更したとか … Protectedに変更して Form2のコンストラクターなどで cmdClose.Click += cmdClose_Click; などとしているのであれば Form1クラスで定義されたハンドラによる呼び出しと Form2で追加されたハンドラの 2回呼び出されるのではないかと思います
ベッセル関数も第二種ベッセル関数も数式はまったく理解できないのですが ネット検索で見たこのベッセル関数式の場合、セルに書き出すのですが １００行目まで、I列までだと 当方の７年ほど前の古いノートPC（CeleronM 1.86Ghz）でも グラフ描画を含めて0.2秒かからずに終わります。 http://homepage3.nifty.com/rikei-index01/excel/e … 科学技術計算などで膨大な量だとだめかもしれませんが 計算結果だけなら0.1秒でセルに書き出されます。 　マクロの記録だけくらいなのでもっときちんと書いたほうがいいのですが。　 dim i as single Application.ScreenUpdating = False Range("C6:I100").ClearContents ' Range("c6").Activate ActiveCell.FormulaR1C1 = "=BESSELJ(RC2,R5C)" Range("C6").Select Selection.AutoFill Destination:=Range("C6:C100") Range("C6").Select Selection.AutoFill Destination:=Range("C6:I6"), Type:=xlFillDefault Range("C6:I6").Select Selection.AutoFill Destination:=Range("C6:I100") Range("B5").Select Application.ScreenUpdating = True For i = 0.1 To 1 Step 0.1 Range("b7").Value = i Range("B6:B7").AutoFill Destination:=Range("B6:B100") Next １０回書き換えで2.1秒ほどかかりました。 関数も得られたデータもどうつかうのかわかりませんが お役に立てれば。
＃２、ｃｊです。＃２への補足、追加レスです。 ちょっと説明が足りてなかったのですが、 テストする際の要件として、 最初に、シートモジュールにSub 準備()だけを貼り付けて 一度だけ実行します。 それが済んだら、他のプロシージャを貼り付けて、 ブックを保存します。 ここまでが準備、で、 "最初に、シートモジュールにSub 準備()だけを" という説明が抜けていました。すみません。
Sheet1のデータ（レコード）のうち、sheet2のa1セルの市町村コードに該当するものを、 縦軸（年齢）、横軸（死因）で、性別ごとに集計する、と理解しました。 ************************************************************* Sub zzz() Dim r As Long Dim i As Integer, j As Integer, k As Integer Dim Wsf As Object Dim SCode As Range, Nenrei As Range Dim Ws1 As Worksheet, Ws2 As Worksheet Set Ws1 = Worksheets("sheet1") Set Ws2 = Worksheets("sheet2") Set Wsf = Application.WorksheetFunction Application.ScreenUpdating = False Ws2.Range(Ws2.Cells(2, 2), Ws2.Cells(132, 133)).ClearContents Ws2.Range(Ws2.Cells(134, 2), Ws2.Cells(264, 133)).ClearContents With Ws2 Set SCode = .Range(.Cells(1, 1), .Cells(1, 133)) End With r = 2 Do While Ws1.Cells(r, 1).Value <> "" If Ws1.Cells(r, 4).Value = Ws2.Cells(1, 1).Value Then If Ws1.Cells(r, 1).Value = 1 Then i = 1 ElseIf Ws1.Cells(r, 1).Value = 2 Then i = 134 End If With Ws2 Set Nenrei = .Range(.Cells(i, 1), .Cells(i + 130, 1)) End With j = i + Wsf.Match(Ws1.Cells(r, 3).Value, Nenrei, 0) - 1 k = Wsf.Match(Ws1.Cells(r, 2).Value, SCode, 0) Ws2.Cells(j, k).Value = Ws2.Cells(j, k).Value + 1 Else End If r = r + 1 Loop Application.ScreenUpdating = True Set Scode = Nothing Set Nenrei = Nothing Set Wsf = Nothing Set Ws1 = Nothing Set Ws2 = Nothing End Sub ****************************************************************************** （簡単に補足） 変数rを整数型で宣言 変数i,j,k を整数型で宣言 変数Wsf をオブジェクトで宣言 変数Scode,Nenrei をレンジで宣言 変数Ws1,Ws2 をワークシートで宣言 Ws1にSheet1をセット Ws2にSheet2をセット Wsfにエクセルのワークシート関数をセット 画面更新を止める Sheet2の男性用入力エリアをクリア Sheet2の女性用入力エリアをクリア Scode に、死因コードの範囲をセット rは2です。（シート１のレコード、2行目から始める） Sheet1のA列のセルが空白になるまでループさせる。 　　　　もし、レコードの市町村コードが、シート２のA1セルと同じだった場合、 　　　　　　　　もし、性別コードが１（男性）だった場合、 　　　　　　　　　　　　i は1 　　もし、性別コードが２（女性）だった場合、 　　　　　　　　　　　　i は　134 　　　　　変数Nenrei　に　年齢の範囲をセット　（上で決めたiによって、男女の区別をしてセット） 　　　　　j は、年齢の該当する行　（をMatch関数で求めている） 　　　　　k　は、死因コードの該当する行　　（同上） 　　　　　j,k で決まったセルに１を加算（カウント） 　　　もし、レコードの市町村コードが、シート２のA1セルと異なる場合、 　　　　　　　　　なにもしない 　　　r に１を足して ループ。 画面更新を復活させる 変数の開放 終わり。
>For i = 1 To 3 ↓ For i = 1 To 100 >Set sh = Nothing 　　↑ 　　不用
たびたびごめんなさい。 No.2のコードで無駄な行がありました。 ↓のコードに変更してください。 Sub Sample3() Dim i As Long, k As Long, str As String For i = Cells(Rows.Count, "F").End(xlUp).Row To 2 Step -1 If InStr(Cells(i, "F"), "×") > 0 Then Cells(i, "A").Resize(, 17).Interior.ColorIndex = 36 str = Replace(Cells(i, "F"), "×", "") k = Len(Cells(i, "F")) - Len(str) If k > 1 Then Rows(i + 1 & ":" & i + k - 1).Insert Cells(i, "A").Resize(, 17).Copy Cells(i + 1, "A").Resize(k - 1, 17) End If End If Next i End Sub 何度も失礼しました。m(_ _)m
No.5です。 たびたびごめんなさい。 前回は15085行までになっていました。 Sub Sample2() With Range("G9:G1508") .Formula = "=RANDBETWEEN(1,78)" .Value = .Value End With End Sub に変更してください。 どうも失礼しました。m(_ _)m
当方のWindows XP, Internet Exploret 8で、ローカルのハードディスク上のhtmlファイルを開いて試してみたところ、 objWshShell.SendKeys("{enter}") の前に objWshShell.AppActivate("Internet Explorer") WScript.Sleep 100 とか objWshShell.AppActivate("Web ページからのメッセージ") WScript.Sleep 100 とか入れるとうまくいくようでした。 ただ、セキュリティの設定がよくわからずActiveXコントロールの警告を消せなかったのでその対策にもSendkeysを使ったりしているうえに、そもそも私がこの分野にはあまり詳しくないので、残念ながらあまり自信はありません。
#2です。 #3さんの回答をを見て気付きましたが、どうせ配列数式を使っているのだから、引き算もそこでやれば良いのですね。 そこを簡略化して、複数該当の場合は列挙する様に改善したものを、一応投稿しておきます。 （回さないと言ったループを結局回さざるをえませんが．．．） Sub test() Dim srcRange As Range, calcRange As Range Dim difValue As Double Dim refRange As Range, hitRange As Range Dim firstAddress As String Dim counter As Long Sheets("Sheet1").UsedRange.Cells.Interior.ColorIndex = xlNone Sheets("Sheet2").Cells.Clear 'A1を対象セル範囲の左上セルの番地に変更のこと With Sheets("Sheet1") Set srcRange = .Range(.Range("A1"), .Range("A1").End(xlDown).End(xlToRight)) End With Set calcRange = Sheets("Sheet2").Range(srcRange.Address) '比較する数値の入ったセル Set refRange = Sheets("Sheet1").Range("I1") refRange.Offset(2, 0).CurrentRegion.Cells.ClearContents refRange.Offset(4#).Cells.ClearContents calcRange.FormulaArray = "=ABS(" & srcRange.Parent.Name & "!" & srcRange.Address(True, True) & " - " & CStr(refRange.Value) & ")" '再計算防止のため値に変換 calcRange.Value = calcRange.Value difValue = Application.WorksheetFunction.Min(Sheets("Sheet2").Range(srcRange.Address)) Set hitRange = calcRange.Find(difValue, LookIn:=xlValues, lookat:=xlWhole) counter = 0 If Not hitRange Is Nothing Then firstAddress = hitRange.Address Do Sheets("Sheet1").Range(hitRange.Address).Interior.Color = vbRed Do If refRange.Offset(2, counter).Value = "" Then refRange.Offset(2, counter).Value = Sheets("Sheet1").Range(hitRange.Address).Value Exit Do End If counter = counter + 1 Loop Set hitRange = calcRange.FindNext(hitRange) Loop While Not hitRange Is Nothing And hitRange.Address <> firstAddress End If refRange.Offset(4, 0).Value = difValue End Sub
> 限定的なWindowsアプリなので、あまりシビアに考えてませんが、ダメでしょうか？ 自分しか使わない、とかならそれもありですが……。 まぁ対策と言っても、ただ問題になりそうな文字をエスケープするだけですから、 ついでにやっておいて損はないかと思います。
ご参考。 参考URL：http://omen999.developpez.com/tutoriels/vbs/depl …
こんにちは。 ちょっとコンサバ過ぎるかも知れませんが、現在の私流で書いてみました。 もし、数字（1とか2とか）であれば、そのまま連結してはいけない場合もあろうかと。 とりあえず、評価する対象文字列＝strBufの先頭であればそのまま数字、 それ以外は"+"演算子に続けて数字という風に、勝手に少しお節介にしてみました。 （+2という文字列なら++2、-3という文字列なら+-3、を連結しますが戻り値は変わりません。） ポイントは、最後の一行で、これだけでかなりの誤作動を防げる筈です。 現状が不安定ということですから、なるべく堅実なものをという意図で書いていますから、 処理は比較的遅くなりがちです。 叩き台にするなり、パーツだけ流用するなり、後はそちらで工夫してみてください。 それと、ＵＤＦに限らず、ParamArrayの多用は負荷が大きいようですから、 せいぜい数百、と考えておいた方がストレスがないとは思います。 （関数名、替えてあります。） ' ' /////////////////////////////////////////////////////// Function myEvalAryC(ParamArray ItemR()) As Variant 　　Dim a As Range　　'　　Area 　　Dim c As Range　　'　　Cell 　　Dim strTemp As String　　'　　Cellの表示文字列 　　Dim strBuf As String　　'　　バッファ文字列 　　Dim Param As Variant　　'　　ParamArrayの要素 　　strBuf = "" 　　For Each Param In ItemR() 　　　　If TypeName(Param) = "Range" Then 　　　　　　' ' 引数がRangeの場合 　　　　　　' ' 各領域（Area）をループ 　　　　　　For Each a In Param.Areas 　　　　　　　　' ' 各領域（Area）内のCellをループ 　　　　　　　　For Each c In a 　　　　　　　　　　' ' Cellの表示文字列 　　　　　　　　　　strTemp = c.Text 　　　　　　　　　　' ' Cellの表示文字列が数字として読めるものであれば、 　　　　　　　　　　If IsNumeric(strTemp) Then 　　　　　　　　　　　　' ' バッファ文字列が空ならそのまま数字を 　　　　　　　　　　　　' ' バッファ文字列が空でなければ"+"演算子と数字を 　　　　　　　　　　　　If strBuf <> "" Then strBuf = strBuf & "+" 　　　　　　　　　　End If 　　　　　　　　　　' ' バッファ文字列に流し込み 　　　　　　　　　　strBuf = strBuf & strTemp 　　　　　　　　Next 　　　　　　Next 　　　　Else 　　　　　　' ' 引数がRange以外の場合 　　　　　　If IsNumeric(Param) Then 　　　　　　　　If strBuf <> "" Then strBuf = strBuf & "+" 　　　　　　End If 　　　　　　strBuf = strBuf & Param 　　　　End If 　　Next 　　' ' Applicationではなくて呼び出し元のシートに評価させることが誤作動を防ぎます。 　　myEvalAryC = Application.Caller.Worksheet.Evaluate(strBuf) End Function
＃２、ｃｊです。＃２、補足欄へのレスです。 ' ' ---- Private Sub CommandButton1_Click() 　　Dim Sh As Worksheet 　　Dim FileN As String 　　Set Sh = ThisWorkbook.Sheets("import") ' <-- 読込みシート指定(※) 　　FileN = Application.GetOpenFilename("テキストファイル,*.txt") 　　If FileN <> "False" Then 　　　　Workbooks.OpenText Filename:=FileN, StartRow:=1, DataType:=xlDelimited, TextQualifier:=xlTextQualifierNone, Tab:=True 　　　　ActiveSheet.Cells.CurrentRegion.Copy Destination:=Sh.Cells(Rows.Count, "A").End(xlUp).Offset(1) 　　　　ActiveWorkbook.Close False 　　End If 　　Set Sh = Nothing End Sub ' ' ----xl2010で動作確認済 原形を残して、２行追加するだけです。 シートの何処に出すか、判りませんので、とりあえず、Ａ列を基準に最下行を採り、 最下行の一行下に出力する場合の例です。必要に合わせて応用してください。 （未使用の場合は２行め以下に出力します。） 同じ処理をするのに、方法は色々と（パッと思いつくだけでも５通り）ありますが、 テキストデータをそのまま貼るだけならば、この方法でも、 十分に一般的で、読む人に理解され易いい、と言えるもの、と私は思います。 因みに、 CommandButton1が、シート上に配置したActiveX コントロールだった場合は、 CommandButton1 のプロパティ TakeFocusOnClick を False に設定するのがベターです。 そうしておいた方が、何かとエラーが起き難くなります。 　デザインモード（三角定規みたいなアイコン） 　↓ 　CommandButton1を右クリック 　↓ 　プロパティ 　↓ 　TakeFocusOnClick　を　False という手順です。 以上です。
IDを入力するテキストボックスがよくわかりませんが、 ＞SQLCm.CommandText = "SELECT * FROM T_akusesu" 右辺のSQL文を改造します。 "SELECT * FROM T_akusesu WHERE ID=" & textbox.text
#3です。 WShell.Execを使うと閉じる事ができる様ですが、色々と気難しくて苦労しました。 まず、なぜかAdobe Reader/Acrobatのフルパスを与えないと、ファイルがみつからないとゴネます。 Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) Sub test() printPdf2 GetDesktopPath & "\test.pdf", "DocuWorks Printer", "DocuWorks Printer Driver" ' printPdf2 GetDesktopPath & "\test.pdf" End Sub Sub printPdf2(pdfDocument As String, Optional printerName As Variant, Optional printerDriver As Variant) Dim cmdLine As String Dim WShell As Object Dim oExec As Object 'ここは調整の必要がありそう Const waitTime As Long = 1000 'Windows7 Home 64bitの場合です Const pgmFullPath As String = "C:\Program Files (x86)\Adobe\Reader 11.0\Reader\AcroRd32.exe" Set WShell = CreateObject("WScript.Shell") If IsMissing(printerName) Or IsMissing(printerDriver) Then cmdLine = "pgmFullPath /n /s /o /h /t ""pdfFullPath""" cmdLine = Replace(cmdLine, "pgmFullPath", pgmFullPath) cmdLine = Replace(cmdLine, "pdfFullPath", pdfDocument) Else cmdLine = "pgmFullPath /n /s /o /h /t ""pdfFullPath"" ""printerName"" ""printerDriver""" cmdLine = Replace(cmdLine, "pgmFullPath", pgmFullPath) cmdLine = Replace(cmdLine, "pdfFullPath", pdfDocument) cmdLine = Replace(cmdLine, "printerName", printerName) cmdLine = Replace(cmdLine, "printeDriver", printerDriver) End If Debug.Print cmdLine Set oExec = WShell.exec(cmdLine) Sleep waitTime 'Windows7Home/64bit環境ではここで実行時エラーが出るので無理矢理先に進めていますが 'Adobe Readerは閉じられる様です On Error Resume Next oExec.Terminate Set WShell = Nothing End Sub Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function Terminateで原因不明のエラーが出るのでWebを漁っいて下記をみつけました。64bit環境でエラーが出るのはこれも関係しているのでしょうか？少々無理をしている様なので、ご使用時はご注意下さい。 Terminate メソッドは最後の手段としてのみ使用します。これは、アプリケーションによっては適切にクリーンアップできない場合があるためです。通常は、プロセスを途中で中断せず、プロセス自身で実行を終了させるようにします。Terminate メソッドは WM_CLOSE メッセージを使ってプロセスを終了しようとします。これで終了できない場合は、通常のシャットダウン手順を実行せずに、プロセスを強制終了します。 http://msdn.microsoft.com/ja-jp/library/cc364387 …
Dim d As DateTime = Date.Parse(DateTimePicker1.Value.ToString("yyyy/MM/dd")) If d = Date.Today Then TextBox1.Text = ComboBox1.Text こんな感じとか？
＞表示されていないところを消さない限り 上記をみると、PictureBox.Dispose()をしていないように読めるので、 PictureBoxにイメージがある場合は ・イメージを消す ・新しい領域を描画する の手順を踏まえるべきと考えます。そうでなければメモリ上のイメージが残り続け、どれだけメモリを載せていてもいつかメモリ不足を起こします。 URL：http://dobon.net/vb/bbs/log3-28/17215.html の、下部に解放について記述があります。 また、OutofMemoryExceptionが拾えない状況でしょうか。
Private Sub コマンド6_Click() 　　Dim I As Integer 　　Dim J As Integer 　　Dim S As Integer 　　J = 10 　　S = 4 　　For I = 1 To J Step S 　　　　Debug.Print I 　　　　If I + S > J And I <> J Then 　　　　　　I = J - S 　　　　End If 　　Next I End Sub 理屈は前の回答と同じです。
TextBox.ReadOnly
No1, 2さんに異論はありません。その通りです。 で、別なこころみを一つ。 http://msdn.microsoft.com/ja-jp/library/cc392442 … にあるように、[Public | Private]　が使えます。この使い分けで、何とかする方法ですね。 次に、動的にスクリプトを読み込み、スクリプトごと切り替えてしまう。なんて方法もあります。それを推し進めると、 http://msdn.microsoft.com/ja-jp/library/cc392140 … にあるような、WSFファイルですね。複数の単独のスクリプトをHTMLのような感覚で、一つのファイルにまとめられます。例えば、条件コンパイルの使える、JScriptコード を VBSコード から呼び出し、変数の値を取り込むなんてことも。 まあ、やろうと思えば、 http://msdn.microsoft.com/ja-jp/library/cc428166 … にあるような物を作成し、動的に呼び出す事も。まあ、定数といえども、動的に導かれる定数も、発想の転換によっては可能かもしれません。
こんにちは。 数式を出力するもの、 値を出力するもの、 ２例、挙げておきます。 １）遅くなる原因を十分に（未然に）（場合によっては必要以上に）排除しておく。 ２）オブジェクトへの参照は必要最小限にして、繰り返さない。 ３）計算を実行するタイミングを一度に纏める。 ３）については、本来は配列変数を使って数式を一気に出力するのが有力ですが、 ここでは、数式の先頭に全角空白を付加した文字列を一旦出力して、 置換機能で全角空白を削除するタイミングで計算させます。 「数式を出力するもの」 現状問題の遅さ、についての手当てとしては、主に３）の効果が大きいと思いますが、 １）２）については、ExcelyaExcel VBAを扱う上では、一応基本的な手法ですので、 書き加えています。 「値を出力するもの」 出力する数式の参照先のデータが変動値ではなく、固定であるならば、 ＶＢＡで計算したものを値で出力することで、実行を軽くできますし、 ファイルそのものを軽くできます。 １）の記述は、元に戻す処理と対になっています。 他の処理を書き加える時は、エラーに備えて、確実に元に戻すように エラーを制御するよう検討してください。 この手のテーマは、方法を伝えるよりサンプルを示した方が 解り易いんじゃないかな、と思ったので、例示として以下を提示します。 ' ' 「数式を出力するもの Sub Re8344147f() 　　Dim rRef As Range 　　Dim n As Long 　　Dim i As Long 　　With Sheets("Sheet2")　　'　　２） 　　　　For i = 55 To .Cells(Rows.Count, 2).End(xlUp).Row 　　　　　　If .Cells(i, 2) >= 3 Then Exit For 　　　　Next i 　　End With 　　n = i - 2 　　With Application　　'　　１） 　　　　.Calculation = xlCalculationManual 　　　　.EnableEvents = False 　　　　.ScreenUpdating = False 　　End With 　　Set rRef = Range("A55:A" & n)　　'　　２） 　　With Worksheets("Sheet3").Range("Q16:Q28")　　'　　２） 　　　　For i = 1 To 13　　'　　３）↓ 　　　　　　.Cells(i).Value = "　=Slope(Sheet2!" & rRef.Offset(, i * 2).Address(0, 0) & ",Sheet2!" & rRef.Offset(, i * 2 - 1).Address(0, 0) & "）" 　　　　Next i 　　　　.Replace "　", ""　　'　　３） 　　End With 　　Set rRef = Nothing 　　With Application　　'　　１） 　　　　.Calculation = xlCalculationAutomatic 　　　　.EnableEvents = True 　　　　.ScreenUpdating = True 　　End With End Sub ' ' 「値を出力するもの」 Sub Re8344147v() 　　Dim rRef As Range 　　Dim n As Long 　　Dim i As Long 　　With Sheets("Sheet2")　　'　　２） 　　　　For i = 55 To .Cells(Rows.Count, 2).End(xlUp).Row 　　　　　　If .Cells(i, 2) >= 3 Then Exit For 　　　　Next i 　　End With 　　n = i - 2 　　With Application　　'　　１） 　　　　.Calculation = xlCalculationManual 　　　　.EnableEvents = False 　　　　.ScreenUpdating = False 　　End With 　　Set rRef = Sheets("Sheet2").Range("A55:A" & n)　　'　　２） 　　With Worksheets("Sheet3").Range("Q16:Q28")　　'　　２） 　　　　For i = 1 To 13 　　　　　　.Cells(i).Value = Application.Slope(rRef.Offset(, i * 2), rRef.Offset(, i * 2 - 1)) 　　　　Next i 　　End With 　　Set rRef = Nothing 　　With Application　　'　　１） 　　　　.Calculation = xlCalculationAutomatic 　　　　.EnableEvents = True 　　　　.ScreenUpdating = True 　　End With End Sub
前の書き込みの続きです。 ※以下が、サンプルソース(2)です。。 //DllLoader.vb Start// Imports System.Runtime.InteropServices ''' <summary> ''' 動的DLLローダー ''' </summary> ''' <remarks></remarks> Public Class DllLoader 　　Implements IDisposable 　　Private Class kernel32API 　　　　<DllImport("kernel32", CharSet:=CharSet.Auto, SetLastError:=True)> _ 　　　　Public Shared Function LoadLibrary(ByVal lpFileName As String) As IntPtr 　　　　End Function 　　　　<DllImport("kernel32", CharSet:=CharSet.Auto, SetLastError:=True)> _ 　　　　Public Shared Function FreeLibrary(ByVal hModule As IntPtr) As Boolean 　　　　End Function 　　　　<DllImport("kernel32", CharSet:=CharSet.Ansi, SetLastError:=True)> _ 　　　　Public Shared Function GetProcAddress(ByVal hModule As IntPtr, ByVal lpProcName As String) As IntPtr 　　　　End Function 　　End Class 　　Private _ptrModule As IntPtr = IntPtr.Zero #Region "APIで発生した最後のエラー" 　　Private _lastErrorNo As Integer = 0 　　Public ReadOnly Property LastErrorNo() As Integer 　　　　Get 　　　　　　Return _lastErrorNo 　　　　End Get 　　End Property #End Region #Region "コンストラクタ" 　　''' <summary> 　　''' コンストラクタ 　　''' </summary> 　　''' <param name="p_strDllFullPath">DLLのフルパス</param> 　　''' <remarks></remarks> 　　Public Sub New(p_strDllFullPath As String) 　　　　_ptrModule = kernel32API.LoadLibrary(p_strDllFullPath) 　　　　If (_ptrModule = IntPtr.Zero) Then 　　　　　　_lastErrorNo = Marshal.GetHRForLastWin32Error 　　　　　　Dim ex As Exception = Marshal.GetExceptionForHR(_lastErrorNo) 　　　　　　Throw ex 　　　　End If 　　End Sub #End Region #Region "ロードしたDLLの解放処理" 　　''' <summary> 　　''' ロードしたDLLの解放処理 　　''' </summary> 　　''' <remarks></remarks> 　　Private Sub FreeLoder() 　　　　If (_ptrModule = IntPtr.Zero) Then 　　　　　　Return 　　　　End If 　　　　If Not kernel32API.FreeLibrary(_ptrModule) Then 　　　　　　_lastErrorNo = Marshal.GetHRForLastWin32Error 　　　　　　Dim ex As Exception = Marshal.GetExceptionForHR(_lastErrorNo) 　　　　　　Throw ex 　　　　End If 　　End Sub #End Region #Region "Delegateの取得" 　　''' <summary> 　　''' Delegateの取得 　　''' </summary> 　　''' <param name="p_strProcName">発行を行うメソッド名</param> 　　''' <param name="p_typProcType">発行を行うメソッド型</param> 　　''' <returns></returns> 　　''' <remarks></remarks> 　　Public Function GetDelegate(ByVal p_strProcName As String, ByVal p_typProcType As Type) As [Delegate] 　　　　If (_ptrModule = IntPtr.Zero) Then 　　　　　　Return Nothing 　　　　End If 　　　　Dim l_ptrProcAddress As IntPtr = kernel32API.GetProcAddress(_ptrModule, p_strProcName) 　　　　If (l_ptrProcAddress = IntPtr.Zero) Then 　　　　　　_lastErrorNo = Marshal.GetHRForLastWin32Error 　　　　　　Dim ex As Exception = Marshal.GetExceptionForHR(_lastErrorNo) 　　　　　　Throw ex 　　　　End If 　　　　Return Marshal.GetDelegateForFunctionPointer(l_ptrProcAddress, p_typProcType) 　　End Function #End Region #Region "IDisposable Support" 　　Private disposedValue As Boolean ' 重複する呼び出しを検出するには 　　Protected Overridable Sub Dispose(disposing As Boolean) 　　　　If (Not Me.disposedValue) Then 　　　　　　If (disposing) Then 　　　　　　　　Call FreeLoder() 　　　　　　End If 　　　　End If 　　　　Me.disposedValue = True 　　End Sub 　　Public Sub Dispose() Implements IDisposable.Dispose 　　　　Dispose(True) 　　　　GC.SuppressFinalize(Me) 　　End Sub #End Region End Class //DllLoader.vb End//
ForEachで FCを使ってるから FC.Select　’----------(1) じゃないですか？
No1です 住所の分割：G4セルに住所が有るとして Sub Bunkatu() Adr = Range("G4").Value '住所から県の位置を確認 Ken = 3 - (Mid(Adr, 4, 1) = "県")　 '番地の先頭（最初に出てくる数字）位置を確認 For i = 1 To Len(Adr) Ban = Mid(Adr, i, 1) If IsNumeric(Ban) Then Exit For End If Next i '分割した住所を代入 With Range("G4") .Offset(0, 2).Value = Right(Adr, Len(Adr) - i + 1) .Offset(0, 1).Value = Mid(Adr, Ken + 1, i - Ken - 1) .Value = Left(Adr, Ken) End With End Sub わかりにくいかな
.Object.ListRows = 20 では、如何でしょうか For i = 1 To 100 　　l = sh.Cells(i, "H").Left 　　t = sh.Cells(i, "H").Top 　　w = sh.Cells(i, "H").Width 　　h = sh.Cells(i, "H").Height 　　With sh.OLEObjects.Add(ClassType:="Forms.ComboBox.1") 　　　　.Left = l 　　　　.Top = t 　　　　.Width = w 　　　　.Height = h 　　　　.ListFillRange = "担当者" 　　　　.Object.ListRows = 20 　　　　.LinkedCell = "H" & i 　　　　.PrintObject = False 　　End With Next i
因みに、参照する先が「ブランクセルの場合の他、空白セルの場合もある」の場合は、式を以下のように変更して下さい。 =(OR(R[-1]C="",ISBLANK(R[-1]C))+"0"&R[-1]C)*(OR(R[-1]C[-3]="",ISBLANK(R[-1]C[-3]))+"0"&R[-1]C[-3]) =(OR(R[-1]C="",ISBLANK(R[-1]C))+"0"&R[-1]C)*(OR(R[-1]C[-4]="",ISBLANK(R[-1]C[-4]))+"0"&R[-1]C[-4]) 「ブランクセル」とは、本当に何も入れていないセルのこと。 「空白セル」は、ブランクではなく、式などで「長さ０の文字列」を書いているセルのこと。 例えば「=IF(空白にする条件,"",どこかのセルの値を参照する式)」など、IF関数を使っている場合に、値が「""」になるセルの場合が該当します。
＃１-３、ｃｊです。＃３訂正です。 > こんな風なシンプルな記述でも、二重起動することがありませんから、 > 問題になることはありません。 この記述は（私の認識の）誤りでした。 問題にならないのは、運用ルールによるものでした。 当方の環境でもやはり問題になる場面はあります。 開いていたブックと同一のブックを再度開こうとする場合、 開いていたブックに未保存のデータがあると、 ーーーーーーーーーーーーーーーーーーーーーーーーー "ブック名 .xlsは既に開いています。2乗に開くと、これまでの変更内容は破棄されます。ブック名 .xls　を開きますか？" [はい] [いいえ] ーーーーーーーーーーーーーーーーーーーーーーーーー というダイアログが表示され、 実行を中断せざるを得なくなります。 という訳で、ブックを開く前のタイミングで上書き保存してあれば、問題ない、 という但し書きを付けておくべきでした。 または、考えようによっては、予め、自ブック以外のブックをすべて閉じておいて それから一気に全部開く、などの方法も、検討に値するかも知れません。 以上、訂正でした。失礼しました。
Sheet1の、A1：E5　という範囲を、 Sheet2の、A1に貼り付ける。 既にSheet2のA1：E5に値が入っている場合は注意喚起のボックスが出る。 という形です。 ご意向に合っているでしょうか。 適宜アレンジください。 Sub ppp() Dim Ws1 As Worksheet, Ws2 As Worksheet Dim Res As Long Dim Rng As Range, Sel As Range, Flg As Boolean Set Ws1 = Worksheets("sheet1") Set Ws2 = Worksheets("sheet2") Flg = False With Ws2 Set Rng = .Range(.Cells(1, 1), .Cells(5, 5)) End With For Each Sel In Rng If Sel.Value <> "" Then Flg = True End If Next Sel If Flg = True Then Res = MsgBox("貼付先には既に値が入っています。処理を続けますか", vbYesNo) If Res = 6 Then With Ws1 .Range(.Cells(1, 1), .Cells(5, 5)).Copy End With Ws2.Cells(1, 1).PasteSpecial Paste:=xlPasteAll ElseIf Res = 7 Then MsgBox "終了します" Application.CutCopyMode = False Exit Sub End If ElseIf Flg = False Then With Ws1 .Range(.Cells(1, 1), .Cells(5, 5)).Copy End With Ws2.Cells(1, 1).PasteSpecial Paste:=xlPasteAll End If Application.CutCopyMode = False Set Rng = Nothing Set Ws1 = Nothing Set Ws2 = Nothing End Sub 一応説明。 １．まず貼り付け先の範囲にデータが入っていないか確認する。 ２．データがない場合　→　コピーして貼り付け ３．データがある場合　→　注意喚起のボックスを出す ４．それで「はい」ならば、コピーして貼り付け ５．いいえならば、終了
Q、iは、1,2,3のどれで合致しているか判別する方法はありますか? A、i の値で判別します。
隠しボタン経由でVBA側にイベントを発生させるとか。 http://www.gizcollabo.jp/vbtomo/log/archive/vbqa …
手元に Express エディションがないのですが、PasswordChar プロパティがデザイナーのプロパティ一覧にありませんか？ Premium とやらのエディションでは 「マスク (Mask?)」 という名前のプロパティがあるのですか？
Sample1の > Set objShell = CreateObject("Shell.Application") は要らないのでは。 Sample1は変数宣言と同時に参照をセット、Sample2はCreateObject関数で参照をセット、 Newキーワードの方が効率がいいです。 > 圧倒的にSample2の方がネットでは多いのですが 参照設定が要らないからでは。
こんいちは。 > 置換対象がなかったときは、その旨わかるようにしたいのですが、 > 方法あるでしょうか？ > ※毎回replaceの前でfind関数であるかないか、調べないと > いけないのでしょうか？ 何れにしても、条件分岐は必要な訳ですから、 なるべく簡単に片付けるとして、Instr()関数を使うのが標準的です。 また、見つからないワードを置換するのも無駄ではあるので、 特に"置換対象がなかったとき"を判別する必要がない場合でも、 Replace()関数はなるべくInstr()関数とセットで使うようにすると 効率的です。 Sub Re8335191() 　　Dim s0 As String 　　Dim sTgt As String 　　Dim sRtn As String 　　s0 = "abc" 　　sTgt = "a" 　　If InStr(s0, sTgt) > 0 Then 　　　　sRtn = Replace(s0, sTgt, UCase(sTgt)) 　　　　MsgBox s0 & "　→　" & sRtn 　　Else 　　　　MsgBox "notfound : " & sTgt 　　End If 　　sTgt = "d" 　　If InStr(s0, sTgt) > 0 Then 　　　　sRtn = Replace(s0, sTgt, UCase(sTgt)) 　　　　MsgBox s0 & "　→　" & sRtn 　　Else 　　　　MsgBox "notfound : " & sTgt 　　End If End Sub
ダイアログの「オプション」ボタンをクリックしてみればいいと思いますよ。
表示項目(Text)とリスト項目(DisplayMember)を異なる設定には出来ないみたいです そこで解決案として ComboBoxを継承したクラスを生成して この中に 選択用と表示用の2つのConnboBoxを作って制御するといった具合になろうかと思います ' 選択用に cbSelectなどを Private WithEvents で宣言 private withEvents cbSelect as ComboBox Sub Newを追加して cbSelect = new ComboBox ' 表示用のドロップダウンの高さを1に設定して 見かけ上非表示にする Me.DropDownHeight = 1 ' 選択用を非表示にする cbSelect.Visible =False ' 継承クラスのKeyDownイベントにて if e.Alt AndAlso e.KeyCode = keys.Down then 　　' 処理済にするため 　　e.Handled = true 　　' 選択用を表示して ドロップダウンリストを表示する 　　cbSelect.Show 　　cbSelect.DropDown = true 　　' 自分を非表示に 　　me.hide end if cbSelectのDropDownClosedイベントにて cbSelect.Hide me.Show me.Focus ' WINAPIの宣言を追加 　　<StructLayout(LayoutKind.Sequential)> _ 　　Structure tCOMBOBOXINFO 　　　　Dim cbSize As Integer 　　　　Dim rcItem As Rectangle 　　　　Dim rcButton As Rectangle 　　　　Dim stateButton As Integer 　　　　Dim hwndCombo, hwndItem, hwndList As IntPtr 　　End Structure 　　Declare Ansi Function SendMessage Lib "user32" Alias "SendMessageA" _ 　　　　(ByVal hWnd As IntPtr, ByVal umsg As UInt32, ByVal wParam As Integer, ByRef lParam As tCOMBOBOXINFO) As Integer 　　Const COMBOBOXINFO As UInt32 = &H164 　　Const STATE_SYSTEM_PRESSED As UInt32 = 8 　　Const STATE_SYSTEM_INVISIBLE As UInt32 = &H8000 　　Dim cbInfo As tCOMBOBOXINFO '　継承コントロールのMouseDownイベントで if e.Button = e.Button = Windows.Forms.MouseButtons.Left Then 　　Dim cb As tCOMBOBOXINFO 　　cb.cbSize = 52 　　If SendMessage(Me.Handle, COMBOBOXINFO, 0, cb) > 0 Then 　　　　If cb.stateButton = STATE_SYSTEM_PRESSED Then 　　　　　　cbSelect.Show() 　　　　　　cbSelect.DroppedDown = True 　　　　　　Me.Hide() 　　　　End If 　　End If end if ' 継承コントロールのParentChangedイベントで cbSelect.Parent = me.Parent ' 選択用のDisplayMemberプロパティの公開 public Property DisplayMember2 as String 　　get 　　　　return cbSelect.DisplayMember 　　End get 　　set(value as string) 　　　　cbSelect.DisplayMember = value 　　End Set End Property ' 選択用のDorpDownHeightプロパティの公開 　　Public Property DropDownHeight2() As Integer 　　　　Get 　　　　　　Return cbSelect.DropDownHeight 　　　　End Get 　　　　Set(ByVal value As Integer) 　　　　　　cbSelect.DropDownHeight = value 　　　　End Set 　　End Property ' Size Width Location DataSourceのShadow化 Public shadows Property Size as Size 　　get 　　　　retur myBase.Size 　　End Get 　　Set(value as Size) 　　　　cbSelect.size = value 　　　　myBase.size = value 　　End Set End Property ' 同様に Width Location DataSource を作成 といった具合で 出来るかと … 選択しているときの コンボボックスの表示が コード、読み、都道府県名 になってしまう点が ご希望に添えてないと思います
＃１、３、ｃｊです。＃３お礼欄拝見しました。 そういうことでしたら、 ユーザーフォームを簡単に活用するのが 煩わしくなくて便利、最適と思います。 ユーザーフォームに コマンドボタンをひとつ配置して（キャプションを"次のブック"等に） ' ' Userform モジュール Private Sub CommandButton1_Click() 　　ActiveWindow.ActivateNext End Sub ' ' 標準 モジュール Sub Re8331719uf() 　　UserForm1.Show vbModeless End Sub 準備はこれだけです。 Sub Re8331719uf()を実行して、ユーザーフォームを表示して、 後はボタンを押す度に次のブック（ウィンドウ）がアクティブになります。
＃２、ｃｊです。訂正です。 説明コメントに間違いがありました。 　　If Target.Row > 30 Then Exit Sub 値を変更したセルが30行めより下だったなら、 　　If Target.Column > 20 Then Exit Sub 値を変更したセルが20列め（T列）より右だったなら、 以上訂正をお願いします。失礼しました。
Ｎｏ．３です。 Ｄドライブに保存されたabc.csvと言うファイルの Ａ５からＡ列最終行にあたる範囲のデータを 貼り付ける場合ですが。 ⇒Ｅｘｃｅｌの参照設定は行なってません。 Dim xlApp As Object Dim xlCsv As Object Dim xlWs As Object Dim xlRng As Object Set xlApp = CreateObject("Excel.Application") xlApp.Visible = False Set xlCsv = xlApp.Workbooks.Open("D:\abc.csv") 'CSVファイルの保存先指定 Set xlWs = xlCsv.Worksheets(1) Set xlRng = xlWs.Range("A5", xlWs.Range("A" & xlWs.Rows.Count).End(-4162)) xlRng.Copy xlCsv.Close xlApp.Quit こんな感じでクリップボードには値は入ると思いますよ。
ASP.NET WebサービスでDataSet渡し http://www.atmarkit.co.jp/fdotnet/chushin/introw … ASP.NET Webサービスで型付きDataSet渡し http://code.msdn.microsoft.com/windowsdesktop/10 …
WinsockコントロールをtcpClientという名前でForm1に貼り付けている場合はtcpClientはForm1の配下にありますのでtcpClient.Protocolを標準モジュールに記述する場合は Form1.tcpClient.Protocol とする必要があります。 フォームに記述した場合はForm1.が省略可能なだけです。
その『行』というのが改行コードによるもので 自動的に右端で折り返された見た目の改行ではない場合です。 春よ来い 夏休み 小さい秋 春夏秋冬 冬が来る前に という内容のテキストファイル（d:\songs.txt) があったとして 標準モジュールにて Sub　testF() 　 Dim fSo As Object 　 Dim tTxt As Object 　 Dim i As Integer 　 Dim tStr As String, buf As String 　 Const ForReading As Integer = 1 　　 　　Set fSo = CreateObject("Scripting.FileSystemObject") 　　Set tTxt = fSo.GetFile("d:\Songs.txt").OpenAsTextStream(ForReading, -2) 　　 　　Do Until tTxt.atEndOfStream 　　　　i = i + 1 　　　　tStr = tTxt.readLine 　　　　If InStr(tStr, "春") > 0 Then 　　　　　　buf = buf & vbCrLf & i & "---" & tStr 　　　　End If 　　Loop 　　 tTxt.Close: Set tTxt = Nothing 　　Set fSo = Nothing 　　buf = Mid(buf, 3) 　　DoCmd.RunCommand acCmdDebugWindow　　 　　Debug.Print buf end Sub で 1---春よ来い 4---春夏秋冬 がイミディエイトウィンドウに出力されます。 ということ？
こんにちは。 >C#とphpを連携させる場合、データはやはりxmlが扱いやすいのでしょうか。 その辺はなんでもいいと言ったら乱暴ですが、お好みで大丈夫だと思います。 私ならJSONで組むと思います。 >また、こういったレンタルサーバーのDBに、 >早くて数秒～遅くて2,30秒間隔で、500バイトx3,000レコードを更新するのは、 >やはり高負荷となるのでしょうか。 >これは、別のカテゴリーで質問を立てるか、 >そもそもサーバー業者に問い合わせすべき内容かも知れませんが...。 個人的には負荷が高いかなと思います。 通信時間も入ると数秒の繰り返しでは、3000件のインサートが間に合わないかもしれません。 実際のところやってみないとわかりませんが。 もっと明るい人がいるかもしれませんので別の質問として聞いてみるのも手ですが、一番確実なのは業者に問合わせてください。 常にプロセスがCPUを食ってるとか、メモリの利用が高いと、強制的に止められてしまう可能性もありますので。
VBは使ったことはないのですが。 回答No.2 のやり方は問題が発生すると思われます。 関数やサブルーチンのローカル変数は呼ばれる度毎にスタック上に割り当てられ、サブルーチンから帰った後はローカル変数エリアは別の用途に使用され、破壊されてしまうのではないでしょうか。 配列(の先頭アドレス)を戻り値に指定する事は出来ますが、そのエリアは呼ぶ側が前もって割り当てておきサブルーチンコールのパラメータで指定するか、次善の策としてはコモンエリアやスタティックエリアを使って戻すなりする必要があると思われます。
CommandButton2.Value = True
フォーカスを失う直前のイベントとしてValidateイベントがあります。 こんな感じですかね。 private bkText1 as Variant Private Sub Text1_Validate(Cancel As Boolean) 　　If Text1.Value <> bkText1 then 　　　　MsgBox "テキストが変わりました" 　　EndIf 　　bkText1 = Text1.Value End Sub
xBk.Worksheets(1).Range("C5").xlPasteValues ↓ xBk.Worksheets(1).Range("C5").PasteSpecial Paste:=xlPasteValues こちらに変更してください。 PasteSpecial が形式を選択して貼り付けの事になり、xlPasteValuesで値になります。 思った動作をしないときには、マクロの記録をして、それでできたコードを参考にされたらよろしいと思います。 記録をすると Range("C5").Select Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _ :=False, Transpose:=False こんなコードが出来上がってきます。PasteSpecialでHELPを見ると他の引数の説明が見れます。
CubePDFは使っていないので動作検証はしていませんが、 これでいかがでしょうか？ With CreateObject("Wscript.Shell")　'保存先の所まで移動して名前をつける 　.SendKeys "{TAB}" 　.SendKeys "{TAB}" 　.SendKeys "{TAB}" 　.SendKeys "{TAB}" 　.SendKeys "{TAB}" 　.Run "%COMSPEC% /c echo " & Fname & "| clip", 0, True 'クリップボードにFnameをコピー 　.SendKeys "^v" '貼り付け 　.SendKeys "{ENTER}" End With
On Error Resume Next a = b+c If Err Then 　　Z=0 Else 　　Z=a End If On Error GoTo 0
どちらもiso-2022-jpがベースなので、 iso-2022-jpでデコードすればとりあえず何とかなる気がします。 (ただし、iso-2022-jpに含まれない文字は変換できないかと) 完全さを求めるのであればiso-2022-jp-2/3を扱えるライブラリでも探せば…… と思ったのですが、どうも.NET用のもC/C++用のもなさそうなので、 Encodingクラスを継承して自前でエンコードするしか方法はなさそうです。
#8の続きです。 AND条件だけに切り分けてコレクションに収納しています。 DoEventsは何度か暴走させた名残です(^^;) Function convertAnd(matchString As String) As Collection Dim targetString As String, orStr As String, singleChar As String Dim i As Long, j As Long, k As Long Dim rBracket As Long, matchStringLength As Long Dim mySQLseeds As Collection Dim orConditions As Variant Dim seed As Variant Dim seed2() As Variant Dim orFlag As Boolean Set mySQLseeds = New Collection targetString = treat(matchString) i = 1 matchStringLength = Len(targetString) Do Until i > matchStringLength DoEvents: DoEvents: DoEvents singleChar = Mid(targetString, i, 1) Select Case singleChar Case " " orFlag = False If i + 3 < matchStringLength Then If Mid(targetString, i, 4) = " OR " Then orFlag = True End If If orFlag Then If IsArray(seed) Then For j = 0 To UBound(seed) mySQLseeds.Add seed(j) Next j Else mySQLseeds.Add seed End If i = i + 4 seed = Empty Else If IsArray(seed) Then For j = 0 To UBound(seed) seed(j) = seed(j) & singleChar Next j Else seed = seed & singleChar End If i = i + 1 End If Case "(" rBracket = InStr(i + 1, targetString, ")") orStr = Mid(targetString, i + 1, rBracket - i - 1) orConditions = Split(orStr, " OR ") If UBound(orConditions) > 0 Then ' OR があるとき If IsArray(seed) Then ReDim seed2(0 To (UBound(seed) + 1) * (UBound(orConditions) + 1) - 1) For k = 0 To UBound(seed) For j = 0 To UBound(orConditions) seed2(k * (UBound(orConditions) + 1) + j) = seed(k) & orConditions(j) Next j Next k Else ReDim seed2(0 To UBound(orConditions)) For j = 0 To UBound(orConditions) seed2(j) = seed & orConditions(j) Next j End If 'seedを、seedに異なる抽出条件を付与した配列に置き換える seed = Empty seed = seed2 Else If IsArray(seed) Then For k = 0 To UBound(seed) seed(k) = seed(k) & orConditions(0) Next k Else seed = seed & orConditions(0) End If End If i = rBracket + 1 Case Else If IsArray(seed) Then For j = 0 To UBound(seed) seed(j) = seed(j) & singleChar Next j Else seed = seed & singleChar End If i = i + 1 End Select Loop If IsArray(seed) Then For j = 0 To UBound(seed) mySQLseeds.Add seed(j) Next j Else mySQLseeds.Add seed End If Set convertAnd = mySQLseeds End Function
以下の様な感じではどうでしょうか test1 を実行すると 0 ～ 9 の 3 つを使って・・・ test2 を実行すると A ～ J の 3 つを使って・・・ test3 を実行すると 混合のもので 3 つ使って・・・ 関数にした ReCode は再帰呼び出しで利用します。 呼び出す時には、 第一引数は、常に True 第二引数は、使う数字または文字とかの配列 第三引数は、何個使って 以下では　Cells(1, 1) から書き出します。 ソコソコ動くと思いますが、不都合あれば修正してください。 ※ 処理性能はわかりません Dim iRow As Long Dim iCol As Long Private Sub ReCode(bTop As Boolean, vAry As Variant _ 　　　　, iNst As Long, Optional vInAry As Variant) 　　Dim i As Long, j As Long 　　Dim vI As Variant, v As Variant 　　If (iNst <= 0) Then Exit Sub 　　If (bTop) Then 　　　　ReDim vI(1 To iNst) 　　　　Call ReCode(False, vAry, iNst, vI) 　　Else 　　　　vI = vInAry 　　　　j = UBound(vI) - iNst 　　　　For Each v In vAry 　　　　　　For i = 1 To j 　　　　　　　　If (vI(i) = v) Then Exit For 　　　　　　Next 　　　　　　If (i > j) Then 　　　　　　　　vI(j + 1) = v 　　　　　　　　If (iNst = 1) Then 　　　　　　　　　　Cells(iRow, iCol).Resize(, UBound(vI)) = vI　' Cell への書き出し 　　　　　　　　　　iRow = iRow + 1 　　　　　　　　Else 　　　　　　　　　　Call ReCode(False, vAry, iNst - 1, vI) 　　　　　　　　End If 　　　　　　End If 　　　　Next 　　End If End Sub Public Sub test1() 　　Dim vAry As Variant 　　Dim i As Long 　　ReDim vAry(9) 　　For i = 0 To 9 　　　　vAry(i) = i 　　Next 　　iRow = 1 　　iCol = 1 　　Call ReCode(True, vAry, 3) End Sub Public Sub test2() 　　Dim vAry As Variant 　　Dim i As Long 　　ReDim vAry(9) 　　For i = 0 To 9 　　　　vAry(i) = Chr(Asc("A") + i) 　　Next 　　iRow = 1 　　iCol = 1 　　Call ReCode(True, vAry, 3) End Sub Public Sub test3() 　　Dim vAry As Variant 　　Dim i As Long 　　ReDim vAry(9) 　　vAry(0) = "A" 　　vAry(1) = 1 　　vAry(2) = "B" 　　vAry(3) = 2 　　vAry(4) = "C" 　　vAry(5) = 3 　　vAry(6) = "D" 　　vAry(7) = 4 　　vAry(8) = "E" 　　vAry(9) = 5 　　iRow = 1 　　iCol = 1 　　Call ReCode(True, vAry, 3) End Sub
＃２、ｃｊです。＃２補足欄へのレスです。 ＃２補足欄のコードについては、 　　Range("B30").Resize(Day(DateSerial(Year(Date), Month(Date), 0)), 19).Select ということになるでしょうか。 列数が固定なら、これでいいと思います。 列数がユーザー操作で可変になっていて、それを適切に捉えたい、 ということでしたらば、以下。 > curentregionは使えないのですね。 使えない、ということはありませんけれども、 相対的なセル範囲を返すプロパティですから どう使えばいいかは、実物シートを見てみないと判らないのです。 基準となるRangeオブジェクトの周辺を検索して、 空行や空列、シートの終端、で挟まれた範囲を返すのが、 .CurrentRegion プロパティです。 なので、上、左、下、右、それぞれの方向で、 空行や空列の状況が判れば、使えます。 例えば、 　Rows(29)が空行、 　Rows(61)が空行、 　Columns("A")は、使用中、 　Columns("U")は、空列、だけど不確定。 　それらに挟まれた範囲を使用中 という条件ならば、 　Range("B30").CurrentRegion は、A30:T60、を返します。 こういう条件が判っていれば、 　　With Range("B30").CurrentRegion .Offset(, 1).Resize(Day(DateSerial(Year(Date), Month(Date), 0)), .Columns.Count - 1).Select 　　End With のような記述で、 列幅をCurrentRegionで自動的に変更しながら、範囲を捉えることができます。 ただ、問題点として.CurrentRegion プロパティの相対性がありますから、 もしも、何かの拍子に　Rows(29)　が空行でなくなってしまったり、 とか、期待通りに行かないケースは多々想像できます。 回答する立場からすれば、 .CurrentRegion プロパティを奨めるのに適した条件は、 上、左、が確定していて、下、や、右、に連続した範囲を取得したい場合、 などに限られてしまいます。 確実な空行、確実な空列が、どこどこにある、という情報があれば、 .CurrentRegion プロパティは十分に有効な手段になり得ます。 少し発想を柔らかく、ひとつひとつで考えてみると、 欲しいのはセル範囲なのですから、 「上、左、下、右」または「上、左、高さ、幅」が判ればいい ということに注目して考えてみてください。 　Range("B30")を基準にしている時点で「上、左」は判っています。 　Day(DateSerial(Year(Date), Month(Date), 0))、で、高さは求まりました。 　ここで不確定な幅を求めるにはCurrentRegionしかありませんが、 　「右」を求めるなら、.End プロパティもあります。 例えば、Range("B30") を基準に、右側、連続したセル範囲の終端を採るようにすれなら、 　　Range(Range("B30"), Range("B30").End(xlToRight)).Resize(Day(DateSerial(Year(Date), Month(Date), 0))).Select という記述も有効です。 この他、.CurrentRegion プロパティで求めたい処の「右側の終端」 よりも右側の列は一切使わない、という条件が明らかならば、 sheet.UsedRange プロパティが使える場合もあるでしょうけれど、 先回のご質問ではBR列を対象に処理していましたから、 今回も（類推として）、右側を使っている前提で考えていますので。 以上、一応、当てはまりそうな確率の高いものは、挙げてあるつもりです。 より適切な解決策も考えられますが、それにはシートの状況について情報が必要です。 まだ、スッキリとした解決に到っていないということでしたら、 Range("B30")からみて「上、左、下、右」の状況を、 実物シートが見えない人にも解るように説明してみてください。 ' ' ーーーーーーーーーーーーーーーーーーーーーーーーーー 　　※空行、空列、という用語については、 　　　（当該範囲について） 　　　数式や定数が設定されたセルがひとつもない、行、列、 　　　という意味で用いています。 ' ' ーーーーーーーーーーーーーーーーーーーーーーーーーー
dcount("*" ,"msysObjects","type = -32768 and name = 'チェックしたいフォーム名'") では。 http://www.nurs.or.jp/~ppoy/access/access/acQ017 … ↑解説はこちらにて。
そのライブラリの提供元に聞くのが早いと思いますが … 多分 CmdSizeの型が ULongではなく shortでいいのだと思います
案１ 取りあえず必要なだけコマンドボタンを配置する ５個だと仮定して フォームのモジュール内に Function cmdSel() 　　Dim cb As Control 　　Set cb = Screen.ActiveControl 　　Select Case cb.Name 　　　　Case "コマンド0" 　　　　　　MsgBox "0" 　　　　Case "コマンド1" 　　　　　　MsgBox "1" 　　　　Case "コマンド2" 　　　　　　MsgBox "2" 　　　　Case "コマンド3" 　　　　　　MsgBox "3" 　　　　Case "コマンド4" 　　　　　　MsgBox "4" 　　End Select 　　Set cb = Nothing End Function とします。 各コマンドボタンのクリック時イベントの欄に =cmdsel() としてみてください。 案２ 「オプション グループ」コントロールを配置し（仮名フレーム1） その中にトグルボタンを５個配置し、それぞれのオプション値を０～４にします。 オプショングループのクリック時イベントに Private Sub フレーム1_Click() 　　Select Case Me!フレーム1.Value 　　　　Case 0 　　　　　　MsgBox "0" 　　　　Case 1 　　　　　　MsgBox "1" 　　　　Case 2 　　　　　　MsgBox "2" 　　　　Case 3 　　　　　　MsgBox "3" 　　　　Case 4 　　　　　　MsgBox "4" 　　End Select End Sub Accessのバージョンが不明なので2010の場合↓ http://hamachan.info/win7/Access/option.html
ここを直してみて下さい 誤：cnt = Cells(Rows.Count, 1).End(xlDown).Offset(1, 0).Row ↓ 正：cnt = Cells(Rows.Count, 1).End(xlUp).Offset(1, 0).Row
SelectNodesを使って抽出を行えば いいと思いますよ dim objList, objNode Set objList = objXml.SelectNodes("//links/link/sx") for each objNode in objList 　　objNode.Text = "200" next といった具合です
例えば、格納フォルダパスが、"#C:\Users\myName\デスクトップ#" のようになっているとしたら FolderName= mid(rst![格納フォルダパス],2,len(rst![格納フォルダパス])-2) では。
時間が足りなかったようですね Application.Wait (Now + TimeValue("0:00:10"))←　0：00：20　とか増やす方法もありますが 環境によって変更するようだと、不細工なので ------ここから ActiveWindow.SelectedSheets.PrintOut Copies:=1, Collate:=True, _ IgnorePrintAreas:=False '↑プリントアウト Do cuHw = FindWindow(vbNullString, "CubePDF 1.0.0RC4 (x64)") Loop While cuHw = 0 '↑CubeBDFのウインドーが開いたかどうかを確認（この段階ではまだアクティブになるまで若干間がある） SetForegroundWindow cuHw '↑CubeBDFのウィンドーをアクティブ化 SendKeys "{ENTER}" ------ここまで cuHw = FindWindow(vbNullString, "CubePDF 1.0.0RC4 (x64)")←この部分は環境によって変更の必要あり "CubePDF 1.0.0RC4 (x64)"　CubuPDFのバージョンに拠って変化します 添付画像を参考にして赤枠で囲まれたウィンド名に変更して下さい Win32 API関数 SetForegroundWindow　と　 FindWindow　を使用していますので 標準モジュールに ----- Declare Function FindWindow Lib "user32.dll" Alias "FindWindowA" _ (ByVal lpClassName As String, _ ByVal lpWindowName As String) As Long Declare Function SetForegroundWindow Lib "user32" _ (ByVal hwnd As Long) As Long ----- 宣言文をおいて下さい http://www.happy2-island.com/excelsmile/smile01/ …
インストーラーを作っていない場合は、あなたが想定される環境下で プログラムを走行させることはできません。
＃２、３、４、ｃｊです。＃４に追加レスです。 自分ならこういう場合.Findメソッドを使わずに こんな感じにすると思います。 ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー ' ' / 検索にヒットしたセルすべてに処理を施す場合 Sub Re8317255C() 　　Dim FC As Range 　　Dim flg As Boolean 　　For Each FC In Range("BR30:BR90") 　　　　If FC.Value = DateValue("2013/10/20") Then 　　　　　　MsgBox "Found" & vbLf & FC.Address(0, 0) & vbLf & FC.Value 　　　　　　flg = True 　　　　　　' ' ここに処理を追加したい 　　　　　　Exit For 　　　　End If 　　Next 　　If Not flg Then 　　　　MsgBox "NotFound" 　　　　Exit Sub 　　End If 　　' ' その他見つかった場合の処理 End Sub ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー '場合によっては、以下。 ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー ' ' / ひとつ見つかれば、その他を探す必要がない場合 Sub Re8317255J() 　　Dim FC As Range 　　For Each FC In Range("BR30:BR90") 　　　　If FC.Value = DateValue("2013/10/20") Then 　　　　　　Exit For 　　　　End If 　　Next 　　If FC Is Nothing Then 　　　　MsgBox "NotFound" 　　　　Exit Sub 　　End If 　　MsgBox "Found" & vbLf & FC.Address(0, 0) & vbLf & FC.Value 　　' ' ここに処理を追加したい 　　 　　Set FC = Nothing End Sub ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー '＃本当は日付値かどうかを確認する条件分岐が必要ですが、省略形で提示しました。
＃１、ｃｊです。＃１補足欄拝見しました。 > →記載していませんでしたが、セルに関数が入っているので、不要な行が印刷されてしまいます。 > A～M列に関数がはいっており、計算されたセルの行のみ印刷するという処理が可能でしょうか？ > 大変申し訳ないですが、ご教授ください。★★★ "計算されたセルの行のみ印刷"という条件判別ですが、 Ａ列の値（数式の戻り値）が、""（文字列値""）ならば、処理を終わらせるように書いてみました。 想定しているのは、=IF(条件,値,"")、のような構文の数式が設定されている場合です。 うまく行かない場合は、数式そのものを補足してください。 判別がうまく行けば、無駄な印刷は省けます。 '　　修正↑▲結合セル▲ と記した行は結合セルである、という情報を元に、従来記述をコメントブロックして、 適正化したものをひとつ上の行に書き加えました。 もし、Sheets("問合せ回答一覧")への差し込みがうまく行かない場合は、 書き加えた行を削除して、コメントブロックを解除してください。 私が書く処理では扱いませんが、 変数 myLastCol について、もし、そちらでお使いになる場合は、 今回、15:16列にフラグを出力する関係で、UsedRangeの列幅が変わってしまう かも知れないので、注意してください。 以上です。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Sub 流し込み印刷()　　' '　　 8315727_2 　　Dim mylastRow As Long ' ' 最終行を格納する変数 　　Dim myLastCol As Integer ' ' 最終列を格納する変数　　'　　回答のコードでは未使用▼ 　　Dim myLastCell As String ' ' 最終セルを設定する変数　　'　　回答のコードでは未使用▼ 　　With Sheets("データ入力") 　　　　.Select　　'　　※注意！以下、Select禁止 　　　　 With .UsedRange ' ' 対象はアクティブシートの使用中のセル 　　　　　　' ' 最終行の行番号 　　　　　　 mylastRow = .Rows(.Rows.Count).Row 　　　　　　' ' 最終列の列番号 　　　　　　 myLastCol = .Columns(.Columns.Count).Column　　'　　回答のコードでは未使用▼ 　　　　End With 　　End With 　　Dim i As Integer 　　With Sheets("問合せ回答一覧") 　　　　For i = 7 To mylastRow 　　　　　　If Cells(i, 1) = "" Then Exit For　　'　　修正▲空行なら処理を抜ける。Ａ列が空セル、という条件▲ 　　　　　　If Cells(i, 15) <> True Or Cells(i, 16) <> True Then　'　　10:00、11:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　.Range("F3:J5,H8:V17").Value = Empty 　　　　　　　　If Cells(i, 15) <> True Then　 '　　10:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　　　' ' 10:00、1 - 3 　　　　　　　　　　.Range("F3:F5").Value = Application.Transpose(Cells(i, 1).Resize(, 3).Value) '　　　　　　　　　　.Range("F3:J5").Value = Application.Transpose(Cells(i, 1).Resize(, 3).Value)　　'　　修正↑▲結合セル▲ 　　　　　　　　　　Cells(i, 15) = True　　'　　10:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　End If 　　　　　　　　If Cells(i, 16) <> True Then　　'　　11:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　　　' ' 11:00、4 - 13 　　　　　　　　　　.Range("H8:H17").Value = Application.Transpose(Cells(i, 4).Resize(, 10).Value) '　　　　　　　　　　.Range("H8:V17").Value = Application.Transpose(Cells(i, 4).Resize(, 10).Value)　　'　　修正↑▲結合セル▲ 　　　　　　　　　　Cells(i, 16) = True　　'　　11:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　End If 　　　　　　　　.PrintOut Preview:=True 　　　　　　End If 　　　　Next i 　　End With　　'　Sheets("問合せ回答一覧") 　　i = i + 1　　'　　回答のコードでは未使用▼ End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
・パスからディレクトリ名を得る Path.GetDirectoryName http://msdn.microsoft.com/ja-jp/library/vstudio/ … ・パスからファイル名を得る Path.GetFileName http://msdn.microsoft.com/ja-jp/library/vstudio/ … ・パスからファイル名 (拡張子抜き) を得る Path.GetFileNameWithoutExtension http://msdn.microsoft.com/ja-jp/library/vstudio/ … ・パスから拡張子を得る Path.GetExtension http://msdn.microsoft.com/ja-jp/library/vstudio/ … ・パスの要素を結合する Path.Combine http://msdn.microsoft.com/ja-jp/library/vstudio/ … このあたりのメソッドを使ってファイル名を組み立てて，File.Copyメソッドでファイルをコピーします。 http://msdn.microsoft.com/ja-jp/library/vstudio/ …
2003でも空白のあるファイル名でも正常にDirでファイル名を返します。 もしかして、違うフォルダでDirを実行されていませんか ChDriveでドライブをChDirでフルパスでフォルダを指定してみてください。
おもしろそうだったのでやってみました。 やってみたのは３パターン ・「test1」 　乱数でどこに、乱数で何（値 1 ～ 4）を、を求めて 　値を設定しないところは 0 のまま ・「test2」 　乱数でどこに、を求めて 1 を加算していく 　最悪無限ループに陥るかも ・「test3」 　test2 の改良バージョン 傾向としては、 test1 は、最大値がでやすい？（乱数でどこ・・・が同じなら加算していたので） test2 / test3 は平均されやすい？（乱数の発生頻度と同じ？） 0 の出現は、 test2 / test3 では少ない様な気がします。 （乱数なので、そういうものとしても良いのかも） While 内の実行回数の少ない順（変数 k の値）は、 　test1（100回以下） < test3（100回） < test2（100回以上） の様な感じ（雰囲気で） 説明は省いても良いですかね 確かめられるのであれば、 　　Const CNUMSUM As Long = 100 ' 合計値 　　Const CROWMAX As Long = 30　' 行数 　　Const CNUMMAX As Long = 4　　' 最大値 の値を変更して、 　CROWMAX * CNUMMAX > CNUMSUM になっていればソコソコ動くと思います。 Public Sub test1() 　　Const CNUMSUM As Long = 100 　　Const CROWMAX As Long = 30 　　Const CNUMMAX As Long = 4 　　Dim iAry(1 To CROWMAX) As Long 　　Dim i As Long, k As Long 　　Dim iNum As Long, iR As Long 　　Randomize 　　For i = 1 To CROWMAX 　　　　iAry(i) = 0 　　Next 　　k = 0 　　iNum = CNUMSUM 　　While (iNum > 0) 　　　　k = k + 1 　　　　i = Int(CROWMAX * Rnd()) + 1 　　　　iR = Int((CNUMMAX) * Rnd()) + 1 　　　　If (iAry(i) + iR > CNUMMAX) Then iR = CNUMMAX - iAry(i) 　　　　If (iR > iNum) Then iR = iNum 　　　　iAry(i) = iAry(i) + iR 　　　　iNum = iNum - iR 　　Wend 　　Debug.Print "k = " & k 　　Range("A1").Resize(CROWMAX) = _ 　　　　　　WorksheetFunction.Transpose(iAry) End Sub Public Sub test2() 　　Const CNUMSUM As Long = 100 　　Const CROWMAX As Long = 30 　　Const CNUMMAX As Long = 4 　　Dim iAry(1 To CROWMAX) As Long 　　Dim i As Long, k As Long 　　Dim iNum As Long 　　Randomize 　　For i = 1 To CROWMAX 　　　　iAry(i) = 0 　　Next 　　k = 0 　　iNum = CNUMSUM 　　While (iNum > 0) 　　　　k = k + 1 　　　　i = Int(CROWMAX * Rnd()) + 1 　　　　If (iAry(i) < CNUMMAX) Then 　　　　　　iAry(i) = iAry(i) + 1 　　　　　　iNum = iNum - 1 　　　　End If 　　Wend 　　Debug.Print "k = " & k 　　Range("B1").Resize(CROWMAX) = _ 　　　　　　WorksheetFunction.Transpose(iAry) End Sub Public Sub test3() 　　Const CNUMSUM As Long = 100 　　Const CROWMAX As Long = 30 　　Const CNUMMAX As Long = 4 　　Dim iAry(1 To CROWMAX) As Long, iPos(1 To CROWMAX) As Long 　　Dim i As Long, j As Long, k As Long 　　Dim iNum As Long, iHdn As Long 　　Randomize 　　For i = 1 To CROWMAX 　　　　iAry(i) = 0 　　　　iPos(i) = i 　　Next 　　k = 0 　　iNum = CNUMSUM 　　iHdn = 0 　　While (iNum > 0) 　　　　k = k + 1 　　　　j = Int((CROWMAX - iHdn) * Rnd()) + 1 　　　　i = iPos(j) 　　　　iAry(i) = iAry(i) + 1 　　　　If (iAry(i) >= CNUMMAX) Then 　　　　　　iPos(j) = iPos(CROWMAX - iHdn) 　　　　　　iHdn = iHdn + 1 　　　　End If 　　　　iNum = iNum - 1 　　Wend 　　Debug.Print "k = " & k 　　Range("C1").Resize(CROWMAX) = _ 　　　　　　WorksheetFunction.Transpose(iAry) End Sub
スペルミスを防ぐ意味でも、GetTypeメソッドではなくGetType演算子を使うのが吉 Dim t_data As Type = GetType(System.String) http://msdn.microsoft.com/ja-jp/library/tay4kywk(v=vs.90).aspx
>できれば、スマートな形で、対処したいと思っています。 >※goto文しかないですかね？ 一番の回答の後半部のIF～Then～Elseを使う方法でよいんじゃないでしょうか。 つまり For　・・・ 　前半の処理 　If ある条件に合致しない Then 　　後半の処理 　End if Next ですね。
こんにちは。 何れにしても、"済"かどうかのフラグについては セル範囲を使って管理するのが妥当でしょう。 仮に、印刷済のフラグ、について 　列位置を　　15:16列め（O:P列） 　フラグを　　［ True　｜　その他］ といった具合に設定した場合の例です。 列位置については、 　10:00 が、印刷済、なら、１５列め 　11:00 が、印刷済、なら、１６列め にフラグを設定するように書いています。 書換えが必要なら、ＶＢＥの置換機能で 　15 　16 をそれぞれ、指定の列番号に［すべて置換してみてください。 一応指定が必要な個所に◆マークを振ってあります。 ついでに、オブジェクトアクセスに無駄が多かったので最適化します。 また、Sheets("データ入力")からSheets("問合せ回答一覧")への 値の差し込みも、ブロック毎に纏めて処理するように書いています。 それと、ひとつ気になったのですが、 　　　　.Range("F3:J5").Value = ... 　　　　.Range("H8:V17").Value = ... これ　↑　何故複数列に同じ値を設定するのかな？と考えたのですが、 もしかして[セルの結合]を適用した範囲、ということでしたらば、 　　　　.Range("F3:F5").Value = ... 　　　　.Range("H8:H17").Value = ... という風に一番左の単列を指定するのが正しいです。 ' ' 以下、標準モジュール ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Sub 流し込み印刷()　　' '　　 8315727 　　Dim mylastRow As Long ' ' 最終行を格納する変数 　　Dim myLastCol As Integer ' ' 最終列を格納する変数 　　Dim myLastCell As String ' ' 最終セルを設定する変数 　　With Sheets("データ入力") 　　　　.Select　　'　　※注意！以下、Select禁止 　　　　With .UsedRange ' ' 対象はアクティブシートの使用中のセル 　　　　　　' ' 最終行の行番号 　　　　　　mylastRow = .Rows(.Rows.Count).Row 　　　　　　' ' 最終列の列番号 　　　　　　myLastCol = .Columns(.Columns.Count).Column 　　　　End With 　　End With 　　Dim i As Integer 　　With Sheets("問合せ回答一覧") 　　　　For i = 7 To mylastRow 　　　　　　If Cells(i, 15) = True Or Cells(i, 16) = True Then　'　　10:00、11:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　.Range("F3:J5,H8:V17").Value = Empty 　　　　　　　　If Cells(i, 15) <> True Then　 '　　10:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　　　' ' 10:00、1 - 3 　　　　　　　　　　.Range("F3:J5").Value = Application.Transpose(Cells(i, 1).Resize(, 3).Value) 　　　　　　　　　　Cells(i, 15) = True　　'　　10:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　End If 　　　　　　　　If Cells(i, 16) <> True Then　　'　　11:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　　　' ' 11:00、4 - 13 　　　　　　　　　　.Range("H8:V17").Value = Application.Transpose(Cells(i, 4).Resize(, 10).Value) 　　　　　　　　　　Cells(i, 16) = True　　'　　11:00◆印刷済フラグ、列位置を指定◆ 　　　　　　　　End If 　　　　　　　　.PrintOut 　　　　　　End If 　　　　Next i 　　End With　　'　Sheets("問合せ回答一覧") 　　i = i + 1 End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ご提示のコードだけを頼りにして、素直にお応えしたつもりですが、 これでいいのかな？とも思っています。 例えば、10:00の分は印刷済で、11:00の分以降を印刷する、という場合、 Sub 流し込み印刷 を実行すると、F3:J5 を空欄のまま印刷する仕様です。 もしかしたら、3:5行や8:17行を非表示にして印刷したいのかも知れない、とか、 もしかしたら、フラグによって差し込み位置を可変にしたいのかも知れない、とか、 もしかしたら、Sub 流し込み印刷　の実行を何らかのイベントで自動化したいのかも知れない。とか、 想像はしてみましたが、そこまでのニーズではないと判断しました。 何れにしても、 > 印刷済フラグをチェックし、再度印刷されないようにしたい というリクエストについては、大体、こんな感じになると思いますので。 ニーズに適うものが書けていれば、それが一番いいのですが、 もしも、仕様上の不足がある場合、そしてもしも他に回答が付かない場合、には、 ここは一旦閉じて、シートイメージなどを付した詳細な形で質問を建て直した方が、 解決は近いと思います。 私の回答上の不備や、既に説明されている範囲での仕様に対する誤解や、想定外のエラーや、 処理内容に関する質問、等、あれば、補足欄にでも書いてみてください。
LookIn:=xlFormulas ↓ LookIn:=xlValues じゃありませんか、式を検索してるのではありませんよね。 で、 ActiveCell.Offset(0, -7).Activate この部分でエラーになりますけど…これをやってる意味が分かりませんので…
#2です、変な沼から抜け出せた嬉しさに（言い訳）推敲不足で投稿してしまいました。 最初のFunctionのbufは使用しておらず、消し損ないのゴミです。申し訳ありません。 Function KE(element As Range) KE = 0.5 * WorksheetFunction.SumProduct(element.Columns(1).Value, element.Columns(2).Value, element.Columns(2).Value) End Function
Dim 文字 As Variant 文字 = "2013年10月5日（土）" 文字 = DateValue(Left(文字, Len(文字) - 3)) MsgBox Format(文字, "yyyymmdd")
No1の補足です。 Sub Sample2() Dim oApp As Workbook Set oApp = Workbooks("Book1.xls") oApp.Sheets("Sheet3").Range("A1").Value = "AAA" End Sub こちらでもよろしいのではないでしょうか。
こんにちは。 セル範囲の捉え方、がポイントですね。 色々な書き方が可能ですし、どう書くかは、状況によりますけれど、 必ずしも、９行め、でなくても動くような書き方が 需要が多い思いますから、２例、挙げてみます。 Sub Re8310635a() 　　Dim i As Long 　　i = 9 　　If Cells(i, "C") = "" Then 　　　　If Cells(i + 1, "C") = "" Then 　　　　　　Rows(i).Delete 　　　　Else 　　　　　　Rows(i).Resize(, 6) = Array("[ID]", "氏名", "住所", "年齢", "電話番号", "備考") 　　　　End If 　　End If End Sub Sub Re8310635c() 　　Dim i As Long 　　i = 9 　　With Cells(i, "C") 　　　　If .Value = "" Then 　　　　　　If .Offset(1).Value = "" Then 　　　　　　　　.EntireRow.Delete 　　　　　　Else 　　　　　　　　.EntireRow.Resize(, 6) = Array("[ID]", "氏名", "住所", "年齢", "電話番号", "備考") 　　　　　　End If 　　　　End If 　　End With End Sub
=Replace(文字,"c","0")
こんにちは、参考に Sub Test() 　　Dim arrValue(), v As Variant 　　Dim c As Range, i As Long, j As Long 　　i = -1 　　For Each c In Range("A1", Cells(Rows.Count, "A").End(xlUp)) 　　　　If c.Value = "" Then 　　　　　　i = i + 1 　　　　　　ReDim Preserve arrValue(i) 　　　　　　arrValue(i) = "" 　　　　Else 　　　　　　v = Split(c.Value, vbLf) 　　　　　　For j = 0 To UBound(v) 　　　　　　　　i = i + 1 　　　　　　　　ReDim Preserve arrValue(i) 　　　　　　　　arrValue(i) = v(j) 　　　　　　Next 　　　　End If 　　Next 　　'<<< 配列確認 >>> 　　For i = 0 To UBound(arrValue) 　　　　MsgBox arrValue(i) 　　Next End Sub
VBAのみで実現する方法としては、Application.Runメソッドを使うというのがあります。 引数にも戻り値にも配列が使えます。 Accessは持っていないのでWordとExcelで試してみました。 まずExcelで標準モジュールに以下のプロシージャを書き込んだブックを開きました。 Function MinMax(a) MinMax = Array(WorksheetFunction.Min(a), WorksheetFunction.Max(a)) End Function 次にWordで以下のプロシージャを実行しました。 Sub test1() a = Array(1, 2, 0, 3, 5, 4) Set xl = GetObject(, "excel.application") m = xl.Run("MinMax", a) Debug.Print m(0); m(1) End Sub 実行結果としてWordのVBEのイミディエイトウィンドウに 0 5 と表示されました。 なお、参照渡し(ByRef)による変数書き換えですが、ちょっと検証したところでは、WordからExcelを呼び出すとうまくいくのですがExcelからWordを呼び出したらだめでした。 これがAccessでどうなるかはわかりませんし、そもそもこの検証結果もまだ不十分です。 よって、引数の参照渡しを用いた変数書き換えは行わないのが無難なように思います。 もう１つ考えられる方法としては、Excelのセル範囲と２次元配列を使う方法です。 たとえば、Excelで何かワークシートを表示しておき、他のアプリケーションのVBAで Set xl = GetObject(, "excel.application") a = xl.activesheet.Range("a1:c2").Value とするとセル範囲a1:c2の値が3×2の配列に取り込まれます。配列をワークシートに書き込むこともできます。
iTextSharpを使うのはどうですか？ http://yumenohako.jp/cgi-bin/c/wiki.cgi?page=C%2 … 参考URL：http://itextpdf.com/
セル値の読み書きだけでいいなら、可能です。 Visual Basic .NET と ADO.NET を使用して Excel ブックのレコードの取得と変更を行う方法 http://support.microsoft.com/kb/316934/ja
後で気付きましたが前回の回答の不等号の方向が間違っておりました。 申し訳ありませんm(_ _)m 「日付がきたら下記のプログラム文の動作を中止する」でしたら If Date >= #1/1/2014# Then Exit Sub ～以下色塗り動作のコード のように、先頭に一行記述を行えば良いかと思います。
No1です。 Application.ScreenUpdating = False に設定していませんか？ もししているなら、 ws.Selectの前に Application.ScreenUpdating = True を入れて下さい。 後、webで"ステップ実行"を検索して どの様にプログラムが実行されているか、確認して下さい。
何度もごめんなさい。 間違いの上塗りをしていました。 すでにお判りだと思いますが、 ＞=TODAY()>=DATE(2013,1,1) じゃなくて ＞=TODAY()>=DATE(2014,1,1) です。m(_ _)m
No.2です。 ProgressBarは本来DoEvents()やRefreshで更新しなくてもValueの値を更新すると表示も更新される作りになっています、表示が更新されないのは「進捗数」が変化していないことが考えられます、そのあたりの確認をしてみてください。
こんな感じでどうでしょうか。不具合等あったら申し訳ありません。 前提として 「日付等」の列は日付のみ（yyyy/mm/dd形式） 「名称」の右横の列に「日付等」の項目があるとします。 一部一致ということが具体的にどのようなことか詳細がわかりませんでしたので、とりあえず全一致で作成しました （※そのあたりは質問者様側で修正可能であれば適宜変更願います） ※日付等の欄が単純なテキスト形式であれば、 If Format(c.Offset(, 1).Value, "yyyy/mm/dd") = TextBox2.Value Then の所を単純に If c.Offset(, 1).Value = TextBox2.Value Then 等でも動くかと思います。 '検索ボタン（CommandButton1） Private Sub CommandButton1_Click() Dim c As Range Dim fc As Range Dim s As Worksheet Dim q As Long q = 0 ListBox1.Clear For Each s In ActiveWorkbook.Worksheets Set c = s.Cells.Find(what:=TextBox1.Text, lookat:=xlWhole) If Not c Is Nothing Then Set fc = c Do If Format(c.Offset(, 1).Value, "yyyy/mm/dd") = TextBox2.Value Then With ListBox1 .AddItem .List(q, 0) = s.Name .List(q, 1) = TextBox1.Value .List(q, 2) = TextBox2.Value End With q = q + 1 End If Set c = s.Cells.FindNext(c) Loop Until c.Address = fc.Address End If Next End Sub '表示ボタン（CommandButton2） Private Sub CommandButton2_Click() Sheets(ListBox1.List(ListBox1.ListIndex, 0)).Activate End Sub
仮にDataGridViewのあるフォームをForm1、NumericUpDownのあるフォームをForm2とします。 Form1のDataGridVewの名前をDataGridVew1とし、一行に３つのセルがあるとします。 その３つのセルに対応するForm2のNumericUpDownの名前を、NumericUpDown1、NumericUpDown2、NumericUpDown3とします。 DataGridVew1の任意の１行の全体を選択したいので、MultiSelectプロパティをFalseに、SelectionModeプロパティをFullRowSelectに設定します。 コードの編集で、DataGridVew1を選択し、SelectionChangedのイベントを選択して、Form2の３つのNumericUpDownにDataGridVew1の各セルの値を渡すためのコードを追加します。 Private Sub DataGridView1_SelectionChanged(sender As Object, e As EventArgs) Handles DataGridView1.SelectionChanged Form2.NumericUpDown1.Value = Me.DataGridView1.SelectedRows(0).Cells(0).Value Form2.NumericUpDown2.Value = Me.DataGridView1.SelectedRows(0).Cells(1).Value Form2.NumericUpDown3.Value = Me.DataGridView1.SelectedRows(0).Cells(2).Value End Sub 行も列もインデックスが0から始まることに注意します。 これでForm2を表示させて、Form1のDataGridView1の任意の行を選択すると選択された行の各セルの値がForm2のNumericUpDownに反映されます。 更に、Form2のNumericUpDownの値を変更してその値をForm1のDataGridViewに反映させるには、Form2にボタンを一つ追加して以下のコードを書き込みます。 Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click Form1.DataGridView1.SelectedRows(0).Cells(0).Value = Me.NumericUpDown1.Value Form1.DataGridView1.SelectedRows(0).Cells(1).Value = Me.NumericUpDown2.Value Form1.DataGridView1.SelectedRows(0).Cells(2).Value = Me.NumericUpDown3.Value End Sub これだけです。あとは適当にアレンジしてください。
MsgBox Err.Number 　　　　↓ MsgBox Err.Number & vbCrLf & Err.Description
たとえば以下のような感じで Sub Sample() Dim MyMakeFile As Object Dim MyPath As String Dim MyFileName As String Dim i As Integer Set MyMakeFile = CreateObject("Scripting.FileSystemObject") MyPath = "D:\temp" For i = 1 To Range("A" & Rows.Count).End(xlUp).Row MyFileName = MyMakeFile.BuildPath(MyPath, Range("A" & i).Value) MyMakeFile.CreateTextFile MyFileName Next i Set MyMakeFile = Nothing End Sub
UpDownボタンを前提に。 プロパティの項目を調べればできると思いますが。 たとえば、ボタンクリックで、 Private Sub Command1_Click() With UpDown1 .Min = 10 .Max = 20 .Wrap = True .Value = 10 Text1.Text = .Value End With End Sub のように設定できます。 UpDownボタンを押したときのイベントは、 Private Sub UpDown1_Change() Text1.Text = UpDown1.Value End Sub のように。 また、表示を小数を表示する場合は、 Private Sub UpDown1_Change() Text1.Text = UpDown1.Value / 10 End Sub のような方法もあります。
トップページの階層=／　ルートとは限りません。 指定したパスはルート指定です。もちろん、これは、ＵＮＩＸ系、Ｌｉｎｕｘ系のＯＳである場合ですが、まあ、ＦＴＰ、ＨＴＴＰサーバーであれば、解釈できるような事もおおいが。 ＦＴＰ、ＨＴＴＰなどは、公開用フォルダーを指定されています。その場合、そこがＨＯＭＥとなり、/ or c:\ ではないですね。ＦＴＰなどリモート操作は、ログインしてコネクションした場合、ログインしたユーザーのＨＯＭＥ又は、そのサービスが公開されているパスに導かれます。それで絶対してしまうと、アクセス不能な場所を指定しまうこともあります。 これはクライアントツールにもよるし、サーバー側のサービスにもよります。 例えば、ログインして呼び出された所を指定するならカレントを意味するドット " . " -> ログインした時のフォルダーを指定したければ ” ./../”　　　　　→　ＨＯＭＥの一つ上の階層が指定された事に。　”　../ ”と同じ を指定すれば、ほぼ動作は期待とおりになります。相対パス指定を試してみてください。””でフォルダー指定なしでも通じると思います。仕様が明確でないので、何ともいえませんが、””はリモートフォルダーを指定しなかった。という事だと思いますよ。第２引数が必須だと思われるので、””でＨＯＭＥ指定ということでしょう。 ただ、Ｎｏ１さんが指摘したように　/ or c:\ 直下や　ＦＴＰサーバーのログインした時のＨＯＭＥ（ルート）は書き込み不可であることが多い。そこを確認してからですね。 なお、 ＞トップページの階層にアップしたい場合は で意味は通じますが、このような操作の場合、ＨＯＭＥの方が一般的かと。 この辺に例が http://www.b21soft.co.jp/basp21/basp21pftp.html# … rc = bftp.PutFile("c:\html\images\*","html/images",1) ' バイナリファイルの送信 ここでは"html/images"と絶対パス指定になっていません。これを"/html/images" とすると同じようになるでしょうね。
ん？　質問変えた？　さっき似たような質問があって、その時に回答しようとしたら質問が消されたので書き込めなかったが、SendMessageで送ったメッセージはAcceptTcpClient()では受け取れないですよ。 なぜWin32 API(on VB6)でブロードキャストしたメッセージをTCPで受け取ろうと思ったんだ？　その辺を説明しないと回答は得られんぞなもし。 無線の受信というのもよく意味が分からない。 正直QAサイトで扱える範疇ではないと思うので、いくつか要点を絞ってアドバイス。 送った側のVB6も固まるというのが気になるところではあるが・・・・。 ・AcceptTcpClient()をするのはフォームとは別スレッドにしないといけない。さらに得られたTcpClientとやりとりをするのはそれとも別スレッドにすべき。 ・SendMessageで発信されたメッセージを.Net側で受け取るのは「WndProc」で情報を集めてくれ。こちらは別スレッドを作る必要はない。
普通はOfficeがインストールされていれば、 Microsoft Forms 2.0 Object Library は存在するはずなのですが。 もし、どうにもならないならば、たとえば、 チェックボックスをフォームに設定し、 プロパティのStyleを既定値では0-標準 になっていると思いますが、それを 1-グラフィックスに変更するとトグルボタンの 代用になります。
標準モジュールをインストールするか使わないかでしょう。
Dim myList As New List(Of String()) myList.Add(New String() {"A", "B"}) myList.Add(New String() {"C", "D", "E"}) myList.Add(New String() {"F"}) だとして、 リストの要素数は myList.countといった具合にcountプロパティで、 Listの中のString配列の要素数は、myList(0).length, myList(1).length, ・・・ といった具合にlengthプロパティで取得します。
こんにちは。 マイクロソフトのリファレンスによれば、多段配列と多次元配列はデータ構造そのものが違うようです。 （参考URLを参照願います。） なので、一括してデータを変換・代入することは難しそうです。 ２次元データならば、２段のFor-Nextループを回して１個１個代入していくしか方法はなさそうですね。 参考URL：http://msdn.microsoft.com/ja-jp/library/dd314345 …
cheesepizzaさん NO.1で間違っていました。 下記のように変更して下さい。 For i = 1 To 100 　rs.Fields("x" & i) = Cells(i + 9, 5).Value 　rs.Fields("y" & i) = Cells(i + 9, 7).Value Next i
Visual Basic.NET (正確にはVisual Basic)は，汎用の言語です。 ただし，ハードウェアへの直接アクセスは得意としていませんが。 # CLIという仮想マシン上で動く仕様であるため。 業務用アプリケーションは当然作成できますし， ハードウェアへの直接アクセス部分を除けば，ハードウェアの制御も可能です。 .NET Micro Frameworkという，組み込み用のCLI実装も存在します。 ref) http://msdn.microsoft.com/ja-jp/vstudio/bb267253 … そもそも，プログラミング言語を「制御系」「業務系」といった分け方はあまりしないと思いますよ。
こんばんは！ わざわざVBAでワークシート関数を入力させるより 数式が完成しているのであれば そのままセルに数式を入れてはダメなのですか？ 数式を拝見すると絶対参照になっているので、おそらくオートフィルでコピーしたいのですかね？ 数式はほんのわずかですが、簡単にできると思います。 =IF(OR(M4=$Y$5,M4=$Y$6,M4=$Y$7,M4=$Y$10),$Z$9,IF(M4=$Y$8,$Z$6,IF(M4=$Y$9,$Z$10,IF(M4=$Y$14,$Z$7,IF(M4=$Y$15,$Z$8,""))))) といった感じでしょうか？ 他の回答者様が回答されていらっしゃる通りで、上記数式をコードに組み込みたい場合は 「空白」部分はダブルクォーテーションを4個続けます。 どうしてもVBAで！というご希望であれば、IF関数部分だけは Select Case Range("M4") Case Range("Y5") N列セル = Range("Z9") Case Range("Y6") N列セル = Range("Z9") Case Range("Y7") N列セル = Range("Z9") Case Range("Y10") N列セル = Range("Z9") Case Range("Y8") N列セル = Range("Z6") Case Range("Y9") N列セル = Range("Z10") Case Range("Y14") N列セル = Range("Z7") Case Range("Y15") N列セル = Range("Z8") Case Else N列セル = "" End Select といった具合でもOKだと思います。 おそらくこれをループさせることになるかと・・・ ※　「N列セル」とは数式を入れたいセル番地とします。m(_ _)m
ActiveSheet　はＥｘｃｅｌＶＢＡですから ＶＢ６から操作するにはＥｘｃｅｌオブジェクトから 記載しないとダメなのでは？ ⇒画像の縦横のサイズが０になっているのは気になりましたので、 こちらは１００とさせてもらいましたけど。 Ｅｘｃｅｌの参照設定は行なわれているとして Dim xlApp As New Excel.Application Dim xlWb As Excel.Workbook Dim xlWs As Excel.Worksheet Dim FileNameTmp As String Set xlWb = xlApp.Workbooks.Open("C:\abc.xls") xlApp.Visible = True Set xlWs = xlWb.ActiveSheet FileNameTmp = "C:\test.jpg" ' シートオブジェクトを用いない時 xlApp.ActiveSheet.Shapes.AddPicture FileNameTmp, False, True, 10, 20, 100, 100 'シートオブジェクトを用いた時 'xlWs.Shapes.AddPicture FileNameTmp, False, True, 10, 20, 100, 100 こんな感じじゃないですかね？ ⇒閉じるとか解放については省いてます。
ＶＢのバージョンが不明ですけど、 Me.Picture　ってＶＢ６みたいな感じですし Imaging.ImageFormat.Jpeg　って.NET Framework （ＶＢ２０ｘｘ）みたいだし。 ごっちゃになっていると言う事はありませんか？
Dim myRng1 As Range, myRng2 As Range Set myRng1 = Application.InputBox(prompt:="コピーするセルを選択してください。", Type:=8) Set myRng2 = Application.InputBox(prompt:="貼付先セルを選択してください。", Type:=8) With myRng2 　　.Value = .Text & myRng1.Text End With
列をマージするのだからMergeRow()ではなくMergeCol()ですね。 No1さんも書かれていますが、マージは隣接するセルの内容が同じならくっつけちゃうので 1行目～４行目、５行目～８行目までの4行がマージの対象になります。 回避策は空白行を挿入します、今回の場合は２行毎です。 With oObjGrid .Rows = 1 .MergeCells = flexMergeRestrictColumns .MergeCol(0) = True .AddItem "AA" & vbTab & "1" & vbTab & "2" & vbTab & "3" .AddItem "AA" & vbTab & "A" & vbTab & "B" & vbTab & "C" .AddItem "" '空白行を挿入 .RowHeight(.Rows - 1) = 0 '空白行の高さを０に(非表示) .AddItem "AA" & vbTab & "4" & vbTab & "5" & vbTab & "6" .AddItem "AA" & vbTab & "D" & vbTab & "E" & vbTab & "F" .AddItem "" '*** .RowHeight(.Rows - 1) = 0 '*** .AddItem "BB" & vbTab & "1" & vbTab & "2" & vbTab & "3" .AddItem "BB" & vbTab & "A" & vbTab & "B" & vbTab & "C" .AddItem "" .RowHeight(.Rows - 1) = 0 .AddItem "BB" & vbTab & "4" & vbTab & "5" & vbTab & "6" .AddItem "BB" & vbTab & "D" & vbTab & "E" & vbTab & "F" .AddItem "" '*** .RowHeight(.Rows - 1) = 0 '*** End With '***の行は無くてもかまいませんが、セルの位置を計算する場合に規則性がないと困りますからね。
＞そのまま表示する方法が不明 ListBox1.DataSource = syaindata
こんばんは。 ご要望のプログラミングのポイントは２つあると思います。 1)レンジ・オブジェクトから画像オブジェクトは参照できないので、レンジ（セル）から直接画像を指定することはできないです。 画像オブジェクトのセル・プロパティを１つずつ調べて、指定のセルに存在するかどうか、探索しなければなりません。 2)サイズの変更は、shapeオブジェクトのScaleHeight（高さ）,ScaleWidth（幅） メソッドを使います。 両方を同じ倍率で変更すれば、縦横比を保ってサイズを変えられます。 下にプログラム例を記述します。 画像のあるセルと、倍率を引数で指定して呼び出すサブプロシージャです。 引数 rg は、画像の存在する左上のセルのレンジを指定します。 引数 z は変更する倍率を倍精度数で指定します。 ”Worksheets("****")”　のアスタリスク部は、検索するシート名に変更してください。 （すみませんが、急いで作ったためプログラムの動作確認はできておりません。ご自分で確認をお願いします。） お試しくださいマセ。 Sub PictureZoom(rg as Range,z as Double) Dim shp as Shape Dim nme as String For Each shp In Worksheets("****").Shapes '指定セル上の画像を探す If shp.TopLeftSell.Address = rg.Address then nme = shp.Name Exit For End If Next 'サイズ変更 Set shp=Worksheets("****").Shapes(nme) shp.ScaleHeight z, msoFalse shp.ScaleWidth z, msoFalse set shp=Nothing End Sub
http://www.atmarkit.co.jp/ait/articles/0611/08/n … > ClickOnceはWebサーバを選ばない。つまり、Windows上のIISによるWebサーバだけでなく、Linux上のApacheによるWebサーバなどに対しても、ClickOnceアプリを配置できるのだ（ だそうです
できると思います。 クエリをＳＱＬビューで表示させると、 SELECT Max(テーブル1.整理番号) AS 整理番号の最大, テーブル1.事業所名, テーブル1.職種名 FROM テーブル1 GROUP BY テーブル1.事業所名, テーブル1.職種名; このようになっているはずです。
こんばんは。 何をしたいのかわからない… 何のためにそのようなことをしたいのかを説明されると解決策が出るかもしれません。
イベントは複数のメソッドを登録できる。（メリットか？） Componentを継承したクラスであれば、デザイナでイベントを登録できる。 といったところかな。 提示の例ではイベントにするメリットは全くないですね。
私のPCにVB６の環境が無い為、以下では動かないかもしれませんが、参考になればと思います。 'PictureMotoに読み取る PictureMoto.Picture = LoadPicture(Me.CDialog.Filename) Me.PImage(Index).Stretch = FALSE Me.PImage(Index).Width = intDrawPictureWidth Me.PImage(Index).Height = intDrawPictureHeight '縮小して画像描画 Me.PImage(Index).PaintPicture PictureMoto.Picture, 0, 0, intDrawPictureWidth, intDrawPictureHeight Ｐ．Ｓ． Stretchは表示サイズを変更しているだけで、元の画像はサイズ変更していないと認識しております。
>現在Book1がActiveになっていればBook2に切り替え、Book2がActiveになっていればBook1 If ActiveWorkbook.Name = "Book1" Then 　　Workbooks("Book2").Activate ElseIf ActiveWorkbook.Name = "Book2" Then 　　Workbooks("Book1").Activate End If
やったことはないですが，WS_THICKFRAMEスタイルを追加してみてはどうでしょうか。 http://msdn.microsoft.com/en-us/library/windows/ … GetWindowLong APIまたはGetWindowLongPtr APIで対象ウィンドウのスタイルを取得し， http://msdn.microsoft.com/en-us/library/windows/ … http://msdn.microsoft.com/en-us/library/windows/ … WS_THICKFRAMEを追加して，SetWindowLong APIまたはSetWindowLongPtr APIで設定します。 http://msdn.microsoft.com/en-us/library/windows/ … http://msdn.microsoft.com/en-us/library/windows/ … なお，GetWindowLongPtrおよびSetWindowLongPtrは32bitプロセスでは定義されていません。 このため，VBで使うならば，GetWindowLongとGetWindowLongPtrを定義しておいて， Environment.Is64BitProcessプロパティでどちらを呼ぶかを切り分けることになると思います。 http://msdn.microsoft.com/ja-jp/library/vstudio/ … # GetWindowLongを64bitプロセスで使うこともできるので，こちらを使う，というのもありかと。
こんにちは。 > 別プログラムからOPEN というのは、どんなプログラムでしょう？ 仮に、 Excel VBA、から、Workbooks.Open メソッドで、 ということでお話ししますが、条件によっては、 VBAからでなくとも流用出来ます。 > 処理をWorkbook_Openに書きたいのですが Workbook_Open イベントでなくても良ければ、 Workbook_Open イベントの代りに、 標準モジュールに、 Private Sub Auto_Open() 　　MsgBox "手動で起動したら警告メッセージ" End Sub とプロシージャを置いて、ここで処理すれば十分、 という場合もあるかと思います。 通常、ブックを開くと、まず、 Workbook_Open イベント が発生します。 もしも手動で開かれた場合は、この後に、 Private Sub Auto_Open() が呼び出されます。 手動であろうがなかろうが、共通の処理がある場合などでは、 以下のサンプルのようにしてみては如何でしょう。 従来、Workbook_Open イベント で処理していた内容を、 標準モジュールのPrivate Sub WbkOpenSeq()に書くようにして、 Application.OnTime メソッドを使って、実行プロシージャを呼ぶようにすれば、 　Private Sub Workbook_Open() 　Private Sub Auto_Open() 　Private Sub WbkOpenSeq() の順に実行されるようになります。 WbkOpenSeq実行時に、手動で開いたどうか判るように書いています。 flgAutoOpen と名付けたフラグは、 手動で開かれたなら、True、それ以外は、False、という意味です。 Private Sub Auto_Open() を通った＝手動で開かれた場合だけ、 flgAutoOpen はTrueになります。 （以下の記述中、Workbook_Open、Auto_Open、の二つは規定の名前です。 　それ以外のプロシージャ名、変数名、は、私が勝手に付けている名前です。） ' ' ========== ThisWorkbook モジュール ========== Private Sub Workbook_Open() 　　Application.OnTime Now, "WbkOpenSeq" End Sub ' ' ============================================= ' ' =============== 標準モジュール ============== Private flgAutoOpen As Boolean Private Sub Auto_Open() 　　flgAutoOpen = True End Sub Private Sub WbkOpenSeq() 　　' ' 共通の処理があればココに。 　　If flgAutoOpen Then ' ' 手動 　　　　MsgBox "手動で起動したら警告メッセージ" 　　Else ' ' 手動じゃない 　　　　' ' 従来 Workbook_Open イベントで処理していた内容をココに。 　　End If 　　' ' 共通の処理があればココに。 End Sub ' ' =============================================
こんばんは！ 色々な方法があると思いますが、一例です。 Sub Sample1() With Range("A1") If Range("B1") = "" Then .Copy Range("B1") Else .Copy Range("B1").End(xlDown).Offset(1) End If End With End Sub こんな感じではどうでしょうか？m(_ _)m
　今仮にZ列を作業列として使用するものとして、次の様なVBAは如何でしょうか？ Sub Macro() Dim lr As Long lr = WorksheetFunction.Max(WorksheetFunction.Match("*?", Columns("B:B"), -1), WorksheetFunction.Match("*?", Columns("C:C"), -1)) Range("Z2:Z" & lr).FormulaR1C1 = "=RC2&"" ""&RC3" Range("Z1").Formula = "=""""" Range("Z1").AutoFilter 1, "*名古屋*" End Sub 　因みに、Z列に入力される関数において、途中に半角スペースが挟まる様になっているのは、例えばB2セルが「氏名」、C2セルが「古谷圭司」等となっている場合には、Z2セルの関数を単純に「=B2&C2」としてしまいますと、Z2セルの値が「氏名古谷圭司」となってしまい、B2とC2のどちらのセルにも「名古屋」が含まれていないのにもかかわらず、Z2セルには「名古屋」が含まれてしまいますので、この様な事を防止するために間にスペースを入れる様にしております。
調べてみると２つの方法がみつかりました。 １．SHFileOperation　というWindows APIを用いる方法 http://officetanaka.net/excel/vba/tips/tips75.htm 多量のファイルコピーに試用してみた事があります。速度上のメリットは無さそうでしたが、コピー中おなじみのフォルダーからフォルダーへファイルが移るアニメーションが表示されるので気が紛れます．．． ２．Shellを用いる方法 http://detail.chiebukuro.yahoo.co.jp/qa/question … ご参考まで。
ビルドしなきゃデバッグも何も出来ない
＞上記英文に対して、下記のような正規表現で検索しているのですが、 ＞[ -]?have[ s,-]? ＞"have s"がヒットしてしまいます。 これはあり得ません。勘違いだと思います。" have " がヒットします。 単語境界を認識したいのなら、No1の方の回答のように\bを使うのが普通です。単語の前後が[ ,-]だけに限定したいので無ければ。 \bだと英数字以外のすべてとの間の「隙間」が該当します。 \bhaves?\b でいいのじゃないでしょうか。
特定の行を指定した色に変えることプロパティの変更からははできません。 方法はあるみたいですが、私はやったことが有りません。 http://oshiete.goo.ne.jp/qa/1637047.html msflexgridなどですと、簡単に変更できますので色変更が必要な際は、 そのようなコントロールを使うことが多いです。 http://www.gizcollabo.jp/vbtomo/log/archive/haji …
Ｎｏ．３です。 Imports System.Text.RegularExpressions ' 追加 Public Class Form1 Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click Dim st As String = "トップページ > あ > RD 潜脳調査室" ' \s は半角スペースが１個あるとして ' もしない場合は削除してくださいね ↓ Dim re As New Regex("トップページ\s>[^>]+?>\s(?<name>[^>]+)>*") Dim m As String = re.Match(st).Result("${name}") MsgBox(m) End Sub End Class 変数：ｓｔにはソースが代入されているとした場合の参考になれば。
こんにちは！ 一例です。 ＞元のエクセルファイルにすべての商品コードとサイズと在庫数 のSheetが「Sheet1」として、 ＞在庫表が他部署から回ってきます が「Sheet2」とします。 両Sheetとも1行目は項目行でデータはA2セル以降にあるとして、 標準モジュールに↓のコードをコピー＆ペーストしてマクロを実行してみてください。 Sub Sample1() Dim i As Long, endRow1 As Long, endRow2 As Long, c As Range, wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") '←Sheet1は実際のSheet名に！ Set wS2 = Worksheets("Sheet2") '←Sheet2も実際のSheet名に！ Application.ScreenUpdating = False endRow2 = wS2.Cells(Rows.Count, "A").End(xlUp).Row wS2.Range("D:D").Insert Range(wS2.Cells(2, "D"), wS2.Cells(endRow2, "D")).Formula = "=A2&""_""&B2" endRow1 = wS1.Cells(Rows.Count, "A").End(xlUp).Row wS1.Range("D:E").Insert Range(wS1.Cells(2, "D"), wS1.Cells(endRow1, "D")).Formula = "=A2&""_""&B2" Range(wS1.Cells(2, "E"), wS1.Cells(endRow1, "E")).Formula = _ "=IF(COUNTIF(Sheet2!D:D,D2),INDEX(Sheet2!C:C,MATCH(D2,Sheet2!D:D,FALSE)),0)" Range(wS1.Cells(2, "E"), wS1.Cells(endRow1, "E")).Copy wS1.Cells(2, "C").Select Selection.PasteSpecial Paste:=xlPasteValues wS1.Range("D:E").Delete wS2.Range("D:D").Delete Application.ScreenUpdating = True End Sub ※　じっくり考えればもっと簡単になるかもしれません。m（_ _）m
どこかで見たような質問だなあ・・と思っていたら、 以前回答したものに酷似していたので、 http://oshiete.goo.ne.jp/qa/6860430.html 上記では、戻り値は関数viVScanfで受け取るようです。 回答した関数は、 stats = viVScanf(vi,"%t" , RecvData1) なお、受け取る変数RecvData1を固定長文字列にして、 Dim RecvData1 As String * 10000　 としている部分は VISAによるプログラミング http://ena.tm.agilent.com/e5071c/manuals/webhelp … によると、100でも受け取ることができるようですが、 このあたりは、実際にあわせて変更してみてはどうでしょうか。 なお、VISA.dllを使用したプログラミングはたとえば viVPrintf viVScanf などでググればCあるいはC++でのコードが ヒットしますので、そのあたりから引数などを 確認してみてください。
「ワイルドカードと正規表現」じゃなくて、「ファイル名のマッチと正規表現」の事ですかね。 ワイルドカードはトランプ用語で、「他のどんなカードの代わりにも使えるカード（多くの場合ジョーカー）」のことです。そこから転じて、「他のどんな文字にもマッチする特殊文字」の意味で使われます。 ファイル名のマッチ： コマンドラインや、プログラミング言語の一部の関数でのファイル名の指定に使う 　? どんな1文字にもマッチ（ワイルドカード） 　* 0文字以上のどんな文字列にもマッチ（文字列のワイルドカード） 　Windowsで使えるのは上記2つですが、Unix/Linuxのシェルだともう少しあります。 正規表現： プログラミング言語から様々な文字列パターンを選択するときに使うパターン 　. どんな1文字にもマッチ（ワイルドカード） 　* 直前の表現の0回以上の繰り返し（繰り返し指定子の一つ） 　他に多数あり。 それぞれ使い場所が違います。
Form3 がMDI子フォームになっているからエラーになります。 通常のフォームであればvbModalのネストが出来ます。
＃１-２、ｃｊです。＃２お礼欄を読みました。 > シート上に設定した文字列を誤って変更してしまわないように注意しようと思います。 ハイパーリンクの表示文字列　≒　セルの値 が、仮に変更されてしまったとしても 　　Case "Hoge" 　　　　Call Hoge の "Hoge" など、指定した文字列とマッチしなければ、 期待するマクロが動作しない、という結果なので、比較的軽い問題で済みますが、 偶然、他のマクロを実行させるキーワードにマッチしてしまうと、 全く期待しないマクロが実行されてしまい、こちらの場合は重篤なトラブルになりかねません。 場合によっては、Excel一般機能の、データの入力規則、等が防衛策に役立つかも知れません。 例えば、文字列値でハイパーリンクを設定した後に、 データの入力規則を新たに設定し、数値（最小値～最大値）を指定しておく、 （勝手に文字列値を設定出来なくなる）とか。 （データの入力規則を設定したセルをコピーし、他のセルの書式のみ貼り付けることで 手数を減らして設定できます） これに因んだ情報として、以下。 ハイパーリンクの表示文字列　はあくまでも文字列ですから、 仮に、数値を設定したセルの値を拾ってマッチングするには 　　Select Case Target.Range.Value と書き換えてやれば可能です。 次のサンプル7では、 セル値が、 　　数値　　123 　　数字文字列値　　"123" 　　プレフィクス付の数字文字列　　"'123" ３つの場合にマッチします。 ' ' 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 Private Sub Worksheet_FollowHyperlink(ByVal Target As Hyperlink) 　　Select Case Target.Range.Value 　　Case "Hoge" 　　　　Call Hoge 　　Case "Piyo" 　　　　Call Piyo 　　Case "Fuga" 　　　　Call Fuga 　　Case "123" 　　　　Call Hogera 　　End Select 　　Application.EnableEvents = False 　　Application.Goto 　　Application.EnableEvents = True End Sub ' ' 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 または 　　Select Case Target.TextToDisplay と書き換えると 　　数字文字列値　　"123" 　　プレフィクス付の数字文字列　　"'123" にだけマッチして、数値には反応しません。 ' ' 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 Private Sub Worksheet_FollowHyperlink(ByVal Target As Hyperlink) 　　Select Case Target.TextToDisplay 　　Case "Hoge" 　　　　Call Hoge 　　Case "Piyo" 　　　　Call Piyo 　　Case "Fuga" 　　　　Call Fuga 　　Case "123" 　　　　Call Hogera 　　End Select 　　Application.EnableEvents = False 　　Application.Goto 　　Application.EnableEvents = True End Sub ' ' 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 正確には、セルの値に数値を設定すると、 ハイパーリンクの表示文字列の実態は空の文字列になる、ということです。 こういった特性を利用した設計を考えるなどすれば、 何かの役に立つかも知れませんね。
#1です。 ＞拡張子が合わないメッセージがでますが問題はないのでしょうか？ おっと、すみませんそちらを忘れていました。 「拡張子が合わないメッセージ」とは具体的になんでしょうか？ FilenameでxlsにしてFileformatがxlExcel8(97-2003ブック)なら問題ないはずです。 もしかしたらFPATHやbook3という変数が悪影響を及ぼしているかもしれません。
私なら、以下の様に処理します。 (1)入力文字を半角に変換 (2)数値に変換可能か判定し、数値変数に値をセットする 趣旨と違うかもしれませんが・・ Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click Dim strInputValue As String Dim n As Integer Try '空白除去後に半角に変換 strInputValue = StrConv(TextBox1.Text.Trim, VbStrConv.Narrow) '「.」の位置を確認（LastIndexOfは最後の位置確認） n = strInputValue.IndexOf(".") If n = 0 Then TextBox1.Focus() Call MessageBox.Show("「.」が先頭にあります。") ElseIf n = strInputValue.Length Then TextBox1.Focus() Call MessageBox.Show("「.」が最後尾にあります。") ElseIf n < 0 Then Call MessageBox.Show("「.」は使用していません。") Else Call MessageBox.Show("「.」は中間位置にあります。") End If '別ですが、 '数値扱いの確認 If IsNumeric(strInputValue) Then Call MessageBox.Show("数値扱いです", "数値○") Dim decValue As Decimal decValue = Decimal.Parse(strInputValue) Else TextBox1.Focus() Call MessageBox.Show("数値を入力して下さい。", "数値×", MessageBoxButtons.OK, MessageBoxIcon.Error) End If Catch ex As Exception Call MessageBox.Show(ex.Message, "エラー", MessageBoxButtons.OK, MessageBoxIcon.Error) End Try End Sub
＃２-６、ｃｊです。＃６補足欄へのレスです。 編集が難しいということのようですし、 元々１行めしか想定して書いていませんでしたから、 その点を考慮に入れて、設計変えました。 この際、統一します。 セル範囲がどのように変更になろうとも、 ３つの（結合）セルという前提が崩れない限り、 指定箇所　にある、セル参照文字列、だけを修正すれば、 対応できるように書き直しました。 ' ' 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 ' ' 以下、Sheet1モジュール　' cj8271875_5 Private Sub Worksheet_Change(ByVal Target As Range) 　　Const fSRef = "D13,G13,I13"　　'　指定箇所　３つの結合セルの左上セルの番地をそれぞれカンマ区切りで '　　Const fSRef = "A1,D1,F1"　　'　No.5 での追加オーダー　の場合 '　　Const fSRef = "A1,B1,C1"　　'　原質問　の場合 　　Dim arrRef() As String 　　Dim wsh As Worksheet 　　Dim HAlignB As Excel.XlHAlign 　　Dim HAlignC As Excel.XlHAlign 　　If Intersect(Range(fSRef), Target(1)) Is Nothing Then Exit Sub 　　arrRef() = Split(fSRef, ",") 　　Application.EnableEvents = False 　　On Error GoTo ErrHndl_ 　　For Each wsh In Sheets(Array("Sheet2", "Sheet3")) 　　　　wsh.Cells(Target.Row, Target.Column).Value = Target(1).Value 　　Next 　　On Error GoTo 0 　　Application.EnableEvents = True 　　If Range(arrRef(1)).Value = 0 Then 　　　　HAlignC = xlHAlignRight 　　Else 　　　　HAlignC = xlHAlignLeft 　　End If 　　If Range(arrRef(0)).Value = 0 Then 　　　　HAlignB = xlHAlignRight 　　Else 　　　　HAlignB = xlHAlignCenter 　　End If 　　For Each wsh In Sheets(Array("Sheet1", "Sheet2", "Sheet3")) 　　　　wsh.Range(arrRef(1)).HorizontalAlignment = HAlignB 　　　　wsh.Range(arrRef(2)).HorizontalAlignment = HAlignC 　　Next 　　Exit Sub ErrHndl_: 　　MsgBox "シート：　Sheet1" & vbLf & "セル範囲：" & Target(1).Address(0, 0) _ 　　　　& vbLf & vbTab & ".Valueプロパティの取得" & vbLf & "　　または" _ 　　　　& vbLf & "シート：　" & wsh.Name & vbLf & "セル範囲：" & Target(1).Address(0, 0) _ 　　　　& vbLf & vbTab & ".Valueプロパティの設定" & vbLf & "　　に失敗しました。" _ 　　　　& vbLf & vbLf & "実行時エラー'" & Err & vbLf & Err.Description, vbExclamation 　　Resume Next End Sub ' ' 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
こんにちは。お邪魔します。 まず、直接的な答えとしては、 　【エラーの原因を排除する】 ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー Sub Re8271442a() 　　Dim i, w 　　For i = 1 To 9 　　　　w = Range("A" & i) 　　　　Range("A" & i) = Mid(w, 2) '←この部分 　　Next 　　For i = 10 To 20 　　　　w = Range("A" & i) 　　　　Range("A" & i) = Mid(w, 2) '←この部分 　　Next End Sub ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー ご提示のコードでの問題は 　　Right(w, Len(w) - 1) の部分のRight()関数の第２引数には負数を指定することは出来ないということ。 　　 Len(w) が、0 である場合は 　　 Len(w) - 1 が、-1 になってしまい。 Right()関数の引数エラーになります。 そこで、 　　「左1文字のみ削除」 というのを、 　　「文字列の２文字め以降を取り出す」 という風に解釈替えしたのが、 　　Mid(w, 2) です。 Mid()関数は第３引数を省略すると、 文字列の第２引数文字め以降を取り出す、ように処理します。 For Each Next ループを使って総当たりにして、 うんとシンプルに、こんな風にも書けます。 　【A1:A20 の セル範囲にあるセルを総当たりでループして】 　【２文字め以降を取り出してセルに返す】 ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー Sub Re8271442b() 　　Dim rng As Range 　　For Each rng In Range("A1:A20") 　　　　rng.Value = Mid(rng.Value, 2) 　　Next End Sub ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー もうひとつ解釈替えの例として 　　「セル範囲すべてをループして、空のセルでない場合は処理」 これを 　　「セル範囲の中で値（定数値）が設定されているセルだけをループして処理」 という方法が適している場面も良く見かけます。 ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー Sub Re8271442c() 　　Dim w As Variant 　　Dim rng As Range 　　For Each rng In Range("A1:A9,A10:A20").SpecialCells(xlCellTypeConstants) 　　　　w = rng.Value 　　　　rng.Value = Mid(w, 2) 　　Next End Sub ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー 因みに、 　　"A1:A9,A10:A20" という書き方を敢えてしています。 これは、離れた（複数の領域を持つ）セル範囲であっても 機能することを暗示しているだけで、 　　"A1:A20" に置き換えても、この場合はまったく同じ結果を返します。 　　.SpecialCells(xlCellTypeConstants) と書いて、 セル範囲の中で、定数値が設定された（数式が設定されたセルと空のセルを除いた）セル範囲を指します。 この部分を書き換えて 　　.SpecialCells(xlCellTypeFormulas) とすると、 セル範囲の中で、数式が設定された（定数値が設定されたセルと空のセルを除いた）セル範囲を指します。 /// 以上です。
13.5というのはピクセル数ではないのでは？ ピクセル数が整数ではないのが何だか引っかかります。 おそらくポイント数ではないでしょうか？ Windowsの場合、通常は、 13.5ポイント＝13.5*96/72＝18ピクセルです。
どのプロパティをどう変えようとしているのですか? 具体的なコードが無ければ、何が間違っているのか判断できません。 とりあえずは、マニュアルを見て ・そのプロパティが存在するかどうか? ・そのプロパティはReadOnlyになっていないか? ・そのプロパティに設定しようとしている値の型は、そのプロパティと合致しているか? くらいは調べましょう
Label1.Text = CStr(Int(Rnd() * 10)) Label2.Text = CStr(Int(Rnd() * 10)) Label3.Text = CStr(Int(Rnd() * 10)) Dim st As String st = Label1.Text + Label2.Text + Label3.Text If st = "777" Then MsgBox("メッセージ１") ElseIf st.Replace("7", "").Length = 1 Then MsgBox("メッセージ２") ElseIf st.Replace("7", "").Length = 2 Then MsgBox("メッセージ３") Else MsgBox("メッセージ４") End If 一例になれば幸いです。
x = TextBox1.Text Longのような数値と、Stringの文字列とは、扱いがいろいろと違うので、 計算に使うのなら、文字列→数値への変換をちゃんとしておいた方がいいでしょう。 x = Long.Parse(TextBox1.Text) とか。
No.1です。 VBE画面を出す方法ですが、何通りかあります。 一般的な方法としては 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　表示されるのがVBE画面ですので そこに前回のコードをコピー＆ペースト　→　Excel画面に戻り1行目にデータを入力してみてください。 「1」を入力した時点でマクロが走ります。 ※　「再表示」のコードは標準モジュールでもよいですし、 同じSheetのシートモジュールでも構いません。（すでにあるコードの下へコピー＆ペースト） 再表示のマクロはこちらで操作してやる必要があります。 Alt＋F8キー　→　マクロ　→　マクロ実行です。m（_ _）m
ANo.8さんのコードですが、私がNo2で回答した質問のコードのFor Z = 2 To 2000のループをなくして、変数Zと書かれているところをiに置き換えた(一部書き換え損ねてますけど)のと結果同じじゃないのかなぁと思われますが…変数に代入してる部分だけ無駄なような… データを見ると Worksheets("A").cells(Z, 1) = Worksheets("B").cells(i, 1) の比較は、AシートのA列のデータとBシートのA列のデータとを総当りという考え方ですね。ですから、同一行のデータを比較しただけではダメですので、2000回のループがネストしてなければいけないのだと思われます。 ただ、Zのループが2000まで必要かどうかは、Aシートの品目が2000品目あるのかどうか、iのループが2000まで必要かどうかは、それだけデータがあるかどうかにかかってきますけど。 ANo.6では必要回数をデータの入力されている最終行数分までとしています。
問題なくできる。 プログラムからエクセルファイルを開いて、シート、セルを操作できる。 URLの記述は、Office用のAddInツールを自作する場合の話。
Windows 7 しか手元にないので限定されてしまうかもしれませんが、 質問文にあるコードではエラーが出ず、正しく出力されました。 実際に黒背景に白抜きの 1 や、はしご高の高田などのフォルダーを作ってみましたが問題なくフォルダー名を出力できました。 実行環境は整理できていますか？
>ElseIfの使い方。 If Lavel5 = 7 And Lavel6 = 7 And Lavel7 = 7 Then 　　MsgBox "1" ElseIf Lavel5 <> 7 And Lavel6 <> 7 And Lavel7 <> 7 Then 　　MsgBox "4" ElseIf Lavel5 = 7 And Lavel6 = 7 Then 　　MsgBox "2" ElseIf Lavel5 = 7 And Lavel7 = 7 Then 　　MsgBox "2" ElseIf Lavel6 = 7 And Lavel7 = 7 Then 　　MsgBox "2" Else 　　MsgBox "3" End If
VBでは処理の順番は、上から順に行います。（VBだけでなく殆どのプログラム言語でも同じ） 質問者のコードは 計算をしてから、変数に値を入れている。
当方Excel2007ですが、 With sheet1.ChartObjects("Chart").ShapeRange .Line.EndArrowheadStyle = msoArrowheadOpen End With のかわりに With Sheet1.ChartObjects("Chart").Chart.SeriesCollection(1) .Format.Line.EndArrowheadStyle = msoArrowheadOpen End With としたらエラーは出ずに散布図の線の終点に矢じりがつきました。 参考URL：http://officetanaka.net/excel/vba/graph/17.htm
VBAでは0の0乗は1になります。 ということは、すべての変数に値が代入されていないということです。 先にテキストボックスの値を変数に代入しましょう。
これ（参照ＵＲＬの一番上の回答）でできているけど、何が違うのか良くわかりません。 unhookを呼び出す際にclipboard.clearしても同じ状況でしょうか？ Private Declare Function SetWindowsHookEx _ Lib "user32" Alias "SetWindowsHookExA" ( _ ByVal idHook As Long, _ ByVal lpfn As Long, _ ByVal hmod As Long, _ ByVal dwThreadId As Long) As Long Private Declare Function CallNextHookEx Lib "user32" ( _ ByVal hHook As Long, _ ByVal nCode As Long, _ ByVal wParam As Long, _ ByVal lParam As Long) As Long Private Declare Function UnhookWindowsHookEx Lib "user32" ( _ ByVal hHook As Long) As Long Private Declare Sub CopyMemory _ Lib "kernel32" Alias "RtlMoveMemory" ( _ pDest As Any, _ pSource As Any, _ ByVal cb As Long) Private Type KBDLLHOOKSTRUCT vkCode As Long scanCode As Long flags As Long time As Long dwExtraInfo As Long End Type Private Const HC_ACTION = 0 Private Const VK_SNAPSHOT = &H2C Private Const WH_KEYBOARD_LL = 13& Private hKeyb As Long Public Function KeybCallback(ByVal Code As Long, ByVal wParam As Long, ByVal lParam As Long) As Long Static udtHook As KBDLLHOOKSTRUCT If (Code = HC_ACTION) Then 'Copy the keyboard data out of the lParam (which is a pointer) Call CopyMemory(udtHook, ByVal lParam, Len(udtHook)) If udtHook.vkCode = VK_SNAPSHOT Then KeybCallback = 1 Exit Function End If End If KeybCallback = CallNextHookEx(hKeyb, Code, wParam, lParam) End Function Public Sub HookKeyboard() UnhookKeyboard hKeyb = SetWindowsHookEx(WH_KEYBOARD_LL, AddressOf KeybCallback, App.hInstance, 0&) End Sub Public Sub UnhookKeyboard() If hKeyb <> 0 Then Call UnhookWindowsHookEx(hKeyb) hKeyb = 0 End If End Sub 参考URL：http://www.vbforums.com/showthread.php?372390-RE …
こちらではDelete Create しないで Connect に再代入する方法を行っています。 tdf.Connect = <接続文字列> tdf.Attributes = dbAttachSavePWD tdf.RefreshLink Access 2003, postgreSQL または SQLServer で実施しています。 Oracleだとうまくいかないと言うことはないと思います。 どこかで例外が発生していませんか。
EXCELでCSVで保存したときに””がつくのは、セルデータの中に，や”や改行があるためです。 こういったものがなければ”がなくなります。 逆に””で囲うことによって、，や”や改行を含むが一つのセルとして認識されます。 さもなければ、そこでデータが区切れてしまうためです。
bcrtcjxagatさん こんにちは Stop以下、次のように変更すればできるかと思います。 -------------------------------------- Set objFr = objIE.document.frames MsgBox objFr(1).document.URL -------------------------------------- ※LocationURLではエラーになるのでURLを使用しました。 お試し下さい。
イメージだけですが、参考になりますか。 Class1 Private m_Items As Collection Private Class_Initialize() Set m_Items = New Collection End Sub Public Sub Add(ByVal obj As Class2) m_Items.Add obj, CStr(obj.Name) End Sub Public Property Get Item(Byval vValue As Variant) As Class2 Set Item = m_Items(vVlaue) End Property Public Sub Method() MsgBox "これはClass1のメソッドです" End Sub Class2 Private m_Name As String Public Function Init(Byval strName As String) As Class2 m_Name = strName Set Init = Me End Function Public Property Get Name() As String Name = m_Name End Property Public Sub Method() MsgBox "これはClass2(" & Name & ")のメソッドです" End Sub Sub Try() Dim o As Class1 Dim oo As Class2 Set o = New Class1 Set oo = New Class2 o.Add oo.Init("1") Set oo = New Class2 o.Add oo.Init("2") o.Method o.Item("1").Method '上の行は Class1のItemプロパティを既定のプロパティに設定すれば o("1").Method 'とメソッドチェーンが記述出来ます 'WorkBooks("hoge").WorkSheets・・・・と同じですね End Sub oだけならClass1への参照 o. ならClass1のメンバへアクセス o.Item("1") はClass1が持つItemプロパティ（型はClass2型)によりClass2の参照を得る Itemを省略可能なプロパティに設定すれば o("1")だけでClass2への参照が得られる o("1"). でClass2が持つメンバへアクセス可能になる コンパイルしてませんので、適宜修正願いますm(_ _)m
#1です。 詳しくは分からないのですが、CSVを書き出しているほうのDATATABLEの列(NO)の型定義と、読み込んでいるほうのそれと一致していないのではないでしょうか？ なお、他の回答者さまのおっしゃるとおり、XMLで書き出して読み込めば悩むことは少ないと思います。 いずれにせよ、書き出し側と読み込み側で列の型を一致させておく必要があります。
>>Me.コンボボックス.DataBindings.Add(New System.Windows.Forms.Binding("SelectedValue", Me.バインディングソース, "コンボボックス", True)) これは、コントロールとデータソースを結びつけている命令です。これを入れても、ＤＢから読み込み処理してくれません。 それではなく、以下のような感じの命令がForm_Loadの中にあるのではないでしょうか？ Me.xxxTableAdapter.Fill(Me.dataSet.xxxTable) このTableAdapterの中で記述されているＳＱＬ命令により、データセットの中のテーブルにデータが読み込まれていると思いますので、それを実行すればいいのではないかと思います。 （私が使っているのはＣ＃なので、いくらか差があるとは思いますが、基本は同じはずなので・・・） >>Designer画面以外で、なにか設定している箇所があるということでしょうか？ いえ、Designer画面のコードの中にたぶんあると思います。 ただ、プログラムの作りによっては、どこかの初期処理クラスの中でやっていて、わかりにくくなっているのかもしれませんが・・・。
＃２に補足です。 新規に作ったマクロ入りブックは、集計するブックたちと同一フォルダにいったん保存してから、再度開いてマクロを実行してください。
エラー処理ルーチン内で更にエラー制御しようとしていませんか？ http://www.accessclub.jp/bbs5/0031/vba9642.html そのケースに該当しないようなら、検証できる最低限の再現コードを提示できますか？ 部分的にではなく、一連の流れの中で他者も検証できれば回答がつくかもしれません。 以下余談で。 VLookupやMatch関数は、WorksheetFunctionクラスの関数ではなく Applicationクラスの関数として使うとエラー制御の必要がなく、比較的容易なコーディングが可能です。 Dim ticker As Long Dim flag1　As Long Dim x　　　As Variant ticker = 1332 flag1 = 0 x = Application.Match(ticker, Sheets("r" & Mid(Sheets("InsampleData").Cells(2, 2), 1, 4)).Range("A1:A10000"), 0) If IsNumeric(x) Then 　　flag1 = ticker End If や Dim ticker As Long Dim flag1　As Variant ticker = 1332 flag1 = Application.VLookup(ticker, Sheets("r" & Mid(Sheets("InsampleData").Cells(2, 2), 1, 4)).Range("A1:A10000"), 1, 0) If IsError(flag1) Then 　　flag1 = 0 End If 戻り値用にVariant型変数を用いるとエラー値も格納できるため、 戻り値を調べて処理分岐すれば良いです。
1分間隔くらいで、「.accdb」→「.mdb」を したいので。タスクとかで。 ？ 何かのシステムとかで、accdbファイルが作成されるのでしょうか？ Accessが作っているのなら、オプション設定の 基本設定→空のデータベースの既定のファイル形式 で変更してもダメ？ （mdb形式で上手く行けば・・が前提ですけど） 『サッパリ』な人なので、この辺でゴメン。
http://support.microsoft.com/kb/176399/ja 上記KBを見る限り仕様ということなので、改善を求めるならば呼び出し前後のプログラムをお示しいただく必要がありそうです。
スマフォなので少し分かりにくい表現になったかもしれません。補足します。 あなたの例で仮に「エネルギー電気自動車」という順番で差分が並んだ場合、VBではこの2つを切り離す基準を提示してあげないとダメなはずです。 私が書いた案は、あくまで上下の差が見つかった時を基準に文字列を分割しています。別シート等に単語を登録しておけば、この分割の基準に使えます。 言葉足らずですが、ご参考まで。
ありません。 どういう経緯でそういう場面に遭遇するのでしょうか？
こんにちは！ VBAで可能だとは思いますが、具体的なSheetのレイアウトが判らないので とりあえず流れだけ！ 各Sheetの名前は「機器名」となっていて、製品番号は各SheetのA列に半角英数で入っているとします。 インプットボックスに「Sheet名（機器名」」を入力　→　その「機器」の「製品番号」を入力 →　最初に入力したSheet名のA列の製品番号の行を選択 という感じでやってみました。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面に ↓のコードをコピー＆ペーストしてマクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から Dim k As Long, i As Long, c As Range, sTr1 As String, sTr2 As String, myFlg As Boolean 1: sTr1 = InputBox("機器名を入力してください。") For k = 1 To Worksheets.Count If Worksheets(k).Name = sTr1 Then myFlg = True Exit For End If Next k If myFlg = False Then If MsgBox("入力したシートが存在しません" & vbCrLf & "再入力しますか？", vbYesNo) = vbYes Then GoTo 1 Else Exit Sub End If Else sTr2 = InputBox("製造番号を入力してください。") Set c = Worksheets(sTr1).Range("A:A").Find(what:=StrConv(sTr2, vbNarrow), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then i = c.Row Worksheets(sTr1).Activate ActiveSheet.Cells(i, "A").Select Else MsgBox "入力した製造番号が存在しません。" Worksheets(sTr1).Activate End If End If End Sub 'この行まで ※　あくまで流れだけですので、列・行などは実状に合わせる必要があります。m（_ _）m
いくつもクリアしなければならない箇所が沢山あります。 １、所定のファイル（仮に　一つのフォルダにある000001.XLS　を開き 　　指定したセルの値を　月報.xlsの指定した場所へ入れていく　ＶＢＡのコード ２、１が出来たら、000001.XLSから00000F.XLS　まで繰り返して実行するコード ３、２が出来たら、次のフォルダーのパスを取得して、２を実行するコード ４、8時間ごとに、3を実行させるコード と順番にかんがえましょう。 とにかく、１が出来なければ、前へ進めません。 すべてを考えるとＳＴＯＰしてしまいそうですが、とりあえず　１の段階をクリアしてください。 一案ですが、データ取り込みのシート以外に、添付のようなファイル名とパスをいれたシートを準備しておきます。 データ取り込みのシートから Sub ボタン1_Click() GYOU = Range("A" & Rows.Count).End(xlUp).Row + 1 Myfile = Sheets("ファイル一覧").Range("A2").Value & "\" & Sheets("ファイル一覧").Range("A6").Value Workbooks.Open Filename:=Myfile ThisWorkbook.Sheets("データシート").Range("A" & GYOU).Value = Range("A5").Value ThisWorkbook.Sheets("データシート").Range("B" & GYOU).Value = Range("G6").Value ・・・・・・取り込みたいセルの数だけ ThisWorkbook.Sheets("データシート").Range("Z" & GYOU).Value = Range("H2").Value ActiveWorkbook.Close SaveChanges:=False End Sub を実行せすれば、指定したフォルダの指定したファイルを開いて、それぞれのセルの値が 1行づつ追加されていくと思います。 とりあえず、ここまで十分に理解して、次の　２のステップへ進みましょう
ちょっと補足 4行目まちがい ActiveWorkbook.Close Savechanges:=False win7　excel2010なら下記でも問題なく動きます
> 直近1年分のファイル この意味を解っていなかったので、やり直しました。 例えば今なら、201209-201308の一年分のテキストファイルを拾い上げます。 期間を、月単位で前後に調整出来るように書いてます。 例えば 　　Const fAdjMonth = -1 と変更すると、今なら、201208-201307の一年分、になります。 設計、ガラッと変えました。わりと、教科書的な書き方のように思います。 Ａ列に縦に並べまて出力するように書きましたけど、その後の処理も必要ならば、 恐らく手作業でも出来る内容だと思いますから、マクロの記録でも録って 書き足すようにしてください。 ' ' 標準モジュール専用 Sub Re8257248cj() 　　Const fFolderPath = "C:\Users\Owner\Documents"　　' 指定フォルダ名 　　Const fFileNamePattern = "abc#1xyz_000000.txt"　　' ファイル名パターン。年月に相当する部分に"000000" 　　Const fAdjMonth = 0　　' 期間を月単位で前後に調整する値 　　Dim sFileName As String　　' 各ファイル名。"年月"に相当する部分だけ順次置換 　　Dim sTempLine As String　　' テキストデータを各一行ずつ読み込む変数 　　Dim sMsg As String　　' 見つからないファイルがあった場合の告知用文字列 　　Dim nPosYYYYMM As Long　　' ファイル名の中で"年月"に相当する桁位置 　　Dim cnLines As Long　　' 出力する行位置、をカウントアップ 　　Dim nYear As Long　　' 開始年。1年前の西暦年 　　Dim nMonth As Long　　' 開始月。当月の月 　　Dim i As Long　　' ループ用 　　Dim nFree As Integer　　' 使用可能なファイル番号 　　' ' アプリケーションの描画更新停止 　　Application.ScreenUpdating = False 　　' ' シート3を選択。シート名要指定 　　Sheets("Sheet3").Select 　　' ' Ａ列の値を消去 　　Range("A:A").ClearContents 　　' ' ファイル名パターンを（フォルダパスを加えて）フルネームに 　　sFileName = fFolderPath & "\" & fFileNamePattern 　　' ' ファイル名の中で"年月"に相当する桁位置を取得 　　nPosYYYYMM = InStr(sFileName, "000000") 　　' ' 開始年。1年前の西暦年 　　nYear = Year(Date) - 1 　　' ' 開始月。当月の月（調整可） 　　nMonth = Month(Date) + fAdjMonth 　　' ' Open ステートメントで使用可能なファイル番号 　　nFree = FreeFile 　　' ' 開始月（前年同月）から終了月（昨月）までループ 　　For i = nMonth To nMonth + 11 　　　　' ' ファイル名の中で"年月"に相当する部分を置換 　　　　Mid(sFileName, nPosYYYYMM) = Format(DateSerial(nYear, i, 1), "yyyymm") 　　　　' ' ファイルが存在するか確認 　　　　If Dir(sFileName) <> "" Then　　' 存在するなら 　　　　　　' ' ファイルを読み込み用に開く 　　　　　　Open sFileName For Input As #nFree 　　　　　　' ファイルの最終行を読み終わるまでループ 　　　　　　Do While Not EOF(1) 　　　　　　　　' ' 出力する行位置をカウントアップ 　　　　　　　　cnLines = cnLines + 1 　　　　　　　　' ' テキストデータを一行ずつ変数に読み込む 　　　　　　　　Line Input #nFree, sTempLine 　　　　　　　　' ' 読み込んだテキストデータを一行ずつセルに出力 　　　　　　　　Cells(cnLines, 1) = sTempLine 　　　　　　Loop 　　　　　　' ' 開いたファイルを閉じる 　　　　　　Close #nFree 　　　　Else　　' 存在しないなら 　　　　　　' ' 見つからないファイルがあった場合の告知用文字列 　　　　　　sMsg = sMsg & vbLf & sFileName 　　　　End If 　　Next i 　　' ' アプリケーションの描画更新再開 　　Application.ScreenUpdating = True 　　If sMsg <> "" Then MsgBox Mid$(sMsg, 2) & vbLf & vbLf & "↑　見つかりません。", vbInformation End Sub
＃補足にすぎませんが NothingはObjectの場合だけですね。配列はErase()で初期化します。 EraseでDim時の状態に戻ります。静的配列でもできます。 そして・・・ VB6やVBAの場合、ガベージコレクションが自動的にメモリを解放してくれるので、明示的にメモリ解放する必要はあまりナイかと。解放する癖つけた方がいいのは確かですが。 ------ ・Eraseしなくても解放されます → 関数を抜ける時に未使用のメモリが解放されるため、メモリリークの心配はほとんどありません。 ・Eraseしても即解放されるわけではない → ガベージコレクション対象にセットされるだけで、たいていは関数抜ける時解放されるみたいです。結局メモリ使用量減りません(※)。 ------ リンク先はそーいうコト(※)かと。MsgBoxでメモリ増えるとか謎ですし、MsgBox表示でプログラム止まる際にガベージコレクション走りそうですが・・・バージョンによる違いなのかな。。。
ページフッターに同じ位置に罫線を配置する手もあります。 Option Compare Database Const MaxRow = 8 Dim RowCount As Integer Private Sub ページフッターセクション_Format(Cancel As Integer, FormatCount As Integer) 　　RowCount = 0 End Sub Private Sub レポートフッター_Format(Cancel As Integer, FormatCount As Integer) 　　If RowCount = MaxRow Then 　　　　RowCount = 0 　　　　Me.MoveLayout = False 　　　　Me.PrintSection = False 　　Else 　　　　RowCount = RowCount + 1 　　　　If RowCount < MaxRow Then 　　　　　　Me.NextRecord = False 　　　　　　Me.MoveLayout = True 　　　　Else 　　　　　　RowCount = 0 　　　　End If 　　End If End Sub Private Sub 詳細_Format(Cancel As Integer, FormatCount As Integer) 　　RowCount = RowCount + 1 End Sub
> プロセスを強制終了した場合もイベントは拾う事ができるのでしょうか？ プロセスの強制終了は、正常にアプリケーションを終了したわけではないので、 走行しませんし、そのような状態を捕捉するイベントもありません。 .NET Framework(CLR)のエラーが発生して異常終了したからといって、後続の処理が 走行しないのと一緒です。
Access からしばらく遠ざかっているのでスパッと答えられませんが、 IsNull 関数で判定するのではなかったでしょうか？ If IsNull(rs.Fields(0).Value) THen それと、Field オブジェクトの既定のプロパティは Value なので省略可能なのはわかりますが、 Value の評価なのかオブジェクト変数の評価なのかわからなくなるので rs.Fields(0).Value と省略せずに書いたほうが良いと思います。
ご質問文の内容が目的テキストファイルの全てなら、一括で読み込んで、Instrで「アメリカ」を探し、「アメリカ」の場所を始点に「</h1>」を探し、Midで取り出せば十分と思いますが、もう少し汎用性のありそうな回答をしておきます。改行の存在により手こずってしまいました。 >３行の場合もある　 というのが、解釈に迷うところですが、<br>を介して、別の都市名がもう一つ入ると考えました。 ファイル一個分だけですが、ご参考まで。 Sub test() Dim targetString As String, targetFileName As String Dim regEX As Object Dim MatchesDiv As Variant, MatchesH1 As Variant Dim MatchDiv As Variant, MatchH1 As Variant Dim buf As Variant Dim i As Long Set regEX = CreateObject("VBScript.RegExp") With regEX .ignorecase = True .MultiLine = True .Global = True End With targetFileName = "test.txt" targetString = readTextFile(ActiveWorkbook.Path & "\" & targetFileName) '最後に改行を削除しているので、初めから削除してしまった方が、検索パターンが簡単になりますが、折角試行錯誤したので、そのまま載せてあります。 regEX.Pattern = "<div id=""organizationsBox"">[\S\s\n\r]*?</div>" Set MatchesDiv = regEX.Execute(targetString) For Each MatchDiv In MatchesDiv regEX.Pattern = "<h1>([\S\s\r\n]*?)</h1>" Set MatchesH1 = regEX.Execute(MatchDiv) For Each MatchH1 In MatchesH1 buf = Split(WorksheetFunction.Clean(MatchH1.submatches.Item(0)), "<br>") For i = 0 To UBound(buf) Debug.Print buf(i) Next i Next MatchH1 Set MatchesH1 = Nothing Next MatchDiv Set MatchesDiv = Nothing Set regEX = Nothing End Sub 'テキストファイルをひとまとめの文字列として読み込む Private Function readTextFile(filename As String) As String Dim FSO As Object Set FSO = CreateObject("Scripting.FileSystemObject") With FSO.getfile(filename).OpenAsTextStream readTextFile = .ReadAll .Close End With Set FSO = Nothing End Function 参考URL 正規表現 http://officetanaka.net/excel/vba/tips/tips38.htm こちらでFileSystemObjectの勉強すると、たいていのファイル処理ができます。 http://officetanaka.net/excel/vba/filesystemobje …
＃１、２、３、ｃｊです。 ＃３補足欄へのレスです。 ５つの大項目のうち、 　どの大項目を扱うべきなのか、 　対象となる大項目の先頭行は（絶対位置で）何行めなのか、 という情報を、私はどうすれば知ることができますか？ 対象となる大項目の先頭行より下、最初に見つかる空セル、 が出力ポイントになる、ということのようですが、何分、起点が解りません。 そちらでは解るということでしたらば、 ' ' ●（２／３択）●アクティブセルより下の行で、一番上にある空セル、に出力 　　Range("B" & ActiveCell.Row & ":B" & Rows.Count).SpecialCells(xlCellTypeBlanks).Areas(1)(1).Resize(, 2).Value = 氏名_項目() この記述の 　ActiveCell.Row の部分を 　　対象となる大項目の先頭行の、（絶対位置での）行位置を 　　数値で 　指定して貰えればいいんだと思います。 実際には変数を使うなり工夫する必要はあるでしょうけれど 　対象となる大項目の先頭行の、（絶対位置での）行位置が 　10、であるならば、 　　Range("B" & 10 & ":B" & Rows.Count).SpecialCells(xlCellTypeBlanks).Areas(1)(1).Resize(, 2).Value = 氏名_項目() という風に数値が当て嵌められるようにそちらで書き換えてみて下さい。 また、 　対象となる大項目の先頭行以下の３行（のＢ列）には必ず値が設定してある 　　（対象となる大項目の先頭行の、（絶対位置での）行位置が 　　　10、であるという例ならば、 　　　B10:B12 の範囲は必ず値が設定してある、という意味） 　ということならば、 上の記述をより簡単なものにして 　　Range("B" & 10).End(xlDown).Offset(1).Resize(, 2).Value = 氏名_項目() のように書けるのかも知れません。 もっとも、 対象となる大項目と次なる大項目、の間に必ず空行がある、 という、大前提、で成り立つものですから、 対象となる大項目配下に出力するつもりが、次なる大項目配下になってしまう場合もあります。 大前提が崩れないように注意してください。 現状で私からアドバイス出来るのは、これ位のものです。 先々のこともあるので、またちょっと気になったことを書いておきます。 例えば、（本件と類似した例という意味で） 　２行めが項目タイトルで、 [番号]＿＿[氏名]＿＿[項目] 　と、なっていて、 　３行め以降データ １＿＿"大分類"＿＿"hoge" ２＿＿"小分類"＿＿"piyo" ３＿＿"氏名１"＿＿"hogehoge" ４＿＿（空）＿＿（空） ５＿＿"大分類"＿＿"fuga" ６＿＿"小分類"＿＿"hogera" ７＿＿"氏名２"＿＿"fugapiyo" ８＿＿"氏名３"＿＿"piyopiyo" ９＿＿（空）＿＿（空） 10＿＿（空）＿＿（空） 　のような様式の表なんでしょうかね？ 樹形図を二次元的に表した表、を編集するのは扱いが非常に難しいです。 将来的にお奨めしておきたいこととして、 【リレーショナルデータベース】について、さわりだけでも 知っておくと、色々な可能性や汎用性、融通性、などが見えてくると思います。 現在のような様式で表示したり印刷したりする必要があるにしても、 それは専ら表示用「レポート」にして、 入力作業や編集は別に「テーブル」を用意してそちらで行う ようにシステムを作っておいた方が、すべての作業工程がシンプルになり 誰にも扱い易い、理解され易いものになると思います。 余談が過ぎたかも知れませんが、ご参考まで。
> ご指摘のページは既に見ていたのですが、assembly2　や　Embed Interop Types　という > ワードでプロジェクト内のコードで検索をかけたのですが、まったく引っかからず原因箇所が > 特定できない状態でしたのでこちらで質問させていただいたしだいであります；； （１）assembly2 エラーメッセージの説明ページでは、実際のメッセージの一部分を総称的に記述する場合が多々あります。説明ページでは実際のコードまたはプロジェクト構成を特定することができないためです。 この場合、説明ページ内の一部記述を実際のエラーメッセージの記述に置き換えて読む必要があります。 説明ページの 　アセンブリ '<assembly2>' からの間接参照により、埋め込まれた相互運用機能アセンブリ '<assembly1>' の参照が作成されました。 と あなたのエラーメッセージの 　アセンブリ 'Microsoft.VisualBasic.Compatibility' からの間接的な参照が原因で、埋め込まれた相互運用機能アセンブリ 'stdole' に対して参照が作成されました。 とを比較すると、<assembly1> が 'stdole' に、<assembly2> が Microsoft.VisualBasic.Compatibility に対応していることがわかります。 したがって、以下の解説では文中の assembly1 および assembly2 を上記に置き換えて読む必要があります。 （２）Embed Interop Types VB.Net のことは解らないのですが、コード中ではなく、アセンブリ参照の設定画面にそういう項目はないでしょうか？
今回の図はとても見やすいので滞りなく検討することができました。 Sub シートコピー() Dim r As Range For Each r In Worksheets("Sheet1").Range("B1:D5") With Sheets("Sheet2") If WorksheetFunction.CountIf(.Range("A8:A10"), r.Value) Then .Range(r.Address).Value = r.Value ElseIf WorksheetFunction.CountIf(.Range("C8:C10"), .Range(r.Address).Value) = 0 Then .Range(r.Address).Value = "" End If End With Next End Sub 少し解説すると、 sheet1が入力文字の場合はsheet2に記入、 違う場合、sheet2が記号「○、●、◎」(sheet2のC8:C10でない場合は""を記入（セルを空白に） としたところ、表-3と同一の結果が得られました。 ついでに、Range("A8:A10")のところも一応明示的にSheets("Sheet2")を指定し、その結果Sheets("Sheet2")が５個になってしまったのでWith Sheets("Sheet2")を使ってみました。 蛇足ですが、WorksheetFunction.CountIfのかわりにRange.Findを使うこともできます。 たとえば、 If WorksheetFunction.CountIf(.Range("A8:A10"), r.Value) Then は If Not .Range("A8:A10").Find(r.Value) Is Nothing Then でもかまいません。
ん？　だからそこにIPアドレスを入れればいいんじゃないの？　「IPだけでできるはず」というサーバー管理者からの回答はそういう事だと思うんだけど。 Set oMsg = CreateObject("CDO.Message") oMsg.From = "mailsender@gmail.com" oMsg.To = "user@gmail.com" oMsg.Subject = "Test" oMsg.TextBody = "テストメッセージです" & vbCrLf & Now oMsg.Configuration.Fields.Item("http://schemas.microsoft.com/cdo/configuration/s …) = 　2 oMsg.Configuration.Fields.Item("http://schemas.microsoft.com/cdo/configuration/s …) = "10.333.444" oMsg.Configuration.Fields.Item("http://schemas.microsoft.com/cdo/configuration/s …) = 25 oMsg.Configuration.Fields.Update oMsg.Send これで駄目だったって事なのかな？ 補足説明で教えていただけますか。繋がらなかったですとか、○○というエラーメッセージが表示されたですとか。 状況的に、fromかtoが不正というのはあるかも知れない。メールアドレスがおかしいという意味じゃなくって、リレー送信には許されないfromかtoである可能性もある。無いとは思うけどそもそもサーバーBがリレーを許してないなんてオチはないよね。 ※リレー送信とは：サーバーBがSMTPで受け取ったメールをそのままの内容で別のメールサーバーにSMTPで送信する事。
>そもそも、ネットに繋がった状態でPCを扱うことを前提で考えています。 上記の前提で、その上で「ネットに繋げるようにしたい」という質問にご自分で違和感など感じませんでした？ 今回の場合は、単純に「VB2010でホームページにアクセスする方法を教えてください」でよろしかったかと思います。 質問に対する回答の方は、#2の方が詳細に回答されてますので省略します。
＞追記されてしまいます。 OpenにAppendを指定してますから、当然です。 ＞今ある行を削除をして新たにbuf()のデータを記入したいのですが、できますか？ 出来ますよ。Appendの代わりにOutputって書きましょう。 書いてあるVBAコードが「何をするコードなのか？」は理解出来ていますか？ 理解できていないから「追記されて困る」なんて事になっちゃうのです。 「VBAが何をやっているのか理解しないまま実行する」のはやめましょう。 何を実行するｋ理解せずに実行したら、実行したパソコンのデータが全消去されたり、起動できない状態になったりしますよ。
チェックボックスの選択がない場合、ということで宜しいのですよね？ Private Sub～の下に Dim chk As Boolean chk = False 各If CheckBox○ Thenの下に chk = True （チェックボックスの個数分全て記述してください） 最後のMsgBoxの表示部分を If chk = False Then MsgBox ("保存する編集データを選択してください。"), vbExclamation End If でどうでしょうか。。
SortオブジェクトはExcel2007で追加されたものだとのことです。 http://msdn.microsoft.com/ja-jp/library/office/f … http://officetanaka.net/excel/vba/tips/tips148.htm つまり、Excel2003にはSortオブジェクトはないということのようです。 そのため、質問者様のコードをExcel2003で実行すると、 objXL.ActiveSheet.Sort. で始まる行はすべてエラーになると思われます。 かわりにRange.Sortメソッドを使ってください。 http://msdn.microsoft.com/ja-jp/library/office/f … それで対応できなければオートフィルタを使ったりVBAで書いたりしなければならないと思います。 それを踏まえて質問者様のコードを見ると、Range.SortメソッドとSortオブジェクトのApplyメソッドの両方が書いてありますね。２回ソートしているということでしょうか。 以上いかがでしょうか。さらに解説が必要であればその旨補足ください。 参考URL：http://msdn.microsoft.com/ja-jp/library/office/f …
条件付書式じゃ駄目な理由は何ですか？
＃１です。 その後調べてみたのですが、WndProcをオーバーライドしてマウスホイールメッセージを無効化する方法をやろうとしてみたのですが、適切なクラスが私には分からなかったので別の方法を考えました。 DataGridViewComboBoxが編集状態にあるときにMouseWheelイベントを感知した場合には編集を終了する。という方法を試してみました。 うまくいきそうでしたので下記のコードを参考にしてみてください。 --------------- Public Class Form1 Private Sub Form1_Load(sender As Object, e As EventArgs) Handles MyBase.Load Dim column1 As New DataGridViewComboBoxColumn() With DataGridView1 .Columns.Clear() .Columns.Add("Col01", "列１") With column1 .Items.AddRange(New String() {"Item01", "Item02", "Item03"}) .Name = "Col02" .HeaderText = "列２" End With .Columns.Add(column1) For i As Integer = 0 To 100 .Rows.Add() Next i End With End Sub Private dataGridViewComboBox As DataGridViewComboBoxEditingControl = Nothing Private Sub DataGridView1_CellEndEdit(sender As Object, e As DataGridViewCellEventArgs) Handles DataGridView1.CellEndEdit If Not (Me.dataGridViewComboBox Is Nothing) Then RemoveHandler Me.dataGridViewComboBox.MouseWheel, _ AddressOf dataGridViewComboBox_MouseWheel Me.dataGridViewComboBox = Nothing End If End Sub Private Sub DataGridView1_EditingControlShowing(sender As Object, e As DataGridViewEditingControlShowingEventArgs) Handles DataGridView1.EditingControlShowing If TypeOf e.Control Is DataGridViewComboBoxEditingControl Then Dim dgv As DataGridView = CType(sender, DataGridView) If dgv.CurrentCell.OwningColumn.Name = "Col02" Then Me.dataGridViewComboBox = _ CType(e.Control, DataGridViewComboBoxEditingControl) AddHandler Me.dataGridViewComboBox.MouseWheel, _ AddressOf dataGridViewComboBox_MouseWheel End If End If End Sub Private Sub dataGridViewComboBox_MouseWheel(ByVal sender As Object, _ ByVal e As EventArgs) Me.DataGridView1.EndEdit() End Sub End Class
・テキストファイルの読み込み System.IO.StreamReaderクラス http://msdn.microsoft.com/ja-jp/library/vstudio/ … System.IO.FileクラスのReadAllTextメソッド http://msdn.microsoft.com/ja-jp/library/vstudio/ … などを使います。 元々，OpenFileDialog自体は基本的にファイル名の取得機能しか持っていません。 なので，OpenFileDialogを使ってファイルを読めるのであれば，ファイル名を固定にしても読めるはずです。 もちろん，OpenFileメソッドでStreamを取得できますが， 文字列として取得するにはStreamから結局はStreamReaderを作ることになります。 似た作りにするなら，System.IO.File.OpenReadで開いたStreamをOpenFileで取得するStreamの代わりにすればよいでしょう。 ・ボタンを押した時に反応する Button.Clickイベントにハンドラを追加 ・テキストボックスに表示 TextBox.Textプロパティに値を代入
No.1です。 回答が'?'になってしまっていました。 こちらで大丈夫です。 Selection.NumberFormatLocal = ChrW(8364) & "#,##0.00;-" & ChrW(8364) & "#,##0.00"
C:\WINDOWS\Media\の中にシステム音が入っているので書き換えるだけです。 Windows XPのころはlogoff.wavだったように思いますが vistaでは Windows Logoff Sound.wav Windows7と８では Windows ログオフ サウンド.wav になっています。
よく考えてみると、コマンドプロンプトを介さずに直接qwinsta.exeを叩けばいいような…… '--------------------------------------------------------- '--Processオブジェクトを作成 Dim pr As New System.Diagnostics.Process pr.StartInfo.FileName = "C:\windows\system32\qwinsta.exe" pr.StartInfo.UseShellExecute = False pr.StartInfo.RedirectStandardOutput = True pr.StartInfo.RedirectStandardInput = False pr.Start() '出力を読み取る Dim results As String = pr.StandardOutput.ReadToEnd() Console.WriteLine(results) pr.WaitForExit() pr.Close() '---------------------------------------------------------
そうですか。うまくいきませんか。 もっと検討したいところですが、画像のシートが小さすぎて見えないので困っています。 補足にて詳しく説明いただけないでしょうか。 あるいはいっそのことこの質問を締め切ってもっと見やすい画像を用意して再質問していただいても結構です。 よろしくお願いします。
＃１、＃２です。 修正しました。これでたぶんどこのセル範囲でも大丈夫だと思います。 なお画面の右の方だったり下のほうだったりした時にユーザーフォームが切れるのは直していませんので悪しからず。 ---------------- Sub test() Dim x As Long Dim y As Long Dim str As String Dim rng As Range Dim adr As String str = Selection.Address If InStr(str, ":") = 0 Then adr = str Else adr = Mid(str, InStr(str, ":") + 1, Len(str) - InStr(str, ":")) End If Set rng = Range(adr).Offset(1, 1) x = ActiveWindow.PointsToScreenPixelsX(0) * 72 / 96 + rng.Left * ActiveWindow.Zoom / 100 y = ActiveWindow.PointsToScreenPixelsY(0) * 72 / 96 + rng.Top * ActiveWindow.Zoom / 100 Load UserForm1 With UserForm1 .StartUpPosition = 0 .Left = x .Top = y End With UserForm1.Show End Sub
名前通りフレームワークです。 [IT用語辞典] http://e-words.jp/w/E38395E383ACE383BCE383A0E383 … VB6の時代はランタイムと言ってましたね。 http://e-words.jp/w/E383A9E383B3E382BFE382A4E383 … 本来は、英単語の意味的にもフレームワークの方が共通化された 土台的な意味を持っていると思われますが、あまり区別されずに 使われてますね。
はじめまして。 vb2010でソケット通信を使いたくて、今TCPサーバーを作っています。 クライアント側から受信した瞬間にサーバー側から返信というのは可能でしょうか。 受信したタイミングで接続が切れてしまって困っています。 初めてソケット通信に触れてイマイチ分かってないので説明がうまくいきませんが、 どなたかわかる方がいらっしゃいましたらご回答よろしくお願いします。 まずは、自分で投稿した質問内容を読み返して見てください。 恐らく質問を読んだ人は ・vb2010でソケット通信をしようとしている事 ・サーバ接続後に切断されてしまう事 ・本当はサーバ→クライアント側への返信を返したい事 ・しかしうまく実現出来ていないという事 がわかりますが、、、 ただ単に 「サーバー側から返信というのは可能でしょうか？」 というだけの質問であるならば「可能」ですと答えるだけです。 「なぜ、切れてしまうか？」 という原因を究明したいのであれば、現在のプログラムがどのように出来ているのかがわからない限り、誰にも答えようがないと思います。 ですのでとりあえず、 http://dobon.net/vb/dotnet/internet/tcpclientser … とURLを残しておきます。
こんばんは！ 「グループ」の分け方はA列・B列の組み合わせ数でよいのでしょうか？ VBAになってしまいますが、そう解釈しての一例です。 Sheet1に元データがあり、Sheet2を作業用のSheetとして使用していますので Sheet2は全く使っていない状態にしておいてください。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面に ↓のコードをコピー＆ペーストしてマクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から Dim i As Long, cnt As Long, str As String, c As Range, wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") For i = 1 To wS1.Cells(Rows.Count, "A").End(xlUp).Row str = wS1.Cells(i, "A") & wS1.Cells(i, "B") Set c = wS2.Range("A:A").Find(what:=str, LookIn:=xlValues, lookat:=xlWhole) If c Is Nothing Then cnt = cnt + 1 With wS2.Cells(cnt, "A") .Value = str .Offset(, 1) = "グループ" & cnt End With wS1.Cells(i, "C") = wS2.Cells(cnt, "B") Else wS1.Cells(i, "C") = c.Offset(, 1) End If Next i wS2.Cells.Clear End Sub 'この行まで ※　もしグループ分けの種類を確認したい場合は 最後の ＞wS2.Cells.Clear の行を削除してマクロを実行してみてください。 Sheet2のA・B列にグループの種類が表示されているはずです。m(_ _)m
No.1・3です。 ＞Averageプロパティが使えません すなわち「AVERAGE関数」が使用できない！というコトですかね？ 普通では考えられないのですが・・・ 別案です。 ↓のコードではどうでしょうか？ （結果的にはAVERAGE関数と同じ操作を行っています） Sub Sample3() Dim i As Long, cnt As Long For i = 2 To Cells(Rows.Count, "A").End(xlUp).Row On Error Resume Next '←おまじない If Cells(i, "A") <> Cells(i - 1, "A") Then cnt = i Do While Cells(i, "A") = Cells(cnt, "A") cnt = cnt + 1 Loop Cells(i, "B") = WorksheetFunction.Sum(Range(Cells(i + 1, "B"), Cells(cnt - 1, "B"))) / _ WorksheetFunction.Count(Range(Cells(i + 1, "B"), Cells(cnt - 1, "B"))) Range(Cells(i + 1, "B"), Cells(cnt - 1, "B")).ClearContents i = cnt - 1 End If Next i End Sub ※　AVERAGE関数でも同じコトが言えるのですが、「0」で割るという場合はエラーとなりますので、 必ずB列の範囲内には数値データがある！という前提です。 これでもダメならごめんなさいね。m(_ _)m
WebClientではなく，HttpWebRequestとHttpWebResponseを使うことで対処可能かと。 # TwitterのUserStreamで可能だった HttpClientからStreamContent.CreateContentReadStreamAsync経由でできそうな気もしますが， これで可能かどうかは確かめていません。
うまくいかなかったのですか。 検証しておらず申し訳ありませんでした。 そこで検証してみたのですが、質問者様の状況がちょっとよくわかりません。 質問者様の方でご指摘のエラー（「インデックスが有効範囲にありません」）が出る場所はNo.1の回答で修正した部分なのでしょうか。 というのは、こちらでもNo.1の修正を行ったコードで確かにご指摘の通りのエラーが出たのですが、それは Set WBA = Workbooks("Ａ") のところであり、しかも、No.1の修正をしてもしなくてもこのエラーは発生しました。 この部分のエラーについては、ファイル名の拡張子まで指定することで解消しました。 上記のエラー解消後の検証では、No.1の回答については期待通りの動作をしました。 すなわち、修正前は6.8までしかデータがコピーされず、いずれかの修正を行ったところ30までコピーされました。 なお、こちらではコードはブックＢの標準モジュールに置きました。 もし、質問者様のところでエラーの出ている場所が Set WBA = Workbooks("Ａ") 以外のところであるなら補足いただければ、と思います。 なお、他にも修正した方がいいところがあります。 まずNo.1の回答ですが、エラーの原因ばかり考えていたため、一応動くもののあまり気の利いた回答ではありませんでした。 また、マクロ開始時にWBA以外のブックがアクティブになっているとうまく動きませんでした。 他にもデフォルトのActiveWorkBookを使っている場所がありますので、ブックはＡであるものとみなして修正しました。 このような事を考慮して修正したコードを示します。 コードを置く場所ですが、 モジュールは標準モジュールしかテストしていません。 ブックはＢにしてありますがＡでも他のブックでも大丈夫です。 ブック名は実際のファイル（ブック）に合わせて書き直してください。 Sub Macro9() Dim WBA As Workbook Dim WBB As Workbook Dim WSA As Worksheet Dim WSB As Worksheet 'Set WBA = Workbooks("Ａ") 'Set WBB = Workbooks("Ｂ") Set WBA = Workbooks("Ａ.xlsx") Set WBB = Workbooks("Ｂ.xlsm") '↑この2行のブック名（ファイル名）は実際のファイルに合わせて要修正 'xlsとxlsxの両方を使う可能性がある場合等拡張子が一定しない場合は、 '上の2行のかわりに下の5行でうまくいくかもしれない 'Dim e 'For Each e In Workbooks ' If UCase(e.Name) Like "Ａ.XL*" Then Set WBA = Workbooks(e.Name) ' If UCase(e.Name) Like "Ｂ.XL*" Then Set WBB = Workbooks(e.Name) 'Next Set WSB = WBB.Worksheets("1") For i = 100 To 3000 Step 20 'Worksheets.Add Before:=Worksheets("Sheet1") Set WSA = WBA.Worksheets.Add(Before:=WBA.Worksheets("Sheet1")) Dim k As String 'k = i k = i / 100 'ActiveSheet.Name = (k / 100) WSA.Name = k 'Set WSA = WBA.Worksheets(k / 100) WSB.Range("A1:AY30").Copy Destination:=WSA.Range("A1") WSA.Range("D4:I30").Clear WSA.Range("Q4:V30").Clear WSA.Range("AD4:AI30").Clear WSA.Range("AQ4:AV30").Clear Next i Application.DisplayAlerts = False 'Sheets("Sheet1").Delete WBA.Sheets("Sheet1").Delete Application.DisplayAlerts = True Application.DisplayAlerts = False 'Sheets("Sheet1").Delete WBA.Sheets("Sheet2").Delete Application.DisplayAlerts = True Application.DisplayAlerts = False 'Sheets("Sheet1").Delete WBA.Sheets("Sheet3").Delete Application.DisplayAlerts = True End Sub
Access レポート PDF 複数の種類 結合 でGoogleったら Accessでデザインの違う複数のレポートを1つのPDFファイルとして出力する http://www.ilovex.co.jp/blog/system/softwaredeve … そちらのお望みの形になるかは不明です。 VBAでやるとなると外部のアプリ・ツールが必要になってきます。
mitarashiです。 今頃はお気づきになっているかもしれませんが、 完成の悦びを取り上げては申し訳ないと、考え方の提示に止めた、 delOval Sheets(2).Range(Target) は、 delOval Sheets(2).Range(Target.Address) の誤りです。 混乱させて申し訳ありません。 その分完成の悦びが増加したという事で、結果オーライですね。(^^;) 当方も質問者からスタートしたのですが、その内に一晩冷却期間をおくと、大抵のバグが自己解決できる事に気付き卒業しました。masarin16さんもじきにそのレベルに到達されると思いますので、是非VBAの沼にはまって下さい。
何もややこしいことはしてないので書いてあることをそのままVBAに落とし込むだけ。 相当独特な何かをしてるみたいですが、本文で提示された内容は「あるセルの値をあるセルに反映する」の繰り返しでしかないので、何も難しいことはありません。 まずは(1)～(4)を組む。 組めたら、1.0～20.0のループの中に入れる。 これだけ。 現状あなたのやっているのは丸投げなので、まずは上記を自力でやってみてください。
新規ブックを開き、[使い方]、[リスト]、[当番表]のシートを選択して、新規ブックに「シートの移動又はコピー」で移動すればよろしい課と思います。 もし、ThisWorkbookにコードの記述があるなら、そのコードも新しいブックに貼り付ければよろしいかと。
専門家ではなく、SQLサーバーを触ったことすらないので的外れな回答かもしれませんが、、、 テーブルのスキーマ（インデックス）はコピーされているのかな？
> Inherits AxSample1 > のように記述するのでしょうか？ これでOKですね。 > その場合、グループ分けした機能群の数だけActiveXコントロールの派生クラスを作成するような > イメージでしょうか。 こちらも、その考え方でOKです。 機能ごとに派生クラスを用意するという事は、例えば以下のような事ですよね。 基底クラス：TextBox 派生クラスA：数値のみ入力可能なTextBox 派生クラスB：郵便番号のみ入力可能なTextBox ※ 補足として、継承について書かれているHPを記載しておきます。 http://homepage1.nifty.com/rucio/main/VBdotNet/A … http://www.atmarkit.co.jp/fdotnet/vb6tonet/vb6to …
質問で書かれている内容を見ると ・タグで囲まれたHTML形式のマークアップ という事なので 「行」という考えは「テキストの行」ではなく「TableRow」の行という考えですよね？ TableRowのROWタグの内部の文字列化された情報が、1行に収まっているという前提があるのであれば、容易に判定が出来ると思いますが、情報が複数行にまたがるのであれば、テキスト化された文字列から「正規表現」でROWタグを探してウニャラウニャラと。。。。 となると思います。 しかし「Microsoft HTML Object Library」というライブラリを参照設定に加え使用すると、解析を楽に行うことが出来ます。 以前にVB.NET版でサンプルを載せました。 http://okwave.jp/qa/q5888958.html それを改造したVBA版を載せておきます。 Option Explicit '起動メイン Sub Test() 　　'ファイルを読込 　　'テキストファイルにはHTML形式のBODYの中だけが記されているとする 　　Dim l_strBuff As String 　　l_strBuff = ファイル読込("c:\testdata.txt") 　　 　　'取得した内容を解析 　　Call 解析(l_strBuff) End Sub '文字列解析サンプル Private Sub 解析(ByVal p_strBuff As String) 　　Dim l_htmDoc As New MSHTML.HTMLDocument 　　Call l_htmDoc.Open("<html />") 　　'引数の文字列は<BODY>～</BODY>のinnerHTMLのみなので 　　'ダミーのDIVタグを作成し、その中に引数の文字列を埋め込む 　　' 　　'もし<HTML>～</HTML>で文字列を取得できるのであれば、 　　'l_htmDoc変数から直接オープンを行いl_htmDoc変数のbodyプロパティ配下を 　　'解析したらよいので、ダミーのDIVタグは不要となる 　　Dim l_htmDiv As MSHTML.HTMLDivElement 　　Set l_htmDiv = l_htmDoc.createElement("DIV") 　　Call l_htmDoc.appendChild(l_htmDiv) 　　l_htmDiv.innerHTML = p_strBuff 　　 　　'TABLEタグに限定し、解析開始 　　'l_htmDiv.childrenでループを行うと、TOPクラスの全てのタグを取得することも出来る 　　Dim l_htmTbl As HTMLTable 　　For Each l_htmTbl In l_htmDiv.getElementsByTagName("table") 　　　　Debug.Print String(10, "*") & " テーブル開始 " & String(10, "*") 　　　　 　　　　Dim l_lngRowID As Long 　　　　For l_lngRowID = 1 To l_htmTbl.Rows.Length 　　　　　　Dim l_htmRow As HTMLTableRow 　　　　　　Debug.Print "※ " & l_lngRowID & "列目" & " ※" 　　　　　　Set l_htmRow = l_htmTbl.Rows(l_lngRowID - 1) 　　　　　　'<TR>タグから出力 　　　　　　Debug.Print l_htmRow.outerHTML 　　　　　　'<TR>タグが不要であれば 　　　　　　'Debug.Print l_htmRow.innerHTML 　　　　Next l_lngRowID 　　 　　　　Debug.Print String(10, "*") & " テーブル終了 " & String(10, "*") 　　Next l_htmTbl End Sub 'ファイル一括読込サンプル Private Function ファイル読込(ByVal p_strFilePath As String) As String 　　Dim l_strRet　　As String 　　Dim l_fsoObj　　As Object　 'Scripting.FileSystemObject 　　Dim l_fsoFile　 As Object　 'Scripting.File 　　Dim l_fsoSr　　 As Object　 'Scripting.TextStream 　　 　　Set l_fsoObj = CreateObject("Scripting.FileSystemObject") 　　Set l_fsoFile = l_fsoObj.GetFile(p_strFilePath) 　　 　　Set l_fsoSr = l_fsoFile.OpenAsTextStream(1) 　　l_strRet = l_fsoSr.ReadAll 　　l_fsoSr.Close 　　 　　ファイル読込 = l_strRet End Function
ロジスティック曲線の性質上、 ＞XMaxが200ならば、Table(200)に100が入る ＞T_Valが小さければ、比例に近く ＞T_Valが大きければ、曲線がきつくなる とするのは難しいと思います。 蛇足ですが、 ベジェ曲線ですと、上記のようなものができそうです。 ただし、xとyの関係が媒介変数(t)を介しての記述となるため、xが○のときyは●、という計算が簡単にはできません。 以下サンプルです。 エクセルVBAです。 B１セルにXMax、B２セルにYMax、B３セルにT-Val（ゼロ以上１以下）を入力してください。 マクロ実行すると、A7セル以下にxの値、B７セル以下にyの値が表示されます。 ---------------- Sub test() x1 = 0 y1 = 0 x4 = Cells(1, 2) y4 = Cells(2, 2) x2 = (x4 - x1) * Cells(3, 2) y2 = y1 x3 = (x4 - x1) * (1 - Cells(3, 2)) y3 = y4 div = x4 For i = 0 To div t = i / div tp = 1 - t x = t * t * t * x4 + 3 * t * t * tp * x3 + 3 * t * tp * tp * x2 + tp * tp * tp * x1 y = t * t * t * y4 + 3 * t * t * tp * y3 + 3 * t * tp * tp * y2 + tp * tp * tp * y1 Cells(7 + i, 1) = x Cells(7 + i, 2) = y Next End Sub
A=1.5(基数?) B=閾値 C=計算値 C=A^(B/10) 但し、A<0のときはBが整数の場合のみ有効
寝ぼけてきました。 With Sheets("Sheet1" & MySheetCount) With Sheets("Sheet" & MySheetCount) にしてください。
split http://www.kanaya440.com/contents/script/vbs/fun … ubound http://www.kanaya440.com/contents/script/vbs/fun … splitでバラして、uboundで調べて、条件が一致するかどうか比較して制御する。 といったところかと。
#1さんの仰る通りなんですが、この手の速度ネタは好きなので試してみました。 ExcelVBAですが、試験データをワークシート関数で作っているところ以外は、VBSでも同様に動くと思います。 最初試験データをワークシートにおいて使い回ししようとおもったので、途中で方針転換しましたが、そのまま使っています。 なお、0msecになっているところは、GetTickCountの精度の関係ですが、数十msecでは終わっていると思います。 また、10000件程度では大して差が出ませんでした。 結論から言うと、配列を一個の文字列に合成してから正規表現検索を行うのは予想外に速いですが、 strMSG = strMSG + TEST(i) & vbCrLf の方法による文字列合成は世間で言われている通り高コストで、こちらが律速になってしまいます。Midステートメントを使いましょう。 http://www.moug.net/tech/exvba/0140045.html Private Declare Function GetTickCount Lib "kernel32" () As Long Sub test1() Dim myArray() As String Dim buf1 As String Dim buf2 As String Dim i As Long Dim regEx, matches Const maxNo As Long = 100000 ReDim myArray(1 To maxNo) Set regEx = CreateObject("VBScript.RegExp") With regEx .Pattern = "001-.{3}" .IgnoreCase = True .Global = True End With buf2 = String(maxNo * (7 + 1) - 1, ",") Debug.Print "1:" & CStr(GetTickCount) For i = 1 To maxNo myArray(i) = Evaluate("=IF(RAND()>0.5,TEXT(RANDBETWEEN(1,999),""000"")&""-"" & CHAR(RANDBETWEEN(65,90)) & CHAR(RANDBETWEEN(65,90)) & TEXT(INT(RAND()*10),""0""),TEXT(RANDBETWEEN(1,999),""000"")&""-"" & CHAR(RANDBETWEEN(65,90)) & CHAR(RANDBETWEEN(65,90)) & TEXT(INT(RAND()*10),""0""))") Next i Debug.Print "2:" & CStr(GetTickCount) 'ここは乱数でのテストデータ生成にかかる時間なので関係ないが、上記関数使用は遅い。 For i = 1 To maxNo Set matches = regEx.Execute(myArray(i)) Next i Debug.Print "3:" & CStr(GetTickCount) '文字列配列の個々にregExで検索 125msec buf1 = myArray(1) For i = 2 To maxNo buf1 = buf1 & myArray(i) Next i Debug.Print "4:" & CStr(GetTickCount) '文字列=文字列+付加文字列で文字列合成 16099msec For i = 1 To maxNo Mid(buf2, (i - 1) * 8 + 1, 7) = myArray(i) Next i Debug.Print "5:" & CStr(GetTickCount) 'Midで文字列合成 測定不能 0msec Set matches = regEx.Execute(buf2) Debug.Print "6:" & CStr(GetTickCount) 'regExで一括検索 測定不能 0msec 'ちゃんと抽出できた事の確認 100個弱が該当 For i = 0 To matches.Count - 1 Debug.Print matches(i) Next i Set matches = Nothing Set regEx = Nothing End Sub
ie.Document.getElementsByname("Image1")(0).Click のコードで、新しいウィンドウやタブが開いたら、 それをieオブジェクトにセットする必用があるのでは Dim objShell As Object Set objShell = CreateObject("Shell.Application") ・ 　　・　 　　・　 >ie.Document.getElementsByname("Image1")(0).Click >Call IEWait(ie) 'IE待機 '最後に開いたウェブページorエクスプローラをieにセットする Set ie = objShell.Windows(objShell.Windows.Count - 1) >ie.Document.getElementById("menu_2").Click
こんばんは！ ExcelでVBAの一例です。 ↓の画像で左側がSheet1・右側がSheet2とします。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面に ↓のコードをコピー＆ペーストしてマクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から Dim i As Long, j As Long, k As Long, cnt As Long, str As String, wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") i = wS2.Cells(Rows.Count, "A").End(xlUp).Row If i > 1 Then Range(wS2.Cells(2, "A"), wS2.Cells(i, "C")).ClearContents End If wS2.Range("B:B").Style = "Percent" '←Sheet2のB列を％表示にしている場合は不要 With wS1 For i = 2 To .Cells(Rows.Count, "B").End(xlUp).Row .Range("A1") = .Cells(i, "B") For j = 2 To .Cells(Rows.Count, "B").End(xlUp).Row If InStr(.Cells(j, "B"), .Range("A1")) > 0 Then .Cells(j, "C") = 1 Else For k = 1 To Len(.Range("A1")) str = Mid(.Range("A1"), k, 1) If InStr(.Cells(j, "B"), str) > 0 Then cnt = cnt + 1 End If Next k .Cells(j, "C") = cnt / Len(.Range("A1")) cnt = 0 End If If .Range("A1") <> .Cells(j, "B") And .Cells(j, "C") >= 0.9 Then With wS2.Cells(Rows.Count, "A").End(xlUp).Offset(1) .Value = wS1.Cells(j, "B") .Offset(, 1) = wS1.Cells(j, "C") .Offset(, 2) = wS1.Range("A1") End With End If Next j Next i .Range("C:C").ClearContents End With End Sub 'この行まで ※　余計なお世話かもしれませんが、Sheet2のC列にはSheet1のA1セルのデータの場合で B列にはそれに対する割合を表示させています。 Sheet2の2行目を説明すると A1セルが「リンゴ」の時に「おリンゴ」が100％になります 同様に3行目はSheet1のA1セルが「もも」の時に「すもも」が100％ というコトになります。 （Sheet1のC列データは最終的には消しています） 外していたらごめんなさいね。m（_ _）m
Twitter APIの仕様上，できません。 ・連携アプリケーションとして投稿を行うユーザーで認証を行う必要があります。 https://dev.twitter.com/docs/auth Textbox3に入れるユーザーは無意味です (認証済みユーザーなら別です)。 ・特定のTweetを連続して送信することはできません。 https://dev.twitter.com/docs/api/1.1/post/status … > For each update attempt, the update text is compared with the authenticating user's recent tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error.
ご質問の通りにやるならUnionを使えば良いと思います。ちょっと遊んでみました。 Dim setRange As Range Sub test() Dim i As Long Dim myCell As Range Randomize Time Cells.Interior.ColorIndex = xlNone For i = 1 To 120 Set myCell = Cells(Int(Rnd() * 100) + 1, Int(Rnd() * 100) + 1) If setRange Is Nothing Then Set setRange = myCell Else Set setRange = Union(setRange, myCell) End If myCell.Interior.Color = vbYellow Next i End Sub Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If setRange Is Nothing Then test If Not Intersect(Target, setRange) Is Nothing Then Cancel = True 'cells(1)は、結合セル対策 If Target.Cells(1).Value = ChrW(10003) Then Target.ClearContents Else Target.Value = ChrW(10003) End If End If End Sub 代替案として、参照用のシートを用意し、Targetと同じ番地に特定の値が設定してあるときだけイベント動作をさせる方法があります。目的シートと同様のレイアウトをして、イベントを動作させたい番地だけ特定の値を入れておくと、分かり易いと思います。下記コードは、空か否かだけで分岐しています。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Dim refSheet As Worksheet Set refSheet = ThisWorkbook.Sheets(2) If Not IsEmpty(refSheet.Range(Target.Cells(1).Address)) Then Cancel = True If Target.Cells(1).Value = ChrW(10003) Then Target.ClearContents Else Target.Value = ChrW(10003) End If End If End Sub
#1です。 当方Access2010ですが、単純に標準モジュールにコードをコピペし、Microsoft XML v6.0に参照設定し、XMLをデスクトップに置いて実行すると、 item_title1 item_title2 が取得できました。質問者様のAccessのバージョンが不明ですが、Accessの機能は使っていないので、どのバージョンでも変わらないと思います。 エラーNo. -2147024809を検索してみましたが、それらしい情報がヒットしません。 簡単なモデルで試してみて、うまく行ったら肉付けをしていく事をお勧めします。
次の条件にて、マクロ構文(B)を書きます。 Bからマクロを実行する。 AとBが共に開かれている。 CをBと同じフォルダに保存する。 Bのシート「あ」をCの最左に貼り付ける。 Workbook("A").SaveAs Filename:=Workbook("B").Path & "\C.xls" 'Aをコピーして、Bと同じフォルダにCを作成します。 Workbook("B").Activate 'Bをアクティブします。 Sheets("あ").Copy Befor:=Workbook.("C").Sheets(1) 'BのSheets("あ")をコピーして、Cの最左に貼り付けます。 Workbook.("C").Save 'Sheets("あ")が貼り付けられたCを保存します。
1.1の時代はサイドバイサイド実行がうたわれていた時代なので、 1.1を使わないと一部で不具合がでてしまうという可能性も あるのでは？ ソースコードがあるなら新しい開発環境で再コンパイルすべき だと思います。
どの程度改善できるかは不明です。単なる思いつきなので試していません。 フォームを一つ作成します。仮に名前を「F_PDF出力」にします。 F_PDF出力のレコードソースを、SELECT DISTINCT 顧客番号 FROM 納品書 にします。 レコードセットはスナップショットにします。 フォーム上に顧客番号のテキストコントロールを置きます。 もう一つ非連結のテキストボックスを置き、コントロールソースには =[CurrentRecord] & " / " & Count(*) とします。 上はどこまで進んでいるか確認するためです。 あとは、コマンドボタンを一個。 レポートのレコードソースをパラメータークエリにして 上記フォームの顧客番号を参照するようにします。 コマンドボタンのクリック時イベントなどに Const TBL_NAME = "納品書" Const RPT_NAME = "納品書"　 Const PDF_PATH = "C:\Users\Desktop\ Docmd.GoToRecord acDataForm,me.name,acFirst 　　Do DoCmd.OutputTo acOutputReport, RPT_NAME, acFormatPDF, PDF_PATH & Format（date,"yyyymmdd"） & ".pdf" 　　　　If Me.Recordset.RecordCount = Me.CurrentRecord Then 　　　　　　MsgBox "最終レコードまで出力しました。" 　　　　Exit Sub 　　　　End If 　　　　Docmd.GoToRecord acDataForm,me.name,acNext 　　Loop とします。 これで上手く行けばプレビューにかかる時間が短縮できるはずです。
こんばんは！ 単純に Sub Sample1() Range(Cells(11, 79), Cells(420, 79)).Formula = "=IF(OR($G11="""",COUNTIF(H11:BN11,""ｋ"")>0),"""",INT(AVERAGE(H11:BN11)*10+0.5)/10)" End Sub ではどうでしょうか？ ※　相対参照にしていますが、絶対参照の場合は「$」マークを通常の関数のように追加してください。 ※　検証はしていませんので的外れならごめんなさいね。m（_ _）m
Range("B9").Value ではないでしょうか？
構造体を使ってバイトを入れ替える方法。 Public Type Data4Byte2 myByte(1) As Byte End Type Public Type Data4Byte4 myByte(3) As Byte End Type Public Type Data4Integer myInteger As Integer End Type Public Type Data4Long myLong As Long End Type Public Function Swap(ByVal L As Long) As Integer Dim d4b2 As Data4Byte2 Dim d4b4 As Data4Byte4 Dim d4i As Data4Integer Dim d4l As Data4Long ' d4l.myLong = L LSet d4b4 = d4l d4b2.myByte(0) = d4b4.myByte(1) d4b2.myByte(1) = d4b4.myByte(0) LSet d4i = d4b2 Swap = d4i.myInteger End Function
IF N3=1 then 　　　　-M2 else 「N3<>1のとき」 endif ↓ if( N3=1,-M2,「N3<>1のとき」) 「N3<>1のとき」は 　　　　IF(K2=1, then 　　　　　　「K2=1のとき」 　　　　else 　　　　　　「K2<>1のとき」 　　　　endif だから if(K2=1,「K2=1のとき」,「K2<>1のとき」) これを最初の式に代入すると if( N3=1,-M2, if(K2=1,「K2=1のとき」,「K2<>1のとき」)) 以下同様に、落ち着いて順番にやれば、IF関数を使った記述に変更できます。 今回のについて言えば、内容を吟味して、#2,#3のようにすると、if関数が減らせて見易くなります。 さらに if(A<B,A,B)→MIN(A,B)であることを使えば =IF(N3=1,-1*M2,IF(ABS(K2)=1,MIN(M2,K2*(P3-M3)),0)) と、とても見易くなります。
以下の部分でそのような処理にしているからです。 If IsNumeric(A.Value) Then→数値だった場合 →なにもしない。 Else→それ以外の場合（数値以外）は Exit Sub→サブルーチンを抜ける。 End If こんな感じです。 正しくは、 For i = 1 To 10 Set A = Cells(i, 1) Set B = A.Offset(0, 1) Set C = A.Offset(0, 2) If IsNumeric(A.Value) Then 　If B.Value = "" Then B.Value = A.Value 　If C.Value = "" Then C.Value = A.Value 　If A.Value > B.Value Then B.Value = A.Value 　If A.Value < C.Value Then C.Value = A.Value End If Next i でよいと思います。
これですか？↓ http://dobon.net/vb/bbs/log3-45/26935.html
Sub ボタン1_Click() str1 = "2012年1月5日（木）" str2 = Format(DateValue(Left(str1, InStr(str1, "（") - 1)), "yyyymmdd") MsgBox str2 End Sub
とりあえず、下記なら動くと思います。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Intersect(Target, Range("A1:A10")) Is Nothing = False Then Cancel = True 'ここに付け足したのみ If Target.Cells(1).Text = ChrW(10003) Then Target.ClearContents Else Target = ChrW(10003) End If End If End Sub 確認してみました。ご参考まで。 Sub test() Dim myRange As Range Dim i As Long, j As Long '結合セル Set myRange = Range("A8:D13") myRange.Value = "A" 'Debug.Print myRange.Value 配列なので型違いのエラーになる Debug.Print TypeName(myRange.Value) 'Variant() Debug.Print myRange.Text 'nullを戻す->myRange.Text = "A" は成立しない '値はCells(1,1)にしか入っていない For i = 1 To 6 For j = 1 To 4 Debug.Print i, j, myRange.Cells(i, j).Value Next j Next i End Sub
D ドライブ直下、または D ドライブ内のすべての Excel ファイルの一覧を取得する。 Excel VBA で Excel ファイルをひとつずつ開き、ExportAsFixedFormat で PDF 保存をして閉じる。 http://www.google.co.jp/search?hl=ja&q=ExportAsF …
前の方が書いてる通り <rss version="2.0"> は <rss version="2.0" xmlns:a="http://xxxx/"> でなくてはいけません。 一度、XMLファイルを読み込んで ・<rss version="2.0">を、<rss version="2.0" xmlns:a="http://xxxx/">に置き換える。 ・<xx:xx>のタグを別のもに置き換える。 ・<xx:xx>のタグの:を取り除く。 や これXMLじゃないんですけどと、XML提供元に文句をいう。 などです。
リモートデスクトップのウィンドウハンドルが取得できない訳は #1 さんの説明に尽きます。 補足から推測するに きぬあささんの http://www.ka-net.org/blog/?p=1131 のようなツールがあれば仕事がはかどると思います。 （今回のダメな事も確認できます） 当方ではおとなしく Inspect.exe を使っています。
テキストボックスのサイズが変わるのは Autosize プロパティがtrueになっているからでしょう。 位置がずれるのは（＊大きくずれるのだとすれば） コントロールの書式設定　→　プロパティ　→　・・・・移動しない。 　にチェックが入っているか確認してください。 少しのずれは表示倍率を変更するのが原因かもしれません。 （縮小した時に少しずれるのだったような気がします。）
あのですね。ＶＢの場合というかマイクロソフトの場合は時間は人間が考えている時分秒みたいな形をとっていないせいですね。 年月日を含む時間は全て数字で管理されています。 つまり、ある年月日時分秒が3255642みたいな数字で表されているのです。 ＞Debug.Print Now + インターバル これは、時間型同士を足してますのでエラーにはなりません。 ＞Debug.Print 終了時刻 + インターバル 型が合わないエラーになるのは当然です。 ＞終了時刻 = Format(Now, "yyyy/mm/dd") & " " & TimeValue("3:02:00") で文字型に変換されていますよね。時間型と文字型を足そうとしてもエラーなるのは当たり前です。 型変換をされるか、時分秒を分解してそれぞれを計算で足し込むようなプログラムが必要と思われます。
日付を跨ぐ際の処理 If Format(反復時刻, "hh:mm:ss") > "23:54:00" Then 反復時刻 = Format(DateAdd("d", 1, 反復時刻), "yyyy/mm/dd") & " " & TimeValue("0:00:10") Else 反復時刻 = Format(反復時刻, "yyyy/mm/dd") & " " & TimeValue(反復時刻) + インターバル End If をざっくり削って 反復時刻 = 反復時刻 + インターバル Application.OnTime 反復時刻 , "必要な作業を行うマクロ", 待ち時間 の2行にしましょう。 バグの原因は「素直に足し算すれば良いのに、Format関数で余計な事をするから」です。 「ただ足すだけ」で、日付を跨ぐ場合も問題ありません。 直したいなら「Format関数は、デバッグ表示以外では使わない」ようにしましょう。
Excel から Access にデータを送る手法がよくわからないけれど、ADO を使ってるってことは INSERT INTO の SQL 実行か、レコードセット オブジェクトに対して AddNew を挿入対象の件数分だけ繰り返し実行してるとか。 Access 側で誰かが何かをしている最中に、その外部から Access にちょっかいを出すような作りこみ方は良いやりかたとは思えない。 Access 側の操作で Excel のデータをインポートするように作り変えたほうが安全だと思う。
誤字があるけど、別質問にイメージ書いたよ 参考URL：http://oshiete.goo.ne.jp/qa/8216841.html
if文ブロック中のexit subは正しいが、その他はEnd subでした。
「インポート対象シートを選択する」があるので、大きく２つに分けて考える。 ６項目書かれているので、１～３まででブック別シート名一覧を作る。 対象にマークする工程を経て、４～６を実行。 前半は「フォルダ内のファイル名一覧作成」を、 後半は「指定したシートのインポート」のEXCELサンプルを探して下さい。 前半のファイル名一覧を、テーブルにすれば良いでしょう。
Combo1.ListIndex の値はどうなっていますか？
Dim行やアンダースコアによる継続行ならならともかく、 ＝の前後は無効にできません。
Exprは表現でExpression （例外処理はExceptionとなります）
こんにちは。 > sheet2のE22セルの文字がTRUEの場合 > sheet2のE22セルの文字がFALSEの場合 問題はこの部分のあやふやさが原因で、 条件分岐が正しく出来ていないということのようです。 　Sheet2のE22セルの値は論理値で 　　True の場合 　　False の場合 というように条件分岐するのが普通です。 それとも、、 　Sheet2のE22セルの値は文字列値で 　　"TRUE" の場合 　　"FALSE" の場合 というように条件分岐したいのならば、 ご提示の条件分岐の部分は正しいです。 要するに人間の感覚のように 見た目が一緒なら一致したと判断する、というような 曖昧さをプログラムに持ち込むことに難があります。 セルの値が論理値であるか文字列値であるかは ＶＢＡ側の問題ではなくて、Excel一般機能の問題で、 シートでどのように値を設定しているか、 ということに依存します。 確認の為、シート上の空いているセルに 以下の数式を確定させてみてください。 　=ISLOGICAL((Sheet2!E22)) 　=ISTEXT(Sheet2!E22) 前者はセルの値が論理値ならば、TRUEを返します。 後者はセルの値が文字列値ならば、TRUEを返します。 　Sheet2のE22セルの値は論理値 であることが確認できたなら、 ご提示の条件分岐は以下のようになります。 　　If Sheet2.Range("E22").Value = True Then 　　　　OptionButton1.Value = True 　　ElseIf Sheet2.Range("E22").Value = False Then 　　　　OptionButton2.Value = True 　　End If あるいは 　Sheet2のE22セルの値が論理値であっても文字列値であっても 見た目上の"表示された文字"で判別したいということでしたら、 以下のようになります。 　　If StrComp(Sheet2.Range("E22").Value, "TRUE", vbTextCompare) = 0 Then 　　　　OptionButton1.Value = True 　　ElseIf StrComp(Sheet2.Range("E22").Value, "FALSE", vbTextCompare) = 0 Then 　　　　OptionButton2.Value = True 　　End If 次に、 > OptionButton1がON・OptionButton2がOFF > OptionButton1がOFF・OptionButton2がON ということが、 ご提示のコードで実現されるかどうかについては、 OptionButton1 と OptionButton2 を グループ化してあれば可能、ということになります。 この点は説明がありませんが、恐らく グループ化してあるものと推察します。 もしこの点で躓いているようでしたら、補足欄にでも書いてみて下さい。 以上です。
Office2002と2010で試すと・・確かに。 Excel上で手動で変更は出来ましたので同じことをやらせれば・・。 ただし、HyperLink関数やInDirect関数では、 シングルクォーテーションで囲む必要が出てくるなどデメリットも。 http://app.m-cocolog.jp/t/typecast/260142/217579 … 下記はOffice2010の場合です。"sheet-X" → "sheet_X" → "sheet-X"に変わってゆきます。 ご参考までということで。 Sub test() Const tblName As String = "テーブル名" Const xlName As String = "e:\test.xlsx" Dim oXL As Object Dim oBK As Object DoCmd.TransferSpreadsheet acExport, acSpreadsheetTypeExcel12Xml, tblName, xlName, False, "sheet-X" 'Excel操作部分 Set oXL = CreateObject("excel.application") Set oBK = oXL.workbooks.Open(xlName) oBK.Sheets("sheet_X").Name = "sheet-X" oBK.Close saveChanges:=True ' oXL.UserControl = True ' oXL.Visible = True Set oXL = Nothing MsgBox "終了" '確認のために開きなおす CreateObject("shell.application").shellexecute xlName End Sub
以前に、Yukiさんから教えていただいたモノです。 解説出来るだけのスキルはいまだに持ち合わせておりませぬ orz Excel2010 & 32bit バージョンでの確認ですが、多分2003でも機能するハズです。 ※サイトの都合上、タブインデントの代わりに全角スペースにしています。 ' すべてのウィンドウ Declare Function EnumWindows Lib "user32.dll" _ 　　　　　　　　　　　　(ByVal lpEnumFunc As Long, lParam As Any) As Long Public Declare Function IsWindowVisible Lib "User32" _ 　　　　　　　　　　　　(ByVal Hwnd As Long) As Long ' ウィンドウのクラス名 Declare Function GetClassName Lib "user32.dll" Alias "GetClassNameA" _ 　　　　　　　　　　　　(ByVal Hwnd As Long, ByVal lpClassName As String, _ 　　　　　　　　　　　　 ByVal nMaxCount As Long) As Long ' ウィンドウテキスト Declare Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" _ 　　　　　　　　　　　　(ByVal Hwnd As Long, ByVal lpString As String, _ 　　　　　　　　　　　　 ByVal nMaxCount As Long) As Long '親ウインドウの Public Declare Function GetParent Lib "User32" _ 　　　　　　　　　　　　(ByVal Hwnd As Long) As Long 'ウインドウ文字列の長さ Public Declare Function GetWindowTextLength Lib "User32" Alias "GetWindowTextLengthA" _ 　　　　　　　　　　　　(ByVal Hwnd As Long) As Long 'ウインドウ設定値 Public Declare Function GetWindowLong Lib "User32" Alias "GetWindowLongA" _ 　　　　　　　　　　　　(ByVal Hwnd As Long, ByVal nIndex As Long) As Long Public Const GWL_STYLE = (-16) Public Const WS_SYSMENU = &H80000 Public Const WS_BORDER = &H800000 ' コールバック関数 Function EnumWindowsProc(ByVal Hwnd As Long, lParam As Worksheet) As Long 　　 Dim wks　　　　　　　　　　 As Worksheet Dim strWindowClassNameBuff As String * 128 Dim strWindowTextBuff　　 As String * 516 Dim lngRtnCode　　　　　　 As Long Dim lngStyle　　　　　　　　As Long Dim lngRow　　　　　　　　 As Long 　　'表示状態 　　If IsWindowVisible(Hwnd) = 0 Then GoTo EnumPass 　　'親ウインドウ 　　If GetParent(Hwnd) <> 0 Then GoTo EnumPass 　　'タイトルバー文字長さ 　　If GetWindowTextLength(Hwnd) = 0 Then GoTo EnumPass 　　lngStyle = GetWindowLong(Hwnd, GWL_STYLE) 　　'システムメニュー 　　If Not lngStyle And WS_SYSMENU Then GoTo EnumPass 　　'境界線 　　If Not lngStyle And WS_BORDER Then GoTo EnumPass 　　Set wks = lParam 　　lngRow = wks.Range("A65536").End(xlUp).Row + 1 　　 　　' ウィンドウハンドル 　　wks.Cells(lngRow, 1).NumberFormatLocal = "@" 　　wks.Cells(lngRow, 1).Value = CStr(Right("00000000" & Hex(Hwnd), 8)) 　　' クラス名をバッファに 　　lngRtnCode = GetClassName(Hwnd, strWindowClassNameBuff, _ 　　　　　　　　　　　　　　 Len(strWindowClassNameBuff)) 　　' クラス名表示 　　wks.Cells(lngRow, 2).Value = Left(strWindowClassNameBuff, _ 　　　　　　　　　　　　　　　　 InStr(strWindowClassNameBuff, vbNullChar) - 1) 　　' タイトルバーテキストをバッファに 　　lngRtnCode = GetWindowText(Hwnd, strWindowTextBuff, Len(strWindowTextBuff)) 　　' タイトルバーテキスト表示 　　wks.Cells(lngRow, 3).Value = Left(strWindowTextBuff, InStr(strWindowTextBuff, _ 　　　　　　　　　　　　　　　　vbNullChar) - 1) 　　' 列挙を継続 EnumPass: 　　EnumWindowsProc = True End Function Sub TEST() 　　Dim lngRtnCode As Long 　　' シートクリア 　　Worksheets(1).Cells.Clear 　　Worksheets(1).Range("A1").Resize(, 3).Value _ 　　　　　　　　　　　　　　　　= Array("WindowHandle", "ClassName", "WindowText") 　　' トップレベルウィンドウを列挙 　　lngRtnCode = EnumWindows(AddressOf EnumWindowsProc, Worksheets(1)) 　　Worksheets(1).Columns("A:C").AutoFit End Sub
＃２ですが、操作方法を間違えてたので訂正 ×）まず、セルC4を選んで、Ctrl＋Endキー押して（結果、4行目～5行目が選ばれる）、 ○）まず、セルC4を選んで、Ctrl＋Shift＋Endキー押して（結果、4行目～5行目が選ばれる） ブログラムが「列あるいは行全体を選択して書式設定する」を持ってたら、再発しますよ
説明だけではうまく伝わらないこともありますので、 コードも載せていただけると助かります。 　Dim MyImageList(3) As ImageList 　Dim Imagelist1 As New ImageList() 　'画像の読み込み 　With Imagelist1.Images 　　.Add(Image.FromFile("test01.jpg")) 　　.Add(Image.FromFile("test02.jpg")) 　　.Add(Image.FromFile("test03.jpg")) 　　'---(略)--- 　　.Add(Image.FromFile("test20.jpg")) 　End With 　'画像が多い場合は配列に登録 　If Imagelist1.Images.Count >= 20 Then 　　MyImageList(0) = Imagelist1 　End If いろいろと手抜きしていますが、こんな感じのコードでしょうか？ .NETのすべての型は「値型」と「参照型」に分けられます。 Imagelist1.Images.Clear()という操作がMyImageList(index)にも影響した(という言い方は正確ではないですが……)のは ImageListという型が「参照型」だからです。 オブジェクトを思い通りに操作するには、 値型と参照型の違いをよく理解しておく必要があります。 この2つについて説明されているサイトのアドレスを貼っておきますので、 こちらの「変数への代入における値型と参照型の違い」という項目を参考になさってみてください。 http://dobon.net/vb/dotnet/beginner/valuereferen …
MS製品の場合、一般的にタイトルバーの"ヘルプ(H)" メニューを選択して表示されるヘルプ画面の"目次" からプログラミングガイドやリファレンス等のドキ ュメントが参照できます。 関数やコマンドの全てはリファレンスに記述されて います。 ＃ディスク容量の節約の為に、ドキュメントをイン ＃ストールしていない場合は、追加でインストール ＃する必要があります。(残容量に注意)
＞何が足りないでしょうか？　＜ 　質問内容緯線のことですが 提示する情報が不足しています。 実際に書いているコードを載せればすぐにでも解決するでしょう。 １０年以上前の記憶ですが 適切なプロシージャの中に TextToSpeech1.Speak　"読み上げテスト" のようにテキストか変数を指定するだけでよかったと思います。
#1 です。 関連リンクの一つは、今回使っている WebBrowser クラスのリファレンスです。 メソッド、プロパティ、イベントは一通り読んでおくことをお勧めします。 http://msdn.microsoft.com/ja-jp/library/system.w …
こんにちは http://support.microsoft.com/kb/948615/ja こちらに説明されている内容だと思います。 とにかく。エクセル2007は、評判が悪く、私も苦労しています。 安直にエクセル2010で作ったファイルを配布して2007で使用すると 機能しなかったり、VBAでエラーが表示されたり。 2007ユーザーには、私もあきらめました。 それなり理解して使ってもらうことにしています。 表示は出るけれど、使えないわけではないのでは？
どこがわからないのでしょうか。。。 ADO でパラメータ クエリを実行するところ？ ADO でベタに書いた SQL を実行するところ？ SQL 文の組み方？ とりあえず Access のクエリ ビルダーで更新クエリぐらい作れるだろうから、SQL 文の解説は無しでも OK ですよね？ ベタに書くと UPDATE テーブルA SET テーブルA.名前 = "名称なし" WHERE テーブルA.ID = 1 となるので、 Dim con As ADODB.Connection Set con = Application.CurrentProject.Connection con.Execute "UPDATE テーブルA SET テーブルA.名前 = ""名称なし"" WHERE テーブルA.ID = 1" ってところか。 指定する ID の値と、書き換える新しい名前の文字列を指定できるようにするなら動的にパラメーター クエリを作って実行するって感じで、 Dim con As ADODB.Connection Set con = Application.CurrentProject.Connection Dim cmd As ADODB.Command Set cmd = New ADODB.Command Dim param As ADODB.Parameter Dim sql As String sql = "UPDATE テーブルA SET テーブルA.名前 = @newName WHERE テーブルA.ID = @id" With cmd 　　.ActiveConnection = con 　　.CommandText = sql 　　.CommandType = adCmdText 　　.Prepared = True End With Set param = cmd.CreateParameter("@newName", adVarChar, adParamInput, 10) param.Value = "名称なし" cmd.Parameters.Append param Set param = cmd.CreateParameter("@id", adInteger, adParamInput) param.Value = 1 cmd.Parameters.Append param cmd.Execute とか。
#1です。 ＞ActiveSheet.Name = Charts(s).Name を ActiveSheet.Name = Workbooks(FName).Charts(s).Name としてください。 Charts(s).Name はどちらのブックに対しての操作なのかを考えてみてください。 頭に何も書かないとアクティブなブック（今回の場合ではGNameのほう）に対しての操作となります。 グラフシートがあるのはFNameのほうですから、明示的にWorkbooks(FName).Charts(s).Nameと書きます。
他の方の回答の補足となってしまいますが・・・ Dim strFileName As String strFileName = Dir("E:\フォルダ\*.txt", vbNormal) Do While strFileName <> "" Name "E:\フォルダ\" & strFileName As "E:\フォルダ\" & Left(strFileName,Len(strFileName)-4) & ".xls" strFileName = Dir() Loop
＃２、ｃｊです。追加レスです。 > 開いている複数のエクセルブック(.csv) が、確実に開いているなら、名前を指定してアクティブにするのでも 構わないと思いますけれど、漏れがあってもエラーを出さない という意味では、＃２は比較的易しい設計を意図したつもりでした。 開いているワークブックだけを相手にしていますから。 ところで、 元質問でご提示のコードについてですが、 （意図を汲み兼ねている面もありまして） 変数 i の増加によって処理に変化を付けているのでしたら、 既出のもの、そのままでは対応出来ません。 　> ファイル名は、1 A、1 B、2 A、2 B・・・ 　> Do While i < 9 このふたつを合わせて読むと 　ファイル名は、1 A、1 B、2 A、2 B・・・8 A、8 B ということになると思いますが、 これらのファイル名を、1 から 8 まで、ふたつのファイルを一組として 順にアクティブにしていく記述を示しておきます。 Sub Re8205665a() 　　Dim i As Long 　　For i = 1 To 8 　　　　Workbooks(i & " A.csv").Activate 　　　　　　' ←' 1 A、2 A、3 A、4 A、5 A、6 A、7 A、8 A に対する処理を記述 　　　　Workbooks(i & " B.csv").Activate 　　　　　　' ←' 1 B、2 B、3 B、4 B、5 B、6 B、7 B、8 B に対する処理を記述 　　Next i End Sub 以上はファイル名で指定したワークブックが開いていないとエラーになります。 以下は "複数のエクセルブック(.csv)"　｜（開いてるかわからないブック） を 開きながらアクティブにし　｜（開いているならアクティブにするだけ） 順に処理していきます。 この場合、開いていなくてもエラーになりませんが、 存在しないブックを開こうとした場合は当然エラーになります。 Sub Re8205665aa() 　　Dim i As Long 　　For i = 1 To 8 　　　　Workbooks.Open i & " A.csv" 　　　　　　' ←' 1 A、2 A、3 A、4 A、5 A、6 A、7 A、8 A に対する処理を記述 　　　　Workbooks.Open i & " B.csv" 　　　　　　' ←' 1 B、2 B、3 B、4 B、5 B、6 B、7 B、8 B に対する処理を記述 　　Next i End Sub 以上、i は、1 から 8 まで 1 ステップずつ増加します。 いずれの例も、 　i & " A.csv" 　i & " B.csv" のように、 　数字（数値）を表す変数 i と 　文字列値 " A.csv"、 " B.csv" を 　&演算子で文字列として連結しているだけです。 文字列の部分だけ、ダブルクオート""で括って&で繋ぐ。 その基本だけ解れば応用は簡単です。
「インデックスが有効範囲にありません」ということは、恐らくシートを探す際に 指定された名前のシートが見つからない状況だと思います。 下記内容を確認してみて下さい。 １）「転記シート1」というシートのある「転記.xlsx」が存在すること ２）「データ1」というシートのある「データ.xlsx」が存在すること ３）上記、１）２）ともに、Bookが開かれていること このマクロには、Bookを開く操作が含まれていないので、 自分で開いておく必要があります。
VB6からVB.NETコンバーターに掛け、動作しないイベント処理やデバッグして 動作しないコードもしくはメゾットがあれば、書き換えてやればいいだけです。 VB6からVB2010へのアップグレードについて http://social.msdn.microsoft.com/Forums/ja-JP/55 …
Open "E:\フォルダ\試作.txt" For Output As #1 Print #1, "テスト" Close #1
Option Explicit '' 変数の宣言をチェックしてくれるキーワード Sub tepa() 　Dim strFilename As String 　Dim FileNumber As Integer 　Dim strREC As String 　 　Dim i as long 　For i = 1 To 70　　　'' 7行でワンセット×10セットの狙い撃ち 　　If Cells(i, 1) = "-" Then 　　　i = i + 2 　　　strFilename = Cells(i, 1) & ".txt" 　　　FileNumber = FreeFile 　　　Open strFilename For Output　As FileNumber 　　Elseif Cells(i, 1) = "" Then　　　'' スペース行判定がちょっとちがうかも。 　　　close 　　Else 　　　Print #FileNumber, Cells(i, 1) 　　End If 　Next End Sub
CDOというのは初めて扱ったので、参照設定してみました。 g_stmの型は何？ 調べてみると、ADODB.Streamの様なので、こちらも無駄に参照設定。（As Objectでも十分ですが） 一応動いている様に見えますが、ご希望のものが保存出来ているのかは判断つきかねます。ご参考まで。 Declare Function FindWindow Lib "User32.dll" Alias "FindWindowA" _ (ByVal lpClassName As String, _ ByVal lpWindowName As String) As Long Sub test() Dim ie As WebBrowser Dim g_msg As CDO.Message Dim g_stm As ADODB.Stream Set ie = getTopIeTab If ie Is Nothing Then Exit Sub Set g_msg = New CDO.Message g_msg.CreateMHTMLBody ie.LocationURL, 0, "", "" DoEvents Set g_stm = g_msg.GetStream DoEvents g_stm.SaveToFile GetDesktopPath & "\test.txt", 2 Set g_stm = Nothing Set g_msg = Nothing Set ie = Nothing End Sub 'IEの最前面Tabを取得 Function getTopIeTab(Optional matchWord As String) As WebBrowser Dim hWnd As Long Dim ie As WebBrowser Dim targetIe As WebBrowser Const IEClassName As String = "IEFrame" 'IEのClass名 hWnd = FindWindow(IEClassName, vbNullString) For Each ie In CreateObject("Shell.Application").Windows() If hWnd = ie.hWnd Then ie.StatusBar = True ie.statusText = CStr(hWnd) If ie.statusText = CStr(hWnd) Then If matchWord = "" Then Set getTopIeTab = ie ie.statusText = "" Exit Function Else If InStr(ie.LocationURL, matchWord) > 0 Then Set getTopIeTab = ie Exit Function End If End If End If End If Next ie Set getTopIeTab = Nothing End Function Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function
Workbooks.Open OpenFileName ↓ createobject("shell.application").shellexecute openfilename にしてみてください。
文字をクリアするのでは無く、空白を入力にすれば良いのでは？ 結合セル、結合していないセル両方とも空白になります。 C.ClearContents 　　↓ C.Value = "" ご参考まで
こんばんは！ せっかくコードをお考えのようですが、一例です。 バイト数で追いかけてみてはどうでしょうか？ 半角の場合は1バイト・全角の場合は2バイトとなるのを利用します。 Sub Sample1() Dim i As Long, k As Long, cnt As Long, myStr As String For i = 1 To Cells(Rows.Count, "B").End(xlUp).Row If LenB(StrConv(Cells(i, "B"), vbFromUnicode)) > 30 Then For k = 1 To Len(Cells(i, "B")) cnt = cnt + LenB(StrConv(Mid(Cells(i, "B"), k, 1), vbFromUnicode)) myStr = myStr & Mid(Cells(i, "B"), k, 1) If cnt >= 30 Then Exit For End If Next k Cells(i, "B") = myStr cnt = 0 myStr = "" End If Next i End Sub ※　半角文字が奇数の場合が問題ですが、今回のご質問に関しては 9文字の半角英数＋全角の空白　があるというコトですので大丈夫だと思います。 （半角の空白の場合は1文字多く表示されてしまいます）m（_ _）m
> 空白まで１ファイルとして出力したいです。 ファイル名（….sh） 文字列1 文字列2 (一行空白） ファイル名（….sh） 文字列1 文字列2 (一行空白） ファイル名（….sh） という構成ですか？ なら、VBAで行単位に値を読んでループさせる。 （ループの終了判定は２行空白が発生したとき）
　Bookには最低１つのシートが残っていないといけないので ここでエラーになりそうな気がしますが、エラーにならないのでしょうか。 For i = 1 To cnt Workbooks(fname).Worksheets(1).Move Moveではなくコピーならエラーにならないはずです。
子供みたいなご質問です、単に参考本と同様の回答しても問題解決になりませんよね。 どういった点が判らない、どういった点が理解できない、等々を自分なりに分析しましょう。 ＶＢＡを学習する以前にもう少し論理的な考え方をするようにして下さいとしか言えません。
MoveWindowではサイズの変更は避けられません。 ほかのWindowsAPIを使ってもよいなら、SetWindowPosで実現できます。 SetWindowPos http://msdn.microsoft.com/ja-jp/library/cc411206 … uFlagsにSWP_NOSZIEとSWP_NOZORDERを指定すれば、hWndInsertAfter、cx、cyは無視されます。
Adobeのアプリは『JavaScript』を使用し自動化する事が出来ます。 但し『マクロ』として存在している訳で無く『一から』作成する必要が 有ります。 http://www.openspc2.org/book/InDesignCS6/ ここではライブラリを提供してます。 Macでは『AppleScript』で簡単に動作を記録して作業出来るアプリが有ります
Worksheets("B")がWorksheets("A")の右隣にあるのなら With Worksheets("A") 　　 .Range("A1:C1").Value = .Next.Range("A1:C1").Value End With
「1要素のメモリサイズ」 × 「要素数」 文字列なら、上記+全文字数(アライメント等も含む)
VBAからEnviron関数で取得してみて設定出来ているのであれば (おっしゃるとおり)無理なのでしょうね。
LabelはGUI部品と結びついているだけの，単なるクラスです。 なので，Labelだからといって特殊なことは存在しません。 Label.TextはSystem.String型のプロパティですから， ・あらかじめ文字列を作ってから代入する ・&=演算子や，&演算子と=演算子を使ってTextプロパティ値を逐次更新する といった方法があります。 基本的には，文字列を作ってから代入した方がよいでしょう。 Textプロパティの内部でUIの更新が行われるので，あまり好ましくありません。 なお，改行はvbNewLineまたはEnvironment.NewLineを使います。 Windows環境であればvbCrLfと同等のはずです。 おまけ。 規則性があるならString.JoinやString.ConcatとLinq使うのも手ではあります。 Label1.Text = String.Join(vbNewLine, Enumerable.Range(1, saizu).Select(Function (n) New String("*"c, n)))
例外が発生した場合，通常そのMessageプロパティに例外に関する情報が含まれます。 # 場合によっては，InnerExceptionを辿る必要があるかもしれませんが。 デバッグ実行を行えば，例外が発生した時点でIDEが検知し， 例外インスペクタでExceptionオブジェクトの各プロパティを表示してくれるはずです。 まずはMessageプロパティの値を見て，例外の原因を調べてください。 ところで，auone-net.jp，SMTPS使って認証が必要なように読めるのですが……。 http://www.au.kddi.com/support/internet/guide/ma … http://msdn.microsoft.com/ja-jp/library/system.n … http://msdn.microsoft.com/ja-jp/library/system.n …
コードが不明なので何とも言えませんが 1行ずつステップ実行した場合に 結果が同じになるなら、 そのコード中に不適切な部分（非同期的処理？）が有るのでは。
分かりもしないプログラムを使おうとするよりフリーソフト探したほうが早いよ。 http://www.vector.co.jp/soft/win95/util/se162621 …
>sheet2へ列をずらして(先頭列CをFへ)コピーできないでしょうか。どうかよろしくお願いします。 Sub ボタン1_Click() Dim r As Range ST = InputBox("元データの列") EN = InputBox("挿入先の列") For Each r In Range(ST & "1:" & ST & 10) If WorksheetFunction.CountIf(Range("B10:B20"), r.Value) Then Sheets("sheet2").Range(EN & r.Row).Value = r.Value Else Sheets("sheet2").Range(EN & r.Row).Value = "" End If Next End Sub こういった書き方は参考になるでしょうか。 エラー処理はしていません。 コピーしたい元データ列を取得する方法 データを入れたい列の取得する方法は？ とりあえず　Inputbox　にしましたが。
> 1 セッションタイムアウトがあったとしてもログアウトしてからIEを閉じた方が無難だと思いますよ。 > 2 HTAでUIを持たせるとか、複数のバッチファイルかVBSから呼び出して(呼び出される側は)WScript.Argumentsプロパティで判別するとか。
こんにちは、 > ここで、ReDim PreserveのPreserveをとって、ReDimだけにすると、数字の増え方が目に見えて遅くなります。 > ReDim Preserveとしたときは9.5秒ぐらいですが > ReDim の時は 30秒以上かかっています 　ReDim は 新築 　ReDim Preserve は 増築 という喩で説明になっているかと思います。 実際には、Eraseして、メモリの再割り当てをしつつ、配列のサイズ（ディメンション）を再定義するのがReDim 既存のメモリを維持しつつ、メモリを拡張、サイズを再定義するのがReDim Preserve ということになります。 必然的にReDimを繰り返したら遅くなります。 ご提示のコードでPreserve キーワードを抜くと、 kankakuごとに、ReDimしている訳ですから、 せっかく格納したそれまでの値を消去していることになります。 可変長のString型変数の場合は特殊で、割り当てられるメモリサイズが固定ではありませんから 格納したり消去（長さ０の文字列を格納）したりするのに特に時間が掛かります。 ご提示のコードでPreserve キーワードを抜くと、 それまでに格納した文字長に比例したメモリサイズ、は無視されてしまいます。 本来の目的から外れたテストになってしまいます。 可変長の変数なのですから、要素数、だけではなくて、 要素数と文字長、の２点について、色々パラメータを変えながら テストしてみた方がより有意義なものになるのではないかと思います。 　Dim ans() As String のように一旦、文字列型として、動的配列変数を予め定義しておいた方が テストの精度が高まりますし、ReDimに掛かる時間も短くなります。 以上です。
> メモリ上でどのように動いているかまで言及されていて、根本についてとてもわかりやすく そういうところは「考えない」のも、プログラミング(特に高級言語を使ったもの)でのコツだと思います。 例えば、ウィンドウ上のボタンをクリックしたら... ってあたりを、CPUの視点から考えていたら、理解できるまでに知らなければならないことが多過ぎるし、知ったところで、それが役立つのはOS制作者くらいです。
＞マクロの記録ぐらいしかわかりません。 で ＞まずはなにからやればいいでしょうか。 ですよね。まずはVBAの基本を学びましょう。 http://excelvba.pc-users.net/ この辺りは最低　必要でしょうね。 一通り理解できたら 次に必要な方向性が見えてくると思います。
Dictionary オブジェクト速いですね。 当方でも日本郵便の郵便番号データの町域部分で試したところ、 データ数、124,300件、（Excel2010）で 抽出件数：86,117件 ADO→1825ms Dictionary→1061ms でした。 都道府県部分だと ADO→1217ms Dictionary→172ms ファイル形式（xls、xlsm）やExcelのバージョンに配慮する必要がないので #5さんの方法をお勧めします。
通常の配列ですとループを廻してつめていくしかないと思います。 余談ですが、collectionオブジェクトを使うとお望みのようなことができるかもしれません。 サンプルのマクロです。 Sub test() Dim a As Collection Dim b As Collection Set a = New Collection Set b = New Collection a.Add "a" a.Add "b" a.Add "c" b.Add a, "1" Set a = Nothing Set a = New Collection a.Add "A" a.Add "B" a.Add "C" b.Add a, "2" Set a = Nothing Set a = New Collection a.Add "あ" a.Add "い" a.Add "う" b.Add a, "3" MsgBox "最初の状態は・・・" For i = 1 To b.Count For j = 1 To b.Item(i).Count MsgBox "b(" & i & ")(" & j & ")= " & b.Item(i)(j) Next Next b.Item(1).Remove (2) '1行目の2番目の要素を削除 MsgBox "1行目の2番目の要素を削除したら・・・" For i = 1 To b.Count For j = 1 To b.Item(i).Count MsgBox "b(" & i & ")(" & j & ")= " & b.Item(i)(j) Next Next b.Remove (2) '2行目全体を削除 MsgBox "2行目全体を削除したら・・・" For i = 1 To b.Count For j = 1 To b.Item(i).Count MsgBox "a(" & i & ")(" & j & ")= " & b.Item(i)(j) Next Next End Sub
宣言していないシート名を指定すればエラーになるのは当然ですよね。 誤）場所入力 = 窓.Cells(3, 2).Value 正）場所入力 = 保管.Cells(3, 2).Value エラーとは関係ありませんが If 薬品名.Cells(行, 4).Value = 場所入力 ThenのCells(行, 4)はCells(行, 3)ではありませんか？ I
具体的にどの部分が『どうしてもうまくいかない』のでしょうか？ そちらの方が回答し易いです。 実際にプログラミングしたら、かなり安直なロジックと思われますが。
こんにちは！ VBAでもワークシート関数は使用できます。 おそらく参照先の項目の列・行の位置は変わらないと思いますので、 考え方としてINDEX関数とMATCH関数を組み合わせる方法と全く一緒だと思います。 具体的な配置が判らないので、参照先の表が↓のような感じになっているとすると Sub Sample1() Dim i As Long, j As Long i = WorksheetFunction.Match("4月", Columns(1), False) j = WorksheetFunction.Match("売上", Rows(1), False) Cells(i, j).Select End Sub これはMATCH関数を利用して行・列番号を取得しています。 いかにもVBAのような感じでやると Sub Sample2() Dim i As Long, j As Long, c As Range, r As Range Set c = Columns(1).Find(what:="4月", LookIn:=xlValues, lookat:=xlWhole) i = c.Row Set r = Rows(1).Find(what:="売上", LookIn:=xlValues, lookat:=xlWhole) j = r.Column Cells(i, j).Select End Sub 上記どちらのマクロを実行しても画像のD5セルが選択されるはずです。m（_ _）m
＃１です。 ・パスに空白を含む場合はパスの両端をダブルクォートで囲む必要がある。 ・引数は、パスの後に空白をはさみ記述する。 をお伝えしたかったところです。 Microsoftさんのライブラリでも記述があります。（参考URLの「ファイルの保護」あたり） その観点で補足の > WshShell.Exec ("C:\Program Files (x86)\MarketSpeed\MLauncher\MLauncher.exe" + RSS + "") の末尾は MLauncher.exe " + RSS + "") では無かろうか、と思います。 VBAからの起動よりも、拡張子BAT（CMD）バッチファイルで試されたほうが簡単かも。 バッチの起動時に「管理者として実行」を選択するとか。 検索する際に「ディスクトップアイコンの　プロパティー」では無くて 「デスクトップアイコンの　プロパティ」を用いたほうが良いと思います。 Win8は正直使いこなせそうに無いので未導入です。 的外れでごめんなさい。 参考URL：http://msdn.microsoft.com/ja-jp/library/xe736fyk(v=vs.80).aspx
試したわけではありませんが http://oshiete.goo.ne.jp/search_goo/result/?MT=C … が参考になるかと。 性質上、個人用途に限定されますね。
データの件数やテーブルのカラム定義等の条件により、 処理速度が変わる場合があります。 この質問には、上記のような詳細情報が欠如しているため、 「処理速度が速くなるような、別のコーディング」があるか どうかは不明です。
#1です。おバカな回答をしてしまいました。 すみません。 ちゃんと質問内容に書いてありましたね。 穴があったら入りたい。。。 XPで動作していたとのことなのでチェック済みかもしれませんが TMP_DIR のアクセス権の問題かも？ Usersグループに「変更」の許可を与えて試してみてください。 ↓なので↑これも見当違いな気がします。orz >そのファイルを使用してグリッドを表示使用とした時
下記でいかがでしょうか。 但し、対象範囲内から対象範囲内に単独または複数セルを、コピーとか移動した場合にキチンと動作するかどうかは未検証です。 Private Sub Worksheet_Change(ByVal Target As Range) If Intersect(Target, Range("I10:CW42")) Is Nothing Then Exit Sub Application.EnableEvents = False Application.Undo Sheets("Sheet2").Range(Target.Address).Value = Target.Value Application.Undo Application.EnableEvents = True End Sub
ＳＱＬｉｔｅにＯＤＢＣ経由で接続する
このような質問をする場合はＶＢのバージョンは必須です。 （6以前とその後では全く書き方が変わってきます）
#1です。それらしいモデルを作成して、ご提示のコードを入力シートのシートモジュールに貼り付けてやってみました。 Worksheets("入力").のD7セルのチェンジイベントで実行させたところ、 Range("番号").Name.Deleteでエラーが出て止まってしまいますね。 ActiveWorkbook.Names("番号").Deleteに書き換えると動作し、データの抽出・貼り付け、名前定義共に動作している様にみえます。当方xl2010です。 ただ、お示しのコードには、Worksheets(”データ")の抽出データ貼り付け先のクリアがないので、以前の残骸が残る事があります。
こういう問題では、レジストリに値を保存するのが、普通のやり方でしょう。 複数ユーザーでの使用で問題が起きにくい、Windowsのバージョンにかかわらず使える、といったことを考えると、一番安全な方法といえます。 http://dobon.net/vb/dotnet/system/registrykey.html
色々とおかしいです。 TransferSpreadSheet メソッドのヘルプを読んでみてください。 DoCmd.TransferSpreadsheet acExport _ , spreadsheettype:=acSpreadsheetTypeExcel12Xml _ , tablename:="クエリ2" _ , FileName:="c:\hoya\hoya.xlsx" _ , hasfieldnames:=True のような感じになります。 （パラメータの名前部分 例:spreadsheettyep:= などは分かりやすくするために付けたので 無くても構いません） あと、投稿の際に質問欄にべた書きしたためかもしれませんが、 行継続文字 _ の前には半角スペースが必要です。 エクセルの拡張子もxlsxです。 ※実行する前に、メニュー→デバッグ→○×のコンパイルを行ってエラーが出ないことを 確認してください。 ※変数『リスト』はテキスト型ですよね？
状況が今ひとつはっきりわからないのですが、推定すると以下のようなことでしょうか？ ・係数を求めたい。よってこれを変化させるセル(D3:D4)に割り当てた。 ・計算値を実測値に近付けたいので、目的セル(E18)には計算値（あるいは計算値と実測値の近さを表す数値）が計算されるようになっている。 ・計算値は外部dllを用いて係数から算出する。そのため、係数（変化させるセル、D3:D4）を変更しただけでは目的セル(E18)の値は更新されない。そこで、外部dll呼び出しとソルバーを交互に繰り返し実行する質問文中のコードを書いて実行してみたがうまくいかない。 もしそうであれば、そのとおりうまくいきません。 質問者様も書かれている通り、ソルバーが正常に動作するには「ここでいう係数と計算値が連動している」必要があり、そういう状態にできないのであれば値の計算とソルバーを交互に行ってもうまくいきません。 （連動の意味も質問者様の理解で合っていると思います） 部外者の立場としては、外部dllでの計算をワークシートの数式で実現できないのか、と聞きたくなりますがおそらくだめなのでしょうね。 現実的な解決策ですが、ユーザー定義関数を作り、その中で外部dllを呼び出すようにし、ワークシートの数式にそのユーザー定義関数を用いて化させるセル(D3:D4)から目的セル(E18)を算出するようにしてはいかがでしょうか。 （もちろん、外部dllの呼び出しとソルバーの交互繰り返し実行はやめます）
SQLはDAOでも実行できると思いますよ。 http://www.accessclub.jp/sql/05.html
>・継承関係にあるObject型に変換するならDirectCastがよい。 「継承関係にあるObject型に変換」ってどういう意味ですか？ 全てのクラスはObject型を継承しています。(だからこそObject型の 変数を用意すれば型変換なしに何でも代入できてしまうわけですが。) ほぼ意味の無い表現ですよこれ。 「オブジェクトに変換」という意味で使ったんでしょうか？ 「Object型」というものが定義されている以上、意味が変わってしまいますよ。 >・継承関係にない型変換の場合は、Ctypeがよい。 DirectCast の方がパフォーマンスに優れているのだから、DirectCast が使えるなら使った方がよいです。「良い悪い」では無く「出来る出来ない」 のレベルで違いがあるので、この理解の仕方では本末転倒です。 DirectCast の使い方が理解できない初心者向けの一時しのぎの解釈として、 CTypeで統一しておくというのはあると思います。 可読性とか、統一する事で検索し易くして保守性を上げる人もいるかもしれ ません。少数派だと思いますが。 >・Cstr、ToString、convertは、nullやNothingをどう扱うかによって使い分ければよい 対象の値がnullやNothingの場合にエラーになるならないの違いはありますが、 エラートラップすればいいだけなので、どの関数でも同等のプログラムは 書けます。nullやNothingの処理が関数の仕様どおりなら使った方がスッキリ 書けるでしょうが、nullやNothingが入ってきてる時点で問題がある場合が 多いので、Convert.ToStringで変換してしまうのは、そういった仕様が明確に なっている場合のみに限定する事をお勧めします。 あとは、コーディングルールを決めているならそれに従えばいいですし、 オブジェクト指向的な概念を重要視すれば、ToStringはオブジェクトが 主体。Convert.～は変換が主体。CStrは手続き型なのでオブジェクト指向 ではないと言えます。 オブジェクトを文字列に変換する場合に、内部的には ToString が呼ばれて いる場面が多々あります。ToString を使えるのが統一的な処理を書ける場合が 多いです。オーバーライドしてリスト系のコントロールに表示される文字列を カスタマイズするテクニックなどがあります。 CStrはVB6世代のコーディングなので、VB.NETの概念的には使わない方がいいの ですが、VB用に最適化されているのでパフォーマンスが向上することがあります。 私は使いません。 そもそも型変換において重要な点には、拡大変換と縮小変換があり、 VBは勝手に暗黙的な型変換を試みるので、変換元から変換先へ、どのような 変換規則が適用されるかを知っていないと判断なんてできませんが。 私の結論としては、勉強する気が無いなら CType と ToString 使っとけです。
あまりお役に立てるかわかりませんが Accessの接続がどのoracleDBのどのインスタンスのどのスキーマのTBLに接続していいか わかりません　という感じですかねー 管理ツール→ODBC接続がありますがＤＮＳの設定とか確認することをおすすめします まずはプログラムからではなく上記のような接続テストをお勧めします それと大穴で ODBCのバージョンアップ問題の可能性があります まあ　まずはどのようなエラーメッセージが出てるのか？ そこからつぶしていくしかないでしょう そんなに難しい問題ではないと感じますので 解決はできますよ 頑張ってください
＞forで回すしか方法はないのでしょうか？ でしょうね。私も他の方法が思い浮かびません。
質問の趣旨を確認させてください ・動いているけど遅いので速くしたい ・ただ単にSQL一発の方法に興味がある どちらになるのでしょう。 提示された VBA を見る限り、INSERT 一発では終わりませんね 存在したら UPDATE　/　存在していなかったら INSERT 単に考えると、この切り分けは必要ですね。 過去の以下質問で回答していたと思います Access2000のVBAで上書き更新 http://oshiete.goo.ne.jp/qa/8139092.html 回答の1つ目に記述していたと思いますが、動かなかったという事になりますか。 （INSERT ではなく UPDATE でのものになっていますが） WHERE 部分を削除すれば、UPDATE / INSERT 区別なく処理していると思うのですが・・・ なので、今回の回答では、上記質問での回答を試してみてください。という事になります。 ただ、あの時の回答のまま動くのか？は、わかりません 今回の質問では、Excel ファイルの拡張子は xlsm になっているので。 （他の質問でも 拡張子は xlsm ですね） どの様な環境で動かそうとしていますか Excel は、2007 以降がインストールされていて、Access は 2000 だけとか？ Access も 2007 以降が一緒にインストールされている？・・・とか 混在した環境は持ち合わせていないので、これについて補足いただいても回答できません。 （補足あれば、他の方が回答する際に役立つと思います） 以下は余談です：記述を見ていて気になった箇所２つ） > rs.Filter = "日=" & oApp.Sheets(sheet).cells(iRow, 2) > rs.Filter = rs.Filter & " and 場=" & oApp.Sheets(sheet).cells(iRow, 1) > rs.Filter = rs.Filter & " and 番号=" & oApp.Sheets(sheet).cells(iRow, 3) ここは以下の様に rs.Filter = として設定する回数を１回に rs.Filter = "日=" & oApp.Sheets(sheet).cells(iRow, 2) _ 　　　　　& " and 場=" & oApp.Sheets(sheet).cells(iRow, 1) _ 　　　　　& " and 番号=" & oApp.Sheets(sheet).cells(iRow, 3) rs.Filter =　で設定されると、その都度 絞込み処理が動いたと思います つまり、現状では３回絞込み処理が・・・・→ １回にする事で速くはなると思います。 　　Cells(4, 6) = "ABCD" 　　Cells(4, 6 + 26) = "abcd" 　　Cells(4, 6 + 26 + 26) = "1234" 雰囲気、上記の様な記述が見受けられますが、数値にこだわる必要はないと思います。 例えば、 　　Cells(4, "F") = "ABCD" 　　Cells(4, "AF") = "abcd" 　　Cells(4, "BF") = "1234" でも動いたと思います。 同じ動きをするのなら、後々わかりやすい方を選ばれたらと・・・
List1.List(ｎ) = "foobar" にてn番目のデータを書き換えることができます。 http://www.hanatyan.sakura.ne.jp/vbhlp/listcont. …
処理が終わったことがアクセス側からわかる方法はありますか？ ないなら、エクセルのマクロ1の最後に特定のセルに値を書き込んだりして（所定場所にファイルを造るでもいいですし）、処理が終了したことを伝える仕組みを作ってください。　アクセス側では、定期的にその場所を監視し、処理が終了した信号を受け取った後に次の処理に入ってください。　 アクセス側で（3の実行にかんして）は、自分自身の処理が終了するのはすぐにわかりますので、問題ないですよね。　
No.3です。 コードに oApp.Sheets(sheet) とたくさん書きならべてありますが、 これは書きならべないでWithを使うか変数にsetしてから使うかのどちらかにしたほうが速度が少し速くなると思います。
試しにやってみました。ご参考まで。 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address <> "$A$1" Then Exit Sub Application.EnableEvents = False Application.Undo 'コピー先は別のシートにします。'同じシート内で行うと、二回目のApplication.Undoで、Undo出来ないというエラーになりました。'途中で対象シートをいじってはイカンという事でしょうか。 Sheets(2).Range("B1").Value = Range("A1").Value Application.Undo Application.EnableEvents = True End Sub
こんばんは！ 手っ取り早いのはオートフィルタを使用する方法ですが、 今回の質問の場合はデータ数が少ないので、For～Nextでやってみました。 Sub 非表示() Dim i As Long For i = 1 To 10 If Cells(i, "D") = "●" Then Rows(i).Hidden = True End If Next i End Sub ※　再表示も必要だと思います。手作業でやっても簡単にできますが、 この際ですので再表示のコードもついでに・・・ Sub 再表示() ActiveSheet.Rows.Hidden = False End Sub こんなんではどうでしょうか？m（_ _）m
Cells( まで書いたら、コードヒント出てくると思いますが。 row＝行、column＝列 出てこないなら、遅延バインディングの恐れあり。
進められて良かった。 データ行（見出し含む）が32677行を越えているのですね。 > Dim i As Integer Integerでは、-32768～32767までしか対応できません。 型をLongで宣言してください。（±21億強に対応） Dim i As Long ということです。
引数 number が value1 以上でなおかつ value2 以下の場合か、value2 以上でなおかつ value1 以下の場合に True を返す ex. 1) number = 10, value1 = 5, value2 = 15 → True ex. 2) number = 10, value1 = 15, value2 = 5 → True Public Function Between(value1 As Double, value2 As Double, number As Double) As Boolean 　　Between = ((value1 <= number) And (number <= value2)) Or ((value2 <= number) And (number <= value1)) End Function
HideSelectionをFalseにしてください。
１個のオブジェクトに対してなら Excel　VBAで直線の座標を取得する方法をご存じなら それをPPに応用するだけでごく簡単にできます。 　ですが、複数のオブジェクトからこれとこれに という場合は手作業のほうが早いでしょう。 PPのVBAの機能を使う場合はちょっと面倒です。 　MotionEffect　、Path　か 　MotionEffect　、FromX などのキーワードで検索して MSDNかtechnetのサイトを読めばわかります。
ご質問から時間がたっているのでもう解決したかもしれませんが、今までの経験から回答します。 1　MSCOMCTL.OCXというファイルがどこにありますか (1)　Win7(32bit),XP場合 SP6であれば　(Cドライブ=システムドライブとして)　c:\Windows\system32 にありますが、ご質問のようにアンインストールやインストールの際にレジストリが壊れている可能性があります。また、その場所になければ最新のファイルを入手して上記のフォルダに保存します。 (2) Win7(64bit)の場合 　C:\Windows\SysWOW64にあるはずですが、なければ64bitで使う32bit用の上記ファイルをダウンロードします。ここは、要注意です。32bitで使っていたOCXをコピーしてもうまくいかない可能性があります。 　64bitマシン用には、c:\Windows\System32に同名のOCXはありません。 　ちなみに、私の最新ファイルバージョンですが、32bitマシン用が6.1.98.34に対して64bitマシンが6.1.98.33です。 　なお、このOCXは必ずしも上記のフォルダになければならないものではありません。適当なフォルダに入れておいてレジストリに登録すればよいのです。 2　レジストリに登録します。 　Regsvr32.exeの使い方については、WEBにいっぱい記述があるので検索してください。二重に登録しても特に問題はありません。一般的には、Regsvr32.exeを「ファイル名から実行する」などによりレジストリに登録します。 　ただし、Windows7は管理者として「スタート」→「アクセサリ」→「コマンドプロンプト」(右クリックして「管理者として実行」)を実行します。 　なお、管理者として実行する方法は別にもありますので、検索してください。 3　注意 　32bitマシンでVB6のプロジェクトをコピーし、64bitマシンに貼り付けても、MSCOMCTL.OCXを使っている場合はロードエラーになります。対策は下記のURLを参考にしてください。 　http://www.hanatyan.sakura.ne.jp/patio/read.cgi? … 参考URL：http://www.hanatyan.sakura.ne.jp/patio/read.cgi? …
こんにちは Sub 列移動() ActiveWindow.ScrollColumn = ActiveCell.Column End Sub では
VBA でも使用可能な OCX を探しまくればそんなコントロールが存在するかもしれない。 ツールの全体像がわからないからマッチするかわからないけど、Access で開発すれば帳票フォームを使用できるので質問にある絵のようなフォームは簡単に作成できる。
試してないのですまないが ドメインコントローラーの FQDN が dcname.hoge.local だとした場合 Dim path As String　= "LDAP://dcname.hoge.local/DC=hoge,DC=local" Dim root As New DirectoryEntry(path, "hoge\\認証ユーザー名", "パスワード") とか Dim root As New DirectoryEntry(path, "認証ユーザー名@hoge.local", "パスワード") とかは？
InputBoxのフォームを呼ぶときにShowDialogで呼ぶと、フォームが閉じるまで元のプログラムは止ります （例） Dim f as New InputForm f.ShowDialog
> Dim frm As New FormTest1 をボタンクリックイベント内でなくパブリックにしておいてメイン等で定義し、イベントの中で frm.TopMost = True frm.Show() を行うではどうでしょうか。 Newが完了する前にTopMostが指定されていて最初は間に合わないような気もします。 あるいは frm.Show(Me) ではどうなるでしょうか。
とりあえず検索のやり方だけですが考えてみましたので回答いたします。 まず、これはExcelですよね。 それと、質問者様提示のワークシートのデータですが、文章にある「営業」が見当たりません。これはA2に入力されているということでいいですよね。 さて、ExcelVBAでの検索の方法ですが、VBAだけで行うか、Findを使うか、オートフィルタを使うかなどいろいろありますが、今回の条件はオートフィルタに合っていると思いますので、オートフィルタを使ってはいかがでしょう。 ただし１つ問題があります。 A列の業務分類は各業務分類が１つしか入力されていないのですが、オートフィルタに使用するならすべての行に業務分類が入力されている必要があります。 業務分類がすべての行に入っている状態で検索を行うためのコードを書いてみました。 このコードを動作させるには、最低限ユーザーフォームからPublic変数(IGyou, IToi1, IToi2, IOp, I_Ok)を受けるところを補ってください。（動作確認だけならば単にPublic変数の値が決まればいいので、ユーザーフォームでなくとも代入文を並べるだけでOKです。） あとは、得られた範囲（変数ToiRS）をEnterキーで１つずつ選択するよう工夫してください。 Option Explicit Public IGyou, IToi1, IToi2, IOp, I_Ok Sub SearchTable1() Dim S, T1, T1RB, T1RE, CToi, CGyouK, ToiRS, oWshShell Set oWshShell = CreateObject("Wscript.Shell") Set S = ThisWorkbook.Sheets("Sheet1") 'シートはSheet1とした If Not S.AutoFilter Is Nothing Then S.Cells.AutoFilter 'オートフィルタが設定されていたら解除 End If Set T1 = S.Cells(1, 1).CurrentRegion '表のセル範囲を得る If T1.Rows.Count <= 1 Then oWshShell.popup "データがありません", 2 Exit Sub End If 'データがなければメッセージ表示（２秒間）後終了 CToi = 2 '「問い合わせ内容」の列 CGyouK = 1 '「業務分類」の列」 T1RB = T1.Cells(1).Row 'タイトル行位置(=1) T1RE = T1.Cells(T1.Cells.Count).Row '最終行位置 ' Userform1.Show ''ここでユーザーフォームから、業務分類(IGyou)、検索文字列(IToi1, IToi2)、 ''AND/OR(IOp)、入力の有無(I_Ok)を受け取るようにする。 ''（IGyou, IToi1, IToi2は文字列。IOpはANDで1、ORで2。I_OkはTrueまたはFalse） ''動作テストであれば、単にこれらの変数に値を代入するだけでよい。 ''なお、この例ではこのプロシージャをメインルーチンとして動作させ、 ''ここでユーザーフォームを呼び出し、ユーザーフォームで ''上記Public変数に値を代入することを想定しているが、 ''ユーザーフォームからこのコードを呼び出す場合は ''ここでプロシージャを分割すればよい。 ''その際、これ以前とこの後の両方で使用している変数に注意。 If Not I_Ok Then Exit Sub '入力がないなら終了 T1.AutoFilter field:=CGyouK, Criteria1:="=" & IGyou '業務内容でフィルタ If IToi1 = "" Or IToi2 = "" Then T1.AutoFilter field:=CToi, Criteria1:="=*" & IToi1 & IToi2 & "*" Else T1.AutoFilter field:=CToi, Criteria1:="=*" & IToi1 & "*", _ Operator:=IOp, Criteria2:="=*" & IToi2 & "*" End If '続いて問合せ内容でフィルタ（キーワードが１個か２個かで場合分け） Set ToiRS = S.Range(Cells(T1RB, CToi), Cells(T1RE, CToi)) _ .SpecialCells(xlCellTypeVisible) 'まずは問合せ内容の可視セルをタイトルごと選択。セル１個ならデータなし。 '（選択データがないとSpecialCells(xlCellTypeVisible)がエラーになる） If ToiRS.Count <= 1 Then oWshShell.popup "該当するデータがありません", 2 S.Cells.AutoFilter Exit Sub End If 'データなしならメッセージ表示（２秒間）後オートフィルタ解除して終了 Set ToiRS = S.Range(Cells(T1RB + 1, CToi), Cells(T1RE, CToi)) _ .SpecialCells(xlCellTypeVisible) 'ヒットしたセル範囲（問合せ内容の可視セル・タイトル以外）を変数ToiRSにセット S.Cells.AutoFilter 'オートフィルタ解除 oWshShell.popup ToiRS.Address, 2 '得られた範囲のアドレスを２秒間表示 ''この後、EnterキーでToiRSの範囲を１セルずつ選択するようにする End Sub うまくいかないところやわからないところ、ご要望に合わないところなどありましたら補足ください。
手元にVBがないので違っているかもしれませんが、 参照設定で「Microsoft Excel 11.0 Object Library」にチェックを入れておいて（11.0の箇所は環境によって数字が違うかもしれません）、 Dim xlObj As New Excel.Application xlObj.Visible = True xlObj.Workbooks.Open FileName:= "D:\Book1.csv" で、どうでしょうか。
過去のQ&Aを検索してみたら、以下の情報が見つかりました。 http://oshiete.goo.ne.jp/qa/1314881.html これが役に立つかも。
そのままだったら 2003版のときにもエラーになるのが普通です。 「変数の宣言を強制する」にチェックを入れないまま使っていたから そのまま使えたのでしょう。 　２０１０版のほうはチェックを入れてあるのでしょう。
Timer.Intervalプロパティの値はミリ秒単位です。 通常のディスプレイは60fps(≒17ミリ秒に1回のペース)で画面を表示しますので、 2ミリ秒に1回という短いペースでラベルを更新しても意味がありません。 むしろPCにとって負担なだけです。 人間の目では、リフレッシュレートが30fps(≒33ミリ秒に1回のペース)を切ると「カクついている」と感じると言われています。 以上の情報を参考に、ラベルの更新頻度を再調整してみてください。
やってみて動いたッポイので回答してみますが、裏付け等はしてください。 テーブル「T5」で、フィールド「FF1」が添付ファイルとします。 フィールド「FF1」の Value はレコードセットになっているようで、 フィールドは６つ存在しました。（2007 にて） その中で Name = "FileName" 部分の Value にファイル名があるようです。 Public Sub test1() 　　Dim rs As DAO.Recordset 　　Dim v As Variant 　　Set rs = CurrentDb.OpenRecordset("T5") 　　While (Not rs.EOF) 　　　　With rs("FF1").Value 　　　　　　While (Not .EOF) 　　　　　　　　For Each v In .Fields 　　　　　　　　　　If (v.Name = "FileName") Then 　　　　　　　　　　　　Debug.Print v.Value 　　　　　　　　　　　　Exit For 　　　　　　　　　　End If 　　　　　　　　Next 　　　　　　　　.MoveNext 　　　　　　Wend 　　　　End With 　　　　rs.MoveNext 　　Wend 　　rs.Close 　　Set rs = Nothing End Sub Name = "FileName" はフィールドの３つ目にあるみたいで・・・（裏付けなし） 添付ファイルの個数は１つ or 設定なしであれば、以下でも良いのかも Public Sub test2() 　　Dim rs As DAO.Recordset 　　Set rs = CurrentDb.OpenRecordset("T5") 　　While (Not rs.EOF) 　　　　With rs("FF1").Value 　　　　　　If (Not .EOF) Then Debug.Print .Fields(2) 　　　　End With 　　　　rs.MoveNext 　　Wend 　　rs.Close 　　Set rs = Nothing End Sub とか Public Sub test3() 　　Dim rs As DAO.Recordset 　　Set rs = CurrentDb.OpenRecordset("T5") 　　While (Not rs.EOF) 　　　　If (Not rs("FF1").Value.EOF) Then 　　　　　　Debug.Print rs("FF1").Value("FileName") 　　　　End If 　　　　rs.MoveNext 　　Wend 　　rs.Close 　　Set rs = Nothing End Sub
VarType関数があるのは忘れてました。 Variant型はこの辺を参照。 参考URL：http://www5f.biglobe.ne.jp/~f-lap/tips_staticarr …
こんな感じのアルゴリズムになるかと思います。 なお、実際のコーディングではありませんのでこのままコピペしても動きません。 gosa = 0.01 '一致とみなす誤差範囲 for i = 0 to 360　'涙型を0～360まで廻す 　cx = ....　'角度iの時の涙型のx座標 　cy = .... '角度iの時の涙型のx座標 　for j = 0 to 360　'点Bを0～360まで廻す 　　bx = ..... '角度jの時の点Bのx座標 　　by = ..... '角度jの時の点Bのx座標 　　if ( bx - cx )^2 + ( by - cy )^2 <= gosa then 　　　　 '（一致した時の処理：座標(bx,by) 、角度：j　を別変数に保存） 　　　　X = bx 　　　　Y = by 　　　　 deg = j 　　　　i = 360 ' iループから抜ける 　　　　j = 360　' jループから抜ける 　　 end if 　next j next i
例えば・・ フィルタ実行ボタン Private Sub CommandButton1_Click() 　　　　' ↓Range("B15")は実際の条件選択の表の左上のセル番地に直す。 　　　　If Not Intersect(Selection, Range("B15").CurrentRegion) Is Nothing Then 　　　　　　　　With Range("A2")　' 実際の表の左上セル番地 　　　　　　　　　　　　If ActiveSheet.AutoFilterMode Then .AutoFilter 　　　　　　　　　　　　' 以下同文につき省略 　　　　　　　　　　　　.AutoFilter Field:=Selection.Column, Criteria1:=Cells(Selection.Row, "B") 　　　　　　　　End With 　　　　Else 　　　　　　　　MsgBox "ERROR" 　　　　　　　　Exit Sub 　　　　End If End Sub フィルタ解除ボタン Private Sub CommandButton2_Click() 　　　　If ActiveSheet.AutoFilterMode Then Range("A2").AutoFilter End Sub こんな感じでしょうか。 でも、この程度なら手動でフィルタをかけた方が早くないですかね？ と言う素朴な疑問です。
(?<=<pre>).*?(?=</pre>) これを大文字小文字区別しない、複数行に対してやる、を条件に、 正規表現で抽出すればよいのでは。 http://msdn.microsoft.com/ja-jp/library/b49yw9s8(v=vs.80).aspx http://msdn.microsoft.com/ja-jp/library/system.t …(v=vs.80).aspx
仰っている意味は、たとえば「20行目まで入力されたらそれ以降は入力できないようにする」ということでしょうか？ 上から15目あたり、 If ListBox1.ListIndex = -1 Then 'リストが選択していなかったら、 Cells(Rows.Count, 16).End(xlUp).Offset(1).Select '----------追加ここから If Selection.Row = 27　Then i=Msgbox("これ以上は登録できません",vbOKOnly) Exit Sub End If '----------ここまで For myArray = 0 To 9 としてはどうでしょうか？
SetWindowPos APIにHWND_TOPMOST指定とか。
.Range("A1").PasteSpecial Paste:=xlPasteValues ですが、セルの結合状態が貼り付けられないのではないでしょうか。 とりあえず下記の１行を追加してもう一度試してみてはいかがでしょうか。 .Range("A1").PasteSpecial Paste:=xlPasteFormats
セル（10,5）に入っているのは「g_array(1,1)」という「文字列」ですから、ご質問のように文字列としての「g_array(1,1)」が返ってきてしまう訳です。 配列名g_arrayが固定（他の配列も定義して、セルに入れる配列名が変化する。という状況はない）だとして、強引ですが以下のようにすればとりあえずは目的の値が返ります。 動作の概要としては、文字列としての「g_array(1,1)」から数値としての添字「1と1」を取り出してきて、g_arrayの添字として使って、目的の値を得ています。 -------------- Sub sample() Dim g_array(3, 3) As Variant Dim idx As Variant　　　'配列の添字用 g_array(1, 1) = "5" Dim test As Variant idx = getindex(Cells(10, 5).Value) test = g_array(idx(0), idx(1)) End Sub Private Function getindex(str As String) Dim retdata(1) '戻り値を配列で Dim i As Long Dim strlen As Long Dim str0 As String Dim str1 As String strlen = Len(str) str1 = "" For i = 1 To strlen str0 = Mid(str, i, 1) chk = check(str0) Select Case chk Case 0 '数値の場合 str1 = str1 + str0 Case 1 '「,」の場合 retdata(0) = str1 str1 = "" Case 2 '「)」の場合 retdata(1) = str1 End Select Next i getindex = retdata End Function Private Function check(str As String) As Long check = 9 If str = "," Then check = 1 End If If str = ")" Then check = 2 End If If InStr("0123456789", str) <> 0 Then check = 0 End If End Function ------------------ 全然スマートではないです。もっといい方法があると思います。 ご参考までに。
sub 関数A(Optional test As Long = 999) とすると引数が省略でき、省略時の値も設定できます。
UTF-8のファイルをSJISのファイルに変換する例です。 '変数を定義する Dim 変換元ファイル As Object Dim 変換先ファイル As Object '変換元ファイルのオブジェクトをインスタンス化する Set 変換元ファイル = CreateObject("ADODB.Stream") '変換元を開く 変換元ファイル.Open '変換元ファイルを設定する 変換元ファイル.Type = 2 変換元ファイル.Charset = "UTF-8" '変換元ファイルを読み込む 変換元ファイル.LoadFromFile "D:\okvbs\UTF8.txt" '変換先ファイルのオブジェクトをインスタンス化する Set 変換先ファイル = CreateObject("ADODB.Stream") '変換先ファイルを開く 変換先ファイル.Open '変換先ファイルを設定する 変換先ファイル.Type = 2 変換先ファイル.Charset = "SHIFT_JIS" '変換先ファイルにコピーする 変換元ファイル.CopyTo 変換先ファイル '変換先ファイルを保存する 変換先ファイル.SaveToFile "D:\okvbs\SJIS.txt", 2 '各オブジェクトを廃棄する 変換元ファイル.Close Set 変換元ファイル = Nothing 変換先ファイル.Close Set 変換先ファイル = Nothing
http://msdn.microsoft.com/ja-jp/library/vstudio/ … 追加です。 上記を見るとC#のFocusとは違う考え方を（近いのはキーボードフォーカスと推測）しており、詳細になっているため、上記概念を把握された上で適切に実装されたほうがよいです。
この質問からはどのコントロールを消すのかはわかりませんでしたが、 コントロール名は分かりそうなので、 ControlsクラスのFindメソッドで検索できると思います。 http://dobon.net/vb/dotnet/control/findcontrolby …
http://dev.mysql.com/doc/refman/5.1/ja/string-sy … http://www.dbonline.jp/mysql/ini/index1.html これじゃないんですか？ \(バックスラッシュ)はエスケープ文字だと思いますけど。 やるなら、MySQLをコマンドライン上からINSERT文発行が正しい確認の仕方でしょう。
取り急ぎ。 エクセルの機能には「Ｎアップ＝Ｎｉｎ１」の機能は無いです。 ですが、エクセルには「プリンタを選択する」機能があります。 これがキーワードです。 で、ウィンドウズでは「同じプリンタを２つインストール」できて、 「プリンタの基本設定を保存」しておけます。 これが二つ目のキーワード。 つまり、普段使っているプリンタをプリンタ一覧にもう一つ用意して、 「２アップする設定で保存」しておき、 「設定変更したプリンタを選択して印刷する」マクロを作れば良い、と言うことです。 踏まえて検索すると、ヒントが見つかると思いますよ。
No.1です！ たびたびごめんなさい。 前回の投稿で大きな変換ミス（入力ミス）をしていました。 ＞実際のデータ数はもっと酢酸あると思うのですが は ＞実際のデータ数はもっとたくさんあると思うのですが の大間違いです。 酢酸だらけだと酸っぱくてどうしようもないですね！ 何度も失礼しました。m（_ _）m
連続した範囲ではないからでは？ なので　A1:A5　ここしか代入されていないから そうなると思うのですが。。。
質問の詳細化を図りたく伺います。 ・フォームに複数のテキストボックスなどがあり、登録（コマンド）ボタンをクリックするとそれがワークシート上に転記される、というイメージでしょうか ・「登録」ボタンをクリックした後はどのように動くことを期待していますか？ →たとえば、ワークシートの次の行へ追加するために 　　・フォームのデータをクリアし、 　　・ワークシートのオフセットを移動する　　　とか。 ・Cmd_1, Cmd_2...は特定のコンポーネント（たとえば、コマンドボタンのクリックイベント）と関連づいていますか？ 初めてということなので、一応記載しますと、 フォームのデザイン画面で「登録」ボタンをダブルクリックすると、コマンドボタンのクリックイベント（ボタンがクリックされたときに呼び出されるブロック）を実装するエディタが開きます。 そこに、ワークシートに入力したい内容をプログラムします。
仔フォームからは、MdiParentプロパティで親フォームのオブジェクトが参照出来るので、そこからさらにLocationプロパティで位置を取得すればよいと思います。 frm.MDIparent.Location
フォーム側のBackColorプロパティは無視されている状態です。 MDIフォームのクライアント領域は、MdiClientというコントロールがあり、そちらのBackColorを変更することで対処します。 http://dobon.net/vb/dotnet/form/mdibackcolor.html
オリジナルファイルが、E:\org.txt にあったとして 文字コードがShift-JIS、中身が mCZ8MQsfT2tWHMG XKXrDCT1QA5Pi9v f41jdIHEFa5mEDw NyiEDEF59A53TMP M4SCGZFGuB6mIAt VqfDGgEyZ0Wuz6z とした場合です。 Dim oFS Dim FF(3) Dim tmp Const forReading = 1 Const forWriting = 2 Set oFS = CreateObject("Scripting.FileSystemObject") Set FF(0) = oFS.OpenTextFile("e:\org.txt",1) Set FF(1) = oFS.CreateTextFile("e:\org_1.txt", 2,true) Set FF(2) = oFS.CreateTextFile("e:\org_2.txt", 2,true) Set FF(3) = oFS.CreateTextFile("e:\org_3.txt", 2,true) Do Until FF(0).atEndofStream tmp = FF(0).readLine If Mid(tmp, 5, 1) = "D" And Mid(tmp, 10, 2) = "A5" Then FF(1).writeLine(tmp) ElseIf Mid(tmp, 5, 1) = "G" And Mid(tmp, 10, 2) = "B6" Then FF(2).writeLine(tmp) Else FF(3).writeLine(tmp) End If Loop FF(0).Close:FF(1).Close:FF(2).Close:FF(3).Close
WinformのPointToClient相当のメソッドをWPFで探すと、VisualクラスのPointFromScreenが該当するようです http://msdn.microsoft.com/ja-jp/library/system.w … 参考までに、(WinForm)PointToScreenは(WPF)PointToScreenです。 回答のための情報源： http://social.msdn.microsoft.com/Forums/vstudio/ …
Speech SDK 5.1 http://www.microsoft.com/en-us/download/details. … ここから「Download」する。 エンジン、ドキュメント、サンプルコードは、SpeechSDK51.exe 日本語を使う場合は、SpeechSDK51LangPack.exe も追加。 （Install Instructions より）
回答させていただきます。 １．Outlook 2007のＶＢＡにてデスクトップのvbsファイルを実行 方法は複数ありますが、ここではVBAのShell関数を使う方法を書きます。 デスクトップのパスが変わっても大丈夫なようにWshShellオブジェクトのSpecialFoldersを使いました。 デスクトップにある Sample1.vbs を実行します。 Sub RunSample1() Dim oWshShell Set oWshShell = CreateObject("Wscript.Shell") Shell "wscript """ & oWshShell.SpecialFolders("Desktop") & "\Sample1.vbs""" End Sub ２．途中で１秒止めるというコード これも何通りかありますが、一番よく使われていると思われるものを説明します。 まず、モジュールの先頭に以下のように１行書きます Declare Sub Sleep Lib "kernel32" (ByVal ms As Long) （上記は64bit版Officeには未対応ですがその話は省略します） あとは、1秒待ちたいところに Sleep 1000 と１行入れるだけです。 （数字はミリ秒単位で指定します）
こんにちは！ 横からお邪魔します。 No.1さんが回答されていらっしゃる通り、 ＞Cells(Rows.Count, 5).End(xlUp).Select ＞dataend = ActiveCell.Row の部分でE列の最終行を取得されているみたいですが その後の ＞If Cells(2, i).Value = Cells(2, i + k).Value Then 部分で 「行」がいつも間にか「列」に変わっていますよね！ Excelで表示できる列数以上に最終行があった場合は当然そこでマクロが止まってしまいます。 ご希望としては「行削除」というコトでしょうから、少し考え方を変えて E列に重複するデータがあればそれを削除する！としてみてはどうでしょうか？ せっかくコードをお考えですが、別コードでの一例です。 Sub 重複削除2() Dim i As Long Application.ScreenUpdating = False For i = Cells(Rows.Count, "E").End(xlUp).Row To 2 Step -1 If WorksheetFunction.CountIf(Range("E:E"), Cells(i, "E")) > 1 Then Rows(i).Delete End If Next i Application.ScreenUpdating = True MsgBox "処理完了" End Sub こんな感じではどうでしょうか？m（_ _）m
おそらく、textBlock.ActualHeightかと思われます。 RenderSizeのドキュメントを読むと、RdnderSizeを使うシチュエーションは限られていそうで、通常はActual***を用いるとあるためです。 http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.95).aspx この時、気をつけなければならないのは、ActualHeightの更新契機です。以下のURLが参考になるかと存じます。 http://csfun.blog49.fc2.com/blog-entry-41.html
No.2です。 補足のコードを拝見しました。 仮にインプットボックスに「3」という数値を入力すれば D列に1列挿入　→　C列すべてを挿入した列にコピー！ という操作を行いたい訳ですよね？ 2点ほど問題があります。 （1） ＞With Cells(myColumn, 1) の行の部分で行・列が逆だと思います。 ＞With Cells(1, myColumn) にしてみてください。 （2） ＞.EntireColumn.Copy .Offset(1) の行で貼り付け先が1行下となりますので、ここでエラーになると思います。 ＞.EntireColumn.Copy .Offset(, 1) ※　手抜きなしに書くと　 .EntireColumn.Copy .Offset(0, 1) これで補足のコードに関しては動くと思います。m（_ _）m
>私が触ってきた言語では、通常、 >何も書かなくても親の処理が実行され、 >子側では、差分だけ、同名メソッドに追記するだけでよいということが多かった気がします。 それが何という言語なのか、興味ありますね。その言語では、下記のような場合にどうやって記述するのでしょう。 [A]親クラスのrunメソッドと全く違うことを子クラスのrunメソッドでやりたい(コンソールに「親」と表示したくない)場合 [B]コンソールに「子」と表示してからコンソールに「親」と表示したい場合 super.run()を明示的に書く言語(C++とかJava)では[B]は明らかですし、[A]もsuper.run()を書かないだけで実現できます。
http://support.microsoft.com/kb/219905/ja
　PictureBox1.Image = img でPictureBoxに設定した画像を 　img.Dispose() で片付けてしまっているからだと思います。
入力したい数式はそれであってますか？ H4セルが=IF(H4="","",SUM(H5:H30)/(30-COUNTIF(H5:H30,"")))循環しちゃってますけど？ 単純なAVERAGEとも違うって事なんですよね.. ..って事はおいといて。 ループインデックスを参照渡しする事の是非もおいとくとして。 コンパイルエラーですよね。 >質問1：なぜ、test1がダメで、test2ならうまくいくのかという理由がわかりません。 提示されたtest2でもうまくいきません。 問題は >dim i, myR as integer >dim i, k, myR as integer ここ。 変数iもkも型宣言が省略されているとみなされ、Variant型になっています。 だから型不一致コンパイルエラーです。 ByVal値渡しだと暗黙的に型変換されるのでコンパイルエラーにひっかからないとは思いますが ループインデックスをVariantにする必然性はないので、ちゃんと型宣言しておくほうが良いでしょう。 カンマで繋ぐ場合は Dim i As Integer, myR As Integer と書いてください。
手作業でも簡単にできるよね、これ。 １）Bシート選択 ２）シートのメニューから「全てのシートを選択」 ３）Aシートの選択をCtrl押しながら解除 ４）選択されているシートのメニューから「削除」
　　With objIE.Document.getElementById("entry_title") 　　　　.Value = "A" 　　　　.NextSibling.Data = "B"　　　　'　　　　（１／３択） 　　　　.NextSibling.NodeValue = "B"　　　　'　　　　（２／３択） 　　　　.NextSibling.textContent = "B"　　　　'　　　　（３／３択） 　　End With こんな感じのことでしょうか。 三者択一です。 ご提示のループにはめるなら、 　　With objIE.Document.getElementById("entry_title") を 　　With itm に換えて itm.Value = "A" の位置に挿入します。
＃既に種々の回答が付いていますが、お示しのコードの「図」を拝見して考えられることを少し。 ●１）先ず、「p=array.indexof(str,"い")」のところが赤くなっていますが、これはコンパイルエラーですよね。 　「array」という言葉は予約語（Array 関数）であるため、変数としては使えないはずです。 　試しに、「Dim array as Object」などと書こうとすると、「array」の部分が選択された状態で、「コンパイルエラー: 修正候補: 識別子」と表示されます。 http://officetanaka.net/excel/vba/error/compilat … ●２）次に、「indexof」という関数自体についてですが、 Sub Macro1() 　　Dim myAL As Object 　　Set myAL = CreateObject("System.Collections.ArrayList") 　　For i = 1 To 3 　　　　myAL.Add Mid("あいう", i, 1) 　　Next i 　　p = myAL.indexof("い", 0) + 1 　　MsgBox p & "番目" End Sub みたいな使い方なら動かすことはできなくはありません。 　しかし、pucho3338 さんがお示しのコード p = indexof(str, "い") に書かれているような、第１引数が「配列」、第２引数が「配列の要素」となるっているものが、どの言語の [IndexOf メソッド] なのかが判りかねます（言語によって引数の数や種類が異なる）。 http://social.msdn.microsoft.com/Search/ja-JP?qu … 　しかも、次行には、 p = array.indexof(str, "い") というように、関数の前にオブジェクト（array）が配置されていますが、(１)で書きましたように、この行も動かないはずです。 　この２行を拝見しただけでも、まともに動くコードとは思えませんので、これは、「友人に頼まれ修正」する前のコードではなくて、pucho3338 さんご自身が、修正時点でつまづかれたところだけを抜き書きされたコードではないかと存じますが、いかがでしょうか？ ●３）この「コンパイルエラー: Sub または Function が定義されていません。」エラーが出ないようにするためには、下記のいずれかの処置がされている必要があるかと存じます。 　　・何かのライブラリに参照設定を施す。 　　・[CreateObject 関数] で ActiveX オブジェクトへの参照を作成する。 　　・別途、下記のようなユーザー定義関数が定義されている。 Function indexof(myArr, element) 　　For i = 0 To UBound(myArr) 　　　　If myArr(i) = element Then Exit For 　　Next 　　indexof = i + 1 End Function ●４）しかし、 p = array.indexof(str, "い") という書き方から見ると、求める「p」は「2」ではないかと存じますが、その「答え」が欲しいだけでしたら、わざわざ関数を作らなくても、 p = Application.Match("い", str, 0) でイケルかと存じますが、実は、「IndexOf メソッド」だけではなくて、「Sort メソッド」や「Contains メソッド」などが使いたいというようなことでしたら、 http://social.msdn.microsoft.com/Search/ja-JP?qu … に検索された「ArrayList クラス」を使うことになろうかと存じます。
ウチのＮｏ６のスペックでは９×９×９はできました。 あと画面解像度は１９２０×１０８０ピクセルです。
http://oshiete.goo.ne.jp/qa/8149540.html ちょうど同じ質問を受けていましたので上記URLで参照してください。 参考になればと存じます。
http://dobon.net/vb/dotnet/form/autoscroll.html AutoScrollプロパティはいかがでしょうか。
No.1の方がおっしゃるよう、マクロは関係ないですね。 ＞別のファイルの物を印刷しようと思い、そのファイルの印刷設定を変えて ＞印刷をしました。 この操作がどのようなものかわかりませんが、プリンターのデバイスから変更の操作を していたら、ご指摘の様な動作になると思います。 回避の方法として １、別のファイルを印刷した後に、プリンターのデバイスの設定を元に戻す。 ２、別のファイルを印刷するときに、プリンターのデバイスは操作しない。 ３、エクセルで印刷する際には、別のプリンターデバイスで印刷する。 ちょっとしたウルトラＣ的なテクニックですが 手順 １、同じプリンターで、プリンターの設定を２個作ります。 ２、エクセルＶＢＡで印刷するときに、プリンターの指定を行います。 提示のＶＢＡも結構もだが多いので修正してみます（動作確認はしていません） Sub Futo_Copy() Dim myPrinter AS string myPrinter = Application.ActivePrinter '現在のプリンタ名を取得 Application.ActivePrinter = "変更したいプリンタ名" '↑の部分でプリンターを通常のプリンターから設定の変更していないプリンター切り替える with Worksheets("出力") row_count = Worksheets("印刷対象").Range("A65536").End(xlUp).Row For i = 3 To row_count '印刷対象の3行目からループ .Cells(1, 1) = Worksheets("印刷対象").Cells(i, 1) .Cells(2, 1) = Worksheets("印刷対象").Cells(i, 2) .Cells(3, 1) = Worksheets("印刷対象").Cells(i, 3) .Cells(4, 1) = Worksheets("印刷対象").Cells(i, 4) Worksheets("出力").PrintOut 'プリントアウト Next i End With Application.ActivePrinter = myPrinter '↑の指示で最初のプリンターデバイスに戻す。 End Sub こんな感じで試してみてください。
エラーについては、既出の３つの回答で解決されるかと思います。 私からはそのエラーが解消したとして・・・やっておきたい事を（他の部分も提示されていたので） やりたい処理を整理されてみてはどうでしょう。 MycnnrstDst は、（「追加」時に）ある/ない判別にしか使ってない様ですね。 MycnnrstDst を得ているのなら、追加時には MycnnrstDst.AddNew してから MycnnrstDst("整理番号") = Me.整理番号 　等羅列して最後に Update すれば良いような気がします。 例） MycnnrstDst.AddNew MycnnrstDst("整理番号") = Me.整理番号 ・・・ MycnnrstDst("重要度") = Me.重要度 If (Not IsNull(Me.対策完了)) Then 　　MycnnrstDst("内容") = Me.内容 　　・・・ 　　MycnnrstDst("対策完了") = Me.対策完了 End If ・・・ MycnnrstDst.Update そうすれば、INSERT文に記述しているフィールド部分と VALUES 部分の個数/順があっていない 等、間違いがなくなるような気がします。 If IsNull(Me.対策完了) Then 側では、天候, 温度, 風,・・・　に対する VALUES が無さそう その Else 側では、上記に加え、件名,発生日が "#" & Me.発生日 & "#,'" & Me.件名 で逆　とか また、「追加」の最後の方で MycnnrstDst.AddNew してますが、この後どうなるのでしょう 変数の宣言部分（ Dim なんチャラ ）がないので、他の処理で使っているのかもしれませんが・・・ MycnnrstDst.Close しないまま、また MycnnrstDst.Open するとエラーになったような （実際には　Set MycnnrstDst = New ADODB.Recordset　しているので大丈夫かと思いますが、Close は必要な気がします） 「修正」時の方では、 > Me.入力日 & "#, " & "' " ここは、Me.入力日 & "# "　で良さそうなんですが
VBのバージョンがわかりませんが・・・ （VBAも該当しますし） まぁ、それは別として。 ComboBoxに以下のアイテムが入っていると仮定した場合。 あ ListIndex=「0」 い ListIndex=「1」 う ListIndex=「2」 え ListIndex=「3」 お ListIndex=「4」 インデックスではなくアイテムの文字そのものを取得するのですよね？ VB6の場合 「Combo1.ListIndex」で選択されているインデックスが取得できます。 で、今回はインデックスではなくリスト（アイテム）を取得するので、 「Combo1.List」にインデックスを渡してやれば選択項目の文字列が取得できます ですから、「Combo1.List(Combo1.ListIndex)」となります。 VB2008などの場合 VB6以降は選択されたアイテムを直接取得できるので、 「ComboBox1.SelectedItem」で取得できます。 確かこういう感じだったかな。 最近さわっていないのでうろ覚えです。
http://oshiete.goo.ne.jp/qa/8145552.html ↑のベストアンサーのコードの…… For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row ↓ For i = 3 To Cells(Rows.Count, 1).End(xlUp).Row 少しは回答されたコードを理解しようとしましょう。
sum += Integer.Parse(CType(Me.Controls("tb" + (cnt + (rows * columns * (k - 1))).ToString()), TextBox).Text) カッコの閉じる位置が問題だったのですよ。 知恵袋の質問が削除されているので ２つ目の方と合わせて既に解決したみたいですね。
>Button1を押さないで とありましたので、フォームのクローズが呼ばれた際に、Button1_Clickと同等の処理を行えばよいと思いました。 そうすると、2つ該当するイベントがありますので、どちらか適切なイベントで実行して下さい。 という回答になります。フラグを更新するだけならばClosingでも良いのかな、と思います。
　ずっと先の時間まで非常に多数のOntime予約されている途中でエラーになったのなら そのようなことが起こりえます。 　中断するときはその時点より後の予約をすべてキャンセルしておかねばなりません。 キャンセル方法がわからない場合はエクセルを閉じてしまうのが簡単です。
＃２、３、ｃｊです。 私の方にも見落としがあったこともあって （＃３のコードは私の見当違いだと気が付きました） ますます、混乱してしまいましたので、 原点に戻って、ご提示のコードに書き加えることだけで レスしてみます。 ＃３の方は、まだ、手を付けていなければ、試さなくていいです。 すみません。 Private Sub CommandButton1_Click() 　　If setIn Is Nothing Then Set setIn = ActiveCell 　　Select Case データ入力.Caption 　　Case "コード　入　力" 　　　　cnt_A + 1 　　　　setIn(cnt_A, 1).Value = Sample_No.Text 　　　　Sentaku_Koumoku.Value = "" 　　Case "A　入　力" 　　　　cnt_A = cnt_A + 1 　　　　setIn(cnt_A, 2).Value = Sentaku_Koumoku.Text 　　　　Sentaku_Koumoku.Value = setIn(cnt_A + 1, 2).Text 　　Case "B　入　力" 　　　　cnt_A = cnt_A + 1 　　　　setIn(cnt_A, 3).Value = Sentaku_Koumoku.Text 　　　　Sentaku_Koumoku.Value = setIn(cnt_A + 1, 3).Text 　　End Select 　　Sample_No.Value = setIn(cnt_A + 1, 1).Value End Sub > cnt_A = cnt_A + 1 修正対象レコードのインデックスをひとつずつ送る、 というのは理解できました。 > 上から下へのベタ打ち ということですから シート上では「ひとつ下のセル」という意味ですよね？ > With setＩn(cnt_A) これでは 「ひとつ右のセル」→「ふたつ右のセル」 という意味になってしまうので、修正してます。 　　Sample_No.Value = setIn(cnt_A + 1, 1).Value Sample_Noは、単純に一つ下のセル値を採ればいいのだと思います。 　　　　Sentaku_Koumoku.Value = setIn(cnt_A + 1, 2).Text これで、次のレコードに該当するセル値を表示します。 　　　　Sentaku_Koumoku.Value = "" "コード　入　力"モードの場合に、 Sentaku_Koumokuに何を表示するのか判らないので空欄にしています。 以上、これも、可能性が高そうなニーズへの暫定回答です。 （動作は確認していますが、ニーズが確認出来ていません） もしこれで、うまく行かない場合は、 UserForm全体のコードとデザイン、シートのイメージ、の詳細、システム概要 などを添える形で、新たに質問を建ててみてください。 UserFormや他のコントロールのイベントで処理するのが妥当と 思われる内容をコマンドボタンのイベントで処理しているような気がします。 ただ、この回答のコードは、当たらずも遠からず、と思ってレスしていますので、 相違の説明補足あれば対応します。 以上です。
ちょっとどう答えたらいいのか悩む。 どうしたいのか具体的に書いてないので勝手な想像で書きます。 「日付をリストボックスに追加したい」とのことなので "2013/06/24" のような年月日タイプの日付を日付レベルでリストボックスに表示させてみる。 「2013年から始まり、2014年、2015年となるごとに自動で追加されていく」 とあるが、「いつからいつまで」の日付を表示させたいのかがまったくわからないので「今日の日付から 1年分の日付」つまり約 365個の日付をリストボックスに表示させる。 フォームにリストボックスを追加し、名前を listbox1 とした。 フォームが呼び出された時、つまり Load イベントでリストボックスに日付を追加する。 Private Sub Form_Load() 　　Me.listbox0.RowSourceType = "Value List" ' リストボックスの値集合タイプを "値リスト" にする 　　Dim currentDate As Date 　　Dim endDate As Date 　　currentDate = Date ' 今日の日付 　　endDate = DateAdd("yyyy", 1, currentDate) - 1 ' 今日の日付から 1年後の 1日前の日付 　　Do Until currentDate > endDate 　　　　Me.listbox0.AddItem currentDate ' 1日分ずつリストボックスに追加 　　　　currentDate = currentDate + 1 　　Loop End Sub もし仮に 「今年の 1月1日から 1年分の日付」 というのであれば以下のようにする。 currentDate = DateSerial(Year(Date), 1, 1) すべて勝手な想像なので外しまくっている可能性が大きいけど・・・
＞Sleep(1000)の間は止められなくても，For～Next間でどうして止められないのかと思いました。 Loop処理中は、それだけに専念するので他の処理を受付けないからです。 フラグとDoEvents()を使って中止させる例です。 private ExitFlag As Boolean = False 'ボタンのClockイベント Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) ExitFlag = True End Sub ' Forの処理の部分 ' For I=1 to 100 System.Threading.Thread.Sleep(1000) Application.DoEvents()'他のWindows操作を可能にするため If ExitFlag Then Exit For Next
No.2です。 ＞10行目の行全体に罫線が引かれるようコーディング頂けると大変助かります。 とありましたので・・・ 本来であればデータがない列まで罫線は必要ないであろうと思い データが入っている最終列を取得して、そこまでの列に罫線を引くようにしていました。 ご希望はデータがあるなしに関わらず最終列（Excel2003の場合はIV列）まで罫線を引きたい！ というコトですね！ ↓のコードに変更してみてくささい。 Sub Sample2() Dim i As Long, cnt As Long, c As Range Application.ScreenUpdating = False For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row Set c = Rows(i).Find(what:="×", LookIn:=xlValues, lookat:=xlPart) If c Is Nothing Then cnt = cnt + 1 If cnt = 10 Then With Rows(i).Borders(xlEdgeBottom) .LineStyle = xlContinuous .Weight = xlMedium End With cnt = 0 End If End If Next i Application.ScreenUpdating = True End Sub 今度はどうでしょうか？m(_ _)m
exeファイルと同じディレクトリ配下に置くのが適切だと思います。 但し、起動時、通常カレントディレクトリーは、exeファイルの存在するフォルダーですが、OpenFileDialog（ファイルを開くダイヤログ）等を使用すると、カレントディレクトリーが変化します。 結論として、exeファイルと同じディレクトリーに設定ファイルを置いた上で、設定ファイル読み込み時は、次の様にして読む込むと安全に読み込めます。 Application.StartupPath & "\設定ファイル.xxx" 何かの参考になれば幸いです。
空白ではない～何か文字が入力されている場合のVBAは、以下になります。 If a1 <> "" Then f = f or 1
印刷に関しては、下記のサイトにサンプルがたくさんあります。 すべて英語ですが、ソースコードは動くものもあります。 （VB6のものはだめです）　C#とかは、こんばーどすればVBにできます http://www.codeproject.com/
まずはじめに、全ての各プルダウンリスト用のデータに名前（野菜や果物）を付けます。 （プルダウンデータ範囲を選んで右クリックして範囲に名前を付けるをクリック） A２セルに「野菜」と記載されているとして、 B2セルをクリックし、データの入力規則をクリックし、設定タグで入力値の種類の欄をリストにし、元の値の欄に、 =INDIRECT(A2) と記載して、下にドラッグしてみてください。
＃１、２、３、ｃｊです。 ＃１補足欄へのレスです。 > 上記のように入力してみましたが、エラーが出てしまいます。 ＃１に関しては、フィルターOffの状態で実行すると 　実行時エラー　' 1004 　Worksheet クラスの ShowAlldata メソッドが失敗しました。 というエラーになります。 （このこともあって、＃２、３、で改善をしています。） それ以外で、どんなエラーが出るのか想像できなかったので、 実際にExcel2003環境をお借りして２時間ほどエラーを出すように テストしましたが、私にはエラーを出す方法が解りませんでした。 Excel2003よりも旧い環境で作成されたファイルで フィルターOnのまま保存されたものならば、特定の条件下で エラーを出すことは出来そうですが、試す環境がありません。 ただ、この場合は解決策として、 　シート保護解除→オートフィルタを削除→保存→ブックを閉じる→再度開く 　オートフィルタを再設定→シート保護を再設定 という手順でトラブル回避できる筈です。 それ以外に、オートフィルターの破断した一時ファイルが Tempフォルダに残っている場合も考えられます。 その場合は、Tempフォルダを掃除すれば トラブルが解消される可能性は高いです。 他、私の経験的な知識と想像力が足りないだけで、 トラブルを抱えていないファイルでもエラーを出す 方法があるのかも知れませんが、 限られた情報から導けるものには限界があります。 /// ＞ ... そして、 Sub すべて表示() On Error Resume Next ActiveSheet.ShowAllData End Sub のように入力すると実行できるんですが、 シート保護をかけると実行できません。 エラーはでないんですが。。。 ＜ 今回の課題では、 On Error Resume Next は使わない方がいいです。 エラーを無視して次に進むだけですから、 無論エラーダイアログは表示されませんが、 エラーが出ていない、という意味ではありません。 /// さて、困りましたね。 そちらで、出来ること、を最後に書いておきます。 エラーになる原因が何であれ、 試しに、新しいブックを（ここで説明されている範囲の設定だけで）作成して、 エラーが出ない状況を確認して、 エラーが出るブックとエラーが出ないブックとで、何が違うか 原因を探ってみる、とか、ですかね。 もし、 こちらでもエラーを再現できる程度に情報が揃ったなら、 具体的な手当てをアドバイスできるだろうと思います。 または、 具体的にどの記述のどの部分でどんなエラーが発生するのか、解ったなら、 今よりは原因を推定できる可能性は高まります。 マクロで対応する、のが好いとは思いますが、 それを難しくしている原因が見当たらない、ということです。 ひとまず、何かお気づきのことでもあれば、また補足してみてください。
こういった場合は、無理にデータのシートを変更せずに 別途、シートを使ったほうが良いです。 例 別途、テンポラリ　ちいうシート名のシートを準備していて Sub ボタン1_Click() With Sheets("テンポタリ") For i = 1 To Range("D" & Rows.Count).End(xlUp).Row If i = Int(i / 2) * 2 Then .Range("E" & Int(i / 2)).Value = Range("D" & i).Value Else .Range("D" & Int(i / 2) + 1).Value = Range("D" & i).Value End If Next End With End Sub を実行します。 ご希望通りになったら、元シートを削除してもよいですし 残しておくのも何らかの場合に役に立つこともあるでしょう。 元データのシートを残しておくなら 抽出する別シートの　 D列に　=INDEX(データシート!D:D,ROW()*2-1)&"" E列に　=INDEX(データシート!D:D,ROW()*2)&"" と入れて下までコピーしておくだけでも良いと思います。
SQLビューに以下を記述してみます。 SELECT 名前, Sum(IIF(成績=80,1,0)) AS 80の件数, Sum(IIF(成績=60,1,0)) AS 60の件数 FROM テーブル GROUP BY 名前; 名前='やまだ'　に限定するのであれば SELECT 名前, Sum(IIF(成績=80,1,0)) AS 80の件数, Sum(IIF(成績=60,1,0)) AS 60の件数 FROM テーブル WHERE 名前='やまだ' GROUP BY 名前; Sum（合計）を使って、成績 = ○○なら 1 でなければ 0 を IIF で判別すると件数に ※ 不都合あれば修正してください
以下は、32ビット版と64ビット版の機能の制限を説明し、どちらを利用すべきかの判断材料を提供している資料です。 http://office.microsoft.com/ja-jp/excel-help/HA0 … Microsoftは、64bit版のOfficeに対してComctl（ListViewなどのコントロールを提供する機能）に対する適切な代替手段を提供していません。 職場のほとんどのListViewが利用できるパソコンが32Bit版であるということでしょう。
英語の情報ですが... http://scn.sap.com/thread/1445453 英語が苦手なので、間違っていたらゴメンなさい。 「レポートを開く，データソースの変更，データ追加のいずれかに問題がある」 「-crpetrace 7オプションをコマンドラインに追加して、クリスタルレポートのトレースを取得することができる」 ※ あまり参考にならないかもしれません。
ん？ > ユーザーフォーム内のテキストボックスになります。 なるほど。 それは主に仕様の関係で残念ながら無理です。
XMLの規定文字コードはUTF-8なので、 VBAで文字列として扱うと字化けします。 方法としては二通りあり、一つは元の ファイルをSJISにしてencoding属性で Shift_JIS宣言します。もう一つは内部で UTF-8からSHIFT_JISに変換する方法です。 入力ファイルを加工してよいなら前者の方が 分かり易いでしょう。入力ファイルの加工が 難しい場合は後者になります。 尚、出力ファイルにencoding属性を指定しない 場合は、置換後にSHIFT_JISからUTF-8への 変換が必要です。 先ず、入力ファイルの1行目を見てください。 <?xml version="1.0"?> このようにencoding属性がなければUTF-8です。 SJISなら以下のように文字コードが指定されて います。 <?xml version="1.0" encoding="SHIFT_JIS"?> XMLの基本なので、よく注意してください。 どちらの方法をとるかで話が変わってきますので、 先ずは状況を補足して下さい。
こんばんは！ ＞ボタンを押せば並べ替えできるようにできますでしょうか というコトですので、Sheet上にコマンドボタンを挿入したとしての一例です。 尚、データはA1セルからあるとします。 Private Sub CommandButton1_Click() Range("A1").CurrentRegion.Sort key1:=Range("A1"), order1:=xlAscending, Header:=xlNo, _ key2:=Range("B1"), order1:=xlAscending, Header:=xlNo End Sub ※　タイトル行がある場合は当然コードも変わってきます。m(_ _)m
＃直接の回答にはなっていないでしょうから、ご要望から離れておりましたら、スルーなさってください。 ＞xmlファイルの全要素・全属性を読み込み、 ＞Excelに書き出したい 　[XML ファイル] でしたら、お示しのような面倒くさいコードを使わなくても、エクセルの標準機能で行った方が簡単ではありませんか？ 　「書き出した」後の閲覧もビジブルですし。。。 Sub Macro1() 　　ActiveWorkbook.XmlImport URL:= _ 　　　　"C:\Users\harada\Desktop\problem_info取り込み\problem_info.xml", _ 　　　　ImportMap:=Nothing, Overwrite:=True, Destination:=Range("$A$1") End Sub
こんにちは。お邪魔します。 MSForms.TextBoxには、 フォント設定を部分的に変更する機能は用意されていません。 無論、テキストの一部を行として指定することも出来ません。 なので、代替え案を検討された方がいいです。 ＃私が実際にテストしていたのもend-uさんと同趣旨のものだったりしたのですが 　直接の回答としてはNo.1のご回答で十分だと思います。 私が気になったのは、 　実際にやりたいこと、 と、 　TextBoxの扱いを含めた全体の設計 が 　目的に合ったものになっているか、 ということです。 ＃ TextBox で改行しながら手入力って個人的に違和感があるもので、、、。 ご提示のコードに出てくる TextBox12 というのは、 ■手作業での入力（編集）に用いているものなのでしょうか？■ もしも、 ■ただ単に表示させる目的だけでTextBox12を用いているなら■ 目的に合ったツール選びが出来ていないのかも知れません。 また、 ■取り消し線でなければいけないのでしょうか？■ ■"１行目"にあたるテキストの一部だけを他とは差別して表示する■ ということで足りるとか？ 例えば、表示だけが必要で手入力はしないのなら、 WebBrowserコントロールを使う方法が妥当に思います。 加えて、取り消し線である必要がないなら、 ListBoxコントロール（.ListStyle=1）を使うのが簡便でしょう。 手入力をするのなら、必要な項目（行）の数だけ TextBox を 縦に隣接させて並べるのが現実的だと思います。 ＃一昔前ならRichTextBoxコントロールとか Office Web Components SpreadSheetとかで容易に解決できたのですが、 現在は使えないようですので。 　 　 ご自身で目的を明確にして設計を見直すことから、あらためてチャレンジしてみてください。
Excel から取り込む際 ・重複・・・これはIDで、Excelデータ内には重複したIDは存在しない ・前に取り込んだものも、まだ Excel にデータとして入っている Excel の１行目には、テーブルのフィールド名と同じ項目が設定されている・・・ テーブル名を「T3」 これを条件に、以下を記述し実行してみます。 Public Sub testImport() 　　Dim sSql As String 　　sSql = "UPDATE T3 RIGHT JOIN [Excel 8.0;HDR=YES;IMEX=1;DATABASE={%2}].[{%1}] AS Q1 " _ 　　　　　　& "ON T3.ID = Q1.ID SET T3.ID = Q1.ID, T3.氏名=Q1.氏名 " _ 　　　　　　& "WHERE T3.ID Is Null;" 　　sSql = Replace(sSql, "{%1}", "Sheet1$") ' 対象のシート名 + $ 　　sSql = Replace(sSql, "{%2}", "E:\Excel\hogege\hogehoge.xls") ' 対象ファイルのパス 　　CurrentProject.Connection.Execute sSql End Sub これは、テーブル「T3」の「ID」と、Excel ファイル hogehoge.xls の Sheet1 のIDとを 外部結合して、（Excel側全部とT3にあったら）その結果 T3.ID が Null であれば、 Excel側にしか存在しないものになるので、ID、氏名を設定するものになります。 ※ ID に変更はなく、氏名が変わる事があれば 　WHERE T3.ID Is Null 部分を削除することで対応できると思います。 なお、上記では UPDATE 文を使いましたが、INSERT に変更しても良いかも 未検証ですが、雰囲気以下の様な感じで INSERT INTO T3(ID, 氏名） SELECT ID, 氏名 FROM [Sheet1$] IN 'E:\Excel\hogege\hogehoge.xls'[Excel 8.0;HDR=YES;IMEX=1;] WHERE NOT EXISTS (SELECT 1 FROM T3 WHERE ID=[Sheet1$].ID); ここでは EXISTS を使ってみましたが、前述の様に外部結合を使っても良いかも 提示のあった記述で対応するとすれば、 ・ On Error Resume Next でエラーを無視する ・ On Error GoTo ERR_HND として、 ERR_HND 部分でエラー番号を判別し 　　重複・・・なら UpdateCancel してから Resume Next するとか IDが重複した場合でも、氏名を更新したい・・・であれば、未検証ですが以下の様な雰囲気 （ ID は数値型とした場合 ） 　　rs.Open "テーブル", CurrentProject.Connection, adOpenStatic, adLockOptimistic 　　iRow = 2 　　While (ループ) 　　　　rs.Filter = "ID=" & oApp.Cells(iRow, 1) 　　　　If (rs.EOF) Then 　　　　　　rs.AddNew 　　　　　　rs("ID") = oApp.Cells(iRow, 1) 　　　　End If 　　　　rs("名前") = oApp.Cells(iRow, 2) 　　　　rs.Update 　　　　iRow = iRow + 1 　　Wend Filter で ID が存在するか絞り込んでから、なかったら AddNew Filter を使ってますが、遅かったら・・・ Find にしてみるとか・・・・ 参考にする/しないは、自己責任にてお願いします。
クエリ「Q2」の内容が以下になっていると仮定します。（「番号」は数値型 ） SELECT * FROM テーブルA WHERE 番号=[数字入力]; このクエリを開くと「数字入力」が表示され、入力すると抽出結果が表示されます。 以下を VBA で記述し実行してみます。 Public Sub testDAO() 　　Dim rs As DAO.Recordset 　　Dim i As Long 　　With CurrentDb.QueryDefs("Q2") 　　　　.Parameters("[数字入力]") = 1 　　　　Set rs = .OpenRecordset 　　End With 　　If (Not rs.EOF) Then 　　　　With CreateObject("Excel.Application") 　　　　　　.WorkBooks.Add 　　　　　　With .Range("A1") 　　　　　　　　For i = 0 To rs.Fields.Count - 1 　　　　　　　　　　.Offset(, i) = rs(i).Name 　　　　　　　　Next 　　　　　　　　.Offset(1).CopyFromRecordset rs 　　　　　　End With 　　　　　　.Visible = True 　　　　End With 　　End If 　　rs.Close 　　Set rs = Nothing End Sub Public Sub testADO() 　　Dim rs As ADODB.Recordset 　　Dim cat As New ADOX.Catalog 　　Dim i As Long 　　cat.ActiveConnection = CurrentProject.Connection 　　With cat.Procedures("Q2").Command 　　　　.Parameters("[数字入力]") = 1 　　　　Set rs = .Execute 　　End With 　　If (Not rs.EOF) Then 　　　　With CreateObject("Excel.Application") 　　　　　　.WorkBooks.Add 　　　　　　With .Range("A1") 　　　　　　　　For i = 0 To rs.Fields.Count - 1 　　　　　　　　　　.Offset(, i) = rs(i).Name 　　　　　　　　Next 　　　　　　　　.Offset(1).CopyFromRecordset rs 　　　　　　End With 　　　　　　.Visible = True 　　　　End With 　　End If 　　rs.Close 　　Set rs = Nothing End Sub 前者がDAO、後者がADO 直接 Excel を起動し、新規 Book に抽出結果を転記して表示するまでです。 後は、 　.Parameters("[数字入力]") = 1 部分の値を、関数のパラメータにして受け渡しするとか・・・ フォームに入力した値を参照する様にするとか・・・・ ※ .Offset(1).CopyFromRecordset rs　でデータを転記してますが、 書式がチョッと・・・ってな場合には、 先に書式を設定してから CopyFromRecordset してみたりします。 ※ DoCmd.TransferSpreadsheet を使いたい場合は、 「数字入力」部分をフォームで作成しておいて、 クエリではそのフォームを参照するようにします。（未検証） 参考にする/しないは、自己責任にてお願いします。
テキストボックスの内容が「4」のときは 　cmd /c @echo 4>> aaa.txt というコマンドが実行されることになり、 4という数字がファイルディスクリプタ番号だと判断されます。 　cmd /c @echo 4 >> aaa.txt というコマンドが実行されるように直してみてください。
本来は、どのようなエラーを想定しているか、によって 答えは違ってくると思いますが、、、 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝ ・・・ Exit Sub ErrorHandler: ～～処理 End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝ のようにするのが一般的です。 > 特に問題が無ければ、ErrorHanderを飛び越えてend subに行くと思っていたのですが、認識が違うのでしょうか？ 飛び越えません。 以上です。
関数の宣言 http://homepage1.nifty.com/rucio/main/dotnet/Sam … Private Function　で呼び出す任意の関数の事とは違う？
日付値としての判断は 「フォルダー名が 8文字であり、なおかつ IsDate で日付値として評価できる」 という条件にした。 DateSerial で日付書式を作成すると 20130631 も 2013年7月1日になってしまうため手動で日付書式を生成した。 これにより 20130631 は "日付値ではない" と判断する。 フォルダーの一覧取得や削除は FileSystemObject を使用した。 日付値どうしの大小比較を行うため、フォルダー名を ADODB Recordset オブジェクトに格納し、Recordset のソート メソッドを使用した。 ' 日付形式のフォルダー名を格納する ADODB Recordset Dim rs Set rs = CreateObject("ADODB.Recordset") Call rs.Fields.Append("FolderName", 3) ' フォルダー名 (数値) Call rs.Fields.Append("FolderSpec", 130, 1000) ' フルパス 文字列 1000文字 Call rs.Open() ' 名前が 8文字で、日付値として評価できるフォルダーを Recoreset に取り込む Dim fso, f Set fso = CreateObject("Scripting.FileSystemObject") For Each f In fso.GetFolder("D:\test").SubFolders 　If Len(f.Name) = 8 Then 　　If IsDate(Left(f.Name, 4) & "/" & Mid(f.Name, 5, 2) & "/" & Mid(f.Name, 7, 2)) Then 　　　Call rs.AddNew() 　　　rs.Fields("FolderName").Value = f.Name 　　　rs.Fields("FolderSpec").Value = f.Path 　　　Call rs.Update() 　　End If 　End If Next ' 一番大きな日付値が先頭に来るように降順でソートする rs.Sort = "FolderName DESC" ' 候補フォルダーが 2個以上あれば 2個目以降のフォルダーを削除する If rs.RecordCount >= 2 Then 　Call rs.Move(1) ' 2個目のレコードに進む 　Do Until rs.EOF 　　fso.DeleteFolder(rs.Fields("FolderSpec").Value) 　　rs.MoveNext 　Loop End If Call rs.Close()
こんにちは。お邪魔します。 まず、誤解されている方が非常に多いので説明しておきますが、 csvファイルといっても一様に統一された規格がある訳ではなくて、 殆どローカルルールで運用されるものです。 （共通語を持たない方言に喩えられることが多いですが、 　言語で喩えるなら"ヨーロッパ語"ほどの曖昧さを持ったものです 　つまり、通じない、場面が容易に想像できる"csv"なのです） 　　引用符の扱い、 　　引用符（で挟む単セル）内のカンマの扱い、 　　引用符（で挟む単セル）内の改行の扱い、 　　引用符（で挟む単セル）内の引用符の扱い、 等、確認できないと、テキストデータとして編集することは不可能です。 "csv'に'出力する" とか "csvデータ'に'出力する" という言葉通りだと、 一般には「テキストデータとして編集した後、テキストファイルを出力する」 という意味になるのだと思いますが、 その場合は、ローカルルールを詳細に説明しておかないと 誰にも手が付けられない質問ということになってしまいます。 「Excelシートの一部をcsv形式で保存する」 ということだと、似ているようでも全然意味が違っていて、 Excelのcsv保存の機能を使って（Excelのcsv保存の仕様に合わせて） ファイルを作成する、とうことになります。 その場合のサンプルを以下挙げてみます。 行区間指定の一例として対話型で書いてあります。 「★」の行までの記述は専ら、 先頭行（nTop）最終行（nBtm）を決める為の記述です。 「シート名 要 指定 ■」の部分は、 運用に合わせて正しいシート名を指定してください。 Sub Re8138672() Const 出力行数初期設定 As Long = 3000 ' 指定変更可 □ Dim rtn Dim sFn As String Dim nTop As Long Dim nBtm As Long With Sheets("Sheet1") ' シート名 要 指定 ■ With .UsedRange nTop = .Row nBtm = .Rows(.Rows.Count).Row End With rtn = Application.InputBox(Prompt:="出力する範囲の先頭行を数字で指定" _ & vbLf & vbLf & "先頭行 ↓", _ Title:="csv出力：行指定１", Default:=nTop, Type:=1) If rtn <> "False" Then nTop = rtn Else Exit Sub End If If nBtm > nTop + 出力行数初期設定 - 1 Then nBtm = nTop + 出力行数初期設定 - 1 rtn = Application.InputBox(Prompt:="出力する範囲の最終行を数字で指定" _ & vbLf & vbLf & "先頭行 ： " & nTop _ & vbLf & "最終行 ↓", _ Title:="csv出力：行指定２", Default:=nBtm, Type:=1) If rtn <> "False" Then nBtm = rtn Else Exit Sub End If ' ' ★ sFn = "Title_" & nTop & "―" & nBtm & ".csv" Application.ScreenUpdating = False Application.DisplayAlerts = False .Rows(nTop & ":" & nBtm).Copy Destination:=Workbooks.Add.Sheets(1).Cells(1) End With ActiveSheet.SaveAs Filename:=sFn, FileFormat:=xlCSV ActiveWorkbook.Close False Application.DisplayAlerts = True Application.ScreenUpdating = True MsgBox Prompt:="以下のファイル名でcsvファイルを出力しました" _ & vbLf & vbTab & sFn, _ Buttons:=vbInformation, Title:="csv出力：完了" End Sub
Ｎｏ１です。 ＞msgbox(dmy = "aaa")だとFalseが返ってきます。 ＞しかし、msgbox(dmy)で、aaaと表示されます。 余計な文字があるんでしょうね。 ＞Case dmy.indexof("aaa") > -1でもダメでした。 Select case trueも変更しているんですよね？ あとは Case dmy.indexof("aaa") >= 0 こっちの方が良いのかな？
伝統的なBASICは「フロー駆動型プログラミング」で VisualBASICは「イベント駆動型プログラミング」である というのが一番大きな違いじゃないでしょうかね。 まあVisualBASICは、イベント駆動型プログラミング言語の開発ありきで、それにBASICのコマンド体系を割り当てたというのが正しいように思いますけど。
64ビットWindows8を前提に回答します。 外していたらOSの情報を記載すると、回答が得られやすくなると思います。 http://ja.wikipedia.org/wiki/WOW64 こういうものは関係しますでしょうか？ であれば、ocxはSysWOW64フォルダに格納することになります。 32ビットアプリケーションからSystem32フォルダを参照すると、SysWOW64へリダイレクトする仕組みになっているため、System32フォルダに格納したファイルを見つけられない、ということになります。 わかりづらいのですが、System32フォルダには64ビット版のバイナリが格納されています。 外していたらすみませんが明記がないので回答いたします。
クリップボードは使えないので ユーザーフォームを用いた案。 Ｘにユーザーフォームを作成して CommandＢｕｔｔｏｎ１と２を配置。 Private r As Range Private Sub CommandButton1_Click() Set r = Selection End Sub Private Sub CommandButton2_Click() r.Copy ActiveCell End Sub 上記をユーザーフォームのモジュールに。 Sub try() UserForm1.Show 0 End Sub 上記を標準モジュールに。 (1)手動で、Xの任意の連続したセルを選択してマクロ：tryを実行しＣｏｍｍａｎｄＢｕｔｔｏｎ１を押す。 (2)Yに移動して、貼り付けしたいセルを選択しＣｏｍｍａｎｄＢｕｔｔｏｎ２を押す。 (3)(1)で取得したデータをペーストされる
>>.Parameters("ID") = rs.Fields("idx").Value >>で満たせるでしょうか? 　　試してませんけど、それでいけると思いますよっ。なんでもまずやってみることが大切と思いますよっ(^^)b がんばってくださいませm(__)m　また、つまずいたら、質問してください。
質問文をそのままマクロにすると以下の様になりますけど、[Ctrl]+[V]で済むことをマクロで行う理由はなんでしょう。 あ、VBEのツール→参照で、「Microsoft Forms 2.0 Object Library」（C:\Windows\System32\FM20.DLL）を参照設定しておいてください。 Sub Sample() 　　Dim CBD As New DataObject 　　With CBD 　　　　.GetFromClipboard 　　　　If .GetFormat(1) = False Then 　　　　　　MsgBox ("コピーしていません") 　　　　　　Exit Sub 　　　　End If 　　　　ActiveSheet.Paste 　　End With End Sub
Dim ws As Worksheet, i& は、VBAでは Dim ws As Worksheet, i As Long と同じ意味です。 Basic系の言語の古くからの慣習の一つですね。 参考URL：http://www.eonet.ne.jp/~myexcel/vba2/VbaPrg03.htm
以下ではどうですか。一応、ボタンクリックの イベントで対応しています。 いくつか余分な処理をコメントアウトしていれてますが、 何かの参考にしてください。 それと、メッセージボックスが出るようになっていますが、 実際の時には必要なければコメントアウトするなり、 消すなりしてください。 （クエリを表示する方法はわかりますよね。） Private Sub コマンド0_Click() 'テキスト1にデータが入力されている場合 If Not IsNull(Me!テキスト1) Then 　　'テキスト2にデータがありテキスト3にデータがない場合 　　If Not IsNull(Me!テキスト2) And IsNull(Me!テキスト3) Then 　　　　MsgBox "クエリ2を出力します。" 　　　　'クエリ2を表示する処理をいれてください。たとえば、以下のように 　　　　'DoCmd.OpenQuery "クエリ2" 　　End If 　　'テキスト2にデータがなく、テキスト3にデータがある場合 　　If IsNull(Me!テキスト2) And Not IsNull(Me!テキスト3) Then 　　　　MsgBox "クエリ3を出力します" 　　　　'クエリ3を表示する処理をいれてください。たとえば、以下のように 　　　　'DoCmd.OpenQuery "クエリ3" 　　End If '　　'テキスト2とテキスト3の両方にデータがある場合 '　　If Not IsNull(Me!テキスト2) And Not IsNull(Me!テキスト3) Then '　　　　MsgBox "両方ゲット" '　　　　'何か適当な処理 '　　End If '　　'テキスト2もテキスト3もデータがない場合 '　　If IsNull(Me!テキスト2) And IsNull(Me!テキスト3) Then '　　　　MsgBox "両方なし" '　　　　'何か適当な処理 '　　End If 'テキスト1にデータが入力されていない場合 Else 　　MsgBox "出なしてください" End If End Sub ところで、表示したクエリのエクスポートはOffice Linksで Excelなりに出力するということでいいのでしょうか？ それとも・・・・・・・直接・・・・・・・？いや何でもありません。
> 別のシートからセルをセルをコピーして順番に入れていくのですが、 > 指定された数だけしか入力できないのです。 > 例）　５の場合、A2まで　以降ブランク > 　　１２の場合、B3まで　以降ブランク ますます何がしたいのか解りません。 説明が出来ないのなら、せめて例をもっと具体的かつ詳細に提示してください。 元データが別シートのどこにどう有って、元シートのデータをどういう順番でどこに貼り付けたいと言う感じで……。
とりあえず「VBA　セル　コピー」でググるとか「マクロの記録」機能を使うとかしてください。 ちなみに、値だけコピーできれば良いなら Workbooks(ExcelB).Sheets(該当シート）.Range(貼り付け範囲) = Workbooks(ExcelA).Sheets(該当シート）.Range(コピー範囲) だけでもできます。 何故か「小ネタ」や「裏技」系のサイトでしか紹介されてませんが。
VB6から.NETに焼き直すときにはよくある話です……。 .NETでは文字列はUnicodeで管理されているため、 ANSIで文字列を扱うAPIをそのまま呼び出すと引数の内容が壊れたりします。 こちらのリンクを参考になさってください。 http://www5b.biglobe.ne.jp/~yone-ken/VBNET/speci …
こんばんは！ range（セル番地）.Formula = "=IF(AK3554>0,""○"",IF(AK3554<0,""▽"",""□""))" のようにしてみてはどうでしょうか？ ※　通常のワークシート関数がそのまま利用できますが、 文字列の場合はダブルクォーテーションがダブルで必要です。m(_ _)m
　　private void treeView1_MouseMove(object sender, MouseEventArgs e) 　　{ 　　　　TreeNode clickedNode = treeView1.GetNodeAt(e.X, e.Y); 　　　　if (e.Button == MouseButtons.Left && allowLine == false) 　　　　{ 　　　　　　allowLine = true; 　　　　　　if (this.VisibleDraggedNodeLabel == true) 　　　　　　{ 　　　　　　　　motionLabel.Visible = true; 　　　　　　} 　　　　　　 　　　　} 　　　　if (allowLine == true) 　　　　{ 　　　　　　//motionLabel.Location = Cursor.Position; 　　　　　　Point client = treeView1.PointToClient(Cursor.Position); 　　　　　　 　　　　　　if (clickedNode != null && this.VisibleDraggedNodeLabel==true) 　　　　　　{ 　　　　　　　　motionLabel.Location = new Point(treeView1.Bounds.X+clickedNode.Bounds.X+(clickedNode.Bounds.Width/2), 　　　　　　　　　　treeView1.Bounds.Y+clickedNode.Bounds.Y+(clickedNode.Bounds.Height/2)); 　　　　　　} 　　　　　　treeView1.Invalidate(); 　　　　} 　　} } TreeViewクラス、TreeNodeクラス、TreeNode.DrawModeプロパティのヘルプを参考になさってください。
setSelectedFlgメソッドの中身が載せられていないので詳しいことはわかりませんが……。 VB.NET側ではshowMessageという名前の関数になっているので 　Panel1.showMessage(true); とすればよい気がしますが、いかがでしょうか。
この辺りかなと。 http://hanatyan.sakura.ne.jp/patio/read.cgi?no=310 http://hanatyan.sakura.ne.jp/patio/read.cgi?no=311
こんばんは！ 横からお邪魔します。 データは１行目からあるとします。 No.１さんと全く同じやり方になりますが・・・ Sub Sample1() Dim endRow As Long Application.ScreenUpdating = False Cells(1, 1).CurrentRegion.Sort key1:=Cells(1, 1), order1:=xlAscending, Header:=xlNo endRow = Cells(Rows.Count, 1).End(xlUp).Row Range("A:A").Insert With Range(Cells(1, 1), Cells(endRow, 1)) .Formula = "=COUNTIF(B$1:B1,B1)" .Value = .Value End With Cells(1, 1).CurrentRegion.Sort key1:=Cells(1, 1), order1:=xlAscending, Header:=xlNo Range("A:A").Delete Application.ScreenUpdating = True End Sub こんな感じではどうでしょうか？m(_ _)m
質問文に記載されたコード自体は、 とくに問題等見当たらないように思われます。 # イベント名がChangedなのに値の変化が無くてもイベント発生するとか、細かい点はさておき。 掲載されていない部分のコードで、 ・親側がちゃんとSelectedFlgを意図する値に設定しているか ・setBackColor()の中で、パラメータに渡された色を正しくBackColorに設定しているか などを確認してみてはいかがでしょうか。
for i = 1 to ActiveSheet.ChartObjects.count　で呼び出すとのことしたので 以下の応用編になると思います。 テストには2007を使用しています。 For i = 1 To ThisWorkbook.Charts.Count　'ActiveSheetでも、ThisWorkbookでも With ThisWorkbook.Charts(i) If .HasTitle = False Then　'有無の判定はHasTitleを用いる .HasTitle = True .ChartTitle.Select '2003 対応(フォント設定に必要） .ChartTitle.Text = "noTitle" & i 'この部分を変数に変える End If End With Next i ポイントは上記のコメントを参照してください。
UWSCを使ってみてはいかがでしょう。 キー送信もマウスクリック送信もできます。 （と言いつつ私自身はごく簡単なことしかやったことがないのであまり偉そうなことは言えませんが・・・） 参考URL：http://www.uwsc.info/
たとえばこんなイメージでしょうか。 Dim InsSVal, EndSVal As Integer Dim NewWS As Worksheet InsSVal = Val(InputBox("statval")) EndSVal = Val(InputBox("endval")) For i = InsSVal To EndSVal Worksheets("Sheet1").Copy After:=Worksheets("Sheet3") Set NewWS = ActiveSheet NewWS.Name = "NewSheet" & i Set WS = Nothing Next i シートの追加、削除、コピー http://www.big.or.jp/~seto/vbaref/vbaref7.htm InputBoxではなくて、ApplicationInputboxを使用して、整数型を入力するようにType引数を設定するのがよさそうです。 http://www.eurus.dti.ne.jp/yoneyama/Excel/vba/vb …
対話型だと、SendKeysでタイミングが計れなかったり、入力できないケースが発生して、うまくいかないかもしれません。 コマンドラインの説明書きを参考に示します。 http://sourceforge.jp/projects/winscp/wiki/comma … スクリプトをVBで生成して、それを叩くとか、、方法は考えられそうです。
＃最初にお断わりしておきます。 ＞ここまで親切に対応して下さって誠にありがとうございます。 とのことですが、私は、プロフィールに書いておりますように、「自分自身のパソコンのスキルを向上するためにこちらに参加して」いるのですから、そのようなお気遣いは無用です。 　webdesign254 さんがお尋ねのご質問自体が、汎用性があり、私自身も役に立つときがあるかも知れませんし、また、他の読者の方にとっても、有為な内容になると判断されたから回答させていただきましたが、同じようなご質問でも、ご質問者さん独自の用に特化されたような（汎用性のない）内容でしたら、ここまでの回答はいたしません。 ------------------------------------------------------ 　さて、 ＞A1セルを処理しない の件ですが、これは、 For i = 2 ～～ を For i = 1 ～～ にすればＯＫです。 ------------------------------------------------------ ＞マクロは基礎から知識ゼロ とのことですが、元々のコードと改変されたものの何処が変わったかというようなことを、比較する癖をお付けになったら、処理や操作が変わった原因も分かるようになりますし、そういうところから、スキルがアップするかと存じますので、是非、そういう習慣を付けてください。 　コードの比較の仕方は、 １）エクセルのワークシートＡ列に元々のコードをコピペ ２）Ｂ列に新しいコードをコピペ ３）Ｃ列に「=A1=B1」のような式を入れて、これを最終行までコピー ４）以上で、変わったところの行は、Ｃ列の値が「FALSE」になりますので、何処が変わったのかが一目瞭然となります。 　このヤリカタは、コード自体に行の追加・削除があった場合は、比較が難しくなりますので、ホントは、もっと複雑な式をＣ列に入れるべきですが、取り敢えずは、そのようにして比較するということを覚えてください。 　ちなみに、「複雑な式」というのは、下記です。 =INDIRECT(ADDRESS(ROW(),1))=INDIRECT(ADDRESS(ROW(),2)) ------------------------------------------------------ 　ついでに ＞エラーの詳細が詳しくわかった方が・・・ の件ですが、 ＞のところを、 ＞～～～～～～ ＞このように変更してみました。 とするとお書きなので、ちょっとビックリいたしました。 　そこに羅列された「Case = ～～」の数字の部分ですが、概ねすべてのステータスが網羅されていて、その点についての知識がおありなのだなと思ったのですが、ただ、「200」はいいとしても、「402」が抜けていました。 　で、ここは、ズラ～～っとコードを並べるのではなくて、ほぼ「全て」のステータスを書き出すようにするわけですから、 Select Case .Status ～～～ End Select の部分を、全面的に書き直しましょう。 　つまり、「Case 200 とそれ以外」ということにしてしまえば、コードの記載が下記の２行で済んでしまいます。 Case Else Cells(i, 2).Value = .Status ～～ ------------------------------------------------------ 　ということで、新しいコードは、下記です。 　ただし、 ＞タイムアウトを設定しないまま使用する方がよい とのことですので、関連のコードも削除しました。 '----------------------------------------------------- Sub KeyWord_Search() 　　Dim objHTTP As Object 　　Dim i As Long 　　Const strKW As String = "news" 　　Set objHTTP = CreateObject("Msxml2.ServerXMLHTTP.6.0") 　　With objHTTP 　　　　For i = 1 To Range("A1").End(xlDown).Row 　　　　　　Cells(i, 2).Select 　　　　　　If Cells(i, 2) = "" Then 　　　　　　　　.Open "GET", Cells(i, 1).Value, False 　　　　　　　　On Error Resume Next 　　　　　　　　.Send 　　　　　　　　Select Case .Status 　　　　　　　　　　Case 200 　　　　　　　　　　　　Cells(i, 2).Value = " なし" 　　　　　　　　　　　　If InStr(1, .ResponseText, strKW, 1) > 0 Then Cells(i, 2).Value = " あり" 　　　　　　　　　　Case Else 　　　　　　　　　　　　Cells(i, 2).Value = .Status & ":" & .statusText 　　　　　　　　End Select 　　　　　　　　.Abort 　　　　　　End If 　　　　　　If Err.Number <> 0 Then Cells(i, 2).Value = Err.Description 　　　　　　If Err.Number = -2147483638 Then Cells(i, 2).Value = "タイムアウト" 　　　　　　On Error GoTo 0 　　　　Next 　　End With 　　Set objHTTP = Nothing End Sub
OutlookVBAもそんなに詳しいわけではないですが試してみた感じだと以下のような。 Option Explicit Private Sub Application_ItemSend(ByVal Item As Object, Cancel As Boolean) 　　Dim objRec As Recipient 　　Dim strCC　As String 　　Dim strMsg As String 　　Dim s　　　As String　　　 '■変数追加 　　Dim a　　　As AddressEntry '■変数追加 　　On Error GoTo Exception 　　strCC = vbCrLf 　　For Each objRec In Item.Recipients 　　　　If objRec.AddressEntry.Members Is Nothing Then 　　　　　　s = objRec.Name 　　　　Else 　　　　　　s = "" 　　　　　　For Each a In objRec.AddressEntry.Members 　　　　　　　　s = s & a.Name & vbCrLf 　　　　　　Next 　　　　End If 　　　　strCC = strCC & s & vbCrLf 　　Next 　　strMsg = "件名:" & Item.Subject & vbCrLf & strCC & vbCrLf & _ 　　　　　　 "上記の宛先に、メールを送信してもよろしいですか?" 　　If MsgBox(strMsg, vbExclamation + vbYesNo + vbDefaultButton2) <> vbYes Then 　　　　Cancel = True 　　End If 　　On Error GoTo 0 　　Exit Sub Exception: 　　MsgBox CStr(Err.Number) & ":" & Err.Description, vbOKOnly + vbCritical 　　Cancel = True End Sub >『型が一致しません』 これは >Dim objRec As Recipients 変数 objRec の 型の間違い。 正しくは Recipient です。 >For Each objRec In Item.Recipients ここで Recipients コレクション をLoopして個々の Recipient オブジェクトに対して処理するわけだから それに合った型を用意してあげないといけません。 >グループ登録している宛先を氏名で表示する方法 Typeで分岐できるのかもしれないけど取り合えず Recipient オブジェクト の AddressEntry.Members をLoopして取得すれば良さそうでした。
VBではなく、ExcelVBAですが、こんな感じで作ってみました。 ポイントは、Dirで作ったテキストには項目の区切りに連続した複数の空白が入るので、ワークシート関数のTrimを使って1つの空白にしてからSplit関数で分割したところです。 Sub Sample() 　　Dim nFF As Integer 　　Dim sLine As String 　　Dim sData 　　Dim nRow As Long 　　nFF = FreeFile 　　Open "C:\Temp\test.txt" For Input As #nFF 　　nRow = 1 　　Do While Not EOF(1) 　　　　Line Input #nFF, sLine 'CSVを1行取り込む 　　　　sLine = WorksheetFunction.Trim(sLine) 'ワークシート関数のTrimを使って連続する空白を１つにする 　　　　sData = Split(sLine & " ", " ") 'NULLの時ように1つだけ空白を付けて空白でSplit 　　　　'分割した1つ目が日付の場合、シートに貼り付ける 　　　　If IsDate(sData(0)) = True Then 　　　　　　Range(Cells(nRow, 1), Cells(nRow, UBound(sData))) = sData 　　　　　　nRow = nRow + 1 　　　　End If 　　Loop 　　Close #nFF End Sub
『役に立った』『参考になった』を投じたのは私です。 #1さんので こちら（Windows 7 Pro 64bit)では下記のVBSで『エラーにはなりませんでした』よ。 勘違い珍怪答のような気もします。ご参考まで。 Dim oHttp Dim strURI Dim ADO ' 変数を初期化します。 strURI = "http://db.netkeiba.com/index.php?" _ & "pid=horse_detail&id=2002101806" On Error Resume Next Set oHttp = CreateObject("MSXML2.XMLHTTP") If (Err.Number <> 0) Then Set oHttp = CreateObject("MSXML.XMLHTTPRequest") End If On Error GoTo 0 If oHttp Is Nothing Then MsgBox "XMLHTTP オブジェクトを作成できませんでした。", vbCritical wscript.quit End If set ADO =createobject("Adodb.Stream") ' HTTP リクエストを送信します。 oHttp.Open "GET", strURI, False oHttp.Send ' 失敗した場合は関数を終了します。 If (oHttp.Status < 200 Or oHttp.Status >= 300) Then wscript.quit ' HTML ソースを格納します。 Dim retval With ADO .Open .Type = 1 'adTypeBinary .Write oHttp.responseBody .Position = 0 .Type = 2 'adTypeText .Charset = "euc-jp" retval = .ReadText .Close End With msgbox retval ' オブジェクト変数の参照を解放します Set oHttp = Nothing ' 戻り値をセットします。 'GetHtmlSource = True
VBはVB4のころから使っているけど、ExploreBarとかFlatButtonというコントロールは、標準には無かったはずです。 WindowsNTにて、サードパーティ（マイクロソフト以外の会社）製か、自作したコントロールを追加登録していると思われます。 同じコントロールをWindowsXPにも登録しないとだめです。（レジストリ登録が必要） ※WindowsXPでVB6を動かすのなら、VB6にSP6を当てたほうが良いです。
いろいろ考えて、以下のようになりましたが．．． Public IY1 As String: Public IY2 As String: Public IY0 As String: Public I1 As Integer Public WOI(10) As Double Public DDDD As New ADODB.Connection Public RTR As New ADODB.Recordset Public Sub SY_DT_A() IY0 = "KM6" IY1 = "Allloto6" DDDD.ConnectionString = "provider=Microsoft.Jet.OLEDB.4.0;DATA SOURCE =E:\U SS VB\IK NY DATA\" & IY0 & ".mdb" DDDD.Open For I1 = 1 To 10 IY2 = "SELECT Count(A) AS DataCount FROM " & IY1 & " WHERE A = " & I1 Set RTR = DDDD.Execute(IY2) WOI(I1) = RTR.Fields("DataCount").Value Next I1 RTR.Close DDDD.Close
ユーザーフォームはくわしくないのですが、とりあえず最低限のサンプルを作ってみました。 リストボックスが配置されたフォームは作成済みとします。 フォーム名はUserForm1、リストボックス名はListBox1であるとします。 UserForm1のコードを以下のようにします。 Private Sub ListBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer) If KeyCode = vbKeyReturn Then ThisWorkbook.Sheets("Sheet1").Range("A1").Value = ListBox1.Value ThisWorkbook.Sheets("Sheet1").Range("A2").Value = ListBox1.ListIndex Unload Me End If End Sub Private Sub UserForm_Initialize() ListBox1.AddItem "アイテム1" ListBox1.AddItem "アイテム2" ListBox1.SetFocus End Sub あとはユーザーフォームを表示させ、上下矢印キーでアイテム選択し、Enterキーでフォームを閉じます。アイテムの値とインデックス値はA1とA2に入力されます。
>・そもそも、カジノソフトが何の言語？でできているか？ 極端に言えばなんでも良い。 >・自動で履歴を取得することが可能か？（ローカルとカジノ側サーバーの通信履歴の取得？） 現在は不可能。スパイウェア扱いとなるため。 >・取得・解析・表示・自動プレイを実現する言語は何がよいか？ なんでも良い。 >・自動プレイは可能か？ 不可能。 アンチウイルスソフトをくぐり抜けることは出来ないでしょう。 現在の感覚では、このようなシステムを作ろうとしている人は、非常に怪しい人ととらえられます。 オンラインはクライアントの任意で通信するのが基本です。
.NET Frameworkになってからは、WebBrowserコントロールを使うほうが一般的かもしれません。 http://social.msdn.microsoft.com/forums/ja-JP/cs … もし、COMの利用をしたいならこちらを参考に。 http://bbs.wankuma.com/index.cgi?mode=al2&namber …
因みにエクセル２００７以上ですよね。（エクセル２００３以下では最大列数が２５６なので不可能） 先ずは、マクロ記録でコピー＆貼り付け操作を記録しては如何でしょうか。 ２ブロック目のA列先頭セルを選択→Shft＋Ctrl＋*キー押下→コピー（カット）→１ブロック目のA列先頭セルを選択→Ctrl＋→キー押下、→キー押下→貼り付け、３ブロック目以降同様
「何処に」「何を」貼り付けるのでしょう？ 「JAVAアプリ」だけじゃ何のことか不明 ですよ。
No.1です。 訂正です。 IsNumeric関数では空のセルが0と判定されてしまってだめでした。 とりあえずApplication.IsNumber関数なら、数値型かどうかで判定してくれるので大丈夫なようです。 If Application.IsNumber(Range("F" & r)) Then rval = Range("F" & r) Else rval = 1 End If
フォルダ名と基本ファイル名から、重複しないファイル名を検索して返す関数です。 バージョン番号を1から順に増やしてファイル名を作成し、存在しないファイル名を返します。 Private Function GetNewVersionFile(fDir As String, fBase As String) As String 'fDir フォルダのパス名（￥マークの終端） 'fBase 基本ファイル名（拡張子なし） Dim fVer As Integer Dim fName As String '検索するファイル名 Dim swork As String fVer = 1 Do If fVer = 1 Then fName = fBase & ".xlsm" Else fName = fBase & CStr(fVer) & ".xlsm" End if swork = Dir(fDir & fName) If swork="" Then Exit Do fVer = fVer + 1 Loop GetNewVersionFile = fName End Function
>if xlrange.value<>"*合計*" then これってxlrange.value　の値が　"*合計*"　と言う文字列かどうかを 判定しているんですよ。 なのでたぶんですけど目的とは違うでしょうね。 "合計"と言う文字を含む判定なら、 if xlrange.value Like "*合計*" then です。 ⇒含まないって事なら if Not xlrange.value Like "*合計*" then それを否定すれば良い。
Q1が少しおかしかったですね。 正しくは以下のようになります。 Q1： SELECT A.顧客番号,←★これが無かった。 Nz(E.集約先番号,Nz(D.集約先番号, Nz(C.集約先番号,Nz(B.集約先番号, A.集約先番号)))) AS 実集約先 FROM (((T9A AS A LEFT JOIN T9A AS B ON A.集約先番号=B.顧客番号) LEFT JOIN T9A AS C ON B.集約先番号=C.顧客番号) LEFT JOIN T9A AS D ON C.集約先番号=D.顧客番号) LEFT JOIN T9A AS E ON D.集約先番号=E.顧客番号 それでQ2はこちら SELECT Nz(B.実集約先,A.顧客番号) AS 集約番号, 売上月,売上金額 FROM T9 AS A LEFT JOIN Q1 AS B ON A.顧客番号=B.顧客番号←★これが正しい。 Q3はそのままです。 前のクエリだと集約先がない顧客だと上手くいきません。
Microsoftの開発言語と言えば、昔はVBでしたが、今はC#ですからね。 執筆するプロな著者な方は、今更VBやるのもめんどくさいのでは。 いちいちコードが長ったらしくなって汚くなりますし。 http://www.microsoft.com/visualstudio/jpn/downlo … Web上で動作するアプリケーションを開発する場合は Visual Studio Express 2012 for Web Windows Storeにアップしたいようなモバイルアプリケーションを開発する場合は Visual Studio Express 2012 for Windows 8 パソコン上で動くアプリケーションを開発する場合は Visual Studio 2012 Express for Windows Desktop Windows Phoneで動作するモバイルアプリケーションを開発する場合は Visual Studio Express 2012 for Windows Phone 手っ取り早いのはfor Windows Desktopです。 パソコンで動かしている他のソフトと同じ見た目で動作しますから。 球から矢印が出てるようなアイコンをクリックすると、Web経由でインストールします。 （唯一for Webは違うようですが、やったことないのでわかりません。） 円盤のアイコンをクリックすると、iso形式のファイルをダウンロードするので、 DVD-Rに焼くか、仮想ドライブを利用してインストールします。
> ・インストーラ付きモジュールを配布している訳ではない。 > ・Visual studio内のネットアドオン機能で取得する。 > という事ですね。 そう考えてもらってかまわないと思います。 ライブラリをNuGetで提供することが，最近多くなってきています。 ASP.NET MVCなどもNuGetで提供されるようになっていますし。 http://nuget.org/packages/AspNetMvc/ ちなみに，NuGetのNpgsqlのページには，以下のように書いてあります。 > To install Npgsql, run the following command in the Package Manager Console 「Npgsqlをインストールするには，パッケージマネージャコンソールで以下のコマンドを動作させて下さい」 これはNuGetサイトの定型句です。ASP.NET MVCのページにも，NpgsqlがASP.NET MVC 4.0となっただけの文があると思います。 Npgsqlの使い方は，ADO.NETの通りなので，ADO.NETが分かっていれば原則名前の読み替えだけで済みます。 知らない場合は，一度SQL Server Expressを相手にADO.NETを使う解説等を読んで， その上でSql～をNpgsql～に読み替えて使うのが，最終的に早く理解できると思います。 # PostgreSQLをC#で扱う説明やサンプルより，SQL ServerをC#で扱う説明やサンプルの方が圧倒的に多いため。
ExcelとかのVBAなら dim a a=shell("explorer.exe \\サーバー名\共有フォルダ名",vbNormalFocus) a=shell("cmd /c start \\サーバー名\共有フォルダ名",vbNormalFocus) などでは。
こんにちは。 Ｃ列が正しく日付値ならば、ですが、 If Year(Cells(r, "C").Value) = 2011 Then End If の部分を以下のいづれかに替えてみたらよいかと。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ If Cells(r, "C").Value >= #6/1/2010# And Cells(r, "C").Value <= #4/1/2012# Then End If ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Dim dtTgt As Date dtTgt = Cells(r, "C").Value If dtTgt >= #6/1/2010# And dtTgt <= #4/1/2012# Then End If ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Const DT_MIN = #6/1/2010# Const DT_MAX = #4/1/2012# Dim dtTgt As Date dtTgt = Cells(r, "C").Value If dtTgt >= DT_MIN And dtTgt <= DT_MAX Then End If ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Dim dtMin As Date Dim dtMax As Date Dim dtTgt As Date dtMin = #6/1/2010# ' 日付値が指定出来れば方法は問わず。 dtMax = #4/1/2012# ' 同上 dtTgt = Cells(r, "C").Value If dtTgt >= DT_MIN And dtTgt <= DT_MAX Then End If ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 　 　 　 尚、変数を宣言する場合はプロシージャの先頭に書いてください。念の為。 以上です。
可能かどうか，という質問への答えは可能。 ファイル入出力の機構は.NET Frameworkに備えられているのですから，それを使えばよいです。 保存するのが，「テキストボックス」と「コンボボックス」ではなく， 「テキストボックスのTextプロパティ」と「コンボボックスのTextプロパティ」だということを間違えなければ， Visual Basicの基礎の範囲でできると思います。
>同様の物が100個とか200個とかずらずら並ぶ。 根本的にGrid系かList系のコントロール使えって話。 > CType(Me.Controls("child" & cnt_1), TextBox).Text 意味としてはフォームが持っているコントロールの中から該当する文字列 の名前の付いたものを探す。。。だからコントロールがたくさんある 処理で事ある毎に検索する処理が走る。。。ので重くなるかもね。 昨今のPC性能だと問題ないのかもしれないし、テストしてみれば すぐ分かる話だけど、ラベルをそんなに並べる必要性を感じないから 食指が全く動かないなぁ。
Dim dtToday As DateTime = DateTime.Today For i As Integer = 0 To 6 ComboBox1.Items.Add(dtToday.AddDays(i).ToString("yyyy/M/d")) Next こんな感じかな？
どう考えても参照設定してイベントが利用可能なVBAの方が出来る事が多いです。 でもVBSで済む処理なら起動時のもたつきが無いので移植するのもありかなと。
メソッドの外でprivate定義すればいいと思いますが。 予めDB操作として分離できるならばADO操作をクラス化してしまえばいいです。 【Form.frm】 Private Sub Form_Load() Call ConnectDatabase Call CloseDatabase End Sub Private cn As ADODB.Connection Private rs As ADODB.Recordset Private Sub ConnectDatabase() ' 接続処理 End Sub Private Sub CloseDatabase() ' 切断処理 End Sub これだと、Form.frmの外（例えばForm2.frm）に行くと、またオブジェクトを生成し直す必要があります。 もしくは 【Form.frm】 Private Sub Form_Load() 　Dim db As DatabaseADODB 　Set db = DB.Get() 　 　Call db.ConnectDatabase() 　Call db.CloseDatabase() End Sub 【DatabaseADODB.cls】 Private cn As ADODB.Connection Private rs As ADODB.Recordset Public Sub ConnectDatabase() 　 ' 接続処理 End Sub Public Sub CloseDatabase() 　 ' 切断処理 End Sub 【DB.bas】 Private mDb As DatabaseADODB = Nothing Public Function Get() As DatabaseADODB 　If mDb Is Nothing Then 　　Set mDb = New DatabaseADODB() 　End If 　Get = mDb End Function みたいにして、どこからでも唯一のDatabaseADODBオブジェクトを取得するようにすれば どこからでもアクセス可能になります。 が、レコードセットもDatabaseADODBクラス内に含める前提で書くと、レコードセットの リフレッシュ契機もシビアに考えてあげないとバグになります。 普通は、接続クラスとSQL発行クラス、レコードセットクラスが分かれるものなので。 （1接続に対して1レコードセットではない為） 今作ってるモノの規模により、臨機応変にメンテし易い最小限規模を選択してコード化 すればいいと思います。 勉強なら、最初は簡単な規模から、徐々に色んな場面に対応できる規模の大きいものへと 極めるのもいいでしょう。
とりあえず以下の条件で作ってみました。 １．ファイル名のあるセルはSheet1のA1～A3 ２．マクロのあるブックと雛形.xlsは同じフォルダにあり、そこにタイトル1.xls、タイトル2.xls、タイトル3.xls（仮名）を作成する。 ３．雛形.xlsをExcelで開き、名前を付けて保存する ４．同名のファイルがあった場合保存するかどうか尋ねる コードは以下のようになりました。 Sub Create3s() Dim WS, Path, SFN, Hinagata Set WS = ThisWorkbook.Sheets("Sheet1") Path = ThisWorkbook.Path Set Hinagata = Workbooks.Open(Path & "\雛形.xls") For Each SFN In WS.Range("A1:A3") Err.Clear On Error Resume Next Hinagata.SaveAs (Path & "\" & SFN & ".xls") Debug.Print Err.Number, a If Err.Number > 0 Then MsgBox SFN & ".xls は保存されませんでした" Next Hinagata.Close SaveChanges:=False End Sub このマクロを標準モジュールに置き、フォームのボタンをシートに挿入してマクロをボタンに登録しました。そして、雛形.xlsのあるフォルダに保存しました。 動作確認は、Windows XP, Excel 2007で行いました。 疑問点や不都合な点などありましたら補足ください。 参考URL：http://officetanaka.net/excel/vba/file/file09.htm
イベント駆動のマクロを、該当シートに記載しましょう。 「excel セル入力 イベント」で検索すれば詳細が見つかります。 Private Sub Worksheet_Change(ByVal Target As Range) a1 = Range("a1").Value a2 = Range("a2").Value f = 0 If a1 = "k" Then f = f or 1 If a2 = "m" Then f = f or 2 c = Switch(f = 1, 4, f = 2, 5, f = 3, 6, True, xlNone) ActiveSheet.Tab.ColorIndex = c End Sub 変数 c の処理は、少々かっこつけて書きました。 「ビット演算」で検索すれば詳細が見つかります。 個人的には「ビット演算 ワンパク君」が読みやすくてオススメです。
VBA ということは、Microsoft Excel または Access を想定しているのでしょうか。それならば 　スタッフが一人だけなら、VBA マクロ付き Excel/Access 　スタッフが複数人なら、VB アプリケーション + DB サーバー が妥当かと思います。 ただデータの一元性を重視するなら、Web+DB サーバーにて ASP.NET をご検討ください。
あ、すみません。 編集ミス、消し忘れがありました。 > Sheet2.Cells.Copy .Cells(1) > .Range("A:B").Cut .Cells(COL) 上記２行は、こちらでのテスト用の記述ですので、 削除して投稿するべきものでした。 上記２行、削除してください。 失礼しました。
参考までに。 Dim i As Long Dim n As Long n = 1 '連番用 i = 2　'開始位置 '前処理のセル背景色クリア Columns(1).Interior.ColorIndex = xlNone 'Ａ列が空白になるまでループ Do While Cells(i,1) <> "" Select Case n Case Is = Cells(i,1) 'セル値の重複チェック If n = Cells(i+1,1) Then 'セル背景色変更 Cells(i,1).Interior.ColorIndex = 35 Cells(i+1,1).Interior.ColorIndex = 35 Else n=n+1 End If Case Is < Cells(i,1) '行の挿入 Rows(i).Insert shift:=xlDown '連番記載 Cells(i,1).Value = n n=n+1 End Select i=i+1 Loop
CreateObject("WScript.Shell")ws.run "cmd /c startup.bat",vbhide CreateObject("WScript.Shell")ws.run "cmd /c wait9s.bat",vbhide の２行ですが、wsというのは転記間違いでしょうか? もしエラーのでるファイルにそのまま書いてあるなら、おそらくそれがエラーの原因でしょう。 対策ですが、以下のようにwsを削除します。 CreateObject("WScript.Shell").run "cmd /c startup.bat",vbhide さらに付け加えるなら、CreateObject("WScript.Shell")を３つ書いても動くとは思いますが、CreateObjectで精製したオブジェクトを変数に入れて使いまわす方法の方がよく使われると思います。 つまり、最初の方で Dim ws Set ws=CreateObject("WScript.Shell") と書いておいて、CreateObject("WScript.Shell")のかわりにwsにします。 たとえば、 ws.run "cmd /c startup.bat",vbhide のようにします。
TextChangedはその名の通り，Textが変化したことを表すイベントです。 キー操作だけでなく，コードの変更でも発生します。 よって，TextChangedの発生原因となるキーというのは「存在しない」です。 キー情報が欲しければ，KeyDown/KeyPress/KeyUp各イベントを使います。 TextChangedの中で使いたければ，KeyDown/KeyPressあたりで拾ってフィールドに保持しておき， KeyUpで破棄することになるかと思います。
＃結果によって、表示を変えてみました。 Option Explicit Sub Macro1() 　　Dim objHTTP As Object 　　Dim i As Long 　　Dim myURL As String 　　Dim strHtml As String 　　Set objHTTP = CreateObject("WinHttp.WinHttpRequest.5.1") 　　Columns("B").Clear 　　Application.ScreenUpdating = False 　　For i = 1 To Range("A1").End(xlDown).Row 　　　　myURL = Range("A" & i).Value 　　　　With objHTTP 　　　　　　.Open "GET", myURL, False 　　　　　　.Send 　　　　　　If .Status = 200 Then strHtml = .responseText 　　　　End With 　　　　If InStr(strHtml, "指定されたドキュメントは存在しません") > 0 Or _ 　　　　　 InStr(strHtml, "指定したオークションIDは無効です") > 0 Then 　　　　　　Range("B" & i).Value = "URL エラー" 　　　　Else 　　　　　　If InStr(strHtml, "このオークションは終了しています") > 0 Then 　　　　　　　　If InStr(strHtml, "auction:Price") > 0 Then 　　　　　　　　　　Range("B" & i).Value = _ 　　　　　　　　　　　　Format(Split(Left(Split(strHtml, "auction:Price"">")(1), 10))(0), "#,##0 終") 　　　　　　　　Else 　　　　　　　　　　Range("B" & i).Value = _ 　　　　　　　　　　　　Format(Split(Left(Split(strHtml, "auction:BidOrBuyPrice"">")(1), 10))(0), "#,##0 終") 　　　　　　　　End If 　　　　　　Else 　　　　　　　　If InStr(strHtml, "<th>即決価格<br>") > 0 Then 　　　　　　　　　　Range("B" & i).Value = Format(Split(Left(Split(strHtml, "auction:BidOrBuyPrice"">")(1), 10))(0), "#,##0 即") 　　　　　　　　Else 　　　　　　　　　　If InStr(strHtml, "auction:Price") > 0 Then 　　　　　　　　　　　　Range("B" & i).Value = _ 　　　　　　　　　　　　　　Format(Split(Left(Split(strHtml, "auction:Price"">")(1), 10))(0), "#,##0 円") 　　　　　　　　　　Else 　　　　　　　　　　　　If InStr(strHtml, "アダルト") > 0 Then 　　　　　　　　　　　　　　Range("B" & i).Value = "アダルト" 　　　　　　　　　　　　Else 　　　　　　　　　　　　　　Range("B" & i).Value = "要ログイン" 　　　　　　　　　　　　End If 　　　　　　　　　　End If 　　　　　　　　End If 　　　　　　End If 　　　　End If 　　Next 　　With Columns("B:B") 　　　　.HorizontalAlignment = xlRight 　　　　.Columns.AutoFit 　　End With 　　Application.ScreenUpdating = True 　　Set objHTTP = Nothing End Sub
こんにちは！ 一例です。 入力する列はA列とします。 ＞D1セルの11文字目以降はH1のセルに・・・ とありますが、列方向に関しては規則性がないみたいですね！ シートモジュールです。 Private Sub Worksheet_Change(ByVal Target As Range) Dim tmp As String If Application.Intersect(Target, Range("A:A")) Is Nothing Or Target.Count <> 1 Then Exit Sub Application.EnableEvents = False tmp = Target With Target .Value = Left(tmp, 10) .Offset(, 3) = Mid(tmp, 11, 10) .Offset(, 7) = Mid(tmp, 21, 10) End With Application.EnableEvents = True End Sub ※　A列は「文字列」とします。 ※　H列までのコードですので、31文字以上は別途コードを追加してやる必要があります。 これでA列に文字列を入力してみてください。m（_ _）m
推測ですが、Dispose しない場合、 Cmd.CommandType = CommandType.StoredProcedure の状態で SQL を実行しているからではないでしょうか。 Dispose しなくても、Point2 の直前に Cmd.CommandType = CommandType.Text を入れるといいのではないでしょうか。
IEを制御して一旦、ローカルにHTMLファイルを保存して、そちらに対してWebクエリを適用させればいいのではと。 (IEのNavigateメソッドのjavascriptプロトコルで処理) http://hpcgi1.nifty.com/MADIA/VBBBS/wwwlng.cgi?p … ↓IE制御の入門書 「Excel VBAでIEを思いのままに操作できるプログラミング術　Excel 2013/2010/2007/2003対応」 http://www.impressjapan.jp/books/3384
#1です。 お褒めにあずかり光栄です。 For Each のLoopが遅いという件ですが、基本的なところでは、 Application.ScreenUpdating = False Application.Calculation = xlCalculationManual 'セルに対する処理 Application.Calculation = xlCalculationAutomatic Application.ScreenUpdating = True という方法があります。 更には、一旦Variant型の配列に入れておいて、配列上で処理した後書き戻すといった技もありますが、Eventマクロの中でそこまで時間のかかる処理をするのは本来の趣旨と異なる気がします。 ご参考まで。
画像は潰れて見えません。 説明文も、画像を見れば分かるような書きっぷりになってるので、何を入力して、最終的に何をどうしたいのか？不明瞭です。 説明は、画像使わずに、具体的に何をどうした時に、何をどうするって事を箇条書きなんかで書くのが良いです。 > 赤で囲んだエクセルのセル内容をメモ帳で書き込み後改行する(クリップボードを使用)を作成するにあたり これが最終的にやりたい事になるんでしょうか？ そのまんま書くなら、 Sub test() ' B2の範囲をクリップボードにコピー Range("B2").Copy ' メモ帳起動 Shell "c:\Windows\notepad.exe", vbNormalFocus ' Ctrl+Vキーを送信 SendKeys "^v", True ' Enterキーを送信 SendKeys "{ENTER}", True End Sub とか。 テキスト処理するんなら、クリップボードやメモ帳使うなんて方法はお勧めしませんが…。
標準APIに全角文字なんて概念はありません（日本独特のものだから） 全角含む文字数として認識させたいのであれば独自に処理する必要があります 全角1文字＝2バイト って理解してればあってますよね
No.3・4です。 ＞(1)Ａ－Ｄ列の2行目と3行目を結合し1つのセルにして会社名を入れています。 ＞(2)Ｅ－Ｋ列のの2行目から11行目に契約内容を入れています。 とありますが、なかなか実際の表の配置が見えてきません。 結局、各シートのE列に2行以上のデータがあればE～K列データのみを表示する！という解釈で コードをいじってみました。 Sub 全Sheet表示() Dim k As Long, endRow As Long Application.ScreenUpdating = False endRow = Worksheets(1).Cells(Rows.Count, 1).End(xlUp).Row If endRow > 2 Then Worksheets(1).Rows(2 & ":" & endRow).Clear End If For k = 2 To Worksheets.Count With Worksheets(k) endRow = .Cells(Rows.Count, "E").End(xlUp).Row '←ココを変更（E列の最終行） If endRow > 1 Then '←ココを変更（最終行が2行以上あれば） Range(.Cells(2, "E"), .Cells(endRow, "K")).Copy Worksheets(1).Cells(Rows.Count, 1).End(xlUp).Offset(1) '↑　E列～K列を表示したいSheetのA列にコピー End If End With Next k Application.ScreenUpdating = True End Sub こんどはどうでしょうか？m(_ _)m
こんばんは！ 前回回答した者です。 ＞シートのC1に顧客のＩＤ数字が7ケタあるのですが・・・ とありますが、各SheetともID番号がC1セルに入っている訳ですよね？ そして「検索用」SheetのA1セルに、Sheet名もしくはID番号を入力すると そのSheetを選択したい！ という解釈での一例です。 ID番号の扱いが問題になりますが、「文字列」で7桁表示しているのではなく 各Sheetには「数値」でID番号が入っていて、表示形式で7桁表示にしている！ という前提です。 Private Sub Worksheet_Change(ByVal Target As Range) Dim k As Long, tmp, myFlg As Boolean tmp = Range("A1") If IsNumeric(tmp) Then For k = 1 To Worksheets.Count If Worksheets(k).Range("C1") = tmp Then myFlg = True Exit For End If Next k Else For k = 1 To Worksheets.Count If Worksheets(k).Name = tmp Then myFlg = True Exit For End If Next k End If If myFlg = True Then Worksheets(k).Activate Else MsgBox "該当シートなし" End If End Sub こんなんではどうでしょうか？m(_ _)m
VB のことはよくわからないのですが、暗黙のうちに型変換関数が呼ばれているのではないかと思われます。 テキストボックスに合計が Single 型の範囲を超えるような値を入力したらどうなりますか? 自分の予想では System.OverflowException エラーが発生するのではないかと思うのですが……。
こんばんは！ せっかくコードをお考えですので、余計なお世話かもしれませんが・・・ Private Sub Worksheet_Change(ByVal Target As Range) Dim k As Long, str As String, myFlg As Boolean str = Range("A1") For k = 1 To Worksheets.Count If Worksheets(k).Name = str Then myFlg = True Exit For End If Next k If myFlg = True Then Worksheets(str).Activate Else MsgBox "該当シートなし" End If End Sub こんなんではどうでしょうか？m(_ _)m
# 上手く行ったなら解決済みにされた方がいいのではと。 objIE.document.forms(1).Item("XCID").Value = "12345" objIE.document.forms(1).Item("SECURITY_CD").Value = "Password" objIE.document.forms(1).all("ACT_ACBS_do_LOGIN2").Click とも書けますね。 --- > nameは普通ユニーク Idの方はUI Automationの AutomationId として検索としても使われるのでユニークなのですが、nameはForm毎に同名なのは結構ある様です。 (Twitterのログインページも同じ類)
こんにちは。 ３行追加、１行変更（書き足し）です。 .SaveAs メソッド については、一応、VBAヘルプ目を通しておいてください。 /// 　　'Dim nShInNWB As Long ' ● 　　' ' 新しいブックを開いた時のシート数 　　' ' 後で元に戻す為に変数に記録 　　nShInNWB = Application.SheetsInNewWorkbook ' ● 　　' ' 新しいブックを開いた時のシート数を指定 　　Application.SheetsInNewWorkbook = 1 ' ● ShName = ThisWorkbook.ActiveSheet.Name Set objWorkBook = Workbooks.Add objWorkBook.ActiveSheet.Name = "○○商事" Call 処理 Set WSH = CreateObject("Wscript.Shell") Path = WSH.SpecialFolders("Desktop") & "\" ''On Error Resume Next '上書き保存をキャンセルした時の取り合えずの回避策（宿題(^^;)） ''ActiveWorkbook.SaveAs Path & "○○系_" & ShName & ".xls" 　　' ' Excel2003互換、.xlsで"名前を付けて保存" 　　objWorkBook.SaveAs Filename:=Path & "○○系_" & ShName & ".xls", FileFormat:=xlExcel8 ' ● 　　' ' 新しいブックを開いた時のシート数を元に戻す 　　Application.SheetsInNewWorkbook = nShInNWB ' ● Set WSH = Nothing Set objWorkBook = Nothing /// 以上です。
VBAの応用として必要なのは １、テキストファイルの読み込　と ２、指定したフォルダ内のファイルの指定では ないでしょうか。 １については http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub0 … 等を参考にしてください。 ２について、DIR関数を使用してみました。方法はいくつかあります。 dir関数で検索してみてください。 サンプルですが Sub ボタン1_Click() Dim intFF As Integer Dim strREC As String Mypath = "テキストファイルのあるフォルダーへのパス" Filename = Mypath & Dir(Mypath & "*.txt") RETU = 1 intFF = FreeFile Do While Len(Filename) > Len(Mypath) Open Filename For Input As #intFF GYO = 1 　Do Until EOF(intFF) Line Input #intFF, strREC If GYO = 10 Then 　 Temp = Split(strREC, " ") 　 Cells(1, RETU).Value = Temp(1) End If If GYO = 20 Then 　 Temp = Split(strREC, " ") 　 Cells(2, RETU).Value = Temp(1) 　 Cells(3, RETU).Value = Temp(3) End If GYO = GYO + 1 Loop Close #intFF Filename = Mypath & Dir() RETU = RETU + 1 Loop End Sub こんな感じではないでしょうか。
パブリック変数に動作可否を持っておいたら？ 例えば、 public Flag_WSChange as string Private Sub workbook_open ・・・ Flag_WSChange = "" end sub Private sub 止めたいサブルーチン Flag_WSChange = "STOP" ・・・ Flag_WSChange = "" end sub Private Sub WorkSheet_Change(ByVal Target As Range if Flag_WSChange = "STOP" then exit sub end if ・・・ end sub って感じ。 EXCELブック上の特定シート上にある特定セルの値でもいいですし。 ★止めたいサブルーチンでエラーが起きて続行しなかったときは、STOPになったままなので要注意。 （ON ERROR 処理でSTOPをはずすなり、手作業で変えるなりする必要があります）
Visual Studio 自体が 32bitアプリケーションなのでは？ http://backyard.hatenablog.com/entry/20110501/p2 http://msdn.microsoft.com/ja-jp/library/vstudio/ …(v=vs.110).aspx
＃２補足欄へのレスです。 エラーが出るとのこと。 掲示されている＃２のコードをコピーして再度繰り返し確認しましたが、 こちらでは問題なく処理できています。 記述の通りでテストしているのであれば、実際のシートのあり方と こちらが想定しているものとが違っているのかも知れませんね。 まず、 > 最後から７行目、　.Select　だけでいいのでしょうか。 はい、合っています。 もしここがエラーになっている？、ということですと、 標準モジュールに貼るべきところをSheet1モジュールに貼っているとかですかね？ 特に断りがない場合は、マクロは標準モジュールに記述するものです。 私がちゃんと説明しておけば良かったですね。 ちょっと不親切でした。すみません。 対策として以下、 標準モジュールに貼って実行するか、または、Sheet1モジュールのまま 最後の23行分を以下の25行に差し替えてみてください。 　　 Application.ScreenUpdating = False 　　 With Sheets("Sheet2") 　　　　 .Select ' ←要指定　出力シート名［ "Sheet2" ？］ 　　　　 .Cells.ClearContents 　　　　 rngS.Copy 　　　　 .Cells(1).PasteSpecial xlPasteColumnWidths 　　　　 .Cells.Resize(nPrtRow, tnCols).PasteSpecial xlPasteFormats 　　　　 If VarType(rngS(2, 2).Value) = vbString And rngS(2, 2).NumberFormat = "General" Then 　　　　　　　　.Range("B2:C" & nPrtRow).NumberFormat = "@" 　　　　 End If 　　　　 If nPrtXSize > tnCols Then 　　　　　　　　.Columns(tnCols).Copy 　　　　　　　　.Columns(tnCols + 1).Resize(, nPrtXSize - tnCols).PasteSpecial xlPasteFormats 　　　　 End If 　　　　 With .Cells.Resize(nPrtRow, nPrtXSize) 　　　　　　　　.Value = mtxP() 　　　　　　　　.Select 　　　　 End With 　　 End With 　　 Application.CutCopyMode = False 　　Application.ScreenUpdating = True 　　Erase mtxP() 　　Set rngS = Nothing End Sub 以上で解決が得られた場合は、以下読まなくて結構です。 > 試してみたところ、エラーになってしまいました。 どの行でエラーになっているか確認できますか？ エラーメッセージが表示されたら、[デバッグ]ボタンを押してみてください。 エラーの原因になっている行が黄色くハイライトされますので、 その行の記述とエラーメッセージの内容を教えてください。 ↑エラー相談時のルーティンです。 とりあえず、他に原因として思い付く点だけ、 １）元データシートでシートの保護を適用している場合 　　→　一旦シートの保護を解除して試してみる。 ２）元データシートの６列目、例示では空白列だけど、本当は違っている場合 ' ' 要指定　元データシート名↓［ "Sheet1" ？］ 　　Set rngS = Sheets("Sheet1").Cells(2, 2).CurrentRegion 　　mtxS() = rngS.Value 　　tnRows = UBound(mtxS()) 　　tnCols = UBound(mtxS(), 2) 　↑この４行を以下の4行に差し替えて試してみる 　　tnCols = 5 　　Set rngS = Sheets("Sheet1").Cells(2, 2).CurrentRegion.Resize(, 5) 　　mtxS() = rngS.Value 　　tnRows = UBound(mtxS()) ３）要指定と書かれた部分の指定を確認する。 ' ' 要指定　元データシート名↓［ "Sheet1" ？］ 　→　元データのシート名は　"Sheet1"　で合っていますか？ 　　ReDim mtxP(1 To tnRows, 1 To 100) ' ←要指定　最大列数［ 100 ？］ 　→　"商品"項目が右に並んで95品目を超える可能性があれば、 　　　100 の数値を増やして対応してみてください。 　　Sheets("Sheet2").Select ' ←要指定　出力シート名［ "Sheet2" ？］ 　→　出力先のシート名は　"Sheet2"　で合っていますか？ ／／／／／ こちらも慎重さとか配慮が足らなかったかも知れません。 > 初心者の質問ですいません。 どうか、お気になさらず、、、。 更にお困りでしたら、遠慮なく訊いてください。 以上です。
＃２ DOUGLAS_ です。 　＃２に補足いただいた内容を整理して、下記のように理解したのですがいかがでしょうか？ １）「入力.xls」に「データ」シートがある。 ２）「データ」シートの「A1:A1000」に「1 ～ 1000」の連番が入っている。 ３）「データ」シートの「B1:B1000」には、Ａ列の番号が付いた書類が決裁された日を記入。 ４）「確認書.xls」に「チェック」シートがある。 ５）「チェック」シートの「A1:AN25」などの矩形範囲に「1 ～ 1000」の連番が入っている。 ６）(３)の範囲に決裁日が入力されている連番を検索し、(５)の対応する連番を塗りつぶす。 ＞要するに戻ってきた書類の通番が一目でわかるように塗りつぶしをしたい ＞最後はすべての通番が塗りつぶされるというわけです。 とのことですので、「(３)の範囲に日付が入っていれば(５)の連番を塗りつぶす」という考え方でＯＫですよね？ '----------------------------------- ＞VBAの勉強を兼ねて作ってみたい とのことですが、ＶＢＡを使わない場合は、下記により、目的のことを達成できます。 １）「チェック」シートの「A1:AN25」に「1 ～ 1000」の連番が入っているとします。 ２）「A1」をアクティブにし、[Ctrl] + [A] で、「A1:AN25」を選択します。 ３）名前ボックスに「A1」と表示されていることを確認の上、条件付き書式で「数式が」 =INDIRECT("[入力.xls]データ!B" & A1,1)<>"" で、塗りつぶしの書式を施します。 ４）以上で、「入力.xls」を開いた時点で、「確認書.xls」の連番が塗りつぶされますので、印刷なり、目視なりなさってください。 ５）「今日」の日付を強調したい場合は、(３)の時点で、「数式が」 =INDIRECT("[入力.xls]データ!B" & A1,1)=TODAY() で、塗りつぶしの書式を施し、(３)の条件は「条件2」に設定します。 '----------------------------------- 　さて、本題に戻りますが、＃２に補足いただいた内容をよく考えてみると、「１～１０００ごとに」とお書きですので、書類に付された連番が「1000」に到達した時点で、新たに「1」から連番を振り直すということになろうかと存じます。 　したがって、その場合には、「入力.xls」の「データ」シートも「確認書.xls」の「チェック」シートも新しくなるかと存じます。 　このことを含めて、ＶＢＡを書くことは、初級者には難しいと存じますので、「ＶＢＡを使わない」方法をお勧めいたします。 　上記のことを考えずに、取り敢えず、目の前の「入力.xls」の「データ」シートと「確認書.xls」の「チェック」シートだけを対象にＶＢＡを書くと下記のようなことになろうかと存じます。 '----------------------------------- ●「別のブックを開きその通番を塗りつぶす」マクロ 　ただし、「エクセルのVBA初心者」・「VBAの勉強を兼ねて作ってみたい」とのことですので、奇をてらったヤリ方やコードは用いず、人間がするように、マクロの操作を書いてみました。 １）「確認書.xls」を開く。 ２）「入力.xls」の「チェック」シートＢ列を検索し、今日の日付を確認する。 ３）今日の日付が見つかったら、その左側の連番を「確認書.xls」の「チェック」シートから見つけて、これを塗りつぶす。 ４）(２～３)を、今日の日付が見つからなくなるまで繰り返す。 　ただ、「日付文字列の検索」というのは、ワークシート上の手作業でも、ＶＢＡでも少し難しいことになろうかと存じますので、[For...Next ステートメント] で、行数分回すことにします(1000行ですから、そんなに時間も掛からないでしょうし。。。)。 参考）日付を検索する http://officetanaka.net/excel/vba/tips/tips131b. … Sub Macro1() 　　Dim l As Long '行番号 　　Workbooks.Open Filename:="～～\確認書.xls" 　　Sheets("チェック").Select 　　For l = 1 To 1000 　　　　If Workbooks("入力.xls").Sheets("データ").Range("B" & l).Value = Date Then 　　　　　　Cells.Find(What:=l, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False _ 　　　　　　, MatchByte:=False, SearchFormat:=False).Interior.ColorIndex = 6 　　　　End If 　　Next End Sub
2007版ではありませんが 白紙のシートでやってみたところ 何の問題もありませんでした。 　おそらくデータ量が非常に多いシートで 切り替えに負荷がかかっているのではないでしょうか。 （XP機でメモリーが不足気味とか） それと、 昔は２００７版は他の版よりシートやセルの操作でわずかに時間がかかりました。 今もそうなのかもしれません。 　そこで、 Sheets("単価表").Select DoEvents :DoEvents のように１～３個ほどDoEventsを入れてみたらどうでしょう。
>ユーザーフォームのテキストボックスとコマンドボックス とありますが、文脈からフォームコントロールの事の様に思えます。 リストを用意してあるなら、入力規則で十分と思いますがいかがでしょうか。 Sheet1に入力規則から選択するセルと、結果を表示するセル Sheet2にオートフィルタをかけるデータ Sheet3にリストがあるものとします。 ☆標準モジュール Sheet3のリストに動的な名前をつけ、Sheet1のB2に入力規則を設定します。 Sub makeNameAndValidation() ActiveWorkbook.Names.Add Name:="mylist", RefersToR1C1:="=OFFSET(Sheet3!R1C1,0,0,COUNTA(Sheet3!C1),1)" With Sheets(1).Range("B2").Validation .Delete .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:= _ xlBetween, Formula1:="=mylist" End With End Sub ☆Sheet1モジュール オートフィルタを掛けるところは、試験のため簡略化しています。 お気に召したらご自分でアレンジして下さい。 Private Sub Worksheet_Change(ByVal Target As Range) Dim result1 As Long Dim sh As Worksheet Dim GroupName As String GroupName = Target.Value If Intersect(Target, Range("B2")) Is Nothing Then Exit Sub Application.ScreenUpdating = False Set sh = Sheets(2) With sh If .AutoFilterMode Then .AutoFilterMode = False End If 'ここは適当な範囲に合わせて試験したもの '----------------------------------------------------------- .Range("A1").AutoFilter Field:=1, Criteria1:=GroupName result1 = WorksheetFunction.Subtotal(9, .Range("B:B")) '----------------------------------------------------------- Me.Range("A2").Value = result1 If .AutoFilterMode Then .AutoFilterMode = False End If Application.ScreenUpdating = True End With End Sub ※本当にユーザーフォームを使いたいという場合は、補足して下さい。
WSF形式なら、VBScriptとJScriptを混在(VBScriptからJScriptの関数を呼び出す。)が可能ですけど、 ＞MonthNameの逆、つまり、JanuaryとかFebを１とか２で返すような関数 ANo.1さんが書かれている通り、Month()、CDate()で良いような。
＞myNo1　の部分で、『変数の定義されていません』と ＞メッセージが出てしまいます。 Dim myNo As Variant も Dim myNo1 As Variant Dim myNo2 As Variant となります。 ただ、本当に　myNoにVariant型が必要？ とちょっと思うのですが。
適切な正規表現を指定して、Submatchesを使ってください。 Dim ans ans = check("本日は曇り20度ですが、湿度60%でした。") if ans<>"" then msgbox ans else msgbox "NG" end if Function check(target) Dim re, match Set re = new RegExp re.IgnoreCase = True re.pattern = "^本.*(晴|曇り|雨)(\d\d).*湿度(\d\d).*" if re.Test(target) then set match = re.Execute(target)(0) check = match.SubMatches(0) & match.SubMatches(1) & "度、湿度" & match.SubMatches(2) & "%" else check = "" end if End Function
RAND関数はセルに何か入力するごとに反応して戻り値を変えてしまうところが曲者だと思います。 自分ならRAND関数で値を取得してそれをセルに入れるマクロを使うかな。 セルA2以下に応募者の番号が入っていると仮定して、以下のマクロを実行。 Sub test() Dim i As Integer Dim myrnd As Double For i = 2 To Range("A65536").End(xlUp).Row Do While Range("B" & i) = "" myrnd = Rnd If WorksheetFunction.CountIf(Columns(2), myrnd) = 0 Then Cells(i, 2).Value = myrnd Exit Do End If Loop Next i End Sub
No.2です。 ＞混在したプログラムは作れないので とありましたので、一気にやってみました。 区切りられている文字は 読点（、）・半角スペース・全角スペース・改行　 にしています。 Sub Sample2() Dim i As Long, j As Long, k As Long, cnt As Long Dim wS1 As Worksheet, wS2 As Worksheet, myArray1, myArray2, tmp Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") myArray1 = Array("、", " ", "　", vbLf) '←ココに「区切り」の文字を追加する For i = 1 To wS1.Cells(Rows.Count, 1).End(xlUp).Row tmp = wS1.Cells(i, 2) For j = 0 To UBound(myArray1) tmp = Replace(tmp, myArray1(j), ",") '←区切り文字をすべてカンマ（,）に置換 Next j myArray2 = Split(tmp, ",") For k = 0 To UBound(myArray2) cnt = cnt + 1 With wS2.Cells(cnt, 1) .Value = wS1.Cells(i, 1) .Offset(, 1) = myArray2(k) End With Next k Next i End Sub 今度はどうでしょうか？m(_ _)m
>シート2には，用語と読みが一緒になったDBがあります（用語と読みは1対1です）． その場合、Do..Loopは必要ないです。 ： >Set Foundcell01 = Rng01.Find(What:=Str01, searchorder:=xlByRows, LookIn:=xlValues, lookat:=xlWhole) >If Not Foundcell01 Is Nothing Then >　　Set firstcell = Foundcell01 >　　Foundcell01.Select >　　Do >　　　　Selection.Offset(0, 1).Value = Str02 >　　　　Selection.Offset(0, 2).Value = "●" >　　Loop Until ActiveCell.Address = firstcell.Address >End If ： 以下のように書きます。 Set Foundcell01 = Rng01.Find(What:=Str01, searchorder:=xlByRows, LookIn:=xlValues, lookat:=xlWhole) If Not Foundcell01 Is Nothing Then 　　Foundcell01.Offset(0, 1).Value = Str02 　　Foundcell01.Offset(0, 2).Value = "●" End If ただし、用語の個数をピボットでチェックして、 登録済み用語のみをFindメソッドで検索してシート1に『当て』にいく.. ような処理は効率悪いです。 >..速度の面でピボットのほうが断然早いため，改修したという経緯がございます． 前回提示したSub sample()を実行してみたらどうなりますか？ 比較してみてください。 もっと速度を上げたい場合はdictionaryオブジェクトを使う事になります。 http://oshiete.goo.ne.jp/qa/6327928.html?order=asc
すみません。 夢の中でポカしていたことに気が付きました。 Sub Re8078570a()　についての一部訂正です。 誤） ｜' ' 既存データをクリア ｜　　　　If nBottom >= nPrintPos Then ｜　　　　　　.Cells(nPrintPos).Resize(nBottom - nPrintPos + 1).ClearContents ｜　　　　End If 正） ' ' 既存データをクリア 　　　　If nBottom >= nPrintPos Then 　　　　　　.Cells(nPrintPos).Resize(nBottom - nPrintPos + 1, 12).ClearContents 　　　　End If それから、少し説明が雑だったようなので、、、。 > 　sWshNm = StrConv(oWsh.Name, vbNarrow) > に続けて > sWshNm = Replace(sWshNm, " ", "") > と書き足して、スペースを抜いた形で比較する方が好いかも知れません。 b、a、２パターン共通で、 ' ' 各シート名取得（２回以上使う値は変数に）（全半角混在対策で半角に統一） 　　　　　　sWshNm = StrConv(oWsh.Name, vbNarrow) ' ' 各シート名の中のスペースに過不足がある場合を想定してスペースを抜いて比較。 　　　　　　sWshNm = Replace(sWshNm, " ", "") ' ' Like演算子で "一覧 (#)" "一覧 (##)" 0-99の数字に対応したシートを判別 　　　　　　If sWshNm Like "一覧(#)" Or sWshNm Like "一覧(##)" Then という意味のことを書きましたが、不明瞭でした。 全半角やスペースの有無の入力時錯誤、この手の対処は私自身多くの経験があります。 職場によっては全く必要ない場合もありますし、 保険を掛ける意味でＶＢＡの確度を高めようとする場合もあります。 シート名の判別をより正確にしたい場合などは正規表現（RegExp）を使うニーズもあるでしょう。 「一覧 (0)」というシートがあって、それだけはコピーしたくない、 なんてニーズもあるかも知れません。 何か不足があったら補足欄にでも書いてみてください。 訂正の件。失礼しました。
今回日付を入れたいブック（以後ブックAとします）と納品.xlsxは、どういう使い方をするのでしょうか？ 一人の人が二つのブックを同時に開いて使用するのでしょうか？ 同時に開くことはない、あるいは同時に開くとしても別々の人が使用するものでしょうか？ 前者であれば、納品.xlsxのWorkSheet_Changeイベントで、ブックAに日付を書き込むようにする。 Workbooks("ブック名").WorkSheets("シート名").Cells(行,列) = DateAdd("d", Now(), -1) のように、頭に「Workbooks("ブック名").」をつければ別のブックに書き込むことは可能です。 ただし、書き込み対象のブックが開かれていないとエラーになります。 後者であれば、ブックAのWorkbook_Openイベントでブックオープン時のB列の値を別シートに保持しておき、マクロなりボタンなりにリンクの更新と保持した値との比較、日付入力を一連の処理として設定し、そこから実行する。 この場合、ブックAを開く際にはリンクの更新をしないようにする必要があります。 リンクの更新は ThisWorkbook.UpdateLink Name:=ファイル名（納品.xlsxをフルパスで指定）, Type:=xlExcelLinks
   こんな感じでイケルかと存じますが、内容をよく吟味してから、実情に応じてコードを書き換えてみてください。 Option Explicit Dim fs, f, msg, copyFrom, c Dim hizuke, hizuke8, hizuke8h, hizuke8p, hizuke6, hizuke6h, hizuke6p, h Const copyTo = "D:\VBS\コピー先\" copyFrom = Array("D:\AB", "D:\CD", "D:\EF") '日付の確定 Do      hizuke = InputBox("日付を入力してください。" & vbCr & vbCr & "例）2000-01-01")      If hizuke = "" Then WScript.Quit      If Len(hizuke) > 5 Then          If Left(hizuke, 2) <> "20" Then hizuke = "20" & hizuke          hizuke = Replace(hizuke, ".", "/")          On Error Resume Next          hizuke = FormatDateTime(hizuke, vbShortDate)          If Err.Number = 0 Then              If Year(hizuke) > 1999 Then                  If MsgBox(FormatDateTime(hizuke, vbLongDate) & "でよろしいか？", vbYesNoCancel) = vbYes Then Exit Do              End If          End If      End If      On Error GoTo 0 Loop '日付文字列の配列 hizuke8 = Replace(hizuke, "/", "") hizuke8h = Replace(hizuke, "/", "-") hizuke8p = Replace(hizuke, "/", ".") hizuke6 = Mid(hizuke8, 3, 6) hizuke6h = Mid(hizuke8h, 3, 8) hizuke6p = Mid(hizuke8p, 3, 8) hizuke = Array(hizuke8, hizuke8h, hizuke8p, hizuke6, hizuke6h, hizuke6p) '該当するファイルのコピー Set fs = CreateObject("Scripting.FileSystemObject") For c = 0 To UBound(copyFrom)      For Each f In fs.GetFolder(copyFrom(c)).Files          For h = 0 To UBound(hizuke)              If InStr(f.Name, hizuke(h)) > 0 Then                  On Error Resume Next                  fs.CopyFile f.Path, copyTo & f.Name, False                  If Err.Number <> 0 Then                      '同名のファイルが存在するときは、フォルダ名を冠して保存                      fs.CopyFile f.Path, copyTo & Replace(Mid(copyFrom(c), 3, 100), "\", "") & "_" & f.Name, False                  End If                  On Error GoTo 0              End If          Next      Next Next MsgBox "終了しました"
CInt(引数の型は Object型） Integer.Parse(引数の型は string型） CInt は object型渡しなので CInt(3.14) とかもできます
変数1個用意して、ボタン押下時に、識別できるような値を入れて おけばいいだけに思います。
そちらで現在公開している情報と全く同じ環境で、以下のコードをWin7 32bit vb2005にてコンパイルを行いました。 ※Oracle.DataAccessを参照設定に追加 Imports Oracle.DataAccess.Client Public Class Class1 　Public Shared Sub Main() 　　Dim l_strCnn As String = "User Id=ユーザID;Password=パスワード;Data Source=TNS設定名;Connection Timeout=900;Pooling=False;Min Pool Size=10;Validate Connection=true;" 　　Try 　　　MsgBox("1.起動") 　　　Using l_oraCnn As New OracleConnection(l_strCnn) 　　　　MsgBox("2.接続開始") 　　　　l_oraCnn.Open() 　　　　MsgBox("3.接続中") 　　　　l_oraCnn.Close() 　　　　MsgBox("4.接続終了") 　　　End Using 　　　MsgBox("5.終了") 　　Catch ex As Exception 　　　MsgBox(ex.Message) 　　End Try 　End Sub End Class コンパイル後、「Test.exe」と「Oracle.DataAccess.dll」を抜き出し実行を行うと、こちらの環境ではWin7でもXPでも正常に動作を行うことが出来ました。 ndoxxさんの環境では「2.接続開始」まで行かないって事ですよね？ OracleClientのバージョンが一致しているのにインスタンスが行えないとなると、、、 あとはFramework本体を疑うしかないかな・・・パッチの状況とか・・・ http://www.atmarkit.co.jp/ait/articles/1210/26/n …
>足したところ、なぜかその部分が黄色くなり、 >「変数が定義されていません」というコンパイルエラーが発生します。 あ、もしかして、ボタンがActiveXコントロールになってないのでは？ http://www.officelabo.net/excel/list2.html なお、前の回答にある、「ボタンの名前」はこのリンクの2番目の画像に出ているプロパティボックスの一番上の枠内の太字で書かれた文字です。
こんばんは！ 外しているかもしれませんが・・・ ＞今後も７月８月とデータは増えていきます(空白は空白セルです) の部分は↓の画像のようにSheet1に月が連続で1行目の項目にあるとして、 Sheet2にSheet1のデータに追加したいデータがあるという前提です。 標準モジュールにコピー＆ペーストしてマクロを実行してみてください。 Sub Sample1() Dim i As Long, j As Long, c As Range, wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") j = WorksheetFunction.Match(wS2.Cells(1, 3), wS1.Rows(1), False) For i = 2 To wS2.Cells(Rows.Count, 1).End(xlUp).Row Set c = wS1.Range("A:A").Find(what:=wS2.Cells(i, 1), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then With c.Offset(, j - 1) .Value = .Value + wS2.Cells(i, 3) End With Else wS2.Cells(i, 1).Resize(1, 2).Copy wS1.Cells(Rows.Count, 1).End(xlUp).Offset(1) With wS1.Cells(Cells(Rows.Count, 1).End(xlUp).Row, j) .Value = .Value + wS2.Cells(i, 3) End With End If Next i End Sub こんな感じではどうでしょうか？m(_ _)m
> foreach (var lb in new[] { listBox1, listBox2, listBox3, listBox4, listBox5 } > ) > foreach (var item in lb.Items) > { > parm.Value = item; > } > > int count = cmd.ExecuteNonQuery(); なぜこういうコードを書いたのですか。 デバッグ実行して，ブレークポイントを最初のforeachにおいて，lb, item, parm.Valueをウォッチしながらステップ実行をしてみましたか。 やりたいのは，「すべてのリストボックス」の「すべての要素」に対して，「SQLを実行したい」のですよね。 そう書かないと，プログラムはそのようには動きません。 私がANo.2で書いたコメントの位置を，勝手に別の場所に書いてもよいと解釈してはいけませんよ。
シートの状況、グラフの種類、ラジオボタン（オプションボタン）をどこに置くといった事を明示すれば、優しい回答者の方がこさえてくれるかもしれません。 ご要求通りという訳にはいきませんが、オートフィルタを使えばVBA要らずです。画像をご覧下さい。 下記は、興味本位に作成したもので、分かり易くも速くもないと思いますので、話の種程度です。 ワークシートに散布図（マーカーと線あり）が一つあり、元データも同一シートにあるとします。元データのある系列のセルでWクリックすると、該当するグラフの系列の表示・非表示が切り替わります。目的のシートモジュールに記述します。イベントマクロについては、参考URLをご覧下さい。 線の色とマーカーがエクセルお仕着せで変更になってしまう事があるのが難です。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Dim mySeries As Series Dim mychartobj As ChartObject Dim i As Long Set mychartobj = Me.ChartObjects(1) For i = 1 To mychartobj.Chart.SeriesCollection.Count Set mySeries = mychartobj.Chart.SeriesCollection(i) If Not Intersect(Target, Me.Range(Split(Split(mySeries.Formula, ",")(2), "!")(1))) Is Nothing Then Cancel = True With mySeries If .Format.Line.Visible = msoFalse Then .Format.Line.Visible = msoTrue .MarkerStyle = xlMarkerStyleAutomatic Else .Format.Line.Visible = msoFalse .MarkerStyle = xlMarkerStyleNone End If End With End If Next i End Sub ※ループをiで回しているのは、マーカーの種類をワークシートに保存しようとした時の名残です。最初にマーカーの種類を手動で決めてあれば、保存する価値もあるのですが．．． 参考URL：http://www.eurus.dti.ne.jp/yoneyama/Excel/vba/vb …
TextBoxにはLockedプロパティが無いようです。（VB.NETの場合） EnabledプロパティかReadOnlyプロパティで代用してください。
下記方法で元号の書式で他のセルに入力出来ます。 A1の日付データをB1に元号書式で入力 Range("B1") = Format(Range("A1").Value, "ggge年m月d日") 別シートでも可能です。 シート１のセルA1データをシート２のB2に入力 Worksheets("sheet2").Range("B1") = Format(Worksheets("sheet1").Range("A1").Value, "ggge年m月d日") コピペの後に書式変更するのであればB1の書式を元号にする方法は下記となります。 Range("B1").NumberFormatLocal = "ggge年m月d日"
http://msdn.microsoft.com/ja-jp/library/cc427964 … あたりを参考にしてください。 ・フォルダーの全ファイルを列挙 　・ファイル名が特定のパターンか？ 　　・ファイルの更新日を取得
保存した文書にないなら Normal.dotに保存されているんじゃないですかね？ Ｅｘｃｅｌの場合は「マクロの自動記録」を行なうと そのブックに記録されますけど、 Ｗｏｒｄの場合は＜すべての文書（Normal.dot）＞が デフォルトになってたりします。 またＶＢＥ画面でもNormalと文書の双方が 表示されているはずです。
> Form1からボタンで各画面に遷移するのですが、 > Form2でデータが入った状態でしか > Form3を開かないようにしたいのです。 やっぱりわからない。Form2とForm3はどう関係しているのですか？ Form2のFormLoadにForm3.Openを書いてあるの？ 「各画面に遷移」ということは、Form2を開くボタンと Form3を開くボタンがあるのですか？ Form1でボタンを押した処理そのものにMe.Close()を記述しているのでは？ 「Me=自分自身」だから、Form1にMe.Close()を書くとForm1.Close()です。
こんにちは！ 関数でできそうですが、VBAをお望みだというコトですので 一例です。 Excel2007以降のバージョンをお使いだという前提です。 Book1のデータは1行目からあるとします。 Sub Sample1() Dim i As Long i = Cells(Rows.Count, 1).End(xlUp).Row With Cells(1, 3).Resize(i, 1) .Formula = "=SUMIF([Book2.xlsx]Sheet1!A:A,A1,[Book2.xlsx]Sheet1!C:C)" .Value = .Value End With End Sub ※　Book1のC1セルに入れる数式をそのまま利用しています。 （Excel2003までのバージョンをお使いの場合は ＞=SUMIF([Book2.xlsx]Sheet1!A:A,A1,[Book2.xlsx]Sheet1!C:C) の ＞xlsx を ＞xls とします。 ※　Book1のC1セルに個の数式を入れそのままオートフィルでコピーでも大丈夫です。 （IF関数で空白の場合のエラー処理は必要になります） こんなんではどうでしょうか？m(_ _)m
接続先文字列は、テーブルアダプタのConnectionプロパティにあると思います。 接続先文字列には、サーバへの接続に必要な情報が書いてあるはず。 (1)ＤＢサーバ、(2)ＤＢ名、(3)ユーザ名、(4)パスワード これをＯＳ側で接続する設定をするのがＯＤＢＣ(Open DataBase Connectivity) コントロールパネル>管理ツール＞データソース（ＯＤＢＣ）で開けます。
こんにちは。 ＃２補足欄へのレスです。 確認が必要なことへのリターンや新たな情報 などが少なくて、応える（答える）力がなかなか湧きませんでした。 うまくリードしてあげられなくてゴメンナサイ。 > sheet1の例で言えることは、ModalのユーザフォームでCloseするとエラーになる、ということかなと 思いました。 そうではない、ことを説明する為に、『回避策２　　Modal版』を例として挙げたのですが、、、？ >>　つまりSheet1のイベントを実行中で、ブックを閉じることが出来ないのに >>　ブックを閉じようとすると、エラーになります。 ... >> 抜けるべきプロシージャを抜けないとブックを閉じられない 私が提示したテストで確認して頂きたかったのは、 「ブックを閉じられる状態を用意しないと、workbook.Close メソッドは失敗する」 という一般的なことと、 「ブックを閉じられない状態での、workbook.Close メソッドのエラー」 が、今回ご質問で問題となっているエラー、と同じ種類のエラーなのではないですか？ ということです。 >> ...ご提示のプロシージャの記述の問題ではなく... 呼び出し側の問題である可能性が高い、ということの検証を目的としたのが＃２です。 質問当初とも違う、＃２補足欄とも違う、視点を、質問者さんが切り替えた上で 解決（まずは原因）を質問者さん自身が探らないと、難しそうですね。 エラーの原因は、公開されていない部分にあるのですから。 　場合によってはUserFormそのものをUnloadしないとworkbook.Closeできない 　ようなControls（外部オブジェクト）の構成（設定）になっているのかも知れません。 　オブジェクトを扱っていて解放しなければならないアクセスとかコネクションとか 　が原因でworkbook.Closeできないのかも知れません。 　イベントドリブンからサブルーチンのネストが深すぎるのかもしれません。 　Excel一般機能を使用中で、ユーザーからの応答を待っている状態なのかも知れません。 　ただ単にシートイベントなどでCancelし忘れている単純ミスかも知れません。 　... 「ブックを閉じられない状態」は結構あるような、、、、 # それでいて詳細で整理された文献がある訳でもなく、私としても得意な訳ではありませんが、、、 まず、原因を付きとめることですし、原因を付きとめる為に何をすべきか、 ということなのだと思います。 　　ご提示のプロシージャの記述、以外の記述や各種プロパティ設定などで 　　「ブックを閉じられない状態」を作り出している部分はないか 　　ひとつひとつ慎重に確認していってみてください。 原因のひとつひとつは＃２のテストの例のように単純なものが多いので、 例えば、既存のブックのコピーを作成して、 記述を少しずつ削除（構文エラーやコンパイルエラーにならないように注意）しながら 都度都度実行して、原因を絞り込んでゆくとか。 "切り分ける"作業が必要なのかも、です。 後書きになりますが、 > 「ブックを閉じられない状態での、workbook.Close メソッドのエラー」 > が、今回ご質問で問題となっているエラー、と同じ種類のエラー であると "確認" できていれば、以上のような説明になりますが、 そうではない、ということなら、ただの無駄話になってしまいます。 ただ、解決への工程という意味では共通してる点も多いですけど。 次に補足があって、新たな局面を迎えて、私で役に立てるようなら、もう一度レスします。 今日は私も不調なので、この辺で。
こんばんは。 慣れてくると、これ邪魔なんですよねー。 VBE画面でツール→オプション→編集タブの 自動構文チェックを外して下さい。 エラー行は赤くハイライトされますがメッセージは出なくなります。 私もずっとこの設定です。 それでは。
こんにちは。お邪魔します。 この課題は少し使い分けを覚えておかないと 実践でこまることもあるので 一応、３パターンほど挙げておきますね。 　.Close メソッド 　.Save メソッド 　.Saved プロパティ ＶＢＡのヘルプを眺めておくだけでも、 さらに様々な状況に対応出来るようになると思います。 ' ' ブックを閉じながら、変更があれば上書き保存 Sub Re8064722() 　　ThisWorkbook.Close True ' Workbookオブジェクトを適宜指定（例示は自ブック） End Sub ' ' 変更があれば上書き保存して、ブックだけ閉じる Sub Re8064722a() 　　With ThisWorkbook ' Workbookオブジェクトを適宜指定（例示は自ブック） 　　　　If Not .Saved Then .Save 　　　　.Close 　　End With End Sub ' ' 変更があれば上書き保存して、アプリケーションごと閉じる Sub Re8064722b() 　　With ThisWorkbook ' Workbookオブジェクトを適宜指定（例示は自ブック） 　　　　If Not .Saved Then .Save 　　End With 　　Application.Quit End Sub
簡略化でも断片的でも実際に確認出来ない以上、何とも言いようがないかと。 取り合えず、マウスカーソル直下の要素を取得して、一番上の親のdocumentから列挙して比較するサンプル。 再帰処理のフレーム部分は環境が無かったので未確認。 (想像で書いてます) 参考URL：https://gist.github.com/kumatti1/46ccb4fda7be7b8 …
Ｎｏ．１です。 やりたい事が不明ですが もしかして再帰処理なんですかね？ フォルダ内のファイル一覧の取得 http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub0 … こちらはフォルダ内のファイル情報を取得してますけど、 同じようにフォルダ以下にあるフォルダ名を取得したいとか？
> RetVal = Application.Dialogs(xlDialogOpen).Show("*.txt") そもそもここはOpenFileDialogでよかないか、とは思いますがそれはさておいて。 ものすごーく大雑把な指針を示すと、 ・「複数ファイルを選択する方法」を考える ・「選択された複数のファイル」を繰り返し処理可能な形にする ・あとはforなりfor eachなりwhileなりでループ処理 って流れになります。
技術的には可能ですが、あなたがスムーズかつメンテナンスしやすいようにプログラミングできるかどうか、ちゃんと検証できるかどうかは別の話です。 テキストファイル出力方法、テキストファイル出力時の文字エンコード指定方法、ＯＳによる文字エンコード／ＢＯＭ／改行コードの違いを技術解説書等（Webサイトだと、Excelの学校、moug、Office TANAKA、インストラクターの独り言などがExcelの高度な使い方を知るには有効です）で勉強の上で、Excel VBAでプログラミングするか、いったん出力したＣＳＶファイルに対し、ファイル・コンバータやテキスト置換ユーティリティツール（nkfとか）で処理するか（ＦＴＰツールでも可）、TeraPad、秀丸エディタなどのテキストエディタでＣＳＶファイルを開いて、文字エンコードと改行コードを指定して保存しなおしても対応可能です。 運が良ければ、ＦＦＦＴＰのようなＦＴＰツールやnkfでWindows用のテキストファイルからたとえばＬｉｎｕｘ用のテキストファイルに変換しておしまいです。いずれにしろ、コンバート先のソフトが受け入れ可能なＣＳＶファイルの仕様定義書で、ほかにも事前チェックしておかないとまずいこと（日付書式、項目ごとの制約条件、最大行数、ファイル名規則など）が抜け落ちていないか確認してからでないと完了のめどが立たないでしょう。使ってみてから不足している機能や詰めが甘い仕様が判明する都度プログラムの修正が必要になり一進一退を繰り返すのは避けたいところです。 なお、ExcelのＣＳＶファイル出力は、Ｅｘｃｅｌで開く上では目立ちませんがバグっぽい点があるので、単純にSaveAsでxlCSVを指定して安心しないでください。ExcelがＣＳＶファイルに出力する単位はたしか１６行（バージョンによって異なる可能性があります。また新しめのバージョンで以下の問題が解消されている可能性もあります）で、１６行単位ごとにチェックして最大項目数を決めています。このためデータの入力がないセルが最終項目に１６行単位で連続してあるときは期待した最大項目数より少なく出力されてしまいます。逆に最終項目列の右側にあやまって入力したデータを削除してもダーティ・セルとしてマーキングされて、最大項目数より多く出力されることがあります。書式設定により数値データの右側に空白文字がつくケースもあります。ほかに悩ましいのが、Ｅｘｃｅlのワークシート上では正常に表示された文字や記号が、ＣＳＶファイルへの出力時にＵＴＦ１６ＬＢからＳＨＩＦＴ ＪＩＳ（ＭＳ９３２）へコンバートされることで文字化けする可能性が出てくること。round trip conversionが保証されていない符号類（代表例は、~）をデータに含んでいる場合も厄介です。ＣＳＶファイルに出力する前にエラーデータのあるセルを特定できる仕組みか、出力したＣＳＶファイルに対しエラーデータを全件特定できる仕組みがふつうは必要です。 インポート先のシステムが、定義しているインポート可能なＣＳＶファイルは、項目名つきか否か、データ項目値は二重引用符で括る（データ自体に二重引用符を含む場合はエスケープ処理を施す。この指定は、数値の書式に桁区切りカンマを使用しているなどデータ自体にカンマを含むことを許容している場合に必要になります）のか否か、特定項目の文字長や数値の有効桁数に制限があるか否か等、システムによって様々なので、対応可能なプログラムを自作するなり、業者に開発依頼して用意しておくことも検討するとよいと思います。
コンバータはあくまでコンバータなので，変更後のソースが正しいことは自分で調査する必要があります。 今回の場合では，コンパイルエラーにある通りです。 カーソルはSystem.Windows.Forms.Cursor型を使って保持しないといけません。 なので，lSv_Mouseの型をSystem.Windows.Forms.Cursor型に変更して下さい。 もちろん，それに伴って別の修正が必要になるかもしれませんが。
どうも。 Dim OndoR As Range '温度 Set OndoR = Range("温湿度[温度" & vbLf & "'[℃']]") '温度 例示のコードには半角スペースがありますが、 フィールド名の例示の方に合わせてスペースは抜いておきました。
＞Debugフォルダー内では正常に何回も動作し、Debugフォルダーから外すと、この様なエラーが出るので困って居ます。 同じPC内でこのような現象の原因として考えられるのは、次の２つ。 (1) exeファイルの他に、exe.configファイルが必要。 これは、プログラムの設定（画面コントロールのプロパティ等）をファイル保存するようにしている場合、exeファイルと一緒にexe.configファイルもコピーする必要がある。 (2) Debugフォルダー外として、保護されたフォルダを使っている。 例えば、「C:\Program Files」下のフォルダは全て保護されているので、プログラム実行時に一時ファイル等が作れない。 上記は該当しないですか？
あ、そか。 フィールド名が 　日付　　　温度 [℃] という意味で"[日付]"はエラーになってないのですね。 フィールド名全部"[]"で括りたいのかと思って読み違えてました。 失礼しました。
エラー修正に関しては＃１の方の通りです。 気になった点は、データ数が増減する可能性があるのであるのでしょうから、コース別VBAシートに抽出したデータを最初に削除する必要があります。又、抽出元データの増減にも対処が必要です。 両シートのデータがあるであろう列のデータが存在する最終行を取得し、データ削除又はforループの指定をする為に、変数「窓最大」「クラス最大」を追加したのが下記のマクロです。ご参考まで。 Sub コース別表示() Dim 窓, クラス As Worksheet Dim 引き取り As String Dim 縦, 行 As Integer Dim 窓最大, クラス最大 As Integer Set 窓 = Worksheets("コース別VBA") Set クラス = Worksheets("クラス出席番号順") 引き取り = 窓.Cells(3, 2).Value 'コース別VBAシート　C列の最終行を取得し、最終行が5以上であれば、B6～G列最終行までの値を削除する 窓最大 = 窓.Range("B" & Rows.Count).End(xlUp).Row If 窓最大 > 5 Then 窓.Range("B6:G" & 窓最大).ClearContents 'クラス出席番号順シート　C列の最終行を取得 クラス最大 = クラス.Range("C" & Rows.Count).End(xlUp).Row 縦 = 6 For 行 = 3 To クラス最大 If クラス.Cells(行, 9).Value = 引き取り Then 'クラス出席番号順シートのC列～H列の値をコース別VBAシートのB～G列に出力する 窓.Cells(縦, 2).Resize(, 6) = クラス.Cells(行, 3).Resize(, 6).Value 縦 = 縦 + 1 End If Next 窓.Activate End Sub
VB.NET ならハッシュテーブルの使い方が間違ってる。 VB6、VBAで hashtable という配列に入れているなら、ループ処理で検索しかない。 参考URL：http://www.atmarkit.co.jp/fdotnet/dotnettips/125 …
Visual Basic 6.0 は、 .Net の Visual Basic .Net とは別系統のプラットフォームです。 Visual Basic 6.0 は .Net 環境以前の開発プラットフォームです。つまり、i386 アーキテクチャの CPU に対応したネイティブアプリケーション開発環境です。 VB の歴史を簡単にまとめると 1991年 VB 1.0 初出荷 1992年 Windows 3.1 初出荷 1998年 VB 6.0 初出荷（Visual Studio 6.0） 2002年 Visual Basic .Net 出荷（ .Net Framework 1.0 ) 2005年 VB 6.0 メインストリームサポート終了 2008年 VB 6.0 延長サポート終了 と、まあ、VB 6.0 は 16 ビット OS の Windows 3.0 時代から（正確には、 MS-DOS の Basic 時代を引き継いでいる）の歴史を引き継いだ開発環境です。 この歴史も VB 6.0 でようやく終わりました。 VB 6.0 の開発者は .Net Framework の Visual Basic .Net に引き継がれ、すべてが万事うまく・・・いっていたら良かったのですが・・・。 VB 6.0 と Visual Basic .Net は言語仕様は配慮されていました。 それだけでした。既存のコードはまったく互換性が無く、行き場を失ったコードが停滞しています。 既存のコードを Visual Basic .Net で再開発するなんてことをお気楽にできるはずがなかったのです。 まあ、 NEC の PC98シリーズや DOS のアプリケーションや COBOL が生き残っているのと同じ状況です。 i386 (x86) アーキテクチャの CPU も当分、絶滅するようなことはないでしょう。（ .Net Framework は 脱 i386 アーキテクチャ、Go RISC アーキテクチャのための布石でもあるのでしょう） さて、本題ですが、要するに、「VB 6.0 のアプリケーションの再開発や保守を依頼されたが、 Visual Basic 20XX で開けないんですけど・・・」という状況ですよね。（たぶん） VB 6.0 の保守を行うには、 Visual Basic 6.0 を使います。（1998年製のソフトウェアです） 開発環境は Windows XP か Windows 2000, Windows Me, Windows 98 SE あたりがサポートされる OS のはずです。 最新の Windows 8, Windows 7, Windows Vista では不具合が出る可能性があります。 Windows Vista 以降は *.hlp ファイル（古いヘルプファイル）などがサポートされていないようですので Windows XP 以前をおすすめします。（追加のインストールやレジストリ設定の変更、互換モードの利用などが必要になるかもしれません。） 幸いにも、下記のMSDN からダウンロードできるようです。 >日本語版 Visual Basic 6.0 提供再開に関するご案内 >現在、日本語版 Visual Basic 6.0 は MSDN サブスクライバ ダウンロード サイトよりご利用いただけます。 >更新日: 2010 年 4 月 13 日 http://msdn.microsoft.com/ja-jp/subscriptions/dd … 最新の開発環境は無料で提供しても（Express）、古い開発環境は有料な感じなのはしゃくぜんとしませんが、まあマーケティング的に仕方ないですね。
myFileSystem.CreateFolder NewFolderName1 MkDir フォルダの作成を２回やっている。 FileSystemObjectの方は不要
http://www.atmarkit.co.jp/fdotnet/dotnettips/100 …
知識が無いんだったら作れないから市販ソフトを使いましょう。 ところでモデムはあるの？
>I列の背景が何もない場合その行のＡからＦまでのセルを薄い緑の背景にしたいのです。 　⇒I列が条件付き書式でセル背景が変化している場合、このコードでは確認できません。 　　よって、I列の色の有無を判定ではなく、色付けされる条件で判定すべきですね。
RemoveHandlerを使いましょう。 参考URL：http://dobon.net/vb/dotnet/beginner/eventhandle. …
会社では使ってるんですが、自宅のPCにはExcelが入っていないのでうろ覚えで回答します。 Private Sub WorkSheet_Change(Byval Target As Range) If Target.Address="$B$4" Then 　Select Case Target.Value 　　Case "もも" 　　　WorkSheets("Sheet2").Range("A2").Value=Range("C5").Value 　　Case "りんご" 　　　WorkSheets("Sheet2").Range("A5").Value=Range("C5").Value 　　Case "みかん" 　　　WorkSheets("Sheet2").Range("A8").Value=Range("C5").Value 　End Select End If End Sub でいけると思います。 ただし、これはC5に既に値段が入っていないと動作しません。 ＞もも、りんご、みかん のどれかが入力されます。そしてC5には単価が入力されています。 という質問文から、C5には予め単価が入力されているという前提で考えてあります。あと、フールプルーフは考えていませんので、C5に数値以外のものが入力されていてもやっぱり書き写してしまいます。 ま、上の構文の一部をちょっと変えればどのようにでも対応できますので、いろいろ自分で試してみてください。 それぞれの命令文の意味は確認した上で、試してみてくださいね。
初期状態設定中のフラグを立て、その間の各オブジェクトのイベントをキャンセルさせる。 初期状態設定が終わったら、フラグをおろして各オブジェクトのイベントを有効にする。 FormのTagでも利用すればよさそう。
bin\Releaseフォルダ内と思います。
"（ダブルクォート）で囲ってあるから、文字の大小を識別してるかも。 "SELECT * FROM item_data WHERE no=1"と書き換えたらどうなります？
こんばんは！ 色々やり方があるかと思いますが、一例です。 Private Sub Worksheet_Change(ByVal Target As Range) With Target If .Count = 1 Then Select Case .Value Case "●" .Font.ColorIndex = 3 Case "◆" .Font.ColorIndex = 50 '←「シーグリーン」にしました Case "★" .Font.ColorIndex = 38 '←「ローズ」にしました Case "◆★" .Characters(Start:=1, Length:=1).Font.ColorIndex = 10 .Characters(Start:=2, Length:=1).Font.ColorIndex = 38 End Select End If End With End Sub こんな感じではどうでしょうか？m(_ _)m
物事、分けて考えてみては？ １）「ある特定のフォルダに入っている複数のファイル」のすべてのシートを参照する。 ２）参照しているブックのシート名が「指定されたシート名」だった場合にコピーする。 １）のサンプルはネット上から拾えるはず。 ２）はマクロの記録で出来るはず。
こんにちは WebBrowserコントロールを使うとjavascriptを自由に実行して、値を取得できますが WebBrowserコントロールが使えない場合は少し時間がかかりますね。 WebBrowserコントロールを使ったサンプルです。 下記のhtmlから値を取得する場合です。 <!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/> <title></title> </head> <body> <form name="js"> <input type ="text"id="n1" name="t1" value="" /> <input type="text" id="n2" name="t2" value="" /> <input type="button" id="n3" name="b" value="値" onclick="st()"/> </form> <script type="text/javascript"> function st() { document.js.t1.value = "テスト1" document.js.t2.value = "テスト2" } </script> </body> </html> ＃簡単にするために各inputにidを付けていますので、idを手がかりにInvokeMember("click")でボタンをクリックしてjavascriptを実行します。 ＃input type="text"に値が表示されますので、GetAttribute("value")でinputの値を取得します。 ＃idの値を手がかりにしてinputの値を取得してListBox1に表示します。 Public Class Form1 Dim ur As String = "http://～～～～l" Private Sub f() Handles MyBase.Shown WebBrowser1.Navigate(ur) WebBrowser1.Visible = False 'WebBrowser1を非表示にする End Sub Private Sub WebBrowser1_DocumentCompleted(sender As System.Object, e As System.Windows.Forms.WebBrowserDocumentCompletedEventArgs) Handles WebBrowser1.DocumentCompleted ListBox1.Items.Clear() Dim txt1 As String Dim txt2 As String If sender.url.ToString = e.Url.ToString Then 'ボタンをクリックしてjavascriptを実行 WebBrowser1.Document.GetElementById("n3").InvokeMember("click") 'inputに値を入力 txt1 = WebBrowser1.Document.GetElementById("n1").GetAttribute("value") txt2 = WebBrowser1.Document.GetElementById("n2").GetAttribute("value") Dim wre As Net.WebRequest = Net.WebRequest.Create(ur) Dim wrs As Net.WebResponse = wre.GetResponse() Dim st As IO.Stream = wrs.GetResponseStream() Dim reader As New System.IO.StreamReader(st) Dim line As String line = reader.ReadLine Do Until IsNothing(line) 'idの値を手がかりにしてinputの値を取得してListBox1に表示 If line.Contains("id=""n1""") Then ListBox1.Items.Add(txt1) ElseIf line.Contains("id=""n2""") Then ListBox1.Items.Add(txt2) End If line = reader.ReadLine Loop reader.Close() End If End Sub End Class
下記マクロは,列番号１～90までの間で、選択された列（選択したセルでは無いのでお間違え無きように）以外の列を非表示にします。 チェックボックスを利用されるのであれば、 変数SelectCOLに表示させたい列番号、変数iに表示させる列数を指定すれば利用可能ではないでしょうか。 Sub Hidden_col() Dim c As Range Dim i, j, k, FLAG As Integer Dim ColNo As Integer Dim SelectCOL() ColNo = 90 ReDim SelectCOL(ColNo) i = 1 For Each c In Selection.Columns SelectCOL(i) = c.Column i = i + 1 Next c For j = 1 To ColNo FLAG = 0 For k = 1 To i If j = SelectCOL(k) Then FLAG = 1: Exit For Next If FLAG = 0 Then Columns(j).EntireColumn.Hidden = True Next End Sub
もし、入力規則のドロップダウンだけ消したくないなら、 if sp.Type<>.msoFormControl then sp.Deleteとか または、AutoShapeだけ消したいなら、 if sp.Type = msoAutoShape then sp.Delete　とか。 以上、ご参考まで。
※直接の回答ではないです。今手元にExcelがないため… Excelの機能で、「マクロの記録」というのがあります。これは記録開始から終了までの操作をマクロに落とし込む機能ですが、この機能を使って自分がマクロでやりたいことを操作として行うと、その内容がマクロに記述されていきます。 余計なもの(セルの移動とか、過剰なオブクジェクト指定とか)も入ってしまいますが、これを参考に余計な部分を削ったり、不足しているところを追加していくといいかと思います。
No2です。 一部コード抜けを訂正しました。 Private Sub WorkSheet_Change(ByVal Target As Range) With Target If .Count > 1 Then End Select Case .Address(0, 0) Case "C1" If .Value <> Sheets("祝祭日").Range("A1").Value Then MsgBox ("祝日の設定を反映するため年度を同じにしてください。") End If Case "G1" If .Value = 4 Or .Value = 1 Then メインデータの復元 '動かしたいマクロ名 End If End Select End With End Sub
とりあえず△の方をサンプルとして作りました。 ×の方はこれを改造してください。 Sub Sankaku() 　　'Sheet2の挿入位置(C列は結合セルではなく、必ず何か入っている事） 　　nMax2 = Sheets("Sheet2").Cells(Rows.Count, 3).End(xlUp).Row + 1 　　With Sheets("Sheet1") 　　nMax1 = .Cells(Rows.Count, 9).End(xlUp).Row 　　　　For i = nMax1 To 2 Step -2 　　　　　　If .Cells(i, 9) = "△" Then 　　　　　　　　'A～J列を移動対象とする 　　　　　　　　.Range(.Cells(i, 1), .Cells(i + 1, 10)).Copy 　　　　　　　　Sheets("Sheet2").Cells(nMax2, 1).Insert Shift:=xlDown 　　　　　　　　.Range(.Cells(i, 1), .Cells(i + 1, 10)).Delete Shift:=xlUp 　　　　　　End If 　　　　Next i 　　End With End Sub
Visual Basicをやりたいって事なら 今時の「Visual Studio Express 2012」に してみたら如何ですか？ 無料だし。 Visual Studio Express 2012 インストールの手引き http://homepage1.nifty.com/rucio/main/material/V …
http://www.crystal-creation.com/software/technic … Webサイトに有効期限を書いておく VBA起動時に毎回参照させる
Windows InstallerにしろClickOnceにしろ，レジストリを書き換えます。 なので，Setupプロジェクトを作ったのであれば，当然レジストリの書き込みがあります。 SetupプロジェクトはWindows Installerを利用して配置を行います。 また，セットアッププログラムは典型的に HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall の下にキーをひとつ作り，そこに値を書き込みます。 なお，Visual Studio 2010にvb.net/Visual Basic.NETは含まれません。 Visual Basicに.NETが付いていたのはVisual Studio.NET及びVisual Studio.NET 2003の時代のみです。
#1さんのやり方が王道だ、ということを十分承知の上で。 「メインのプログラムで、RANGE()= でワークシートに書き出して、 サブで必要な部分のデータを =RANGE() として取り出す」 せっかくワークシートに直接アクセス出来るんですから、有効に 使わない手はないです。Excel-VBAは、ワークシートにデータ を書き出し、ワークシート関数で処理させると速くて簡単、って ことが結構ありますよ。
dim array as Array 変数名を関数名と同じにしている点が気にはなりますが。。。
ちょっと見、エラーが分からなかったので試してみました。 試験用のブックで、下記のコード（Selectしない様にアレンジしています）で試しましたが、正常に実行できました。 ただし、オートフィルターで見出し行しか表示されていない（0個がみつかりました）場合や、MaxRowの取得が誤っている場合(MaxRow=1)の場合に、お示しのエラーが発生しました。そのあたりを確認される事をお勧めします。 Sub test() Dim retu As Variant Dim n As Long, MaxRow As Long Dim srcSh As Worksheet, dstSh As Worksheet Set srcSh = Sheets("Sheet1") Set dstSh = Sheets("Sheet2") MaxRow = srcSh.Range("A" & srcSh.Rows.Count).End(xlUp).Row retu = Array(1, 3) For n = 0 To UBound(retu) With srcSh Range(.Cells(1, retu(n)), .Cells(MaxRow, retu(n))).SpecialCells(xlCellTypeVisible).Copy End With dstSh.Cells(1, n + 1).PasteSpecial Paste:=xlValues, Operation:=xlNone, SkipBlanks:= _ False, Transpose:=False Next n End Sub
以下の事項は可能です。 ■選択したセルの値から、計算し、値を代入すること ■ショートカットキーでアドインを機能させること 但し、当方、線形補間のロジックが不明なので、完成できません。 ■線形補間の式を教えて下さい。 よろしくお願いします。
Index番号は、図形が削除されると振り直されるのでしょう。 Sub test() Dim oval1 As Shape Dim oval2 As Shape Set oval1 = ActiveSheet.Shapes.AddShape(msoShapeOval, 10, 10, 16, 16) Debug.Print ActiveSheet.DrawingObjects(oval1.Name).Index '1 Set oval2 = ActiveSheet.Shapes.AddShape(msoShapeOval, 40, 10, 16, 16) Debug.Print ActiveSheet.DrawingObjects(oval2.Name).Index '2 oval1.Delete Debug.Print ActiveSheet.DrawingObjects(oval2.Name).Index '1 　'番号が振り直されて2から1に変わってしまっている。 End Sub オブジェクト変数の配列に入れておけば、配列の添字でIndexで行いたかった様にアクセス出来ると思います。 下記は、Stopのところから継続実行させると、つつがなく全削除できます。ご参考まで。 Sub test2() Dim ovals(10) As Shape Dim myArray As Variant Dim i As Long, j As Long myArray = Array(10, 3, 1, 4, 7, 9, 5, 8, 6, 2) For i = 1 To 10 Set ovals(i) = ActiveSheet.Shapes.AddShape(msoShapeOval, 20 * i, 10, 16, 16) Next i Stop For i = 1 To 10 ovals(myArray(i - 1)).Delete Next i End Sub
MSDNに目を通しましたか？ http://msdn.microsoft.com/ja-jp/library/2b9cyk6x …
一例です。 SUMIFの検索範囲と合計範囲は合わせましょう。 "=SUMIF(F" & S860 & ":F" & S862 & ",""あああ"",I" & S860 & ":I" & S862 & _ ")-SUMIF(F" & S860 & ":F" & S862 & ",""いいい"",I" & S860 & ":I" & S862 & ")"
(1)について 利用するならば，アセンブリバージョンでしょう。 というよりも，setupプロジェクトの情報を取得するのは大変だと思います。 msi*系のWindows Installer APIを駆使すれば不可能ではないとは思いますが。 あと，アセンブリバージョンを単純に取得して表示すると，major.minor.build.revisionの形式になります。 必要な形式が何なのかによって，自前で整形する必要があるかもしれません。 (2) setupプロジェクトのバージョンは，Windows Installer Databaseである.msiに書き込まれます。 setup.exeは，基本的にシステムが生成する物なので，システムが用意したバージョンリソースにそのバージョンが書き込まれているのでしょう。 バージョンリソースを書き換えればバージョン情報を書き換えられますが，そこまでする必要は通常ないと思います。
もっと条件が有れば、線形計画法を使うという手も有るのですが、慣れないと（慣れても）難しいところがあるので、 手で表を作って、関数を使って、グループや人の配置のバランスを確認する方が現実的だと思います。 まず、グループを割り付け（グループの人数に比例した回数にする） 次に、人を割り付けていく。 割り付けられたグループの頻度や個人の頻度はEXCELの関数で求め、それを見ながらスケジュールを手で調整する 頻度の求め方は、この掲示板のデジタルライフ->ソフトウエアに何度も質問されていますので探してみてください。
Windows7 IE9ですが、↓で動きました Private Delegate Function D_EnumChildWindowsProc(ByVal hWnd As IntPtr, ByVal lParam As IntPtr) As IntPtr Private Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As IntPtr, ByVal hWnd2 As IntPtr, ByVal lpsz1 As String, ByVal lpsz2 As String) As IntPtr Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As IntPtr, ByVal wMsg As IntPtr, ByVal wParam As IntPtr, ByVal lParam As String) As IntPtr Private Const WM_ACTIVATE = &H6 Private Const BM_CLICK = &HF5 Private Const WM_GETTEXT = &HD Private Const WM_QUIT = &H10 Private Const NAVDIR_NEXT = &H5 Private Const NAVDIR_FIRSTCHILD = &H7 Private Const CHILDID_SELF = &H0 Private Const OBJID_CLIENT = &HFFFFFFFC Private Declare Function AccessibleObjectFromWindow Lib "oleacc" _ (ByVal hWnd As IntPtr, ByVal dwId As IntPtr, _ ByRef riid As Guid, <MarshalAs(UnmanagedType.IUnknown)> ByRef ppvObject As Object) As IntPtr Declare Function AccessibleChildren Lib "oleacc" _ (ByVal paccContainer As IAccessible, ByVal iChildStart As IntPtr, ByVal cChildren As IntPtr, <[Out]()> ByVal rgvarChildren() As Object, ByRef pcObtained As IntPtr) As IntPtr Private IID_IAccessible As Guid = New Guid(&H20400, 0, 0, {&HC0, 0, 0, 0, 0, 0, 0, &H46}) Sub FileDownLoad_Proc() Dim strCaption As String Dim PWnd As IntPtr Dim cWnd As IntPtr ' 親ウィンドウ取得 strCaption = "○○○○ - Windows Internet Explorer" While PWnd = 0 PWnd = FindWindowEx(0, 0, "IEFrame", strCaption) System.Threading.Thread.Sleep(50) End While ' 通知バーのハンドル While cWnd = 0 cWnd = FindWindowEx(PWnd, 0&, "Frame Notification Bar", vbNullString) System.Threading.Thread.Sleep(50) End While ' 通知バーボタン群のハンドル Dim hChild As IntPtr = FindWindowEx(cWnd, 0&, "DirectUIHWND", vbNullString) Dim objAcc As IAccessible = Nothing AccessibleObjectFromWindow(hChild, OBJID_CLIENT, IID_IAccessible, objAcc) If Not IsNothing(objAcc) Then ClickPreserve(objAcc) While cWnd = 0 cWnd = FindWindowEx(PWnd, 0&, "Frame Notification Bar", vbNullString) System.Threading.Thread.Sleep(50) End While SendMessage(cWnd, WM_QUIT, 0, 0&) End If End Sub Private Sub ClickPreserve(ByVal acc As IAccessible) Dim i As Long Dim count = acc.accChildCount Dim lst(count - 1) As Object If count > 0 Then AccessibleChildren(acc, 0, count, lst, 0) If Not IsNothing(lst) Then For i = LBound(lst) To UBound(lst) With lst(i) 'On Error Resume Next 'Debug.Print("ChildCount: " & .accChildCount) 'Debug.Print("Value: " & .accValue(CHILDID_SELF)) 'Debug.Print("Name: " & .accName(CHILDID_SELF)) 'Debug.Print("Description: " & .accDescription(CHILDID_SELF)) 'On Error GoTo 0 '保存ボタンを見つけたらクリック（デフォルトアクション）する If .accName(CHILDID_SELF) = "保存" Then System.Threading.Thread.Sleep(500) .accDoDefaultAction(CHILDID_SELF) System.Threading.Thread.Sleep(500) End If End With ClickPreserve(lst(i)) '再帰 Next End If End If End Sub
こんにちは。 Google マップで、仕様としてどこまで用意されているか、 ということさえも俄かには把握できない私です。 （因みに手作業でもマーカー（座標の一時的ブックマーク）の数に制限はあるようです） これまでの流れに合わせるならば、XML操作での解決を探るとか、 それとも、ご指摘頂いたようにWeb APIなどでの解決を目指す、 ということになるのかと思います。 （HTML操作だけでは解決できないような気がします。断言はできませんが。） ただ、そういうことになると、元々のご質問とはだいぶ離れてしまいますし、 私がサジェストできるものはもはや残っていない気がします。 解決に適した知識を募る意味で、 "Google マップのマーカー（バルーン）をVBAで設定" のようなタイトルで、今一度、真っ新な質問を建て直してみては如何でしょう。 力及ばずすみません。 尚、効果的で有用なサポートを続けて下さっているNo.10さんの方から もう少し、お話を引き出してみるのもきっと質問者さんの力になると思います。 早期の解決を祈りつつ、私はここまで、とさせて頂きます。 頑張ってください。
一発で取得する方法はありません。 再帰を使って数えて下さい。 # 再帰でなくてQueueでもStackでもいいけれども。 そもそも，フォルダに「ファイル数」なんてプロパティが物理的に存在しているわけではなく， 毎回(キャッシュはしているようだが)ディレクトリを辿って数えています。 子孫ディレクトリ数が多いディレクトリ(できたらネットワーク経由)のプロパティを表示してみると，数えていることがわかりますよ。
複合機の機種名が分かっても、 中身までは使っていないユーザには分からないでしょうね。 >マクロではＦＡＸ送信が記録されませんでした。 ActiveWindow.SelectedSheets.PrintOut Copies:=1, ActivePrinter:="プリンタ名" 上記の様なコードでプリンタを指定して印刷する事は可能です。 ＦＡＸの場合、送信先の番号が複数あるはずなので、 そのあたりがプリンタドライバにＶＢＡで渡せるかどうかにもよります。 しかし、プリンタのプロパティなどを表示させたりは可能ですが、 プリンタの設定まではＶＢＡではどうする事もできなかったはずです。
IE側の設定を変更してリダイレクトを抑止して保存するとか。 参考URL：http://social.technet.microsoft.com/Forums/ja-JP …
2010で使えるかわかりませんが DefSng A-G 参考 http://www.openreference.jp/?aid=253
すみません。編集ミスに気が付きました。 ＶＢＡコード冒頭の On Error GoTo 0 は、直後の End if の下の行にあるべきですね。 失礼しました。
こんにちは！ 横からお邪魔します。 安直な考え方ですが、一旦A1セルのデータを別セルに移動させ A1セルのデータが変更するたびにC1セルに「別セル」のデータを表示させる方法はどうでしょうか？ 仮に「別セル」をD1セルとした場合は Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$A$1" Then Range("C1") = Range("D1") '←D1セルはどこか使っていないセルに！ With Range("D1") .Font.ColorIndex = 2 .Value = Target End With End If End Sub この程度しか思いつきません。 他に良い方法があればごめんなさいね。m(_ _)m
参考になるかどうかですが、とりあえず Sub Macro1() Range("G3:I5").ClearContents For i = 1 To 6 Step 2 RETU = Range("G1:I1").Find(What:=Range("A" & i).Value, LookAt:=xlWhole).Column GYOU = Columns("F:F").Find(What:=Range("D" & i).Value - Range("B" & i).Value, LookAt:=xlWhole).Row Cells(GYOU, RETU).Value = Cells(2, RETU).Value Next End Sub G1~I1を検索して一致した列番号を取得 Ｆ列で、縦方向に検索して、日付の差と一致した行を取得 その行と列に、２行目の値を入れる Ａ列の最後まで２行おきに繰り返し といった風です。 エラー処理もありませんが、参考までに。
こんにちは。 これ案外、難しいですね。 ネックは、アンインストールしたアドインを Excel.Applicationのアドインのリストから削除する部分。 （そういうメソッドが用意されてない。） 移動後のアドインファイルの名前を変更しても良ければ、インストールまでは比較的簡単ですが。 私としては「VBS書いといて、スケジュールして、Excel.Applicationを閉じて、 VBSによりExcel.Applicationを再度開く」とか、 アイディアはあるのですが、書いて検証するまでの余裕が今ありません。 （検証に時間かけた方が良さそうですから。） 近々に自分の勉強の為、取り組むつもりではありますが、今のところ、 　『ユーザ定義関数(UDF)をVBAで完全にアンインストールしたい』 　http://www.excel.studio-kazu.jp/kw/2011092118361 … こちら↑を参考になさってみてください。 未解決のまま数日経って、私の方で進展あれば再度レスしてみますが、 とりあえず、参考URLで解決の目途は立つとは思っています。
No.1のものです。 間違いがあったので修正を。 フラグ(代わりに1を入れたセル)のクリアは(1)のマクロの最後でやら無いとダメですね。 すみません。 つまり、(1)を Private Sub Worksheet_Change(ByVal Target As Range) if (邪魔にならないセル)<>1 今までの(1)の処理 else (邪魔にならないセル)="" end if End Sub (2)を Private Sub CommandButton_Click() (邪魔にならないセル)=1 今までの(2)の処理 End Sub と言う感じです。どうでしょうか
32bit版Excelを使用する(インストール時に特に指定しなければ32bit版が入っている) http://office2010.microsoft.com/ja-jp/word-help/ …
Private　Sub Userform_Initialize() ここでリストボックスにデータを入力するようにします。 End Sub そのあとで Private Sub CommandButton1_Click() UserForm1.Show (このあとリスト項目のコード)←　ここでは必要ありません。 End Sub
配布先でインストール作業が発生しないデータベース製品となると Microsoft の SQL Server など Microsoft 製品になります。（データベースアクセスに必要な情報を Excel ファイルにもたせるとして） 他者の製品を使うとなると、クライアントにどうしてもドライバやプロバイダなどをインストールする必要があります。（今回の要件には適合しませんが、 Oracle データベースに限ってはマイクロソフトが読み取り専用のプロバイダを提供しています。これはインストール済みです。フル機能のプロバイダは提供しようと思えばできるでしょうが商売敵ですからね。） 他者の製品を使いながらインストール作業を回避するとなると、データベースアクセスの前にアプリケーションサーバのレイヤを配置して HTTP 関係のプロトコルで通信を行う（いわゆる WebAPI みたいな構造にします）方法が考えられます。つまり、ブラウザの代わりに Excel がその役目を果たします。 つまり、データベース製品の問題ではなくアーキテクチャの問題かと思います。 ２層構造のアーキテクチャでは、クライアントのインストール作業はほぼ必須です。（前述のマイクロソフト製品を除いて）このため、インストール作業はできるだけ自動化することが望ましいです。 ３層構造のアーキテクチャでは、クライアントのインストール作業は（すでにインストールされているソフトウェアを使用するため）軽減されます。（ソフトウェアの設定が必要になることがあります）
回答３より、 同一シート内で作業するなら、A,B列に行挿入して作業列として使えばいいと思います。 １）A,B列に行挿入 ２）B列に連番を振る（後で戻す時のために） ３）D列の値でソート ４）ループしながらA列に順位を振る ５）A列のセルの値が４になったらループ終了。 そのセルより上の行にあるD列の値をコピーしてF列にはる。 ６）元の表をB列の値でソート ７）A、B列を削除して終了。 Sub test() Dim i As Integer, j As Integer Columns("A:B").Columns.Insert i = Range("C65536").End(xlUp).Row For j = 1 To i Range("B" & j).Value = j Next j Range("B1").Sort Range("D1"), xlAscending Range("A1").Value = 1 For j = 2 To i If Range("D" & j).Value = Range("D" & j - 1).Value Then Range("A" & j).Value = Range("A" & j - 1).Value Else Range("A" & j).Value = Range("A" & j - 1).Value + 1 If Range("A" & j).Value = 4 Then Range("C1:C" & j - 1).Copy Range("F1") Exit For End If End If Next j Range("B1").Sort Range("B1"), xlAscending Columns("A:B").Delete End Sub マクロなしでどうやってマニュアル作業で行うかを考える力をつけるべきかと思います。 作業列、作業用シートはエクセルではよく使います。 この回答も回答３からの応用でできますよ。 、
SMTP認証は正しく行われているのでしょうか？ というか、それ以前にちゃんとサーバに接続できているのでしょうか？ 最近だとOP25Bで接続自体できない。なんてパターンがあったりしますが。 http://ja.wikipedia.org/wiki/Outbound_Port_25_Bl … http://www.yahoo-help.jp/app/answers/detail/p/56 … では… >14. [サーバーのポート番号]の[送信メール（SMTP）]に「587」を設定します。 とかなっていたりしますけど……。
描画処理は重く、それを改善する方法やメモリを直接管理 する方法があまりない(VBが裏で勝手にやっちゃう)ため、 VB では不向きなジャンルですが、やるとしたら１でしょう。 System.Drawing.Graphics クラスを使って自前で描画していく事に なりますので、基本的に Picturebox である必要さえありません。 …ただし、描画した画像の保存等で使える機能がありますので、 Picturebox １つの上に描くのでいいですが。 車を描く部分は Picturebox より Graphics をキーワードに Web 検索するとサンプルコードなどが手に入りやすいです。
APIを使う方法もありますね。 参考URL：https://gist.github.com/kumatti1/4028479
Evaluateが使えるのはワークシート関数だけのようです。 Findはワークシート関数ですが、Application.WorksheetFunction.を付けるとVBA関数になってしまいます。 term02 = "Find(""D"",""ABCDE"")" でうまくいきませんか？
PostBuildEventを使います。 とりあえず，こんな感じで。 IF EXIST "$(ProjectDir)$(Configuration)\abc_setup.exe" DEL "$(ProjectDir)$(Configuration)\abc_setup.exe" IF EXIST "$(ProjectDir)$(Configuration)\setup.exe" REN "$(ProjectDir)$(Configuration)\setup.exe" abc_setup.exe
Application.Callerは 図形（２００３版までのオートシェープ）をクリックしてマクロを実行するときに使います。 使い方を勘違いしているようです。 標準モジュールに書くなら このようにしてください。 Sub 角丸四角形1_Click() namae　'Sub namae() を呼び出します End Sub Sub namae() Dim namae1 As String Dim namae2 As String namae1 = Application.Caller namae2 = Sheet1.Shapes(namae1).TextFrame.Characters.Text MsgBox namae2 End Sub あるいは普通に登録するなら。 図形を配置して右クリック、 マクロの登録　→　新規作成　→　OK 下記のように。 （上の書き方より、ふつうはこちらを使います。） Sub 角丸四角形1_Click() Dim namae1 As String Dim namae2 As String namae1 = Application.Caller namae2 = Sheet1.Shapes(namae1).TextFrame.Characters.Text MsgBox namae2 End Sub
う～ん。 TCPを使うって一言で言っても、説明しなければいけないことが多すぎて・・・。 とりあえずネットで見つけたサンプルと説明。 http://dobon.net/vb/dotnet/internet/tcpclientser …
単にリンク（ハイパーリンクではない）なら、各セルの数式内にリンク先のファイルが 書かれているだけなので、 Ａブックでリンクを書いてあるセルを１個ずつ調べて （調べ方は、cells(行番号,列名).formulalocalを見て、B～Dブックのファイル名があるかどうかしらべればいい）、もしくは無条件で、 cells(行番号,列名).formulalocal = replace(replace(replace(cells(行番号,列名).formulalocal,"Ｂのファイル名","1のファイル名"),,"Cのファイル名","2のファイル名") ,"Dのファイル名","3のファイル名") と式をセットしなおしすればいいはず。 （ただし、Ｂのファイル名とかが、関数名等とかぶると誤動作するので、.xlsまで置き換える。）
Sub sample() Dim dic As Object Dim lastRow As Long Dim r As Long Dim key As String Set dic = CreateObject("Scripting.Dictionary") 'Dictionaryオブジェクト lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 'データ収集 For r = 3 To lastRow '3行目から最終行まで If Year(Cells(r, "D").Value) = 2010 Then '日付が２０１０年ならば key = Range("A" & r).Value & Chr(0) & Range("Z" & r).Value 'キー値はA列注目行の値+Z列注目行の値(間にchr(0)) If Not dic.exists(key) Then 'キー値が無ければ dic.Add key, 1 'キーを追加して、値(個数)を１に Else '既にキー値があれば dic(key) = dic(key) + 1 'そのキーの値(個数)+1 End If End If '★追加 Next '表示 For r = 3 To lastRow '3行目から最終行まで key = Range("A" & r).Value & Chr(0) & "1" '探す値はA列注目行の値+"1"(間にchr(0)) Range("BW" & r).Value = dic(key) 'BW列にその値(個数)を表示 Next End Sub みたいな事ですか？
行挿入ではなくコピー＆ペーストを使う方法。 セル範囲の開始行から数えてｉ行目のデータは開始行から数えて2×ｉ行下にずれることを利用。 Sub test() Dim toprow As Long Dim i As Long If TypeName(Selection) <> "Range" Then Exit Sub toprow = Selection(1).Row For i = Selection.Rows.Count - 1 To 1 Step -1 Range(Cells(toprow + i, 5), Cells(toprow + i, 7)).Copy Cells(toprow + 2 * i, 5) Range(Cells(toprow + i, 5), Cells(toprow + i, 7)).ClearContents Next i End Sub
こんにちは。 どちらもコンパイルエラーということで宜しいでしょうか？ とりあえずTypeステートメントの方は、 ' ' /// #If VBA7 And Win64 Then Type PRINTER_INFO_1 flags As LongPtr pPDescription As LongPtr pName As LongPtr pComment As LongPtr End Type #Else Type PRINTER_INFO_1 flags As Long pPDescription As Long pName As Long pComment As Long End Type #End If ' ' /// End Typeが漏れているという単純なミス。 64ビットＶＢＡ７（Office2010）／64ビットＷｉｎ７環境では 正しくコンパイルされることを確認しました。 Declareの方は 64ビットＶＢＡ７ではPtrSafeキーワード抜きでDeclare文を記述するだけで、 条件付きかどうかを問わず、問答無用でコンパイルエラーとなります。 対策があるかどうかは残念ながら存じ上げません。 ただ、32ビット用のDeclare分だけをコメントブロックすれば、 条件付きのDeclareがコンパイルされていることは確認できました。 従って問題点は、32ビット用のDeclareを 64ビットＶＢＡ７で如何にして条件付きコンパイルに組み込むか の一点に整理されます。 私はこれまで出来ないものと思い込んでいましたし、 これといって情報も持ってないのですが、 何かの情報をお持ちで、それを元に着手した、ということなら、 そこら辺を紹介なさったら、識者のコメントが付く可能性は高まるかと思います。 私はプリンターの扱いも不得手なので、例えば、 代替え案を提示するにも至りません。 お役に立てず、すみません。
Windowsのプログラムで、ベーシックな 方法により文字列を表示するのは相当 やっかいで、込み入った処理が必要 ですが、VBではとても簡単です。 テキストボックスにあるＴｅｘｔプロパティに 値を入れるだけです。 ボタンのイベントプロシージャ内で、以下の ようにします。 Private Sub Button_Click(～ Me.テキストボックス.Text = "ABC" End Sub
＃１補足欄への返信です。 > 検証はしましたが今回の問題とのつながりがわかってはいません。 「ピボットテーブルで同じ”11”が2つ存在する」 というのが 「今回の問題」 ですよね？ 単純化すると、 「2つ」のうち、１つは【数値】、１つは【文字列値】、なのではないですか？ということを書きました。 例えば、その日付がＣ３セルにある場合、適当な空いてる列を使って、 　=ISTEXT(C3) という数式の戻り値に相違がないか確認してみては如何でしょう。 　見た目の【表示】は "11" 。　【値】が【文字列値】の "11" ならば、TRUE 　見た目の【表示】は "11" 。　【値】が【数値】の 11 ならば、FALSE 相違が見られたならば、どちらかに統一する方法は難しくないですよね。 ＶＢＡの Format 関数については既述の通りで補足しなくてもいいと思います。 今回の補足を加味すると 　見た目の【表示】は "11" 。　【値】が【文字列値】の "11" 。 　見た目の【表示】は "11" 。　【値】が【文字列値】の " 11" 。 と、目に見えない半角スペースが紛れているケースも考えないといけないのですかね。 この場合は 　=C3="11" という数式で確認もできますが、 ワークシートメニューの[検索・置換]機能で、検索値に半角スペースを指定するだけで 確認から解決まで容易にできると思います。 ／／／ > TextBox10.Text = Str("01") > > としたときにテキストボックスに「01」ではなく「1」と表示される問題でつまづいています。 〓〓〓〓〓〓〓〓〓以下ＶＢＡヘルプから引用〓〓〓〓〓〓〓〓〓 Str 関数 バリアント型 (内部処理形式 String の Variant) の値を返します。 数式の値を文字列で表した値 (数字) で返す文字列処理関数です。 構文 Str(number) 引数 number には有効な数式を長整数型 (Long) で指定します。 この引数は必ず指定します。 解説 数値を文字列に変換すると、戻り値の先頭に符号を表示するためのスペースが常に確保されます。 数値が正の場合は、Str 関数の戻り値の先頭にスペースが挿入されます。 このスペースはプラス記号を意味します。 日付、時刻、通貨、ユーザー定義の書式などで数値を書式設定するときに、Format 関数を使います。 Str 関数と異なり、Format 関数を使用して変換した場合は、 引数 number の先頭にスペースは挿入されません。 メモ Str 関数は、ピリオド (.) だけを有効な小数点記号として認識します。 異なる小数点記号を使用する場合は、CStr 関数を使って数値を文字列に変換します。 〓〓〓〓〓〓〓〓〓以上引用（改行は筆者）〓〓〓〓〓〓〓〓〓〓 　　　　要点整理 　　Str 関数の引数は「数字」ではなく【数値】です。 　　Str 関数の戻り値は「数字」【文字列値】です。 　　数値が正の場合は、Str 関数の戻り値の先頭にスペースが挿入されます。 まず、Str 関数は本来【数値】を【文字列値】に置換する為の関数です。 なので、= Str("01")　のような使い方をするものではありません。 TextBox10.Text に "01" を設定したいということなら、 　TextBox10.Text = "01" または 　TextBox10.Text = Format(1, "00") です。 【数値】を指定するべき引数に【文字列値】を指定した場合、 引数の【文字列】が「数字」として読めるならば、 自動的に引数の「数字」を【数値】に置換する機能（型のキャスト）が働きます。 よって、 > TextBox10.Text = Str("01") は、 　TextBox10.Text = Str(1) と命令しているのと同じことになります。 > ......テキストボックスに「01」ではなく「1」と表示される...... = Str(1) の戻り値は先頭に半角スペースがある ■ 1■ です。■01■でも■1■でもありません。 Str 関数の使い途としては、 　　【数値】（正整数）を【文字列値】に変換しながら、先頭に半角スペースを付加する というのが現代的な存在理由で、他の使い方をする例はここ数年見かけません。 ／／／ 確認しておいて欲しいのですが、 今回の＃１、そして前スレ、どちらも『セル』の【値】と【表示形式】と【データ型】の話をしました。 『TextBox』は『セル』とは異なり、 「もっぱら【文字列値】を扱う」もので、他は関係ありません。 ／／／ Str 関数が一連の質問とどのように関連付けされるのか、質問者さんにしか判らないことのように思います。 ＶＢＡの関数やプロパティなどを覚えたい、ということならば、 それぞれの関数やプロパティなどの用途・目的・条件・用法などの基本的な部分は 教本や辞書など（書籍、Webページ、ＶＢＡヘルプなど）を頼りに覚えた方がいいです。 質問掲示板は色々な人が色々な意見を書く場所で、良い面も多くありますが、 初歩的なことを学ぼうという人にとっては、一貫性がない、という負の面もあります。 ／／／ ＶＢＡを書き上げる力、というか、上達する為の指標、というか、私流儀の紹介になってしまうのかも知れませんが 「何をしたいのか自分に問うて、自分自身に説明してみる」 「目的を明確にして、目的に適した道具（例えば関数やプロパティ）を選ぶ」 「とにかく動くようになるまで書き上げることに集中する」→あらためて検証する。 といった決め事が、息詰った時に私を助けてくれる私のサブルーティンです。 ／／／ 大変でしょうけれど、自分を信じてひとうひとつ覚えていくしかありあせん。 頑張ってください。 それでは、また。
こんばんは。 COMBXはString型ですか？ 残念ながらその使い方は出来ません。 変数COMBXをComboBox型で宣言して使います。 Dim COMBX As MSForms.ComboBox If MultiPage1.Value = 0 Then Set COMBX = Me.ComboBox1 ElseIf MultiPage1.Value = 1 Then Set COMBX = Me.ComboBox7 End If name = "シート名" Set ws = ThisWorkbook.Worksheets(name) i = 2 Do Until ws.Cells(i, 9) = "" COMBX.AddItem ws.Cells(i, 9).Value　**********ここでエラー i = i + 1 Loop コントロールを名前で扱いたい時は Me.Controls("ComboBox1").AddItem とか Dim COMBX As String COMBX = "ComboBox1" Me.Controls(COMBX).AddItem でもいいですよ。 ※ Me.　と書きましたが、このコードがUserFormではなく標準モジュールにある場合は UserForm1.Controls("ComboBox1").AddItem と対象オブジェクトを書いて下さい。
?environ・・・でもしかしたら、D/D:\windows が返ってくるかも？と思った次第です。 これはこれで困った状態なのですが。 『管理者として実行』でエラーにならなかったので、 やはり、UAC 絡みの問題と思えてしまいます。 対処方法ですが、望ましいと思われる順です。 ・社内のシステムの管理者さん？に診てもらって根本的に解決する。 ・ドライブ直下に置く運用を止める。 ・#1 さんの方法で問題なければ、これで進める。 ・MSAccess.exe のショートカットを作成し、これを右クリック 　プロパティ→ショートカットタブ→「詳細設定(D)」クリック 　管理者として実行にチェックを入れて、OK 　このショートカットを 　C:\Users\あなたのアカウント名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup 　フォルダにコピーする。（デスクトップでも可） 　（毎回確認画面が出て鬱陶しいです。。） ・UAC の設定を変更する。セキュリティレベルが下がり、WindowsXP時代に逆戻り。 　http://www.sakyou.com/ManualShop/Windows/05_User … ミスリードして状況を悪化させる訳には行かないので、私からはこの辺が限界です。
こんにちは。お邪魔します。 「どうしても文字列でなければならない」理由は見当たらないようですし、 「数値であれ文字列であれ統一されること」こそ肝要ということのようですが。 ◆１　「数値で扱えるものは数値」という合理主義で、、、 セルの書式・表示形式を設定する"一回永続的な"処理 　Range("A2:A25").NumberFormat = "0000" 　Range("B2:B25").NumberFormat = "00" 既存のセル値を数値に統一する"一時的な"処理 　Range("A2:B25").Value = Evaluate("--A2:B25") 各セルの値を設定する"日常的な"処理 　Range("A" & X).Value = Year(Date) 　Range("B" & X).Value = Month(Date) どうしても文字列、と、訳あり、な場合で、、、 ◆２　「何が何でも文字列を堅持するように扱いたい」という保守主義で、、、 セルの書式・表示形式を設定する"一回永続的な"処理 　Range("A2:B25").NumberFormat = "@" 既存のセル値を文字列に統一する"一時的な"処理 　Range("A2:A25").Value = Application.Text(Range("A2:A25"), "'#") 　Range("B2:B25").Value = Application.Text(Range("B2:B25"), "'00") 各セルの値を設定する"日常的な"処理 　Range("A" & X).Value = "'" & Year(Date) 　Range("B" & X).Value = Format(Date, "'mm") ◆２　「とりあえず文字列になればいいや」という楽観主義で、、、 セルの書式・表示形式を設定する"一回永続的な"処理 　Range("A2:B25").NumberFormat = "@" 既存のセル値を文字列に統一する"一時的な"処理 Range("A2:A25").Value = Application.Text(Range("A2:A25"), "#") Range("B2:B25").Value = Application.Text(Range("B2:B25"), "00") 各セルの値を設定する"日常的な"処理 　Range("A" & X).Value = Year(Date) 　Range("B" & X).Value = Format(Date, "mm") 【セル範囲の指定については適宜。左辺右辺ともに。】 何れの場合も、手作業で値を設定する時には、セルの書式・表示形式を変更しないよう注意が必要。 コピーしたものを貼り付ける時は、値のみ貼り付けするようにする、など。 他に検討するべきこととして、 そもそも日付は日付のままにした方がピボットテーブルでも扱い易いような気がしますけどどうでしょ。 （、、、ピボットテーブルは不得手な私ですが） セルの書式・表示形式で表示される成形すること、と、 値は本来あるべき型の値で扱うことを優先するべきこと、と、 まぁ、もし状況が許すならば、シートの設計を見直すのもありかも知れません。 、、、日常的な処理が簡潔になる方向で。 以上です。
こんにちは！ こういうコトでしょうか？ Private Sub CommandButton1_Click() If CheckBox1 = True Then Range("B2").End(xlDown).Offset(1) = CheckBox1.Caption CheckBox1 = False End If If CheckBox2 = True Then Range("B2").End(xlDown).Offset(1) = CheckBox2.Caption CheckBox2 = False End If If CheckBox3 = True Then Range("B2").End(xlDown).Offset(1) = CheckBox3.Caption CheckBox3 = False End If End Sub 外していたらごめんなさいね。m（_ _）m
回答１～３をした者です。 私が訂正したところが直っていれば正しく走ると思うのですが。 （win7pro32bit,　xl2003で確認） Sub test() Dim c As Range Dim i As Integer For Each c In ActiveSheet.Columns(2).SpecialCells(xlCellTypeVisible) i = i + 1 If i = 6 Then　　'←1行目はヘッダー行なので c.Select Exit Sub End If Next End Sub
こんばんは！ 表示するSheetは必ずSheet見出しの最後のSheetですよね？ 一例です。 標準モジュールに↓のコードをコピー＆ペーストしてマクロを実行してみてください。 Sub 表示() Dim j As Long, k As Long, cnt As Long, wS As Worksheet Set wS = Worksheets(Worksheets.Count) With wS j = .Cells(2, Columns.Count).End(xlToLeft).Column If j > 2 Then Range(.Cells(2, 3), .Cells(3, j)).ClearContents End If cnt = 2 For k = 1 To Worksheets.Count - 1 cnt = cnt + 1 .Cells(2, cnt) = Worksheets(k).Cells(2, "AS") .Cells(3, cnt) = Worksheets(k).Cells(8, "AZ") Next k End With End Sub こんな感じではどうでしょうか？m(_ _)m
Excel VBAでは、 >Dim arr() As Integer= {0, 1, 2, 3, 4, 5} Excelでは、変数に直接代入しませんし、 >Console.WriteLine (i) これもありません。 >これって何でエラーになるのでしょう？ 一度、VBAのテキストを御覧ください。VBAは、VB.Netとは違います。 あまりに初級すぎて、教えるのが辛いです。
入力フォームを初期化するときに ListBox1.Index=-1を加えればいいでしょう。 「'データをクリア」の部分にかなと思います。
＃３です。 すみません、提示したコード、ミスってましたので直しました。 それと、混乱するといけないので参照設定しないで済む書き方に替えました。 Sub Re8013103j() ' ' 正規表現を使って ' ' 「数字」「スペース」「数字」を ' ' 「数字」「-ハイフン」「数字」に置換 ' ' 該当するセルだけを置換（改） ' ' 「○○２ ３ ４」のような場合は２度置換（改） 　　Dim oRegExp As Object 　　Dim r As Range 　　Dim s As String 　　Set oRegExp = CreateObject("VBScript.RegExp") 　　With oRegExp 　　　　.Global = True 　　　　.Pattern = "([\d０-９])[\s　]+([\d０-９])" 　　　　For Each r In Range("A2:A6") ' セル範囲は適宜指定 　　　　　　s = r.Value 　　　　　　If .test(s) Then 　　　　　　　　s = .Replace(s, "$1-$2") 　　　　　　　　If .test(s) Then 　　　　　　　　　　s = .Replace(s, "$1-$2") 　　　　　　　　End If 　　　　　　　　r.Value = s 　　　　　　End If 　　　　Next 　　End With 　　Set oRegExp = Nothing End Sub Wordの方も一発置換ではなかったですね。 ７）[すべて置換]を２度押す でした。失礼しました。
当方が利用したことがあるわけでは無いのであやふやで申し訳ありませんが、 VisualStudioで作成したと書かれているインストーラに対して、 独自のインストール処理のコードを追加できるのであれば、 DIFxAPIなどを利用したコードを記述し、 インストールする処理を実装できるのではないかと思われます。 別のより簡単な方法として、Windows Driver Kit (WDK)に含まれる 「DPInst」を利用してドライバパッケージとしてインストールする方法があります。 DPInstはWDKに含まれる、再頒布可能な実行ファイルの形式で、 ドライバinfファイルとドライバファイル群(これら一式をドライバパッケージと呼ぶ) をインストールウィザードのような形でインストールするものです。 また、アンインストールのためにプログラムの追加と削除のエントリも作成されます。 DPInstがサポートする環境はWindowsXP以降となります。 (DIFxAPI なり DPInst で)ドライバパッケージとしてインストールを行うと、 ドライバストアというところに保存され、機器が実際に接続された際に XPの場合は一旦ハードウェア検出ダイアログが表示されてから自動検索をさせれば、 Vista以降の場合は自動的に検索が行われてドライバのインストールが行われます。 当方で利用したことがあるのがWinUSBドライバのインストールで、 他の場合も同じように行えるかまではわかりませんが、 DPInstを利用する場合の最も単純な使用方法としては、 インストール先OSのアーキテクチャ(x86またはamd64)に一致するdpinst.exe ドライバinfファイルおよびドライバ本体ファイル そして「dpinst.xml」という名称の以下のようなテキストファイルを 1つのディレクトリに配置してdpinst.exeを実行します。 # ちなみに、ドライバパッケージに署名が無い場合、赤い警告画面は出てしまいます。 dpinst.xml例 ---------- <?xml version="1.0"?> <dpInst> <enableNotListedLanguages/> <legacyMode/> </dpInst> ---------- おそらく上記記載のみではいろいろ足りないことがあるかと思いますが、調査の際の導線にでもなればと思います。
No.2です。 少し変更しました。 質問者様のご希望は、Outlookのフォルダのウィンドウがあれば新たに開かない、というものと思いますのでそのようにしました。 （No.2のコードでは受信トレイ以外のフォルダが開いていると、新たに受信トレイのウィンドウが開いてしまいます。） Sub Sample2() Dim oApp As Outlook.Application Dim myNameSpace As Outlook.Namespace Dim myFolder As Outlook.Folder 'outlook 起動をCreateObjectで ※フォルダのウィンドウがあるなら一応開かないようになった Set oApp = CreateObject("Outlook.Application") '参照設定済みのようなので Set oApp = New Outlook.Application でもいいかも Set myNameSpace = oApp.GetNamespace("MAPI") 'outlookのフォルダのウィンドウがすでに存在するならそのうちの１つをmyFolderにSetし、 'なければ規定のフォルダを得る。 If oApp.Explorers.Count > 0 then Set myFolder = oApp.Explorers.Item(1).CurrentFolder.FolderPath Else Set myFolder = myNameSpace.GetDefaultFolder(6) '規定のフォルダー olFolderInbox=6 指定 End If myFolder.display End Sub なお、No.1様解説のGetObjectでうまくいくならばその方が私の回答よりも良いと思います。
shape.TopLeftCellはRangeオブジェクトになるので、 ここではshape.TopLeftCell.Addressとするのでは？ If Not Intersect(Range(sp.TopLeftCell.Address, sp.BottomRightCell.Address), myRng) Is Nothing Then で通ると思います。
＞(中断モードで実行することはできません。) VBAウインドウにある停止ボタンをクリックで解除しましょう。 処理を以下で囲ってください。 マクロでセル変更をしてもWorksheet_Changeが呼び出されることに注意してください。 Application.EnableEventsは、マクロ内の書き込みでのマクロ再呼び出しを制御するものです。 Private Sub Worksheet_Change(ByVal Target As Range) If Intersect(Target, Range("D1")) Is Nothing Then Exit Sub '検査範囲 Application.EnableEvents = False　'再帰実行の停止 '処理 Application.EnableEvents = True End Sub
#1さんのように突っぱねることが、本来は親切なのだと思います。ただ、掲示板というのは、締め切りはあっても、書かれたものは、時間というものが存在しない世界(一期一会）ですから、回答をせざるを得ないのは、ご容赦願います。 以下は、ある程度マクロが書ける人なら、考えつくはずです。 本来は、マクロの実行中に、割り込みが利かないのですが、なぜ可能なのか分かりますか？ それが分かりさえすれば、割り込み方法も思いつきます。 '// Dim blnSw As Boolean 'スイッチ Private Sub CommandButton1_Click() 　Dim EndTime As Double 　Dim PassTime As Double 　EndTime = Timer + Range("D5").Value * 60 + Range("F5").Value 　Do 　　PassTime = Timer 　　Range("D5").Value = (EndTime - PassTime) \ 60 '分 　　Range("F5").Value = (EndTime - PassTime) Mod 60 '秒 　　DoEvents 　　If blnSw Then blnSw = False: Exit Sub 　Loop Until EndTime - PassTime <= 0 　Beep 　MsgBox "時間です" End Sub Private Sub CommandButton2_Click() '途中で止める 　blnSw = True End Sub
フレームセットを使ってるページで各フレームのURLを得るなら、 > ObjIE.Document.URL で、メインのURLなら > ObjIE.LoactinURL て使い分けでは。
今回のビルドは、２回目以降のビルドなのでは？ 「前回のビルドで作られたものそのままで行けるから、今回は更新する必要が無いものがあった」 だと思います。
http://msdn.microsoft.com/ja-jp/library/microsof … eが抜けているだけ、ってことは無いですか? このエラーは、そこに書いてある通り、存在しないプロパティやメソッドを使おうとしたときに発生するものです。 ・そのメソッド/プロパティがあると思っていたら無かった ・単なる入力間違い が主な原因です。いずれも、マニュアルで確認しましょう。
私は一応本職ですが、コードの書き溜めは私もやっていますよ。 動いているコードというのは実に重要で、実績のあるコードの書き溜めは非常に便利です。 ・作成時間の短縮化(これが一番大きい) ・動いていた実績も合わせてコピー(ものによりますが、これも重要です) ・コピー対象を熟知しているからコピーできる 一から作ると再度検証しなければならないので、その意味でも、コピーするほうが良いかと思っています。 まぁ当然ながら、コピーしたコードが動くのは、そのコードが正しく動く環境で動かしていることが前提ではありますが。 それにコピーするというのは、そのコードが、どういう環境で、どの様に呼ばれて、何をどう出力するか、を判っていないとできないことで、学習目的であれば、それだけ内容を習得できているということにもなるかと思います。 思った動きをしていない製品があるとき、「既に動いて出荷している製品からそのままコピーしてきたコードだから(うんぬん)」という言葉は、「一から作りました」よりは、他者にコードの正当性を説明する際、説得力があります！(^ ^; (まぁ、うちだけかもしれませんが) 復習をかねてもう一度最初から書くのであれば良いでしょうが、新しいことを習得しようとするのであれば、今まで通り、コピペ＆改造でよいと思いますよ。
こういう条件でしょうか。 △の時の条件は特に見る必要がなさそうですが……。 ・K13が空白なら、空白 ・K13が×なら、E ・K13が○で、 　　・0.0000001以下　ならA 　　・0.0000099以下　ならB 　　・0.0002以下　ならC ・それ以外は、D Private Sub Worksheet_Change(ByVal Target As Range) 　　If (Target.Address <> "$K$13") And (Target.Address <> "$K$14") Then Exit Sub 　　sMark = Range("K13").Text 　　nData = Range("K14") 　　sAlphabet = "D" 　　If sMark = "" Then 　　　　sAlphabet = "" 　　ElseIf sMark = "×" Then 　　　　sAlphabet = "E" 　　ElseIf sMark = "○" Then 　　　　Select Case nData 　　　　　　Case Is <= 0.0000001 　　　　　　　　sAlphabet = "A" 　　　　　　Case Is <= 0.0000099 　　　　　　　　sAlphabet = "B" 　　　　　　Case Is <= 0.0002 　　　　　　　　sAlphabet = "C" 　　　　End Select 　　End If 　　Range("K15") = sAlphabet End Sub
Range("G2").Value ではなく Range("G2").Text ならどうですか？
ここに、呼び出し方法が出ています。 「Win32 API を呼び出すことが可能なコンポーネントとしては「DynamicWrapper」「SFC mini」「Excel」等がある」 http://cx20.main.jp/blog/hello/2012/04/20/hello- … SFC miniというものは、Win7では、動くでしょうか？ もし動くなら、これを使う方法がありますね。 http://www.vector.co.jp/soft/winnt/prog/se387565 … >ExcelVBA経由でGDI32.DLLを呼び出すのが >もっともシンプルかなと思いました。 確かにそのとおりでしょうね。
警告を表示させないようにするだけなら簡単ですが、それでは根本的な解決にはならないので、「値を返さないコードパス」を探してみましょう。 ありがちなのとして ○ エラー処理などで Exit Functionを使っている 例) ' エラーになったっときには関数を終了させる If エラー発生 Then Exit Function End if ○ Then側だけで、Else側だけ、特定のCaseだけで、戻り値が設定されている 例) ' A<>0のときは戻り値が無い If A = 0 Then test="aaa" End If ' Aが1でも2でも無いときに、戻り値が無い Select Case A Case 1 test="aaa" Case 2 test="bbb" End Select 注意しなければいけないのは、コンピュータは「絶対有り得ない」かどうかを判断できない、ということです。 例えば、上記Select Caseで、Aは絶対に1か2になるようにプログラムを作ってあったとします。 それを知っている人間は、このSelect Caseで「値を返さないコードパス」は存在しない、と判断できます。 しかし、コンピュータには、それを知る手段がありません。A=0になっているかもしれない、そのときには値を返さない、と判断します。 > コードが長すぎてここに記載できないのですが そういう「長いコード」を整理することも考えましょう。
「ソリューションエクスプローラー」の文字が書いてある下部に 「すべてのファイルを表示」のアイコンがあるので、それを押せば参照設定が表示される
シートタブを右クリックして、コードの表示を選びます。 そこに、以下のコードを貼り付けてください。 マクロを動かすときは、B列,C列などををセレクトとしてください。 Private Sub Worksheet_SelectionChange(ByVal Target As Range) Dim t_Row As Long, t_Column As Long Dim 最終行 As Long If Target.Count <> Rows.Count Then Exit Sub If Target.Columns.Count > 1 Then Exit Sub t_Column = Target.Column If t_Column = 1 Then Exit Sub If t_Column > 14 Then Exit Sub 最終行 = Cells(Rows.Count, 1).End(xlUp).Row Application.EnableEvents = False If Cells(1, t_Column).Value < Cells(最終行, t_Column).Value Then Range("A1:N" & 最終行).Sort Key1:=Cells(1, t_Column), Order1:=xlDescending, Header:=xlNo, _ OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom, SortMethod _ :=xlPinYin Else Range("A1:N" & 最終行).Sort Key1:=Cells(1, t_Column), Order1:=xlAscending, Header:=xlNo, _ OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom, SortMethod _ :=xlPinYin End If Cells(1, t_Column).Select Application.EnableEvents = True End Sub
こんにちは。 構文としては、一般的なコードではないので、今回、試してみましたが、問題なく通りました。 ふつうなら、Case で、数多く分かれなければ、If構文になるはずです。またCaseの右に「：」を入れたら、1行で実行させるという意味になるはずです。 それはともかく、 a =Cells(i, j).Value '←このようなものを前に置いておきます。 >Select Case Cells(i, j).Value(移動する) >Case 1:(移動する) それで、考えられるのは、Cells(i, j).Value　が、正しく取得出来ているかどうかだと思います。それで、上記の「←」で示したようなダミーコードを置いて、ローカルウィンドウで、値を取得しているか、みてください。
ProcessStartInfoを引数にとるバージョンを利用します。 この時，FileNameプロパティにはCMD.exeを， WorkingDirectoryプロパティにCMD.exeの初期カレントディレクトリを指定します。
・それらのPCのメモリー不足？ 　　（消さないまま高速で線の本数を増やすので 　　　瞬時に非常に多数の再描画が必要になり動作が不安定になる？） ・システムに再描画の時間を与えていない？ 　　（repaint か　DoEvents の使用）
>希望としましては、１データ送信に対して１データ受信が望ましいのですが。 >実際のデータには全角はある為、このような希望となりました。 >もしかして、不可能なのでしょうか。 TCPはストリーム(連続したデータ)ですので、その上で走らせるプロトコルレベルで「１データ送信」の区切りを決めないと無理です。 たとえば、ファイルに複数回のデータを書き込んで、1024バイトにしたとします。 読み込む時に決め事なしの状態で、書き込んだ時と同じデータサイズの読み込みができるか？というのと同じことになります。 http://www.kt.rim.or.jp/~ksk/wskfaq-ja/intermedi … の「3.4 - TCPのようなストリームプロトコルで、パケット単位の処理を強制するための正しい方法は?」とか。 参考URL：http://net-newbie.com/tcpip/tcp/tcp-intro.html
要約すると「指定フォルダ内の全ファイルに対し処理を行う」ですよ。 ご希望の場合は、「全ファイルに対し処理」を「カウンタをインクリメント」に置き換え。 過去問「Excel マクロ　指定フォルダ内のファイルを順に開き処理をする方法は?」とか。 小生、教えて!gooからの参加なので、 参考URLはご自身のサイトのアドレスで番号のみ打ち変えても可。 参考URL：http://oshiete.goo.ne.jp/qa/5169104.html
取り出したい文字位置が常に同じなら 文字列から指定した部分を取得する http://dobon.net/vb/dotnet/string/substring.html でも、これってどんなショボい入門書でも書いてあるような基本的な事項です。 それが判らないということは、そういう入門書を持ってないんですか？ それでは英和辞典を使わずに英語を読み書きしようとする「チャレンジャー」のようです。
何度もごめんなさい。 「集計用紙」の「集計」という言葉で思い込みをしていました。 集計するのではなく、単に集計用紙のB・C列の2行目以降に 「青」のSheet見出しデータを羅列すれば良い訳ですよね？ 今までのコードは無視して、標準モジュールに↓のコードをコピー＆ペーストしてマクロを実行してみてください。 Sub Sample3() Dim i As Long, k As Long, cnt As Long cnt = 1 For k = 1 To Worksheets.Count With Worksheets(k) If .Tab.Color = RGB(0, 112, 192) Then For i = 15 To 45 Step 6 cnt = cnt + 1 Worksheets("集計用紙").Cells(cnt, "B") = .Cells(i, "L") Worksheets("集計用紙").Cells(cnt, "C") = .Cells(i, "P") Next i End If End With Next k End Sub 今度はどうでしょうか？m（_ _）m
No.1です。 ＞列にはほかにも記号があり ＞記号"○","△"のみカウントしたいのです ＞またC列以降も記号があり同じように列にカウントしていきたい というコトですので・・・ 行の配置は前回同様で、C列以降に記号のみの列があるという解釈です。 ↓のコードに変更してみてください。 Private Sub CommandButton1_Click() Dim i As Long, j As Long, cnt As Long Application.ScreenUpdating = False For j = 2 To ActiveSheet.UsedRange.Columns.Count Cells(14, j).Resize(9, 1).ClearContents cnt = 0 For i = 2 To 10 If Cells(i, j) = "○" Or Cells(i, j) = "△" Then cnt = cnt + 1 Cells(i + 12, j) = cnt End If Next i Next j Application.ScreenUpdating = True End Sub 今度はどうでしょうか？m(_ _)m
「開発」タブの「挿入」からActiveXコントロールグループに有る「コマンドボタン」をクリックします。 その後にシート上に四角を描くようにしてコマンドボタンを配置します。 コマンドボタンを右クリックして「コードの表示」を選択します。 表示される画面に次のコードを入力します。 Private Sub CommandButton1_Click() Dim n, i As Integer Range("B12:B14").Clear n = 11 For i = 2 To 10 If Cells(i, 2) = "●" Or Cells(i, 2) = "▼" Then n = n + 1 Cells(n, 2) = Cells(i, 1).Value End If Next End Sub 最後に「開発」タブの「デザインモード」がアクティブ状態になっているのでそこをクリックして終了します。
最も簡単にはRange("B11;E13"）.Clearを使うことでしょう。 見つからない場合にはセルを空にするというようにするのでしたら次のようなコードになりますね。 Sub 入力() Dim i, j As Integer Dim x On Error Resume Next 'Range("B11:E13").Clear この式を入れるならそれが最も簡単です。 For j = 2 To 5 For i = 1 To 3 Set x = Range(Cells(15, j), Cells(23, j)).Find(i, LookIn:=xlValues) If Not x Is Nothing Then Cells(i + 10, j) = WorksheetFunction.Index(Range("A1:A9"), WorksheetFunction.Match _ (i, Range(Cells(15, j), Cells(23, j)), False)) Else Cells(i + 10, j) = "" End If Next i Next j End Sub
ついでに関数。 （例題見る限りSheet1とSheet2の位置関係を行列入れ替えれば良いだけのように見えるので） Sheet1のデータがA1から始まってるとして。 これもまず「名前定義」で 「名前」に database 「参照範囲」に =INDEX($A:$A,COUNTA($A:$A)+1):INDEX($1:$1,COUNTA($1:$1)+1) Sheet2のB1セルに =INDEX(database,COLUMN(),1) 右に必要データ列数コピー。 A2セルに =INDEX(database,1,ROW()) 下に必要データ行数分コピー。 B2セルに =($A$1=INDEX(database,COLUMN(),ROW()))*1 右と下に必要データ行列数分コピー。 #Sheet1とSheet2の並びを行列入れ替えず、そのままで妥協できるならもっと簡単？
ANo. #2です。 スペルミスの修正。 誤) System.DateTime.ParseExtract 正) System.DateTime.ParseExact http://msdn.microsoft.com/ja-jp/library/system.d … 誤) System.DateTime.TryParseExtract 正) System.DateTime.TryParseExact http://msdn.microsoft.com/ja-jp/library/system.d …
そうですね、プログラミングは言語を習得するだけではダメなので、多くの関連知識も勉強する必要があるでしょう。 広く浅く（と言っても素人には深いですが）勉強するには、IT関連の国家試験の勉強がいいでしょう。 高校在学中には合格する人もいると思いますが、中学在学中に合格すると凄いかも。 広く浅く知識を得ることで、少しはプログラミング学習のことも方向性が分かるかもしれません。 なお、常に基礎からの理解と上位概念からの理解の両面を持つといいでしょう。 基礎とはプログラムも分解していくと最後にはAND、OR、NOTのみになってしまうとか、です。 EORもあるとか言ってもEORもAND、OR、NOTに分解でき、AND、OR、NOTはそれ以上分解出来ません。 そこまで分解して組み立てると、結果がVBであろうとC++であろうと再構築できるわけです。 その辺が分かると言語も基本の部分は一緒、と理解できるでしょう。 また機械語の勉強ですね。CPUの仕組みを勉強することです。 プログラムはCPUを駆動するわけですから、CPUの知識なしで語るな、です。 CPUの知識の無いプログラマは、時たまオカルトのようなプログラムを組み、「動かん」と四苦八苦しているのを見ます。 言語の文法の解釈にも影響を与えると考えています。 上位概念とは、システムとは何ぞや、サブシステムとは？　その中でのプログラムとは？　どうあるべきか？ といったような思考です。 これは、技術倒れのプログラムではプログラムの存在意義がありませんから、利用されるプログラムとは何ぞや？それによってプログラムの作り方も変わろうというものです。 プログラマ「技術的に凄いプログラムを作りました」 ユーザ「で、それが我々に何の役に立つのかね？」 ということです。 それより、 ユーザ「こんな夢の様なことは出来ないでしょうね？」 プログラマ「いえ、私の技術ではお安い御用です」 といきたいものです。 技術を磨くことと、技術倒れにならないこと、です。
そんなことはありませんが、 Importsステートメントを書いた方がソースがすっきりすることが多いです。 Excel.WorkbookはMicrosoft.Office.Interop名前空間の中にあるため、 Importsステートメントを使わない場合は 　Microsoft.Office.Interop.Excel.Workbook とフルパスで書く必要があります。 Importsステートメントを書くことにより、 「知らない名前空間、クラスが出てきたらこの中を探してね」と指示することができます。 そのため、 　Excel.Workbook と書くだけで済みます。 「.NET 名前空間」というキーワードで調べるとさらに理解が深まると思います。 参考URL：http://dobon.net/vb/dotnet/help/imports.html
ANo.4のものですが、即席のファイル名変更プログラムを作りましたので、ご参考までに。 下のプログラムを標準モジュールにコピー＆ペーストして下さい。 Public Function FlashFileReName(ReNameFlg As Boolean) 'WebBrowserの面倒なメッセージを出なくするため 'Flashフォルダ内のFlash32**.ocxファイルをリネームする Dim FldPath As String 'フォルダの設定 Dim FileNameF As String '公式ファイル名 Dim FileNameD As String 'ダミーファイル名 Dim FullPathF As String '公式ファイルのフルパス Dim FullPathD As String 'ダミーファイルのフルパス '#==　初期設定　================================================================ 'Flashのフォルダ設定（自身のPCに合ったフォルダを設定して下さい） FldPath = "C:\Windows\System32\Macromed\Flash\" 'flashのファイル名設定 '必ず自身がお使いのファイル名を設定して下さい FileNameF = "Flash32_11_6_602_180.ocx" '←公式ファイル名 FileNameD = "Flash32_11_6_602_180.ocx.bak" '←ダミーファイル名 '#============================================================================== 'フルパス設定 FullPathF = FldPath & FileNameF FullPathD = FldPath & FileNameD 'ファイル名を変更する If ReNameFlg = True Then 'ダミー名から公式名に変更 Name FullPathD As FullPathF Else '公式名からダミーに変更 Name FullPathF As FullPathD End If End Function ↑コピーはこの真上までです。 初期設定は必ず行って下さい。 次に、コマンドボタンを作って下さい。 コマンドボタンのクリックイベントに 下記のプログラムをコピー＆ペーストして下さい。 'ダミー名から公式名に変更 FlashFileReName (True) ↑コピーはこの真上まで。 もう一つコマンドボタンを作って 下記のプログラムをコピー＆ペーストして下さい。 '公式名からダミーに変更 FlashFileReName (False) ↑コピーはこの真上まで。 コマンドのボタン名は自身が分かりやすい名前に。 １つ目は『Flash使用可』や『公式ファイル名に変更』等 ２つ目は『Flash一時停止』や『ダミーファイル名に変更』等 そんな感じで作ってみて下さい。 即席モノですので、ファイルの存在確認や その他エラー回避などは入っておりません。 各自改造して使ってみて下さい。
デザイン画面で表示しているページが実行時に表示されるので ページ１を選択しておきましょう。 私もこの作業を結構忘れる事があるので下記のコードを必ず入れています。 UserFormの初期化イベント Private Sub UserForm_Initialize() 　　Me.MultiPage1.Value = 0 End Sub page1は0、page2なら1といった具合です。 それでは。
一例です。 Sub Sample() Dim i As Long For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row Step 15 Cells(i + 1, 1).Resize(14) = Cells(i, 1) Next End Sub
変換規則さえ書かれていないので回答不能です。
こんばんは！ 色々やり方はあると思いますが・・・ 一例です。 ＞納品日は検索した日の日付になります。 とありますが、とりあえずSheet2（納品リスト）のA列日付としています。 Sheet1（発注リスト）に重複があっても対応できるようにしてみました。 ↓のコードを標準モジュールにコピー＆ペーストしてマクロを実行してみてください。 Sub Sample1() Dim i As Long, k As Long, c As Range, wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("発注リスト") Set wS2 = Worksheets("納品リスト") Application.ScreenUpdating = False i = wS1.Cells(Rows.Count, "A").End(xlUp).Row Range(wS1.Cells(2, "D"), wS1.Cells(i, "D")).ClearContents k = wS2.Cells(Rows.Count, "A").End(xlUp).Row With wS1 .Cells.Interior.ColorIndex = xlNone .Range("A:A").Insert With .Range(wS1.Cells(2, "A"), wS1.Cells(i, "A")) .Formula = "=C2 & ""_"" & D2" .Value = .Value End With End With With wS2 .Cells.Interior.ColorIndex = xlNone .Range("A:A").Insert With .Range(wS2.Cells(2, "A"), wS2.Cells(k, "A")) .Formula = "=C2 & ""_"" & D2" .Value = .Value End With End With For k = 2 To wS2.Cells(Rows.Count, 1).End(xlUp).Row Set c = wS1.Range("A:A").Find(what:=wS2.Cells(k, "A"), LookIn:=xlValues, lookat:=xlWhole) If c Is Nothing Then wS2.Cells(k, "D").Interior.ColorIndex = 3 Else For i = 2 To wS1.Cells(Rows.Count, "A").End(xlUp).Row If wS1.Cells(i, "A") = wS2.Cells(k, "A") Then With wS1.Cells(i, "E") .Value = wS2.Cells(k, "B") .NumberFormatLocal = "m/d" End With wS1.Cells(i, "D").Interior.ColorIndex = 4 End If Next i End If Next k wS1.Range("A:A").Delete wS2.Range("A:A").Delete Application.ScreenUpdating = True End Sub ※　両SheetともA列を作業用の列として挿入していますので、 コードでは元データは1列ずつずれています。m(_ _)m
>それぞれのシートの名前が顧客の名前になっています。 ですよね。 Dim i As Integer Dim btn Dim name As String With 顧客リスト Application.DisplayAlerts = False For i = 0 To .ListCount - 1 If .Selected(i) Then name = .list(i) '選択されたリストを変数に格納 btn = MsgBox("本当に、 " & name & " さんを削除していいですか？", _ vbYesNo, "削除の確認") If btn = vbYes Then Worksheets(name).Delete End If End If Next i .Clear For i = 2 To Worksheets.Count .AddItem Sheets(i).name Next Application.DisplayAlerts = True Worksheets(1).Activate End With と Private Sub UserForm_Initialize() With 顧客リスト For i = 2 To Worksheets.Count .AddItem Sheets(i).name Next End Sub で十分ではないでしょうか？ Sheets(1)は削除しないものとしてです。 Application.DisplayAlerts = False もFor～Nextの外側で十分ですね。 位置側に書くと何度もパソコンに無駄な動作をさせてしまいますね。
StrFN = "c\data.txt" ドライブ指定で「コロンが抜けている」のは完全に間違っています。 さらに「Cドライブの直下」にはデータを書き込むことができないと思います。 ご確認ください。
コードを拝見してみると If btn = vbYesNo Then Exit Sub End If の場所がおかしいですよ。やりたいことがいまいちわからないので一部こちらの想像で Private Sub 顧客削除_Click() Dim i As Integer Dim btn Dim name As String With 顧客リスト For i = 0 To .ListCount - 1 If .Selected(i) Then name = .list(i) '選択されたリストを変数に格納 btn = MsgBox("本当に、 " & name & " さんを削除していいですか？", _ vbYesNo, "削除の確認") If btn = vbYes Then Application.DisplayAlerts = False Worksheets(Mid(.list(.ListIndex - 0), InStr(.list(.ListIndex - 0), " ") + 1)).Delete Application.DisplayAlerts = True End If End If Next i Worksheets(1).Activate End With ActiveWorkbook.Save End Sub
続けてお邪魔します。 エラー処理について・・・ 安直な方法ですが ↓のコードにしてみてください。 Sub Sample2() Dim i As Long, j As Long On Error Resume Next '←おまじないでこの行を追加 For j = 2 To 5 For i = 1 To 3 Cells(i + 10, j) = WorksheetFunction.Index(Range("A1:A9"), WorksheetFunction.Match _ (i, Range(Cells(15, j), Cells(23, j)), False)) Next i Next j End Sub これで1～3のデータがない場合でも何とか対処できると思います。m(_ _)m
VBはよくわかりませんけど… >Dim x As String = Now().ToString() でxに「ファイル名、フォルダ名に使えない文字」とか入っていませんか？ # '/'や':'はファイル名やフォルダ名には使えませんが…。
>条件付書式による着色がカウントし 方法が無いこともないですが、相当面倒です。セルをクリップボードにコピーし、html形式のデータを取り出し、色を表現する部分を取り出すなんてワザがあります。 元ネタはmougですが、既に消えています。 こちらに保管している方がいます。ご参考まで。 https://gist.github.com/honda0510/3088353
プログラマなら.NetFrameWorkをプラットフォームとしたオブジェクト指向型言語、 オフィスを使っている人はVB6をメインとしたVBAとなります。 実際に開発してみるとＶＢとOFFICEのVBAは全く異質であることが分かります。
どの行を生成するのか記憶しておく変数を準備して これをSessionに登録してみてはいかがでしょう dim bRow(10) as Boolean ' Page_Loadイベント Protected Sub Page_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load 　　if IsPostBack then 　　　　'何かのアクションで呼び出されたのなら bRowをSessionから復元 　　　　bRow = Session("bRow") 　　else 　　　　' Sessionを新規生成 　　　　Session("bRow") = bRow 　　end if 　　for n as integer = 1 to 10 　　　　if bRow(n) = false then 　　　　　　' 削除済みフラグが設定されていなければ生成 　　　　　　tblFormat.Rows.Add(retCreateRow(n)) 　　　　end if 　　next End Sub ' 行削除ハンドラ Private Sub btnDelete(ByVal sender As System.Object, ByVal e As System.EventArgs) 　　Dim btn as ImageButton = CType(sender, ImageButton) 　　Dim ControlIdx = Split(btn.ID, "_")(1) 　　' Sessionから bRowを取得 　　bRow =Session("bRow") 　　if bRow(ControlIdx) = false then 　　　　bRow(ControlIdx) = true 　　　　dim row as HtmlTableRow = btn.Parent.Parent 　　　　tblFormat.rows.Remove(row) 　　　　' Sessionの更新 　　　　Session("bRow") = bRow 　　end if End Sub
「vba 画像　ｃｈｕｎｋ」でググってください。 ｃｈｕｎｋは「チャンク」と読みます。
Ｎｏ１です。 ＫＯＴＯＫＯが見つかればいいのかはわからなかったので、 取り合えず全部を抜き出すもの。 Imports System.Text.RegularExpressions ' 正規表現 Public Class Form1 Dim url As String Private Sub Form1_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load url = "http://fah-web.stanford.edu/cgi-bin/main.py?qtyp … WebBrowser1.ScriptErrorsSuppressed = True WebBrowser1.Navigate(url) End Sub Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click Dim re As Regex = New Regex("(?<Rank>\d+)\s+(?<Donor>.+?)\s+(?<Score>\d+?)\s+(?<WU>\d+)\s", RegexOptions.Singleline) Dim st As String = "" Dim ch As Boolean = False For Each tg As HtmlElement In WebBrowser1.Document.GetElementsByTagName("TR") st = tg.InnerText If Not st Is Nothing AndAlso st.StartsWith("1") Then ch = True If ch Then Dim m As Match = re.Match(st) Debug.Print(m.Result("${Rank}") & vbTab & m.Result("${Donor}") & vbTab & m.Result("${Score}") & vbTab & m.Result("${WU}")) End If Next End Sub End Class 一例になれば。
No1です。 こっちが良いかも？ Dim r As New System.Text.RegularExpressions.Regex(">\s[^>]+?\s</(a|TD) ", System.Text.RegularExpressions.RegexOptions.IgnoreCase)
こんばんは。 サンプルです。 Sub Try() 　　Dim CheckRange As Range 　　Dim rng As Range 　　Dim cnt As Long 　　Set CheckRange = Range("A1:D50") 　　For Each rng In CheckRange 　　　　If rng.ColorIndex = 7 Then 　　　　　　cnt = cnt + 1 　　　　End If 　　Next 　　If cnt > 0 Then 　　　　MsgBox cnt & "ヶ所、日付が入力されていません。" , vbCritical 　　　　Exit Sub 　　End If 　　'ここに本処理を記入 　　 End Sub ※インデントを見やすくする為に行頭に全角スペースを挿入しています。
何をどうしたら出来たのか不明ですけど、 それは単なる名前（ボタンを押した際のイベント名）の 違いでしょう。 ボタンが１つ（あるいはButton1が１つ）であるなら Private Sub Button1_Click_1 の方を削除すれば良いのでは？ ⇒どのＢｕｔｔｏｎを押した時に実行するかは その後ろにある Handles Button1.Click で決まってきますから。
> ほしいのは、シート増減したときの、シート連番です。すべてのシートに > Private Sub Workbook_SheetActivate(ByVal Sh As Object) > を書き込むのは面倒なので、できれば、シートに書きたくないです。 何か、勘違いがあるように思います。 例示のコードだと、実行された際にブック内に存在するシートすべてに番号を "振りなおす" 機能。 新規に追加したシートにのみ番号を振っているわけではありません。 マクロの実行で"シートに連番"を動かせば良いだけの話と思うのですが。 問題点は「自動的に起動しないからイヤ」とおっしゃてると読んだのです。 だから一番最初に 「シートに連番()はどのようにして呼び出しするおつもりですか？」 とお尋ねしています。 現在のブックをバックアップした上で、マクロ "シートに連番" を実行してみてください。
http://www.grapecity.com/tools/support/technical …
描画はPaintにまかせて、Resizeの場合はInvalidateを呼び出してコントロール全体が再描画されるようにすればいいんじゃないでしょうか。
可能性として 2010　が　64bit　だったりして・・・
こんな方法もあります。 Select Case True Case　CD >= -30561 And CD <= -26510 Or _ 　　　CD >= -26415 And CD <= -5468 Or _ 　　　CD >= -31936 And CD <= -31850 Or _ 　　　CD >= -32097 And CD <= -32015 Or _ 　　　CD >= -1444 And CD <= -949 i = i + 1 End Select
第一条件が共通なら、その中に第２条件を入れるほうが、見やすい。 If ComboBox1.SelectedIndex = 0 Then　 　　If ComboBox2.SelectedIndex = 1 Then　TextBox1.Clear() 　　If ComboBox2.SelectedIndex = 2 Then　TextBox2.Clear() 　　If ComboBox2.SelectedIndex = 3 Then　TextBox3.Clear() 　　If ComboBox2.SelectedIndex = 4 Then　TextBox4.Clear() End if 構造化と言います。
NO2です。 シート名を以下のコメントコード内の文字列にカンマ区切りで設定して下さい。 Sub sample() Dim i As Integer, ws ws = Split("aaa,bbb,ccc,ddd,eee,fff,ggg", ",")　'シート名配列の作成 For i = 0 To UBound(ws) Debug.Print ws(i) With Sheets(ws(i)) Union( _ .Range("F109:BO109,F112:BO112,F115:BO115,F118:BO118,F121:BO121"), _ .Range("FJ225:GS225,FJ228:GS228,FJ231:GS231,FJ234:GS234,FJ237:GS237"), _ .Range("OA535:PD535,OA538:PD538,OA541:PD541,OA544:PD544,OA547:PD547")). _ ClearContents End With Next Sheets("sheet6").Select Range("J1:L1").Select End Sub
1) 既存のテーブルを参考にしてみる ハイパーリンク型のフィールドを持つ単純なテーブルを手動で作成して、Table オブジェクトで参照する。 Column プロパティでハイパーリンク型フィールドを参照し、各プロパティをローカル ウォッチ ウィンドウで確認する。 ハイパーリンク型フィールドとしての特色を見つけ出す。 2) 試す 見つけ出した特色を試してみる。 1) の方法は質問者が参考にしているサイトにヒントがあるのですでに試している可能性もある。 すでにそんなのは見ているというのであればご容赦を。 既存テーブルを参照するには "ADOXを用いてテーブル名を取得する" のページを参照する。 ハイパーリンク型フィールドを持つテーブルを 1個だけ作っておき、上記ページのコードを参考に、そのテーブルをコードから参照できるようにする。 テーブルを参照できたら、さらにそのテーブルが持つフィールドを参照するようにコードを改造する。 ADOX でフィールドは Field ではなく Column と呼ぶらしいということは質問者が参考にしているページ上に書かれているのですでに知っているはず。 ともかくフィールドを参照するコードを書いたらそれをステップ実行する。 フィールドを参照している所でローカル ウォッチ ウィンドウを見てみる。 Column オブジェクト変数の中身を展開する。 Name プロパティがフィールド名の事だと言うのはすぐにわかると思う。 Type プロパティが型をあらわしているのもすぐにわかると思う。 ただし Type プロパティは何の変哲もない adLongVarWChar 型なので、ハイパーリンク型として機能するためには更に他の設定値も必要なんじゃないか、という予想が立つ。 Column オブジェクト変数の中身をよーく見てみると Properties という、何やら更に展開できるプロパティの存在に気づくので、それを展開してみると Item1 から Item15 まで 15個のプロパティが隠されていることがわかる。 これらのプロパティの一部は質問者が参考にしているページのコードでも使われているので臆する内容じゃないとちょっぴり安心できると思う。 Item1 から Item15 までの Name プロパティを見てみると、とうぜん英語で書かれているが、Item1 の Autoincrement がオートナンバーをあらわし、Item2 の Default が規定値をあらわし、Item 3 の Description が説明、Item4 の Nullable が Null許容 (Access 的には値要求)、、、 ともかく、この Item1 から Item15 が Access のフィールド型としての特殊な部分のキモになっているんじゃないかっていう予想ができるはず。 その証拠に Item15 の Name は "Jet OLEDB:Hyperlink" である。 これだろう、絶対にこれがハイパーリンク型の鍵になっているだろうっていう予想。 このプロパティの設定値は adBoolean なので True か False になる。 今参照しているのがハイパーリンク型のフィールドであれば Value は True になっている。 つまり 「とあるハイパーリンク型フィールドの Type は adLongVarWChar で、そのフィールドの Properties("Jet OLEDB:Hyperlink") プロパティの値は True である」 ぐらいの結論にたどり着く。 下記コードをステップ実行して Debug.Print fld.Name の行で中断する。 Sub hoge() 　　Dim cat As ADOX.Catalog 　　Set cat = New ADOX.Catalog 　　cat.ActiveConnection = CurrentProject.Connection 　　 　　Dim tbl As ADOX.Table 　　For Each tbl In cat.Tables 　　　　If tbl.Type = "TABLE" Then 　　　　　　Dim fld As ADOX.Column 　　　　　　For Each fld In tbl.Columns 　　　　　　　　Debug.Print fld.Name 　　　　　　　　Debug.Print fld.Type 　　　　　　　　Debug.Print 　　　　　　Next 　　　　End If 　　Next End Sub ローカル ウィンドウで変数 fld を展開し、Properties を更に展開し、Item 15 を確認する。 これらの結果をもとに、テーブル作成のコードを試してみる。 Sub MyCreateTable() 　　Dim cat As ADOX.Catalog 　　Dim tbl As ADOX.Table 　　 　　Set cat = New ADOX.Catalog 　　cat.ActiveConnection = CurrentProject.Connection 　　 　　Set tbl = New ADOX.Table 　　tbl.Name = "tbl_sample" 　　Set tbl.ParentCatalog = cat 　　 　　With tbl 　　　　.Columns.Append "ID", adInteger 　　　　.Columns.Item("ID").Properties("AutoIncrement") = True 　　　　.Columns.Append "WebSite", adLongVarWChar 　　　　.Columns("WebSite").Properties("Jet OLEDB:Hyperlink") = True 　　End Witd 　　cat.Tables.Append tbl End Sub っていう手順で考えていくわけだが。 私は ADOX は使ったことがなく、今回の質問をきっかけに上記の思考ロジックで進めてみた。
> Excel 2003です。 セルの書式設定を見れば分かるけど、セルの背景色はカラーパレットに登録 されている色にしか設定できません。Excel の仕様です。 だから一番近い色に丸められています。 Debug.Print RGB(204, 204, 102) '6737100 Debug.Print RGB(255, 204, 204) '13421823 Range("A1").Interior.Color = RGB(204, 204, 102) Range("A2").Interior.Color = RGB(255, 204, 204) Debug.Print Range("A1").Interior.Color '10079487 Debug.Print Range("A2").Interior.Color '13434879 フォームの方は設定値のままのようですね。 ちなみにオートシェイプの背景色であれば256階調の設定ができます。
先程の投稿にタイプミスがありました、下記に訂正願います。 Microsoft.VisualBasic.Interaction.Shell("notepad.exe", AppWinStyle.MaximizedFocus)
ExpressはVisual Studio製品群の一番低位の製品です。 言語・コンパイラの機能自体は他の有償VSとの違いはありませんが，IDEの機能に制限があります。 VBコードを書くのであれば，わざわざ機能の劣る (特に拡張機能系が使えない) VB Expressを使わず，Visual Studio 2010を使えばよいでしょう。
リピートボタンの実装と思われます。 こんな方法はどうですか？ （イベント関数の引数などは省略して記載してません） Private ButtonMode As Integer = 0　'ボタン識別のモジュール変数 Private ButtonTime As Integer = 0　'ボタン押し時間のモジュール変数 '/********************************************************************* ' *音量ボタン長押しの場合の処理 ' ********************************************************************/ Private Sub Button0_MouseDown() ButtonMode = 1　'この場合はボタンごとにイベントを記載する 'ButtonMode = Object.Tag のようにButtonのTagプロパティをボタンの識別に使う方法も有り。（イベント関数を１つにすることができる） ret = SetVol(ButtonMode)　'押した時の最初の処理 ButtonTime = 0 Timer2.Enabled = True End Sub Private Sub Button0_MouseUp() ButtonMode = 0 Timer2.Enabled = False End Sub '/********************************************************************* ' *タイマー起動 ' ********************************************************************/ Private Sub Timer2_Tick() If Button = 0 Then Return 'ボタン押されていない ButtonTime = ButtonTime + 1 If ButtonTime>10 Then 'リピート反応待ち Dim ret As String ret = SetVol(ButtonMode)'//ボタンの番号によって音量アップ、ダウンをセット End If End Sub
一応そのコードでも表示する事は可能ですが、VB の.NET 系のバージョンから EXcel（Com オブジェクト)を操作する場合、Com オブジェクトの解放処理が必要になります。 VB6.0 であっても投稿されたコードでは、Excel のプロセスがタスクマネージャ上に残る事になりかねません。 今回の原因は、環境の問題で発生しているものと思われますが、詳しい環境がわかりませんので即答はできませんが、ご使用の Excel ファイルを新規のファイルを使って試してどうなるかとか。？ 他のバージョンのExcel が同一環境にインストールされていないとか。 実行環境と開発環境が違っていないかと。 Excel 2010 が開発環境でなくサーバー等にインストールされていないかとか。 タスクマネージャ上にExcel.exe がいくつも存在していないかとか。 その辺を一度調べて見て下さい。 それでも解らない場合は、正確なエラーメッセージをキーにしてWEB上を検索してみて下さい。 貴方と同じ環境の事例があればその辺をチェックして見て下さい。 因みに、VB.NET というと VB.NET 2002 と VB.NET 2003 になります。 VB2005 以降は製品名に“.NET”の名を冠さないようになっています。 VS2010 とか書く人もおられますが、Visual Studio には、Visual Basic 以外の言語も含まれておりますので、この掲示板(Visual Basic)でバージョン(環境)として書く場合は、意味がありません。
No.2です。 どうしてもVBAでやりたいというコトですので・・・ 標準モジュールに一旦↓のコードをコピー＆ペーストしておいてください。 Sub Sheet2に表示() Dim i As Long, j As Long, k As Long Dim wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") Application.ScreenUpdating = False j = wS2.UsedRange.Columns.Count For i = 6 To wS2.Cells(Rows.Count, 1).End(xlUp).Row Step 6 wS2.Cells(i, 2).Resize(3, j).ClearContents Next i On Error Resume Next For i = 3 To wS2.Cells(Rows.Count, 2).End(xlUp).Row Step 6 For j = 2 To wS2.Cells(i, Columns.Count).End(xlToLeft).Column k = WorksheetFunction.Match(wS2.Cells(i, j), wS1.Rows(5), False) wS1.Cells(13, k).Resize(3, 1).Copy wS2.Cells(i, j).Offset(3) Next j Next i Application.ScreenUpdating = True End Sub 次にSheet1のコマンドボタンのコードを↓にして、コマンドボタンをクリック！ Private Sub CommandButton1_Click() Call Sheet2に表示 End Sub こんなんではどうでしょうか？ ※　上記コードはお示しの画像通りの配置としていますので、 Sheet1およびSheet2の配置が少し変わっただけでも まったく意味のないコードになってしまいます。m(_ _)m
投稿されたコードを試しましたが、特段問題がありません。 もちろん、EXE で試しても同様正常にメッセージボックスが表示されます。 新規プロジェクトで試して見ても動作しませんか？ 動作しないようなら、すべてのイベントでメッセージボックスを表示するようにしてみてどのイベントが発生していないかを調べてみたらどうでしょうか？ 因みに、私の環境は、VB2010 / Windows 7 32ビット
以前のＶＢＡは役に立たないので、別のVBAを書き換えています。 VBAでIEのページオブジェクトを開いてから、直接書き込んでいます。 質問のものはHTMLファイルを作成して、それを開いています。 表示が終わる（VBAが終了）するまでページはさわらないでください。 １行目はシングルクリックで開くコード。 書き換えるとダブルクリックに出来ます。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) 以下VBA Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Intersect(Target, Range("A:B")) Is Nothing Then Exit Sub If Cells(Target.Row, 1).Text = "" Or Cells(Target.Row, 2).Text = "" Then Exit Sub Dim objIE As Object Dim tgt1 Dim tgt2 Set objIE = CreateObject("InternetExplorer.application") tgt1 = Cells(Target.Row, 1).Text tgt2 = Cells(Target.Row, 2).Text objIE.Visible = True objIE.Navigate "http://maps.google.co.jp/maps" Do While objIE.Busy = True Or objIE.ReadyState <> 4: Loop '--ルート乗換案内オブジェクトページのの項目をダイレクト書き込み With objIE.Document .all("d_launch").Click Do While objIE.Busy = True Or objIE.ReadyState <> 4: Loop Application.Wait Now + TimeValue("00:00:02") '--車で行く～自社住所～得意先住所～検索 .all("dir_d_btn").Click .all("d_d").Value = tgt1 .all("d_daddr").Value = tgt2 .all("d_sub").Click .all("d_options_show").Click End With Set objIE = Nothing End Sub
どういう規則性？ ２桁同士の掛け合わせの後、２桁同士の掛け合わせ？ データが追加されたらどう振舞うの？
>ちなみに2010で実行したら、カレンダーを作成している最中に「応答なし」が表示され、画面上の処理がフリーズします。 時間がかかるのなら Application.ScreenUpdating や Application.StatusBar を使った方がいいかと。 Sub test() ' 画面更新を抑制 Application.ScreenUpdating = False Application.StatusBar = "処理中です。しばらくおまちください。" ' 注　ステータスバーを変更する処理は時間が掛かるので、頻繁に変更するとマクロの処理時間が長くなります。 ' 処理を記述 ' ステータスバーと画面更新を元に戻す Application.StatusBar = False Application.ScreenUpdating = True End Sub >その後に、テキストボックスを指定して、特定のセルに移動させる処理があるのですが、指定したテキストボックスが存在しないというエラーが返ってきて、処理が中断します。 指定の仕方がまずいのでは？ 厳密に Sheet1.TextBox1.Value のように指定してみてはどうでしょうか？ あとは、ありがた迷惑なセキュリティ関係かもしれませんね。 セキュリティ設定を変更して実行してみてはどうでしょうか？ ・ActiveX のセキュリティ設定 ・マクロのセキュリティ設定 ・外部コンテンツのセキュリティ設定 セキュリティ センターのオプションと設定を表示する http://office.microsoft.com/ja-jp/excel-help/HA0 … ご参考いただければ幸いです。 （Excel 2000, 2010 とも私の手の届かない環境なので間違いがありましたらご容赦ください。）
ファイルを保存する前に、フォルダ「保存データ」に年フォルダ、月フォルダがあるか検索し、無ければフォルダを新設する。 年、月、日はＮＯＷ関数を用いる事を条件とする。で宜しいでしょうか。 尚、変数に漢字を使用されていますが、変数とテキストデータが重複すると見づらいので、変数をアルファベットとしました。 Sub 自動保存（） Dim SaveFol, Fname As String Dim nen, tuki, nichi As String nen = Year(Now()) tuki = Month(Now()) nichi = Day(Now()) With Workbooks （″サンプル．xlsm″） WorkSheets（″Sheet3″）．Range（″B6：B205″）．Value ＝ Worksheets（″メインモニタ″）．Range（″F13：F212″）．Value End With Worksheets（″Sheet3″）．Select Application．DisplayAlerts ＝ False '－－－－－－－－－－－－－－－－－－－－－－－ 'ここから追加 '年フォルダ確認、無ければ年フォルダ作成 SaveFol = "C:\保存データ\" & nen & "年" If Dir(SaveFol, vbDirectory) = "" Then MkDir SaveFol End If '月フォルダ確認、無ければ月フォルダ作成 SaveFol = "C:\保存データ\" & nen & "年\" & tuki & "月" If Dir(SaveFol, vbDirectory) = "" Then MkDir SaveFol End If Fname = "\＿" & nen & "年" & tuki & "月" & nichi & "日.xlsx" ActiveWorkbook.SaveAs SaveFol & Fname ActiveWorkbook.Close '－－－－－－－－－－－－－－－－－－－－－－－ 'ここまで Application．DisplayAlerts ＝ True Application．Ontime DeteValue（Dete ＋1）＋TimeValue（″8:00:00″），″自動保存″ Worksheets（″メインモニタ″）．Activate End Sub 不要と思われる箇所は削除しましたので、必要でしたら再度追加下さい。 ペースト先が記載していないのでコピー削除。Worksheets（″Sheet3″）．Selectも不要な気がしますが。 Worksheets（″Sheet3″）．Copy パスを使用していないので削除しています。 Const mypath As String ＝ ″C：￥保存データ￥″ 日付保存ファイル名の先頭に全角の＿を入れてますが、それで良いのでしょうか？問題なければ良いのですが。 ファイル名、フォルダ名の作り方が希望通りであるかは分かりませんので、ダミーのフォルダでも作成して確認下さい。
続けておじゃまします。 補足を読みました。 丸文字は環境依存文字になってしまいますので、 当方も以前丸文字で投稿した時にカッコ付きの数字になってしまいました。 さて、実際は丸文字で　1～3までなのでしょうか？ もしそうであれば前回のコード内の ＞If buf Like "[A-Z a-z]" Then の部分を ＞If buf Like "[(1)-(3)]" Then　←丸文字数値を入力していますがおそらくカッコ付き数値で表示されると思います。 に変更してみてください。 ※　もっと大きい数値の丸文字がある場合、いくつまで対応できるか検証していませんが、 試しに(3)の部分を大きな数字の丸文字にしてやってみてください。m(_ _)m
プログラミング用語で「正規表現」というやつですね。 「VBS　正規表現」で検索するといいですよ。 最後の節をこうしてみてください。 Dim objRE Set objRE=CreateObject("VBScript.RegExp") objRE.Pattern="^.*ークショ.*$" ' Yahoo トップページのオークションのリンクをクリックする For Each objLINK In objIE.Document.Links If objRE.Test(objLINK.InnerText) Then objLINK.Click Exit For End If Next objRE.Pattern="^.*クシ.*$"　でもオークションのトップページに飛べましたよ。 参考URL：http://chaichan.lolipop.jp/vbtips/VBMemo20070101 …
StackOverflowにExampleがありました。 http://stackoverflow.com/questions/8474718/listi … marc_s氏のコード，C#のコードですが，難しくはないかと。 実際にfound.Nameでグループ名を取得できます。 ComboBoxに突っ込むなら，srch.FindAll().ToArray()あたりをDataSourceに突っ込んで， DisplayMemberをNameにしておけばよいでしょう。
こんにちは 一例です。 タグの間の表示文字をTextBoxに入力します。 Form1に WebBrowserとTextBoxを貼り付けています。 Public Class Form1 Dim k As Integer Private Sub f() Handles MyBase.Shown WebBrowser1.Navigate("http://oshiete.goo.ne.jp/qa/7978798.html") TextBox1.Dock = DockStyle.Fill End Sub Private Sub WebBrowser1_DocumentCompleted(sender As System.Object, e As System.Windows.Forms.WebBrowserDocumentCompletedEventArgs) Handles WebBrowser1.DocumentCompleted If k = 0 Then 'カウンターが0の時は処理する 'sender.urlとe.Urlが違う場合はプロシージャを抜ける If sender.url.ToString <> e.Url.ToString Then Exit Sub End If '要素が"div"でがq_descのときはTextBoxに表示 For Each htm As HtmlElement In WebBrowser1.Document.GetElementsByTagName("div") If htm.GetAttribute("classname") = "q_desc" Then TextBox1.Text &= htm.InnerText & vbNewLine End If 'classがokw_clearfixの時はループを抜ける If htm.GetAttribute("classname") = "okw_clearfix" Then Exit For End If Next End If k += 1 End Sub End Class すいませんどこがどのように違うのかおしえてください。 例 ＃タグも取得する。 ＃リンクアドレスのみ取得する。など
No.1です。 「--」で止まらないようにするため、 「If IsNumeric(Cells(i, 5)) Then」という条件をつけているわけです。 これにより、E列で数値以外のセルに当たった時には計算をスキップさせます。 Do Loopだと動かないということではありません。 私の書いたコードでもこのIf節を使えばちゃんと動きます。 その点は私の理解不足でしたのでごめんなさい。
#3です。 前回の回答は忘れてください。 こんなことを考えていたのですが。。。 シート名 MSG 内に 「マクロを有効に」と入れて置く。 ブックのイベントに Private Sub Workbook_BeforeClose(Cancel As Boolean) Application.ScreenUpdating = False Worksheets("MSG").Visible = True Worksheets("MSG").Select ThisWorkbook.Close savechanges:=True ’←BeforeClose中に、.Close 危ない方法の気がします。 Application.ScreenUpdating = True End Sub Private Sub Workbook_Open() Worksheets("MSG").Visible = False End Sub のような感じで入れて置く。 これだと、マクロを有効にしないで開き、他のシートにフォーカスを与えて上書き保存する。 次回からもマクロを有効にしないで開く。 当然、BeforeCloseが無効なので、セット出来ない。 『下手な考え休むに似たり』でした。orz ブック単独ではたぶん無理。 何らかの外部からのが必要になりそう。 http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub0 …
>色々試して、初期値を入れておいて、改めて別の数値をいれると動いたので、それでやってみます。 つまり変数の宣言の問題ではなくて、初期値の設定の問題だという事ですよね。 フォームのロード前か、フォームのロード時でも初期値の設定のコードの実行前に 使用しているということでは？ モジュール側で配列をグローバル宣言してると、モジュールが呼ばれた際に初期化の 処理が全て走ってしまうからフォームのロードイベントに書いてある初期値設定の コードを実行する前にモジュール側で初期化しようとしているとか。 プログラムの開始から1行1行ステップ実行すれば分かるのでは？
VisualStudioのデザイナによるローカライズリソースの作成は、 「規定値」のリソースの内容を基準として、 別の特定言語のリソースを作成した後、特定の言語で変更を行った内容だけが、 差分のようにその特定の言語用のリソースとして保存されます。 そのため、単に別言語用のリソースファイルができただけの状態では、 すべての文字列などが「規定値」の設定としてだけ保存されているため、 規定値のリソースを書き換えると質問文に記載されているような状況となります。 ですので、少々力業にはなりますが、 以下のようにして一応「規定値」が英語でja-JPが日本語リソース、 という状況を作れるかと思います。 ・現在の日本語が入った規定のリソースをコピーして ***.ja-JP.resx という名称にする。 ・デザイナ上で規定の言語のリソースを英語に書き換える。 ・ソリューションエクスプローラ上などで、ソリューションに ***.ja-JP.resx を追加する。 　(プロジェクトノードを右クリックして、[追加]-[既存の項目]で追加できます) ・デザイナでリソース言語を ja-JP に変更して、なにも変更せずに上書きする。 ・デザイナでリソース言語を 規定値 に戻して、上書きする。 手順の最後のほうで、切り替えて上書きをしているのは、 言語ごとに差異が無いリソース値を規定側にのみ保存されるようにするためです。 (たとえばフォームのリソースであればコントロール配置位置やサイズ等) # デザイナは言語ごとの差異が無くなったリソース値を規定側で一元化します。 一応手元で簡単に確認はしてみましたが、 もし行う際にはバックアップを残して慎重に結果を確認しつつ 行われた方が良いかと思います。
条件付き書式になります。 Excel2010なら、 A2:C2を選択して、 ホーム―条件付き書式―新しいルール―数式を使用して、書式設定するセルを決定―次の数式を満たす・・・のボックスに「=$D$2<0」を入力―書式―色のボックスで、「白」を選択して―OK―OK 2003でも、 書式―条件付き書式― で同様な設定ができる。
IEで予期せぬエラーが発生していることが問題でしょう。 IEは巨大アプリだからVBAによる制御はお勧めしません。 WebBrowserコントロールをお勧めします。 http://www.ken3.org/vba/backno/vba118.html
こんばんは！ 一例です。 Sheet1のデータをSheet2に表示するようにしてみました。 ↓のコードを標準モジュールにコピー＆ペーストしてマクロを実行してみてください。 Sub Sample1() Dim i As Long, j As Long Dim wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") wS2.Range("A:B").ClearContents Application.ScreenUpdating = False For i = 1 To wS1.Cells(Rows.Count, 1).End(xlUp).Row j = wS1.Cells(i, Columns.Count).End(xlToLeft).Column If j > 1 Then wS1.Cells(i, 2).Resize(1, j - 1).Copy wS2.Activate wS2.Cells(Rows.Count, 2).End(xlUp).Offset(1).Select Selection.PasteSpecial Paste:=xlValues, Transpose:=True wS2.Cells(Rows.Count, 1).End(xlUp).Offset(1).Resize(j - 1, 1) = wS1.Cells(i, 1) End If Next i wS2.Rows(1).Delete Application.ScreenUpdating = True wS2.Cells(1, 1).Select End Sub ※　B列以降、途中に空白セルはない！という前提です。 こんな感じではどうでしょうか？m(_ _)m
言われている「配列」がなんの事かわかりませんが、 単純にフォーム１とフォーム２の値のやりとりと言う事なら、 これだけでいいかと思います。 'フォーム１のボタンのクリック Private Sub CommandButton1_Click() 'フォーム１からフォーム２へ値を移す UserForm2.TextBox1.Text = Me.TextBox1.Text UserForm2.CheckBox1.Value = Me.CheckBox1.Value 'フォーム２を表示する UserForm2.Show vbModal 'フォーム２からフォーム１へ値を戻す Me.TextBox1.Text = UserForm2.TextBox1.Text Me.CheckBox1.Value = UserForm2.CheckBox1.Value End Sub 'フォーム２のボタンのクリック Private Sub CommandButton1_Click() 'フォーム２を非表示にする Me.Hide End Sub
こんにちは！ 今回は関数だけで対応できそうな感じですが・・・ 仮に関数でやる場合は Sheet2のB2セルに =IFERROR(INDEX(Sheet1!$1:$1048576,MATCH($A2,Sheet1!$A:$A,0),MATCH(B$1,Sheet1!$1:$1,0))&"","") として列・行方向にオートフィルでコピー！ （Excel2007以降の場合です） どうしてもコマンドボタンで操作したい場合は 前回同様、標準モジュールに一旦↓のコードをコピー＆ペーストしておきます。 Sub Sample2() Dim i As Long, j As Long, k As Long, L As Long Dim wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") i = wS2.Cells(Rows.Count, 1).End(xlUp).Row j = wS2.Cells(1, Columns.Count).End(xlToLeft).Column Range(wS2.Cells(2, 2), wS2.Cells(i, j)).ClearContents On Error Resume Next For i = 2 To wS1.Cells(Rows.Count, 1).End(xlUp).Row If WorksheetFunction.CountA(wS1.Rows(i)) > 1 Then For j = 2 To wS1.Cells(i, Columns.Count).End(xlToLeft).Column If wS1.Cells(i, j) <> "" Then k = WorksheetFunction.Match(wS1.Cells(i, 1), wS2.Columns(1), False) L = WorksheetFunction.Match(wS1.Cells(1, j), wS2.Rows(1), False) wS2.Cells(k, L) = wS1.Cells(i, j) End If Next j End If Next i End Sub 次にコマンドボタンのコードを↓にしてみてください。 Private Sub CommandButton1_Click() Call Sample2 End Sub こんなんではどうでしょうか？m(_ _)m
こんばんは！ Sub Sample1() Dim k As Long, str As String, myFlg As Boolean str = Worksheets("A").Range("B3") For k = 1 To Worksheets.Count If Worksheets(k).Name = str Then myFlg = True Exit For End If Next k If myFlg = True Then Worksheets(str).Activate Else MsgBox "該当シートはありません" End If End Sub こんな感じはどうでしょうか？m(_ _)m
>保存されている場所に依存しない書き方はないでしょうか？ http://park14.wakwak.com/~simizu/cgi-bin/uwscbbs … フォルダの選択ダイアログを使って選択すればいいんじゃない？ 個人的には、UWSCなんて微妙なツールを使わないで、VisualBasic 2010 ExpressとかVisual C++ 2010 Expressなどのフリーのプログラミングツールを使った方がいいような気がする。 そっちの方が使える機能が豊富ですし、デスクトップのアドレス取得とかフォルダ選択ダイアログの使い方も簡単ですからね。 もしくは、Excelのマクロ機能を使うとか。 ExcelのマクロはVisualBasic 6.0相当くらいの機能はありますので、結構色々なことが出来ますからね。
こんにちは！ 一例です。 画像ではSheet1にコマンドボタンを配置されているようですが 一旦↓のコードを標準モジュールにコピー＆ペーストしてみてください。 Sub Sample1() 'この行から Dim i As Long, j As Long, k As Long, c As Range, wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") i = wS2.Cells(Rows.Count, 1).End(xlUp).Row j = wS2.Cells(1, Columns.Count).End(xlToLeft).Column Range(wS2.Cells(2, 2), wS2.Cells(i, j)).ClearContents 'A班操作 For i = 2 To wS1.Cells(Rows.Count, 1).End(xlUp).Row Set c = wS2.Range("A:A").Find(what:=wS1.Cells(i, 1), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then k = c.Row For j = 2 To wS2.Cells(1, Columns.Count).End(xlToLeft).Column If WorksheetFunction.Count(Range(wS1.Cells(i, 2), wS1.Cells(i, 4))) = 2 Then If wS2.Cells(1, j) >= wS1.Cells(i, 2) And wS2.Cells(1, j) <= wS1.Cells(i, 4) Then wS2.Cells(k, j) = "○" End If Else If wS2.Cells(1, j) = wS1.Cells(i, 2) Then wS2.Cells(k, j) = "○" End If End If Next j End If Next i 'B班操作 For i = 2 To wS1.Cells(Rows.Count, 5).End(xlUp).Row Set c = wS2.Range("A:A").Find(what:=wS1.Cells(i, 5), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then k = c.Row For j = 2 To wS2.Cells(1, Columns.Count).End(xlToLeft).Column If WorksheetFunction.Count(Range(wS1.Cells(i, 6), wS1.Cells(i, 8))) = 2 Then If wS2.Cells(1, j) >= wS1.Cells(i, 6) And wS2.Cells(1, j) <= wS1.Cells(i, 8) Then wS2.Cells(k, j) = "△" End If Else If wS2.Cells(1, j) = wS1.Cells(i, 6) Then wS2.Cells(k, j) = "△" End If End If Next j End If Next i End Sub 'この行まで 次にコマンドボタンのコードを↓にして、コマンドボタンをクリックしてみてください。 Private Sub CommandButton1_Click() Call Sample1 End Sub こんなんではどうでしょうか？m(_ _)m
変更後のシート名がすでに使われていないかどうかはチェックした方が良いと思います。 Sub Sample() 　　Dim ws As Worksheet 　　Dim sName As String 　　Dim rtn 　　'*** 変更後のシート名がダブらないかチェック 　　For Each ws In Worksheets 　　　　sName = Replace(ws.Name, "T", "S") 　　　　If sName <> ws.Name Then 　　　　　　On Error Resume Next 　　　　　　rtn = 0 　　　　　　rtn = Sheets(sName).Index 　　　　　　If rtn <> 0 Then 　　　　　　　　MsgBox ("変更後のシート名(" & sName & ")と同名のシートが存在しています") 　　　　　　　　Exit Sub 　　　　　　End If 　　　　　　On Error GoTo 0 　　　　End If 　　Next 　　'*** シート名変更 　　For Each ws In Worksheets 　　　　ws.Name = Replace(ws.Name, "T", "S") 　　Next End Sub
こんにちは。 これと同じよな感じですかね。 参考URL http://bbs.wankuma.com/index.cgi?mode=al2&namber …
