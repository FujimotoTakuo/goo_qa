No.3です。 もう一度質問文を読み返してみると・・・ A～T列のみをコピー＆ペーストするのですね？ 前回のコードはすべての列がコピー＆ペーストされますので ↓のコードに変更してください。 Sub Sample2() Dim lastRow As Long, myRng As Range, wS As Worksheet Set wS = Worksheets("Sheet1") lastRow = wS.Cells(Rows.Count, "A").End(xlUp).Row Set myRng = Range(wS.Cells(1, "A"), wS.Cells(lastRow, "T")) With myRng .AutoFilter field:=1, Criteria1:="東京都" .SpecialCells(xlCellTypeVisible).Copy Worksheets("Sheet2").Range("A1") End With wS.AutoFilterMode = False End Sub どうも失礼しました。m(_ _)m
30個以上続いた５の「セルの合計数」ということであればこうでしょうか Dim i As Integer Dim i2 As Integer Dim cnt As Integer Sub x() cnt = 0 For i = 1 To 1000 　If Cells(i, 1) = 5 Then 　For i2 = i + 1 To i + 29 　　If Cells(i2, 1) <> 5 Then 　　　Exit For 　　End If 　Next i2 　If i2 = i + 30 Then 　　cnt = cnt + 30 　　For i3 = i + 30 To 1000 　　　If Cells(i3, 1) = 5 Then 　　　　cnt = cnt + 1 　　　Else 　　　　i2 = i3 　　　　Exit For 　　　End If 　　　Next i3 　　End If 　　i = i2 　End If Next i MsgBox cnt End Sub
印刷範囲の追加は、離れている複数の範囲を指定して印刷することができる機能です。 ただし、改ページプレビューでみていただくとわかりますが範囲は改ページで区切られますのでページが分かれるのはどうしようもありません。 複数の範囲を1ページに収める機能ではないのです。 隣接している範囲なら1ページに収められますが。 ですから、2つ以上の印刷範囲を同じ紙に印刷する為にはプリンターの機能でするしかないのです。 お使いのプリンターにそういった機能があるかどうかを確認された方がいいと思います。
こんばんは！ 元データはSheet1にあるとし、Sheet2に表示するとします。 Sheet2のA列に =IFERROR(INDEX(Sheet1!A1:A10000,MAX(IF(Sheet1!$B$1:$B$10000=15,ROW($A$1:$A$10000))),),"") 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　A列セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ フィルハンドルで右へコピー！ ※　「日付列」は好みの表示形式にしてください。 今回は「15」限定の数式になりますが、汎用性を持たせたい場合は 仮にA1セルに表示したいNoを入力し、それを参照する場合の数式は =IFERROR(INDEX(Sheet1!A1:A10000,MAX(IF(Sheet1!$B$1:$B$10000=$A$1,ROW($A$1:$A$10000)))),"") のように「15」の部分をセル番地（絶対参照）に変更してください。m(_ _)m
No.1様への返信で、やりたい事はだいたいわかりましたが。 サンプルコードでは、×にするには一旦○になっていないとなりません。 つまり×にするには、さかのぼってダブルクリックしなくてはいけないという事です。 入力順のパターンでＢ1の値を変更していく処理で、この仕様自体が無理なのではと思います。 >誤ってダブルクリックしてしまった場合の解決策などありましたら 誤って以前に問題があると思います。 この事を実現する為にダブルクリックでの○×でない方法を考えた方がいいと思います。 成功不成功とＢ1の数値の関係（業務？の意味）がよくわからないので、代替え案までは浮かびませんが、コードを書いていてふと疑問というか出来ないのでは、と思いました。 回答にはなっていませんが、ちょっと考えてみて下さい。
こちらが参考になる手しょう。 https://support.office.com/ja-jp/article/%E3%83% …
Excelで同じファイルで同じ印刷結果とするためには ・同じバージョンのOS ・同じバージョンのExcel ・同じ機種のプリンタ ・同じバージョンのプリンタドライバ が条件になります。どれか一つが違っても結果か変わるのが普通です。 同じ印刷結果にするためには、Excel単体では無理ですので、印刷イメージや画面のキャプチャ画像を「画像として保存」し、その画像をミリ単位で大きさを指定して印刷できるソフト（たとえばラベル印刷ソフトなど）で印刷を実行すれば、近い結果にはなるでしょう。
> どのようにVBAを記述すれば良いでしょうか？ マクロを人任せで作らせても勉強にならないと思います。 Sub Sumple1() Dim xRng As Range Dim arry() As Variant, i As Long Dim sr As Long, lr As Long Dim r As Range Application.ScreenUpdating = False sr = 1 lr = Cells(Rows.Count, 1).End(xlUp).Row Set xRng = Range("A" & sr & ":B" & lr) xRng.Offset(, 2).MergeCells = False arry = xRng.Value For i = 1 To UBound(arry) arry(i, 1) = Left(arry(i, 1), _ InStr(InStr(arry(i, 1) & "\", "\") + 1, arry(i, 1) & "\", "\")) Next i Call ttl(arry, 3) arry = xRng.Value For i = 1 To UBound(arry) arry(i, 1) = Left(arry(i, 1), InStr(arry(i, 1) & "\", "\")) Next i Call ttl(arry, 4) For Each r In xRng.Offset(, 2) If r.Value = "" Then r.Offset(-1, 0).Resize(2, 1).merge End If Next r Set xRng = Nothing Application.ScreenUpdating = True End Sub Sub ttl(arry() As Variant, c As Integer) Dim i As Long For i = UBound(arry) - 1 To 1 Step -1 If arry(i, 1) = arry(i + 1, 1) Then arry(i, 2) = arry(i, 2) + arry(i + 1, 2) End If Next i For i = 2 To UBound(arry) If arry(i - 1, 1) = arry(i, 1) Then arry(i, 2) = vbNullString End If Next i For i = 1 To UBound(arry) Cells(i, c).Value = arry(i, 2) Next i End Sub
じゃあこれで！！
ルール３のみ練習用がてら作ってみました Sub シート1からシート2にコピーする() 　 　Dim Z As Long 　 　Dim n As Long 　 　Dim m As Long 　 　Dim x As Long 　 　Z = Worksheets("Sheet1").Range("A" & Rows.Count).End(xlUp).Row 　 　m = 0 　 　Worksheets("Sheet2").Columns("A:J").ClearContents 　 　For n = 1 To Z Step 10 　 　 　 　m = m + 1 　 　 　 　For x = 1 To 10 　 　 　 　 　 　Worksheets("Sheet2").Cells(m, x).Value = _ 　 　 　 　 　 　Worksheets("Sheet1").Cells(n + x - 1, 1) 　 　 　 　Next x 　 　Next n End Sub
こんなのはいかがでしょうか？ ------------------------------------------------------------------------- Sub Sample() Dim 行終 As Long Dim 列終 As Long Dim シート番号 As Long Dim 行 As Long Dim 列 As Long Dim 結果行 As Long Const ①シート As String = "Sheet1" Const ②シート As String = "Sheet2" Const 結果シート As String = "Sheet3" For シート番号 = 1 To Sheets.Count If Sheets(シート番号).Name = 結果シート Then Application.DisplayAlerts = False Sheets(結果シート).Delete Application.DisplayAlerts = True Exit For End If Next Worksheets.Add after:=Sheets(②シート) ActiveSheet.Name = 結果シート With Sheets(①シート).UsedRange 行終 = .Rows(.Rows.Count).Row 列終 = .Columns(.Columns.Count).Column End With With Sheets(②シート).UsedRange If 行終 < .Rows(.Rows.Count).Row Then 行終 = .Rows(.Rows.Count).Row End If If 列終 < .Columns(.Columns.Count).Column Then 列終 = .Columns(.Columns.Count).Column End If End With 結果行 = 2 Cells(1, 1).Value = ①シート Cells(1, 2).Value = ②シート Cells(1, 3).Value = "セル番号" Cells(1, 4).Value = "検証結果" Cells(2, 4).Value = "OK" For 行 = 1 To 行終 For 列 = 1 To 列終 If Sheets(①シート).Cells(行, 列).Value <> Sheets(②シート).Cells(行, 列).Value Then Sheets(①シート).Cells(行, 列).Interior.Color = RGB(255, 0, 0) Sheets(②シート).Cells(行, 列).Interior.Color = RGB(255, 0, 0) Cells(結果行, 1).Value = Sheets(①シート).Cells(行, 列).Value Cells(結果行, 2).Value = Sheets(②シート).Cells(行, 列).Value Cells(結果行, 3).Value = Cells(行, 列).Address(RowAbsolute:=False, ColumnAbsolute:=False) Cells(結果行, 4).Value = "NG" 結果行 = 結果行 + 1 End If Next Next End Sub ------------------------------------------------------------------------- 対象のシート名を変更したいときは「Const …」行の右辺を変更して下さい。
No.2です。 投稿後気づきました。 0,1,2個の3種類しかないのですね？ ↓の数式に変更してください。 =INDEX({0,1200,3000},G1+1) または =G1*1200+(G1=2)*600
とりあえずこんなのいかがでしょうか？ ---------------------------------------------------------------- Sub Sample() Dim 元行 As Long Dim 先行 As Long Dim 中央 As Long Dim 作業 As Variant 先行 = Cells(Rows.Count, 1).End(xlUp).Row 中央 = Int(先行 / 2) For 元行 = 1 To 中央 作業 = Cells(元行, 1).Value Cells(元行, 1).Value = Cells(先行, 1).Value Cells(先行, 1).Value = 作業 先行 = 先行 - 1 Next End Sub ----------------------------------------------------------------
変換前文字をA列に後の文字をB列に入れるとすると、肝心な元の文字列はどこに入るのでしょうか。 C1セルに入っている文字列を変換するコードを書きますので、 C列から下の文字列全部を処理するのであれば、これを更にループすれば出来ます。 Sub 変換() Dim i As Integer Dim moji As String moji = Range("C1").Value For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row moji = Replace(moji, Range("A" & i).Value, Range("B" & i).Value) Next i Range("C1").Value = moji End Sub
これで、通るはずです。 10000　というのは、組み込み定数のMsoShapeStyleIndex(列挙型)の 線のスタイルのことです。 '// Sub TestArrowSelect() Dim shp As Shape For Each shp In ActiveSheet.Shapes 　　 If shp.ShapeStyle > 10000 The 　　　shp.Select False 　 End If Next shp End Sub
こんにちわ 標準モジュールで、実行してください。 Sub 文字列の末尾に連番を自動で入力B列の値が等しい場合は同じ連番を入力() Dim maxRow As Long Dim i As Long, j As Long Dim myDic As Object, myKey Dim Temp, TempArray Dim str1 As String, str2 As String, str3 As String Const CstAAA As String = "AAAA,BBBB,ABCD" 'Const CstAAA As String = "AAAA" '特別な文字列が一つしかない時は下、複数ある時は上 Set myDic = CreateObject("Scripting.Dictionary") TempArray = Split(CstAAA, ",") For Each Temp In TempArray myDic(Temp) = 0 Next Temp With Worksheets("Sheet3") 'シート名は、実際の物にする maxRow = .Cells(Rows.Count, "A").End(xlUp).Row For i = 1 To maxRow str1 = .Cells(i, 1).Value If myDic.exists(str1) Then str2 = .Cells(i, 2).Value str3 = str1 & "/" & str2 If Not myDic.exists(str3) Then j = myDic(str1) + 1 myDic(str1) = j myDic(str3) = j End If .Cells(i, 1).Value = str1 & "_" & Format(myDic(str3), "00") End If Next i End With End Sub 解らないことがあったら excel vba xxxxで検索してください。 例　excel vba exists　[検索]
こんにちは。 前回の回答者ですが、画像は言葉をいくら尽くすよりも、はるかに、いろんな情報力を持っているようですね。 そのファイルは、人が貰い受けたものでしたら、まず、一旦、Excelを終えてください。 次に、エクスプローラーなどで、そのファイルを右クリックして、プロパティを開きますと、 セキュリティ　このファイルは他のコンピュータから取得したものです。……とありますから、「ブロック解除」を、クリックします、 そして「OK」または「適用」を押しますと、その注意書きがなくなります。 「参照：添付画像」 そして、もう一度、同じようにして、Excelからそのブック(ファイル)を開けますと、同じように黄色い注意書きの帯がでましたら、「コンテンツの有効化」でクリックして、使えるようになるはずです。 使えなかったら、こんどは、ファイル-オプション-セキュリティセンター -セキュリティセンターの設定で、 マクロの設定-警告を表示してすべてのマクロを無効にする ActiveX の設定-先に確認メッセージを表示してから、初期化に危険が伴うコントロールには制限を強化し、初期化して…… あたりを選んで置けばよろしいかと思います。 なお、信頼できる場所等は、そのままにして置いたほうがよろしいかと思います。 以下の画像の細かい部分の違いは気にしないでください。単に、「ブロック解除」の説明だけのためです。 画像引用：http://jisaku-pc.net/hddhukyuu/archives/3331
此処は Excel の部屋だから、「図のような表」もワークシート上にあると推察。 「別シートに…抽出したい」と仰るからには何らかの数式を期待しておられると推察。 数式を作成するには、列記号と行番号から成るセルアドレスが必要。 ところが、参照すべきセルアドレスが「図のような表」にないのは何故？！
シート名を間違えている？ 試しに、その参照できないシートに対して直接セルを指定する方法で参照させてみてはどうか。 １、参照できないシート以外のシートの、任意のセルに半角のイコール（＝）を入力。 ２、イコールを確定せず、その状態から「参照できないシート」を選び、値の入っているセルを選択する。 ３、Enterキーを押して入力を確定する。 これで、値を参照できるはずです。 参照できないと言われるセルの入力と比較してみましょう。
複数範囲を選択したときでも、入力されるセルは一つでそのセルをアクティブセルと呼びます (名前ボックスにも表示されます) 対象の範囲を選択したときに条件付き書式で数式を書かれたとのことですが、 アクティブセルがA1セルならば、セルの相対参照で自分のセル 数式=COUNT (A1)>0 となっていれば、選択範囲すべてに設定されます。 ただ、COUNTA、または、LEN関数のほうが良いような？ 添付図のコマンドをダブルクリックすると便利かも
ご質問のコードをざっと見ると Sleep 1　もう少し長く取りましょう Sleep 10　これでも短いですね。それで、取りこぼすことはないと思います。 それと一緒に、DoEvents も加えておいたほうが無難ですね。 flag = 1 は見つけたという意味ですね。 flag =0 で、Do While flag = 1 なら、Loop は、通らないはずです。 For Each ie In colsh.Windows　'ここは、objIE にするのでは？　IE はわかるけれども、Shell のWindows から取れるものは、生のIE ではないはずです。 別にエラーが出ないなら、こちらが言う筋合いではないと言われそうですが。 それに、終わりがありませんね。For Each ～　Next です。 IE 側は、事前バインディングしているのに、Shell 側はしないのでしょうか。 Set colsh = CreateObject("shell.application") それと、 strTemp = ie.document.Location Document にLocation プロパティはあったのでしょうか。 あまり、人様のコードをいじりまわすと、また、怒られてしまいますが、私の解釈です。ただ、見つからないと、無限ループになる恐れがありそうな気がします。もうひとつ、どこかで安全弁を作ったほうがよいと思います。 Function targeturl(urlmozi As String) As InternetExplorer 　Dim colsh As Object 　Dim ie As InternetExplorer　　'←この部分は浮いています。 　Dim strTemp As String 　Dim objIE As Object 　Dim flag As Integer 　strTemp = "" 　 　'フラッグを初期化 　flag = 0 　Do 　　'flagが０なら、IEの分析を繰り返す 　　Sleep 10 　　 　　'今あるIEをすべて取得します。 　　Set colsh = CreateObject("Shell.Application") 　　'一つずつ分解 　　For Each objIE In colsh.Windows 　　　'分解したieのURLを取得する 　　　　strTemp = objIE.LocationURL 　　　　If InStr(strTemp, urlmozi) > 0 Then 　　　　　flag = 1 　　　　　Set targeturl = objIE 　　　　　Exit For 　　　　End If 　　　'10ミリ秒待って再チャレンジ 　　　Sleep 10 　　　DoEvents 　　Next 　Loop Until flag = 1 End Function そこで、私なりに、コードを考えてみました。ふつう、画面が変わっているなら、IE のイベントを取るのが普通です。 VBA内部のMsgBox ですと、あまり華々しくメッセージが出ませんでしたが、拾っていることは間違いないです。 このURLの番号を探すプログラムです。 http://oshiete.goo.ne.jp/qa/9396135.html 要：Microsoft Internet Controls 'ThisWorkbook モジュール Private WithEvents objIE As InternetExplorer Sub StartIE() 　　myURL = "https://oshiete.goo.ne.jp/” 　　Set objIE = Nothing 　　Set objIE = New InternetExplorer 　　 　　objIE.Navigate myURL 　　objIE.Visible = True End Sub Private Sub objIE_NavigateComplete2(ByVal pDisp As Object, URL As Variant) Dim FindTxt As String FindTxt = "9396135" 　If InStr(1, pDisp.LocationName, FindTxt, 1) > 0 Then 　　 Application.EnableEvents = False 　　 Call Call GetIEObject(objIE) 　End If End Sub '標準モジュール Sub GetIEObject(obj As InternetExplorer) 　 MsgBox obj.LocationURL End Sub もしも、勘違いしていましたら、ご寛容のほどを。
条件付き書式の設定ではダメでしょうか。 一例 A3～D5セルを　選択 条件付き書式の設定 数式を利用して・・・ =LEN(SUBSTITUTE(SUBSTITUTE(A5,0,""),";",""))>0 の式を切れる 右下の書式のボタンで　塗りつぶしを　黄色に OKで終了してみて下さい。
こんにちわ このコードは、一つのcsvファイルを読み込んで処理する物です。 Option Explicit Dim FullFilePass As String Dim dMaxArr() As Double, dTotalArr() As Double Dim iCountArr() As Long Dim iRow As Long Dim myDic As Object Sub CallSubCsvLineInput() Dim i As Long, j As Long Dim outArea, myDicKeys Dim TempArr iRow = -1 Set myDic = CreateObject("Scripting.Dictionary") FullFilePass = "D:\AAA\BBB\yyyymmdd_対象サーバ名_種類_01.csv" 'Pass は、実際の物にする Call CsvLineInput ' FullFilePass = "D:\AAA\BBB\yyyymmdd_対象サーバ名_種類_02.csv" ' 'Pass は、実際の物にする ' Call CsvLineInput myDicKeys = myDic.keys ReDim outArea(UBound(dMaxArr), 4) For i = 0 To UBound(dMaxArr) TempArr = Split(myDicKeys(i), "■") outArea(i, 0) = TempArr(0) outArea(i, 1) = TempArr(1) outArea(i, 2) = TempArr(2) outArea(i, 3) = dMaxArr(i) outArea(i, 4) = dTotalArr(i) / iCountArr(i) Next i TempArr = Split("日付､対象サーバ､種類､最大値､平均値", "､") 'シート名は、実際の物にする Sheets("Sheet1").Cells(1, "A").Resize(1, 5).Value = TempArr Sheets("Sheet1").Cells(2, "A").Resize(UBound(dMaxArr) + 1, 5).Value = outArea Set myDic = Nothing Erase dMaxArr, dTotalArr, iCountArr End Sub Private Sub CsvLineInput() Dim intFF As Long Dim strTemp As String Dim TempArr Dim DblTemp As Double Dim DicKey As String Dim i As Long, j As Long intFF = FreeFile Open FullFilePass For Input As #intFF 'Line Input #intFF, strTemp '必用があれば一行目を読み飛ばす Do While Not EOF(intFF) Line Input #intFF, strTemp TempArr = Split(strTemp, ",") 'Split(TempArr(0), " ")(0)・・・日付時分秒から、日付け部分だけを取り出す。 '実物のデータを見ないとこれで良いかは不明 DicKey = Split(TempArr(0), " ")(0) & "■" & TempArr(1) & "■" & TempArr(2) DblTemp = CDbl(TempArr(3)) If Not myDic.exists(DicKey) Then iRow = iRow + 1 myDic(DicKey) = iRow ReDim Preserve dMaxArr(iRow) ReDim Preserve dTotalArr(iRow) ReDim Preserve iCountArr(iRow) dMaxArr(iRow) = DblTemp dTotalArr(iRow) = DblTemp iCountArr(iRow) = 1 Else i = myDic(DicKey) If dMaxArr(i) < DblTemp Then dMaxArr(i) = DblTemp dTotalArr(i) = dTotalArr(i) + DblTemp iCountArr(i) = iCountArr(i) + 1 End If Loop Close #intFF End Sub フォルダの全部のcsvファイルを処理するとか、 ダイアログを開いて、csvファイルを選択するとかの変更を 望む場合、新しく質問を建ててください。
I列の下から5番目までの入力されている数値（計5つ）の平均値 =AVERAGE(OFFSET(I1,MATCH(10^15,I:I,1)-5,0,5)) こういう意味でしょうか？
難しいですね。 =NETWORKDAYS(A1,A2,F1:F53) A1:2014/1/1 A2:2016/8/26 F1:F53 （祭日データ　気をつけたつもりでも、間違っているかもしれません。) 今年から、「山の日」が加わったのでしたね。 14/01/01,14/01/13,14/02/11,14/03/21,14/04/29,14/05/03,14/05/04,14/05/05,14/05/06,14/07/21,14/09/15,14/09/23,14/10/13,14/11/03,14/11/23,14/11/24,14/12/23,15/01/01,15/01/12,15/02/11,15/03/21,15/04/29,15/05/03,15/05/04,15/05/05,15/05/06,15/07/20,15/09/21,15/09/22,15/09/23,15/10/12,15/11/03,15/11/23,15/12/23,16/01/01,16/01/11,16/02/11,16/03/20,16/03/21,16/04/29,16/05/03,16/05/04,16/05/05,16/07/18,16/08/11,16/09/19,16/09/22,16/10/10,16/11/03,16/11/23,16/12/23
>Ｂ3セルに=ROUNDDOWN(B2*24,2)と入力し、表示形式標準にすると、60分が1ではなく、0.99で変換されます。 一旦、整数化して小数点誤差を消し、それから計算しては？ =ROUNDDOWN(TEXT(B2,"[m]")/60,2)
「一括で書き換える」と言えるかどうかは微妙ですが…。 I列を選択（I列を縦に全部）して、オートフィルタ。「-5より小さい」でフィルタを掛けます。 最初のセルに-5を入力して、下にコピー。 オートフィルタを解除して出来上がりです。
No.1です。 ＞色変えしたいセルを選択した後に色変更したいです。 というコトですので、↓のコードにしてみてください。 今回も前回同様、Sheet2のA列に「文字列」、B列セルを「塗りつぶし」の準備ができているとします。 Sub Sample2() Dim i As Long, k As Long, myStr As String, wS As Worksheet Dim myRng As Range, myFound As Range, myFirst As Range Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") Set myRng = Selection '←★// For i = 1 To wS.Cells(Rows.Count, "A").End(xlUp).Row myStr = wS.Cells(i, "A") Set myFound = myRng.Find(what:=myStr, LookIn:=xlValues, lookat:=xlPart) '←★// If Not myFound Is Nothing Then Set myFirst = myFound GoTo 処理 Do Set myFound = myRng.FindNext(after:=myFound) '←★// If myFound.Address = myFirst.Address Then Exit Do GoTo 処理 処理: For k = 1 To Len(myFound) If Mid(myFound, k, Len(myStr)) = myStr Then myFound.Characters(Start:=k, Length:=Len(myStr)) _ .Font.ColorIndex = wS.Cells(i, "B").Interior.ColorIndex End If Next k Loop End If Next i End With End Sub ※　コードそのものは前回とほとんど変わっていません。 （★の行が変わっています） 範囲指定は列全体でもシート全体でも構いません。m(_ _)m
>先方から頂いたエクセルの書式の中にマクロが一部あります この意味が分かりません。 書式という所にはマクロは載せられません。 VBEditor のことではないでしょうか。 まず、Excel(起動の際に、Ctrl を押し続ける)をセーフモードにして開いて、ファイルをたちあげて、VBEditorが開けられるなら開けて、 それを公開して貰わないといけないでしょうね。 もしくは、xlsx で再保存して、マクロを抜いてしまう方法もあります。
たぶん、私の回答は、「分からない」→ボツになるのかもしれませんが、問題の解決は100%するはずです。実験もしてみましたから。 ただし、Excelが健全な状態です。私のExcelは調子っぱズレでしたので、修復を掛けて、元に戻してから、実行しました。(主に下位バージョンとの整合性の問題) ExcelAutomation.VBS というファイル名で、メモ帳で作ります。 オートメーション名：Excel.Application.14 Book名　->Book1.xlsm Excelファイルの位置は、デフォルト マクロ名:　RMacro こうすると、現在のExcelとは別に動いています。 '//Excel Automationizing Set xlApp = CreateObject("Excel.Application.14") On Error Resume Next xlapp.workbooks.open xlapp.DefaultFilePath &"\book1.xlsm" xlapp.Visible = True xlapp.Run "book1.xlsm!RMacro"
「aやbの表の値を変えると『全データ』に出来ている表の値も同時に更新されるようにしたいです。」ですと処理が重くなってしまうのでやめた方が良いです。 それよりも『全データ』シートを開いた時に変更されていれば良いはずなので『全データ』のシートモジュールの『Worksheet_Activate()』イベントで『matome』をコールした方が良いと思います。 ただ、このままだといくつかの問題が有ります。 ① 先に『全データ』シートが無いと『Worksheet_Activate()』イベントにコードを書き込む事ができません。 ②『○○.Activate』みたいな物がいくつかあるので直さないといけません。 --------------------------------------------------------------- 話は変わりますが、提示のコードでは『b』シートの１列目が『全データ』シートで抜けてしまいます、修正が必要ですよ。
No2です。　リカバリー用のソフトが、購入時の箱に入っていると思いますよ。
今回は、フォルダーのあるかないかですから、パターンAしか該当しません。 >1)A1が空白の時 →　「A1が空白です」　 >2)A1の値のフォルダーが「C:\A\」にあった時 →　「フォルダーあります」 >3)A1の値のフォルダーが「C:\A\」になかった時 →　「フォルダーないです」 条件式を内部で行うのか外部で行うかの別はありますが、コードが成り立てないなら、それは除外。 それは、どちらでも可能でしょう。 Option Explicit Sub MacroTEST() 　　Dim MyFolder As String 　　Const myPATH As String = "C:\A\" If Range("A1").Value="" Then　　'この部分がなくても、OK 　　 MsgBox("A1が、空白です") End if 　　Cells(1, "C").Value = StrConv(Cells(1, "A"), vbNarrow) 　　MyFolder =Cells(1, "C").Value　'半角処理 　　 　　If Len(Dir(myPATH & MyFolder, vbDirectory)) > 0 And _ 　　　　Dir(myPATH & MyFolder, vbDirectory) = MyFolder Then 　　　　MsgBox MyFolder & "はあります。", vbInformation 　　Else 　　　　MsgBox MyFolder & "が見つかりません。", vbExclamation 　　End If 　　Range("A1").Select End Sub
こんにちは！ 標準モジュールにしてください。 Sub Sample1() Dim i As Long, wS As Worksheet Dim myS As Range, myV As Range, myN As Range, myR As Range Set wS = Worksheets("Sheet2") Set myS = wS.Rows(1).Find(what:="種類", LookIn:=xlValues, lookat:=xlWhole) '←「種類」列を取得// Set myV = wS.Rows(1).Find(what:="数量", LookIn:=xlValues, lookat:=xlWhole) '←「数量」列を取得// Set myN = wS.Rows(1).Find(what:="番号", LookIn:=xlValues, lookat:=xlWhole) '←「番号」列を取得// With Worksheets("Sheet1") For i = 3 To .Cells(Rows.Count, "H").End(xlUp).Row Set myR = wS.Columns(myN.Column).Find(what:=.Cells(i, "H"), LookIn:=xlValues, lookat:=xlWhole) If Not myR Is Nothing Then .Cells(i, "A") = wS.Cells(myR.Row, myS.Column) .Cells(i, "B") = wS.Cells(myR.Row, myV.Column) End If Next i End With MsgBox "完了" End Sub こんな感じで良いのでしょうか？m(_ _)m
TextBox1はオブジェクトなので、Range()で取得するものではなく、そのオブジェクトを直接操作するものです。 ANo.1にあるとおり、TextBox1.SetFocus()によってフォーカスが遷移します。 http://officetanaka.net/excel/vba/tips/tips17.htm http://www.atmarkit.co.jp/ait/articles/1411/26/n …
入力規則を設定します。 A列全体を選択した状態でAlt、D、Lと押下します。 「入力規則」のダイアログが開きます。 （Excelのバージョンによって入力規則ダイアログの開き方は異なりますが、上記の方法ならどのバージョンでも開くでしょう） ダイアログの「設定」タブ→「入力値の種類」→「ユーザー設定」を選択します。 「数式」に =A1=PHONETIC(A1) と入力します。 「エラーメッセージ」タブをクリックし、タイトルとエラーメッセージを入力します。 タイトルに「ひらがなで入力」、エラーメッセージに「ひらがなで入力してください。」とするなど、好みで文字列を設定してください。 その後、A列を選択した状態のまま、Alt、O、T、Tと押下して「ふりがなの編集」ダイアログを表示させます。 「種類」を「ひらがな」に設定します。 これで全角ひらがな以外を入力するとエラーが出るようになります。 B列については、B列全体を選択した状態→同様に「入力規則」ダイアログから、「設定」タブ→「入力値の種類」→「ユーザー設定」→「数式」に =ISNUMBER(B1) と入力します。 「タイトル」や「エラーメッセージ」なども適時設定してください。 また同時に「日本語入力」タブで「日本語入力」を「無効」に設定します。 これで半角英数しか入力ができなくなります。 ※Officeは2003依然とそれ以降で操作性が大きく異なります。 入力規則ダイアログ 2003以前 メニューの「データ」→「入力規則」 2007以降 リボンの「データ」→「入力規則」から ふりがなの設定 2003以前 メニューの「書式」→「ふりがな」→「ふりがなの設定」 2007以降 リボンの「ホーム」→「フォント」グループの「ふりがなの表示/非表示」の右にある「▼」をクリック
>コピーして貼る、なども含めて、チマチマした手作業をなくしたかったんです。 えーっと…一応、一応、念のために書いておきますが、「範囲選択してコピー→値貼り付け」とはＡ1セル選択してコピー→値貼り付け、Ｂ1セル選択してコピー→値貼り付け、Ｃ1セル選択・・・・ ではなくて、Ａ1から表の範囲をダダーっと選択して一遍にコピー→値貼り付けをすることです。 面倒ならＡ1セルの斜め左上を押して全セル選択してからコピー→値貼り付けでもいいです。 >VLOOKを用いた箇所はB.xlsの数値を目で見て手で入力しています。 この作業をされている方が、今さら範囲選択して値貼り付けがチマチマしていると表現されているのがどうにも腑に落ちず… 「リンクの解除」もクリック3つくらいでできますしね。 外部リンクの値を保存する設定は、VLOOKUPの参照元の情報を持ったまま相手に行ってしまいますので、検索値を書き換えた時に元情報にある値だったら式の結果が出てしまう事があります。 Aブックを渡したくないということですから、見られたくない部分もわかってしまう可能性もあります。 かなり諸刃の剣な設定だと思います。それを踏まえた上でお使い下さい。
No.1 の訂正です。「分」が抜けてしまいました。 書式設定を以下のどちらかに設定してください。 ①「[<=0.0416][mm]"分";[h]"時間"mm"分"」 ②「[<=0.0416][m]"分";[h]"時間"mm"分"」 ①と②の違いは１０分未満、たとえば９分の時、①は「09分」②は「9分」と表示されます。お好きなほうをお使い下さい。 ついでなので、説明です。 「0.0416」は「1」を「24」を割った物です。これはエクセルが24時間を「1」としている事を使っています。
こんにちは！ 一例です。 画像の配置だとSheet3のC2セル（表示形式は好みの日付にしておく）に =IF(COUNTBLANK(A2:B2),"",INDEX(Sheet1!$1:$1,MIN(IF(IF(COUNTIF(Sheet1!A:A,A2),OFFSET(Sheet1!$1:$1,MATCH(A2,Sheet1!$A:$A,0)-1,,1),OFFSET(Sheet2!$1:$1,MATCH(A2,Sheet2!A:A,0)-1,,1))=B2,COLUMN(1:1))))) 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　C2セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ フィルハンドルで下へコピーしてみてください。 ※　「部屋番号」と「顧客名」が一致しない場合は「0」が表示されてしまいます。 Excelのオプションで「ゼロ値」を表示させないとか、セル色を変えるとか・・・ 他の工夫が必要になってきます。 時間があればその対処も数式でできると思いますが、数式そのものがやたらに長くなるような気がします。 一発で解決！とはいかないと思いますが、 まずはこの程度で・・・m(_ _)m
添付図参照 Sheet2!B1: =VLOOKUP(LEFT(A1,2)&"*",Sheet1!A:B,2,FALSE)
F2: =IF(COUNTIF(D2:E2,"*承認")=2,D2,IF(COUNTIF(D2:E2,&quot;*承認")=1,SUBSTITUTE(D2&E2,"-",""),"-"))
とりあえずこんな物でいかがでしょうか？ --------------------------------------------------------------------- Sub Macro1() Dim シート番号 As Long Dim 行 As Long For シート番号 = 2 To 33 Sheets(シート番号).Select Range("A100:N113").ClearContents For 行 = 26 To 39 If Cells(行, 1).Value = "大計" Then Exit For Next Range(Cells(行, 1), Cells(39, 14)).Copy Range("A100").Select Selection.PasteSpecial _ Paste:=xlPasteFormats, _ Operation:=xlNone, _ SkipBlanks:=False, _ Transpose:=False Selection.PasteSpecial _ Paste:=xlPasteValues, _ Operation:=xlNone, _ SkipBlanks:=False, _ Transpose:=False For 行 = 1 To 39 If Cells(行, 1).Value = "小計" Then Exit For Next Range(Cells(行, 1), Cells(39, 14)).ClearContents Range("A100:N113").Cut Range("A26").Select ActiveSheet.Paste Application.CutCopyMode = False Next End Sub ---------------------------------------------------------------------
こんな事ですか？ ---------------------------------------------------------------------- Sub Sample() Dim 元 As Long Dim 先 As Long Dim 英 As String Dim 日 As String For 元 = 1 To 445 Step 3 英 = Cells(元, 1).Value 日 = Cells(元 + 1, 1).Value Range(Cells(元, 1), Cells(元 + 1, 1)).ClearContents 先 = 先 + 1 Cells(先, 1).Value = 英 Cells(先, 2).Value = 日 Next End Sub ---------------------------------------------------------------------- ※注．同じシート上として作りました。
こんばんは 先ほどの回答にいろいろと不備があったので、修正版です。 結果的にはNo.4さんの回答に近いものになりました。 Sub Macro3() Dim Line As Long Dim Year As Long Const EndYear As Long = 10000 Line = 1 'タイトル行の上書きを防ぐため Year = 1900 Do 　 Line = Line + 1 '次の行に進む 　 Cells(Line, "A") = Year 　 Cells(Line, "B") = "○" '4年ごとなのでまずは、全部"○" 　 If Cells(Line, "A") Mod 100 = 0 Then Cells(Line, "B") = "×" '例外として100で割り切れる年は× 　 If Cells(Line, "A") Mod 400 = 0 Then Cells(Line, "B") = "○" 'さらに例外として400で割り切れる年は"○"に復活 　 Year = Year + 4 '4年ごと Loop Until Year > EndYear End Sub VBAのコメントと重なりますが、 「基本→例外→例外の例外」 を１つのループの中で上書きしています。
ただでさえ難しいのに、その条件では不可能です。（少なくとも未熟者の私には･･･）
何のためにとか、良く判りませんが Ｕ4セルに「=IF(OR(H16=D87,N16=D87,T16=D87,Z16=D87,AF16=D87),D87,"")」ですか？
Sample1 は、ご質問者さんのマクロを直したものです。 これでは、図形以外にも全部消し去ってしまいます。 Sample2 は、Formボタンや画像などは残すようにしたマクロです。 '// Sub Sample1() 　Dim sh As Worksheet 　For Each sh In Worksheets 　With sh 　　If .Shapes.Count > 0 Then 　　　 .Shapes.SelectAll 　　　　Selection.Delete 　　End If 　End With 　Next End Sub '// Sub Sample2() 　Dim sh As Worksheet 　Dim shp As Shape 　For Each sh In Worksheets 　　With sh 　　　For Each shp In .Shapes 　　　　If shp.Type = msoAutoShape Then　'オートシェイプのみ 　　　　　shp.Delete 　　　　End If 　　　Next shp 　　End With 　Next End Sub 一括して消しても、ループで消しても、それほど大差はありません。なお、Sample1 の手法は、Excelではあまり使われないようです。
現段階でランサムウエアに暗号化された拡張子luckyのファイルと拡張子zeptoのファイルは確実なものがあると断言できません。 http://hi-kick.jp/info/pc-mainte/zepto.html にいくつか紹介されているようですが、万能ではありません。亜種に対しては無力である可能性が高いです。 請け負っている会社があるそうです http://pc-setting.com/ でも複合化したという話は聞いてません。 Data Recovery Proなら複合できるとしています http://sakujosuru.jp/guides/zepto-file-virus このソフト自体がインチキ金集めソフトです。そんな機能があるなんて話は聞いたことがありません。
こんばんは。 たぶん、検索ログというものですね。 検索というのは、Ctrl + F または、ホームタブ-編集の検索ですよね。 少し、検証してみましたが、これは、ちょっと、涼しくなったら、というような条件付きの話になりそうです。 一度はやりかけたものの、途中で頓挫してしまいました。 私の考え方が間違いなければの話ですが、ExcelやC言語が得意で、若くて知識のある方なら、こなせられるだろうとは思いますが、ここらへんは、私がもたついている技術ですね。今さら、Win32 APIを追い求めてもしょうがないという気持ちもあるからです。 Winspector spy というツールで、途中までは、検索ダイアログの子ウィンドウのハンドルを入手するぐらいのところまでは来たものの、その先が進めません。 Excel2003時代には、ここの回答者の某氏が開発していたのですが、Excel 2007以上になると勝手が違うようで、昔のようには行きません。 まず、ホームタブ-編集-検索の所にフックをつけるところまではやっとこぎつけた程度で、その先が進めません。 というわけで、「Excelで検索した語句」の出力というものは、ここ最近、そうした技術を扱っている方も見当たりませんので、事実上、無理だということになりそうです。 以下は、内容が違っているとは思いますが、似たようなことをします。 https://oshiete.goo.ne.jp/qa/5554143.html myHwnd = FindWindowEx(0&, 0&, "bosa_sdm_XL9", "検索と置換") ですが、もしかしたら、UWSC(ウィンドウズ・マクロ)なら、ここらは簡単にやり抜けるかもしれません。 ご質問者自身がトライしてみてもよいかもしれません。
こんにちは！ VBAになりますが一例です。 元データはSheet1にあり、Sheet2に表示させるとします。 前提条件として↓の画像のようにSheet1のデータはA列の１ぎょうめから規則正しく連続している！とします。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long, wS As Worksheet Set wS = Worksheets("Sheet2") Application.ScreenUpdating = False wS.Cells.Clear With wS.Range("A1") .Value = "会社名" .Offset(, 1) = "役職" .Offset(, 2) = "就任日" .Offset(, 3) = "氏名" End With With Worksheets("Sheet1") For i = 1 To .Cells(Rows.Count, "A").End(xlUp).Row Step 4 '←1行目～A列最終行まで// .Cells(i, "A").Resize(4).Copy wS.Cells(Rows.Count, "A").End(xlUp).Offset(1).PasteSpecial Paste:=xlPasteValues, Transpose:=True Next i wS.Range("C:C").NumberFormatLocal = "yyyy/m/d" '←表示形式は好みの日付で！// End With With wS.Range("A1").CurrentRegion .Sort key1:=wS.Range("A1"), order1:=xlAscending, Header:=xlYes .Borders.LineStyle = xlContinuous End With wS.Activate wS.Columns.AutoFit wS.Range("A1").Select Application.ScreenUpdating = True MsgBox "完了" End Sub 'この行まで// ※　関数でないのでデータ変更があるたびにマクロを実行する必要があります。 ※　元データの配置が異なれば全く意図しない動きになってしまいます。 まずはこの程度で・・・m(_ _)m
ユーザ定義関数での実装はいかがでしょう。 下記のユーザ定義関数(userCONCATENATE)を標準モジュールに張り付けた後、シート上に次の式を入力して、下にコピーしてください。 H3セル =userCONCATENATE($C$1:$G$1,C3:G3) Function userCONCATENATE(出荷コード範囲 As Range, 丸印範囲 As Range) As Variant Dim i As Long userCONCATENATE = "" For i = 1 To 丸印範囲.Count If 丸印範囲(i).Value = "○" Then If userCONCATENATE <> "" Then userCONCATENATE = userCONCATENATE & "," userCONCATENATE = userCONCATENATE & 出荷コード範囲(i).Value End If Next End Function
>最初、回答の数式をｺﾋﾟｰして貼り付けましたが、「＠」と「なし」しか表示されず、なぜ「@」なのかさっぱりわからず途方にくれました。 添付図の通りならできるはずです。 ただ、「＠」が出る方法が分かりません。 たぶん、回答の下の数式を入力して、char(64)の計算結果になったとは思うのですが。 >ネットで検索しても見つかりませんでした。 そうですね。検索では見つけにくいかもしれません。 > 最後、ダメで元々と手入力するとすんなりとできました。 当方の回答では、漢数字の零 〇 を検索しています。 なぜならご質問に書いてあるからです。 tom04さんはまる ○ を検索しています。 そこで違いが出たのかもしれません。 > 数式は何となくしかわかりません。特に「９，１」は見当がつきません。 例としてH4セルでは 1/(B4:F4="○") の計算結果が {1,1,1,#DIV/0!,#DIV/0!} となり lookup関数が二分探索するので、9未満の一番右を返します。エラーも無視してくれます。 つまり、3番目。 ここで、検索値を9ではなく1にすると、おかしな動作になるので、 1を超える数値である9を設定しました。別に2でも3でも99999でも良いです。 で COLUMN(B$1:F$1) を計算した {2,3,4,5,6} の3番目 つまり、4 CHAR(64+4) が Dとなります。
作業列を使いまくりなのですが、こんな感じでどうでしょう。 質問内容を読み違えていたら、ごめんなさい。 A列およびB列の1行目から下に、値が入力されているものとします。 下記の式を入力して、下にコピーします。 C1セル =IF(A1<B1,A1&B1,B1&A1) D1セル =COUNTIF($C$1:C1,C1)<2 E1セルに次の式を入力すると答えが表示されます。 E1セル =COUNTIF(D:D,TRUE)
2個しかないなら =A1&REPT("/",COUNTA(A1:B1)=2)&B1 いくつも繋げるセルがあるなら =SUBSTITUTE(TRIM(A1&" "&B1)," ","/")
特に問題は無さそうですが…。 あてずっぽうで、「シートが保護されていて、該当セル（B1)が変更できない」
選択されたセル範囲をイベントプロシージャに渡すTargetを何故使うのかが解りませんし、何故１回でやる必要があるのかも解りません。 Range(Cells(Target.Row + 1, 3)）と、わざわざRANGEにする理由も解りません。 返信内容をそのまま尊重するなら、赤にするとすれば、 Cells(Target.Row + 1, 3).Interior.ColorIndex = 3 Cells(1, 2).Interior.ColorIndex = 3 と２回に分ければ良いのでは？？？ with End with などでシートが選択されている前提で書いてます。
ネライが　もしかして　｛Ｎ日目にシフトが入っている人で、前日(N-1)日目にはシフトが入っていない人の名前を、データ２sheetに表示させる｝ということならば、次のようなのではどうでしょうか。 イメージとして画像をみてください。 例えば、スタッフは３～９行目に入れるとします。（行数は問題ではない） どの行に書くかは、シフト時間帯とか同時間帯に入るスタッフ数とかあるのでしょうが、問題にしてません。 [テータ２]sheetのB列B3に《=IF(ISERROR(VLOOKUP(データ!B3,データ!A$3:A$9,1,0)),データ!B3,"")》の式をいれ、下方向と右方向にコピーします。 ただこの方式の場合、《○月1日》の前日のシフト表がデータにないので、《○月1日》についてはなにも出来ません。　28日～1日～31日のような前月をまたぐ表を作ってあれば、それ1日のことも出来ます。
こんばんは！ 画像の配置通りだとしての一例です。 Sub Sample1() Dim i As Long, k As Long, myStr As String Dim myFound As Range, myFirst As Range For i = 2 To Cells(Rows.Count, "A").End(xlUp).Row myStr = Cells(i, "A") Set myFound = Range("C:C").Find(what:=myStr, LookIn:=xlValues, lookat:=xlPart) If Not myFound Is Nothing Then Set myFirst = myFound GoTo 処理 Do Set myFound = Range("C:C").FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do GoTo 処理 処理: For k = 1 To Len(myFound) If Mid(myFound, k, Len(myStr)) = myStr Then myFound.Characters(Start:=k, Length:=Len(myStr)).Font.ColorIndex = 3 End If Next k Loop End If Next i End Sub こんな感じではどうでしょうか？m(_ _)m
すいません。No.2 ママチャリです。 式を入力するのは、A1セルではなくD1セルでした。
ユーザ定義関数(userF)を書き換えてみました。 前回のものを流用してしまったので、ちょっと歪ですが、こんな感じです。 処理の違いは以下の通りです。 （前回）検索文字列（分解したもの毎に）で、検索範囲の各セルを検索 （今回）検索範囲の各セルの文字列で、検索文字列を検索 Function userF(検索文字列 As String, 検索範囲 As Range) As Variant Dim r As Range userF = "" For Each r In 検索範囲.Rows("1:" & 検索範囲.Cells(Rows.Count, 1).End(xlUp).Row) If InStr(1, 検索文字列, r.Cells(1, 1).Text) <> 0 Then If userF <> "" Then userF = "エラー" Else userF = r.Cells(1, 2).Text End If End If Next End Function
下記の設定が変更された可能性があります。シート数は無関係です。 オプション→計算方法　計算方法→「自動」を選択
一例です。 Range("A1").Value　の前にシート名を記述するかどうかはお任せします。 Sub test() If Dir("C:\A\" & Range("A1").Value, vbDirectory) = "" Then MsgBox "ないです" Else MsgBox "あります" End If End Sub
OS： windows10 64bit で，excel 32bit ではlongのほうが速いです． （今，再度確認してみました） 実際，integerは もう使うこと無いんじゃないでしょうか．3万少々ではすぐにオーバーしてしまいます． 最近のPCであれば，「VBAの整数はlong」として考えています． 速度を気にするような計算はそもそもVBA以外の言語を使うし．
>しばらく質問は開けておきます。 と云うことなので、ちょっとだけ回答させていただきます。 フォルダ内のファイル名が、「図番」もしくは「図番＋改正コード」でユニークになっているのであれば、こんな感じでいけると思います。 ZZ-TOPさんの書いたコードをベースにしているので、読んでいただければ理解できると思いますが、念のため、変更点だけ仕様を書いておきます。 【仕様】 テキストボックス１に入力されているファイル名に、”？”（任意の1文字を表すワイルドカード）を付加して、実際に存在しているファイル名を求める。 ファイルが存在していない場合、その旨メッセージを表示して終了。 存在していれば、その名前をテキストボックス２へ転記。以降は、ZZ-TOPさんの書いたコードと同じです。 Private Sub CommandButton3_Click() Dim WSH As Object Dim FName As String Set WSH = CreateObject("Wscript.Shell") FName = Dir("C:\A" & "\" & TextBox1.Value & "?.pdf", vbNormal) If FName = "" Then MsgBox "ファイルが見つかりません。", vbExclamation Else FName = "C:\A" & "\" & FName TextBox2.Value = FName WSH.Run """" & FName & """", 3 Dim lastRow As Long With Worksheets("Sheet2") lastRow = .Cells(.Rows.Count, 1).End(xlUp).Row + 1 .Cells(lastRow, 1) = TextBox1.Value End With End If Set WSH = Nothing End Sub
「同月内」ということは「年」は考慮しなくても構わないと？ つまり、2016～2018年の「年」はチャンポンになっても「月」が同じであれば「同月内」であると？ホント？ 後になって「それじゃ困る」とか言わないでせうネ！
株価を想像していたのですが、金相場ですか。 Excelでなければ、Googleでつけておく方法もあるそうですが。 #2様のご紹介の、Webクエリでもいいです。 以下は、田中貴金属様のサイトから情報を取り出す、DOMのマクロです。 画面は一日に一度しか変わらないようですから、DOM(HTMLの骨組み）で取れます。 恒久的なマクロではありませんが、DOMで情報を取りやすいので、また面白いかと思います。分かる人は、これを元に試してみるとよいと思います。 ここのサイトは、なぜか、外部から取得しやすいようになっています。なお、外為の場合は、WinHttpでは取れません。また、外為のサイトの中では、Webクエリで取れないものもあります。そういう場合は、以下のコードとは違うアクセスの仕方があります。 下記のSelect Case を工夫すれば、サイトのほとんどの情報は、入手できるようです。 空のシートで試してみてください。 なお、「 "アクセスに失敗しました。」というエラーが返った時は、必ず、サイトを覗いてみてください。これは、通信に障害があった場合です。 それと、これを毎日決まった時間に取得する方法は、タスクスケジューラを使いますが、もう一つ違う技術が必要です。 '// Sub GetPriceofGold() 　　Dim objHTTP As Object 　　Dim httpLog As String 　　Dim ar As Variant 　　Dim n As Variant 　　Dim strURL As String 　　On Error GoTo ErrHandler 　　'Microsoft WinHTTP Service, version 5.1 　　Set objHTTP = CreateObject("WinHttp.WinHttpRequest.5.1") 　　 　　strURL = "http://gold.tanaka.co.jp/commodity/souba/d-gold. … 　　 　　objHTTP.Open "GET", strURL, False 　　objHTTP.Send 　 　　If objHTTP.Status <> 200 Then 　　　 MsgBox "アクセスに失敗しました。" & objHTTP.Status, vbExclamation 　　　 Exit Sub 　　Else 　　　　httpLog = objHTTP.ResponseText 　　　　Call GetLog(httpLog) 　　End If ErrHandler: If Err() > 0 Then 　 MsgBox Err.Number & " " & Err.Description End If Set objHTTP = Nothing End Sub Sub GetLog(httpLog As String) 　Dim mn As Variant, mdt 　Dim oHtml As Object 　Dim arBuf(4), buf As Variant 　Dim n As Variant 　Dim i As Long, j As Long 　Dim LastRow As Long, c As Range 　''Microsoft HTML Object Library 　LastRow = Cells(Rows.Count, 2).End(xlUp).Row 　If LastRow = 1 Then 　　Range("A1").Resize(, 5).Value = Array("地金価格公表日本時間", "税別小売価格", "小売価格先日比", "税込買取価格", "買取価格前日比") 　　For Each c In Range("A1:E1") 　　　c.EntireColumn.AutoFit 　　Next c 　End If 　Set oHtml = CreateObject("HTMLfile") 　oHtml.body.innerHTML = httpLog 　With oHtml 　　Set mn = .getElementByID("main") 　　mdt = Split(mn.innerText, vbCrLf) 　　For Each n In mdt 　　If n <> "" Then 　　　 Select Case True 　　　 Case n Like "地金価格*" 　　　　arBuf(0) = n 　　　 Case n Like "（小売価格*" 　　　　arBuf(1) = n 　　　 Case n Like "(*円)" 　　　　If arBuf(2) = "" Then 　　　　　 arBuf(2) = n 　　　　Else 　　　　　 arBuf(4) = n 　　　　　 Exit For 　　　　End If 　　　 Case n Like "（買取価格*" 　　　　arBuf(3) = n 　　　 End Select 　　 End If 　　Next 　　buf = Replace(arBuf(0), "地金価格", "") 　　buf = Mid(buf, 1, InStr(buf, "公表") - 1) 　　arBuf(0) = buf: buf = "" 　　 　　arBuf(1) = Mid(arBuf(1), InStr(1, arBuf(1), "）", 1) + 1) 　　arBuf(3) = Mid(arBuf(3), InStr(1, arBuf(3), "）", 1) + 1) 　End With 　Cells(LastRow + 1, 1).Resize(, 5) = arBuf() 　'数値変換(不要なら、ここまででも良い） 　For i = 2 To 5 　 Cells(LastRow + 1, i).Value = Replace(Cells(LastRow + 1, i).Value, "円", "") 　 Cells(LastRow + 1, i).Value = Val(Replace(Cells(LastRow + 1, i).Value, "(", "", , , 1)) 　Next End Sub
「○のセルをクリックしただけで×に変わるとか」の件 （ https://oshiete.goo.ne.jp/qa/9384928.html の続き） 本来は出来ませんが、別のイベントを無理やり使えば出来ます。 ☆「SelectionChange」イベントを使った場合 （イベントを無理やり発生させるため、変更後隣のセルを選択する） --------------------------------------------------------------------- Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Target.Column <> 1 Then Exit Sub If Target.Value = "○" Then Target.Value = "×" Else Target.Value = "○" End If Cells(Target.Row, 2).Select End Sub ---------------------------------------------------------------------
こんなのいかがでしょうか？ -------------------------------------------------------------------------- Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Target.Column = 1 Then If Target.Value = "○" Then Target.Value = "×" Else Target.Value = "○" End If Cancel = True End If End Sub --------------------------------------------------------------------------
すでに他の方がかかれているように， Like "[A-Z]" で短くできます． 今後の他のコード作成のために・・・ and や or は使えるのでしょうか？ Ifの条件式で，複数の条件を「or」 でつなぐと，どれか一つが一致すればその処理を行います （「and」の場合は，全てが一致した場合のみにその処理を行います．） 例の場合は，下記のように書けます． If Range("A1").Value = "A" or Range("A1").Value = "B" or Range("A1").Value = "C" Then その他，下のページを見てみるといいかも http://officetanaka.net/excel/vba/tips/tips35.htm
マクロで良ければこんな感じです。 下記のマクロは、Sheet1上の全数式をSheet2の同位置に設定します。 Sub sample() Dim r As Range For Each r In Sheets("Sheet1").Cells.SpecialCells(xlCellTypeFormulas, 23) Sheets("Sheet2").Range(r.Address).Formula = r.Formula Next End Sub
別案 =COUNT(FIND(1,A1:A100)) [Ctrl]+[Shift]＋[Enter]配列数式、{}で囲まれる。
http://detail.chiebukuro.yahoo.co.jp/qa/question … のようにPDFに変換すれば一気に印刷が可能だと思われます。 http://detail.chiebukuro.yahoo.co.jp/qa/question …
色をつける事が目的ではなく、該当の担当を表示したいのだと思いますので。 作業列を使いますが、邪魔にならない列に変更してやってみて下さい。 図ではD列～F列が作業列で、G列に担当の番号を表示します。 D2の式 =IF(B2="","",$A2) これを右へE2と、下へコピー F2 =IF(D2="","",IF(COUNTIF(E:E,D2),ROW(A1),"")) 下へコピー G1の式 =IF(COUNT($F$2:$F$100)<ROW(A1),"",INDEX(A$2:A$100,SMALL($F$2:$F$100,ROW(A1)))) 下へコピー データ数を100件に想定しています。データ数に応じて $F$2:$F$100　の部分の範囲を変更して下さい。
もう一案 F3セルに =SUMIFS($D$3:$D$18,$B$3:$B$18,$F1,$C$3:$C$18,F2) +SUMIFS($D$3:$D$18,$B$2:$B$17,$F1,$C$3:$C$18,F2)
こんにちは。 #2の回答者です。 改良型と言いたいのですが、あまり複雑になると、やはりダイアログにしたほうが良いようです。ここのテキストファイルウィザードと同じようなものは私も作れるのですが、マクロの意味がなくなってしまいます。また、テキストファイルウィザードそのものを利用しても作れるのですが、一定以上のスキルがあるという自負があると、なかなかお仕着せのものは使いづらいです。記録マクロを応用すれば、簡単に出来上がります。(出てきたコードに、最後にQueryTables(1).Delete だったかな、それを加えれば、完璧のはずです） テキストファイルウィザードの設定は、複数を使うことが可能ですが、その場合は、私は、BRegExp.dll/Basp21 というツール(公に認められています）を使います。 現状では、スペース区切りと他の区切り文字とは、多数は共存はできませんが、区切り文字を「、(読点）」「, (カンマ）」などの文字列とした場合も区切れるようにしました。安易ですが、スペースに変えるわけです。 また、Windowsの場合は、Chr(13) =CR を使って区切ってしまうと、Chr(10)=LFが、次の行の文字列に残ってしまうようですので、予め、削除することにしました。 Excelでは、数式などは、'=AB1' だと文字に入りませんので、それも加えました。ただ、経験値を活かしても、せいぜい、こんなものです。単純明快なコードのほうが最近は好まれるようですが……。 '// Sub OutputfmrClipboardR() 　Dim CB As Object 　Dim buf As Variant, ea As Variant 　Dim arBufs As Variant 　Dim arBuf As Variant 　Dim stc As Variant 　Dim i As Long, j As Long, k As Long 　Const CLSID As String = "1C3B4210-F441-11CE-B9EA-00AA006B1A69" 　 　Set CB = CreateObject("new:" & CLSID) 　 　'Const DELIM As String = "、" '文字を区切り文字を使う場合(下も外す） 　 　On Error GoTo ErrHandler 　Range("A1").Select 'A1 を最初とする 　With CB 　　.GetFromClipboard 　　buf = .GetText 　　If VarType(buf) = vbString Then 　　　'buf = Replace(buf, DELIM, Space(1), , , vbTextCompare) ''区切り文字を使う場合 　　　arBufs = Split(buf, Chr(13), , vbBinaryCompare) 　　　For Each stc In arBufs 　　　　If Len(stc) > 0 Then 　　　　　'全角空白を半角に 　　　　　buf = Replace(stc, Space(1), Space(1), , , vbTextCompare) 　　　　　'空白は2個以上は、1つにまとめる 　　　　　Do 　　　　　　buf = Replace(buf, Space(2), Space(1), , , vbTextCompare) 　　　　　Loop Until InStr(buf, Space(2)) = 0 　　　　　 　　　　　'Windows用　不要な改行コードを落とす 　　　　　buf = Replace(buf, Chr(10), "", , , vbBinaryCompare) 　　　　　arBuf = Split(buf, Space(1)) 　　　　　j = UBound(arBuf) 　　　　　If j > -1 Then 　　　　　　For i = 0 To j 　　　　　　　'Excelでは、セルの文頭に使えない文字がある 　　　　　　　If arBuf(i) Like "[-+=]*" Then 　　　　　　　　ea = "'" & arBuf(i) 　　　　　　　Else 　　　　　　　　ea = arBuf(i) 　　　　　　　End If 　　　　　　　'不要なバイナリコードをセルには入れない。 　　　　　　　 ActiveCell.Offset(k, i).Value = Application.Clean(Trim(ea)) 　　　　　　Next i 　　　　　End If 　　　　　k = k + 1 　　　　End If 　　　Next stc 　　End If 　End With ErrHandler: 　Set CB = Nothing 　If Err() <> 0 Then 　　MsgBox Err.Number & " :" & Err.Description 　End If End Sub '// GooUserラック様へ。 ありがとうこざいました。これで終止符を打てると思ってClipboardFormats を使おうと思いましたが、取り出すほうは、また関数が用意されていないようです。ここで、取り出すAPI関数を使おうとも考えてみましたが、ちょっと大げさ過ぎてしまいますので、やめにしました。 私は、長い間、この件は、いろんな方法を試してみて、し尽くしているつもりですから、当然、「Microsoft Forms 2.0 Object Library」の参照設定は知っているのですが、なかなか容易には使わせてもらえないような気がします。
横軸目盛表示部分の縦の長さが不足しているのではないでしょうか。 グラフ部分をクリックし、グラフエリアの下方(横軸目盛上端)を持ち上げて、 この部分(縦の長さ)を確保してみてください。
With ws1.Columns("B:B") にした為A列が省かれてしまっていました。すみません。 紛らわしくなるので、修正したものを最初から全部書きます。 Private Sub TextBox1_BeforeUpdate(ByVal Cancel As MSForms.ReturnBoolean) Dim Obj As Range Dim wA1 As String Dim wAddress As Range Dim ws1 As Worksheet, ws2 As Worksheet Dim i As Integer Set ws1 = Sheets("Sheet1") Set ws2 = Sheets("Sheet5") With ws1 Set Obj = .Columns("B:B").Find(What:=TextBox1.Value, LookIn:=xlValues, LookAt:=xlPart, MatchByte:=False) If Obj Is Nothing Then MsgBox "対象データは存在しません。", _ vbOKOnly + vbInformation, "検索" Exit Sub End If ListBox1.RowSource = "" wA1 = Obj.Address Do Set wAddress = Obj.Offset(0, -1) i = i + 1 .Range("A" & wAddress.Row & ":AS" & wAddress.Row).Copy Destination:=ws2.Range("A" & i) Set Obj = .Columns("B:B").FindNext(Obj) If Obj Is Nothing Then Exit Do Loop Until Obj.Address = wA1 ListBox1.AddItem "" ListBox1.List = ws2.Range("A1:AS" & i).Value ws2.Range("A1:AS" & i).ClearContents End With End Sub
「組んでいるのなら」どんな式かを示すべきでしょうに！ 私の案を記しておきませう。(添付図参照) １．列Ｃの各セルに示された文字列を入力 ２．式 =IF(D$1="","",TEXT(D$1,C1)) を入力したセル B1 を下方にズズーッとオート ￣￣フィル ３．セル D1 に日付形式で「2016/8/8」とか式 =TODAY() とかを入力 ４．次の[入力規則]を設定したセル D2 を必要なだけ下方にオートフィル ￣￣￣[入力値の種類]→“リスト” ￣￣￣[元の値]￣￣￣→ =$A$1:$A$7 ５．式 =VLOOKUP(D2,A$1:B$7,2,FALSE) を入力したセル E2 を下方にズズーッとオート ￣￣フィル
>上のマクロはとても軽快に動き、そのセルにとって最高の結果を表示してくれました。 たぶん、私のアドバイスは不要だとおっしゃっているのだ思いますが、満足して使われているとおっしゃるからには、私には、それ以上、何もいう資格はありません。 ただ、読者の方たちもいらっしゃいますから、もう少し、注釈を述べさせていただくと、 >他のシートに入力したら全ての関数は再計算されるのですが、 >=ConcatenateRangeText(の関数だけが再計算されず、考えたのが同じ半角の >「=」を検索して置き換えるという方法でした。 >Ctrl+Fだと置き換えられるのですが、これをマクロの記録でやるとエラーになるという事です。 「インストラクターのネタ帳」からの'ConcatenateRangeText'で参考にしたものでしょうね。 このユーザー定義関数そのものに、私は疑問を感じています。ユーザー定義関数の中に、動的な働きを求めることは可能ですが、起動するための動力が必要です。そのきっかけを持ってくるのが、Volatileメソッドですが、このユーザー定義関数は物理的な時間を伴い、スピードとして遅すぎるのではないかと、感じるわけです。 さしずめ、レーシングカーで、そこらで売られている中古車のパーツを使うようなものだと思います。バランスが悪すぎるのです。それは、一般関数の100倍から1000倍、遅いからなのです。 それで、高速で走らせるのをやめて、ユーザー定義関数をやめて、これをプロシージャの中に組み入れててしまうことなのです。Volatileは、高速性能に耐えられるもの以外は、悪い結果を導いてしまいます。 記録マクロは、VBAプログラミングとはまったく違うものです。記録マクロがどうであっても、初歩的な所から新たに学ばないと、とてもVBA自体は扱えるものではありません。 >=ConcatenateRangeText(の長い数式は11行ごとに20セル×6列ごとに31セルあります。 それを繋げ合わせて、ひとつのセルの貼り付けることの意味がどういうことになるのか、ブックがハングしないのが不思議なぐらいです。 たぶん、一気にピークにならないように、Excelのメモリの保護機能が働いているのだろうと思います。 いずれ、時が来たら、また、私のアドバイスは可能になるかもしれません。お役に立てずにすみません。
このようなことが起こらないセルをコピーして一度貼り付けて、式を入れなおしてもダメですか？
どうやら「Range("E631:E849,…,GC631:GC849").Select」が長すぎるようです。 次のようにみたらいかがでしょうか？ --------------------------------------------------------------------------- Sub 数式更新() Range( _ "E631:E849,K631:K849,Q631:Q849,W631:W849,AC631:AC849,AI631:AI849,AO631:AO849,AU631:AU849,BA631:BA849,BG631:BG849,BM631:BM849,BS631:BS849,BY631:BY849,CE631:CE849" _ ).Select Selection.Replace What:="=", Replacement:="=", LookAt:=xlPart, _ SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, _ ReplaceFormat:=False Range( _ "CK631:CK849,CQ631:CQ849,CW631:CW849,DC631:DC849,DI631:DI849,DO631:DO849,DU631:DU849,EA631:EA849,EG631:EG849,EM631:EM849,ES631:ES849,EY631:EY849,FE631:FE849,FK631:FK849,FQ631:FQ849,FW631:FW849,GC631:GC849" _ ).Select Selection.Replace What:="=", Replacement:="=", LookAt:=xlPart, _ SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, _ ReplaceFormat:=False End Sub --------------------------------------------------------------------------- ちなみに「Range("GC849").Activate」は完全に不要です。
参考にしたコードは、マクロができる人が書いたものとは思えません。 間違いがいくつかあります。 そして回答者側もたいして変わらないようです。 >「A1」・「B1」に数字を上書き入力し「A1」の累計を「A2」に「B1」の累計を「B2」に表示したいのです だけで十分です。 その掲示板には、入力間違いの修正の話が出ていますが、例えば、2と入力して間違いなら、 マイナス符号をつけて、-2　と入力して、削除すればよいです。 If Intersect(Target, Range("A1:B1")) Is Nothing Then Exit Sub ここを書き換えれば、一行目のセルは全部同様に使えます。 'シートモジュール Private Sub Worksheet_Change(ByVal Target As Range) If Target.Count > 1 Then Exit Sub If Target.Value = "" Then Exit Sub If Intersect(Target, Range("A1:B1")) Is Nothing Then Exit Sub 　Application.EnableEvents = False 　Target.Offset(1).Value = Target.Value + Target.Offset(1).Value 　Application.EnableEvents = True End Sub '------- PS マクロを使わなくてもできます。 ファイル　 オプション　数式-反復計算を行う -最大反復回数　「1」 例えば、 C2 のセルに、=C1 + C2 とすれば、同じようにできます。
私は、JavaScript の知識が乏しいので、最初に、VBScriptを作ってから、やってみました。単に記法の問題だけなのでした。 ウィルスもどきですから、私の環境では許されても、他の方の環境では許されないかもしれません。絶対的に必要な部分だけを書いておきます。これが、できない場合は、PC環境のせいであり、セキュリティ設定の違いです。 // JavaScript Document var xlapp = new ActiveXObject("Excel.Application"); xlapp.visible =true; var newbk = xlapp.workbooks.add(); newbk.vbproject.references.addfromguid("{0002E157-0000-0000-C000-000000000046}",5,3); var e =newbk.vbproject.vbcomponents("ThisWorkbook").codemodule; e.insertlines(1, "Private Sub Workbook_BeforeClose(Cancel As Boolean)"); e.insertlines(2, "End sub"); // >今回若い技術者に教えられてJScriptを始めてみましたが、VBScriptも必要かもしれませんね JScript とは本来使用目的が違うだろうけれども、覚えればなんとかなるのかもしれません。ドイツのエディタの会社では、VBScript 系は手放し-フリーにしてしまいました。 今、Excel 2013には、オフライン・ヘルプがないとか、VBAには、暗い影のようなものを落とし始めましたが、そこで、最近は、私も、JavaScript はなんとかしようとは思っているのですが……。PowerShell が進み始めています。 >今はエクスポートしたVBAを、インポートする方法を模索しています 別のカテで出ているのは確認しました。たぶん、できるだろうと思いますが、あえて、JavaScript で書くというのも気が進まなかったりします。VBScript のほうがはるかに違和感が少ないです。
> 横軸に期間、縦軸に使用率でグラフを書きたいのですが、… 横軸の期間として、期間=終了-開始　の列を設ければよいと思います。 > 開始 · 終了時間で棒グラフのようにし、… イメージがわきませんが、 年月日時間はシリアル値を使えば数値扱いすることができます。 例えば、2016/7/5 8:57=42,556.372917 このシリアル値をグラフ軸に割り当てます。
=IF(SUMPRODUCT((A1:A4="×")*1)*SUMPRODUCT((B1:B4="×")*1),"NG","OK") または =IF(SUM((A1:A4="×")*1)*SUM((B1:B4="×")*1),"NG","OK") 【お断り】後者は配列数式として入力のこと
丸投げになってしまっているので回答がつかないのだと思います。 フォームの作成は出来ているのですか？ フォームを使ったVBAはどの程度経験があるのでしょうか。 AS列とは随分項目数が多いですが、それを全部リストボックスに表示したいのですか。 出来ない部分を具体的に質問した方がいいと思います。
VBAでなくとも 置換ではだめなのでしょうか？
ノートパソコンなら他のキーと一緒に押すようになっている可能性もあります。 Fnキーとか。
》 オプション・メニューそのものの有無が分からない Windows版と同様に、[ファイル]タブの配下にありませんか？
Sheet2の方は9月が先頭で月の位置が固定。 入力のSheet1はB3が9になったり10になったりする。 これでは数式では不可能なのです。 逆ならOKです。つまり入力の方の位置が固定で、それを適宜のセルに表示は数式で出来ます。 色々やってみるのはいい事ですが、数式には限度があることをお伝えして、当方はこれで失礼します。
》 セルＡ１の”５月”を…のどちらにする方がよいか この一文だけから、「もっとこうした方が好いよ」的なアドバイスを求めておられると判断しました。 「５月」の箇処はドッチでも構わないけど、シートを「４月」「５月」と分けずに添付図のように１本にすることをお奨めします。行数は１００万行以上もあるのだから、 １列目を適用月として４、５、６、…を入力するのです。 嫌よ、イヤ、イヤなら仕方ないけど、Excel に慣れて来るとその利点が理解できるようになること請合います。
[No.1お礼]へのコメント、 私が書いた【お断り】の意味が分かってますか？ ハイレツスーシキって聞いたことある？何のこと？ 私が提示した式を入力したら、直ぐに Enterキーを叩くのでなく、 CtrlキーとShiftキーを左指で抑えたままで、Enterキーを「エイヤッ！」と叩き付けてご覧！ 数式バーを眺めると提示式の両端が括弧{}で囲まれて次のように表示されます。 {=IFERROR(INDEX(Sheet1!・・・・・,""),ROW(A1))),"")}
「=IF(MOD(A1,A2)=0,1,MOD(A1,A2)」でよいと思いますが 余り「1」と、余り「無」が、同じになってしまいますが良いのでしょうか？
こんにちは！ 「シートB」は「Sheet2」とします。 OFFSET関数だと =OFFSET(Sheet2!B$5,(ROW(A1)-1)*9,,1) 別の方法としては =INDEX(Sheet2!B:B,ROW(A1)*9-4) でも大丈夫だと思います。m(_ _)m
「大至急」とのことなので、もう手遅れかと思いますが、･･･ Sheet2の任意のセルに次の数式を入力します。 1番目の任意のセル　=IF(1<=Sheet1!$B$1,Sheet1!$A$1,"") 2番目の任意のセル　=IF(2<=Sheet1!$B$1,Sheet1!$A$1,"") 3番目の任意のセル　=IF(3<=Sheet1!$B$1,Sheet1!$A$1,"") 　・ 　・ 20番目の任意のセル　=IF(20<=Sheet1!$B$1,Sheet1!$A$1,"") 以降、想定している最大の個数まで設定します。 もし、任意のセルというのが、A1から下に連続しているようであれば、次の式をA1に入力して、下にオートフィルでも大丈夫です。 =IF(ROW()<=Sheet1!$B$1,Sheet1!$A$1,"")
こんにちは。#7の続きです。 正直なところ、勉強させていただいた、という気持ちです。 ここ何年ぶりかの、久々に骨のある質問でした。（^^; コードをみましたが、面白いことを考えますね。発想がユニークです。残念ながらうまくいかないのではないでしょうか。お書きになったのはユーザー定義関数とは呼ばないのです。それを、私は、「関数プロシージャ」と呼んでいます。 ユーザー定義関数で使おうとすると、途中で終わってしまうはずです。 関数プロシージャは、動的に用いないとうまく働かないのです。 静的に用いようとすると、何度やっても、エラーが出るはずです。 単独で、ユーザー定義関数(静的）にするなら、例えば、このようになります。 '// Function Find_Cells(数式 As Variant, 範囲 As Range, Optional 値 As Variant) 　Dim myFormula As Variant: myFormula = 数式 　Dim myRng As Range: Set myRng = 範囲 　Dim myVal As Variant: myVal = 値 　Dim Rng As Range 　Dim c As Range, cnt As Long 　Set Rng = myRng.SpecialCells(xlCellTypeFormulas) 　For Each c In Rng 　 If InStr(1, c.Formula, myFormula, vbTextCompare) > 0 Then 　　　If Not IsMissing(myVal) Then 　　　　 If c.Value = myVal Then 　　　　　 cnt = cnt + 1 　　　　 End If 　　　Else 　　　　　cnt = cnt + 1 　　　End If 　 End If 　Next 　Find_Cells = cnt 　End Function 　 ''------- 質問のFunctionプロシージャとして動くようにしてみました。 '// Function Find_Range(検索式 As String, 検索範囲 As Range) As Range 　Dim FoundCell As Range, FirstCell As String, Target As Range 　 　Set FoundCell = 検索範囲.Find(What:="*" & 検索式 & "*", LookIn:=xlFormulas, LookAt:=xlWhole, MatchCase:=False) 　If FoundCell Is Nothing Then Exit Function 　If Not FoundCell Is Nothing Then 　　FirstCell = FoundCell.Address 　　Set Target = FoundCell 　 End If 　　Do 　　　Set FoundCell = 検索範囲.FindNext(FoundCell) 　　　If FoundCell.Address = FirstCell Then Exit Do 　　　Set Target = Application.Union(Target, FoundCell) 　　Loop Until FoundCell Is Nothing 　 　Set Find_Range = Target End Function 'What:="*" & 検索式 & "*", ここはなんとなくです。あまり深い意味はありません。 '---- '実行ファイル '以下で、CountIf 関数は、使えないのは、引数が、パラメータ配列で取れませんので、せっかく、Find_Range関数が持ってきた範囲は、一括して検索ということができないのです。その都度、検索しカウントしていくか、以下のようにまた分解するかどちらかだと思います。 Sub Test_findNcount() Dim Rng As Range Dim c As Variant Dim cnt As Long 　Set Rng = Find_Range("=countif", Cells) 　For Each c In Rng.Cells 　　If Not IsError(c) Then 　　　If c.Value = 1 Then 　　　　cnt = cnt + 1 　　　End If 　　End If 　Next 　MsgBox cnt End Sub '// ここまで、展開できましたら、その後、関数で、これを解決できる人はいるかもしれません。たぶん、配列などの処理になるのではないかと思います。私は、ここまでマクロで作ってしまいますので、そのようなことは考えませんけれども。
疲れたので、「質問１）」のみに反応します。 I60: =IFERROR(VLOOKUP(H60,K$59:L$63,2,FALSE)&IF(H60>3,MID(A60,2,FIND("⇔",A60)-2),MID(A60,FIND("⇔",A60)+1,LEN(A60)-FIND("⇔",A60)-1)),"") 【お願ひ】 回答者を疲れさせないでぇ～
》 ちなみに画像のみかんの行は手入力しました だから、添付図に「矛盾があってもガチャガチャ言うな！」と防衛線を張っておられるのでせうか？ B11: =IFERROR(INDEX($B$2:$P$2,MATCH(B$10,OFFSET($A$1,MATCH($A11,$A$1:$A$7,0)-1,1,,15),0)),"") で如何でせう。
ふりがなが自動記録されることで、何か不都合があるんですか？ 操作の上で問題があるなら、本来やりたいことを書かれた方が回答がつきやすいと思いますよ。
{=SUM(((A1:A20)="○")+(A1:A20="○"))}
こんにちは こちらでは対処できませんか？ https://oshiete.goo.ne.jp/qa/6527450.html
WindFallerさんがおっしゃるように、元データのシートから検討しましょう。 ＞Sheet1は、社内の売り上げ表（月単位) ですので、月ごとのファイルがあったりしませんか？ 横方向に、製品列と会社の列が並んでたら移動するのも大変でしょう。 データは、日付と一緒に縦方向に入力するのが鉄則です。 一例で言えば 日付　販売先　担当者　製品名　単価　数量　合計金額・・・ と一行目に準備してひたすら縦方向に入力します。 別シートに 　年　　月　販売先 2016　8　　A社 日付　担当者　製品名　単価　数量　合計金額 と準備して、年と月、会社名を指定したらご希望の集計表委にあるような 仕組みを考えます。
RR～LRが50cmだとすると、 左右の左足を基準にすると重心位置 X＝（(24+12)*40/(24+12+20+9)=22.2cm 前後の後足を基準にすると重心位置Ｙ=((24+20)*50)/(24+12+20+9)=33.8cm
缶詰の表示ならば構いませんが、そのままでは平成と成りやすいので 2010、11、1と明記すべきでしょう。
素直に質問に回答すると、『マクロで出来る』です。 しかし、質問を読む限りマクロでやる必要はなく、並べ替えとフィルタでできるように思います。 ファイル容量削減の観点からも、ダブりデータを増やすより好ましいです。（HDDの容量は無限ではありません） <やり方> １．データがある部分を選択して(ひとつのセルだけでよいです)、データ→フィルタ　とします。 ２．最終行に集計とありますが、最上行のほうが都合がよいので1行目に行を挿入します。 ３．挿入した1行目の『金額』の上のセル（C1セル）に『=SUBTOTAL(9,C3:C最終行)』と入力します。最終行は数値です。 ４．データがある部分を選択して(ひとつのセルだけでよいです)、データ→並べ替え ５．ウィンドウが表示されるので、『最優先されるキー』に必要な項目を選択します。 質問にあるやりたいことの操作 ・シート2にデータの日付順最終行に集計 →上記の手順４～５にある並べ替えを行います。『最優先されるキー』を日付にします。集計は手順3で追加した式に表示されます。 ・シート3にデータの店舗名コード順最終行に集計 →上記の手順４～５にある並べ替えを行います。『最優先されるキー』を店舗名コードにします。集計は手順3で追加した式に表示されます。 ・シート4にデータの店舗ごとの集計 →手順１で準備したフィルタ機能を使います。見出し行のセルにでている▼印をクリックして、表示したい店舗名を選択します。 ・シート5以降は店舗別にシートごとに分けます。 →やりたいことは上と同じなので、やる必要性がないと思います。
グラフが最終目的ですね。 ［空白セルのプロット］欄で［補間してプロットする］オプションをオンに。 http://www.becoolusers.com/excel/chart-connect-d … の方法でできます。
最近、同じようなマクロの質問がありましたが、全体的には無理があるマクロだと思います。別の質問は、完了せずに終わりました。 Worksheets(i).Range("A1").Value　にちゃんとシート名があると確約できないと思います。それにシート名として正しいかも分からないです。 一応、回答のひとつとして載せて起きます。 同名シートがあれば、枝番がつきます。 '// Sub ChangeSheetName() 　Dim i As Long, j As Variant 　Dim shName As Variant 　On Error GoTo ErrHandler 　For i = 1 To Worksheets.Count 　　shName = Worksheets(i).Range("A1").Value 　　If shName <> "" Then 　　　Worksheets(i).Name = shName 　　End If 　　j = "" 　Next i 　Exit Sub ErrHandler: 　If Err.Number = 1004 Then 　　If InStrRev(shName, "_") > 0 Then 　　　shName = Mid$(shName, 1, InStrRev(shName, "_") - 1) 　　End If 　　j = Val(j) + 1 　　shName = shName & "_" & j 　　Resume 　Else 　　MsgBox Err.Number & ": " & Err.Description 　End If End Sub
＞数値を色で表したのですが、どうすれば良いでしょうか？ これはグラフの元データのセルということですか。 ならば、「条件付き書式」で「カラースケール」を設定しましょう。 ＞れとグラフの基準の５の部分に線を入れたいです。 直線のオブジェクトを追加すればよい。 「挿入」から「図形」を選び、そこから「直線」を選択して直線を引こう。
すでに、ご満足のいく回答を得られているようなので、今更なのですが… ユーザ設定の並べ替えでは、「最優先されるキー」「次に優先されるキー」･･･のように最大64列のキーが指定可能です（Excel2010の場合）。 最優先されるキーに「1日」、次に優先されるキー「2日」、･･･「31日」まで指定すれば、お望みの順番に並べ替えることができます。 一旦設定したものをマクロ記録すれば、いつでも再利用可能です。
No.5・6です。 投稿がダブってしまいました。 No.6は無視してください。m(_ _)m
こんにちは 符号だけ取るとかもあるかもしれませんが、結局のところ、正、0、負の場合分けをしなければならなさそうなので、素直に場合分けをしてしまえば良いのではないでしょうか？ A1セルに対象の数値があるとして 　=IF(A1>0,A1+10,IF(A1=0,0, A1-10)) などではいかがでしょうか？
ご自分で「特定の日付」(例えば 2014/01/01、2016/01/01、2018/01/01)を設定したときに、幾らなのかを示してください。 つまり、その正解値で我々は検証して、式を提示することになります。お分かりかな？
むやみに複雑な式を書くのは好みではないのですが、こんな感じでしょうか。 =IF(H60=3,"どちらでもない",IF(OR(H60=2,H60=4),"やや","")&IF(H60>3,MID(LEFT(A60,FIND("⇔",A60)-1),2,999),MID(A60,FIND("⇔",A60)+1,LEN(A60)-FIND("⇔",A60)-1))) 表の作り方を工夫することによって、式を簡単にすることができます。合わせて検討されることをお勧めします。例えば… ①「（天才⇔努力家）」の先頭と末尾のカッコを書式設定で表示する ➁「天才」と「努力家」を別のセルにする ･･･などです。
=ROW(1:3) は正確には ={1;2;3} となり 縦に1,2,3と並びます。 =COLUMN(A:C) なら ={1,2,3} で横に並びます。 この質問においてはどちらでもOKですね。 {1;2;3}や{1,2,3}は配列定数といいます。 数学における行列の勉強をしているとわかりやすいと思います ちなみに配列数式として確定するときに付く{ }は 最初の=の後ろではなく前、つまり {=A1:C5} といった具合です(例としては、いまいちですが) 参考まで
もうちょっと詳細な情報が必要な気がします。 Sub テスト() Dim vRng As Range Dim i As Long For i = 1 To 30 Step 5 Set vRng = Range("A" & i) '画像ファイルを挿入 ActiveSheet.Shapes.AddPicture Filename:="<画像へのフルパス>", LinkToFile:=msoFalse, _ SaveWithDocument:=msoTrue, Left:=vRng.Left, Top:=vRng.Top, _ Width:=vRng.Width, Height:=vRng.Height Next i End Sub A列の1、6，11、16，21，26行目のセルに、セルの幅と高さにあわせた<画像へのフルパス>の画像が挿入されるプロシージャです。 不足する点、変更する点を補記ください。
A列とB列のセルの「ロック」を外して「シートの保護」をすると意図する動作になるのではないだろうか。 A列とB列を選択して「セルの書式設定」から「保護」タブを選ぶと「ロック」にチェックマークが入っているので、これを外す。 次にリボンの「校閲」から「シートの保護」を選択し、開いたウインドウ内で「ロックされたセル範囲の選択」のチェックマークを外す。 「ロックされていないセル範囲の選択」のチェックマークは付けたままにする。 これでA列とB列のセルしか選択できなくなる。 他の列のセルも選択したい場合は、「シート保護の解除」をしたあと、他にも選択したいセルで「ロック」のチェックマークを外したのちに もう一度「シートの保護」をすればよい。
＞Worksheet のChangeイベントに書けばいいんですよね。 この使い方ですと、シートの値が書き換えられるたびに、マクロが起動してしまいます。 https://oshiete.goo.ne.jp/qa/9372486.html データー量が多かったり、コンピュータの性能が足りなかった場合には、データを変更するたびに待ち時間が出来てしまいます。 そこで、「標準モジュール」を使う方法を提案しました。
No.9の回答者です。 質問者さんの文がよくわかりません。 No.2への追加コメント　 >　どうやら18000f以降が一致しなくなります。 >　18000f -> 00:10:00.20 (正)00:10:00.18 No.2への補足コメント >　18000fをタイムコード表記すると00:10:00:00となります。 No.9の回答画面の中の表示 　　18000に対応するもの　00:10:00.18f No.9の回答では、18000は、DFの数(個数《DFの総数》）です。DFの番号がどういうものか分かりませんが、番号を意識したものではないです。 【00分,10分,20分,30分,40分,50分の時にはフレームの00,01はカウントしますが、他の分表示の時は、00fと01fを無くしてしまう。という仕組みです】この意味をどうとるのかが、私に分かってないのです。　例えば、999999876が20分目justのとき、その次を【999999879】と名付けて、二個数字を飛ばすのでしょうか。そのようにするのであれば、それをベースに計算しますが、そのような計算をする(＝経過時間から固有DFの番号を計算する)と、番号は飛び飛びになります。また、番号は連番でとり、撮影開始から00分,10分,20分,30分,40分,50分目に二フレーム分取り込まない方式にするというのは、実際上あり得ないと思います。 DFの総数から《1秒未満を切り捨てた総時間と秒に満たないフレームの数を同時並列表記する》として考えると、次のサイトを参考にすることが出来ます。 http://keisan.casio.jp/exec/system/13814530574678 それで作ったのが、No.9の式です。 18000f 　とか　218015の場合には、どのようにでる式にして欲しいのでしょうか。
セル範囲を(とびとびでもよい)選択 数式を入力し、[Ctrl]押しつつ[Enter] で選択したセルに、数式が入力できます。 (一般的には(-_-;)
こんばんは ＞因みに、内容に訂正がありますので質問し直します。 ＞引き続きよろしくお願いいたします。 こちらは、 ・新しい質問にリンクを張る ・「回答済み」にして受付を停止する をしておいてください。 そうしないと、回答が分散してしまいます。
シートBの条件を添付の図のようにしてみて下さい。 AdvancedFilterの条件は、同一行内はAND。行毎にORで判断されます。 添付のようにすると、次の条件でフィルターされます。 ID=1かつ来店日2015/7/1~同8/31、もしくは、 ID=2かつ来店日2015/11/1~同12/31、もしくは、 ID=3かつ来店日2015/4/1~同5/31
内容は社外秘と言うことなので、詳細が判らないままですが。 先ずはデータベースを作る。 日付、商品、注文数、注文に係る要素を数値化したもの。 次に、日付関数を使って、year、month、week、day（需要予測に必要なもの）を付け加える。 ピポットテーブルを使って集計する。 グラフ化して、傾向を見る。 グラフを右クリックで予測（trend）を推計する。 未来を予測するのは、関数をどうするのか？による。 例えば、弁当の売上が曜日によるのであれば、week。月によるのであればmonth。 factorを如何に数値化するかに依る。 気温がfactorであれば、気温を気象庁のデータベースからコピーする。 １２時の雨量であれば、それを豪雨１、雨２、小雨2、曇3、晴4と評価する。 君は知らないだろうが、コンビニのレジでは客の性別、年代ボタンを押さないとレジが開かない。知らないうちにデータベース化されている。 可愛いアルバイトの女の子から、年齢ボタンを歳上に押されたとすれば、見込みが無いと言うこと。主観的評価なのだから諦めて。(笑)
ママチャリです。 お礼に書かれている確認の件ですが、前半部分はsraphさんの理解で正しいです。 後半部分については、ひとつのファイルに対して複数の参照をしているのであれば、修正する必要はないです。修正が必要なのは、複数のファイルに対してリンクを張っている場合だけです。「データ」タグの「リンクの編集」で複数のリンク先が表示される場合は、修正が必要な可能性があります。
#1です。間違えました。 E1＝SUMPRODUCT(COUNTIF(C:C,C1)) では解が出ません。すみません。
同じ話を繰り返してもしょうがないのですが、マクロはExcelとは関連性があっても、Excelのアプリの延長上にはないと思ったほうがよいです。別のアプリなのです。知らないことは恥ではありませんが、本来は、VBAは知らないのだったら、使うべきではないと思います。 #2さんがVBAにはヘルプがあるというようなことをおっしゃっていましたが、今のところ、Office 2013 以降は、VBAは、オンラインヘルプだけで、ファイルとしてのヘルプはあることはあっても、英語しか存在しません。たぶん、ここら辺で、Microsoft 社は、こうした差別的な対応が深まっていくだろうという予想はしています。 そう遠からず、ユーザーの手からは、VBAと取り上げられるような気がしてなりません。また、知っている人と知らない人の二極化が進んでいくわけです。それも、程度の低い二極化です。なぜなら、Microsoft 側は、VBAの情報をどんどん出し渋っているように感じます。 初心者でも、VBAを知らなくても、掲示板で必ず回答を貰える可能性をひとつ提案します。それは、フローチャートが完璧なほど作られているものです。まともなVBAプログラマーなら、どんな人でも、それを「ノー」とは断れないです。 しかし、私は、今のVBAの状況は、終末感を感じています。 以下は、Match関数で、3つの数字を同時に検索して、3つともあれば、その合計値が出せますから、それを利用して、その行の端に「◯」をつけます。 せいぜい、検索数字は、5～6個までは試していますが、それ以上は、予測がつきません。 たぶん、Excelの下位バージョンによっては、大量の場合は、不都合があるかと思います。一応、Excel 2010 を標準とさせていただきます。(こちらは、Excel 2013です。 >行としては、10万行を超えます。 10万行にも耐えられるはずですが、こちらは、12,000行程度でしか調べていません。 こんな単純なものでも、間違いはあるかもしれませんが、ひとつのテクニックだと思ってくれればよいと思います。一気に削除する部分に工夫があります。 検索データは、Sheet2 のA1 から使いました。 '// ' Dim sh1 As Worksheet Dim sh2 As Worksheet Sub CheckNubers() Set sh1 = Worksheets("Sheet1") Set sh2 = Worksheets("Sheet2") 　Dim i As Long, j As Long, k As Long 　Dim num As Variant, nums As Variant 　Dim rng2 As Range 　Dim flg As Boolean 　Dim ar As Variant, a As Variant 　Dim buf As String, n As Variant 　Dim arbuf() As Long 　Dim LastRow As Long 　With sh2 　Set rng2 = .Range("A1").CurrentRegion 　ReDim ar(rng2.Rows.Count) 　For i = 1 To rng2.Rows.Count 　ReDim arbuf(1 To 10)　　'この10は仮の数字です。検索する数字の入れ物です。 　　 Do 　　　j = j + 1 　　 arbuf(j) = .Cells(i, j).Value 　　 Loop Until IsEmpty(.Cells(i, j)) Or .Cells(i, j).Value = 0 　　 ReDim Preserve arbuf(1 To j - 1) 　　 ar(i) = arbuf 　　 j = 0 　Next i 　End With 　With sh1 　LastRow = .Cells(Rows.Count, 1).End(xlUp).Row 　　For k = 1 To LastRow 　　　For j = 1 To UBound(ar) 　　　　　a = ar(j) 　　　　　'1列目から9列目までのそれぞれの行という意味 　　　　　nums = Application.Match(a, .Cells(k, 1).Resize(, 9), 0) 　　　　　num = Application.Sum(nums) 　　　　If IsNumeric(num) Then '　　　　For Each n In nums '　　　　　.Cells(k, n).Interior.ColorIndex = 35　'色を付ける '　　　　Next n 　　　　　 .Cells(k, 10).Value = "◯" '10行目に◯をつける 　　　　　 flg = True 　　　　　 Exit For 　　　　End If 　　　　nums = 0: num = 0 　　　Next j 　　Next k 　End With 　If flg = False Then 　　MsgBox "削除するべきものはありません。", vbExclamation 　Else 　　Call AutoFilterDelete 　End If End Sub Sub AutoFilterDelete() Dim i As Long 'Set sh1 = Worksheets("Sheet1") '単独の場合 With sh1 　.Cells(1, 1).EntireRow.Insert 　For i = 1 To 10 　　.Cells(1, i).Value = Chr(64 + i) 　Next 　 .Range("A1").CurrentRegion.Resize(, 10).AutoFilter 　 .AutoFilter.Range.AutoFilter _ 　　Field:=10, _ 　　Criteria1:="◯" 　　With .AutoFilter.Range 　　　 .Offset(1).Resize(.Rows.Count - 1).Delete 　　End With 　　.AutoFilterMode = False 　　.Cells(1, 1).EntireRow.Delete 　　.Cells(1, 1).Select 　End With End Sub
どうも何か勘違いなさっていると思います。印刷業者に渡す時に フチなし 印刷の設定なんてしても無意味です。塗り足しとトリムマークが必要です。 Adobeの Acrobatでいうなら PDF ファイルにトンボを追加する方法（Acrobat Pro DC） https://helpx.adobe.com/jp/acrobat/kb/233377.html こういうやつですね。後 Excelの[名前を付けて保存]で PDFファイルとし て保存した場合 文字情報が残ってしまうので 却下される可能性がありま す。印刷業者に確認することをお勧めします。 Excelで作るなら B4用紙サイズ内に A4サイズで作成した表を中央に配置 して塗り足しとトンボ（トリムマーク）を入れて PDF化します。 その際 ファイル形式を変えるのではなく 仮想PDFプリンタで文字情報を 埋め込んで PDF出力すべきかと思います。 Officeで作ったファイルは RGB指定なので色味が確実に変わってしまいま すからチラシの制作には向きません。入稿する時には必ず 出力見本を出し て渡した方がいいです。少しはましにしてくれるかもしれません。 Officeや そのPDF化したファイルを入稿する時は 印刷業者に確認してから にした方がいいと思います。
こんばんは エクセルの「仕様」です。 多数のセルを処理するため、画面上は問題なくても、印刷にの時にずれが出てくることがあります。 セルの幅を少しずつ広くして、余裕も持たせてみてください。 https://support.microsoft.com/ja-jp/kb/2997538
No.1です。 回答文章に一部間違いがありました。訂正致します。 >図でD列には祝日を入れておきます。 >これはD列でなくてもいいですが必須の作業です。 D列と書いてしまいましたが、図でもサンプル回答の式でもE列としています。 すみませんでした。
E43: =IF(C43="","",(C43>D43)+D43-C43) F43: =IF(C43="","",E43*24) G43: =IF(C43="","",F43*1132)
http://windows-sousa.com/2015/12/28/post-1533/ のシステムファイルチェッカが有効ではないかと思います。
[No.2]で提示した式は冗長でした。次式で十分です。 =MAX((B3:L3="○")*(B1:L1)) 【お断り】上式は配列数式として入力のこと
「教えていただきたいのは」に続く文章が日本語になっておらず、やりたいことがわかりません…
こんにちは 門外漢なので理論はまったくわかりませんが… ＞期待値は15%ですが、実際は波があります。 推定確率をきちんと求めたいのであれば、発生する値のバラツキの度合いによって変わってくるはずですね。 とはいうものの、実際の多くの場合は、平均や分散がわからない時にも推定をしたいということが起こるので、そのような場合でもなんとか求める試みがなされているようです。 理屈はわかりませんが、こんなのが多少は利用できるのかも。 https://software.ssri.co.jp/statweb2/cgi-bin/tip …
SUMIFS 関数を使います。 月締という前提で、 日付値はシリアル値を使って、書式「d 」としているとします。 別シートで表す場合は、 　A　　　　　　B　　　　C 担当者　　　日付　　　　金額 Aさん　　<=2016/7/15　　500　　←2行目から Bさん　　<=2016/7/15　　500 　　 Aさん　　>=2016/7/16　　1500 Bさん　　>=2016/7/16　　1100 データは、Sheet1 にあるとして、 C2 の数式は、 =SUMIFS(Sheet1!$C$2:$C$9,Sheet1!$B$2:$B$9,A2,Sheet1!$A$2:$A$9,B2) A列とB列の条件だけ変えるようにしてあげれば、答えは出てくるはずです。 B列はただの数字だけなら、 <=15 <=15 >=16 >=16 だけでよいです。
プルダウン…入力規則。 日付（シリアル値）から年の数値を取り出す関数…YEAR 日付（シリアル値）から月の数値を取り出す関数…MONTH 日付（シリアル値）から日の数値を取り出す関数…DAY 年・月・日のそれぞれの数値からシリアル値にする関数…DATE A1セルに入力されている2015年12月1日の次の月を求めたい場合、 ＝DATE(YEAR(A1),MONTH(A1)+1,DAY(A1)) のように、MONTH関数で得られた月の数値に１を加えればよい。 「2015年13月1日」となったら、自動的に「2016年1月1日」に置き換わる。 3日に入社して、入社した月は評価対象にしたくないなら、 入社日から評価したい月の1日までの日数①を求め、 それが入社月の1日からその翌月の1日までの日数②と比較し ①＜②ならば評価しないようにすれば良い。 IF関数の組み合わせでできるだろう。 あとは自分で試行錯誤してみよう。
数式を使って抽出したいってことでしょうか？ 画像が小さすぎて(荒くて)わからない部分もあるのですが、 どのようになれば良いかが書かれていないようです。 ↓サンプルを作ってみました。 M3セルに 0 M4セルに =SUM(L$3:L4) O4セルに =IF(MAX(M:M)<ROW(O1),"",ROW(O1)) P4セルに =IF(O4="","",INDEX(B:B,MATCH(O4-1,M:M)+1)) 上記数式 下へオートフィル
私は「特に40代・男性」ではありませんが・・・ Sheet2!B2: =IF(SUMPRODUCT((Sheet1!$A$2:$A$14=$A2)*(Sheet1!$B$2:$B$14=B$1)),"○","")
いくつか方法はあるとは思いますが、結果的には、間の行で計算するのが楽のような気がします。これは、今まである所に、上書きになります。 '標準モジュール Sub BetweenCountCells() Dim i As Long, b As Long, f As Long Dim c As Variant With ActiveSheet For i = 1 To 3 '検査する列 f = 0 '初期値 For Each c In .Range(.Cells(1, i), .Cells(Rows.Count, i).End(xlUp)) 　 If c.Value <> "" Then 　　　b = c.Row 　　　c.Value = b - f 　　　f = b 　　End If Next c Next i End With End Sub
かなり難しいシート（ブック）の様ですね。 可能性の１つとして、小さくて端に寄ってしまって見つけられないシェイプ(図形)に他ブック・シートへのハイパーリンクが設定されてしまっている場合があります。 他から貰ったシートには良くこういう事があり、VBAで一括削除した経験が多々有ります。 先ずはシェイプを探して見て下さい。 手順は以下ですが、点になってしまったシェイプは見えないかも知れません。見えたら、そこにフォーカスが当たっているので削除。 ①［編集］→［ジャンプ］コマンドを実行 ②［セル選択］ボタンをクリック ③［オブジェクト］ボタンをクリック ④［OK］ボタン
[No.1]ですが、 「上の式にくっつけるには」とあったので、アーしましたが、「AND」なんて不要で、次式で御の字でしょ？ =IF(G11="","",ROUND(G11*0.7,0))
》 …で紐付が出来ません 「紐付」って、具体的にどういうことを言うのですか？
2点、確認させてください。 月計が同じ場合、どちらの該当日の値を削除しますか？若い方の日を削除で良いのでしょうか？ 日別の値を削除した場合、当然、月計も変動すると思いますが、次のデータを処理する際は変動後の月計で判断するのでしょうか？削除を繰り返していくと月計の大小が逆転することがありますが、futsuujinさんのやりたいことに影響はないでしょうか？
=VLOOKUP(A2,E2:F932,5,FALSE) ではなく =VLOOKUP(A2,E2:F932,2,FALSE) の間違いでは？ いずれにしろVLOOKUPの引数の「範囲」が2列しかないのに「列数」が2より大きいのは誤りでしょう。
こんにちは。 #4の回答者です。 自分の発言に対して、実行可能か調べてみました。 私自身の回答のオブジェクトの名前の問題については、トラブルを発生しやす原因として、それは至急変更すべきだという意見は、変えるつもりはありません。おそらく、オブジェクトのセルのアドレス名でコンフリクトが生じている問題だと思います。 しかし、私はわたし自身の発言を、それとは別に、プロテクトという件で、数日来から、ずっと調べていました。 >ボタンのマクロ名を変えられないようにするものではありません。 ご本人がこの内容を、じっくりと、ゆっくりと理解していただくしかありません。私の発想そのものが、まったく違うからです。見慣れない用語もありますから、そこらは調べていただくことで、実際に試してみればわかる話しです。 さて、最初からですが、 今回のご質問は、「図形(AutoShape)」に対するマクロの登録も問題であって、フォーム・コントロールボタンもActiveX も安易にプロテクトというよりも、ご質問者さんが望む程度のプロテクトというか、ユーザーが、マクロ名などを簡単には変更できないようになっています。 念のためですが、予め再度確認しておかなくてはなりません。 図形などにマクロをつけたことではなく、その図形の名称をオリジナルのままにしなかったのが問題ではないかと思っています。 コンテクストメニュー(右クリックメニュー）から、マクロの登録ができないようにするというご相談では、いろいろ調べてみましたが、いくつかのリボン・カスタマイザーの海外の作者が指摘していましたが、コンテクスト・メニューでPicture　モードのものは、その変更は不可能だというそうです。 そこで、私が考えた方法は、複数のマクロ自体を、マクロの登録に入れるのではなく、ひとつのマクロで、AlternativeText や図形の名称そのものでマクロを選ばせるという方法があります。普通は、オブジェクトには、Tag やIDを持っているのですが、図形(AutoShape)には、それがありません。 AutoShape そのものが持つユーザ認識コード(AlternativeTextに書き込む） 　↓　　　　　それぞれに振り分けられる Main()----------+-- triangle　　Macro1　 　　　　　　　　|　　　　　　　　　　　　 　　　　　　　　+-- round　　　　Macro2 　　　　　　　　|　　　　　　　 　　　　　　　　+-- pentagon　　Macro3　　 　　　　　　　　|　　　　　　　　　　　　 　　　　　　　　+-- rectangle　　Macro4　　 実は、今の私には、クラスからインスタンス自体も、載せることができませんでした。(前言を訂正させていただきます。） オートシェイブの「マクロの登録(Assign Macro）」に登録するのはこれ一つです。 むろん標準モジュールです。(入れるときは、選択していれるのではなく、コピー＆ペーストで、マクロの登録に貼り付けないとできません '// Private Sub obSelectjMacro1() Dim NameObj As String Dim obj As Object 　On Error Resume Next 　NameObj = Application.Caller() 　If Err <> 0 Then Exit Sub 　On Error GoTo 0 　Set obj = ActiveSheet.Shapes(NameObj) 　Select Case obj.AlternativeText 　Case "triangle"　'オブジェクトの認識コード(AlternativeText) 　　 Call Macro1 　Case "round" 　　 Call Macro2 　Case "pentagon" 　　 Call Macro3 　Case "rectangle" 　　 Call Macro4 　Case Else 　　 sObjName = NameObj 　　 Call Macro5(sObjName) 　End Select End Sub '/本体のモジュール内に以下も置いてください。 Private Sub Macro1() 　　　　MsgBox "三角形から、マクロ1が選ばれました", vbInformation End Sub Private Sub Macro2() 　　MsgBox "丸から、マクロ2が選ばれました", vbExclamation End Sub Private Sub Macro3() 　　MsgBox "五角形から、マクロ3が選ばれました", vbCritical End Sub Private Sub Macro4() 　　MsgBox "長方形から、マクロ4が選ばれました", vbQuestion End Sub Private Sub Macro5(ByVal sObjName As String) 　　MsgBox sObjName & "は、登録されていません。", vbCritical End Sub --------------- 次に、図形側に、代替テキストの中に、それぞれ、 三角は、triangle 丸は、round 五角形　pentagon 長方形は　rectangle とします。こうしますと、オブジェクト名が変更されても、そのまま、マクロ自体は変わりません。（添付の画像） ---------------- 他の発言されている方に対して失礼かもしれませんが、 特定のシートのVBAマクロだけをプロテクトする方法はありません。 ClassモジュールのFriend キーワードや標準モジュールのPrivate キーワードがありますが、これらは、少し目的が違います。 また、プロジェクトというのは、単体のVBEの構成の最高レベルに位置します。 シートモジュール・標準モジュール、ThisWrokbookモジュール、UserFormモジュールそして、Class モジュール、参照設定を含めた機能が、プロジェクトといいます。
印刷の設定の「拡大縮小なし」を「シートを1ページに印刷」に変更してみてください。
>＜教えて頂きたいポイント＞ >受信者はロックされていないセルには入力でき、そのまま保存でき、他社にもメールに添付して送ることができ、受信者がA４判を全面コピーし、別のExcelの帳票に貼り付けた場合でもロックは解除されていない方法はないでしょうか。 受信者の作業 ・ファイルを開きます。この時点で >受信者はロックされていないセルには入力でき、そのまま保存でき、他社にもメールに添付して送ることができ はできるはずです。 しかし、 >受信者がA４判を全面コピー をするためにはブックの保護を解除する必要があります。 ブックの保護を解除したなら、シートタブ右クリック→「移動またはコピー」が選択できるようになります。 「移動またはコピー」の先は >別のExcelの帳票 を選択します。 「移動またはコピー」が完了すれば、 >ロックは解除されていない 状態、つまり各セルのロックの状態は最初のファイルと同じ状態になります（シートの保護がかかっている状態をコピーしたため）。 もしここで「移動またはコピー」先の帳票（ブックといいます）も「移動またはコピー」ができないようにするなら再度ブックを保護します。 ______________________ ついでです。 >受信者がA４判を全面コピーし、別のExcelの帳票に貼り付けた場合・・・セルの大きさはバラバラですがロックは完全に解除されており コピー＆ペーストのしかたに誤りがあると思います。 全面コピーのための範囲選択の方法は「全セル選択ボタン」で選択もしくはどこかのセルを選択した状態でCtrrl+Aなどで選択していないのでは？ ドラッグによる範囲選択や「A1を選択してからshiftキーを押しながら最終セルを選択」というような方法で選択してからコピーした場合、その後の貼り付け作業では「セルの高さ」と「セルの幅」のどちらか一方しか反映させることができません。こうした範囲選択の場合、貼り付けるときにはまず「形式を選択して貼り付け」で「セルの幅」を選択して貼り付け、もう一度同じ場所に対して通常の貼り付け作業をしなくてはなりません。 ロックについては以前の回答のようにシートを丸ごとコピーする作業をしないとコピーができません。
入力規則 - 入力値の値:リスト による入力の選択、および、無効なデータ入力時の「停止」による入力の制限。 が書かれたものなら一般機能なので、「Excel2013」のように検索かければよいと思います。 http://7net.omni7.jp/search/?keyword=Excel2013&s … >ボタンで「プルダウンメニュー」を作成し という点が、VBAを使用するって意味ならプログラミング関連になります http://7net.omni7.jp/detail/1106344444?gclid=Cjw …
Dim sh As Worksheet For Each sh in ThisWorkbook.Worksheets 　　If sh.Cells(1,1).value = True Then 　　　　sh.PrintOut 　　End If Next とか？
例えば、｢エクセルで複数の表の見出しを編集したいのですが量が多く困っています。何かいい方法はありますか？｣と問われても、回答は難しいです。どんな状態にあるものの、どの部分を、どう編集したい、対象はこのように存在しています。とか、何かが分からないと、イイ方法があるか、ないから一つ一つ手動でやるのが一番ですとか、回答出来ません。 編集でも入力や消去でも、対象毎に個別にやることを変えるのであれば、一つ一つ手動でやるのが一番です。
No.3 の補足です。 ユーザーフォームについて、作り方、表示方法などは、ここでは書ききれないので次のサイトに細かく説明されているようなので紹介しておきます。 http://excel-ubara.com/excelvba3/ ユーザーフォームを使えば、ボタンの配置や文字などもかなり自由に出来ますが、その分どうしてもやらなければいけないことが増えてしまいます。ですが背景に絵とかも設定できるので凝ったものが作れます。
表内で計算をするのではなく、単純に見た目の表を作成するのであればWordの方がいいです。
連続データならマウスポインターが＋に変わったらダブルクリックで指定範囲が一気に最後まで広がります。 連続データでない場合は、セル範囲の先頭をアクティブセルにしてから、名前ボックスに貼り付けしたいセルの最後のセル番号を入れ、shiftキーを押しながらEnterキーを押します。
>win7プロ（32bit）で使用。 怪しいのが　32bit・・　ＯＳだと　64が普通かと、 で、アドインソフトが　64bit対応のみだと・・・・無視される可能性があるかと。 それと、エクセルの上段メニューのアドインを　開かれました？？ そこも無反応だと、あと、エクセルの再インストくらいしかないかも
B4には何が入っているのでしょう。 ・1 ・1日 ・B3=2016/9/1として、B4=B3、B5=B4+1・・・・ などいろいろ考えられますし、それによって数式が変わります。 「1」しか入力されていないとすると、30日31日の判定がやや面倒です。 わたしなら3番目を採ります。 3番目だとして 表全体を選択して「条件付き書式」のダイアログを出し、「数式を利用して…」を選択して =month($B4)<>month($B$4)　とし、書式をグレーの網掛けにします。 「祝日」という範囲名の列をどこかに作り、祝日扱いにする日付を入力しておきます。 追加の条件で「数式を利用して…」を選択して =or(weekday($B4)=1,weekday($B4)=7,countif(祝日,$B4)) とし、書式を「赤の網掛け」とします 追加の条件で同様に「数式を利用して…」を選択して =（$B4=Today()）として書式を「黄色網掛け」とします。
=SUMIF(N$1:N$10,P1,J$1:J$10)
何が何だかよく分かりません。説明が全く不足しているように思います。 どこが入力したデータで どこに数式が入っているのかがそもそも分からないの ですが 数式が入っているなら それも提示された方がいいと思います。 > どのような関数を使えばよろしいでしょうか 手段を関数に限定することには何か意味がありますか？
>マクロから勉強しなおさなきゃいけないようです、 ここら周辺は勉強しても、ブラックボックス化して誰も分からないと思います。 本来なら、諸条件(Excelのバージョン）やら、もう少し聞かなくてはならないような気がしますが、小出しにあれこれ聞くよりも、サンプルマクロをみていただいたほうが早いような気がします。 私が、毎月、印刷しているマクロは、このようなスタイルです。 でも、通常、下のコードでわかるように、Preview:=True にして、どんなふうに印刷されるかプレビューを見るというのがお約束なのです。だから、仮にマクロでも、その時、コメントが下段に出れば、気がつきます。 2番目のマクロは、「拡大・縮小」を使いますので、マクロを実行すると、今までの内容がリセットして新たに設定されています。確実に思い通りになったら、直接、印刷に行けばよいと思います。 '// 'ヘッダーを左隅に太字で出すというものです。 Sub ボタン1_Click() '印刷 With ActiveSheet 　If .Name Like "Sheet*" Then 　.PageSetup.LeftHeader = "" 　.PageSetup.LeftHeader = "&""-,太字""&12 " & Format(.Range("A1").Value, "yyyy年m月") 　.PrintOut , Preview:=True 　End If End With End Sub '名前登録で、PrintArea1 と名前をつけた所を印刷するという仕組みです。 Sub　ボタン2_Click() With ActiveSheet 　　.PageSetup.PrintArea = "" 　　.PageSetup.PrintArea = ThisWorkbook.Names("PrintArea1").RefersToRange.Address 　　.PageSetup.Zoom = 100 　　.PrintPreview End With End Sub
じゃあ、範囲名として、祝日シートのA列を「祝日」と名前を付けて登録すればよい。 そのままの条件式で反映されますよ。 祝日シートのA列全体を選択（A、B、C…と並んでいる場所のAをクリックしてA列全体を選択）して、左上の名前ボックスに「祝日」と入力して確定するだけです。 ・・・ 「名前ボックス」が何なのか分かっていないような気もするので…
#4の回答者です。 「シート内に入力済みのすべての数式を、一度に絶対参照に転換」する理由 #3さんの質問を質問者に代わって私が回答するというのは、まったくもってでしゃばった行為ですし、質問者さんの回答とは同じだと思っているわけではないのですが、なぜ、こんなマクロのテクニックが残っているかお答えさせていただきたく思いました。 端的にいうと、この絶対参照に変更というのは、Lotus123->Excel の人には、あまり馴染みがないでしょうけれども、昔からのPCユーザーの最初の表計算は、Excelの前進ともいえる、同じ作者のMS-Multiplanで、各社各様にOEM販売され、富士通のワープロにさえバンドルされていました。その仕様が、R1C1方式で、Multiplan は、日本では、NEC 98モデルの普及とともに使い続けられ、その製品は1992年頃を、最後に約10年で終えました。 だから、一部の人には、R1C1方式は馴染みが深かったわけです。それで、ずっとR1C1方式で使い続ける人が残っていたわけです。 A1方式には相対参照と絶対参照の差はあまり大きく変化しないのですが、このR1C1方式は、相対参照と絶対参照では、まったく考え方が違うというか、相対参照には、セル位置の情報がないので、どこを参照しているのかまったく分からないわけです。そのために、絶対参照式に変える必要性を感じたわけです。今となっては、そんな要求する人は皆無だとは思いますが……。 さて、問題のマクロは、私の言葉どおりなら文句はないのでしょうから、このコンバートは、シートが、A1スタイル上でないと、今のところ、私の所では変換しません。
元がCSVファイルなら、それをExcelで読み込むのは危険だと思います。 なぜなら、Excelに取り込んでそれを保存した時点で、本来のCSVのフォーマットを崩す可能性があるから。 フォーマットがどうなってもいいなら関係ありませんが。 ダブルクォーテーションが消えるとか。 あと、CSVファイルを直接ダブルクリックしてExcelを開くことにより、中身が壊れる可能性もありますね。 そういうのを理解していればExcelでも事足りるでしょう。 Accessが使えるなら、こんな方法論も取れると思います。 CSVファイルのフォーマットが変わらないなら、Excelでやればいいと思います。 1. TableAにAファイルの中身、TableBにBファイルの中身をメモ型フィールド項目「CSV_VALUE」内に全部突っ込んでおく。 TableAには、「1」を追加する用のテキスト型フィールド「DUPLICATE_FLG」を設けておく。 2.SQLを叩く UPDATE TableA A SET A.DUPLICATE_FLG = 1 WHERE EXISTS ( SELECT B.CSV_VALUE FROM TableB B WHERE B.CSV_VALUE = A.CSV_VALUE ) 3.テーブルを開いて、Ctrl+Aで丸々、新csvファイルとして正規表現が利用できるテキストエディタに貼り付ける。 (EmEditorなど) 1行目のタイトル行は不要なので、行削除する。 4.正規表現を使って、「1」の部分を置換する。 検索：\t$ 置換文字：, 検索：\t1$ 置換文字：,1
やり方は、いろいろあります。 無くて七癖ですが、私はいつもこういうパターンです。 '// Sub IntegratedCellsData() 　Dim Rng As Range 　Dim i As Long 　Dim x As Variant, v As Variant 　With ActiveSheet 　　Set Rng = .Range("A2", .Cells(Rows.Count, 1).End(xlUp)).Resize(, 9) 'Jまで 　　For i = 1 To Rng.Rows.Count 　　　If Application.CountA(Rng.Rows(i)) > 0 Then 　　　　x = Rng.Rows(i).Value 　　　　x = Application.Index(x, 1, 0) 　　　　v = Trim(Join(x, " ")) 　　　　'間を揃えるなら、ここでrepalce関数か正規表現 　　　　Rng.Cells(i, 10).Value = v '10 = k 　　　　Erase x 　　　End If 　　Next i 　End With End Sub
数式のエラーチェックで どこかが循環参照になっていないか確認して下さい。
計算式がどういったものか分かりませんが，ABS関数（絶対値を返す）を使ってはどうでしょう． 例えばセルA1～A3の合計を計算するとして各々のセル値が下記のの通りとします． A1 -40 A2 20 A3 -30 これの合計を求める時は =SUM(A1:A3) 合計は-50ですよね． この時の-50ではなく，50として計算したいなら =ABS(SUM(A1:A3)) とすれば50になります．
こんにちは！ 他の方への補足などを読み返してもイマイチ理解できないのですが・・・ 質問文の「あ～か」はE列にあり、F列のデータを操作するという解釈です。 VBAになりますが一例です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim lastRow As Long, myRng As Range Dim myFound As Range, myFirst As Range lastRow = Cells(Rows.Count, "E").End(xlUp).Row Set myRng = Range(Cells(6, "E"), Cells(lastRow, "E")) '←検索範囲は6行目以降に設定！ Set myFound = myRng.Find(what:="か", LookIn:=xlValues, lookat:=xlWhole) If Not myFound Is Nothing Then Set myFirst = myFound If myFound.Offset(, 1) <> "" Then myFound.Offset(, 1).Cut myFound.Offset(-5, 1) End If Do Set myFound = myRng.FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do If myFound.Offset(, 1) <> "" Then myFound.Offset(, 1).Cut myFound.Offset(-5, 1) End If Loop End If End Sub 'この行まで// ※　一旦マクロを実行すると元に戻せませんので 別シートでマクロを試してみてください。m(_ _)m
ExcelのVBAでのOutlook操作は結構厄介です。 新規メールの作成は簡単なのですが、既に作成されているメール文書の操作というのがなかなか出来ませんでした。 Outlookの下書きフォルダに入っているものであれば取り出す事が出来ました。 Bccの設定は下記でやっていますので、そこで既にできている複数アドレスを入れて下さい。 objMAILITEM.BCC = "x,y,z" Sub Sample() Dim oApp As Object Dim myNameSpace As Object Dim myFolder As Object Dim objMAILITEM As Object Application.ScreenUpdating = False Set oApp = CreateObject("Outlook.Application") Set myNameSpace = oApp.GetNamespace("MAPI") Set myFolder = myNameSpace.GetDefaultFolder(16) Set objMAILITEM = myFolder.Items(1) objMAILITEM.BCC = "x,y,z" objMAILITEM.Display '表示 objMAILITEM.Save 'objMAIL.Send '送信 objMAILITEM.Close 0 Set objMAILITEM = Nothing Set myFolder = Nothing Set myNameSpace = Nothing Set oApp = Nothing Application.ScreenUpdating = True End Sub
前回ベストアンサーをいただいたのですが、前回の回答と中身同じ。 C2セルに =IF(OR(A3="",SUM(A$1:A3)-SUM(C$1:C1)>10),SUM(A$1:A2)-SUM(C$1:C1),"") D2セルに =IF(C2="","",SUM(B$1:B2)-SUM(D$1:D1)) 上記、説明が必要ですか？
条件付き書式で、A列に値が入力されたら、 セルの背景色と同じ色に文字を修飾する。 質問タイトルでは行を、 質問文では特定の範囲を非表示 …という意味が良くわからない質問なのだ。 自分なら面倒なので条件付き書式を使ってセルの背景色と同じ色にして見えなくするように仕向ける。
VBAは関係ありませんね。 IF関数で条件を指定して、その条件の結果で処理を変えれば済むだけの話です。 IF関数は、 　=IF(条件式 , 条件成立時の値または数式 , 条件不成立時の値または数式) のようにして使います。 それ以前に、質問の例にあげている値は質問文を読み限り間違っているような気がするのですが…。 10を超えない範囲で合計を求め、次のセルから合計の積算を続ける…のように見えます。
回答にはならないかもしれませんが、 VBAで、データの変更があったセルの位置を確認し、チェックを入れたり外したりするSheet1のセル☆であれば、そのセルと対応しているsheet1のＡさんの固有コードをSHEET2の固有コードが記載されているセルを探索し、そのセルに対応させているチェック表示用セル★のプロパティを、Sheet1のセル☆と同じにコピーする 最低限、sheet1とsheet2に、個人を特定識別出来る個人にユニークなコードを入れておく必要があります。（氏名だけでは不完全でエラーになる危険が多いです） ｢sheet2には、必ずsheet1の人物がいる｣ことが好ましいです。sheet2にはいない人物がsheet1にはいる可能性が否定できないならば、そうしたsheet1の人物にチェックを入れた場合はどのように扱うのかを決めておくのが好ましいです。 チェックを入れる,チェックが入るという具体的なことの、excelシート上の具体的変化を決めておいた方がいいです。例えばチェックには、◎/○/△/×/レの5種を使うとか、数字を使うとか、空白/｢既｣の文字を入れるとか、氏名のセルの背景色を変えるとか、その他ActiveXのコントロールなどを使うとか。それによって具体的なやり方が変わります。 また、sheet1にはAさんに関して｢B列に会合参加/C列に会合＋懇親会/D列に不参加/三列は共に空白｣のような申込状態のチェックで、sheet2にはB列に回答の到着だけをチェック表示するというような、ちょっと変わった対応をするやり方もあり、方法が変わります。 具体的な状況が分からないと、方法についての回答が難しいような気がします。
C1: =LEN(A1)-LEN(SUBSTITUTE(A1,"　","")) B2: =IF(ROW(A1)>C$1,"",FIND("　",A$1,SUM(B1,ROW(A1)))) A2: =IF(B2="","",MID(A$1,B1+1,B2-B1-1)) 範囲 A2:B2 を下方にズズーッとオートフィル
>ファイル数が１０以上あり、また、それらを保存しているフォルダも >別々なので、マクロを組みたいと だとすると数式よりもマクロの方がめんどうです。 プロシージャの中でファイルへのパスを指定する変数は一つだけですみますが、その変数にパスを代入するための記述がかなり面倒になります。 各パスに法則がないのならすべてを手入力することになるでしょう。 数式なら数式入力中に該当ファイルの該当セルをクリックするだけですので、この際数式で考えられた方がいいと思いますよ。
↓が参考になります。 http://kogolab.chillout.jp/elearn/icecream/chap2 …
オートフィルターで○のデータを抽出して、追加したシートにペーストします。 追加するシート名を「転記」にしますので、既に「転記」というシートが存在していたらエラーになります。 元データのあるシートをアクティブにして実行してください。 Sub ○のみ抽出() Dim SH Set SH = ActiveSheet With Range("a1") If .AutoFilter = False Then .AutoFilter End If .AutoFilter field:=2, Criteria1:="○" .CurrentRegion.Copy End With Sheets.Add With Range("a1") .PasteSpecial xlPasteColumnWidths .PasteSpecial xlPasteFormats .PasteSpecial xlPasteValues End With Range("b1,e1,g1").EntireColumn.Delete Cells(1, 4) = "年月" ActiveSheet.Name = "転記" SH.Range("A1").AutoFilter End Sub
2010は標準でPDF出力できたような気がする。 「印刷」ではなく「保存と送信」でPDF化できますよ。 PDF化されたものの印刷はPDFビューワソフトで行います。
今、軽１４と入力されているセルに Sum関数を入れるだけだと思いますか 例 =Sum(B2:E2)　と入れて　下方向へコピー
マクロを含んだファイルのようですので、マクロを見直してくださいな。 パスが違っているなんて落ちかもしれません。 ・・・(´・ω・`) 他人様が書いたマクロを使って文句を言ってはいけないとどっかの偉い先生が言ってたような気がする
》 数式を"0"にだけ適用してあとの2つは自動でカウント どういう意味ですか？ 》 左端の列の平均を"1"、"2"、"3"別に同じように自動計算できる方法 じゃあ、冒頭の「データ中の"0"と"1"と"2"をそれぞれカウント」は、どの列に対するものですか？ 》 画像データはフィルターで抽出した後のデータ 「フィルター」とは「オートフィルタ」のことですか？ つまり、表示されているデータの行番号は飛び飛びであって、連続していないと？
》 「2016/7/11」の時は「2016/7/4」を返す”の方で考えております え？ホント？考えても分からなかったので、質問したのでは？
自分なら7時から6時までを0から23と言う数字に置き換えて、15以下と16以上かを判断して印をつけます。 A1セルに日時の入ったセルがあれば、 　A1+"17:00" で7時を翌日の0時にすることができます。 　HOUR(A1+"17:00") これで時間（時）だけを取り出せます。 ちなみに22時は「15」になるので 　=IF(HOUR(A1+"17:00")<16,"7～22時","23~6時") みたいにします。
一応、たたき台程度です。 添付の図のような配置として 棚名称の右側に　=INT(B5/B$2) と割り算して整数化すれば、並べられる数がわかります。 同様に、縦に並べられる数 高さに詰められる数を計算すれば、それぞれの棚に入れられる個数が出ます。 後は、その数値を見ながら棚を決めるか 縦横を入れ替えてみるか等ですかね。 実際は、箱に商品シールが貼ってあり、向きを変えてはダメとか 箱を立ててはダメとか仕様もあるでしょうし、 置く場所も商品グループごとなどと要望も出てきますよね。
私も発想を変えて、グラフを自動で作成するマクロではなく 必要なデータを抽出するマクロや関数を考えて方が良いと思います。 別途、一枚シートを準備して 名前を入れると（選択すると）グラフに必要なデータが抽出されるようにする。 複合グラフを配置しておく。 名前を変えるだけで、必要なグラフに変わると思うのですが、如何でしょうか。 一例ですが これをマクロとして １．別シートにコンボボックスにて個人名を指定してフィルターオプションでデータを抽出する。 ２．そのシートには上記のような複合グラフが準備してある。 ３．表をグラフを印刷する。 ４．グラフを削除し、オートフィルターを解除する必要もありません。
添付図参照 Sheet2!B2: =SUMPRODUCT((Sheet1!$A$2:$A$19=B$1)*(Sheet1!$B$2:$B$19=$A2)*(Sheet1!$C$2:$C$19))
細かな所までは見ていませんが、ほんのちょっとの、微妙な所ではないでしょうか。 >ThisWorkbook.Activate これが要らないと思います。 最後にブックを締めるときに邪魔にならないように、False を入れました。 '// Public Sub Macro1() Dim Thisbook_path As String Dim Excel_path As String Dim Excel_name As String Thisbook_path = ThisWorkbook.Path Excel_name = ThisWorkbook.Worksheets("本店").Cells(4, 1).Value & ".xlsm" Excel_path = Thisbook_path & "\" & Excel_name MsgBox (Excel_name) If Dir(Excel_path) = "" Then 　MsgBox (Excel_path & "が存在しません") 　Exit Sub End If Workbooks.Open Excel_path　'Activate を抜きました。 Workbooks(Excel_name).Worksheets("集計").Range("B1").Copy ThisWorkbook.Worksheets("本店").Range("B20").PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _ :=False, Transpose:=False Workbooks(Excel_name).Close False '←ここにFalse を加えました。 End Sub
こんにちは。 スタンタードの行全体の高さを変えて、1～2を元の高さに戻す方法にすると良いと思います。 この場合は、表の最後尾まで触れていませんので、データのある所までしか、使われていません。ファイルは小さいままで済みます。 その後でフォントの大きさを変えないと、それに合うようにセル幅を変えてしまいます。なお、高さは完全な50にはたぶんならないと思います。ピクセルが優先されていますので、丸められてしまいます。 '// Sub ChangeRowHeight1() Dim OrgRowHeight As Double With ActiveSheet 　 OrgRowHeight = .Cells(1, 1).RowHeight 　 .Cells.Rows.RowHeight = 50# 　 .Rows("1:2").RowHeight = OrgRowHeight ' または、スタンダード 13.5 　 　 .Columns("X").ColumnWidth = 30 'Ｘ列の幅３０ 　 'フォントの位置､サイズは 　 .Columns("X").HorizontalAlignment = xlCenter 　 .Columns("X").VerticalAlignment = xlCenter 　 .Columns("X").Font.Size = 16 'Ｘ列のフォントサイズ　'ここは重要 End With End Sub
>「Ａlt」ボタンで改行する方法を知らずに・・・ 広い意味で言えば、人間として知らなくても全く問題のない事ですが 会社の中で、事務系の仕事している人にとっては致命的ですよね。 色々とパソコンの指導をしていて 私、エクセルは毎日使っているので大乗です。　と云う人 8割の方で 書式＝＞表示形式（特にユーザー定義） 条件付き書式 ピボットテーブル フィルターオプション（ひどい時はオートフィルター） Vlookup関数、Sumif関数なども知らない。 最近びっくりしたシートで 月単位のシートで日付が文字型　'8/1　と最初に’を打っていた事 出来る事は 既に作成されたシートに入力する オートサムで合計を計算 自分でシートが作れないので、ひたすらシートをコピーして増えていく。 そんなもんですね。 傾向として 総務部門等保守的な部門、社外との競争のない部門ですね。 ワードやメールなど文書能力はありますが、新しく自分で何かを実行する能力が欠けている傾向がある。 出来る人が多いのは 営業部門、開発部門など、社外との競争がある部門 エクセルだけでなくパワーポイントなども使いこなしている。 表現力がすごいが、ワードしか使えない人にはかえって伝わらない。 標準偏差とか近似曲線とか使っても意味を知らないので話をしても伝わらないですね。 まあ、所詮は、その職場の雰囲気、リーダーの考え方と云った所でしょうか。 ３つに分けると １、指示された仕事をこなす（与えられたファイルに入力する）職場 ２、自分で考えて仕事をさせられる（自分でファイルを作る、分析する）職場 ３、仕事を教えてくれる職場（能力のある人がとことん教育、指導）職場 職場の実力を上げるのであれば、Alt＋Enterを知らない人があいれば教えてあげましょう。 Ctrl＋　＋　＋（れ）　のキーで今日の日付、Ctrl　＋　＊（け）のキーで今の時刻 も意外と誰も知らないので、教えてあげるとちょっとした自慢になります。 ちょっとでも興味を持ってくれれば、後は自分で成長します。 但し、成長途中の人をばかにしない事、凄いとほめる事は忘れないようにしましょう。
こちら↓で説明している条件付き書式と同じようにできるのでは。 Excelで条件付き書式で種別ごとに罫線を引く http://miyu-excel.seesaa.net/article/396268866.h … 担当の列にあるデータで、上下が違う場合に実線を引くようにすれば、 希望していることができると思いますよ。 =$A2<>$A3　←この場合は実線 =$A2=$A3　←この場合は破線 =ROW($A2)=2　この場合も実線（表全体の上罫線）
「ナンバリング」の意味を間違っていませんか？少なくとも使い方を間違っています。 ×ナンバリングが振っています。 https://kotobank.jp/word/%E3%83%8A%E3%83%B3%E3%8 … 添付図のようなものがほしい場合、ナンバリングとは通常呼びません。 「ナンバーを割り当てる/割り振る」が妥当だと思います。 「ナンバリング」では、すべてに番号を付けることと捉えます。 数量が10個だったら、1,2,3,4,5,6,7,8,9,10と番号を付ける。と捉える。 さて、どこに入力するのでしょうか？ となったわけです。 ([Alt]+)[PrintScreen]で画面をコピーできますので、ペイントに貼りつけて画像をアップさせてはいかがでしょうか？
こんにちは！ COUNTIFS関数はAND条件になりますので、今回の質問には適しません。 =COUNTIF(範囲,"A")+COUNTIF(範囲,"D") のように「A」のセル数と「D」のセル数をコツコツと足し算するのが 間違いないと思います。m(_ _)m
こんばんは Excelは何年も使っていますが、優れたソフトだと思います。 だだ、No.2さんの回答にあるように、印刷は苦手です。 思った通りに印刷したい場合には、Wordを使うことをお奨めします。 ＞同じエクセルなのに、どうして、２０１６ Ｅｘｃｅｌｌ for Mac では、同じように表示が出来ないのか、・・・？ ＞Ｍａｃのエクセルは、ウィンドウズとオプション設定が違うのか、・・・？ 同じエクセルのように見えても、中身は別物です。出来るだけ使い勝手が同じになるように作ってあるとは思いますが、使い方によっては違いが出てくることもありえます。
Google スプレッドシートにあるFILTER関数を使いたいのですね。 https://support.google.com/docs/answer/3093197 条件を満たす値が見つからない場合は、" #N/A "が返されますので、 COUNTA関数を使うと"1"を返します。 どうしてもCOUNTA関数を使わないと駄目なのですか？ 数値をカウントするのならCOUNT関数で済むのでは？ 　=COUNT(FILTER('シートA'!X:X,'シートA'!X:X=5)) このような数式でカウントできませんか？
#2の回答者です。 もう一言だけ書かせていただきます。 ご質問者さんのご質問には、何をしたいかを書かれておりません。 そのコードはどういうつもりで手に入れて、何をさせようとしているのでしょうか。どんなに便利な道具でも、それぞれには使い方と目的があります。それを道具だけ持ってきて、これを動かしかたを教えてくれというのは、掲示板の質問としては、とても不自然なことだと思うのです。 コードを実行しようとしたけれども、動きません、ということだけです。イベント・ドリブン型のマクロ自体、その仕組み自体を教えることと、必要に応じて、その場面でマクロを動かせるというのでは、同じようなことでも雲泥の違いがあります。 まず、ご自身が何をしたいか、ということです。 これが、どんなに偉い人であっても、この場面でいう言葉は一言。 「一体何のためにですか？」ということです。 たかが、VBAマクロかもしれません。ただ、このコードを動かせるように教えてくれればよいのです、と言われているように感じます。 回答者側がVBAのコードを通るようにしてくれた親切な方もいらっしゃるようですが、それだけでは足らないものがあるはずです。 単なるボタンの掛け違いような話でも、回答者側にとっては、大きな違いではないでしょうか。
A1セルに8桁の数が入っていた場合 ・文字列で処理 「=MID(RIGHT("00000000" & A1,8),1,2)」 「=MID(RIGHT("00000000" & A1,8),3,2)」 「=MID(RIGHT("00000000" & A1,8),5,2)」 「=MID(RIGHT("00000000" & A1,8),7,2)」 ・数値で処理（表示形式は「00」してください） 「=INT(A1/1000000)」 「=INT(MOD(A1,1000000)/10000)」 「=INT(MOD(A1,10000)/100)」 「=MOD(A1,100)」
》 …の部分を右にオートフィルすると… え？「右に」ですって？ A12:AD42 　　↓ A54:AD84 　　↓ A96:AD126 　　↓ A138:AD168 という関係は、「下方向」では？
…もう面倒だから、セル1つずつ設定するかい？ F２セルにはB2セルと全く同じ条件の数式を書くんだ。 B2セルに 　=B2=TODAY() なら F2セルにも 　=B2=TODAY() と設定する。 B2セルの値を参照しながらF2セルの条件付き書式を設定するということ。 そのため適用先に列の異なる範囲を設定した場合は、列方向に参照先がずれないようにするため ＄B2 のように列を示すBの前に＄を付ける。 ※絶対参照について自身で調べて理解をすること。（←これ、お約束） そして、条件付き書式の優先順は、 　「条件が上にある方が優先」 これはしっかり覚えておくこと。 条件を作るときに、 　・今日 　・過去 　・30日以内 　・31日以上 の順で作ると、条件付き書式には 　・31日以上 　・30日以内 　・過去 　・今日 の順に出来上がる ので、今日から30日後より以前の値を持つセルは30日以内とみなされ、この書式が適用され赤くなるでしょう。 この場合、順番を 　・過去 　・今日 　・30日以内 　・31日以上 と並び替えればよい。並び替えは後からでもできる。 優先順位があることが分かれば、 　=$B2<TODAY() 　=$B2=TODAY() 　=$B2<TODAY()+30 　=$B2>=TODAY()+30 と条件式を指定すれば良く見た目もスッキリすることも理解できるのではないだろうか。 …ただし、B列に値が無い場合や文字列が入力されている場合、今日の日付よりも古いと判断されるので注意。 「B列の値が日付であれば」という条件を、条件式に加えよう。 IF関数を使い、日付かどうかを確認し、日付なら今日の日付と比較、日付でなければ "FALSE" を返すだけですので自身で考えてみてください。 ＝IF(日付かどうかを確認する数式 , IF($B2=TODAY(),TRUE,FALSE) , FALSE) みたいに。 あとは応用です。 初めは難しいかもしれませんが、しっかり理解して身につけてしまいましょう。 ちょっとだけヒントを混ぜて図を貼り付けてみます。参考にしてください。
質問内容に、誤解のようなものがあると思います。「のようなもの」というのは、VBAやマクロが素人ということではなく、それ自体、何もご存知がないままに質問して、マクロでどうにかならないか、とおっしゃっているように感じられます。それでは、解決しようがないのです。 もちろん、記録マクロではどうにもならない壁がありますが、むしろ、ご質問者さんは、少しはマクロのことは、記録マクロぐらいでも取って、あれがこうなり、これがああなりと、想定していれば、もう少し違った質問になったと思うのです。 こちらとしては、大雑把な輪郭だけで、あとのリクエストは無視するしかありません。それでは無理だからです。 マクロというものはどういうものか、それを見せるだけのためです。 >オートシェイプのサイズをセルの値と連動させるような機能 これ自体は、オートシェイプは、セルの位置に結びつけるというのは、VBAでは常識的です。 http://officetanaka.net/excel/function/tips/tips … この操作を思い出すまでは時間がかかりましたが、この話と、VBAは、まったく別というぐらい違います。 そもそも、リンク貼り付けを持ち込んで、どうこうするというなら、VBAの範疇ではありません。そのオブジェクトを処理するというのは、ステージが違います。 >エクセルでのオートシェイプのサイズ変更方法について質問。 これ自体は簡単です。 >縦はB2からB12の10個のセルにそれぞれ入れたいです。 >横はC2からC12の10個のセルにそれぞれ入れたいです。 しかし、図形は、それだけでは不足しています。 以下は、質問者さんの話に沿いながら、こちらの創作です。 参考にしてみてください。 マクロで操作するというのは、おそらくは、イメージとは雲泥の差があるのかもしれません。図形の拡大と縮小はトグルになっていますから、拡大したものをもう一度実行すれば、元に戻ります。 最初に、図形の寸法を記述します。 フォームコントロールのコンボボックスは、Sheet1 にあり、図形は、Sheet2 にあるということになっています。 なお、Magni (倍率）の1.5 つまり、150%が最高ですから、それ以上は大きくさせないでください。 ''標準モジュール '// Sub MeasureShapes() '20行目から書き出します。 ''図形の位置とサイズの記録 Dim shp As Shape Dim i As Long Dim j As Long With Worksheets("Sheet2") j = 20 　.Cells(j, 1).Resize(, 6).Value = Array("Name", "ADR", "Top", "Left", "Height", "Width") j = 21 On Error Resume Next For Each shp In .Shapes 　.Cells(j, 1).Value = shp.Name 　.Cells(j, 2).Value = shp.TopLeftCell.Address(0, 0) 　.Cells(j, 3).Value = Int(shp.Top * 100 + 0.5) / 100 　.Cells(j, 4).Value = Int(shp.Left * 100 + 0.5) / 100 　.Cells(j, 5).Value = Int(shp.Height * 100 + 0.5) / 100 　.Cells(j, 6).Value = Int(shp.Width * 100 + 0.5) / 100 　j = j + 1 Next On Error GoTo 0 End With End Sub Sub ドロップ1_Change() 'フォームコントロールのコンボ・ボックス Dim idx As Integer With Worksheets("Sheet1") idx = .DropDowns(1).Value Call EnlargeShape(idx) 　.DropDowns(1).ListIndex = 0 End With End Sub Sub EnlargeShape(ByVal idx As Integer) '図形の拡縮 Dim mSizes(1 To 5) Dim i As Long, j As Long Dim Magni As Double Magni = 1.5 '倍率　*100% (max) i = idx With Worksheets("Sheet2") If .Cells(20 + i, 1 + j).Value = "" Then 　　MsgBox "図形の測定がされていません。", vbExclamation 　　Exit Sub End If For j = 1 To 5 　mSizes(j) = .Cells(20 + i, 1 + j).Value Next 　With .Shapes(idx) 　　If Abs(.Height - mSizes(4)) < 5 Then 　　.Top = mSizes(2) '起点 　　.Left = mSizes(3) '起点 　　.DrawingObject.ShapeRange.LockAspectRatio = msoTrue 　　.DrawingObject.ShapeRange.ScaleWidth Magni, msoFalse, msoScaleFromTopLeft 　　Else 　　.Top = mSizes(2) '起点 　　.Left = mSizes(3) '起点 　　.Height = mSizes(4) 　　.Width = mSizes(5) 　　End If 　End With End With End Sub 左がSheet1, 右がSheet2 その右下に出てくるのがオートシェイプの位置です。
条件付き書式にCOUNTIF関数を使ってみては。 　=COUNTIF(C4:C12,"×")>0 4行目から12行目までに「×」が一つでもあればTRUEになるので。
No.1です。 エラーが出たというコトなので・・・ 「タブ1」Sheetと「タブ2」SheetのB1～D1セルの項目の並びが一致しているのであれば 「タブ2」SheetのB2セルの数式を =IF(COUNTIF(タブ1!$A:$A,$A2),IF(COUNTIFS(タブ1!$A:$A,$A2,タブ1!B:B,"YES"),"YES","NO"),"") という数式にしてみてください。 ※　前回の数式は項目の並びがバラバラでも対応できる形にしていました。m(_ _)m
SUMPRODUCT関数を使えば、一つのセルだけで計算できます。 http://www.eurus.dti.ne.jp/~yoneyama/Excel/kansu … 計算例 　=SUMPRODUCT(A1:A400,B1:B400)
以下は Sheet2 における操作です。 G2: =COUNT(Sheet1!$D:$D) H2: =MAX(Sheet1!D:D) A2: =OFFSET(Sheet1!$A$2,(ROW(A1)-1)/$H$2,COLUMN(A1)-1) 此れを右３列にオートフィル 範囲 A2:D2 を下方にズズーッと(戻り値が 0 になるまで)オートフィル セル E2 に次式を入力して、このセルのフィルハンドルを「エイヤッ！」とダブクリ ￣￣=IF(MOD(ROW(A3),3)+1>D2,NA(),"") その結果を添付図右側に示している。 列Ａ～Ｅ全体を選択して、[コピー]＆[値の貼り付け]した後で、[ジャンプ]→[セル選択] から、“定数”に目玉を入れて、“エラー値”以外のチェックを外して[OK]をツン。その マンマで、[編集]→[削除]→“行全体”→[OK] 数値 1 を入力したセル E2 を下方にズズーッとオートフィル 列Ｅを削除 以上で貴方が示した添付図右側が得られます。
こんばんは Excelのルビ機能は「入力されたときの情報を表示する」というものです。 例えば、「鉛筆」を「鉛・筆」で入力するとルビも「ナマリ・フデ」になってしまいます。 Wordですと、文章を解析してルビをふる機能がついています（たまに間違いもありますが。また「大谷さん」を「おおやさん」か「おおたにさん」かを区別は出来ません）。 かなりの難問です。 そこで補足要求です。 なぜそのようなことをしたいのか、企業機密に触れないような範囲で教えてください。
SUMIFでもいいかと思いますが ピボットテーブルで集計すればいいのでは？ ピボットテーブルは一度作っておけば 送られてくるデータを Ａ:Ｃ列に貼り つけて データを[更新]するだけでいいです。
>A1をダブルクリックして、100行目まで取り込めましたが、 >それ以降のデータが取り込めませんでした。 こちらの解釈とはかなりのズレがあるような気がします。 そのように作りましたから、そうなるはずです。 そもそもの受け取り方の意味が大きく違っていたようです。 >sample1.csv、sample2.csv、sample3.csv・・・です。 >それぞれ行数が決まっておらず、数万行の場合もあり、 >数百行の場合もあります。 それだけでは、よく理解できないのです。だから、こちらは混乱しています。 最後尾をどのようなスタイルにするかということです。 全体的な結果のイメージがついていないのですが、データを隙間なく入れることでしょうか。それとも、ダブルクリックした場所から、データを最後まで入れていくということでしょうか。 例えば、100,123行あれば、それを全部インポートして、その後、どこをダブルクックしようとも、100,124行から項目を抜いて入れていくことですか？ 私は、てっきり、100行ずつ区切るものだから、最初の項目行の部分だけ、1行減ってしまうものだと思いました。 >A10001を起点に11200行まで取り込みたいのです。 こうしたピンきりの数字で収まるとも思えません。 >A101をダブルクリックすると、項目行から取り込まれました。 ここは何度も確認した事項でしたが、今コードを読むと、 　If g < 99 And i = 0 Then 　　Cells(g + i, 1).Resize(, UBound(arBuf) + 1).Value = arBuf 　'ElseIf i >= 0 And i < 100 Then　'←　0を読むように書いていますから、0を読まないようにすればよいのですが…… 　ElseIf i > 0 And i < 100 Then 　　Cells(g + i, 1).Resize(, UBound(arBuf) + 1).Value = arBuf 　End If となるように思うのですが、そもそも、100行しか読まないように作られていますから、意味がありませんし、全体的に変えなくてはならないようです。 前のデータと次データの境目をどのようにするのか、分かりません。 なお、 ・項目行とデータ行は、人間の目視では区別はつくでしょうけれども、明らかに、データ行と項目行に違いはありますか。同じ文字型ですと、今度は、その区別はプログラムで分けなくてはなりません。 ここを読んでいる他の方で勘の良い方なら、すぐに、解決するでしょうけれども、私は、Excel系では、徐々に、質問で読み取れないものが増えてきているような気がします。もちろん、記録マクロで解決するレベルではなさそうです。 >今回用意されているcsvはカンマを区切り文字とされているため、 >データの前後に「"」がついてきてしまうのですが、これは、 >どこで修正したらよいでしょうか。 それは、おそらく、(こちらの想像の範囲ですが、） TextLine = Replace(TextLine, """", "") arBuf =Split(TextLine, ",") とすれば、問題なく通るはずです。 とりあえず、本日はここまでです。
こんにちは セルにあらかじめ関数式を設定しておけば可能だとは思いますが・・・ 使い方がわからないのですが、式を設定しておくセルって入力用のセルのように感じられます。 この場合、一度何らかの入力をしてしまうと（事前にセットしておいた）式は上書きされてしまいますので、その後に隣接するセルの入力値を修正したりしても、式で予定されていた表示はされないということが起こり得ます。 そのようなことは起こらないというものであれば、式を事前にセットしておくことで、ご質問の内容は実現可能だと思います。 そうではなく、いろいろ操作していて、5行目（？）に「三原」と入力したら常に右隣のセルには「→」を、下の2つのセルには「15：00」を強制的に入力したいというのであれば、マクロを利用することで実現可能です。 イメージとしては、5行目（？）の入力を監視して、該当する入力があったら、隣接セルの値を設定するようにしておくだけなので、比較的単純なもので済むはずです。 入力した「三原」を修正して消した場合に元にもどしたいとかなってくると、急に難しくなってきますが・・・
私は、海外に出る社員の出張経費などの会計を長い間していたので、ひとつの決め事があります。 今回については、お気に召さないかもしれませんが、 SUMIF関数の方がよいのではないでしょうか。 D32以降で、外貨合計を出すということですから、 添付画像をご覧ください。 Euro　　　=SUMIF($B$10:$B$31,B32,$C$10:$C$31) JPY　　　=SUMIF($B$10:$B$31,B33,$C$10:$C$31) 人民元　　=SUMIF($B$10:$B$31,B34,$C$10:$C$31) それと、以下は、経理側が計算するのかもしれませんが、なんでしたら、円換算にするのには、VLOOKUP関数がよいでしょう。 currency　Amount　J.Amount　　(数式) Euro　　　10.00　　　1,113　　=TRUNC(N(C10)*VLOOKUP(B10,$I$2:$J$5,2,0)) JPY　　　1500.00　　 1,500　　=TRUNC(N(C11)*VLOOKUP(B11,$I$2:$J$5,2,0)) 人民元　　2600.00　 40,040　　=TRUNC(N(C12)*VLOOKUP(B12,$I$2:$J$5,2,0)) Trunc関数は、Int関数の代わりに使います。 マイナスの時に、四捨五入が狂うからです。 -------------------- 　I　　　　J Currency　Cash B 　EUR　111.34　 　USD　102.02　 　CNY　15.4　　* キャッシュレートがありません。 　JPY　1.00 　 三菱東京ＵＦＪ銀行より
なんでピボットテーブルを使わないのでしょう……合計も表示でき るので何の問題もないと思いますけど。 もしくはデータベースクエリで抽出すれば 勝手にテーブルになるの ですから最終行に集計行を追加すればいいかと思います。 項目も必 要なものだけ選んで抽出できます。コマンド文字列は SELECT 日付, 金額 FROM [Sheet1$] WHERE 業者 = 'A社' これだけです。「'A社'」のところは「?」にして パラメータにセル を指定することもできます。
> A列の種別に対して一つの商品にしたいです。 ということなら C4:=IF(COUNTIFS(A$4:A4,A4,B$4:B4,B4)=1,MATCH(A4,F$3:H$3,0)*1000+COUNTIF(A$4:A4,A4),"") F4：=IF(COUNTIFS($C:$C,"<"&1000*(COLUMN(A1)+1),$C:$C,">="&1000*COLUMN(A1))<ROW(A1),"",INDEX($B:$B,MATCH(SMALL($C:$C,COUNTIF($C:$C,"<"&1000*COLUMN(A1))+ROW(A1)),$C:$C,0))) こうなります。
こんにちは！ 具体的な配置が判らないので、やり方だけ・・・ ↓の画像でI2セルに =SUMPRODUCT((B2:G2=K$2:K$11)*L$2:L$11) という数式を入れフィルハンドルで下へコピーしています。m(_ _)m
こんばんは テストとして、以下の手順を試してみてください ・エクセルを開く(ワークシートは３つで) ・名前を付けて保存 ・Sheet1のA1に「abc」を入力 ・Sheet2のA1に「def」を入力 ・標準マクロを作成 ・以下のマクロを標準モジュールに作成して実行 を試してみてください。 同じbook内ならば、他のワークシートの値を利用するのは簡単です。 Sub サンプル() Worksheets(3).Range("A1") = Worksheets(1).Range("A1") Worksheets(3).Range("A2") = Worksheets(2).Range("A1") End Sub
CLng関数【も】銀行型丸め（偶数）ですがその辺は大丈夫ですか。 https://msdn.microsoft.com/ja-jp/library/cc41021 … より 「小数部分が 0.5 の場合は、CLng 関数は常に最も近い偶数に値を丸めます。 たとえば、0.5 を 0 に、1.5 を 2 に、それぞれ丸めます。」
こんにちは 写真（？）を見てもよくわからないところがあるので、以下のように仮定しました ・赤色のセル範囲はＣ3：Ｌ3になっているが、C3を参照すれば良い ・2セット目以降は隙間なく下に並んでいて、参照先はC45、C87、C129…の順である ・上記セルの参照を別シートに横に並べたい（一行に表示したい） ・別シートのセルは結合などなく、1セル単位で参照が並べば良い 別シートの横並びの一番左側のセルに以下の式を代入して、 　=IF(COLUMN(A1)<=30,INDIRECT("Sheet1!C" & COLUMN(A1)*42-39),"") 右方向にフィルコピーすれば宜しいかと。 30個分の参照が並びます。 参照位置が違っていたり、別シートのセルが（結合されているなどで）飛び飛びの場合でも、同様の考えでできますが、条件に応じて計算式を修正する必要があります。 ANo2様もおっしゃっていますが、応用するためには、式の意味するところをご自身でも理解なさっておくのが一番かと思います。
[No.1]です。 》 M2: =(D2>0)+(I2>0) は、N2: =(D2>0)+(I2>0) の間違いでした。」m(_._)m
No.2です。 すみません、テストをH列でしたので、そのままH1の式を回答に書いてしまいました。 A列でA1からの日付なら勿論A1です。変更してやってみて下さい。 大変失礼しました。
No6です お礼ありがとうございます。 >この様な関数は書籍から学べるものなのでしょうか？ countif関数の基本的な説明をしている参考書はいろいろありますが このような例題ズバリを解説している本を見付けるのは大変だと思います。 書店に行って、本人のレベルにふさわしい本をみるとか、 Excel　の数式バーの左にあるボタン fx をクリックして関数挿入窓で 関数の分類をすべて表示し、適当な関数を選択して、この関数のヒントをクリックすれば関数の説明と例題をみることができます。 それから このカテで他の方の質問を沢山チェックしていると、その回答の中に、他の問題に応用することが出来るヒントに出会うことがあります。私の場合は、これが相当に役立っています。
直接的な回答ではありません。 中身は知りませんが 株損益計算エクセルシート(ExcelVBA) http://happy.kabu-web.net/kabu_tool_6.html のようなものが役に立ちませんか？
仕様をちょっと変えて、「C列が１の行を削除」→「C列に入力がある行を削除」でも問題が無ければ、より簡単にコーディングすることができます。（コーディングに合わせて仕様を決めるのは本末転倒ですが･･･） こんな感じです。 Sub Macro1() Dim LastRow As Long Range("C2:C" & Rows.Count).SpecialCells(xlCellTypeConstants, 23).EntireRow.Delete LastRow = Cells(Rows.Count, "B").End(xlUp).Row If LastRow > 2 Then Range("A2") = 1 Range("A2").AutoFill Destination:=Range("A2:A" & LastRow), Type:=xlFillSeries End If End Sub
D2セルには半角の「W」を入力していますか？ 全角だと、同じにならないので「1」が表示されますので。 B3セルの式にある"W"と、D2セルに入力したという「Ｗ」は違います。 「W」　　←半角W 「Ｗ」　　←全角W ココのサイトだと見分けがつきにくいですが、全角と半角を区別しないと IF文の判定で正しくないとされますから、注意が必要です。 どうしても間違って入力される可能性があるなら、JIS関数を組み込み IFの条件が半角・全角どちらでも正しく判定するようにしてはいかが。 =IF(JIS(D2)="Ｗ",0,1)　　←ここでの"Ｗ"は全角
ママチャリさんの回答に近いかな =IF(ISNA(MATCH(LEFT(B8,2),INDEX($B$3:$D$5,,MATCH(LEFT($B$7,FIND("日",$B$7)-1)*1,$B$1:$D$1,0)),0)),"休み？", INDEX($A$3:$A$5,MATCH(LEFT(B8,2),INDEX($B$3:$D$5,,MATCH(LEFT($B$7,FIND("日",$B$7)-1)*1,$B$1:$D$1,0)),0))) XL2007以降でなくてもOKです。#N/AエラーをISNA関数で対処してます。 IFERROR使えるなら =IFERROR(INDEX($A$3:$A$5,MATCH(LEFT(B8,2),INDEX($B$3:$D$5,,MATCH(LEFT($B$7,FIND("日",$B$7)-1)*1,$B$1:$D$1,0)),0)),"休み？")
バージョンによって違います。とりあえず参考にどうぞ！ https://121ware.com/qasearch/1007/app/servlet/re …
最初に、この場合は、 If Range("A1").Value >= "1" Then "1" が、String 型ですから、Range("A1").Value も、連動して、String 型に変わってしまいます。 それとは別に、VBA上のDouble型の小数点は、補正処理を受けないままの数値ですから、その誤差は約50%ぐらいですから、そのままでは使えません。いわゆる丸め誤差が発生してしまいます。 VBAで、Double/Single型の小数点を扱う時には、要注意です。 これは、基礎的なVBAの知識です。VB6の教科書には出てきますが、VBAでは知られていないかもしれません。 'Currency 型を使う方法、 Sub TEST2() Dim myVal As Currency '厳密な計算をする場合 myVal = Range("A1").Value If myVal > 1 Then 　MsgBox "100%を越えています", vbInformation Else 　MsgBox "100%以下です", vbExclamation End If End Sub 'Decimal 型に変える方法。 Sub TEST3() Dim myVal As Variant '厳密な計算をする場合 myVal = CDec(Range("A1").Value) If myVal > 1 Then 　MsgBox "100%を越えています", vbInformation Else 　MsgBox "100%以下です", vbExclamation End If End Sub '// 参考例 Sub Test4() Dim mData Dim bln As Boolean a = 1.03: b = 1.001 mData = a - b: bln = mData = 0.029 mData = CCur(a) - CCur(b): bln = mData = 0.029 mData = CDec(a) - CDec(b): bln = mData = 0.029 mData = Format(a - b, "0.000"): bln = mData = 0.029　'整数固定法 End Sub
=TEXT(M2,"00!:##")*24 入力　結果 30 -> 0.5 2430 -> 24.5 -------------------- =TEXT(M2+2400*(INT(M2/100)=0),"00!:##")*24 入力　結果 30 -> 24.5 2430 ->24.5 2830 ->28.5
こんにちは！ 一例です。 ↓の画像のような配置で元データはSheet1にあり、Sheet2に表示するとします。 まずSheet2のC2セルに =IFERROR(SMALL(Sheet1!C:G,ROW(A1)),"") という数式を入れておきます。 A2セルには =IF($C2="","",INDEX(Sheet1!A$1:A$1000,SMALL(IF(Sheet1!$C$1:$G$1000=$C2,ROW($A$1:$A$1000)),COUNTIF($C$2:$C2,$C2)))) 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　A2セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ A2セルのフィルハンドルで隣りのB2セルまでコピー！ B2セルの表示形式を好みの日付にします。 最後にA2～C2セルを範囲指定　→　C2セルのフィルハンドルで下へコピー！ これで画像のような感じになります。m(_ _)m
Excelには標準で入力した文字数が表示セルの幅を超えたときにセルの幅を固定する機能はありません。 フィルでコピーした結果か、セルの幅を後から縮めた場合、数値の表示桁がセル幅を超えた場合に表示される機能だからです。 たとえ「セルの表示形式」で「ユーザー書式」を選択し「#######」を指定しても、セルの表示幅を超えると当然セルの幅は変わってしまいます。 （小数点以下も四捨五入されるしね） マクロで都度セルの幅を監視して、幅が拡張されたら元に戻す…ようにしないとダメかも。
>>やってみたんだけど、動作しませんでした。 >>これでいいんですよね？ 1,2行目のセルを結合してませんか？　していたら以下。 H列最終行を取得する関数はRange("H3").End(xlDown).Rowとする。 Sub Sample1() Dim lastRow As Long With ActiveSheet ActiveSheet.Range("A3:H" & ActiveSheet.Range("H3").End(xlDown).Row).Sort Key1:=Range("H3"), order1:=xlAscending End With End Sub
蛇足ですが「両方に名前が有ったら」の考慮は不要でしょうか？ 　○×を表示する各セルに「ＡリストをチェックしてからＢリストをチェックするCOYNTIFを用いた式を入れる」だけだと、Ａリストに名前があった時点で「○」となり処理を終えてしまいます。 　両方のリストに名前が有るケースが有る得る場合は○×以外のマークを設定する必要があります。でないと「両方のリストに名前が無い」場合の空欄と区別がつかなくなります。 参考まで。
こんにちは！ VBAでの一例です。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　カーソルが点滅しているところに↓のコードをコピー＆ペースト →　Excel画面に戻り（VBE画面を閉じて）範囲を選択しマクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Selection.Replace what:=vbLf, replacement:="", lookat:=xlPart End Sub 'この行まで// ※　必ず範囲指定（列全体、シート全体でも構いません）した後に マクロを実行してみてください。m(_ _)m
>或る数値のみ条件を満たしていると思われるにも関わらず白文字で表示されてしまい。頭を悩ませています。 本当ですね。不思議です。 表計算ソフトは小数点の計算が苦手とはききますが、なぜなのかさっぱりわかりません。
No.４です。 Sheet1の配置が間違っていました。 ↓のような配置なのですね？ 前回のコードは消去し、↓のコードに変更してください。 Sub Sample2() Dim i As Long, c As Range, r As Range Dim wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") Application.ScreenUpdating = False With Worksheets("Sheet3") For i = 1 To .Cells(Rows.Count, "A").End(xlUp).Row Set c = wS2.Range("B:B").Find(what:=.Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then Set r = wS1.Range("C:C").Find(what:=c.Offset(, -1), LookIn:=xlValues, lookat:=xlPart) If Not r Is Nothing Then .Cells(i, "B") = r.Offset(, 1) End If End If Next i End With Application.ScreenUpdating = True MsgBox "完了" End Sub 今度はどうでしょうか？m(_ _)m
集計に IF関数なんて使いません。関数でやるなら SUMIFSでしょう。 ただやりたいことはピボットテーブルで集計すれば済むことです。 Excelを使うのなら関数より前に 集計機能全般を勉強して下さい。 そっちの方がよほど大事です。
失礼 ×　表示のシートがあるのかどうかで細部は変わります。 ○　非表示のシートがあるのかどうかで細部は変わります。 #1のプロシージャは非表示のシートがあるとエラーで止まります。
関数を使っても良いと思うのですが、 「B列を基準に並べ替えをする」という選択はないのでしょうか。 そのうえで、C列など空いている列にB列の値が5以上の時にマークを表示するなどの工夫をすることを勧めてみます。
こんにちは！ すでに回答は出ていますので、参考程度で・・・ C1セルに =IF(COUNTIF([sample.xls]Sheet1!$A:$A,A1)+COUNTIF([sample.xls]Sheet1!$A:$A,B1),"○","×") でも大丈夫だと思います。m(_ _)m
黄色にするのは簡単だと思います。 範囲選択して、条件付き書式で以下のように数式を指定します。 　 　=ROW()>ROWS(A$1:A$12)-A$13 A14などの値での青色は、もっと良い方法があるのかもしれませんが、 以下のような数式で指定すれば、一応可能です。 　=AND(ROW()>A$15,ROW()<=ROWS(A$1:A$12)-A$13) A15での白色の塗りつぶしを、別の色にするなら以下の数式で可能だと 思います。 　=ROW()<=A$15
> マクロで実現しているようにも見えません。 ファイル拡張子はどうなっていますか？　シートモジュールは確認されたのでしょうか。 既にちらと書かれていますがデータベースクエリでセルをパラメータに指定しておけば マクロを使わなくても 書いていることはできます。「姓名」がスペース等で区切られて いるなら姓のみ表示させることもできます。 Microsoft Queryとの連携で SQLでコマン ド文字列を書けばいいので。
> VLOOKUP関数で検索範囲を2つの条件で指定することは可能でしょうか？ 質問の意味がよく分かりませんが「VLOOKUP関数で」というのが「VLOOK- UP関数だけで」という意味なら不可能でしょうね。 手段方法に拘らず もうちょっと質問を具体的になさった方がいいと思います。 やり方は回答者が考えればいいことです。
D列のデータがなぜお示しのようになるのか説明してください。 そうしないと、「貴方、大丈夫？」と心配になります。
[No.2お礼]へのコメント、 》 両方とも色が塗られていて欲しい感じ 最初から、そう仰い！ 普通は左から入力して行って、新たに入力したものが重複しているかどうかを知りたいのだ、と思うンじゃない？ 何れにしても、変更はカンタンで馬鹿でも思い付く式になります。 前のが高級なのです。 =COUNTIF($E13:E13,E13)>1 　　　　　　↓ =COUNTIF($E13:$AA13,E13)>1
色をつけるのであれば F2以降範囲指定して、条件付き書式 数式 =AND(A2<>"",E2<>"",SUMPRODUCT((A:A=A2)*(E:E=E2))>1) 塗りつぶしの色を設定 範囲が広いので重くなります。 範囲がわかっていたら =AND(A2<>"",E2<>"",SUMPRODUCT(($A$2:$A$100=A2)*($E$2:$E$100=E2))>1) のように行を指定した方がいいですね。 F列にメッセージを出すなら、これをIFの式にて文言を入れるといいです。
Activecell.Offset(0, 1).Value Rangeオブジェクトの概念を理解する必要がありますね。 いろいろ試してみてください。
まずA1にx,B1にf(x),C1にg(x)と書いてみます。(ラベル) A2に0,A3に=A2+0.05と書きます。そしてA3をコピーしてA4からA102まで選択して貼り付けます。(xの用意) B2に=SQRT(2)*EXP(-A2*A2/2)と書きます。そしてB2のセルの右下でカーソルが+になったところをダブルクリックします。(f(x)の計算) C2に=4*EXP(-A2*A2)と書きます。そしてC2のセルの右下でカーソルが+になったところをダブルクリックします。(g(x)の計算) A1からC102までを選択してExcel画面の上の挿入＞散布図＞散布図(平滑線)でも選びましょう。 いい感じでグラフができます。
もう一つを見て、とは？ せめてこの質問の回答に対してはどうなのか、を書いて下さい。 新たな回答はURLを載せて下さい。 ちょっとマナーがないのでは、と思います。
>>こんなにむずかしいのですか 例えば、直接的に3と言う数字で計算したいなら =SQRT(3)*EXP((-3)^2/2) 10なら：　=SQRT(10)*EXP((-10)^2/2)
あくまでもアップされている表を元にしての方法ですと、No2の方の方法かNo4の方の方法が簡単です。 もう少し知ったかぶりをして余計に式を長くすると セルC2に　=IF(MIN(A2:B2)<A2,"○","")　の式を入れてオートフィルコピーとかｗｗ 式は短ければ短いほどPCのCPUやメモリーに負担をかけませんので、できるだけ短いほうがいいです。 VBAで処理をする場合の方法 「Alt」キー+ファンクションキーの「F11」を押してVBAを起動 「挿入」タブより「標準モジュール」をクリックして入力画面に以下のプログラムを組みます。 ーー↓－－－－－－ここから下のプログラムーーーー↓ーーーーーーー Sub 条件() Dim i As Long For i = 2 To Cells(Rows.Count, 1).End(xlUp).Row If Cells(i, 1) > Cells(i, 2) Then Cells(i, 3) = "○" Else Cells(i, 3) = "" End If Next End Sub ーーここまでーーーーーーーーーーーーーーーーーーーーーーーーーー Sub 条件()～End Subまでのプログラムをコピーするか入力。 VBAの画面からexcel画面へそのまま戻り、excel画面より 「表示」タブの一番右側の「マクロ」をクリック マクロ名「条件」が選択されていることを確認後「実行」をクリックすると プログラムが実行され自動処理されます。
想像で回答してます。違ってたら読み捨てて下さい。 選択したシェイプを一旦、オブジェクト変数に代入した後、適当なセルを選択することによりシェイプの選択を解除します。その後、シェイプを移動させます。 ActiveSheet.Shapes.Range("Picture 1").Select Set sh = Selection Range("A1").Select For i = 1 To 50 sh.Left = i DoEvents Next
無料な復元ソフトでなくなったデータを検出できるかどうかを確認しましょうか。 http://jp.easeus.com/data-recovery-software/drw- …
以下ではいかがでしょうか？ もちろん「C:\Users\○\」は環境に合わせて変更してください。 ---------------------------------------------------------------------------------------- Sub Macro1() Sheets(Array("全員", "対象者")).Copy Application.DisplayAlerts = False ActiveWorkbook.SaveAs _ Filename:="C:\Users\○\" & Sheets("全員").Cells(1, 1).Text & ".xlsx", _ FileFormat:=xlOpenXMLWorkbook, _ CreateBackup:=False Application.DisplayAlerts = True ActiveWindow.Close Application.Quit End Sub ---------------------------------------------------------------------------------------- ※ 同じファイル名が有った場合はメッセージを出さず上書きします。
No.2　ママチャリです。 マクロで行いたいのであれば、こんな感じです。 次のマクロは、Sheet1をコピーして新しいシートを作り、さらに、A~C列をキーとして重複を削除します。 Sub Macro1() Sheets("Sheet1").Copy After:=Worksheets(Worksheets.Count) ActiveSheet.Range("A:C").RemoveDuplicates Columns:=Array(1, 2, 3), Header:=xlYes End Sub
ドライバは関係ないのですが、2003で作成したブックは2010で必ず開き編集することが出来ます。 逆はセルの数や許容されている書式の数などが原因で開くことが出来ない場合があります。 互換機能パックで開くことができるのは、許容されている範囲内で作成された2007~バージョンの保存ファイルだけです。特に書式が4000を超えたファイルは使用しているセルの範囲がどんなにせまくても開くことはできません。
現在使っている画像１､２のユーザインターフェースですが、画面が小さい以外に、特にクレームは無いのですか？もし私が利用者なら、いくつか注文を付けたいところですが･･･。 とりあえず、ご要望通りのコードを書いてみました。処理概要は以下の通りです。 ①アクティブセルのある行のC列に名前を設定する ➁上記①で設定した名前をメッセージボックスで表示する ③上記②でOKが押下された場合、同D列に日付を設定する Private Sub CommandButton2_Click() With ActiveCell.EntireRow .Columns("C") = "田中" If MsgBox(.Columns("C"), vbOKCancel) = vbOK Then .Columns("D") = Format(Date, "mm/dd") End If End With End Sub
回答がつきにくいようです。　イイ方法は私は知りません。 私は、グラフにしても、他のことにしても、エクセルでなにかを実現したい場合には、自分の知っている機能でなんとか希望に近い形のものを作成できるには、｢シートやセル(行や列)、データの値にどうデータが入っているといいんだろうか？｣と考え、それに適合するようにデータを換算加工したり、配置を変更したりします。 質問をそのまま読むと、(個人別(月別(実績：目標)))とX軸(項目軸)に【全部を棒グラフにして】並べるような感じですが、それが本当に良いのか、私には疑問に思えます。 質問ではABCの3人のグラフですが、それで終わりですか。5人、10人の場合はないですか。4,5,6月の三ヶ月で終わりですか。５ヶ月、６ヶ月にすることはないですか。 ｛各月の(目標と実績)を(目標)点付き折れ線と(実績)棒で表したものを、(月別(横軸))推移グラフとしても見えるグラフ｝を各人毎に、５人なら５個グラフを作る方が、簡単で、汎用性もあるのではないですか。 一つのグラフの中に、（各月の実績と目標の棒グラフを３ヶ月分）を個人別にABCの３人分描くだけであれば、グラフにするデータの並べ方を工夫すれば一応可能だと思います。（添付の画像参照） また、通常（Ｙ軸に量的スケール、Ｘ軸に項目を並べる）ことが多いです。（棒グラフの場合X軸は時間軸とは限らない。Ｘ軸に、Aの4月の実績、Aの4月の目標、Aの5月の実績、Aの5月の目標、、、、、Bの4月の実績、Bの4月の目標、Bの5月の実績、Bの5月の目標、、、、、Eの4月の実績、Eの4月の目標、Eの5月の実績、Eの5月の目標、、、、、と並べれば、n人のmヶ月分の(実績,目標)を並べることも簡単です）　それを念頭にして、グラフ作成用元データのテーブルを作り値を入れておけば、結構簡単です。　AさんとＢさんのデータが入る切れ目に空白の列(行)を配置してからグラフにすれば、できあがったグラフも少しは見やすくなります。Ｘ軸の項目名の下にテキストボックスを置き、個人名を書けば、それで、グラフをみた人には、よくわかります。 全自動で作成させるよりも、追加加工で仕上げる方が簡単です。 グラフのX軸の項目名にどう表示させるのが良いかを考えて、グラフ用の項目名を入れておけば、さらにいいかもしれません。
こんな感じでしょうか。 シートAの1行目について”CBA”を検索します。見つかったセルのひとつ下のセルから最終行までをシートBのA1セルへコピーします。 Sub sample() Dim r As Range With Sheets("A") Set r = .Rows(1).Find("CBA", LookIn:=xlValues, LookAt:=xlWhole) If Not r Is Nothing Then Range(r.Offset(1), .Cells(Rows.Count, r.Column).End(xlUp)).Copy _ Destination:=Sheets("B").Range("A1") End If End With End Sub
> その列は例えば"大阪府"@と定義して ……最初からそう書いて欲しい。 データの範囲をコピーして 一度メモ帳などに貼りつけ それを再度コピーして Excelに貼り直せばいいと思います。
=MAX(IF(A$4:A$10=I4,E$4:E$10)) Ctrl + Shift + Enterで確定 配列数式になります。それか J4に「=DMAX(A3:E10,5,I3:I4)」と入力 I4:J8を選択した状態で [データ]→[What-If 分析]→[データ テーブル] [列の代入セル]を「I4」にして[OK] でも。後 一回こっきりなら 集計機能が一番早いです。
Excel2007以降なら、[ルールのクリア]で可能だと思います。 [ホーム]タブの[スタイル]グループで[条件付き書式]→[ルールのクリア] から選択し[選択したセルからルールをクリア]を選択します。 http://www.ne.jp/asahi/juku/excel/Jouken03.htm http://www.eurus.dti.ne.jp/~yoneyama/Excel2007/e … これで選択したセルのみ条件付き書式がクリアされます。
以下でどうなりますか 使っている領域全部の数値（数字）を対象に･･･ Public Sub Samp1() 　　Dim vA As Variant 　　Dim i As Long, j As Long 　　Application.ScreenUpdating = False 　　Application.Calculation = xlCalculationManual 　　With ActiveSheet.UsedRange 　　　　For j = 1 To .Columns.Count 　　　　　　With .Columns(j) 　　　　　　　　vA = .Formula 　　　　　　　　For i = 1 To UBound(vA) 　　　　　　　　　　If ((Left(vA(i, 1), 1) <> "=") _ 　　　　　　　　　　　　And (IsNumeric(vA(i, 1)))) Then 　　　　　　　　　　　　vA(i, 1) = "=234*" & vA(i, 1) 　　　　　　　　　　End If 　　　　　　　　Next 　　　　　　　　.Formula = vA 　　　　　　End With 　　　　Next 　　End With 　　Application.Calculation = xlCalculationAutomatic 　　Application.ScreenUpdating = True End Sub
１．Sheet2 の範囲 A1:E6 に naokei という[名前]を付ける。 ２．Sheet1 のセル B1 に次式を入力して、此れを下方にズズーッとオートフィル ＿＿ =MAX(INDEX(naoke,MATCH(A1,INDEX(naoke,,1),0),)) 【お断り】ステップ１において、添付図では naokei でなく range の場合を示していますが、もし、数式バー内の記述が読み取れなければ、この「お断り」は無視してください。
回答ではありませんが。 難題なのではなく、質問の範囲が広すぎるので回答が出ないと思います。 これは小さいシステム一つを作って下さい、というのと同じです。 図が見えれば、まだわかる部分だけでも回答しようかと思いますが、残念ながら小さくて見えません。 急ぎなら外注するか、質問サイトで解決していきたいなら、質問は一つずつにするべきかと思います。その部分の図を見えように拡大して添付する事も必要です。
Windows7でファイル履歴がオンになっているなら復元できます。 また、Excelは上書き保存でも実質の保存はもとのファイルとは別の場所に行い、保存が完了したと認識できたときに元のファイルを削除する仕組みで保存していますので、「データリカバリー」や「ファイナルデータ」などの復元ツールで復元することが期待できます。 http://freesoft-100.com/pasokon/recovery.html
Sheet2 において、 １．セル A2 に次式を入力して、此れを右２列にオートフィル ＿＿ =IFERROR(INDEX(Sheet1!A$1:A$1000,SMALL(IF(INT(Sheet1!$C$2:$C$1000/10)=3,ROW($A$2:$A$1000),""),ROW(A1))),"") ２．範囲 A2:C2 を下方にズズーッとオートフィル 【お断り】上式は配列数式として入力のこと
マクロでやってみてはいかがですか Dim i as integer For i=1 to 42 Cells(1,i). Cut Cells(i,1) Next こんな感じです
> 今は7のセルの７月というのを８月に1つ1つ直してます。 範囲を選択して 置換機能で「7月」を「8月」に[すべて置換]すれば いいと思います。
=B1-INDEX(A:A,(ROW(B1)+9)/10)
>2行目の場合はE2のみ同じなので、D2+E2です。 A-10-aも左から3文字同じです。 よって、文章を基本にして数式を書くと =SUMIF(A:A,D1,B:B)+SUM(SUMIF(A:A,IF(LEFT(D1,3)=LEFT(E1:G1,3),E1:G1),B:B)) [Ctrl]+[Shift]+[Enter]配列数式、{}で囲まれる。 配列を大きくしてもいいなら =SUM(SUMIF(A:A,IF(LEFT(D1,3)=LEFT(D1:G1,3),D1:G1),B:B)) 添付図のようにしたいなら4文字比較して =SUM(SUMIF(A:A,IF(LEFT(D1,4)=LEFT(D1:G1,4),D1:G1),B:B)) 上記理解できないと思うので、計算用の表を作って対処するのが良いと思います。
No.2 の修正です。 「=44000+280」です「,」は入れてはいけません。 セルの表示は計算結果になりますが、セルを選択したときの数式バーにはチャント計算式が表示されます。
昔からのＴＡＮＡＫＡさんですが、お世話になっています。 http://officetanaka.net/excel/function/tips/tips … これって便利なので、私は便利に使ってます。
折れ線グラフを描くだけならば、各系列ごとにグラフ描点用の換算値を計算して、それを描くという手法もあります。 適当に自分で何かの手を加えたらば………　という発想ならば、軸はXとYの二次元でも、Ｙ軸のスケールを様々にしたのは作れます。 極端な話が、Ｙ軸に、等間隔スケールと対数スケールを併存させるのでもできます。
「〇/16～翌月○/15〆」となるレイアウト考えてみました。 月がわかりやすいように、A6とA22セルだけは月を入れた書式「m"月"d"日（"aaa"） "」その他は「"d"日（"aaa"） "」にしてみました。ここにあるように「原紙」というシートを作りそれをコピーして各人のシートを作ることによってレイアウトの統一化を図るのが良いかと思います。これによって原紙シートのデザインを変えることで統一されたデザインで簡単に変更出来るようになります。 以下はこんな形にしたら良いのではというイメージです。 「変換」シートは「個人ＩＤ」「氏名」「シート名」の関連の一覧表 「作業」シートは「ＣＳＶファイル」を取り込んで加工に使います 「データ」シートは過去数か月分のデータを蓄積していきます。 最終的には「○○○○年○○月度.xslx」という、各人のシートをまとめたブックを同じフォルダーに作成しようと考えています。（このブックはマクロを含みません）
No.1　fujillinさんの指摘にもある通り、ワークシートの計算機能を使うのが一番効率的と思います。 そこで、ワークシートで計算した結果をテキストボックスに転記するというのはいかがでしょうか？ プログラムコードのコーディング量は、かなり減ると思います。ただ、TextBoxのプロパティ設定がちょっと面倒ですが…。また、変則的な考え方になりますので、お気に召さなければ読み捨てて下さい。 具体的には、まず、計算用シートを用意します。A列（数量）、B列（単価）、C列(合計）×30行。31行目のC列は総合計とし、それぞれ計算式を設定します。 次に、TextBox（数量と単価）のControlSourceプロパティで、計算用シート上の各セルにリンクを張ります。 ここで、C列の合計にはリンクを張ってはいけません。合計については、計算用シートのWorksheet_Calculateイベントで、TextBox（合計と総合計）へ転記するようにコーディングします。 具体的には、こんな感じです。 Private Sub Worksheet_Calculate() Dim i As Long For i = 1 To 30 UserForm1.Controls("Textbox" & i * 3).Text = Sheets("Sheet1").Cells(i, "C").Value Next UserForm1.Controls("Textbox" & (i - 1) * 3 + 1).Text = Sheets("Sheet1").Cells(i, "C").Value End Sub
キーボードの抜差し キーボードに水分の混入疑い ワードなど他のソフトでも似た症状があるか確認。 エクセルのソフトを復元してみる。
２桁の正の整数と決まっているなら =MOD(A1,10)*10+INT(A1/10)
="='"&A1&"'!K47*24" こういう式で文字列の数式をまず作ってそれをコピー コピーした範囲上で 値貼りつけ データの区切り位置を空で実行して 文字列を数式に変換 でいいでしょう。
こんにちは ご質問は、日付のデータ『16-07-06』をシリアル値として認識させたいということかと思いますが、エクセルは『16-07-06』のような形式でも日付と判断してはくれるようです。 （それを利用して、値を変更後に各セルをクリックなさっているのだとは思いますが） ご提示のCSVデータ（？）にカンマがないため区切り位置がどこなのかわかりませんので、スペースが区切りになっているものと解釈しましたが、ご提示の式をよく見てみると、どうやら『16-07-06 14:55:51s』で一つのデータになっているのでしょうか？ タイトル部の[℃]が4つしかないのに、データらしきものが7つあるのは単純な間違いと推測しました。 ＞1つづつクリックはマクロでやるにしても煩雑ですので～～ クリックする作業に比べれば煩雑ではないような気がしますが、『こんなことにいちいちマクロを走らせるのが（心理的に）煩雑』というのならわからないでもありません。 利用なさりたい形でデータが得られればよさそうですので、マクロで処理をするにしても『CSVファイルを指定すると、利用したい形でデータをシートに読み込む』というマクロにしておけば、煩雑感はないように思いますが…？ とはいえ、現状の手作業を少しは楽にできそうな方法を・・・ 以下は、Ａ列に『16-07-06 14:55:51s』のようなデータが入っているものと仮定しています。 　1）Ａ列を選択して 　2）検索（Ctr+F)ダイアログの全て置換で"s"→""に置換 置換処理を行うことで、セル内の値を日付として認識してくれると思いますが、いかがでしょうか？ （うまくいかない場合は、置換の前にＡ列の書式を日付などにしておいてから試してみてください）
皆さん凄いなあ。 この質問の文章から 11の次に12、1、2 ３の次に4、5、6 と３ヶ月続くことに気付くのに自分はしばらく時間がかかりましたよ。 ・・・ 本題。 月に相当する部分を増やせばよいだけですので、関数で簡単に作成できます。 １から12の繰り返しなので、 １を足した後、12で割った余りを求めればよい。 この場合、0から11の繰り返しになりますので 正確には、元の数から1を引いた値に増分の値を足したのちに12で割った余りに１を加えるというちょっと面倒なやり方になります。 A2セルに 　=MOD(A1-1+1,12)+1 B2セルに 　=MOD(A1-1+2,12)+1 C2セルに 　=MOD(A1-1+3,12)+1 すると、No.2で答えられているような数式に落ち着くんですね。
やっぱり無理やりな数式が出てきましたけど 何故 自分で計算できない 表を作っておいてから数式で悩まなければいけないのか疑問に思います。 少なくとも添付のような表にするだけでも I3:=MAX(($A$3:$A$11=$F3:$H3)*($B$3:$B$11=I$2)*$C$3:$C$11) Ctrl + Shift + Enterで確定 こうなります。INDEXを挟むかどうかはお任せしますが。 CoalTarさんみたいに１個ずつ足すにしても「最大値を合計する」という 計算以外は 本来無駄な処理です。
こんばんは！ すでに回答は出ていますので、参考程度で・・・ Sub Sample1() Dim i As Long, c As Range, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") For i = 1 To .Cells(Rows.Count, "A").End(xlUp).Row Set c = wS.Range("A:A").Find(what:=.Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then .Cells(i, "B").Resize(, 5).Value = c.Offset(, 1).Resize(, 5).Value End If Next i End With End Sub こんな感じでも大丈夫だと思います。m(_ _)m
２つのセルどちらかと同じ値の数を確認したいのであれば COUNTIF関数で、それぞれカウントすればよい。 　＝COUNTIF(範囲 , 条件） のようにして使うので、 　＝COUNTIF(A1:E1 , A2) + COUNTIF(A1:E1 , A3） など、それぞれの値でカウントしたものを足し算して求める。 （この数式は、A1セルからE1セルの範囲に、A2セルの値と等しいセルとA3セルの値と等しいセルの数を数えて足しています） なお。等しい値をカウントする場合は値を直接してすることができますが、基本は文字列で条件を与えます。
試行錯誤しながら、いろいろな条件付き書式を設定していると思いますが、その中で不要な設定が残ってしまってるだけでしょう。 一旦、すべての条件付き書式を削除して、再設定する事をお勧めします。もしくは、該当シートの条件付き書式をすべて表示して、不要なものを削除してみて下さい。もしかしたら、他の回答者さんのやり方でも上手くいくものがあるかもしれませんよ。
いえ、そう考えることが「そもそも間違い」です。 ただし、貴方が期待する目的での用法とは異なります。 例えば、此処の添付図において、 １．範囲 A1:B4 を選択 ２．[数式]→[定義された名前 <選択範囲から作成>]を実行 ３．“左端列”のみにチェックを残す ４．[OK]をツン を実行した後で、 何処かの空きセルに式 =VLOOKUP(りんご,A1:B4,2,FALSE) を入力してみてぇ。この式では確かに「検索値に文字列を入力」してますよね。 そして、その戻り値を見た貴方はびっくりするかも。
VBA を使用する場合は以下のコードを対象のシートモジュールに書き込んでください。 ------------------------------------------------------------------------------------- Private Sub Worksheet_Change(ByVal Target As Range) If Target.Column <> 5 Then Exit Sub If Target.Value = "" Then Exit Sub Rows(Target.Row).Interior.Color = RGB(192, 192, 192) End Sub ------------------------------------------------------------------------------------- もしも E列が空欄になったら解除したいのならば以下になります。 ------------------------------------------------------------------------------------- Private Sub Worksheet_Change(ByVal Target As Range) If Target.Column <> 5 Then Exit Sub If Target.Value = "" Then Rows(Target.Row).Interior.ColorIndex = xlNone Else Rows(Target.Row).Interior.Color = RGB(192, 192, 192) End If End Sub -------------------------------------------------------------------------------------
>何のデータ？という感じですが、わかりやすいようにと思って >例題を作りました。実際は何の関係もありません。 と書いてあります。数値などは適当でいいのですが、項目の種類はわかっていないと、適切な回答は出せないと思います。 この場合だと、B列のエリアは何種類あるのでしょうか？ それぞれの部屋での最大値を検索しなくてはならないので、この情報が必要です。 この例だと、洋室1、洋室2、和室1、・・・などですが、洋室3や和室2はないとしていいのでしょうか。
「Sheet1」から「Sheet30」が連続していて間に不用なシートが無ければ 「=SUM(Sheet1:Sheet30!K30)」これでいけると思います。
Vlookup から、Findメソッドという振り出しをさせると、私には良く分からなくなります。両者の類似点というものが、私にはあまりないと思うからです。 >vbaのfindメソッドで書式ごとコピーをすればいいというのはわかったのですが 理屈としては、まさにそのとおりには違いないのですが、Excelのメソッドにあるようでいて、ないのです。Pastespecial でいくつか試しにやってみるとうまく行きません。 (1) そこで、やはり丸ごとコピーということになります。 (途中から下線というようなスタイルの場合にはできないということです） 検索語に、マウスカーソルを置いて実行します。 (2)の方は、 最初に検索するセルにマウスカーソルを置いて、右隣に()で置き換わる文字を書いておきます。A1 が検索語なら、B1 が置換文字です。 y(o) u　または、y* // _ マクロを実行します。 現在のマクロはただの一回きりです。連続置換の場合は、コードを書き換えなくてはなりません。 '// ''(1) Sub SerchReplacement() Dim c As Range Dim FirstAddress As String Dim r As Range Set r = ActiveCell If r.Value = "" Then Exit Sub With Cells Set c = .Find(What:=r.Value, After:=r, LookIn:=xlValues, LookAt:=xlWhole, SearchOrder:=xlByRows, _ 　SearchDirection:=xlNext) 　　 If Not c Is Nothing Then 　　　　 r.Copy 　　　　 c.PasteSpecial (xlPasteAll) 　　　　 Application.CutCopyMode = False 　　 End If End With End Sub '// ''(2) Sub SerchReplacement2() Dim c As Range Dim Re As Object Dim FirstAddress As String Dim r As Range Dim replTxt As String Dim Matches Dim a As Variant Set Re = CreateObject("VBScript.RegExp") Re.Pattern = "(\(.*\))" Re.Global = False Set r = ActiveCell replTxt = ActiveCell.Offset(, 1).Value '括弧の中だけ If r.Value = "" Then Exit Sub With Worksheets("Sheet2").Cells Set c = .Find(What:=r.Value, After:=r, LookIn:=xlValues, LookAt:=xlWhole, SearchOrder:=xlByRows, _ 　SearchDirection:=xlNext) 　　 If Not c Is Nothing Then 　　　　Set Matches = Re.Execute(c.Value) 　　　　If Matches Is Nothing Then 　　　　　　 MsgBox "括弧が見つかりません。" 　　　　Else 　　　　　　a = c.Value 　　　　　　c.Value = Replace(c.Value, Matches(0).subMatches(0), replTxt, , 1, vbTextCompare) 　　　　　　 If a <> c.Value Then Beep 　　　　 End If 　　　　End If End With 　　Set Re = Nothing End Sub なお、Basp21というオブジェクトライブラリが入れてあれば、もっと簡単に置換が出来ます。
>=SUMIF(N:N,"間接経費（研究）",I:I) を切り取って(コピーじゃ×)目的のシートに貼り付けるだけでは？
tk0244さんが書いたマクロですが、Sheet2がアクティブの状態で実行すれば、正常に動きますよね？ もし、別のシートがアクティブの状態でも正しく動かしたいのであれば、次のように修正してみて下さい。 Sub Macro1() Sheets("Sheet2").PivotTables("ﾋﾟﾎﾞｯﾄﾃｰﾌﾞﾙ1").PivotCache.Refresh Sheets("Sheet2").PivotTables("ﾋﾟﾎﾞｯﾄﾃｰﾌﾞﾙ1").PivotFields("日付").PivotFilters.Add _ Type:=xlDateBetween, Value1:="2016/6/1", Value2:="2016/6/31" End Sub
Dim Cnt1 As Long Dim Cnt2 As Long Dim END1 As Long Dim Sh1 As Worksheet Set Sh1 = ActiveSheet END1 = Sh1.Range("A65536").End(xlUp).Row '全体行数取得 For Cnt1 = 1 To END1 For Cnt2 = 1 To Len(Sh1.Range("A" & Cnt1).Value) If (Mid(Sh1.Range("A" & Cnt1).Value, Cnt2, 1) Like "[A-z]") Then Sh1.Range("B" & Cnt1).Value = Sh1.Range("A" & Cnt1).Value GoTo N1 End If Next Cnt2 N1: Next Cnt1
No.1の回答者です。 MOD関数で除数を「８」にしたのに、「13」が表示されるのですか？ 余りが表示されるはずなので、除数よりも大きくなることはないと思う。 新規文書でA1セルの「780」の数値に対して、 =MOD(A1/60,8) にしたときには「5」が取得できると思います。 余りが除数よりも大きくなるのは何か別原因なのでは？ No.1の回答やNo.4さんの回答にある整数を取得する計算式で「0」が 表示される原因も別原因なのだと思いますが、U42セルにある式などを 提示できる範囲で記載してみてはどうでしょうか？ U42セルやU46・V46セルの表示形式なども記載すれば、回答者側でも 検証しやすくなると思います。 これまでの補足や質問内容だけだと、必ずしも希望していることが可能 なのかも、私などが提示した式だけでは判断できませんからね。
No.４です。 前回のコードはコピー＆ペーストにしていますので、若干の時間を要してしまいます。 前回のコードは消去し↓のコードに変更してみてください。 Sub Sample2() Dim cnt As Long Do cnt = cnt + 1 Worksheets("Sheet2").Cells(cnt, "A").Resize(, Range("LA1").Column - 1).Value = _ Worksheets("Sheet1").Range("B5:LA5").Value If cnt = 120 Then Exit Do Loop MsgBox "完了" End Sub
No.2 の補足 対象範囲などを設定しないと右クリックメニューが使えなくなるので使いにくくなると思います。 たとえば C列のみ対応させたいときには 「Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)」のすぐ後に 「If Target.Column <> 3 Then Exit Sub」 を入れたりします。 たとえば C2セルから E10セルまで対応させるなら 「Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)」のすぐ後に 「If Target.Column < 3 Then Exit Sub」 「If Target.Column > 5 Then Exit Sub」 「If Target.Row < 2 Then Exit Sub」 「If Target.Row > 10 Then Exit Sub」 の４行を入れたりします。
=AVERAGEIFS(C3:C33,B3:B33,"<>土") では、だめですか？
そのコード、 http://oshiete.goo.ne.jp/qa/9124524.html ですね。 項目行部分が7行もあるので、本質問（項目行は1行だけ）に合致するように >If LstRow > 7 Then 'データがあるならそのデータをコピーしてまとめシートへ >　　Set Rng = Range(Cells(8, 1), Cells(LstRow, 8)) も変える必要がありますね。
プリインストールされている MS Officeは、プリインストールされているPC 1台だけです。 Office のパッケージ品の場合は、デスクトップ1台ともう1台のノートかタブレットPC の2台で使用できます。
こんばんは！ すでに回答は出ていますので、参考程度で・・・ 4×4の表はA1～D4セルにあるとし、E列以降は使用していないものとします。 （作業用に一旦　A1:D4 セルをE列にコピー＆ペーストするため） Sub Sample1() Dim cnt As Long, c As Range Range("A1:D4").Copy Range("E1") For Each c In Range("A1:D4") cnt = cnt + 1 c = WorksheetFunction.Large(Range("E1").Resize(4, 4), cnt) Next c Range("E1").Resize(4, 4).Clear End Sub こんな感じではどうでしょうか？m(_ _)m
学校で出された宿題を掲示板で聞いてちゃダメっていうか、いくつかは、他人に聞いたことがバレてしまいます。回答者側は、そういう期待される解答を知らないからいろんな回答は出てきます。 >できれば簡単なプログラミングでお願いします。 といいながら、解答としては、バブルソート・アルゴリズムを使うということが前提となっているはずです。 教科書としてはこのあたりかしら。 『Excel環境におけるVisual Basicプログラミング 第3版』 http://amazon.jp/dp/4320123395 アルゴリズムとは何か、#2さんが書いているように、「解法の論理または手順」ということですが、それに加え、誰でも使って良い公開された手順で、効率性が高いものを指します。 ところで、VBAを学んでいる人たちにとっても、たぶん、ここらは研究課題だろうと思います。バブルソート一つで満足すれば、それはそれで何ら問題はないけれども、その他、いくつかあります。 今回は、他の方が出されていなかったもの2題 ・Framework のSortedList を使った方法。 ・2番めは、バブルソートの改良型、シェーカーソート(ShakerSsort) Excel大辞典 http://home.att.ne.jp/zeta/gen/excel/c04p41.htm 上記のような教科書を自由に使うレベルの人が現れたら、みんなお払い箱になってしまうかもしれませんね。 '// Sub Sample_SortedMethod1() 　Dim objSortedList As Object 　Set objSortedList = CreateObject("System.Collections.SortedList") 　Dim rng As Range, c 　Dim i As Long, j As Long 　Set rng = Range("A1:D4") 　For j = 0 To 1 　　　For Each c In rng 　　　　　If j = 0 Then 　　　　　　　objSortedList.Add c.Value, i 　　　　　Else 　　　　　　　c.Value = objSortedList.getKey(i) 　　　　　　　'c.Offset(, 4).Value =... 右隣のセルに出す場合 　　　　　End If 　　　　　i = i + 1 　　　Next c 　　　i = 0 　Next j End Sub '// Sub SampleShakerSort1() 　Dim a, i As Long, j As Long 　Dim rng As Range, c 　Dim t As Long, n As Long 　Dim l As Long, shift As Long 　Set rng = Range("A1:D4") 　n = rng.Cells.Count 　ReDim a(n - 1) 　i = 0 　For Each c In rng 　　　a(i) = c.Value 　　　i = i + 1 　Next c 　 　l = 0: j = n - 1 　Do While l < j 　　　For i = l To j - 1 　　　　　If a(i) > a(i + 1) Then 　　　　　　　t = a(i): a(i) = a(i + 1): a(i + 1) = t 　　　　　　　shift = i 　　　　　End If 　　　Next i 　　　j = shift 　　　For i = j To l + 1 Step -1 　　　　　If a(i) < a(i - 1) Then 　　　　　　　t = a(i): a(i) = a(i - 1): a(i - 1) = t 　　　　　　　shift = i 　　　　　End If 　　　Next i 　　　l = shift 　Loop 　i = 0 　For Each c In rng 　　　c.Value = a(i) 　　　i = i + 1 　Next c End Sub
セルの書式設定→文字列を選択→1/1と入力 ですかね。 もっと簡単な方法があるのかもしれないが、自分はこれしか知りません。
こんなのでもいいと思います。 =IF(ISNUMBER(A2),IF(ISNUMBER(B1),A2+B1,""),"")
＞シート1のDセルとシート2のDセル 同じ番号のみ抜き出したい ということは、シート１に作業列を利用して、 match関数や vlookup関数を使って、シート２のD列と比較すればいいのではないですか？ シート１のｄ２のデータが、シート２のD列に存在すれば、最初に合致したセル（上からのセルの数）を示したらいいのだとかんがえて 例えば F2に　=iferror(match(d2,シート２!d:d,0),"") ではいかがですか？
Excelって、面白いですよね。 「いろいろと勉強中」とのことなので、VBAでの実装もお楽しみください。 該当Sheetオブジェクトの下のWorksheet_Changeイベントプロシジャに、次のVBAを記述します。 さらに、F1セルの項目見出しを「商品名」→「商品」に修正します。 これで、F2セルの値を変更するたびに、抽出結果が表示されるようになります。 ただし、「パ」を含むものを検索する場合は、F2セルに「*パ*」と入力する必要があります。 詳しくは、Excel(VBA)のヘルプを「AdvancedFilter」で検索してみて下さい。 Private Sub Worksheet_Change(ByVal Target As Range) Range("A1:C8").AdvancedFilter Action:=xlFilterCopy, CriteriaRange:=Range( _ "F1:F2"), CopyToRange:=Range("H1:J1"), Unique:=False End Sub
出来ているものを、出来ないと言っても、これ以上仕方ないですね。 他の回答者さんも出来ないとおっしゃっている、不思議です。 その式が出来るという仮定で、論理的には =SUMPRODUCT((WEEKDAY(B2:C2-1,2)=5)*1) とすればいいだけのように思います。 こちらでは検証できない事をお断りしておきます。
>1回目のコードでバッチリです！ >どうしてこんなに安定しているのか不思議です。 思惑があたったというところですが、ファイルの種類がある程度決まっているなら大丈夫だと思います。 まあ、もしダメでも、解決方法はいくつか用意していますから、その時は、またお聞きになったらよいかと思いますが、分からなくなったら、コマンドプロンプト上で、試してみれば、だいたいのことはみえてくるはずです。
No.3 の説明です。 ① 今日の月初めの日付を算出します。 ② その曜日から第四土曜日の日付を算出します。 ③ その日付と今日の日付を比較して同じならばメッセージを表示します。
C列(C1)に以下を入れて、C2以下ヘコピペ =IF(SUMPRODUCT((CHAR(ROW($9249:$9331))=MID(A1,COLUMN(1:1),1))*1),"ひらがな有り","")
少し割り込み、お邪魔します。 target という変数名は、ちょっと引っかかるけれども、 >Dim target > >target = ThisWorkbook.Worksheets("処理用").ListBox1.Text target のデータ型がVariant であろうが、String 型であろうが、ListBox1 から正しく取れていれば、「型が一致しません」というようなエラーはでません。 このエラーは、Listbox のプロパティの設定の違いによって起きているような気がします。 ListBox のProperty の中の、MultiSelect 0-fmMultiSelectSingle は選んでありますか？ この田中さん、こういうことを書いていますが、 http://officetanaka.net/excel/vba/tips/tips141.htm 私なら、ListBox は以下のように設定しています。私は古い？ 以下は、そのままでは、MultiSelect は使えないけれども、すぐに変えられるようにしています。 '// Private Sub CommandButton1_Click() 'フォーム・コントロールでも可 Dim strTxt ' As String Dim i As Long For i = 0 To Me.ListBox1.ListCount 　 If Me.ListBox1.Selected(i) Then 　　　　　 strTxt = Me.ListBox1.List(i) 　　　　　 If strTxt <> "" Then 　　　　　　　 Exit For 　　　　　 End If 　 End If Next i With Workbooks(strTxt).Sheets(1) 　　.Range(.Cells(1, 1), .Cells(80, 2)).Copy End With Dim LastRow As Long With ThisWorkbook.Worksheets("処理用") 　　 LastRow = .Cells(Rows.Count, 1).End(xlUp).Row 　　If LastRow > 1 Then LastRow = LastRow + 1 　　.Cells(LastRow, 1).PasteSpecial (xlPasteValues) 　　''上書きモード(二者択一） 　　''.Range("A1").PasteSpecial (xlPasteValues) End With ' ''(以下略） Application.CutCopyMode = False End Sub '// こちらの指摘は、当たっていないかもしれません。 ただ、エラーが出た時、そこに「ブレークポイント●」を置いて、ローカルウィンドウで、その変数の値をみれば、ほぼ、100%問題はどこにあるか分かるはずです。ご自分で分からなくても、その入った値は、こんなのでした、だけでも分かるものなのです。 私は、配列が混じりこんだような気がします。
その2 正確に書き直し。 レコードが入っている、全ての行、列を範囲指定→リボンから挿入→ピボットテーブル→ピボットテーブルのフィールドリストから→行ラベルに日時をドロップ（左クリックボタン押しながら、行ラベルに持ってきて離す）→列ラベルに部屋タイプをドロップ→値（Σ）に部屋タイプをドロップで集計方法をカウントにする。
こんばんは！ EOMONTH関数は使わなくても対応できると思います。 A列の「年」がD7セルの「年」だけの場合は =SUMPRODUCT((MONTH(A8:A10)=MONTH(D7))*B8:B10) A列「年」がD7セルの「年」以外も存在するのであれば =SUMPRODUCT((YEAR(A8:A10)=YEAR(D7))*(MONTH(A8:A10)=MONTH(D7)),B8:B10) としてみてはどうでしょうか？m(_ _)m
ワイルドカードを使いましょう =IFERROR(VLOOKUP("*"&$A1&"*",$C:$D,COLUMN(A1),0),"")
提示条件が曖昧だから、もう一度最所から条件を良～く考えて、仕切り直した方が良いですよ。 例えば以下の様に整理する ①なにも記入していないときは、表示しない。 ②送り先が北海道や九州などの場合は納期中１日かかる。 ③その他の送り先は翌日到着 ④発送日が金曜日の場合は、場所に関わらず到着は翌月曜日 ⑤到着日が土日、祝日になる場合は、その後最初に来る平日が到着日
同じフォーマットなら複数シートを選択しながら実行できそうな気がします。 シフトキーを押しながら全てのシートを選択していってください。 その状態から、 ・オートフィルタをかけ直す ・"あ"をフィルタ こちらの手元で検証できないので、一度お試しください。
シート結合は考慮していますので問題はありません。 あくまでも推測ですが、シート名が違うのでは？ もし「Sheet1」が「入力シート」などに変更されているならば、他のシートも含め該当箇所を全て修正してください。
１．列Ａ、Ｂ、Ｃ、Ｇ、Ｈの１行目に、添付図に示したように項目名を入力 ２．セル C2 に式 =VLOOKUP(A2,E:F,2,0) を入力して、此れを下方に ＿＿ズズーッとオートフィル ３．セル D2 に式 =B2<>C2 を入力 ４．列範囲 A:C を選択 ５．下記の要領で[フィルタオプションの設定]を実行した結果を添付図に ＿＿示した。 ＿＿＿[抽出先]→“指定した範囲” ＿＿＿[リスト範囲]→ $A:$C ＿＿＿[検索条件範囲]→ $D$1:$D$2 ＿＿＿[抽出範囲]→ $G$1:$H$1
こんにちは どこまで一般化すれば良いのかご質問文からではわからないので、皆様いろいろ考えておられるようですが… とりあえずご質問文の文面通りに『列7つ移動した形でエクセル関数を使って表現したいのです』であれば、単純に 　=OFFSET(Sheet1!B4,0,7,1,1) とかでは、どうなのでしょうか？ （ANo2様がすでに回答なさっていらっしゃいますけれど…)
このようにファイ内の数多くのメニユーをタスクバーにピン留しますとタスクバーがオーバーフローしてウィンドウでで表示されるものも出ます。タスクバーにはアプリ又ファイルのみピン留して下さい。タスクバーは便利ですがオーバーフローさせるとストレスにになりますので一目で認識できる程度に。後はデスクトップショートカット作成をお勧め致します。並び順は左から登録順になりますが狂いが出ましたら左クリックしたまま左右に移動して整列して下さい。E1 E2 E3は[保存ファイル]内に格納して[Exsei]＋[保存ファイル]のみピン留して下さい。
Ｅｘｃｅｌ2010の場合ですけれど・・・ VBAエディタの画面で、 　「ツール」-「オプション」-「エディターの設定」で フォントの種類やサイズを指定できます。
式は長くなってしまいますが、作業列は不要です。 =IF(COUNTIFS(Sheet2!$A:$A,A1,Sheet2!$B:$B,B1,Sheet2!$C:$C,C1,Sheet2!$D:$D,D1)>0,"重複","該当なし")
こんにちは 通常のグラフではなく、文字キャラクタで積み上げた文字列を作成したいということですよね？ （通常のグラフ機能でやるのなら#1様の回答が妥当なので…） ご質問文に何もないので、必要な人数は関数等で算出することができているものと想像します。 算出された男子、女子の数をそれぞれ男、女と仮に表記するとして、グラフ（＝文字列）を表示したいセルに 　=REPT("○",男) & REPT("●",女) の式を入れておくことで、求める文字列が返されるようになります。 セルの書式を標準や左詰めなどにしておけば、ご提示のような表示になると思います。
「並び替える前後のゼータをもう少し多くのサンプルデータ(なるほど、と言わせるくらいの)」をお願いした筈ですが・・・ つまり添付図のようなモンですよ！ セル E1 に式 =IFERROR(VLOOKUP($A1,$C:$D,COLUMN(A1),0),"") を入力して、それを右のセルにオートフィルした後で、範囲 E1:F1 を下方にズズーッとこれまたオートフィル
私も、一言・二言・三言。 なぜ、アップロードを早めたかからですが、このまま頭の中だけに入れておくと忘れてしまうからです。 #5さんのご指摘のことは、一応は織り込み済みですが、 どこかでエラーが出たら、続きができるようにした方がよいでしょうね。 そのために、先にファイル名を取得しました。 途中で休むようにすればよいものですが、プロシージャ外にしても、エラートラップに引っかかれば、その記録は残せます。ただし、全体的なエラーを出せば、myArray の中身自体も飛んでしまいます。 　'// そのために、こんなところに切れ目を入れたのです。 本来は、 Sub CSVImportPro() 　Dim myArray ではなく、 Private myArray Sub CSVImportPro() です。 Dimの宣言の下あたりに、On Error Goto ErrHandler の一行を加えます。 当然、ルールの一番出し入れの大きい部分に、 DoEvents は入れておいたほうが安全です。 それとこの部分です。失敗したら、その次の番号を下記に入れます。 　For i = LBound(myArray) To UBound(myArray) 　　↓ 　For i = (リテラルな数字） To UBound(myArray) On Error GoTo　　ErrHandler Exit Sub ErrHandler: 　Debug.Pring i; myArray(i) End Sub としたら、良いかと考えています。
こんばんは！ やり方だけ・・・ ↓の画像のように別シート（今回はSheet2）に祝日・不定期休のデータを作成しておきます。 （画像では祝日だけにしていますが、A列に「不定期休」のようにタイトルをいれ、シリアル値をB列に羅列しておきます） そしてSheet1のA6の年・C6の月の数値を入れると1か月のシリアル値がB9～B39に表示されるようにします。 まず、前月の最終土曜日のシリアル値をF6セルに表示しておきます。 F6セルに =DATE(A6,C6,0)-WEEKDAY(DATE(A6,C6,0)-5,3) これで前月の最終土曜が表示されます。 B9セル（セルの表示形式はユーザー定義から　d　としておきます）に =IF(MONTH(DATE(A$6,C$6,ROW(A1)))=C$6,DATE(A$6,C$6,ROW(A1)),"") という数式を入れB39セルまでフィル＆コピー！ 最後にD9セルに =IF(B9="","",IF(COUNTIF(Sheet2!B:B,B9),INDEX(Sheet2!A:A,MATCH(B9,Sheet2!B:B,0)),IF(OR(B9=F$6+14,B9=F$6+28),"指定休日",TEXT(B9,"aaaa")))) という数式を入れD39セルまでフィル＆コピーすると 画像のような感じになります。 ※　「指定休日」とは第二・第四土曜日としています。m(_ _)m
こんばんは。 前回の続きを書かせていただきます。 確かに、前回のAutoFilter を使って、今回もAutoFilter を使っているので、それを残していれば使えるような気がしますが、アウトラインですと、私の知っている範囲ですと、そのマクロの方は、Excel2002の頃の古いスタイルでマクロを書かなくてはなりませんね。 前回のコードが使えません。 (その判別は、中身の計算式が、=SubTotal(100番台,範囲）になっています。） そうなってしまうと、今まで便利な方法が使えません。 >Range("A1").Select >Range(Selection, Selection.End(xlToRight)).Select >Range(Selection, Selection.End(xlDown)).Select これは、Range("A1").CurrentRegion のことでしょうから、 ↓ With Range("A1").CurrentRegion 　　With .Columns("P") 　　　　　　'.Rows.Count は、選択された範囲のP列のセルの数 　　　　 .Offset(1).Resize(.Rows.Count - 2).SpecialCells(xlCellTypeVisible).Copy 　　　　 .Offset(.Rows.Count + 1).Cells(1, 1).PasteSpecial (xlPasteValues) '影響を受けないように1行開けます。 　　　　 Application.CutCopyMode = False 　　 End With End With 貼り付ける時に、セル一つにしてあげないと、全部コピーしてしまいます。しかし、これは、書式はコピーされていませんので、もし必要なら、このような一行が必要です。 　.Offset(.Rows.Count + 1).Cells(1, 1).CurrentRegion.NumberFormat = "#,##0" ●　Application.CutCopyMode = False　の手前に↑のようなコードを入れます。
ユーザ定義関数でよろしければ、こんな感じです。 表示させたいセルに、=ufMaxAdd1(A:A)　と入力してみて下さい。 Function ufMaxAdd1(範囲 As Range) As Variant Dim r As Variant Dim m As Variant Dim n As Variant Dim l As Variant For Each r In Intersect(範囲, 範囲.Worksheet.UsedRange) If r.Text Like "##-??-###" Then n = Mid(r.Text, 1, 2) & Mid(r.Text, 7, 3) If n > m Then m = n l = Mid(r.Text, 3, 4) End If End If Next m = m + 1 ufMaxAdd1 = Mid(m, 1, 2) & l & Mid(m, 3, 3) End Function
それは改ページプレビューじゃないような気がします。 ブックを開き、Alt、W、Iの順にタイプすれば、Excel2007以降なら改ページプレビューが開くはずです。
ん～、希望に合っているのかわかりませんが シート　A店舗 会社コード・商品コード・商品名・価格・売上情報 A1000　　　E1000　　　鉛筆　　５０　100本 A1002　　　E1002　　　用紙　　　５　1000枚 A1003　　　E1000　　　鉛筆　　５０　200本 シート　B店舗 会社コード・商品コード・商品名・価格・売上情報 A1000　　　E1001　　　消しゴム100　　10本 A1002　　　E1002　　　用紙　　　５　1000枚 A1003　　　E1000　　　鉛筆　　５０　200本 集計結果 会社コード A100０ 　　　　A店舗　　　　　　　　　　　　　B店舗 商品コード・商品名・価格・売上情報・商品コード・商品名・価格・売上情報 E1000　　　鉛筆　　５０　100本　　　E1001　　　消しゴム100　　10本 こんな感じでしょうか？ フィルターオプションで条件に合った（指定した会社コード）のデータを抽出すると云う事？ フィルターオプションで検索してみてください、多数ヒットします。 VBAで自動化するのであれば、上記のシート構成として 集計結果のシート名のタブを右クリックして、コードの表示、VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$A$2" Then Sheets("A店舗").Columns("A:E").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("A1:A2"), CopyToRange:=Range("A4:D4"), Unique:=False Sheets("B店舗").Columns("A:E").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("A1:A2"), CopyToRange:=Range("E4:H4"), Unique:=False End If End Sub をコピーして閉じる。 A2セルの会社コードを変更すると、必要なデータ一覧になると思うのですが。
問題があるとすれば、 Range("C7").Activate これはちょっと、オートフィルタを壊すようなものですから、賛成できませんね。もっと下の方にするか、別のシートかどちらかです。 AutoFilter.Range というプロパティがあります。 これは、先頭のフィールド項目から、オートフィルタのデータのある所までの範囲です。だから、Office(1)で、フィールドの項目の行を除き、そして、下が、一行はみ出てしまったので、Resizeでフィルターレンジの行をひとつ引いてあげるわけです。 With Rng　　'オートフィルタ・レンジ .Columns(3).Offset(1).Resize(.Rows.Count - 1).Copy End With それがここの所です。これは、パターンさえ決まれば、初心者でも、上級者でも変わらないものなのです。 今回は、 Const STXT As String = "2"　　'クライテリア と書きましたが、シート上でも可能です。 '// Sub AutoFilterMacro() 　Dim Rng As Range 　Const STXT As String = "2"　　'クライテリア 　With ActiveSheet 　　If .AutoFilterMode = False Then 　　 .Range("A1").AutoFilter　　'オートフィルタモードにする 　　Else 　　 .AutoFilter.ShowAllData　　'一旦データを全部出す 　　End If 　　.Range("A1").AutoFilter Field:=2, Criteria1:="=" & STXT 　　Set Rng = .AutoFilter.Range 　　With Rng　　'オートフィルタ・レンジ 3列目のみ 　　 .Columns(3).Offset(1).Resize(.Rows.Count - 1).Copy 　　End With 　　.Range("C20").PasteSpecial (xlPasteValues)　　'値貼り付け 　End With 　Application.CutCopyMode = False　　'コピーモード解除 End Sub
機種ごとに値が入力される先が違うって言ってます？ もしそうだとしたら別のやり方にしたい。 ifを何個も重ねればできなくはないけどメンテが大変。 これ、スキルある人探してフォーマット作ってもらった方がいいですよ。 やりたいことは決して難しくないと思うんですが、ここからアドバイスだけでだと複雑で難しいです。 それがダメならクラウドワークスみたいとこで頼むとか。
F4 =IF(COUNTIF($AS$3:$AS$54,D4),"黒",IF(COUNTIF($AT$3:$AT$14,D4),"赤 ",IF(COUNTIF($AU$3:$AU$17,D4),"白",""))) 下へコピーしないのであれば $AS$3:$AS$54　などの＄は不要です。
>１．ある業務サイトからCSVデータをDLしてくる（ここに必要な商品名等の内容が含まれています）。 一番大事なのは、最初の問題でしょうね。ここで、きちんと扱えなかったものが、最後まで尾を引いていると思います。 とはいえ、もしマクロの話にするつもりなら、これだけの話では、どうにも形にはしにくいですね。 >ただ、（見やすさのためテキスト上ではなく）CSV上で編集する必要があり、 >それを上書きするとテキスト上でも指数形式で保存されてしまっているため、 >それを避ける方法があるかどうかを探していました。 それは、VBAを扱っている人なら、いくつかの方法を状況によって使い分けます。 具体的な内容があれば、またマクロも考えますが、ここで、先走って提示したところで、私の作ったものは、4つの内3つまでは、ここのカテゴリでは没になっているようで、簡単なものは誰でもできるものですから、こちらでは書かないでおきます。既存の処置だけですと、最後までは数字自体が変わらないまま維持はできないと思います。 ただ、今回は、記録マクロは辞めたほうがよいと思います。 CSVインポート・エクスポートは、あくまでもオーソドックスなスタイルで、行えばよいでしょう。テキストインポートをして、split で、コンマ(C)ごとに別けて、配列にして、ループしてセルに入れます。数値(V)か、文字(S)かの判定をしますが、15桁以上の場合は文字列にします。おそらくは列なのでしょうけれども。 ただし、私の考えているところは""は使いません。セル上に出てきてしまうからです。 文字列書式(')を使います。入出力、同じような方法にします。 書式文字列(@)もQueryTable ではうまくいきません。
Sub ボタンクリック() 'PowerShellを使って関連付けられたアプリケーションでファイルを開く Dim ターゲットパス As String ターゲットパス = Range("A1").Value Dim WSH As Object Set WSH = CreateObject("Wscript.Shell") WSH.Run Chr(34) & ターゲットパス & Chr(34), 1 '第2引数 WshWindowStyle は1が通常サイズ、2が最小化、3が最大化。好みでどうぞ」 Set WSH = Nothing End Sub
こんばんは！ すでに回答は色々出ていますが ＞シート1に同じ品名が2つあるとき・・・ 関数で1セルに複数データを表示するコトは難しいと思います。 とりあえず最初にヒットしたデータのみ表示する方法です。 Sheet2のB2セルに =IFERROR(VLOOKUP($A2,Sheet1!$A:$G,COLUMN(),0),"") という数式を入れ、 列・行方向にフィルハンドルでコピーしてみてください。m(_ _)m
条件表を作ってよいなら、データベース関数があります。
http://www4.synapse.ne.jp/yone/excel2010/excel20 … ユーザー設定のビューも検討してみては
No.5 ママチャリです。 すいません。表題にVBAと書かれているのを見落としました。最近、集中力を欠いています。m(_ _)m ちなみに、先の操作を「マクロの記録」したものを手直しすると、こんな感じになります。 Sub sample() Dim LastRow As Long Dim DelRng As Range LastRow = Cells(Rows.Count, "D").End(xlUp).Row Range("G2:G" & LastRow).Formula = "=SUMIFS(C:C,A:A,D2,B:B,E2)" Range("A1:G" & LastRow).AutoFilter Field:=7, Criteria1:="0" On Error Resume Next Set DelRng = Range("D2:G" & LastRow).SpecialCells(xlCellTypeVisible) ActiveSheet.AutoFilterMode = False DelRng.Delete Shift:=xlUp End Sub
No.8の補足です。作業列の挿入が難しいようですが、同じシートでの挿入が難しい場合は、 下記のC列の部分だけを別シートに切り出してしまいましょう。 で、見た目が悪いと思うので、そのシートを非表示にしてしまえば良いかと思います。 がんばってくださいね☆
文字列のデータのみなら =LOOKUP("ーー",Sheet1!H11:H30)
いまいち理解できないのですが。 どうして左側からデータを持ってこなければならないのですか？ ６月と入力すれば、6月の日付が、7月と入力すれば7月の日付が表示されればいいのですよね？
こんな感じではいかがですか？ ----------------------------------------------------- Private Sub TextBox1_Change() If IsNumeric(TextBox1.Value) Then If IsNumeric(TextBox2.Value) Then TextBox3.Value = TextBox1.Value * TextBox2.Value End If End If End Sub ----------------------------------------------------- ちなみになぜエラーになったかと言うと、Change イベントは１文字づつイベントが発生してしまうため「-」だけでもイベントが発生してしまい「-」では計算が出来ないためです。またなぜ最初に「-」の方はエラーにならなかったかと言うとテキストボックス2が空欄だったため計算されなかったためです。
>次のような簡単なコードでやってみようと思っています。 > >Private Sub CommandButton1_Click() >Sheets("sheets1").Range("h88").Select ‘sheets1でセルh88に移動 >End Sub うーん、困ってしまいますね。 まさか、難易度がかなり高いものをお求めなのでしょうか。私たちが、ここで書いたレベルというのは、中身の意味はともかくとして、入門3日ぐらいです。それを否定した、先には進めないようにも思うのですが、それとも、違うのでしょうか。 #1さんに書いた方法は、誰でも一度はで通ってきた道です。 ''シートモジュール Private Sub Worksheet_Change(ByVal Target As Range) 　　Select Case Target.Address(0, 0) 　　　　Case "A1": Range("B1").Select 　　　　Case "B1": Range("C1").Select 　　　　Case "C1": Range("D1").Select 　　　　Case "D1": Range("A1").Select 　　　　Case Else: Range("A1").Select End Select End Sub シートの下部のタブを右クリックして「コードの表示」で、上記のコードを貼り付ける、これだけのことなのですが。 それとも、 CommandButton1_Click() これを使って、思ったようにしてみたいと言うのでしょうか。 不可能とは思わないけれども、私には、まだ分かりません。 つまり、キーイベントかキーステータスを、その都度取って、命令に置き換えようとするものでしょう。ただ、VBAの範疇を越えてしまうでしょう。
２行目に入力されているとして =SUM(COUNTIF(A2:AE2,{"○","▽","△","□"})*{1,1,0.5,0.5}) 参考まで
G1を =IF(COUNT(A1:B1)<2,"",(MAX(0,MIN(B1,"22:00")-A1)+MAX(0,B1-"29:00"))*24-C1-F1) にすればいいように思います。
私からの結論を申し上げておきます。 [2015-07-06]というファイルが残っていましたので、その作った時の原本の記録から見て思い出してはいるのですが、もともと、このマクロ自体が、対話型で手動で行うような設計なのでした。ですから、本来、その趣旨を変えるということにもなるかと思いますが、作者の私としては、なんとも申し上げられません。 この開発の時に、その手の問題は浮かんだことは間違いないのですが、Excel2003時代とは違って、その手立てが見つからなかったことも事実ですし、これ以上、コードを複雑にしするつもりもありませんでした。 ある意味では、SendKeys は苦肉の策です。 #1さんの回答でよろしければ、私としては、私のあずかり知らないものとして、そのままスルーさせていただきたく思います。 今後、それが、Sendkey を、[名前の管理(Name Manager)」のハンドルを取ってSendMessageやPostMessageで仮想キーを送るようにしたところで、元の趣旨そのものは変わらないと思います。できる出来ないは別として、対話型ダイアログを閉じる手段は、いくつか知られていますが、対話型そのものを否定することになるのだろうと思います。 この件については、 >If n.RefersToRange.Parent.Name = "ｘｘｘｘ" Then の所で、突然終了してしまっていました。№１の回答の２）の時もそのようになっていました。 一旦、終了してしまったマクロを、途中からつなぎ合わせる方法がないわけではありませんが、仮にできても、すでに、私が書く話などは不要なのかと存じます。 いずれ、こうした流れの中で、マクロで全面的に書き換える人は、出てくるでしょうし、その時は、私も新たな気持ちで向き合うことにはするつもりです。 ただ、今のところ、Excel自身にバグが存在しなければ済むという根本的な問題以外は、技術の違いこそあれ、どれも大差がないのではないか、と思っています。 もともと、イレギュラーな問題に対して、それを辛うじて、面倒な作業をマクロで行う以上に、私としては、それを更に便利なものにするつもりはなかったわけです。言い訳めいているように思えますが、1年前と、それほどに考え方は変わっているわけではありません。 あまり、意味のある書き込みではありませんでした。
No.1です。 投稿後気づいたのですが・・・ ＞項目が非常に多いため とは元データの列数はもっとある！というコトでしょうか？ 前回のコードはA～C列までしか対応していませんでしたので、 ↓のコードに変更してみてください。 Sub Sample2() 'この行から// Dim i As Long, lastCol As Long, wS As Worksheet Set wS = Worksheets("Sheet2") Application.ScreenUpdating = False wS.Range("A:B").ClearContents With Worksheets("Sheet1") lastCol = .Cells(1, Columns.Count).End(xlToLeft).Column For i = 2 To .Cells(Rows.Count, "A").End(xlUp).Row .Range("A1").Resize(, lastCol).Copy wS.Cells(Rows.Count, "A").End(xlUp).Offset(2).PasteSpecial Paste:=xlPasteValues, Transpose:=True .Cells(i, "A").Resize(, lastCol).Copy wS.Cells(Rows.Count, "B").End(xlUp).Offset(2).PasteSpecial Paste:=xlPasteValues, Transpose:=True Next i End With wS.Range("A1:A2").EntireRow.Delete wS.Columns.AutoFit wS.Activate wS.Range("A1").Select Application.ScreenUpdating = True End Sub 'この行まで// ※　元データに空白セルはない！という前提です。m(_ _)m
http://oshiete.goo.ne.jp/qa/9124524.html とか https://www.moug.net/tech/exvba/0040062.html とかでできますね
こういうことでしょうか？ If TypeName(Selection) = "Range" Then 　Cells(340, Selection.Column).Select Else 　Cells(340, ActiveCell.Column).Select End If これは、基本技ですが、教えもらわないと、テキストにはたぶん出てこないと思います。 p.s. ActiveCell、というものは、そのオブジェクト　(Worksheet,Workbook,Application）に存在しています。Applicationは、事実上一つしか実体はありませんが、WorksheetもWorkbookも複数ありますから、複数のActiveCellが存在することになります。
No.6です。 まだ解決していませんでしたか。 四捨五入ではなく切り捨てにしたいのであれば、 =TEXT(A1-"00:00:00.5","hh:mm:ss")*1 のように、丸めたい下の桁から5引いてから四捨五入されるようにするとよい。 TEXT関数で、数値に対して書式を指定して表示させ、１を掛けることで数値（シリアル値）に戻しています。 数式を入力したセルの表示形式をユーザー書式で　"h:mm:ss" または "hh:mm:ss"　にしてください。
これでできます。 =VLOOKUP(A2,INDIRECT("'"&B2&"'!A:B"),2,0)
セルの行や列の番号を値として使う関数がある。 ・COLUMN関数は列を ・ROW関数は行を それぞれ値として返す。 ＝COLUMN(A1) とB2セルに入力して、D3セルまでコピーすると 　B2セル　＝COLUMN(A1) 　B3セル　＝COLUMN(A2) 　C2セル　＝COLUMN(B1) 　C3セル　＝COLUMN(B2) 　D2セル　＝COLUMN(C1) 　D3セル　＝COLUMN(C2) と数式中の参照セルが変わり、返ってくる値は 　B2セル　＝COLUMN(A1)　→１ 　B3セル　＝COLUMN(A2)　→１ 　C2セル　＝COLUMN(B1)　→２ 　C3セル　＝COLUMN(B2)　→２ 　D2セル　＝COLUMN(C1)　→３ 　D3セル　＝COLUMN(C2)　→３ となる。 同様にROW関数でも 　B2セル　=ROW(A1)　→1 　B3セル　=ROW(A2)　→2 　B4セル　=ROW(A3)　→3 　C2セル　=ROW(B1)　→1 　C3セル　=ROW(B2)　→2 　C4セル　=ROW(B3)　→3 となる。 応用として、これにMOD関数やINT関数を組み合わせるという手法もある。 　＝MOD(ROW(A100),３) とすると、100を3で割った余りを値として得られる。 0、1、2の値を繰り返して使いたいときに便利に利用できる。 ※＝MOD(ROW(A100),3)+1 とすると、1,2,3の値を繰り返し…。 　＝INT(ROW(A100)/3) ならば、100を3で割った商が値として得られる。 ３つ同じ値を繰り返し、１つ増やしたものをまた３つ繰り返す…という使い方になる。 0,0,1,1,1,2,2,2,3,3,3,…のような値を得られる ※＝INT((ROW(A100)+2)/3) とすると、1,1,1,2,2,2,3,3,3,… これらを工夫してみてください。 面倒ですが、意外と簡単にできたりします。
こんにちは。 マクロで、ショートカットの設定まで含めたコードを作ってみました。 このマクロは、正規表現で、No1の部分を探して、最大文字数を調べて、空白を入れるという仕組みになっています。 　.Pattern = "^(No\.*\d+)\b" 　 >現在自分で全角、半角のスペースを入れてそろえていますが、Tabキーのような形で簡単にそろえることは出来ないでしょうか 大きな問題は、MS P ゴシックと、プロポーショナルになっている所を変更しています。空白の場所は避けて通ります。 ★の部分を書き換えると、上書きモードになります。 使い方は、 範囲をマウスで選択して、Ctrl + Tab で、書き換わります。 その時、MS ゴシック(等幅フォント）に変わります。 '//標準モジュール Sub Auto_Open() 'ブックを開いた時に設定させる 　　Call SettingShortcutKey End Sub Sub SettingShortcutKey() 　　'ショートカットの設定 　　Application.OnKey "^{TAB}", "AlignmentPr" End Sub Sub AlignmentPr() 　Dim objRe As Object 　Dim nos() As Variant 　Dim i As Long, j As Long, Maxlen As Long 　Dim rng As Range, c As Variant 　Set objRe = CreateObject("VBScript.RegExp") 　If TypeName(Selection) = "Range" Then 　　Set rng = Selection 　　If rng.Columns.Count > 1 Then 　　 MsgBox "1列の選択に限ります。", vbExclamation 　　 Exit Sub 　　End If 　Else 　　MsgBox "範囲を指定してください。", vbExclamation: Exit Sub 　End If 　With objRe 　　.Pattern = "^(No\.*\d+)\b" 　　.Global = False: .IgnoreCase = True 　　For Each c In rng 　　ReDim Preserve nos(i) 　　 If .Test(c.Value) Then 　　　　nos(i) = .Execute(c)(0).SubMatches(0) 　　　　If Maxlen < Len(nos(i)) Then Maxlen = Len(nos(i)) 　　 End If 　　 i = i + 1 　　Next c 　End With 　Dim no As String 　Set objRe = Nothing 　j = Maxlen 　i = 0 　For Each c In rng 　　no = StrConv(Format$(nos(i), String(j, "@") & "!"), vbNarrow) 　　If c.Value <> "" And Trim(no) <> "" Then 　　 With c.Offset(0, 1) '★上書きの場合は、c.Offset(0,0)　にする 　　　　.Font.Name = "MS ゴシック" 　　　　.Value = Replace(c.Value, nos(i), no, 1, 1, vbBinaryCompare) 　　 End With 　　End If 　　i = i + 1 　Next c End Sub
参考になったようで、こちらとしても嬉しいのですが･･･。 「複数*** Error ***」については、質問内容がアバウトすぎます。想像すらできないので、アドバイスのしようがありません。ごめんなさい。 ListBoxについては、ユーザフォームを作成すれば可能です。ただ、この辺の説明を最初からするとなると、かなりの労力が必要です（実装自体は簡単ですが、プロパティの設定やイベントプロシジャ等、複数のコーティングに対する説明が必要になるため） とりあえず、ご自身で挑戦してもらって、分からないことがあれば、別途、ご質問されることをお勧めします。
No.1です。 コメントありがとうございました。 知っているというのが、登録の方法はわかる、マクロの記録は経験がある、コードを見れば何とかわかるレベルであるなら、サンプルを作成致します。 そうでないと作成しても無駄になってしまいますので。
再計算方法の設定は確認した？ 試しに『A1の値が反映されたのですがそれがうまく動かなくなりました。』 のタイミングでF9押してみましょう F9で結果が反映されているなら再計算設定が自動では無くなっている
いわゆる「Excel方眼紙」だね セルの枠線を方眼紙のマス目に見立てて使う 微妙なレイアウトの設定も簡単 WORDで意図しないレイアウトの揺れ乱れに悩まされた経験がある人は 全部自分でコントロールしたいという事でExcel方眼紙を使う場合が多い 慣れると全然不便じゃないのが不思議 但し、表としてデータ参照するような場合には向いていない　＜－数式がややこしくなるから WORDで文章を作成する代わりにEXCELで文章や表などを織り交ぜたドキュメント作成するようなケースに重宝する
TIMEVALUE関数を使ってみては。 　=TIMEVALUE(SUBSTITUTE(A1,"'",":")) 表示形式を「mm:ss.00」にすれば、時間で表示できます。
>なるほど、配列数式ってこうやって使えるのですね！ とのことなので、配列数式に関することは、排除します。 また、合計も分かると思うので排除 =(0+TEXT(SUBSTITUTE(A1,"欠",0),"0.0;;1;!0"))-SUM(A1) 数式の内側から、SUBSTITUTE関数で、"欠"を0に置き換える (1) 文字のみ（例：遅・早・浦・特・欠などの１文字） 　パターン(1)「欠」のみ「0」の数字に置き換わる 　パターン(2)その他の文字列は、そのまま (2) 数字と文字の組み合わせ（例：0.1欠・0.5欠　など小数点第1位までの数字と欠の連結のみ） 　パターン(3) 欠が外れて 数字(0.1,0.5 など)となる (3) 数字（0.5　・１のみ） 　パターン(3) 数字(0.1,0.5 など)となる (4) 空白のセル 　パターン(4) 空白の文字列 "" となる まず、上記4パターンに分類される。 次に、TEXT関数、数字と思われるものは数値として扱われる。戻り値は数字(文字列) "0.0;;1;!0" 正;負;0;文字列 であることから パターン(3)において、正の場合は 、"0.0"なので小数点第一位まで返す。 　(ただし、負の場合はないと考え、定義していない。) パターン(1) 0の場合、「1」の数字を返す パターン(2)(4)の場合、文字列なので「0」の数字を返す。 これですべて数字を返したので、0+ つまり、0を足す計算をさせて数値化する。 ただし、 (3) 数字（0.5　・１のみ） の場合も、合計の対象となってしまうため、あとで数値で入力してあるもののみ引く。 合計の意味もあるが、文字列は計算対象としない(エラーにしない)意味も持つ。 聞かれれば答えるつもりではいたが、文章説明は意外とめんどいなぁ(^_^;
張り付けたが画像を選択し、「書式」「色」「透明色を指定」を選んで、画像の透明にしたい部分（画像の白い部分）をクリックすると白が透明になります。 詳細は、Excelのヘルプを「図の色または透過性」で検索してみて下さい。
No.2です。張り付けた数式が文字化けしてしまったようなので、再掲示です。 =SUBSTITUTE(TRIM(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE("0 1 2",A1,""),B1,""),C1,""))," ",",")
面白い問題ですね。 =SUBSTITUTE(SUBSTITUTE(SUBSTITUTE("012",A1,""),B1,""),C1,"") ただ、最近、正規表現にこだわっていますので、RegExp でトライしてみました。 ちょっとややこしいですね。 Function vregReplace(rng As Range) As String Dim out As String Dim objReg As Object Dim m As Variant, buf As String, c As Variant Dim tg As String, Matches As Object Dim Num As String: Num = "012" Set objReg = CreateObject("VBScript.RegExp") With objReg 　　　.Global = True 　　　For Each c In rng: tg = tg & c.Value: Next 　　　.Pattern = "[" & tg & "]" 　　　Set Matches = .Execute(Num) 　　　buf = Num 　　For Each m In Matches: buf = Replace(buf, m.Value, ""): Next 　　　　　　　　vregReplace = buf End With Set objReg = Nothing End Function 'Basp21正規表現ですと、 Function reReplace(rng As Range) Dim out As String Dim bobj As Object Dim c As Variant, tg As String Set bobj = CreateObject("Basp21") For Each c In rng 　　tg = tg & c.Value Next 　　out = bobj.Replace("s/[" & tg & "]//g", "012") 　　reReplace = out End Function
結構「HPageBreaks」や「VPageBreaks」に癖があったので確認に時間がかかりました。 --------------------------------------------------------------------------- Sub Sample() Dim 横頁 As Long Dim 縦頁 As Long Dim 頁 As Long Application.ScreenUpdating = False ActiveWindow.View = xlPageBreakPreview For 横頁 = 1 To ActiveSheet.HPageBreaks.Count If ActiveSheet.HPageBreaks(横頁).Location.Row > Selection.Row Then Exit For Next For 縦頁 = 1 To ActiveSheet.VPageBreaks.Count If ActiveSheet.VPageBreaks(縦頁).Location.Column > Selection.Column Then Exit For Next 頁 = (ActiveSheet.HPageBreaks.Count + 1) * (縦頁 - 1) + 横頁 ActiveWindow.View = xlNormalView Application.ScreenUpdating = True ActiveWindow.SelectedSheets.PrintOut From:=頁, To:=頁, Copies:=1, Collate:=True End Sub --------------------------------------------------------------------------- なお「ActiveWindow.SelectedSheets.PrintOut From:=頁, To:=頁, Copies:=1, Collate:=True」は適当に修正してください。
「できますか」を質問とは呼びませんよ。 Sub Macro1() Dim rng As Range, r As Range Dim lr As Long, i As Long Const key As String = "梅" Application.ScreenUpdating = False With ActiveSheet lr = .Cells(.Rows.Count, 1).End(xlUp).Row Set rng = .Range("A1:A" & lr) For Each r In rng r.Characters.Font.ColorIndex = xlAutomatic For i = 1 To Len(r.Value) If Mid(r.Value, i, Len(key)) = key Then r.Characters(Start:=i, Length:=Len(key)) _ .Font.Color = RGB(255, 0, 0) End If Next i Next r End With Application.ScreenUpdating = True Set rng = Nothing End Sub
=DATE(YEAR(A1)+1,1,1) でいかがでしょうか。 DATE(年,月,日)です。
単純に、=SUMIF(A:A,1111,C:C)+SUMIF(A:A,2222,C:C)+SUMIF(A:A,3333,C:C)
#1の回答者です。 >;;;"*****"の場合、空白セルになります。 >"*****";;;"*****"の場合、*****になります。 >なぜこうなるか、よく分かりません。 >解説していただきませんでしょうか。 書式では、 　正数;負数;0;文字列 と区別して扱われます。 私が#1で書いたのは、正数(プラス）と文字列を****(伏せ字）にすることです。正数;;;文字列を伏せ時にするなら、"****";;;"****" となります。 #2さんの場合は、 そのすべての部分をを伏せ時にすることです。
No.1の回答者です。 前の回答で > 私は、このメーカーのPCを使ったことがないので と書いているように、メーカー独自の機能やソフトはわかりません。 おそらく似たような機能があるのではないかと思って、古いバージョンの 情報を載せただけです。 メーカーのサイトからサポート情報で探すなり、マニュアルから探すなど 質問者自身で探されてはいかが。 http://www.lenovo.com/jp/ja/ Windows10はOSのバージョンであり、ノートPCの機種によって[ F8 ]キー の設定が違うみたいなので、ソフト名や設定方法などを探すのも無理が あるのです（ソフトがあるかどうかも定かではありません）。 もしかしたら、キーボードの設定などから設定するのかもしれませんし、 BIOSから設定するのかもしれませんし、何で設定するかは機種による 違いだと思います。 http://d.hatena.ne.jp/ogohnohito/20140401/p2 http://blog.g-fellows.com/computer/2038/ Fn ＋ Esc 同時押しで Fnキーをロック http://thinkpade450.blog.fc2.com/blog-entry-59.h …
F1だけ修正です。 =IF(COUNT(A1:B1)<2,"",(MAX(0,MIN("8:00",MIN(B1,"22:00")-MAX(A1,"5:00")-C1/24)*24))) 休憩時間は通常時間内にとるというのを前提にしています。 休憩時間も1:00のように入力する方がいいと思いますが・・。
それは、良かったでした。 >adrに少し付け足して、 >adr = "'" & ActiveSheet.Name & "'!" & aRng.Offset(, 2).Address(1, 1) >のようにすると、（）付きのシートも通常のシートもどちらも動作しました。 うーん、やはり私の場合は、Nameの取り扱いは、1000回に1つ程度しか使わないから、いつまでも分からなかったと思います。このシングルクォートは、自ブックの自シート(ActiveSheet)では入らなかったような気がしたのですが、正直なところ、これについては、私の守備範囲外です。ただ、この件については、覚えておくようにします。
単純にIF関数で、２以下なら１、それ以外（3以上）なら０とすればよいと思う。 そのほうが後から見たときに混乱しなくて済む。 Sheet1のB列の2行目から１～５の数値が入る。 Sheet2はSheet1と同じデータ配列になっている…とすると、 =IF(Sheet1!B2<=2,1,0) これをSheet2の「Sheet1のB2セル」に対応するセルに記入し、このセルをコピーし必要な行まで貼り付ける。
#6の訂正 × For Each p In Array(41, 0, 40, 41) ◯ For Each p In Array(41, 0, 40, 38) サンプルをアップロードして置きましたので、もしよろしかったらお使いください。 掲示板のCustom UIも、マクロコードも、両方共ダウンロード版とは若干の違いがあります。 http://bit.ly/29a2cP6 ダウンロードパスワードは、この質問HTMLの手前の番号－7桁の数字です。 使う前には、Excelファイルのプロパテイからブロック解除を行ってください。今回は削除期限は書きません。ただ、長くは置いていません。 今回は、カスタマイザーをCustom UI Ediotr に替えてみました。 http://openxmldeveloper.org/blog/b/openxmldevelo … (場合によっては、サイト開けると変なメッセージが出ますが、これは、このツールを知っている人なら分かる洒落だと思います。） 参考した場所 https://msdn.microsoft.com/ja-jp/library/office/ …(v=office.14).aspx Office 2010 と書かれていますが、これ以降も有効です。
マクロで良ければ、こんな感じです。 Sub sample() Sheets("Sheet2").Rows("1:1").Copy Destination:=Sheets("output").Rows("1:1") Sheets("Sheet1").Range("A1").Copy Sheets("output").Range("A1").Insert Shift:=xlToRight Sheets("Sheet1").Range("A1").CurrentRegion.AdvancedFilter Action:= _ xlFilterCopy, CopyToRange:=Sheets("output").Range("A1").CurrentRegion End Sub
こんばんは！ ＞★2のデータにしたい場合の関数を教えて下さい。 というコトですので、一例です。 元データはSheet1にあり、Sheet2に表示させるとします。 ↓の画像のようにSheet1に作業用の列を2列設けます。 作業列1のD2セルに =IF(COUNTBLANK(A2:B2),"",A2&"_"&B2) 作業列2のE2セルに =IF(OR(D2="",COUNTIF(D$2:D2,D2)>1),"",ROW()) という数式を入れ　→　D2・E2セルを範囲指定　→　E2セルのフィルハンドルでずぃ～～～！っと下へコピーしておきます。 そしてSheet2のA2セルに =IFERROR(INDEX(Sheet1!A:A,SMALL(Sheet1!$E:$E,ROW(A1))),"") という数式を入れ隣のB2セルまでフィル＆コピー！ C2セルに =IF(A2="","",SUMIFS(Sheet1!C:C,Sheet1!A:A,A2,Sheet1!B:B,B2)) という数式を入れ、A2～C2セルを範囲指定　→　C2セルのフィルハンドルで下へコピー！ これで画像のような感じになります。 ※　作業列が目障りであれば遠く離れた列にするか 非表示にしてください。m(_ _)m
UserForm_Activateイベントプロシジャで、TextBox1のControlSourceプロパティに、選択されているセルのアドレスを設定してみて下さい。 こんな感じです。 Private Sub UserForm_Activate() TextBox1.ControlSource = Selection.Address End Sub
条件付き書式で可能だと思いますが、面倒な設定ですよね。 単純にSheet1の2行目の開始と終了を元にSheet2の2行目の時間の 下に出すだけなら、以下のような数式を条件付き書式にすれば可能 だと思います。 　=AND(Sheet1!$B$2<=B$1,Sheet1!$C$2>=B$1) 1行目の時間に対して指定時間内にあるかどうかを判断しています。 こちら↓は時間ではないですが、日付で同じようなものへの回答です。 https://oshiete.goo.ne.jp/qa/9285822.html 勤務時間を出すものは難しくないと思いますので、こちら↓を参考に。 http://www.eurus.dti.ne.jp/~yoneyama/Excel/nyumo … http://news.mynavi.jp/series/excelfunc/023/ http://www.wanichan.com/pc/excel/2010/5/page10.h …
No.2の回答者です。 質問者さんの環境だとできませんが、Excel2013以降の場合だと、「0」 の値と空白セルを区別して表示することは可能です。 http://www4.synapse.ne.jp/yone/excel2013/excel20 … 系列を選択して[データラベルの書式設定]を開くと、[ラベルの内容]に [セルの値]が表示されます。 これにチェックを入れて[値]のチェックを外すと空白のままになります。 Excel2013以降の新機能なので、その前のバージョンだとできません。 バージョンを最新にすることができれば簡単なのですが、そうできない 場合はマクロを使うなどするか、諦めるしかないかもしれませんね。
ワイルドカード（＊）を用いても先頭の文字列だけを示す文字列をおそらく定義できないので置換はできない。 最初の「振込6　ヤマモト　タロー」がB3セルであれば、 C3セルに、=MID(B3,FIND("　",B3,1)+1,100) と入力すればよい。 そのまま下にオートフィルしてください。 ※文字列最初に現れる全角スペースの次の文字から100文字分を出力している。 できたC列を、B列に[形式を選択して貼り付け]で[値]を選んで貼り付けて、C列を削除すれば希望の結果になるだろう。
一覧、顧客予定表のレイアウトが小っちゃくて、よく分からなかったので、勝手に想像してVBAを書いてみました。こちらの想定は下図の通りです。差異がある場合は、適宜、コードを修正して下さい。 各時間は、シリアル値で入力してください。もし、顧客予定表の時間を「9：00～」と表示したい場合は、書式設定で「h:mm"～"」としてください。 顧客予定表の時間に、一覧の時間を超えるような値（例えば、23:00とか）を入力した場合、一覧上の一番遅い時間に転記されます（一覧に存在する直近の時間に転記するようにしています） 一応、エラー処理は入れていますが、かなり雑です。必要に応じて追加してください。 Sub sample() Dim ws As Worksheet With Sheets("一覧") Range(.Cells(2, 2), .Cells(Rows.Count, Columns.Count)).Clear End With For Each ws In Worksheets If ws.Name <> "一覧" Then Call subTenki(ws) Next End Sub Sub subTenki(ws As Worksheet) Dim rng As Range Dim c As Long Dim r As Long On Error GoTo ErrorHandler With Sheets("一覧") For Each rng In ws.Range("A5:F5") If rng.Value <> "" Then c = WorksheetFunction.Match(rng, .Rows("1:1"), 1) r = WorksheetFunction.Match(rng.Offset(-1), .Columns("A:A"), 0) If .Cells(r, c) = "" Then .Cells(r, c) = ws.Range("A1") Else .Cells(r, c) = Cells(r, c) & _ vbLf & ws.Range("A1") End If End If Next End With Exit Sub ErrorHandler: MsgBox ws.Range("A1") & "(" & ws.Name & ") に不正な入力があります。" _ & vbLf & "このシートの転記を中断しました。" End Sub
言語バーの「般」をクリックして「人名/地名」をクリックするだけじゃないの？ これで、郵便番号を全角で入力して変換すれば、住所は出るかな。 半角でもできるけど、変換すると全角になるからね。
新しいエクセルを開くか、Sheet2を開きます。 A1に「=B3」を入れて、オートフィル。 置き換えで「=」を「＄」にしましょうか。＄は何でもいいです。使わない文字がいいかな。 そして、行を2行（又は3行）挿入します。 Keyboard Butler ～鍵盤の執事くん～　をダウロードすれば、楽になるかも。検索したら出てきます。 「Shift+F10」　「I」と設定すると簡単に挿入してくれます。 又は、tinytask　もいいかも。検索したら出てきます。 マウス、キーボードの軌跡です。一度、登録すると同じ動きをしてくれます。 又は、エクセルにも一番新しいことが「F4」を押すとしてくれます。 いちいち、右クリックしなくても同じ作業をしてくれます。 関数にしていなければ、行を挿入しても変更されません。 それをコピーして、右クリックして「形式を選択して貼り付け」を選んで、 Sheet1に戻り、「空白セルを無視する」にチェックしてOK。 置き換えで「＄」を「＝」に置き換えて完成です。 エクセルの「F4」も、楽ですよ。 tinytask　は、パソコンが追いつかない可能性が。 Keyboard Butler ～鍵盤の執事くん～　の方が、キーボードのボタン一つで作業してくれますからこちらの方がいいかな。 慣れれば、tinytask　の方がいいけどね。
こんばんは！ Googleスプレッドシートで出来るかどうかわかりませんが・・・ ExcelだとSUBTOTAL関数があります。 フィルタを掛けても非表示にならないセルに =SUBTOTAL(4,対象列) とすれば表示されているデータの最大値が返ります。 ※　数式内の「対象列」とは、 仮にC列の最大値を返したい場合 =SUBTOTAL(4,C:C) という数式にします。m(_ _)m
ありゃー1分未満の差でtom04さんが回答してくれてました 実質的なアプローチはほぼ同じですが、ユーザー定義関数を実装した点が大きく異なります。 しかも、当方、記述する場所も間違ってるし、、、。 Range("A2") でしたね
だとすれば、ボタンあ　や　い　を作動させる前に、一旦全表示するコードを挟むと良いでしょう。 たとえばこんな感じです。 ボタンあ Sub ボタン1_Click() Cells.EntireRow.Hidden = False Union(Range(Rows(9), Rows(14)), Range(Rows(32), Rows(61))).EntireRow.Hidden = True End Sub たぶんこれで意図されている動きになるような気がします。
特定の値を抽出するならLOOKUP系の関数でしょうが、特定の値が存在するかどうかまででいいならCOUNTIFを使います。 検索値が複数になり、AND条件が加わったなら、Excel2007以降ならCOUNTIFS関数を使い、それ以前のExcelならCOUNT関数を2つ組み合わせます。 >値はあるか、ともに存在するか？　片方だけか？　それともともに存在しないか？ を1つの数式でまかなう方法はちょっと考えつきませんが、IFとCOUNTIFの結果の組み合わせでできるとは思いますが、かなり長い数式になると思います。 縦軸に検索値、横軸には「値あり」「値無し」を表示させるセルを設け、結果に対して「両方値がある」とか「片方だけ」とかを判別する数式を組むことになると思います。 http://oki2a24.com/2014/07/17/if-present-in-list …
こんにちは。 Excelの勉強を楽しまれているとのことで。 使いこなせるようになるととても便利で楽しいソフトなので頑張ってくださいね☆ 質問を拝見し私も同じファイルを作成してみました。 結論から申し上げると、らん0404さんが希望されていることはVBAを使用しなくても行えます。 No.1さんが回答されている様にファイルのリンクで行えます。 ①まず、売上ファイルには支店ごとの合計を計算するセルを用意してあげます。 1/31まで同様の入力欄があった場合CO列まで使用されると思うので、添付画像上の様にCP列に合計列を作成します。 東京合計(CP2セル)の入力式⇒ =SUM(CO2,CL2,CI2,CF2,CC2,BZ2,BW2,BT2,BQ2,BN2,BK2,BH2,BE2,BB2,AY2,AV2,AS2,AP2,AM2,AJ2,AG2,AD2,AA2,X2,U2,R2,O2,L2,I2,F2,C2) ②次に、合計ファイルの売上合計を表示させるセルには添付画像下の様に売上ファイルを参照する式を入力してあげます。 東京合計(C２)の入力式⇒ =[売上.xlsx]Sheet1!$CP2 こうしておけば合計ファイルを開く際に「このブックには、安全でない可能性のある外部ソースへのリンクが1つ以上含まれています。」のメッセージボックスが表示されるのでそこで[更新する]のボタンを押せば売上ファイルの合計が自動的に表示されます。 他の方も書かれていますが、可能であれば表の作り方を変えられた方がこれからの処理もラクになると思います。 とりあえず他のブックを参照する方法を記しておきますね。
>「Excelのオプション」「アドイン」「設定」アドインに「郵便番号変換ウィザード」がないです。 Library は、 C:\Program Files\Microsoft Office 16\root\Office16\Library\　？ というとこですか？ http://okguide.okwave.jp/guides/37340 ここにも、Libary と書かれていますが、いつのまにか昔に戻ってしまったのでしょうね。 私はこちらに入れています。ポリシーを持って棲み分けさせています。 C:\Users\[ユーザー名]\AppData\Roaming\Microsoft\AddIns こちら側にいれるのは、Microsoft側がサポートしていないものです。Microsoft 側が提供しているものなら構わないのですが。 ユーザー側が後で入れたものは、全部、こちらに入ます。それは暗黙のルールなのです。 それと、Zipcode7.xla は、コードをみて分かる人は分かるのですが、不要な部分など加工が必要になってくることがあります。Programe File側に入れるとその変更がききません。いえ、正確には極めて面倒なのです。 それはともかくとして、 [設定]－[参照]で、Zipcode7.xla　を選んでください。 自分の入れた場所、もしくは検索して選べば登録されます。 それと、郵便番号検索エンジンは入っていますか？ ．．．．\Office16\MSYUBIN7.DLL があるはずです。なければ、探してインストールするか、コピーして持ってこなければなりません。たぶん、インストール時に入っているはずです。 MSYUBIN7.DLL このファイル以外にも以下の3つが必要です。 ADVZIP.DIC ADVCMP.DIC ADVTEL.DIC 「Office 更新プログラム: 郵便番号辞書」の中にありますが、安全な場所から手に入れる方法が分かりません。既に、Microsoft のDownload側では見つかりません。
画像もVLOOKUP http://pc.nikkeibp.co.jp/article/technique/20100 …
こんにちは 修正とか以前に、本来なさりたいことがよくわかりませんでしたが・・・ ＞同じ商品名のグループ1／グループ2／グループ3は ＞同じ行になるように抽出したいのです。 普通に考えればそうなるのではないかと思います。 入力がバラバラならば、同じものであることを示すIDのようなものを附してそれで照合するのが通常の考え方かと。 そうでない場合でも、これと同等の判断ができる材料がないと（人間的な判断でしかできない場合は）自動化するのは難しいのではないでしょうか？ ご提示のコードで、入力済みの行を訂正したり値を変えた場合に、予定通りの結果になるのでしょうか？ 全体の処理を整理して考え直した方が、結果的には近道のような気がします。 とはいうものの、なさりたいことがよくわからないので良くわかりません。 回答にもなっていなくて、ごめんなさい。
6/22公開の重要な更新プログラム「Microsoft Silverlightの更新」が自動的にインストールされていると思います。 私の場合本日エクセル2007の動作が大変不安定になったので本更新プログラム適用前の状態に試しにシステム復元してみたところ不安定さが直りました。 質問されている不具合の原因がこれかどうか分かりませんが、試してみたら如何ですか。
こんにちは こんな感じですかね。 すみません、実際に起動させてないのでバグあるかも。 dim n as long '繰り返し用変数 dim m as long '月 m = worksheets("インポートシート").range("I2") for n = 1 to x 'xには必要な数字（行数） 　　worksheets("AAA").cells(n,1+m) = worksheets("インポートシート").cells(n,5) 　　'Sheet "AAA"の、1月ならE（五列目）にインポートシートの数字が入る。 next n
これかな https://www.moug.net/tech/exvba/0150128.html
こんばんは コピー元の行が変化することに困っているなら、 ”計”の入力されているセルを探し、そこまでをコピーすれば解決します。 For i = 1 To Rows.Count If Sheets("Sheet3").Cells(i, "C") = "計" Then Exit For Next With Worksheets("sheet2") Worksheets("sheet3").Rows("2:" & i).Copy .Rows(.Cells(Rows.Count, "C").End(xlUp).Row + 1) End With （質問文の式に近いかたちにしています。） ページ数の件は、C列に"計"がページごとに入力されるのであれば、C列をCountif関数で調べてはいかがでしょうか。
No.4 ママチャリです。 「欲を言えば…」の件ですが、こんな感じですかね。 入力データのセルは、A3およびB1~B9の10ヶ所としました。その中で小数点以下の桁数が一番多いものに合わせて表示するようにしています。警告は出していません。 前回の回答を検証されているようなので、細かい説明は省略させていただきます。 ちなみに、「=LEN(A1)-FIND(".",A1)」って、小数点が無い場合、ゼロになりますか？ Private Sub Worksheet_Change(ByVal Target As Range) Dim myRng As Range Dim r As Range Dim maxLen As Long Dim L As Long Set myRng = Range("A3,B1:B9") If Intersect(Target, myRng) Is Nothing Then Exit Sub For Each r In myRng L = InStrRev(CStr(r.Value), ".") If L <> 0 Then L = Len(CStr(r.Value)) - L If L > maxLen Then maxLen = L Next Me.Unprotect myRng.NumberFormatLocal = "0." & String(maxLen, "0") & "_ " Range("A1").NumberFormatLocal = "0." & String(maxLen + 1, "0") & "_ " Range("A2").NumberFormatLocal = "0." & String(maxLen + 2, "0") & "_ " Me.Protect End Sub
Sheet1の 　A2セルに「C」 　B2セルに数値 　D2セルに「ｋ」 　E2セルに数値 …は大丈夫。わかります。 しかし、 Sheet2のA1セルに「ｋ」と入力すると・・・ ・どこに、 ・どの列のどの行の値を表示させるのか。 …が質問文からは分かりません。 補足をお願いします。 Sheet1のA列にはどこかの行に「C」と入力されていて、 Sheet1のD列にはどこかの行に「k」と入力されていて、 Sheet2のA1セルに「k」と入力したら、Sheet1のD列にある「k」と同じ行にあるE列の値を、 Sheet2のA1セルに「C」と入力したら、Sheet1のA列にある「C」と同じ行にあるB列の値を、 Sheet2のB1セルに表示したい。 …などとお願いします。
⑤の条件が一番上位にくればよいと思います． =IF(A>=45,質問文の関数,B+0) みたいな感じじゃないでしょうか．
E列：=VLOOKUP(D4,関数式!G$3:H$262,2) F列：=VLOOKUP(D4,関数式!A$3:B$262,2) G列：=VLOOKUP(D4,関数式!J$3:K$262,2) H列：=VLOOKUP(D4,関数式!D$3:E$262,2) I列：=VLOOKUP(F4,関数式!AB$3:AC$22,2,FALSE) J列：=VLOOKUP(G4,関数式!AB$3:AC$22,2,FALSE) と直す。 そして必要な行までD4セルからJ4セルの範囲をコピーすることで、たぶん（※）解決すると思う。 D列はそのままで良い気がするのだが？ ※ まあ、これも「関数式」シートをどのように参照したいのかによって変わってくる。 1行下げたらVLOOKUP関数で参照する範囲も1行下げたいなら、数式を変更する必要はない。（これが相対参照） 1行下げてもVLOOKUP関数で参照する範囲を1行下げたくないなら、上のように修正する。（これが絶対参照） 行方向にコピーするようなので、「行」に対して絶対参照させるだけで良いが、列に対して絶対参照させても問題ない。 ・相対参照　　　　　E列：=VLOOKUP(D4,関数式!G3:H262,2) ・行だけ絶対参照　　E列：=VLOOKUP(D4,関数式!G$3:H$262,2) ・列だけ絶対参照　　E列：=VLOOKUP(D4,関数式!$G3:$H262,2) ・行列とも絶対参照　E列：=VLOOKUP(D4,関数式!$G$3:$H$262,2)
ピボットグラフで可能なはずです。 空白が含まれているのは、空白にチェックが入っているからではないですか？
条件付き書式の「新しい書式ルール」から「数式を使用して、書式設定するセルを決定」を選択し、 「次の数式を満たす場合に値を初期設定」に =MATCH(E4,関数式!$AS$3:$AS$54,0) これを入力する。
印刷の設定で、ユーザー設定のビューを使うとよいかもしれません 仮に、A4縦の印刷設定を登録し、「初期A4縦」 とします マクロで sub 初期() 　ActiveWorkbook.CustomViews("初期A4縦").Show end sub 同様にA4横の印刷設定をして(「リピートA4横」として登録) fujillinさんのマクロのに 　ActiveWorkbook.CustomViews("リピートA4横").Show を追加しておく(前の方に追加で良いと思う) ユーザー設定のビューの登録方法は http://www4.synapse.ne.jp/yone/excel2010/excel20 … 非表示の列(行)や印刷の細かな設定が登録できて便利です。 上書きは同じ名前で追加登録してください #VBAだと項目がいっぱい過ぎて、手に負えないだけですが(^^;
拡張子が変更されてしまったのでは？
こんばんは！ ＞JANコードが同じものはまとめて合計個数を出したいです。 をどこに出したいのか判らないので↓の画像のようにやってみました。 Sheet1～Sheet3の配置は画像通りとします。 Sheet3のA2セルに =IFERROR(INDEX(Sheet1!A$2:A$1000,SMALL(IF(COUNTIF(Sheet2!$A$2:$A$1000,Sheet1!$A$2:$A$1000),ROW(A$2:A$1000)-1),ROW(A1))),"") 配列数式ですので、Ctrl＋Shift＋Enterで確定！ A2セルのフィルハンドルでC2セルまでコピー！ D2セル（配列数式ではありません）に =IF(C2="","",IF(AND(COUNTIF(C:C,C2)>1,COUNTIF(C$2:C2,C2)=1),COUNTIF(C:C,C2),"")) という数式を入れ、A2～D2セルを範囲指定　→　D2セルのフィルハンドルで下へコピー！ これで画像のような感じになります。 ※　B列の「個数」はSheet1・Sheet2の合計しなくてよいのですよね？ 単純にSheet1の「個数」を表示しています。 ※　D列は「JAN」が重複する最初に出現した行だけに 重複個数を表示するようにしています。 一発で解決！とはいかないと思いますが、 まずはこの程度で・・・m(_ _)m
[F9]キーを押すと計算されるなら、計算方法が手動になっています。
Sheet2のA1セルに特定の文字列（消したい値）を入力して、次のマクロを実行してください。 Sub sample() Dim r As Range With Sheets("Sheet1").Range("A:A") Set r = .Find(Sheets("Sheet2").Range("A1"), LookIn:=xlValues) If Not r Is Nothing Then .ColumnDifferences(r).EntireRow.Hidden = True .SpecialCells(xlCellTypeVisible).Delete Shift:=xlUp .EntireRow.Hidden = False End If End With End Sub
No.4です。 またまたこんにちは。 遅くなりました。 オートフィルターで表示されているデータのみを対象に、今までの処理をするというコードを作ってみました。 結構変更したので改めてコードを貼り付けますね。 ちなみに作業列(F列)の使用は廃止しました。 私の低いコーディング技術で１つのプロシージャ内に納めたものなので読みにくいと思いますが頑張って読んでみてください(笑) 心配なのはデータ量が多い場合フリーズしないか、ということです・・・。 Public Sub b() Dim r1 As Double Dim r2 As Double Dim rLST As Double Dim cntR As Double Dim cntA As Double Dim cnt As Double Dim i As Integer Dim pick1() Dim pick2() Dim colE() '//-----シート名の指定---- Const SNM1 = "Sheet1" Const SNM2 = "Sheet2" '------------------------// '//-----シート1データ開始行指定---- Const srt1 = 2 '--------------------------------// '//-----シート2データ貼付行指定---- Const srt2 = 2 '--------------------------------// 'シート1のデータ最終行を取得 Worksheets(SNM1).Select Worksheets(SNM1).Range("A" & srt1).Select Selection.End(xlDown).Select rLST = ActiveCell.Row r1 = srt1 cntR = 1 Do Until r1 > rLST '選択行が可視の時 If Sheets(SNM1).Rows(r1).Hidden = False Then 'E列の値が「-」かつ「---」でない時 If Worksheets(SNM1).Range("E" & r1) <> "-" And Worksheets(SNM1).Range("E" & r1) <> "---" Then '行番号を取得 ReDim Preserve pick1(cntR) pick1(cntR) = r1 'E列の値を取得 ReDim Preserve colE(cntR) colE(cntR) = Range("E" & r1) cntR = cntR + 1 End If End If r1 = r1 + 1 Loop '対象行(可視＆E列がハイフンでない)内でのＥ列重複確認 cntR = 1 For cntA = 1 To UBound(pick1) i = 0 For cnt = 1 To UBound(colE) If Worksheets(SNM1).Range("E" & pick1(cntA)) = colE(cnt) Then i = i + 1 '重複が1つでもあったら比較処理を終了(時短対策) If i > 1 Then Exit For End If End If Next '重複の行番号を取得 If i > 1 Then ReDim Preserve pick2(cntR) pick2(cntR) = pick1(cntA) cntR = cntR + 1 End If Next 'シート2へコピペ r2 = srt2 For cnt = 1 To UBound(pick2) Worksheets(SNM1).Rows(pick2(cnt) & ":" & pick2(cnt)).Copy Worksheets(SNM2).Select Worksheets(SNM2).Rows(r2 & ":" & r2).Select ActiveSheet.Paste r2 = r2 + 1 Next 'アクティブセルをA1にしておく Worksheets(SNM1).Select Application.CutCopyMode = False Worksheets(SNM1).Range("A1").Select Worksheets(SNM2).Select Worksheets(SNM2).Range("A1").Select End Sub
何となく、荒れてますね。･･･ので、1回だけ回答させていただきます。 元データは、Sheet1のA1セルから下へ入力されているものとしています。 Sub sample() Dim MyRng As Range Dim r As Range Dim MaxLen As Long Dim l As Long With Sheets("Sheet1") Set MyRng = .Range("A1:A" & .Cells(Rows.Count, "A").End(xlUp).Row) End With For Each r In MyRng If MaxLen < Len(r.Text) Then MaxLen = Len(r.Text) Next For l = MaxLen To 1 Step -1 If CheckLen(MyRng, l) Then Exit For Next If l = MaxLen Then MsgBox "ダブりがあります。" Else MsgBox "下 " & l + 1 & " 桁でユニークです。" End If End Sub Private Function CheckLen(MyRng As Range, l As Long) As Boolean Dim Dic As Variant Dim r As Range CheckLen = False Set Dic = CreateObject("Scripting.Dictionary") On Error GoTo ErrHander For Each r In MyRng Dic.Add Right(r.Text, l), "dummy" Next Exit Function ErrHander: CheckLen = True End Function
１点目、Vlookup関数 ２点目、値のみ貼り付け
こんにちは！ 元データはSheet1にあり、↓の画像のような配置になっているとします。 Sheet2の2行目以降に表示するようにしてみました。 一例です。標準モジュールにしてください。 Sub Sample1() Dim i As Long, j As Long Dim cnt As Long, wS As Worksheet Set wS = Worksheets("Sheet1") cnt = 1 For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row For j = 2 To wS.Cells(1, Columns.Count).End(xlToLeft).Column If wS.Cells(i, j) <> "" Then cnt = cnt + 1 With Worksheets("Sheet2").Cells(cnt, "A") .Value = wS.Cells(i, "A") .Offset(, 1) = wS.Cells(1, j) .Offset(, 2) = wS.Cells(i, j) End With End If Next j Next i End Sub こんな感じではどうでしょうか？m(_ _)m
No.1です。 Sheet2のA3セルの数式ですが・・・ 画像の配置だと =IFERROR(INDEX(Sheet1!$A$1:$A$1000,SMALL(IF((Sheet1!$B$1:$B$1000=A$2)*(Sheet1!$C$1:$C$1000<>"")*(Sheet1!$D$1:$D$1000=""),ROW($A$1:$A$1000)),ROW(A1))),"") 今回も配列数式ですので、Ctrl＋Shift＋Enterで確定です。 ※　C・D列には必ずシリアル値（数値）が入る！というコトであれば =IFERROR(INDEX(Sheet1!$A$1:$A$1000,SMALL(IF((Sheet1!$B$1:$B$1000=A$2)*(Sheet1!$C$1:$C$1000>0)*(Sheet1!$D$1:$D$1000=0),ROW($A$1:$A$1000)),ROW(A1))),"") でも大丈夫だと思います。 ※　お示しの数式内の ＞(Sheet1!$C$1:$C$1000="*") の部分でC列に文字列の「*」のセルがないためエラーとなり 結果として返るのは「空白」になると思います。 "*" とした場合は「ワイルドカード」ではなく文字列の「*」（アスタリクス）という判断になるはずです。 というコトから ＞(Sheet1!$C$1:$C$1000<>"") が良いと思います。 シリアル値の場合は ＞(Sheet1!$C$1:$C$1000>0) としています。m(_ _)m
関数が入っているセルの値が変わった時にマクロを動かす仕組みになります。 まず、下記のVBAを各オブジェクトの下に張り付けて下さい（非表示にするマクロは、qazxcvfr4さんの方で書き直してくださいね）。 その上で、「入力」シートのC5セルに入っている関数を下記のユーザ定義関数（MyChangeIf）で包みます。 具体的には、例えばC5セルに =IF(Sheet2!A1<10,"A","B") という式が入っている場合、それを =MyChangeIf(IF(Sheet2!A1<10,"A","B")) とします。 【ThisWorkbook】 Private Sub Workbook_SheetCalculate(ByVal Sh As Object) If MyChange Then Call 非表示にするマクロ MyChange = False End If End Sub 【標準モジュール】 Public MyChange As Boolean 'パブリック変数で定義。 Function MyChangeIf(v As Variant) As Variant If Application.ThisCell.Text <> CStr(v) Then MyChange = True End If MyChangeIf = v End Function Sub 非表示にするマクロ() MsgBox "Ａ列が空白になっている行を非表示にするというマクロ" End Sub
こんな感じになると思います。 「A4用紙シート」のブックをアクティブにした状態で、下記マクロを実行してください。すると、新しいブックが作成され、そこにデータが抽出されます。 「品番・色柄・数量」の格納位置がよく分からなかったので、適当に想像して書いています。もし違っていたら正しい位置に修正して下さい。 Sub sample() Dim wbI As Workbook Dim wsI As Worksheet Dim wsW As Worksheet Dim r As Range Dim w As Long Set wbI = ActiveWorkbook Set wsW = Workbooks.Add.Sheets(1) wsW.Range("A1") = "品番" wsW.Range("B1") = "色柄" wsW.Range("C1") = "数量" w = 1 For Each wsI In wbI.Sheets For Each r In wsI.Range("C14:C19,C21:C26,I14:I19,I21:I26") If r.Value <> "" Then w = w + 1 wsW.Cells(w, 1) = r.Offset(, -2).Value wsW.Cells(w, 2) = r.Offset(, -1).Value wsW.Cells(w, 3) = r.Value End If Next Next End Sub
ブック1のいちばん右の列に作業列を追加し、追加した列を仮にY列とします Y1セルに 0、 Y2セルに =SUM(B2<>"",INDEX(Y:Y,ROW()-1)) 下へオートフィル 概念だけですので別ブックに見立てた同一シートで説明します AA3セルから連番(別ブックのA列に該当) AB3セルに =IF(MAX($Y:$Y)<$AA3,"",INDEX(B:B,MATCH($AA3-1,$Y:$Y)+1)&"") 右へ下へオートフィル (MATCHの部分が冗長で作業列にしたいところです) 数値も文字列(数字)になります 項目の合わないところは、その3行目をクリックして、[Ctrl]+[Shift]+[↓]で選択し [Ctrl]+[-｣セルの削除 ●左方向にシフト させます 連番までは自動更新としていませんのであしからず
>チェックをいれると隣のL列に０、チェックがないと－１がでるように設定しています。 マクロで作っているのでしょうか、いずれにしても、True と False が逆になっていますし、申し訳ありませんが、TRUE, FALSE ではないので、直接チェックボックスを当たることにします。 この場合は、フォームコントールのチェックボックスにします。こちらの方が、ずっと扱いが便利だからです。ActiveX のチェックボックスでも出来ないことはありませんが、以下のような簡単なマクロではなくなります。 あくまでも、チェックボックスは順序よく並んでいるとします。 j はデータの最初の行 最初の行の意味や転記先の最初の行の意味を確認して、本番前にマクロを試しながら、調整してください。 '// Sub transferBychkbox() Dim i As Long, j As Long, k As Long j = 2　　'元データの最初の行 k = 1 '転記先の最初の行 With ActiveSheet 　j = j - 1 '　i　は1から始まるので 　　For i = 1 To .CheckBoxes.Count 　　　　 If .CheckBoxes(i) = xlOn Then 　　　　　　　　 .Cells(j + i, 1).Resize(, 4).Copy Worksheets("Sheet2").Cells(k, 2) 　　　　　　　　　　k = k + 1 　　　　End If 　　Next End With End Sub '//
こんばんは！ ＞西暦と月を入れると曜日に対して日付が自動に変わるオーソドックスなものです。 すなわち年や月が変わるとセルがずれる！というコトですよね？ VBAでの一例です。 具体的にどのような配置のカレンダーになっているのか判らないので、勝手に↓のような感じのカレンダーだとしてやってみました。 画像にある「カレンダー」SheetのA4～G9セルの範囲で数値が入っているセルをダブルクリックすると 各シートが表示されるようにしています。 （仮に　6/3の　F4セルをダブルクリックするとSheet3　が表示されます） 「カレンダー」SheetのSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて） A4～G9セルのどこかをダブルクリックします。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) 'この行から// If Intersect(Target, Range("A4:G9")) Is Nothing Then Exit Sub If Target <> "" Then Cancel = True Worksheets("Sheet" & Day(Target)).Select End If End Sub 'この行まで// ※　単にクリックだけだと間違ったセルを選択してもマクロが実行されてしまいますので ダブルクリックでの操作にしています。
No.1です。 ＞一覧も1001、1002というように追加していって、シート名も同じく1002,1002としたいです。 というコトですので・・・ 前回は「番号一覧シート」のA列にシリアル値が入る前提のコードでしたのであのような感じにしました。 単純に入力データそのものをシート名にすれば良いというコトですので ＞ActiveSheet.Name = Format(wS.Cells(Rows.Count, "A").End(xlUp), "yyyy年m月") を ＞ActiveSheet.Name = wS.Cells(Rows.Count, "A").End(xlUp) に変更してください。 ※　数値でも文字列でもA列に入力した最終行のデータそのものが シート名になります。m(_ _)m
もう少し具体的に書いていただけませんか？プルダウンリストはどのようなデータを選択するのでしょう？ Ａ，Ｂ．Ｃ，Ｄを選んでどこかにある日付セルに色をつけるのですか？ それとも7月4日から7月8日…というリストを選択するのですか？
>リンク貼付先のデータB（C、D・・・）を単独に運用（貼り付けたデータはそのままで）する方法 > はありますでしょうか？ 一般機能では 1. 対象のシートを選択(仮にSheet2) 2. そのシートを新しいブックにコピー 3. セル全体を選択 4. コピー 5. 形式を選択して貼り付け ●値 6. [Esc]コピーの解除 上記をマクロの自動記録で Sub Macro7() 　 Sheets("Sheet2").Select 　 Sheets("Sheet2").Copy 　 Cells.Select 　 Selection.Copy 　 Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _ 　 　 :=False, Transpose:=False 　 Application.CutCopyMode = False End Sub
横から失礼します。pimanmazuiさんは条件付き書式設定で、文字（フォント）の色を変えることができますか？できるようであれば、次の方法をお試しください。 条件付き書式で、日付が15より小さいセルの文字（フォント）を黒に設定してください（自動以外なら何色でも大丈夫です。とりあえず、赤で実験すると分かりやすいです）。 その上で、「ユーザ設定の並べ替え」または、「色で並べ替え」から、次のキーで並べ替えを行うとご希望の順に並びます。 ・最優先されるキー　「日付」　「フォントの色」　「自動　上」 ・次に優先されるキー　「日付」　「値」　「昇順」
こんばんは ブックやシートの選択の仕方を変えてみたらいかがでしょうか？ 非表示のブックやそのシートは「select」や「Activate」は出来ません。しかし、 Workbooks("Book2").Worksheets("Sheet1").Range("A1") = 1 のような書き方ならば、非表示のブックやシートを扱えます。
一般的な資金繰り表は 日付が時系列で横方向に入り それぞれの事業所の 収支と残額が縦方向に入るかと思います。日付は半月とか１０日毎とかで グループ化しておけばいいです。同様に事業所も残額ごとにグループ化し て閉じられるようにしておきましょう。支出については主要なものは行を 分けておくといいかと思います。 ただ最低でも入金の管理表は別に作った方がいいと思います。クロス表に 直接入力していいことなんて全くありません。請求額との突き合わせも必 要でしょうから別表で管理して入金日に金額が入るように数式を入れてお くのがいいかと思います。
メールにショートカットが添付できて、受信者は全員、それを開けるのですか？ もしそうであれば、話は簡単です。 共有設定したExcelブックを用意するだけで十分ですよね。 もうちょっと凝るのであれば、ボタンをクリックした際にユーザ名を判断して、その方の参加、欠席欄に○を転記するくらいでしょうか。 ユーザ名は、Application.UserNameプロパティで取得可能です（氏名とユーザ名を対応させる必要がありますが…）。こんな感じです。 MsgBox Application.UserName
No.2 少し修正です 「Cells(i, "C").Value = StrConv(Cells(i, "B").Value, vbNarrow)」
こんばんは！ 作業列を使わず一気にやってみました。 ↓の画像でB2セル（セルの表示形式は「日付」にしておく）に =IF(A2="","",MAX(IF(Sheet1!A$1:A$100=A2,Sheet1!C$1:C$100))) 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ C2セル（配列数式ではありません）に =IF($A2="","",INDEX(Sheet1!D$1:D$10,SUMPRODUCT((Sheet1!$A$1:$A$100=$A2)*(Sheet1!$C$1:$C$100=$B2),ROW(A$1:A$100)))) という数式を入れ隣のD2セルまでフィル＆コピー！ 最後にB2～D2セルを選択　→　D2セルのフィルハンドルで下へコピーすると 画像のような感じになります。 ※　お分かりのようにSheet1が空白セルの場合「0」が表示されています。 「0」が目障りであれば メニュー　→　ファイル　→　オプション　→　詳細設定　→　「次のシートで作業するときの表示設定」　→　「ゼロ値のセルにゼロを表示する」のチェックを外してください。 Sheet2のC列は計算に使わない（文字列で良い）のであればC2セルの数式を =IF($A2="","",INDEX(Sheet1!D$1:D$10,SUMPRODUCT((Sheet1!$A$1:$A$100=$A2)*(Sheet1!$C$1:$C$100=$B2),ROW(A$1:A$100)))&"") にしてみてください。 （この場合「ゼロ値の・・・」のチェックに手を付ける必要はありません。） こんな感じではどうでしょうか？m(_ _)m
Format(Range("C8"), "YYMMDD") では？ http://officetanaka.net/excel/vba/function/Forma …
No.3 ママチャリです。 お礼の件ですが、はい。その通りです。今のままでは相手にパスワードを教えてしまうと意味がありません。 簡単にできそうな対応策は、下記の2点です。 ①事前にユーザ名と保存先フォルダをヒアリングして、"Security"シートに設定したものを送る。 ②"Security"シートに設定期限を設けて、期限以降は設定ロジックが動かないようにする。
>一番下の行に実働時間の合計があるため毎回行を追加しなければなりません。 ならば、別シートに(ピボットテーブルなどで)合計を出せばよいのでは？ 質問のような操作を行うにはマクロの力を借りることになりますが、 >excel 2026 macについて が、存在しないことと、MAC環境にないこと、実務的で間違った回答ができないなど から回答が付きにくいことと思われます。 相対参照によるマクロ記録とは http://allabout.co.jp/gm/gc/297850/ [Ctrl]+[↓](または[↑]) などと組み合わせて記録させます [Alt]+[F11]でVBEを起動させ、動作と記録内容を見て修正していきます
こんばんは 古典的な方法です。 赤枠の部分をコピーして、別のシートに 「形式を指定して貼り付け→値」 をすれば、出来ると思います。 …データを再入力するする手間を省いただけです。
一番細かい破線（「なし」の下）を設定すると印刷すると細い実線になることが多いです。（余程高性能のプリンタでなければ） 後は、太い実線を一番外側にして中を普通の実線にするか、ですね。微妙な線の細さを出したいならWordで作る方がいいでしょう。
こんなんでどうでしょう。下記のマクロを該当シートのSheetモジュールに張り付けて下さい。 使い方は、まず、ペースト先セルを右クリックします。その後、コピー元セルをダブルクリックします。 1点、確認なのですが、「セルのAM35～67とAR35～63材料」はあってますか？（～67？～63？） しかし、これって、Ctrl+ｃ、Ctrl+ｖでコピペしても同じような気がしませんか？連続でダブルクリックができて、どんどん下に張り付けられるようになれば、便利かもしれませんが、そこまでは…。 Dim PasteCell As Range 'モジュールレベルで宣言してください！！ Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Application.Intersect(Target, Range("AZ2:AZ70,BB2:BB70")) Is Nothing Then Exit Sub If Application.CutCopyMode = False Then Exit Sub If PasteCell Is Nothing Then Exit Sub PasteCell = Target.Value Set PasteCell = Nothing Application.CutCopyMode = False Cancel = True End Sub Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean) If Application.Intersect(Target, Range("AM35:AM67,AR35:AR63")) Is Nothing Then Exit Sub Set PasteCell = Target Target.Copy Cancel = True End Sub
C3セル「=IF(B3="","",IF(MONTH(B3)>=10,YEAR(B3) & "/10～" & YEAR(B3)+1 & "/9",YEAR(B3)-1 & "/10～" & YEAR(B3) & "/9"))」 D3セル「=IF(B3="","",MONTH(B3))」 それぞれ入力後、必要数下にコピーでいかがでしょうか？
ご存知とは思いますが、セル毎に指定できるのは、「ロックをする／しない」だけです。保護の種類についてはシート単位の指定になります。よって、種類の違う保護をセル毎に設定することはできません。 どうしてもやりたい場合は、VBAを駆使してゴリゴリ作りこみが必要です（できなくはないですが結構、面倒だと思います）。 問題の本質が、「マクロを動かしたいのでカーソルがそのセルにいかないと困る」だけであれば、「マクロの先頭で保護を解除し、最後に保護を掛ける」で十分だと思いますが、いかがでしょうか。 また、Protect メソッドには、次のようなパラメータもありますので、是非、試してみて下さい。 【Worksheet.Protect メソッド】 UserInterfaceOnlyパラメータ True を指定すると、画面上からの変更は保護されますが、マクロからの変更は保護されません。 使用例　ActiveSheet.Protect UserInterfaceOnly:=True
こんにちは。 >印刷範囲設定のエラーが出ます。 印刷範囲は、ここでの話の中では、A1:C8 までだったと思いますが、 ページレイアウト－印刷範囲は、これに関わらず、基本的なことですから、かならず入れるようにしてください。 失礼ですが、その後の説明しても、説明から実際に形づけるのは難しいと思いましたしので、ファイルをアップしました。そちらを御覧ください。 http://bit.ly/28Mw84l 16/06/21 08:46:28　　7日　までです。 パスワードは、ここのアドレスの.htmlの前の7桁の番号です。 ダウンロードした後、右クリックして、プロパティで、「ブロック解除」して、「OK」を押してください。 ここの掲示板で書いた内容とは、違う部分があります。また、ここの掲示板で書かれた私のマクロは、重大なミスがありましたので、訂正版を載せておきます。返って、使わなくてよかったと思います。急遽作りなおしましたので、不備があるかもしれません。試験的に印刷してから試してください。 画像をみると、オートシェイプが置かれて、その中に数字を入れるようになっているようです。ただ、その書式は、分かりませんので、こちらの想像で作らせていただきました。なお、私自身、最初想定していたものよりも、難しい内容だと感じました。 余計な話ですが、このチケットにオリジナル画像やパターンをつけると、偽造防止になるのではないかと思いました。 '// Private Declare Sub Sleep Lib "kernel32.dll" (ByVal dwMilliseconds As Long) Sub PrintMacro() 　　Dim i As Long 　　Dim iStart　　As Long, iEnd As Long 　　Const PREV As Boolean = False　　'True =プレビュー 　　iStart = 1　'最初の番号 　　iEnd = 140　'最後のページ 　　On Error GoTo ErrHandler 　　Application.EnableCancelKey = xlErrorHandler 　　With ActiveSheet 　　　　If .PageSetup.PrintArea = "" Then 　　　　　　MsgBox "このマクロは、印刷範囲を設定していないと、実行できません。", vbExclamation 　　　　　　Exit Sub 　　　　End If 　　　　For i = iStart To iEnd 　　　　　　 Call NumberInShape(i) 　　　　　　.PrintOut , , , PREV 　　　　　　Sleep 500 　　　　　　DoEvents 'この2行を割り込み中止を入れやすくさせるためです。 　　　　Next i 　　End With 　　Application.EnableCancelKey = xlInterrupt 　　Exit Sub ErrHandler: 　　MsgBox i & " :中途で止まりました。" 　　Application.EnableCancelKey = xlInterrupt End Sub Sub NumberInShape(ByVal i As Long) Dim shp As Shape Dim t1 As String Dim t2 As String 　　 t1 = CStr((i - 1) * 2 + 1) 　　 t2 = CStr(i * 2) 　　 For Each shp In ActiveSheet.Shapes 　　　　　　 If LCase(TypeName(shp.DrawingObject)) = "rectangle" Then 　　　　　　　　 If shp.TopLeftCell.Address(0, 0) = "A1" Then　　'オートシェイプの位置 A1 　　　　　　　　　　　　shp.DrawingObject.Text = t1 　　　　　　　　 ElseIf shp.TopLeftCell.Address(0, 0) = "A5" Then　　'オートシェイプの位置 A5 　　　　　　　　　　　　shp.DrawingObject.Text = t2 　　　　　　　　 End If 　　　　　　 End If 　　 Next shp End Sub '//
こんばんは！ VBAになりますが一例です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）B2～B11セルのデータを変更してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) 'この行から// Dim c As Range, myStr As String If Intersect(Target, Range("B2:B11")) Is Nothing Then Exit Sub Range("B13").ClearContents For Each c In Range("B2:B11") If c <> "" Then myStr = myStr & c.Offset(, -1) & "," End If Next c If Len(myStr) > 0 Then Range("B13") = Left(myStr, Len(myStr) - 1) End If End Sub 'この行まで// ※　画像では「○」になっていますが、 「○」以外のデータが入れば（空白以外であれば） A列文字列が表示されます。m(_ _)m
A列の書式ルールとして「数式を使用して、書式設定するセルを決定」を選択し、 「T列が100以上199以下の場合、青色」のルールを設定、 「T列が200以上299以下の場合、赤色」のルールを追加、 「T列が300以上399以下の場合、黄色」のルールを追加します。
こういうことだろうか？ C1セルに =INDEX(1:1,MIN(IF(A1<>E1:J1,IF(B1<>E1:J1,IF(E1:J1<>"",COLUMN(E1:J1))))))&"" [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 対象が存在しない場合もあるならA列を挿入し、非表示にすればよい。 ただし、文字列の場合のみ
WindFallerさん、すごいですね。この質問で、そこまで読みましたか～！！ 私は、てっきりテキストボックス内の文字列をクリアするだけだと思っていたので、次のような回答をするつもりでした（しちゃいましたけど･･･）。お恥ずかしい限りです。 Private Sub CommandButton2_Click() TextBox1.Text = "" End Sub
全角文字を混ぜると半角文字も横になる。 半角文字だけの入力で、文字が横にならないと言っているのではないだろうか。 全角の空白文字を最後に付けると良いでしょう。 半角の数値の場合は…そもそも横にする必要ないような気もするが...。 セルの書式設定で「配置」を縦にしたのちに、そのセルをコピーして、「リンクされた図」として貼り付けてから回転させる。
こんな感じです。 コメントが付いている4行が追加になってます。 Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean) If Not SaveAsUI Then Exit Sub '上書き保存の場合は何もしない。 Application.EnableEvents = False 'イベント発生を抑止する。 Dim fName As String fName = Range("A1").Value & Range("C8").Value & Range("H8").Value & Range("H10").Value Application.Dialogs(xlDialogSaveAs).Show Arg1:=fName Application.EnableEvents = True 'イベント抑止を解除する。 Cancel = True '本来の保存動作は不要なのでキャンセルする。 End Sub
とりあえず、こんな感じでしょうか。 纏めのシートは、1種類目のシート（Sheet1)に、欠席数（合計のみ）と出席数の項目を追加したイメージです。 理由毎の欠席数を表示したい場合は、考え方を変えなければならないのですが…。 ピボットテーブルについては、イメージが分からなかったので作っていません。 ちなみに、Sheet2にあって、Sheet1に無いものは無視されます。Sheet2を入力する際は、その辺のチェックを入れた方が安全です。 Sub sample() Dim ws As Worksheet Dim I As Long Sheets("Sheet1").Copy After:=Sheets(Sheets.Count) Set ws = ActiveSheet ws.Cells(1, "D") = "欠席" ws.Cells(1, "E") = "出席" With Sheets("Sheet2") For I = 2 To ws.Cells(Rows.Count, "A").End(xlUp).Row ws.Cells(I, "D") = WorksheetFunction.SumIfs(.Range("C:C"), _ .Range("A:A"), ws.Cells(I, "A"), .Range("B:B"), ws.Cells(I, "B")) ws.Cells(I, "E") = ws.Cells(I, "C") - ws.Cells(I, "D") Next End With End Sub
こんばんは。 >名前をつけて保存を押したときに まさか、既存のボタンを書き換えるという話ではないでしょうね。 既存ボタンやCtrl+S を使う場合は、クラス・インスタンスが必要になります。既存のボタンを書き換えることはお薦めしません。新しいボタンなら大丈夫です。 私は、クイック・アクセス・ツールバーに、似たような形のものを置いています。マクロブックかどうかを判定してから、xlsx か、xlsm の拡張子を決めます。 今回は、これも、私にとってはなかなか難しい質問ですね。 ファイル名には、いくつかの規則が必要ですが、GetSaveAsFilename がファイル名チェッカーの代わりをしてくれます。 なお、以下のマクロは、個人用マクロブックなどに入れることをお薦めします。そのままですと、自ブックですと、マクロを捨てることになります。 一般的には、ActiveWorkbook だと考えています。 '// Sub BookSaveAs() Dim x, i As Long, fn As Variant On Error GoTo ErrHandler x = Range("A1:D1").Value For i = 1 To UBound(x, 2) fn = fn & Trim(Replace(x(1, i), "/", "", 1)) Next i fn = Application.GetSaveAsFilename(fn, "Excelファイル(*.xlsx),*.xlsx", , "ファイル保存") If VarType(fn) = vbBoolean Then Exit Sub Application.DisplayAlerts = False ActiveWorkbook.SaveAs fn, _ FileFormat:=xlWorkbookDefault Application.DisplayAlerts = True Exit Sub ErrHandler: MsgBox Err.Number & " " & Err.Description End Sub '//
一例です。 If InStr(Range("A1").Value, "Y") > 0 Or InStr(Range("A1").Value, "y") > 0 Then
このマクロが何をやっているのか理解できなかったのですが、ご質問の通り、A列のリンクをクリックした場合のみ、処理したいのであれば、次の判定を入れてみて下さい。 Private Sub Worksheet_FollowHyperlink(ByVal Target As Hyperlink) If Target.Range.Column <> 1 Then Exit Sub （以下、記載のままで） 上記条件の意味は、「クリックしたセルが1列目（A列）でなければ、Subを抜ける」です。
連動したドロップダウンリスト−INDIRECT関数 http://www.relief.jp/itnote/archives/000822.php ということかなぁ
No3です 4/30-5/1　=　-1　マイナスの場合まで　0　にしてしまいました。 質問を読み違いました、No1さんに賛成します。 失礼しました。
No.4です。 ＞検索結果が１行しかでません。。。 もしかして配列数式になっていないのでは？ 数式が入っているB5セルを選択 ①　F2キーを押下 ②　B5セルをダブルクリック ③　数式バー内で一度クリック 上記①～③の中のどれかの操作をしてください。 編集可能になりますのでCtrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 ※　数式をいちいち入れるのが面倒であれば、 前回回答した画面から数式をドラッグ＆コピー　→　B5セルを選択　→　数式バー内に貼り付け　→　そのままCtrl＋Shift＋Enter！ 最後にB5セルのフィルハンドルで列・行方向にコピー！ これではどうでしょうか？ 以上の操作でもお望みの結果にならない場合、考えられるコトといえば ・　F2セルのSheet名が存在していない。 ・　4行目の項目名が各シート1行目の項目名と同じものになっていない。 ・　各シートの配置が統一されていない。 といった原因が考えられます。 今一度確認し、どのような結果が表示されたのかをお示し頂ければ 具体的なアドバイスができるかと思います。m(_ _)m
No.1です ごめんなさい。 手順が抜けていました。 ④D4セルには「=LARGE($K3:$M3,1)」と入力しD6までフィルコピー ⑤F4には「=LARGE($K3:$M3,2)」、H4には「=LARGE($K3:$M3,3)」としてフィルコピー
恐らく書式設定の問題だと思いますが，例えばROUNDUP，ROUNDDOWN関数を入れたセルに適当な数値を入れてみて下さい． 例えばA8にROUND関数（質問文での2007.50）が入っていたとしたら，そこに1を入力すると"1.00"って表示されるのであれば，間違いなくセルの書式設定が問題ですね． それに平均の部分も数値としては2007.5が答えだと思いますが，ここも書式設定が変わっていると思います． セルの書式設定は問題のセルを選択した状態で，Ctrl+1（キーボードのFunctionキーの下にある方の1，テンキーの方ではない）を押すとセルの書式設定のウィンドウが出てきます． おそらく，表示形式が数値の小数点以下の桁数が適切ではないと思いますので，ここを直すか，分類を標準にすれば解決すると思います．
ご質問の機能とは程遠いのですが、ご参考までに･･･。 下記のVBA（sample）を標準モジュールに張り付けて下さい。 その後、シートに図形を張り付けて、その図形に上記のマクロを割り当て（マクロの登録）をしてください。 図形をクリックするたびに、その形が変わっていきます。 図形を変更する元データをシート上のセルから取得するようにできれば、haku-see1231さんのやりたいことが実現できると思います。頑張ってください。 Sub sample() Dim MyAutoShapeType As Variant With ActiveSheet.Shapes.Range(Array(1)) MyAutoShapeType = .AutoShapeType + 1 If MyAutoShapeType > 109 Then MyAutoShapeType = 1 .AutoShapeType = MyAutoShapeType .Width = 300 .Height = 200 .TextFrame2.TextRange.Characters.Text = MyAutoShapeType End With End Sub
ママチャリさんのコードは、ワークブックオープン時イベントへ記述してみて下さい。 エクセルを開けた瞬間にコードが実行されます。
[No.1お礼]へのコメント、 「左端のB列からN列まで」は了解。 私からのリクエスト「左端２列は上から何と入力されているかを教えて」にはどうしてダンマリなの？
冗長過ぎて役に立たないタイトルです。 なぜならこの部屋の看板は「教えて！goo >デジタルライフ >ソフトウェア >Excel(エクセル)」と書いてあるから”
前の質問での回答者です。 No.2さんが書いているように、改行したものを数式バーへと貼り付ける 場合は注意が必要です。 本来なら改行なしで貼り付けたほうが良いのですが、括弧の位置などで ＃NAMEエラーが出ることがあります。 No.2さんのように「=CONCATENATE(　」のように「=CONCATENATE」の 直後の改行を入れないで、記載したほうがエラーは出ないと思います。 前回の回答で、そのあたりを考慮しない数式を提示してしまいました。 私が検証したときには、 =CONCATENATE($AB$2,N2,$AD$2,$AC$2,O2,$AC$2, IF(P2<>"",$AE$2&"<p>"&P2&"</p><p>◆長さ "&P2&"</p>","" ), IF(Q2<>"","<p>"&Q2&"</p><p>◆軸径 "&Q2&"</p>","" ), IF(R2<>"","<p>"&R2&"</p><p>◆重さ "&R2&"</p>","" ), ====以下省略===== のようにしていました。 投稿するときに見やすさを考えて、意味のない改行をCONCATENATE 直後に入れてしまいました。 考慮しないで編集したものを投稿したことをお詫びします。 No.2さんの数式にするか、以下のように間違いにくいものにしたほうが 確実だと思います。 =CONCATENATE($AB$2,N2,$AD$2,$AC$2,O2,$AC$2, IF(P2<>"",$AE$2&"<p>◆長さ "&P2&"</p>",""), IF(Q2<>"","<p>◆軸径 "&Q2&"</p>","" ), IF(R2<>"","<p>◆重さ "&R2&"</p>","" ), IF(S2<>"",$AF$2&"<p>◆太さ "&S2&"</p>",""), IF(T2<>"","<p>◆ペン先材質 "&T2&"</p>",""), IF(OR(U2<>"",V2<>""),$AG$2,""), IF(U2<>"","<p>・"&U2&"</p>",""), IF(V2<>"","<p>・"&V2&"</p>",""), $AI$2) ちなみに、OR関数の使い方は問題ないと思います。
#NAME? は、関数名を間違えたり、指定する範囲を間違えたときに返ってくるエラーです。 次に、No.2でやった方法と同じやり方で、数式を分解する。 ＝INDEX( 　[試験一覧.xls]詳細!$B:$W 　,1/LARGE(INDEX(([試験一覧.xls]詳細!$N$3:$N$1000=$B$3)/ROW(A$3:A$1000),),ROW(A1)) 　,2.5*COLUMN(A1)-1) と分解し、 =[試験一覧.xls]詳細!$B:$W =1/LARGE(INDEX(([試験一覧.xls]詳細!$N$3:$N$1000=$B$3)/ROW(A$3:A$1000),),ROW(A1)) =2.5*COLUMN(A1)-1 とする。 さらに、 =1/LARGE(INDEX(([試験一覧.xls]詳細!$N$3:$N$1000=$B$3)/ROW(A$3:A$1000),),ROW(A1)) を =1/LARGE( 　INDEX(([試験一覧.xls]詳細!$N$3:$N$1000=$B$3)/ROW(A$3:A$1000),) 　,ROW(A1) 　) と分解し、 ＝INDEX(([試験一覧.xls]詳細!$N$3:$N$1000=$B$3)/ROW(A$3:A$1000),) =ROW(A1) さらに ＝INDEX( 　　　　　([試験一覧.xls]詳細!$N$3:$N$1000=$B$3)/ROW(A$3:A$1000) 　　　　,) …あれ？ ここで２つ気づいた。 INDEX関数の「範囲」の指定が間違っている。 そして、ROW(A$3,A$1000)って意味ねーぞ。 まさか、まさか…まさかの配列数式か！ 間違えている箇所が特定されました。 　　「Ctrlキーを押しながらEnterキーをおして確定してください」
こんにちは！ VBAになりますが一例です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて） マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long, k As Long, myAry For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row '▼A列を操作 myAry = Split(Cells(i, "A"), ",") For k = 0 To UBound(myAry) If InStr(Cells(i, "B"), myAry(k)) = 0 Then Cells(i, "A").Characters(Start:=InStr(Cells(i, "A"), myAry(k)), Length:=Len(myAry(k))) _ .Font.ColorIndex = 3 End If Next k '▼B列を操作 myAry = Split(Cells(i, "B"), ",") For k = 0 To UBound(myAry) If InStr(Cells(i, "A"), myAry(k)) = 0 Then Cells(i, "B").Characters(Start:=InStr(Cells(i, "B"), myAry(k)), Length:=Len(myAry(k))) _ .Font.ColorIndex = 3 End If Next k Next i End Sub 'この行まで// ※　データはA・B列にあるとしています。m(_ _)m
こんな感じでしょうか。たぶん、maaana513さんのイメージに一番近いと思うのですが、No.2 WindFallerさんのおっしゃるっとり、日付が増えた場合の拡張性がありません。もし、日付が増えるようならピボットテーブルを前提にした実装が簡単だと思います。 Sub Macro1() Dim ws As Worksheet Dim I As Long Dim LastRow As Long Sheets("Sheet1").Copy After:=Sheets(Sheets.Count) Set ws = ActiveSheet LastRow = ws.Cells(Rows.Count, "A").End(xlUp).Row With Sheets("Sheet2") For I = 1 To .Cells(Rows.Count, "A").End(xlUp).Row If ws.Columns("A:A").Find(.Cells(I, "A"), LookIn:=xlValues) Is Nothing Then LastRow = LastRow + 1 .Cells(I, "A").Copy Destination:=ws.Cells(LastRow, "A") .Cells(I, "B").Copy Destination:=ws.Cells(LastRow, "C") Else .Cells(I, "B").Copy Destination:=ws.Cells(I, "C") End If Next End With End Sub
こんにちは 求める仕上がりの程度にもよりますが、わざわざエクセルでというのは、「4輪自動車で2輪走行したい」というような気がします。 本来は目的にあったソフトを使用するのが良いと思いますし、無償のものもいろいろあるはずです。 とはいえ、事情があって（？）そのようなことをなさっている方もそれなりにいるようですので、トライするなら先達たちの方法を参考になさるのがよろしいのではないでしょうか。 以下は、「配置図」専用の方法というわけではありませんが… http://www.kyotodefudosan.com/xls_madori/xls_mad … http://www.civil-design.net/soft/dl/ http://vicdiy.com/assy_knowhow/009/009.html
手作業ですが、エクセルのフィルターオプションの機能をご存知でしょうか。 準備 Book1の一行目の項目部分をBook2にコピー 不要な列を削除 更に右側にでも　区分　をコピーして配置 その下に　="<>"　と入れておく フィルターオプションの作業 Book1、Book2を開いておく Book２から操作 リボン　データ　の中央ほどにある　詳細設定　をクリック 指定した範囲に　チェック リスト範囲　Book1のA~データのある範囲 検索条件範囲　区分を入れたセルと　="<>"　のセル 抽出範囲　　Book2の項目を入れている一行目 OK　ボタンを実行すれば、Book2で指定した項目で　区分が空白でない行が表示されます。 詳しくは、 http://www4.synapse.ne.jp/yone/excel2010/excel20 … 等を産駒にして勉強してみて下さい。 毎回操作が面倒なら、マクロの記録でコードが自動で作成できます。 次回からは、ボタンをクリックするだけで上記の操作が実行されるようになります。
①「B列」を選択して「列挿入」 ②「B1セル」に「=DATE(LEFT(A1,4),MID(A1,5,2),RIGHT(A1,2))」の式を入力 ③ 必要数コピー ④「B列」を選択してコピー ⑤「A列」を選択して、形式を選択して貼付で「値」貼付を行う ⑥ 書式を「yyyy.mm.dd」に変更する ⑦「B列」を選択して列削除を行う
簡単！簡単！ A8: =OFFSET(A$2,(ROW(A1)-1)/2,) B8: =OFFSET(B$1,,MOD(ROW(A1)-1,2)) C8: =OFFSET(B$2,(ROW(A1)-1)/2,MOD(ROW(A1)-1,2)) 範囲 A8:C8 を下方にズズーッとオートフィル
> 半角がほしいところだけ、’にしました CONCATENETE関数を使うときに文字列（スペースも含む）の場合は、 前後に、二重引用符で括る必要があります。 ですから、引用符で半角スペースを括るのは無意味です。 http://www.kokodane.com/kan19.htm [関数の引数]ダイアログでCONCATENETE関数を指定して、[文字列]の ボックスに半角スペースを入れてみれば、どのようになるのかを確認が できます。 それよりも、質問にあるIF文の整理をしたほうが良いのでは？ 例えば、P2セルが空白でない場合に以下の指定をしていますよね。 (if(P2<>"",$AE$2,"")), (if(P2<>"","<p>","")), P2, (if(P2<>"","</p>","")), (if(P2<>"","<p>",""), (if(P2<>"","◆長さ","")), (if(P2<>"","<p>","")), ' '　,← ここは間違い P2, (if(P2<>"","</p>","")), IF関数では、 　=IF(［論理式］,［真の場合］,［論理式］［真の場合］［偽の場合］)　 になります。 [論理式]の条件として「P2<>""」の指定式を、幾つも分けている意味は ないと思います。 ［偽の場合］は常に""になるのですから、それも一つにまとめたほうが 分かり易くなります。 ［真の場合］は、以下のようにまとめられます。 このようにまとめておけば、P2セルの指定部分と （分かり易いように、＆演算子の前後を開けています） $AE$2 & "<p>" & P2 & "</p>" & "<p>" & "◆長さ " & P2 & "</p>" （"◆長さ "にすることで、半角スペースも含むようにしています） これでも助長な書き方なので、もっと整理できます。 $AE$2 & "<p>" & P2 & "</p><p>◆長さ " & P2 & "</p>" ですから、IF関数を以下のように書くこともできます。 =IF(P2<>"",$AE$2&"<p>"&P2&"</p><p>◆長さ "&P2&"</p>","" ) または =IF(P2<>"",CONCATENATE($AE$2,"<p>",P2,"</p><p>◆長さ ",P2,"</p>","" ) このようにまとめておけば、P2セルの部分と"◆長さ"のような文字列の 部分を書き換えたものを続けるだけで済みます。 質問にあるようなhtml文章に組み立てる、という数式なら、 =CONCATENATE (($AB$2,N2,$AD$2,$AC$2,O2,$AC$2, IF(P2<>"",$AE$2&"<p>"&P2&"</p><p>◆長さ "&P2&"</p>","" ), IF(Q2<>"","<p>"&Q2&"</p><p>◆軸径 "&Q2&"</p>","" ), IF(R2<>"","<p>"&R2&"</p><p>◆重さ "&R2&"</p>","" ), ====以下省略===== のようになります。 IFの前後の括弧は不要なので、外しています。
「月度単位」ってどういう意味で「月度」って何と読むの？ ツキ・ド、ゲツ・ド、ガツ・ド、ツキ・タビ、ゲッ・タク？
No.2です。 気になったのでとりあえず作ってみました。 もう不要でしたらスルーしていただいて結構です。 ちなみに伝達事項としては ①購入履歴.xlsmには作業列を設けておりDM送付履歴へコピペしたデータには「コピペ済」と念のため記します。 ②該当データをDM送付履歴.xlsxへ貼り付ける際7行目から貼り付けていっています。既存データの削除処理は入れておりません。 ③DM送付履歴の上書き保存処理は入れておりません。 ④「I2 購入日」の入力パターンを３つ作ってみました。もし該当するものがあれば他の２つはクリアして下さい。該当するものがない時はゴメンナサイ。 Public Sub a() Dim buf As String Dim ym As String Dim cntALL As Double Dim r1 As Double Dim r2 As Double Dim cnt As Double '//------------------------------- 'ブック名の指定 Const bk1 = "購入履歴.xlsm" Const bk2 = "DM送付履歴.xlsx" '-------------------------------// '//------------------------------- 'シート名の指定(購入履歴) Const sn1 = "Sheet1" 'シート名の指定(DM送付履歴) Const sn2 = "Sheet1" '-------------------------------// '//------------------------------- '作業列の指定 Const wkR = "K" '-------------------------------// '//------------------------------- 'DM送付履歴の保存パス Const pth = "C:\xxx\" '-------------------------------// With Workbooks(bk1).Worksheets(sn1) '抽出年月の指定 buf = InputBox(Prompt:="抽出したい年月を入力してください。", Default:="yyyymm") '作業列をクリア .Columns(wkR & ":" & wkR).Select Selection.ClearContents .Range("A1").Select 'データ数の確認 r1 = 3 cntALL = 0 Do Until Len(.Range("I" & r1)) = 0 r1 = r1 + 1 cntALL = cntALL + 1 Loop '「ＤＭ送付履歴」を開く If Dir(pth & bk2) <> "" Then Workbooks.Open pth & bk2 Else MsgBox "『" & bk2 & "』の指定パスが正しくない可能性があります", vbExclamation End If '該当データのコピペ r1 = 3 r2 = 7 For cnt = 1 To cntALL 'パターン①：購入日が『yyyymmdd』の場合 ym = Left(.Range("I" & r1), 6) 'パターン②：購入日が『yyyy/mm/dd』の場合 ym = Left(.Range("I" & r1), 4) & Mid(.Range("I" & r1), 6, 2) 'パターン③：購入日が『yyyy/m/d』の場合 ym = Left(Format(.Range("I" & r1), "yyyymmdd"), 4) & Mid(Format(.Range("I" & r1), "yyyymmdd"), 5, 2) If buf = ym Then Workbooks(bk2).Worksheets(sn2).Range("E" & r2) = .Range("E" & r1) Workbooks(bk2).Worksheets(sn2).Range("F" & r2) = .Range("F" & r1) Workbooks(bk2).Worksheets(sn2).Range("G" & r2) = .Range("I" & r1) Workbooks(bk2).Worksheets(sn2).Range("S" & r2) = .Range("J" & r1) .Range(wkR & r1) = "コピペ済" r2 = r2 + 1 End If r1 = r1 + 1 Next End With End Sub
問題を勘違いしているかもしれませんが、こういうことで良いのでしょうか？ 1行目がタイトル2行目からデータとして、I2セルに以下の式を入力、最終行までフィル。 　=IF(J2="",COUNTIFS(D$2:D2,D2,J$2:J2,""),"")
No.3の回答者の回答をパクっただけです。 最後の小間の時間数もわかるように枠をつけただけです。 Public Sub a() Dim r As Integer Dim i As Integer Dim cnt As Integer Dim j As Integer Dim jikanwaku As String 'A列にデータが存在るする行数を調べる＆B列にも数値が入力されていることを確認 r = 1 Do While Len(Range("A" & r)) > 0 If Not IsNumeric(Range("B" & r)) Or Len(Range("B" & r)) = 0 Then MsgBox "B" & r & "に数値が入力されていません" Exit Sub End If r = r + 1 Loop r = r - 1 'A1にデータがない時は終了 If r = 0 Then MsgBox "A1に入力されていません" Exit Sub End If 'まずは最初に時間割を書く左端になるD1位置を初期設定 j = 4 '順次処理 For cnt = 1 To r '小間名を記入 Cells(1, j) = Cells(cnt, 1) '時間枠を描く jikanwaku = Cells(1, j).Address & ": " & Cells(1, j + Cells(cnt, 2) - 1).Address Range(jikanwaku).Select Selection.Borders(xlEdgeLeft).LineStyle = xlContinuous Selection.Borders(xlEdgeTop).LineStyle = xlContinuous Selection.Borders(xlEdgeBottom).LineStyle = xlContinuous Selection.Borders(xlEdgeRight).LineStyle = xlContinuous '次の時間枠の左端になる位置を設定 j = j + Cells(cnt, 2) Next End Sub
こんにちは Excel-VBAでは「呪文のようなコード」ではなく、 「検索ｰ置換」を手作業でなくVBAで行う“だけ”の作業になってしまいます。 …変換テーブルを作っておいて変換する …変換テーブルを自動で作ろうとすると、そのためのVBAを組まなければならない と言う状況だと思います。
No.2 ママチャリです。すいません。色を変える部分を失念しておりました。 色を変えるには、色の数の分だけ条件付き書式を指定する必要があります。 こんな感じです。 =COLUMN()-4<SUM($B$1:$B$1)　赤 =COLUMN()-4<SUM($B$1:$B$2)　緑 =COLUMN()-4<SUM($B$1:$B$3)　黄 　・ 　・ 　・
こんばんは ＞業務ではなく知人から頼まれたものなのでデータ自体どういうものなのかは不明です。 ダミーのデータなので、原因が分かりません。 ただ、並べ替えの列の優先順位が関係していそうです。 例えば「A列の値が同じならば、C列の値によって並べ替える」ということも設定できます。 もしかしたら、列の優先順位の設定がうまくいってないのかも知れません。
ＮＯ.2です。 細かい説明をしませんが、 未開封のオフィスでない場合は確認が必要です。 まず、最初にメーカーサイトで、その型版のセット品スペックなどをみるといいです。 次に、その対象のオフィスと一致するバージョンのソフトがついてくるのかどうか。 違う場合は、ネットで認証手続きするまで、使えるかどうかが不明です。 ＰＣにセットでついている正規品と呼ばれるソフトは、そのＰＣだけに使えるものとなります。 他のＰＣでは使えないのでご注意ください。 ですから、一度でも使われたソフトであり、インストールされている状態の場合は 他者が、登録したままの状態であり、そのＰＣ内に入っているソフトと 付属される中古のソフトが同じものかどうかであることがチェックポイントです。 さらに、認証手続きが完了していない状態で受け取り、結果認証されないという可能性が 心配です。 ですので、認証手続きまで終わっているかどうかも確認ポイントです。普通はしてないとおもいます。 販売者が素人である場合、悪意がある場合は、この辺がトラブルになりやすいです。
こんにちは。 >残念ながら中身は理解できません。 私も全体は理解していません。ただ、あのコードを研究尽くした人たちがいるということは事実です。しかし、それでも、概形ぐらいしか分かりません。 別カテで、VBAの設計のような話が、ベテランと思われる方の発言がありました。多くの方は、つまり、全体の設計を描いていからだとおっしゃっています。でも、VBAとかいうものは、そういうものではないと思うのです。個人が一人で作るもので、担当の割り振りが決まっているわけではありません。 「いきなり部品図を描き、そのあとAssy図、全体図を描いている」 まったく他人からみたらそのとおりです。 実は、VBAマクロというのは、私の持論で、こうしたものは心臓部から作っていくという方法なのです。心臓が作れないものは、NGなので、どんなに立派な構想があろうとも、何の意味もありません。だから、最初に、心臓部から作り始めるのです。テクニック優先なのです。 例えば、シートで値を検索するのに、ふつうは、Findメソッドを使うと思うのです。そこがあやふやだったり、それを他に置き換えて、コードを構築するというのは、私などからするとありえないと思えるのです。定石と定石外しという言葉がありますが、VBAプログラムなんていうものは、ほとんど定石でやったほうが楽だし、それを独自路線、つまり定石外しなんて試みたところで、素人ではうまくいくわけがないと思います。 >フレーム構築から最後のコーディングに至る手順というものに関して、参考になりそうな書籍なりサイトをご存知でした それは、「構造化プログラミング」だと思うのです。VBAにそれほど仰々しいものは存在しません。 今は時代が違うとは思っていても、VBAなどは、これを抜きにしては扱えませんね。 放送大学などでも、特別大きく取り上げなくなったもののようです。それでも、Basic 系には不可欠な考え方です。 http://www2.cc.niigata-u.ac.jp/~takeuchi/tbasic/ … 例えば、ここのサイトは、旧VB6 なので、そのものずばりだという感じがします。(内容的には古臭いかもしれませんが、VBAの中で生きています。） 『構造化プログラミングについてまとめ』 •構造化プログラミングはプログラムを書く上での基本的作法である。 •現在の色々なグ技法や手法は全てこの作法の延長線上にある。 •大きなプログラムを書く上で構造化プログラミングは必須である。 •小さいプログラムを書く上でもこの作法は有効 •構造化プログラミングの精神を理解して，構造化プログラム言語を使う こんな話は、仕事やコーディングには直結しませんが、かなり勉強にはなります。ある程度の長年やっている人は、一度はこんなものを目に通しています。
まずは、同じシートでやってみるとよいです。 違うシートに取り出す場合は、取り出す項目の書かれたシート上で始めます あらかじめ添付図のように項目を書いておきます(コピペの方が確実) リスト範囲：A:E 検索条件範囲 : G3:H4 抽出範囲 : J3:K3
「="="&TEXT(L14,"#,###")&" ×";&TEXT(M12,"#.#0")&"%"&" ×50%"」では？
梅雨で湿度が高くてボケてんなぁ 列の挿入しなくてもいちばん右に付け足せばよい。 ですm(_ _)m
「=IF(A1+A2<20,IF(A1+A2<10,3,5),8)」ですかね？
マクロで、できるかどうか、今回のご質問だけでは、誰にも言えないと思います。 >ハイパーリンクにポインタをあてると、file///¥¥〇〇¥△△¥と表示されますが、 ポップアップで、見えているものは、論理的なアドレスです。 論理的アドレスは、システム上で、おそらくはそうだと思われる表示をしているだけですから、実体がありません。だから、ファイルと相対関係の位置になっているはずです。 例えば、手動で、今、書き換えようとして、ハイパーリンクの編集で、書き換えようとしているとか、物理的な書き換えがある、実体のあるものでなければ、無理だと思います。 ただ file///¥¥〇〇¥△△¥ を file///¥¥〇〇¥ にするというのでしたら、ファイル－プロパティ－プロパィの詳細 ファイルの概要 ハイパーリンクの基点　の部分に、 ¥¥〇〇¥ と入れれば直るはずです。
あまりいい方法ではないかもしれませんが これでいかがでしょうか Public TargetBook As Workbook Public tblBuf() Public lngT As Long Public Sub psubGetData() Dim lngR As Long 'Get Rows Dim lngC As Long 'Get Column Dim lngS As Long 'Set Rows Set TargetBook = Workbooks.Open("Book1.xlsx") ThisWorkbook.Activate lngT = 0 ReDim tblBuf(6, lngT) With TargetBook.Sheets(1) For lngR = 1 To 100 lngT = lngT + 1 ReDim Preserve tblBuf(6, lngT) For lngC = 1 To 5 If .Cells(lngR, lngC).Interior.Color = vbRed Then Debug.Print "R = " & lngR & ", C = " & lngC tblBuf(lngC, lngT) = .Cells(lngR, lngC).FormulaR1C1 tblBuf(6, lngT) = 1 End If Next Next End With lngS = 1 With Sheet1 For lngR = 1 To 100 If lngT < lngR Then Exit For If tblBuf(6, lngR) = 1 Then lngS = lngS + 1 For lngC = 1 To 5 If tblBuf(lngC, lngR) <> "" Then .Cells(lngS, lngC).FormulaR1C1 = tblBuf(lngC, lngR) End If Next End If Next End With TargetBook.Close End Sub ただし、book1の部分はフルパスで記載しないと上手く動かないようです
くっつける文字列が固定なら TEXT(…)&"-1" などのように後ろにくっつければいいと思いますけど。
Dim i As Long 　 For i = 3 To 38 　 　 If Cells(2, i) = "" Or Cells(2, i) = 0 Then 　 　 　 Cells(4, i) = 0 　 　 Else 　 　 　 Cells(4, i) = 1 / Cells(2, i) * 1000 　 　 End If 　 Next i ISNULL関数 http://officetanaka.net/excel/vba/function/IsNul …
検証してみましたが、 そのコード自体では、「型が一致しません」というエラーは発生しないように思います。セルにエラー値が存在した場合のみのようです。 VBAでは、エラー値と文字列の比較は、データ型が違うので比較できません。#1さんのように、最初にエラーを排除して検査するのが常套手段だと思います。 もちろん、VBAで、ワークシート上にエラー値を置いたまま、検査させるかどうかは、また状況によって変わりますが。 あえて、厳密に文字列を比較をさせるなら、本来は、以下のようにするのですが、VBAでは、そこまでは要求していません。 If CStr(Cells(i, 1).Value) = "" Then Rows(i).Hidden = False なお、Cells や Rangeのプロパティに.Value を入れたほうがよいのは、環境によって暗黙のプロパティのValue が決定されないことがあるからです。
続けてお邪魔します。 ＞C列の全部、もしくは一部が書き換わったときにマクロが起動してほしいと思っており・・・ というコトはChangeイベントではなく、やはりコマンドボタン等を配置し ご自身でマクロを実行された方が良いと思います。 どうしてもChangeイベントでやりたい場合は、前回のコードの ＞If Intersect(Target, Range("C:C")) Is Nothing Or Target.Count > 1 Then Exit Sub を ＞If Intersect(Target, Range("C:C")) Is Nothing Or Then Exit Sub にしてみてください。 ※　ただC列データ変更があるたびにマクロが実行されてしまい、 「消耗品、工具」のデータがない場合でもメッセージボックスが表示されますので 煩わしいと思います。 ＞MsgBox "完了" と ＞MsgBox "該当データなし" の行を削除したらどうなりますか？ ※　未検証です。m(_ _)m
１．元のSheetの必要のない列を「非表示」にする。 ２．元のSheetのB列で「並べ替え」をする。 ３．Ctrlキーを押しながらGキーを押し「ジャンプ」ウインドウを開き「セル選択」を選ぶ。 ４．「可視セル」選択を選んで、「OK」ボタンをクリックする。 ５．必要な行を選択して「コピー」する。 ６．貼り付け先のセルを選択して「貼り付ける」 ７．必要な行が残っていれば５へ戻る。必要な行をすべてコピーして貼り付けたら終わり。 この一連の操作で良いと思いますが...。 ※「非表示」にするのは、のちに行う「可視セル」だけを選択するための伏線です。 　「並べ替え」を行うのはコピーする範囲を選択しやすくするためです。 難しいことを考えず、都度処理を行えばよいと思います。 これらはExcelの基本操作ですので、まずはこういった基本操作を覚えるようにしてはいかがでしょうか。 そうすれば関数やマクロで分からないことがあっても、手動で何とでもできるようになります。 特に一回限りの操作を関数やマクロを使った方法で考えるよりも、早く作業を終えることができるようになるでしょう。
とりあえず、B~Z列を対象に式を作ってみました。 ただ、制限事項が多いので、使い物になるのやら… =INDEX(B1:Z1,,COUNT(B1:Z1)-1)-INDEX(B1:Z1,,COUNT(B1:Z1)) （制約事項） B列から左詰めで入力されている必要があります。途中に空白セルがあってはいけません。入力されているのは数字のみとします。
質問文の最初の２行は無駄というか邪魔です。 なぜなら此処には「Excel(エクセル) 」の看板があるから。
というか、正しく式が入っても「数値」は出ないと思うんですが… 新しい質問を立てたなら、きちんと断って閉じてくださいね。
http://matome.naver.jp/odai/2141087133639638101 がそのまま当てはまりますね。 >セルo3に番号を入力 が連番なのが条件ですが、 Dim 番号 As INteger 　For 番号 = <印刷したい一番小さな番号> To <印刷したい一番大きな番号> などと変更すればよいはずです。
1. まず「グラフの作成ファイル」を開く。 2. C19にマウスカーソルを置き、マウスの左ボタンを押しながらE30までカーソルを移動してマウスボタンを放す。 　C19からE30まで色が変わって選択される。 3. [Ctrl]を押しながら[C]を押す。 　選択範囲（C19からE30まで）がクリップボードにコピーされる。 4. G19にカーソルを移動してマウス左ボタンをクリック(押す)。 　=RANK.EQ(C19,$C$19:・・・と入力。 5. マウスカーソルをG19セルの右下隅におくとカーソルの形が十字になるので、左ボタンを押しながらカーソルをG30まで移動して左ボタンを放す。 　G19からG30までG19へ入力された式がコピーされる。 　ただし、「C19」部分はG20ではC20,G21ではC21・・・のように自動で変更される。 6. H19セルにマウスカーソルを置き左ボタンを押す。 　=RANK.EQ(D19,$D$19:・・・と入力。 7.　5.同様の操作でにH19からH30までドラッグ(フィル) 8. I19セルについて　4.からと同様に操作。 こんな感じで分かりますか？
私としては、ずいぶん長い間、こういうマクロはやったことがなかったのですが、ボケていなかったようで安心です。本日、雨天ですので調子がよいのです。 さて、真ん中……？ 継ぎ足しですが、こんなふうに計算して入れました。ただし、画像よりもセルが小さい場合は、働きません。(画像の一番下と次のセルの間を計って、その半分を上からずらす。横も同様です） '// Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) 　　Cancel = True 　　Dim myCur As String 　　Dim myPath As String 　　Dim PicFile As Variant, objPic　　As Shape 　　Dim h As Double, y As Double, d As Double, w As Double, x As Double 　　Dim oPDO As Object 　　If Intersect(Target, Range("A11,A24,A37,A50,I11,I24,I37,I50,Q11,Q24,Q37,Q50")) Is Nothing Then GoTo EndLine 　　'［ファイルを開く］ダイアログボックスを表示 　　myCur = CurDir 　　myPath = CreateObject("Shell.Application").Namespace(&H27).Self.Path 　　ChDir myPath 　　PicFile = Application.GetOpenFilename("画像ファイル,*.jpg;*.jpeg;*.gif;*.tif;*.png;*.bmp;*.emf;*.wmf,すべて,*.*", , "画像選択") 　　If VarType(PicFile) = vbBoolean Then Exit Sub 　　Application.ScreenUpdating = False 　　'画像を挿入 　　'Set objPic = ActiveSheet.Pictures.Insert(PicFile) 　　Set objPic = ActiveSheet.Shapes.AddPicture(PicFile, False, msoCTrue, Target.Left, Target.Top, 110, 150) 　　With objPic.DrawingObject 　　　　.ShapeRange.LockAspectRatio = msoFalse 　　　　.Left = Target.Left 　　　　.Top = Target.Top 　　　　.Height = Application.CentimetersToPoints(3.9) 　　　　.Width = Application.CentimetersToPoints(5.2) 　　End With 　　Set oPDO = objPic.DrawingObject 　　With Target　　'真ん中に置くための計算 　　　　h = .Top + oPDO.Height 　　　　y = .Offset(1).Top 　　　　If y > h Then 　　　　　　d = (y - h) / 2 　　　　　　oPDO.Top = .Top + d 　　　　End If 　　　　w = .Left + oPDO.Width 　　　　x = .Offset(, 1).Left 　　　　If x > w Then 　　　　　　d = (x - w) / 2 　　　　　　oPDO.Left = .Left + d 　　　　End If 　　End With 　　Application.ScreenUpdating = True EndLine: 　　If myCur <> "" Then 　　　　ChDir myCur 　　End If End Sub '
すみません、訂正です。 ×各数式最後の「,1,"")」の部分を、火曜なら「,2,"")」、水曜なら「,3,"")」と ○各数式最後の「=1),1,"")」の部分を、火曜なら「=2),1,"")」、水曜なら「=3),1,"")」と
=IFERROR("("&INDEX(Sheet1!A:A,MATCH(B1,INDEX(Sheet1!B:D,,MATCH(A$1,Sheet1!B$1:D$1,0)),0))&")","")
こんな感じでしょうか。 ちなみに、下記のマクロで改行が入るのは、定数が入力されているセルのみです。数式を使っているセルは、数式を直して対応してください。 Sub sample() Dim r As Range For Each r In Cells.SpecialCells(xlCellTypeConstants, 23) If Right(r.Value, 1) <> vbLf Then r.Value = r.Value & vbLf Next End Sub
マクロを使わずとも、関数で出来る場合もあります。 使える関数はこちら http://excel-ubara.com/excel3/EXCEL026.html あとはもう少し具体的な補足を加えてください。
シート１（基礎データシート）に、氏名や資格、品名などの全ての情報を集約しようとしているようですが、それって必要ですか？別々に管理しておいた方が拡張性があると思いますよ。 基礎データには、社員番号、氏名、所属、入社日だけを管理すべきと思います（勤続年数は、毎年変わるので、都度、入社日から計算すべきです）。 その上で、資格シートには社員番号と資格の情報を入力し、氏名などの基礎データは、社員番号をキーにVlookup関数で基礎シートから持って来れば良いでしょう。 品名シートも考え方は同様です。 そうしておくと基礎シートの所属を変えれば、他のシートにも連動します。並び替えは都度、行う必要がありますが、マクロを組んで全体を同期させるより簡単だと思います。 1点、面倒なのは、基礎データに社員を追加した場合、他のシートにも社員番号を入力しなければならないことくらいです。
MATCH関数とINDEX関数になるのだろう。 ＞上のように階段状に”○”はついています。 と言うことなので、”○”は連続していると判断します。 表１がSheet1にあり、 製品名がA列、 日数がB列の2行目から、 表２がSheet2以降にあり、 A1セルに日数が、 A2セル以降に装置名が、 それぞれ記入されているなら、 Sheet2のB2セルに記入する数式は次のように考える。 ＝MATCH("○",Sheet1!B:B,0) これでSheet1のB列に"○"が入力されているセルが上から何行目にあるのかを判断できる。 ＝COUNTIF(Sheet1!B:B,"○") これでSheet1のB列にいくつ"○"が入力されているのか判断できる。 ならば、 Sheet2のB2セルには ＝INDEX(Sheet1!A:A,MATCH("",Sheet1!B:B,0),0) ただし、１つも"○"が無いことを考慮してIF関数で処理することを考える。 また1つ以上ある場合も考慮する。 …と、次のようになる。 Sheet2のB2セルには ＝IF(COUNTIF(Sheet1!B:B,"○")>0,　INDEX(Sheet1!A:A,MATCH("",Sheet1!B:B,0)+0,0)　,"") Sheet2のC2セルには ＝IF(COUNTIF(Sheet1!B:B,"○")>1,　INDEX(Sheet1!A:A,MATCH("",Sheet1!B:B,0)+1,0)　,"") Sheet2のD2セルには ＝IF(COUNTIF(Sheet1!B:B,"○")>2,　INDEX(Sheet1!A:A,MATCH("",Sheet1!B:B,0)+2,0)　,"") Sheet2のE2セルには ＝IF(COUNTIF(Sheet1!B:B,"○")>3,　INDEX(Sheet1!A:A,MATCH("",Sheet1!B:B,0)+3,0)　,"") ・・・ とつづく。（※IF関数の条件による違いが分かりやすいよう全角のスペースを挿入しているので適宜省略して下さい） ちなみにこの数式を使っての動作は未確認です。 正しく動かないときには、自身で修正してください。たぶん難しくなないと思います。 （その場合、できれば修正した数式を「補足」や「お礼」に書いていただけると、他の人の参考になると思いますのでよろしくお願いします） この数式は、”B:B”が「１日」に対応しています。「2日」は”C:C”、「3日」は”D:D”に置き換えると他の日数でも使用できます。 ＝MATCH(A1,Sheet1!2:2,0) これでSheet1の何列目に”1日”が入力されているのかが判断できる。 …ので、上記の式の”B:B”の部分を”日”に自動対応させた数式にすることもできるのですが、その点は宿題として自身で工夫してみてください。 （処理の理解をするには、いったんこのくらいで区切ったほうが良いと判断した結果です。申し訳ありません）
No2です 10sheetなら =Sheet2!A1&Sheet3!A1&Sheet4!A1&・・・・・・・&Sheet10!A1 まで追記してください。
こんにちは はい、すみません、当方も確認しました。ダメでした。すみません。 懸念していた部分がしっかり引っかかりました。 念のため確認してから投稿すべきでした。 回答はLookupでは"このまま"では"不可"ですね。 実際には、B列を昇順に並べ変えるとできます。 Lookupは検索対象が記載されている部分が昇順でないと正確に機能しないみたいですね。
No.1さんの補足のような形になりますが、 「折り返して全体を表示する」が有効な場合は、 列幅の自動調整はできません。 必要なら、そのセルだけ解除して、そのセルを選択した状態で、 書式⇒列幅の自動調整 の手順かと思います。
ループにおける最終行の判断を　Do Until Worksheets("aaa").Cells(i, 9) = ""　としていますが、この条件に「可視行であったら」を追加してはいかがでしょうか。 こんな感じです。 Do Until Worksheets("aaa").Cells(i, 9) = "" And Worksheets("aaa").Cells(i, 9).EntireRow.Hidden = False もう1点、致命的なミスがあります。変数 i をカウントアップする場所は、Enf IFの外です。Elseの中に書いてしまうとカウントアップされない場合があるので、永久ループに陥ります。 これだけ直せば、とりあえず目的の動作になると思います。
E2: =(C2+D2-(A2+B2))/"1:0" 書式は 0.0 【老婆心】 》 23.0と表現したい シッカリしてねッ！
Excel2007以降ならば１ヶ月前は「=EDATE(TODAY(),-1)」になります。
#2の続きです。 OpenSolver を試してみました。 Solver とほぼ同じなので、64bit も32bit もサポートしていることも確認しました。ひとつだけ、デフォルト？(cbc.exe)が含まれていないので、インストールしなければなりません。それでデフォルトというのはおかしいのですが。 そこで、今、使えるエンジンで試してみましたが、結果はちゃんと出るものの遅いのです。しかし、そのデフォルトの、cbc.exe のまとまりをダウンロードして、インストールしましたが、何か足りないものがあって、エラーが出てしまいます。 手作り感が強くて、これをまともに動かすには時間がかかりそうな気がします。 どうやら、ちゃんと、そこのサイトを読まないといけないようです。 http://opensolver.org/ •OpenSolver offers a range of solvers for use in Excel, including the excellent, Open Source, COIN-OR CBC optimization engine which can quickly solve large Linear and Integer problems. https://projects.coin-or.org/Cbc しかしながら、 http://stackoverflow.com/questions/32074259/use- … で書かれているように、このツールをフルに使いたい場合、複雑なライセンスなので、やはりあちらこちらから集めなくてはならないのですが、登録が必要だったりと、容易には揃え切らないようです。
添付図参照 Sheet2!B2: =IFERROR(INDEX(Sheet1!$A$1:$A$100,SMALL(IF(Sheet1!$B$2:$B$100=$A2,ROW($2:$100),""),B$1)),"") 【お断り】上式は配列数式として入力のこと
たとえば「6:00」となっているセルを選択した時に、数式バーにはどのように表示されますか？ ①「'6:00」文字列で入力されてしまっています。 ②「6:00:00」シリアル値で入力されています。 ②はＯＫですが①はＮＧです。 ①の場合の修正方法ですが ・Ｂ列とＣ列の間に１列挿入します。 ・Ｃ２セルに「=TIMEVALUE(B2)」と、式を記入し必要な分コピーします。 ・Ｂ列の書式を「h:mm」に変更します。 ・Ｃ列をコピーします。 ・Ｂ列に「値」でペーストします。 ・Ｃ列を削除します。
「③最終賞与額」は、どういう計算で求めた値でしょうか。 単純に ①×②＝③ という計算であれば、以下のようになるはずですね。 　　①賞与額　②個人評価　③最終賞与額（増減額） Ａ　　1,000　　　1.2　　　　1,200　　（＋200） Ｂ　　2,000　　　0.9　　　　1,800　　（－200） Ｃ　　3,000　　　1.1　　　　3,300　　（＋300） Ｄ　　2,500　　　0.9　　　　2,250　　（－250） 計　　8,500　　　4.1　　　　8,550　　（＋ 50） ②の個人評価ポイント（１±アルファ）をそのまま増減額の係数にすると、 ①のベース額の違いによって増減額の合計が「プラスマイナスゼロ」になりません。 この場合は差し引き50の差異（この場合は原資が不足）が生じています。 この差異（過不足）を按分して補正する必要があります。 つまり、誰かを増額した分だけ誰かを減額して、プラスマイナスゼロにするわけです。 単純に過不足の比率（8500÷8550≒0.9942）を掛けると、こんな数字になります。 少数点以下は四捨五入してあります。値が細かすぎるという場合は、下1桁～2桁がゼロになるように丸めて、全体でプラスマイナスゼロになるよう調整してください。 　　①賞与額　②個人評価　③最終賞与額（増減額）　④補正後（増減額） Ａ　　1,000　　　1.2　　　　1,200　　（＋200）　　1,193 （＋193） Ｂ　　2,000　　　0.9　　　　1,800　　（－200）　　1,789 （－211） Ｃ　　3,000　　　1.1　　　　3,300　　（＋300）　　3,281 （＋281） Ｄ　　2,500　　　0.9　　　　2,250　　（－250）　　2,237 （－263） 計　　8,500　　　4.1　　　　8,550　　（＋ 50）　 　8,500 （± 　0） 参考までに、質問文の③の値が正しいと仮定して、③÷①＝②’ を求めると以下のようになります。この値は変です。 　　①賞与額　③最終賞与額　②’ 個人評価？ Ａ　　1,000　　　2,487.8　　　2.488 Ｂ　　2,000　　　1,865.9　　　0.933 Ｃ　　3,000　　　2,280.5　　　0.760 Ｄ　　2,500　　　1,865.9　　　0.746 計　　8,500　　　8,500.1　　　4.927
こんにちは こっちかな？？ http://answers.microsoft.com/ja-jp/office/forum/ … 印刷されたかどうかの話はないので同じ現象かは断定できませんが。 しかも解決はされていない・・・ PDF化がうまくいったことで、Excelのプレビューは正常表示と勘違いしましたが、 言葉を翻してしまいますが、↑の情報見るとドライバ関係なさそうですね。 たぶん、”エクスポート”でPDFにする場合と、印刷からPDFを作る（Adobe）場合で動作が違うんだろうと思います。 印刷機能を使ったら全部同じ結果（半分写らない）になると予想。 以下はMSへの情報として投稿されたコミュニティーサイトのスレッドに追記しては？という内容です。 何かしら解決方向にいけばよいのですが・・・？ ・上記URLで、同現象ではないか？とのコメント ・お持ちのプリンターではうまくいかないこと。 ・プリンター選択に、Microsoft Print To PDFがあるならそのプリント結果 　（ただしこれはエクスポートと同様かもしれないのでまともに印刷できるかも） ・プリンター選択に、その他PDFにするToolが選択できるならそのプリント結果 　（Acrobat Standard、とか、Cube PDFとか。たぶんNGのはず） ・エクスポートでは正常に変換できたこと。 お力になれず申し訳ない。
すいません。少し違っていましたね。 「Sub」～「End Sub」と「Function」～「End Function」以外の所で宣言され 「Public …」の場合がパブリック変数 「Dim …」の場合がモジュール変数 「Sub」～「End Sub」と「Function」～「End Function」の内部で宣言された物がローカル変数 と、考えるのが良いかもです。
どうでも良い話ですが、有刺鉄線 の「有」の字が消えてましたm(_ _)m https://www.google.co.jp/search?q=%E6%9C%89%E5%8 … プロレスには全く興味がないけど、子供のころの記憶だったので。 本題です。Excelのバージョンはなんでしょう？ 当方では[Ctrl]+[K]で入力までされないようです(XL2003) ただし、そのあと 　[Alt]+[B]でブラウズしたページを出せます。 　[↓]なら過去のリンクも
こんばんは！ 一例です。 数値に重複がない！という前提で・・・ ↓の画像で H3セルに =IF(COUNTIF(B2:E5,G1),INDEX(A2:A5,SUMPRODUCT((B2:E5=G1)*(ROW(A2:A5)-1))),"") H4セルに =IF(COUNTIF(B2:E5,G1),INDEX(B1:E1,SUMPRODUCT((B2:E5=G1)*(COLUMN(B1:E1)-1))),"") という数式を入れています。 ※　万一重複がある場合は 別の方法を考える必要があります。m(_ _)m
データの中の　フイルター　を使います
こんにちは！ やり方だけ・・・ ↓の画像のように元データのSheet（Sheet1）に作業用の列を設け、Sheet2のA1セルにC列の検索したい項目を入力するとします。 前提条件として、Sheet2の3行目項目名はSheet1の1行目項目名と一致するものを入れておきます。 まずSheet1の作業列J2セルに =IF(OR(Sheet2!A$1="",C2<>Sheet2!A$1),"",COUNTIF(I:I,"<"&I2)+COUNTIF(I$2:I2,I2)) という数式を入れフィルハンドルでずぃ～～～！っと下へコピーしておきます。 そしてSheet2のA4セルに =IFERROR(INDEX(Sheet1!$A:$I,MATCH(SMALL(Sheet1!$J:$J,ROW(A1)),Sheet1!$J:$J,0),MATCH(A$3,Sheet1!$1:$1,0)),"") という数式を入れフィルハンドルで列・行方向にコピーすると 画像のような感じになります。 ※　作業列が目障りであれば遠く離れた列にするか 非表示にしてください。m(_ _)m
下のリンク先の最後の方に実は「CTRL+J」が隠しコマンド的な役割を持っている事が理由も含めて書かれています。 http://officetanaka.net/excel/function/tips/tips … 「CTRL+G」の「G」は「Go」かもしれません。
> ＩＦ関数でうまくいきませんでした＞＜ その式をご提示ください。 見た目空白でも、空白ではない場合があります。 　例)　スペース、計算式、見えない文字、 空白検定がうまくいかない場合は、対象セルを「DEL」してみればわかります。
「急いでます」か？知らなかったモンでぇ～ 添付図に示すようなこと？ C1: =OFFSET(A$1,(ROW(A1)-1)/3,)
回答とは無関係です。 Excelの画面で[Alt]+[PrintScreen]とか[Fn]+[Alt]+[PrintScreen]キーで 画面のハードコピーが行えますのでペイントなどに張り付けて不要部分を取り除き アップしましょう また、質問部分は添付図で行わず、質問部分に書きましょう(コピペでできると思う)
画像が見えにくいので，以下に内容を書くと =================================================== 作業3、Round関数（数学関数） ●操作済の「グラフの作成」ファイルを開く ・[C4:E17]選択 ・コピー ・C19に貼り付け ・[C19:E32]選択 ・C34クリック ・=ROUND(C19,0)記入 ・C34をC47までドラッグ ・C47をE47までドラッグ ・[C19:E32]選択 ・<<セルの書式設定>><<数値>>小数以下の桁数<<0>><<OK>> =================================================== で大丈夫ですか？ 質問文は作業内容の4行目以降の事を質問しているのですね． 確かに作業で考えれば，セルを範囲選択した後に"何も操作しないで"別のセルをクリックするのは全く意味は無いように思います． 一応この作業通りの内容を実行（セルに書かれいてる数値は適当にして）したのですが，この作業自体の意味が良く分からないですね． 先ずC4からE17の範囲で任意の数値が入っていて，これをC19にコピーすると，C19からE31の範囲に値が入ります． C34に=ROUND(C19,0)と入力するとC19の値を小数点を含まないで四捨五入した値が入ります． これをC47までドラッグ，即ちオートフィル（C19のセルの右下にマウスカーソルを置くと＋みたいなカーソルになる，このカーソルになったら左クリックしながらC47までマウスを動かす）を行って，そのままE47までドラッグするという意味と解釈します． つまり，C34に=ROUND(C19,0)を入力したら，セルの右端にマウスカーソルを置いてE47までオートフィルを行うというのが6-8行目に書かれている作業の事なんですね． 一方でC19からE32まではセルの書式設定で小数点以下を表示させないという操作を最後の行で行っています． 多分この作業の目的としてはROUND関数で四捨五入した値とセルの表示が小数点以下を出さない事の違いを説明するためのものと思いますが，この画面だけで考えると分かり難い印象が強いですね．
案1 使い方にもよりますが、「情報」ファイルをWordで作って差し込み印刷する(Wordファイルとして保存することも可能) その際、1行目は消しておくか、データベースの範囲に名前を付けておきます 案2 「A」ファイルの別シートにINDEX/VLOOKUP関数などを使い、行番号やファイル名(情報○○)で検索、表示する 例 電話番号 「A」ファイルのシート名を「Sheet1」として、かつ、別シートに情報の書式が書いてあるとしてB4セルに =INDEX(Sheet1!E:E,G1)&"" 案3 マクロ VBAという言語を使い、プログラム(マクロ)を作成する。当方の手に負えませんm(_ _)m たぶん、この案を求めていると思うが、、、
データの参照先をボタンやスイッチのようなもので切り替えたいということでしょうか。 例： 　選択と表示はSheet1 　普段参照するデータはSheet2 　切り替えて参照するデータはSheet3 同じ並びであれば、参照先の範囲に名前を付けて、VLOOKUP関数内でその名前を切り替えるなどの方法があります。 上の例ではSheet3のデータは11列目から15列目までを空欄として処理する必要がありますが、これが一番簡単にできると思います。 ＞別シートのコード入力セルにそのコードが入力されて～ とはいきませんが、 ・Sheet1のA1セルにコード（？）を入力して、対応するデータをSheet1のC1セルからQ1セルまで表示させる。 ・B列にチェックボックスを作成し、B1セルにその結果を反映させ、 　－ B1セルが"FALSE"ならSheet2にある範囲を参照する。 　－ B1セルが"TRUE"ならSheet3にある範囲を参照する。 ということを想像してみました。 １．Sheet2の検索範囲に「参照1」、Sheet3の検索範囲に「参照2」と”名前”を付ける。 ２．（普通はリボンに表示されない「開発」を”リボンのユーザー設定”から表示させるようにしておき） 　リボンの開発タブにある「コントロール」の「挿入」から「コントロール」のチェックボックスを選択して、 　B列あたりにチェックボックスを作成する。（テキストは編集で削除しても良い） ３．チェックボックスのプロパティのコントロール（書式設定？）から「リンクするセル」に「B1」セルを指定。（チェックを付けると”TRUE”、チェックを消すと”FALSE”が入ります） ４．C１セルに 　　=VLOOKUP($A1,IF($B1,参照2,参照1),COLUMN(B1)) 　　と入力し、Q1セルまでコピーする。 ※COLUMN(B1)…は、参照先のデータがA列から順番に並んでいて、VLOOKUP関数では参照先のA列と参照元のA1セルを比較すると仮定し、2列目のデータを参照することを示しています。（D列にコピーすると”COLUNM(C1)”になり、VLOOKUP関数の参照列番号に３が返ります） これでA1セルに入力したコード（？）に対応したデータをC1列から表示可能になり、 さらにB列に置いたチェックボックスにチェックを付けるかつけないかで、参照先を切り替えることができます。 ・・・ たぶん質問者さんが意図しているものとは異なるものになると思いますが、試しに作ってみてください。 参考にできるところがあるかもしれません。
同じフォントがインストールされていないのでは？
2度目の回答ですが、VBAを使わないと出来ないですね。 A列に1回目のチェック B列に2回目のチェック C列にデータ。 こういう前提ならVBAは以下です。プライベートシートにいれて下さい。 また,A列2行目以降、B列2行目以降のセル書式は、FONTをMarleftにしておきます。 クリックすると、チェックマークが付いてしまうので、データ入力でもチェックが付きます。 A,B列のマークはクリアして下さい。 普通にDELETEキーで何回でも消せます。 Private Sub Worksheet_SelectionChange(ByVal Target As Range) Dim strAddr As String Dim 列 As String My_Row = Target.Row My_Col = Target.Column If My_Col = 3 Then strAddr = Cells(1, My_Col).Address(False, False) 列 = Left(strAddr, Len(strAddr) - 1) If ActiveSheet.Range("A" & My_Row).Value = "" Then ActiveSheet.Range("A" & My_Row).Value = "a" Else ActiveSheet.Range("B" & My_Row).Value = "a" End If End If End Sub
最初の質問 =INDEX(A:A,ROW(A3)/3) 下へオートフィル 補足は、補足ではなく新たな質問のですね 新たにスレを立てたほうが良いです。 B1セルに =IF(A1="",INDEX(B:B,ROW()-1),A1) 下へオートフィル でよさそうな？ も踏まえておいてください
ありません。素直に共有を解除してから挿入しましょう。
こんにちは ＞良き解決法がありましたら、教えていただきたく、宜しくお願い致します。 複数キーでの並べ替えで、一部に特殊な比較方法を用いたいということだと解釈しました。 エクセルにも並べ替えのためのSortメソッドが用意されていますが、キーが3種類までという限界があるのと、特殊な比較方法には対応していないという点から、全てを纏めてそのまま適用させるのは無理そうです。 先に、現実的な方法を書いておきますと… 1）優先キーで並べ替える 　（キーは3種まで。手動でもマクロでも良い） 2）そのキーの範囲内で同じ値（さらに比較が必要なもの）をピックアップ 　（条件書式やマクロ等でマーキングするとわかり易いかと） 3）結果を見ながら、残りは手動で並べ替え 実際のデータの内容にもよりますが、1）でどの程度まで並べ替えが終わるのかわからないものの、たかだか3000程度のデータとのことですので、重複部分はかなり少なくなっている可能性が高そうに思います。 あるいは1）の結果を見て、重複が多いようであれば、通常の大小比較で済む範囲に関しては2度目のソートをかけるというのもありでしょう。 1度だけの並べ替え作業であれば、この方法が一番早いのではないかと想像します。 内容的には上記と同じ考えですが、少しだけ要領よくやる方法としては、キーをまとめてしまう方法が考えられます。 例えば、第一キーから順に、5、8、20・・・といったデータがあるとして、それぞれを別のキーのまま扱わず、前処理でまとめて比較できるようにしてしまうという考え方です。 上の例でいえば、まず関数等を利用してデータを適当な桁数の文字列にしてしまうのです。 関数等を利用して空き列に、（仮に3桁として）005008020・・・という文字列に変換したデータを作成しておきます。 これでキーを一つにすることができたことになりますので、ここの値で並べ替えるようにすれば簡単ですね。 （並べ替えが終わったら作業用の列は削除すれば良いです） 特殊な比較の部分も同様に（画像が読めないので内容が不明ですが、表の参照のようなので関数化は可能でしょう）、関数で評価値を作成することができれば、全体を一発で並べ替えが可能になります。 一方で、どうしても、マクロ等で取り組みたいというのであれば・・・ 最初に『エクセルではキーの指定が3種類までで、特殊な比較方法ができない』と書きましたが、これを取り払う必要がありますね。 方法は2通り考えられます。 一つは上の二番目に記したような考え方ですが、各データから比較しやすい形に加工したデータを作成しておいて、組み込みのSortメソッドでそれをキーにして並べ替えた後、追加データを削除するというもの。 これは上記の手作業をそのまま、マクロ化したものとも言えます。 もっとまともな方法でとおっしゃるのであれば・・・ 組み込みのSortメソッドには制限があるので直接は使えませんから、まずはソートのマクロを作成します。 一般的なソートの手法はすでに世の中で充分に研究されていますので、ほとんどコピー同然で簡単に作成できるはずです。 http://www.ics.kagoshima-u.ac.jp/~fuchida/edu/al … http://www.rsch.tuis.ac.jp/~ohmi/software-basic/ … アルゴリズムの紹介等では、1つのキーでの並べ替えになっていると思いますが、等価の場合には次のキーで比較できるようにしておく必要があります、 大小比較の部分は基本的にa、b二値の比較となっているはずですので、比較部分だけを別関数にして二値を与えれば結果を返す仕組みにしておいて、等価の場合はこの比較関数部分に再帰するようにしておけば複数キーに対応可能になります。 さらに、特殊な比較方法にも対応できるようにするためには、実際の比較方法を使い分けることを可能にしておく必要があります。 エクセルのマクロでは関数そのものを引数にはできないので、代わりに番号などを渡してケース分けするようなことになりそうですが、幸いにも、ご質問のケースでは比較方法が2種類しかありませんので、わざわざ一般化する必要もなく、比較関数の中でベタに切り替えるようにしておけばすむと思いますので、面倒なことにはならないでしょう。 基本的には、以上考え方のどちらかで、ご質問の並べ替えのマクロが作成可能と思います。 欠点を考えてみると、組み込みのSortメソッド等に比較すると、VBAでの並べ替えを行う場合は圧倒的に速度が遅くなることが予想されることでしょうか。 とはいうものの、データ数が3000程度とのことですので、たいしたことにははならないと思います。 もう一つの欠点としては、一度しか並べ替えを行わないとするならば、マクロを作成する時間とエネルギーより少ないエネルギーで（最初に述べた方法で）並べ替えが完了してしまう可能性が高いこと。 他にも利用できるようなマクロを作成しておけば再利用は可能ですが、そのためにはさらに一般化した形で作成しておく必要があると思いますし、それには、さらなるエネルギーと時間が必要になると想像します。
リンクするセルを同じにしておけば連動して動きます。 「リンクするセル」を同じにすると、片方をチェックするともう片方もチェックされるようになります。 チェックボックスにチェックすると、 「リンクするセル」で指定したセルに「TRUE」が入り、 チェックを外すと「FALSE」が入ります。 なのでリンクセルを同じにすれば連動します。
「Support cursor translation in Office Word 2013」と、わざわざ Word 2013 と指定しているので Office 他の関係は未対応ではないでしょうか？ http://www.lingoes.net/
「ツール」「オプション」「全般」「R1C1参照形式を使用する」のチェックを外す。
ユーザ定義関数なら、こんな感じです。 E3セル内の最大値をH3に表示する場合は、 H3セルに、=MyMax(E3)　と入力します。 Function MyMax(r As Range) As Variant Dim n As Variant For Each n In Split(r, vbLf) If MyMax < n Then MyMax = n Next End Function
離れたセルの選択はCtrlキーを押しながら選択することができます。 計算式は「=MIN(A6,A11,A16)」になります。
こんにちは。 頻繁にするのでなければ変に工夫するより記載いただいているリンク貼り付けで場所移動がベターかと思います。 可読性も高いので何かMissがでた場合でも可読性が高い。 一応、場所に規則性があるなら、Lookup系の関数を使うと多少楽かなと。 以下は各情報は一つの行に入っているものとします。 行を変えたい場合も A列の値を入れたい行にNo.を入れればよいです。 シート２ A, B, C, D No.,価格,サイズ,対象車種 1,\1,1m,なんか ・・・ 20,・・・・ シート１（Dに価格を表示する） A, B, C, D , , , 2 No., , , 価格 1, , , ここに式を入れる =Vlookup($A3,Sheet2!$A$2:$D$21,D$1,0) あとは数式のコピーと、参照しているセル部分に番号を入れる。
たびたび失礼、No.5の誤記訂正。 １．何も記入されていないセル（値が０）を選択し、Ctrl+Cでクリップボードに「コピー」する。 × ２．数値に変更したいセル（列）を選択し、「形式を選択して貼り付け」で「乗算」を指定して貼り付ける。 ○ ２．数値に変更したいセル（列）を選択し、「形式を選択して貼り付け」で「加算」を指定して貼り付ける。 「０」を乗算すると全部「０」になってしまいますね（汗）
>今手元に少し関数が違うかもしれません。 そんなものを載せるより、eoitajさんが書いた関数をそのまま載せた方が早いと思いますよ。 そもそも、関数をcallするって、ありえないでしょう？
=COUNTIF(A2:A2,"○")+COUNTIF(C2:C2,"○")+COUNTIF(E2:E2,"○") をG2に入れ、G3以降へコピペ
COUNTIF式を足し算したらいいと思いますけど。
2007ならまだ別シートを直接セル参照した条件付き書式はできませんね。範囲に名前をつければ参照できます。 私は、式で色を付けたい部分の日付が予定表の日付に含まれているかどうかを判断し、1などのフラグを入れ1が入ったら条件付き書式で色がつくようにしてガントチャートもどきを作ったことがあります。
こんにちは！ A列に重複はない！という前提で・・・ 一案です。 セル結合があると何かと厄介ですので、↓の画像のように作業用の列を設けます。 作業列L3セルに =IF(J3="","",IF(I3="",L2,I3)) K3セルに =IF(L3="","",INDEX(D$3:G$6,MATCH(L3,A$3:A$6,0),MATCH(J3,D$2:G$2,0))) という数式を入れK3・L3セルを範囲指定　→　L3セルのフィルハンドルで下へコピーすると 画像のような感じになります。 ※　作業列が目障りであれば、遠く離れた列にするか 非表示にしてください。m(_ _)m
こんにちは。 意図されていることに沿っているかが疑問ですが試しに作ってみました。 実際に動かしてみて修正が必要な箇所があるようでしたら補足下さい。 ------------------------------------------------------------------------------ Sub a() Dim dblROW As Double Dim cnt As Double '//---------------------------- 'シート１の名前を指定 Const SNM1 = "Sheet1" 'シート２の名前を指定 Const SNM2 = "Sheet2" '----------------------------// 'シート1のA列にデータが存在する行数を調べる dblROW = 2 Do Until Len(Sheets(SNM1).Range("A" & dblROW)) = 0 dblROW = dblROW + 1 Loop dblROW = dblROW - 1 '入力データが無い時は終了 If dblROW < 2 Then Exit Sub End If For cnt = 2 To dblROW 'シート１のＡ列データをシート２に値貼り付け Sheets(SNM1).Range("A" & cnt).Copy Sheets(SNM2).Select Sheets(SNM2).Range("A1").Select Selection.PasteSpecial Paste:=xlPasteValues 'シート２を新規シートに値貼り付け Sheets(SNM2).Copy after:=Sheets(Worksheets.Count) '新規シートのシート名を付ける Sheets(Worksheets.Count).Name = Sheets(SNM2).Range("A1") '新規シートを値貼り付け Sheets(Worksheets.Count).Cells.Select Selection.Copy Selection.PasteSpecial Paste:=xlPasteValues Sheets(Worksheets.Count).Range("A1").Select Next Sheets(SNM1).Select Sheets(SNM1).Range("A1").Select End Sub ------------------------------------------------------------------------------
>①と②で「✓」が入っているものは除く =IF(COUNTIF(I3:J3,"✔")>0,"(除外)",･･･ I3~J3の✔を数えて、0個より多い場合、"(除外)"を表示します。 ＞D3:G3を範囲として100以上は「✓」を入れる =IF(COUNTIF(D3:G3,">=100")>0,"✔"､… D3~G3の100以上のセルを数えて、0個より多い場合、"✔"を表示します。 でも、これって前回の回答の中にありますよね？何か別のことを質問したかったのでしょうか？読解力が無くてすいません。
こんにちは。 長文で失礼します。 私は頭が悪いのか、どうしても、ここの質問やスレの内容が理解できないのです。 私の疑問は、 　　ThisWorkbook.Protect Password:="1234" 確かに、自分のブックに自分で鍵を掛けることは可能です。それは、玄関を締めるのと同じですから。 しかし、 　　ThisWorkbook.Unprotect Password:="1234" これでは、中から鍵を開けてくださいということだから、セキュリティも何もありませんよね。鍵を開けて玄関から入らなければ、マクロ自体も実行されないと思うのです。そのために、マクロの前に、ブック本来のパスワードダイアログが、開く前に働くはずです。(マクロのプロテクトの話は別です。)　　 全体を言うなら、今の流れは、 ThisWorkbook モジュールで、このように用いることと、解釈しています。 '----------------------- Const pwd As String = "1234" Private Sub Workbook_BeforeClose(Cancel As Boolean) 　　　　 ThisWorkbook.Protect Password:=pwd End Sub Private Sub Workbook_Open() Dim pwd As String pwd = InputBox("パスワードを入力してください。", "ブック保護の解除") If StrPtr(pwd) = 0 Then 　　MsgBox "キャンセルされました。" Exit Sub ThisWorkbook.Unprotect Password:=pwd End Sub '----------------------- >ブック保護解除ボタンを押すと、パスワードの入力を求められるようにするにはどうしたらよいでしょうか。 それは、ブックの構成(場合によりシートも含まれる）などの解除のためであって、ブックそのものを開くためののではないのではないかと思います。 つまり開いてから、本体のマクロ(Thisworkbook)を動かしてパスワードを入れさせるというのは、どちらかというと、ナンセンスな設定ではないかと思うのです。 なぜなら、この時点で、ThisWorkbook のマクロが動いているのですから、表玄関の鍵は半分は開けられていることを意味するからです。(表があるなら裏もあるというのは、別の話で、これは、ナシにしてください。そちらを話すとオフトピになってしまいます。） 以下のマクロの意味は解説しませんが、簡単なマクロですから、見て分かる人がいれば、私の言っている意味が分かると思います。これをステルスで動かされたら、何をしているかさえわかりません。 '------------------- Sub Macro1() 　　Dim acBk As Workbook 　　Dim sh As Object 　　Dim shcnt As Integer 　　Dim fn As String 　　Set acBk = ActiveWorkbook 　　shcnt = Application.SheetsInNewWorkbook 　　Application.SheetsInNewWorkbook = 1 　　Workbooks.Add 　　ActiveWorkbook.Sheets(1).Name = "dumm" 　　With acBk 　　　　For Each sh In .Sheets 　　　　　　sh.Copy after:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count) 　　　　Next sh 　　End With 　　Application.DisplayAlerts = False 　　ActiveWorkbook.Sheets("dumm").Delete 　　Application.DisplayAlerts = True 　　fn = Mid(acBk.Name, 1, InStrRev(acBk.Name, ".") - 1) 　　ActiveWorkbook.SaveAs "C:\Temp\" & fn, 50 　　ActiveWorkbook.Close False 　　Application.SheetsInNewWorkbook = shcnt End Sub '-------------------- 昔、私がこの話をした時に、画面コピーの話がありましたが、それは防ぐことか可能です。 つまり、本格的にパスワードで行うなら、 ①　ダミーのブックを備えて、マクロブックとは別に置く。 (隠しフォルダーに格納する方法もそのひとつ） ②　そのブック以外の外部のVBAや他のプログラムを駆使して、本体のファイルのアンプロテクトをダイアログにする。(例えば、WScript を暗号化して、コンパイルする。パスワードはレジストリに入れる。） ③　IRMを使う。(これが一般的でした） しかし、現在　IRM－Information Rights Managementは、私の間違いでなければ、2015年の11月28日で終わっているというそうです）エラーが発生します。 https://blogs.technet.microsoft.com/enterprisemo … その代わりに、Microsoft のMRS(Rights Management Services)ということで、ARM(Azure Rights Management)に替わっていることですが、サイトをみたら、有償になってしまっています。 Azure Rights Management を使用するように IRM を構成する https://technet.microsoft.com/ja-jp/library/dn15 …(v=exchg.150).aspx https://products.office.com/ja-jp/business/micro … と、私が、ここの質問を読んで思ったことです。見当はずれな回答だと思いましたら、特にフィードバックは不要です。
終わりの処理が推奨できる状態ではなかったので、もう一度貼り付けます。 Private Sub Worksheet_Deactivate() If ActiveSheet.Name = "シート1" Then Dim tableRange As Range Set tableRange = Sheets("シート2").Range("テーブル1") With tableRange.Interior .Pattern = xlNone .TintAndShade = 0 .PatternTintAndShade = 0 End With Set tableRange = Nothing End If End Sub
幅については No.1さんの行ごとコピーで解決と思いますが、日付については各セルには数式が入っていませんか？ 変に絶対参照($)が入っているとか、基準（1日目）となるセルが変わってしまって空白を参照してしまっているとか？？
No.3です。 「=INDIRECT($F$2&"!H)2")」だとHと2の間に不要なカッコがあるのでそのエラーかな？ 念のため数式が入ってる部分の画像を引きのばしてみますね。
No.1です。 ファイル１とファイル２は同じものと思いますので、この際無視します。 ＞ファイル３に飛んでいきません これは目的のデータがファイル３に入力されないということですよね？ ファイル３にはマクロは不要と思いますが・・・ 必要なのは ・ファイル１のシートAモジュールにWorksheet_Changeイベントのプロシージャを書いて 　移動()プロシージャを呼び出す。 ・ファイル１の標準モジュールに移動()プロシージャを書く の2点です。 移動() プロシージャの起動条件はいろいろと都合があると思いますので、If文の中身を十分に検討下さい。 申し訳ありませんがうまく動作しない場合はデバグして詳細に、 目的の動作をしているかをご確認いただく必要があると思います。 ・Worksheet_Changeのマクロは起動しているのか ・Target.Column の値は 目的の値（5)か ・移動() プロシージャに処理が移るか ・移動() プロシージャの動きはボタンで起動したときと同じか などなど。 質問文のコードを組まれているのでデバグはされていると思いますが、、、 http://www.asahi-net.or.jp/~ef2o-inue/vba_k/sub0 … それはすでにやってるよ！と言われると申し訳ない。
>9行目から最終行までの範囲がすべて非表示だったら… 非表示じゃなくて削除してますよね？ 「範囲を変数に代入し、その範囲がすべて非表示だったら」なんて難しく考えないで、単純に「最終行が9行目より小さくなったら」で良いのではないでしょうか。 こんな感じです。 Sub sample() Dim I As Long For I = Cells(Rows.Count, "A").End(xlUp).Row To 9 Step -1 If Cells(I, "B").MergeCells Then Call ExchangeMergeCell(Cells(I, "B").MergeArea.EntireRow) End If If Count○(Rows(I)) = 0 Then Rows(I).Delete Shift:=xlUp End If Next If Cells(Rows.Count, "A").End(xlUp).Row < 9 Then ’←ここからが追加分です！！ ActiveSheet.Visible = False End If End Sub
No.6です。 ＞・記入用フォーマットに、対応する日付が無かった場合 ＞・記入用フォーマットの対応する日付の欄に、すでに何かが記入されている場合 を見逃していました。 前回のコードは消去し↓のコードにしてみてください。 そして、画像のアップを忘れていましたので、 一緒にアップします。 Sub Sample2() Dim c As Range, lastRow As Long, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") Set c = wS.Rows(4).Find(what:=Format(.Range("C4"), "m/d(aaa)"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then If wS.Cells(Rows.Count, c.Column).End(xlUp).Row = 4 Then lastRow = .Cells(Rows.Count, "B").End(xlUp).Row If lastRow > 5 Then Range(.Cells(6, "B"), .Cells(lastRow, "C")).Copy wS.Cells(Rows.Count, c.Column).End(xlUp).Offset(1).PasteSpecial Paste:=xlPasteValues Application.CutCopyMode = False End If Else MsgBox "入力済みです" Exit Sub End If Else MsgBox "該当する日付なし" End If End With End Sub ※　今回はSheet1のデータには手を付けていません。 どうも失礼しました。m(_ _)m
こんにちは No2です。オートフィルタのくだりが完全になくなってますけど大丈夫ですかね・・・ｆ＾＾； とりあえず当方で試したところは動くのですが、、、 （H列に適当に文字をいくつか入れて実行⇒"消耗品"だけ消える） Excelのバージョンに左右されるコードではないと思うんですが、 ちょっとテストできる環境がないのでご了承ください。（2013です） フリーズとのことですが、エラーで停止するのではなく、Excelが止まるイメージでよいですよね。 動作軽くするのであれば ・選択範囲を制限する ・下記している 計算、表示の停止を行う。 ぐらいしか対処が浮かびません。 なお、質問文に記載されている内容（下から順に削除する）でも、計算、表示の停止すると、 結構スピード上がると思いますが、検討されているでしょうか？ とりあえず変更したコードです。 '-------------------------------------------- Sub test() '表示と自動計算の停止--------------------- Application.ScreenUpdating = False Application.Calculation = xlCalculationManual Dim l As Long 'count用変数 Dim Rg As Range '消したい行 Set Rg = Nothing '多分無くてよい For l = 1 To 3500 '検索する行数はここで変えてください。 If Cells(l, 8) = "消耗品" Then If Rg Is Nothing Then Set Rg = Range(Cells(l, 1), Cells(l, 39)) '一つ目は直接代入 Else Set Rg = Union(Rg, Range(Cells(l, 1), Cells(l, 39))) '二つ目以降は結合 End If End If Next l If Not Rg Is Nothing Then Rg.Delete shift:=xlUp '表示と自動計算を有効化--------------------- Application.ScreenUpdating = True Application.Calculation = xlCalculationAutomatic End Sub
ちょっと修正 Sub test2() 　With Sheets("Sheet2").Range("F12:F" & Sheets("Sheet2").Range("a65535").End(xlUp).Row) 　 　.FormulaR1C1 = "=INDEX(Sheet1!C[-4]:C[-3],ROW(R[-8]C[-5])/2,MOD(ROW(R[-8]C[-5]),2)+1)" 　 　.Value = .Value 　End With End Sub 単純に Sheet2!F12:F??セル範囲に =INDEX(Sheet1!B:C,ROW(A4)/2,MOD(ROW(A4),2)+1) を入力して[Ctrl]+[Enter] 数式を値化
私は、そんなに難しいことは知りませんが、 ChartObject というのは、ワークシートに貼り付ける(埋め込み）グラフのことで、ワークシートに従属して、それしか作らないからでしょう。 Shapes.AddChart　なら、こちらは、グラフシートにするか、シート貼り付けにするか、どちらかに振り分けますという意味ですよね。 その時点では、どちらにも決まっていないはずです。 Shapes というのは、ワークシートのオブジェクトの総称のようなもので、単にそのオブジェクトのコレクションであり、それにAddをつけると、そのひとつ(インスタンス）を呼び出します、というような意味だと思います。 Shapesというコレクションは、97以降だったか、比較的後の時代に現れた統合されたオブジェクトで、当然、グラフを作る場合は、直接呼び出ししたほうが早いから、ChartObject[=ChartObjects(1)] を使うわけです。逆に、グラフシートなら、Charts.Add でしょうね。 Mougの書いた人がどうかは分かりませんが、コードとしては、一種のスタイル(格好）の問題だと思います。回り道の案内図では格好が悪いからだと思います。 ただ、その記録マクロは、Excel 2013で作られたものでしょうから、その内容については詳しくは分かりません。
IF関数の条件式に、 ・COUNTIF関数で値が一致するセルの数を数え、値が0より大きいかで判断。 ・MATCH関数で値が一致するセルの位置を返すか、見つからずエラーを返すかで判断。 ・CONCATENATE関数で各セルの値を結合してFIND関数やSEARCH関数で調べ、1以上かで判断。 など、いろいろな方法があります。 比較したい文字列（質問のケースでは”送料有り”）が、一部に含まれること（”代引き・送料有り”など）を確認するような場合は、 FIND関数やSEARCH関数を利用すると良いでしょう。 今回はそのような指定がないので、COUNTIF関数の結果が0より大きいかの判断でいいんじゃないでしょうか。
数値限定ならば 「=IF(OR(ISNUMBER(A1),ISNUMBER(A2)),"○","")」 空白以外ならば 「=IF(OR(A1<>"",A2<>""),"○","")」
こんな感じですね。シート名の（新）ですが、カッコと閉カッコの半角、全角は同じにしてください。 Sub sample() Dim ws1 As Worksheet Dim ws2 As Worksheet On Error Resume Next For Each ws2 In Worksheets If ws2.Name Like "*(新)" Or ws2.Name Like "*（新）" Then Set ws1 = Sheets(Trim(Left(ws2.Name, Len(ws2.Name) - 3))) With ws1.Cells.FormatConditions .Delete .Add Type:=xlExpression, Formula1:="=A1<>'" & ws2.Name & "'!A1" .Item(1).Interior.Color = 255 End With End If Next End Sub
これだけでは情報不足です。 コピー元とコピー先のセルの書式は同じですか？ 変数を介さずにコピーしていますか？ 実際のコードも質問に載せた方がいいと思います。 >18をコピペした結果が0.98666666のようになるといった こんなに違うのであればエクセルの小数誤差ではないと思いますので、上記を補足した方がいいと思います。
変数Jは、最初にD列を指すので、4で良いはずなのですが…。 ちなみに、どこで、どんなエラーがでましたか？
No.1です。 No.2さんの回答が簡潔ですね。 No.1は無視してください。m(_ _)m
No.3の回答者です。 No.4の回答を見ていて、助長部分があったのを修正しますね。 Bさんの場合の例 月別のカウント =SUMPRODUCT(--TEXT(1:1,"yyyym")=20165)*1) 1の場合のカウント =SUMPRODU((5:5=1)*1) "休"の場合のカウント =SUMPRODU((5:5="休")*1) 個別だと「*1」は必要になります。 1と"休"のカウントを合計（AND）した場合 =SUMPRODUCT(((5:5=1)*1)+((5:5="休")*1)) これでも計算されますが、「*1」は無くても計算してくれますね。 =SUMPRODUCT((5:5=1)+(5:5="休")) のほうが簡潔で分かり易いですね。 月別でカウントする場合（質問への回答例） =SUMPRODUCT((--TEXT(1:1,"yyyym")=20165)*((5:5=1)+(5:5="休"))) これでも計算しますし、このほうが簡潔ですね。 私も質問者さんと同じで、まだまだ勉強中ですので、不要な部分がある 回答を投稿することも多く、修正を何度もしています。
こんにちは。 #2の回答者です。 >ものによりますが1.3倍ほどになるのでできれば、、、といったところですね。 >ヘッダーが６列、データが３列の2000～5000、一日に3000ファイルほど吐き出しています。 私が想像していたのは、巨大なCSVファイルを考えていました。しかし、まさか、数で来るとは思いませんでしたね。 一日に3000ファイルほど？　→1.3倍　->[ファイルサイズの問題に発展] もちろん、SHIFT-JISですよね。 カンマだけの問題ではなさそうな気がします。 CSVファイル生成には、問題は発生していないとしても、処理は、CSV生成時にということになるでしょうね。それも、完全自動化しなければ、3,000ファイルなどの処理ができるはずもありません。 とりあえず、最初の第一案から、マクロを提示します。 ツールを使う方法は、どうしても一括処理ということを考えます。しかし、何が問題かというと、ファイル名の決定方法と、タイム・スタンプの問題があります。それを変更しないようにするのではないかと思うと、また別なテクニックが必要になります。 以下は、A1からデータがあることを想定したマクロです。 '// Sub MakingCSV() 　　Dim LastRow　　As Long 　　Dim LastCol As Long 　　Dim Rng As Range 　　Dim buf As String 　　Dim fNo As Integer 　　Dim fn As String 　　Dim i As Long, j As Long 　　 　　fn = ThisWorkbook.Path & "\Test1.csv"　　'ファイル名 　　fNo = FreeFile() 　　Set Rng = ActiveSheet.Range("A1").CurrentRegion 　　LastRow = Rng.Cells(Rng.Cells.Count).Row 　　Open fn For Output As #fNo 　　For i = 1 To LastRow 　　　　LastCol = Rng.Cells(i, Columns.Count).End(xlToLeft).Column 　　　　For j = 1 To LastCol 　　　　　　 buf = buf & "," & Rng.Cells(i, j).Text 　　　　　　 DoEvents 　　　　Next j 　　　　 Print #fNo, Mid$(buf, 2) 　　　　 buf = "" 　　Next i 　　Close #fNo 　　MsgBox "終了", vbInformation 　End Sub
マクロになってしまいますが、こんな感じです。 移動位置は、対象セルの右上の角を基準に、その右上（上-30ポイント、左+30ポイント）としています。 Sub sample() Dim c As Variant For Each c In ActiveSheet.Comments c.Shape.Top = c.Parent.Top - 30 c.Shape.Left = c.Parent.Left + c.Parent.Width + 30 Next End Sub
S4: =INDEX(D$3:O$3,MATCH(R4,D4:O4,0)) MATCH の前に「,」とか「0,」とか、余計なものは不要です。
Excelデータベースを作成する際のNGパターン https://rakuzanet.jp/excel-database.html を見ておくといいかも。データタブで分析可能になりますから
その特定のセルの「セルの書式設定」の「文字の制御」の「折り返して全体を表示する」にチェックは入っていますか？
》 1日は1行使用、勤務時間、退社時間とも1セル使用です そういうことなら、添付図の方法でしょ。 列Ｂ、Ｃの書式は m/d h:mm 列Ｄの書式は [h]:mm セル D2 の式は =C2-B2 セル B2 は「6/5 20:0」と入力 セル C2 は「6/6 1:0」と入力 セル B3 は「6/3 23:30」と入力 セル C3 は「6/4 5:0」と入力
質問3については、今までの流れとは全く関係ないのですね？ まぁ～～～それはさておいて・・・ 当方がアドバイスできる範囲内でお答えします。 1）～5）に関してですが、メッセージボックスよりもインプットボックスの方が適していると思いますが、 フォントサイズ等の変更ができるかどうか判りません。 自分だと↓の画像のようなテキストボックスとコマンドボタンを配置したユーザーフォームを作成し、 質問にある方法にします。 （ユーザーフォーム作成時にプロパティでフォントサイズ等が設定できるため） その下準備ができた上での一例です。 まずSheet上にコマンドボタンを配置、コマンドボタンのコードを↓にします。 Private Sub CommandButton1_Click() UserForm1.Show End Sub 次にユーザーフォームのコマンドボタンのコードを↓にします。 Private Sub CommandButton1_Click() Dim str As String, c As Range If TextBox1 <> "" Then str = TextBox1 Set c = ActiveSheet.Cells.Find(what:=str, LookIn:=xlValues, lookat:=xlWhole) Unload Me If Not c Is Nothing Then c.Select Else MsgBox "該当データなし" End If Else MsgBox "入力してください" End If End Sub これで何とかお望み通りの動きになると思います。 ※　入力時のフォントサイズにこだわらないのであれば インプットボックスを使用して、Sheet上のコマンドボタンをクリックで 何とかできると思います。m(_ _)m
Access　データベースソフトなんだから、表計算ソフトは別もの。 Excelを利用することも出来ますけどね データベースなんだから、作成とかによっては、表計算ソフトはなくても出来ますよ まぁ、Officeソフトって、MS OfficeとKingsoft Office以外にも、フリーのLibreOfficeやApache OpenOfficeなどがありますけどね データベースソフトのBaseなら搭載されているけどね MS Officeと完全な互換性があるわけではないけども
こんにちは。 こちらの認識を確認させて頂く意味も込めて提案の処理を具体的に書いてみますね。 私としても疑問に感じることがいくつかあるので間違って認識しているところがあると思います。 「そうではなくて」「それは困る」などを教えてください。 ------------------------------------------------------------------------------------- 今月データのシート名：[今月シート] 先月データのシート名：[先月シート] データの範囲(max)：A1～AM3500 ①比較元の日付を保持 　⇒[先月シート]のD1～D3500をコピーしてAN1～AN3500に貼り付けておく ②今月データを先月データに貼り付ける 　⇒[今月シート]のA1～AM3500をコピーして[先月シート]のA1～AM3500に貼り付ける ③先月データの日付と今月データの日付を比較 　⇒[先月シート]のD1～D3500とAN1～AN3500を比較して異なる場合はAO列にフラグを立てておく ④削除対象行の抽出 　⇒AO列にフラグがあり、H列が"消耗品"の行をオートフィルターで抽出する ⑤データの削除 　⇒オートフィルターで表示されているデータを行削除する ------------------------------------------------------------------------------------- どうでしょう？
-E2の説明がなかったり、falseなのに"FAULT"と書かれていたりして 意味不明な点もありますが、説明をもとに数式を検討すると =CHOOSE(2-SIGN(1-COUNT(1/(-H2<=0),1/(-K2<=0),1/(-N2<=0))),"なし",MAX(H2,K2,N2),FALSE()) H2,K2,N2セルに「TRUE」または「FALSE」が入力されるようなら使えません 凝りすぎか？？(>_<)
ANo11です。 ＞C5セルではなく、B5セルの間違いでした。 No11のサンプルではC5セルの内容で探すようになっているので、実行すると「登録されていません」の連発になってしまいますね。(^_^;) とは言うものの、B5セルもコピー範囲内なので、列の位置が違うだけで、同じことになっていませんか？ いずれにしろ、検索値を指定しているのは WorksheetFunction.Match(dataSht.Cells(5, 3).Text, dbSht.Columns(4), 0) のところなので、そこで正しいセルを参照するようにしてあげれば、動作すると思います。
No.2で回答した者です。 念のため使用した関数の解説を追記します。 =OFFSET(A1,-1,2) 　A1セルから1行上＆2行右へ移動 =INDIRECT(2,3) 　2行目＆3列目(C2)に入力されているセル番地を参照する =ADDRESS(5,6,4) 　5行目＆6列目のセルのセル番地(F5)を取得する 　(4は参照設定を指定したもの。念のために。) =ROW(F2) 　指定したセル(F2)の行番号を取得する =MATCH(A1,A2:A9,0) 　A2～A9のデータでA1の値と一致する列番号を取得する 　※今回はA列にタイトルがあった為取得した数値に1を足して列番号として使用 　(0は完全一致を指定したもの) 式自体をもっと簡潔に出来る様な気もしますが今回はこんな関数を組み合わせました。 実際に使用される表に応じて引数を変えてみてください。
講釈なしの添付図だけで分かるでしょ？ 式？=A4<>A1 だけでっす！
EXACT関数で比較する文字が、A となっています。正しくは、"A"ですね。こんな感じです。 =IF(EXACT((LEFT(C10,1)),"A"),VLOOKUP(C10,商品管理番号!B1:T192,17,FALSE),FALSE) ただ、このままだとVlookupで値が見つからないと＃NAとなってしまいますが･･･。
私は、ワークシート上で使う使い方を知らないのですが、よかったら教えて下さいませんか。アドインのオートメーションから入れてみました。 入れてみても、その関数は正しくないと返ってくるだけです。 GAS ? Basp のことではないでしょうか。 Split関数は 順に szRegstr : パターン。 szTarget : 対象文字列。 limit　　　: 配列数の制限値。0を指定すると無制限。 戻り値　　 : 配列。 // 数式が成り立つなら、このようになるはずです。 =Split("/\s+/g", Range("A1"), 0) 確かに、想像以上に便利だということは言えるのですが、設定の仕方が分かりません。 例えば、VBA マクロではこのようになります。 配列のindex の最大数を取るのが面倒なので、ループにしました。 Sub TestSplit() 　　Dim srTarget　　As String 　　Const Pattern As String = "/\s/g" 　　Dim ar As Variant 　　Dim v As Variant 　　Dim i As Long 　　srTarget = Range("A1").Value 　　ar = Split(Pattern, srTarget, 0#) 　　i = 2 　　For Each v In ar 　　　　If v <> "" Then 　　　　　　Cells(2, i).Value = v 　　　　　　i = i + 1 　　　　End If 　　Next v End Sub
質問の最初の状態に戻して Excelのファイルタブ→オプション→詳細設定→ハードウェアのグラフィックアクセレーターを無効にする にチェックを入れてみたら・・・。 https://support.microsoft.com/ja-jp/kb/2768648
=IF(AND(COUNT(D6:F6),COUNT(D7:F7),COUNT(D8:F8),COUNT(D9:F9),COUNT(D10:F10)),"OK","")
こんな感じでいかがでしょうか。 各シートともに、見出し行は無く、1行目からデータとなります。 順位で並べ替えはしていますが、50位を超えるものでも削除したりしていませんので、目視で判断してください。 ちなみに、このくらいの操作なら手作業でも十分対応できそうですね。 Sub sample() With Sheets("順位表") .Cells.Delete Sheets("顧客データ").Range("B:B").Copy Destination:=.Range("B1") .Range("A1:A1000").Formula = "=RANK.EQ(C1,C:C)" .Range("C1:C1000").Formula = "=COUNTIF(B:B,B1)" .Range("C1:C1000").Value = .Range("C1:C1000").Value .Range("$A$1:$C$1000").RemoveDuplicates Columns:=2, Header:=xlNo .Sort.SortFields.Clear .Sort.SortFields.Add Key:=Range("A1"), _ SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal With .Sort .SetRange Range("A1:C1000") .Header = xlNo .MatchCase = False .Orientation = xlTopToBottom .SortMethod = xlPinYin .Apply End With End With End Sub
モジュールではなく、ThisWorkbookの配下で Private Sub Workbook_Open() WorkSheets("FAX送付状").Activate End Sub
＞元の質問に詳しい説明でもない限り無理。 元の質問の上記回答者です。 詳しい説明、、、。(@_@) 無理かも https://oshiete.goo.ne.jp/qa/9286837.html INDEX($B$2:$G$20,,MATCH($I$1,$B$1:$G$1,0)),J$1&"") ではセル範囲$B$2:$G$20に対し、行番号が入っていないので列の範囲を取り出している。 あとは対象のみ取り出し、(空白をなくし)上に詰めるって処理。 上に詰めるってのを数式でやろうとすると厄介。 で、おんなじ行で名前を書いていいなら↑INDEXが分かれば難しくないと思う ちなみに配列数式 　 　 　^^^^ うまくいかないのはエラーなのか不明？ ツール - ワークシート分析 - 数式の検証 を使ってみるとか？
O2セルが空白の場合も考慮して =IF(OR(O2=100,O2=""),"",IF(OR(COUNTIF(J2,{"*Z*","*R*"})),"×",""))
=IF(COUNTIF(A:A,G2),"○","") で出来ますが、数値かどうかのチェックも必要ですか？
以下のコードを標準モジュールに書き込んでください。 ---------------------------------------------------- Function ColorCheck(対象 As Range) As String If 対象.Interior.ColorIndex = xlNone Then ColorCheck = "" Else ColorCheck = "1" End If End Function ---------------------------------------------------- 使い方は普通の関数と同じで「=ColorCheck(A1)」のような使い方になります。 実は、問題がありましてセルの色を変えてもそのままでは反応しません。 再計算を実行してください。 と言いたいのですがあまりにも使いにくいので 対象のシートモジュールに以下のコードを書き込んでください。 ---------------------------------------------------- Private Sub Worksheet_SelectionChange(ByVal Target As Range) Calculate End Sub ---------------------------------------------------- これで選択セルが変更されるたびに再計算されるようになります。
こんばんは！ 画像の配置だとK2セルに =SUM(COUNTIF(INDEX($E$2:$H$100,,MATCH(K$1,$E$1:$H$1,0)),INDEX($A$2:$C$100,,MATCH($J2,$A$1:$C$1,0)))) 配列数式ですので、Ctrl＋Shift＋Enterで確定し、 フィルハンドルで列・行方向にコピーしてみてください。m(_ _)m
至急回答求む、書いてありましたので、間違いなく計算できる方法を提示しました。 時間の計算はただでさえエクセルの小数誤差の問題があります。 固定値を小数で、は今後やめた方がいいですよ。 この質問に関してはこれ以上のコメントはできませんので、これで失礼します。
No.1です。 列幅が細くなっただけ？ですかね。 表示範囲の列をまとめて選択して列幅調整すれば治るような？ オブジェクト移動するかもしれないので後で調整必要ですが。
こんにちは！ 質問文の配置だと A1セル（セルの表示形式は好みの日付）に =IF(COUNTIF(B1:F1,"<="&TODAY()),MAX(IF(B1:F1<=TODAY(),B1:F1)),"") 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ A1セルのフィルハンドルで下へコピーしてみてください。m(_ _)m
質問内容を取り違えているかもしれませんが。 [プロパティ]の[ハイパーリンクの基点]で、半角の「￥」を入力することで リンクのパスを維持しませんか？ http://www.wanichan.com/pc/word/2010/08/25.html#b
こんにちは！ 画像の配置だとSheet2のA3セルに =IFERROR(INDEX(Sheet1!$A$1:$A$1000,SMALL(IF((Sheet1!$B$1:$B$1000=A$2)*(Sheet1!$C$1:$C$1000=""),ROW($A$1:$A$1000)),ROW(A1))),"") という配列数式にしてみてください。 どこのセルに数式を入れるにしてもほとんど同じ数式になります。 参照先セルが変わるだけです。 数式の説明を少しだけ・・・ INDEX関数の範囲指定した配列の何番目を返すか？という数式です。 まずINDEX関数の配列はSheet1の「A1～A1000」としているので、 ＞ROW($A$1:$A$1000) のように必ず1行目からINDEX関数の配列を同数の行を指定します。（A列でなくてもどこの列でも構いません） そして最後の ＞ROW(A1) はSMALL関数の「順位」の部分になります。 ROW(A1)=1　ですので下へフィル＆コピーするたびに　ROW(A2)・ROW(A3)・・・ となり、配列のTRUEの小さい順に表示することになります。 その前にB列がSheet2の2行目（氏名）に該当するか？とC列が空白か？という判断を ＞(Sheet1!$B$1:$B$1000=A$2)*(Sheet1!$C$1:$C$1000="") の部分で行っています。 B列がSheet2の2行目（氏名）に該当する場合は「TRUE＝１」となり、該当しない場合は「FALSE＝０」になります。 そしてC列が空白の場合は「TRUE＝１」、そうでない場合は「FALSE＝０」となりますので、 各々の行の掛け算をし、各行そのものが「TRUE」か「FALSE」のどちらかになり ＞ROW($A$1:$A$1000) をかけて「TRUE」の行の小さい順に表示させる！ といった数式になります。 以上長々と失礼しました。m(_ _)m
次の操作をお試しください。 手順①③は詳しく説明していますが、それ以外の操作が分からない場合は、補足等で再質問してください。 【手順】 ①○の文字を検索して、すべて選択する。 ②Cntl+0で選択した列を非表示にする。 ③表示されている列（いらない列）を可視セルのみ選択して削除する。 ④非表示になっている列を再表示する。 【①の説明】 「検索と選択」の「検索」で検索文字に○を指定し「すべて検索」すると見つかったセルの一覧が表示されます。一番下までスクロールして、Shiftを押しながら最終行をクリックすると全て選択することができます。 【③の説明】 表示されているものを列で選択し、「検索と選択」から「条件を選択してジャンプ」で「可視セル」を指定します。その状態で、列番号の見出しの部分を右クリックして「削除」します。
続けてお邪魔します。 No.2で誤記がありました。 ＞上記数式をどらっぐ＆コピー　→　Q2セルを選択・・・ は ＞上記数式をドラッグ＆コピー　→　R2セルを選択・・・ でした。 どうも失礼しました。m(_ _)m
No.1です。 > どうにかして元式を活かして仕上げたいです。 小生には貴殿のご要求内容と元式が理解できていませんでした。 元式を解析すると、以下のようになります。 　元式=F10が空白ならば空白、でなければ(計算式)の値 元式の(計算式)は、 　(0.3333-0.3340)/0.0417*60　…元式、F10が反映されていない。 　(7:59-8:00)/1時間*60　　　　…解釈、"1"分表示？ >> ※『8時00分通常開始』とした場合、『9時30分』と入力すると ”90”と表示される。 ⇒ これは、8時と9時30分の差分を分表示しているだけでしょうが、 　元式ではその計算はしていないはずです。 　また、元式では、F10が空白以外は表示するようになっています。
こんばんは！ VBAになりますが、一例です。 ＞自動で、会社ごとの○○建設のページに自動で一行追加挿入され・・・ ユーザーフォームを使えば簡単にできると思いますが、 ユーザーフォーム作成そのものに手間がかかりますので、 単純に一旦データを消去し、オートフィルタで新たにコピー＆ペーストする方法にしてみました。 ＞また、それが備考欄が「新設」であれば、備考ごとの新設シートにも自動で追加されるようには の部分で「7/10入金」のような備考Sheetも必要なのかどうか判らないので とりあえず「会社名」だけのシート操作をやってみました。 「マスター」シートはシート見出しの一番左側に配置しておいてください。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long, k As Long, sN As String Dim wS As Worksheet, myFlg As Boolean Application.ScreenUpdating = False Worksheets.Add after:=Worksheets(Worksheets.Count) Set wS = Worksheets(Worksheets.Count) With Worksheets("マスター") '←「マスター」は「マスターシート」の実際のSheet名に！★ .Range("A:A").AdvancedFilter Action:=xlFilterCopy, copytorange:=wS.Range("A1"), unique:=True For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row sN = wS.Cells(i, "A") For k = 2 To Worksheets.Count If Worksheets(k).Name = sN Then myFlg = True Exit For End If Next k If myFlg = False Then Worksheets.Add after:=Worksheets(Worksheets.Count - 1) Worksheets(Worksheets.Count - 1).Name = sN End If Worksheets(sN).Cells.Clear With .Range("A1").CurrentRegion .AutoFilter field:=1, Criteria1:=sN .SpecialCells(xlCellTypeVisible).Copy Worksheets(sN).Range("A1") End With Worksheets(sN).Columns.AutoFit myFlg = False Next i .AutoFilterMode = False End With Application.DisplayAlerts = False wS.Delete Application.DisplayAlerts = True Application.ScreenUpdating = True End Sub 'この行まで// ※　最初のマクロ実行では会社名が存在しない場合、シートを追加するようにしています。 Sheet順が意図しない順になっているかもしれません。 その場合はSheet見出しのシートを移動させてください。 ※　「マスター」シートのデータ変更があるたびに マクロを実行する必要があります。m(_ _)m
「備考の列を削除」ではなく「回答以外の列を削除」でも大丈夫でしょうか？ もし、それでよければ、次の操作をお試しください。 手順①③は詳しく説明していますが、それ以外の操作が分からない場合は、補足等で再質問してください。 【手順】 ①「回答」の文字を検索して、すべて選択する。 ②Cntl+0で選択した列を非表示にする。 ③表示されている列（いらない列）を可視セルのみ選択して削除する。 ④非表示になっている列を再表示する。 【①の説明】 「検索と選択」の「検索」で検索文字に「回答」を指定し「すべて検索」すると見つかったセルの一覧が表示されます。一番下までスクロールして、Shiftを押しながら最終行をクリックすると全て選択することができます。 【③の説明】 表示されているものを列で選択し、「検索と選択」から「条件を選択してジャンプ」で「可視セル」を指定します。その状態で、列番号の見出しの部分を右クリックして「削除」します。
何が分からないのかが分かりません
昨日確認して、一応出来そうではあるけど、ある条件下という制約付きですね。 グラフは、何番目という指定方法しか選べないようなので、セルとグラフの関係性が崩れると上手く動作しません。 あとトリガーとしては、セルをダブルクリックした時、が一番しっくりくるかな。
□が1個以上入っている列の数 =SUM((MMULT(TRANSPOSE((A5:K10="□")*1),ROW(A5:K10)^0)>=1)*1) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 注)✅がExcelに張り付けられなかったので、□で代用してます(XL2003)
これでどうですか？ https://support.office.com/ja-jp/article/ピボットグラフを作成する-c1b1e057-6990-4c38-b52b-8255538e7b1c
請求書 (フォーマット)シートって、値が入っていない白紙のひな型ですよね？それをコピーして各月の請求書を作るのですよね？ 例えば、5月分を作るときは、ひな型をコピーし、さらに4月分から継続データだけを張り付けることになりますが、そうなると、継続元のシートを何らかの形で選択してやる必要があります。これって、ちょっと面倒ですよね。 そこで、5月分を作るときは、4月分のシートをアクティブにした状態でマクロを実行し、アクティブシートをコピーして、そこから継続以外の行を削除して上詰めするようなマクロを作った方が、簡単だと思います。 シートのイメージが分からないので、正確なマクロはご提示できませんが、多分、こんな感じです。 シートのイメージとしては、1行目が見出しで2行目以降にデータがあるものとします。 A列には何らかの入力があるものとします。 そして、B列に継続の○が入力されているものとします。 Sub sample() Dim I As Long Dim J As Long ActiveSheet.Copy Before:=Sheets(1) J = 2 For I = 2 To Cells(Rows.Count, "A").End(xlUp).Row If Cells(I, "B") = "○" Then If I <> J Then Rows(I).Copy Destination:=Rows(J) Rows(I).ClearContents End If J = J + 1 Else Rows(I).ClearContents End If Next End Sub
#1の回答の続きですが、ご質問の内容からこんな感じでしょうか。 添付の画像を御覧ください。 この場合は、直接、ComboBox で処理しないで、一旦、サブプロシージャを用意して、その時に排出するListIndex を利用します。特に、あまり13という数が必要ではなく、「東京都」を選んだ時点で、13という数字は確保しています。(ただし、今回は、あえて13を出すようにしています。） それを、今度は、本来は、47個分の地域名のリストが入っているのですが、今は、北海道と神奈川だけですが、こんなリストを作ります。カンマの間にセルの範囲のアドレスを入れます。 Const AREALIST = ",c2:c189,,,,,,,,,,,e2:e62,g2:g59" それを配列にしてあげて、ListIndex の数字で呼び出して、 e2:e62　が出てきたら、ComboBox2 のListFillRangeに入れます。 この配列にきちんと合わせなくてはなりませんが、面倒なら、VLookUp関数などを使うと良いです。 '// Private Sub ComboBox1_Change() 　　Dim L_indx As Long 　　L_indx = ComboBox1.ListIndex + 1 　　If ComboBox1.ListCount >= L_indx And L_indx > -1 Then 　　　　Call AreaChange(L_indx) 　　End If End Sub Sub AreaChange(indx As Long) Dim myLists Const AREALIST = ",c2:c189,,,,,,,,,,,,e2:e62,g2:g59" myLists = Split(AREALIST, ",") ComboBox2.ListFillRange = "Master!" & myLists(indx) ComboBox2.ListIndex = 1　'変更になったことを示すため End Sub '// この場合は、#1と話が違うと思われるかもしれませんが、ComboBox1ひとつだけのためなら、そのComboBox1 の直下に置くことも多いですが、これが、他のシートにも関係してくるとなると、標準モジュールに置かざるを得ません。 サブプロシージャは、他のシートからも呼び出せないわけではありませんが、面倒な上に煩雑になります。煩雑ということは、同じものを数多く作ってしまうことです。後になって、異様にシートが重くなってから気がついた時には、手がつけられなくなっています。 ということで、私の方では、最近は、フォーム・コントロールを多く用いるようになりました。シートをコピーしても問題ないということもあります。その上、マクロは一つでたります。
No.3の回答で数式を見るかぎり、A列および1行目を使用していないことが分かります。 さらに添付図のN1セルには「行」Q1セルには「列」と書きましたが、 行番号に+1したもの、(R1C1参照形式の)列番号に+1したものです。 検証用でどの位置なのか、確かめ算もしています。 初心者だからって謝ったり(または、威張ったり)しないで INDEX関数を勉強してください。求める解答が得られるはずです。 =INDEX(配列,行番号,列番号) http://excel.onushi.com/function/f-index.htm
サンプルがないのでよくわかりませんが、 A1セルに対し =LOOKUP(10^15,MID(A1,FIND("ＮＯ，",A1)+3,{1,2,3,4,5,6,7,8,9,10,11,12,13,14})*1)
ん～、よくわからないけど Range("Ｂ" & GYOU1　＋　6 　& ":Ｅ" & GYOU1).Value の GYOU1　＋　6 　の６を＋は何か意味があるのでしょうか？ ②毎回２行づつ入力するので抽出するのは最終行とその上の１行の２列をファイル3に抽出したい。 Range("Ｂ" & GYOU2 & ":Ｅ" & GYOU2).Value = Range("Ｂ" & GYOU1 -1 & ":Ｅ" & GYOU1 -1).Value Range("Ｂ" & GYOU2 +1 & ":Ｅ" & GYOU2 +1).Value = Range("Ｂ" & GYOU1 & ":Ｅ" & GYOU1).Value では・・ ①Ｂ列は最初から数字が入っているため、抽出するのはＢ列～Ｅ列がすべて入力されている時 スマートではないですが IF Range("Ｂ" & GYOU1 -1 ).Value<>"" Then IF Range("C" & GYOU1 -1 ).Value<>"" Then IF Range("D" & GYOU1 -1 ).Value<>"" Then Range("Ｂ" & GYOU2 & ":Ｅ" & GYOU2).Value = Range("Ｂ" & GYOU1 -1 & ":Ｅ" & GYOU1 -1).Value End If End If End If を2回記述するとか ただ、作業的には、この2行に空白があったら何もしない方が良くないですか。 If WorksheetFunction.CountBlank(Range("A" & GYOU1 -1 & ":D" & GYOU1)) Then MsgBox "空白のセルがあります。全て入力して再度実行してください" Exit Sub End If を最初に入れた方が良ないのかなと思ったりしますが・・
ANo4です。 なんだか大変なことになっているようですね。 その辺になるとさっぱりわからないので、お役には立てないですが、Windows環境であればVBScriptも使えると思いますので、No4は関係なさそうです。 エクセルの関数表示でハングアップしちゃったみたいですが、その際にはマクロ（VBA）自体は動作していないので、内容が関係しているとも思えません。 エクセル本体のインストールがどこか不完全だったのか、あるいはOSがらみなのか・・・ 智識の無い私が考えたところで、何の足しにもならないですね…(^_^;)
まずは、行列/検索関数をマスターしてください OFFSET関数は、読み飛ばして結構です http://excel-ubara.com/excel3/EXCEL015.html No.4のhallo-2007さんの回答でひき数を合わせるだけでできることが分かるはず。 冗長部分をすっきりさせてみました B2セルに =CHOOSE(SUM(1*(COUNTIF($F:$F,$A2)>={0,1,2})),"", INDEX(G:G,MATCH($A2,$F:$F,0)),"重複") 右へ下へオートフィル
＞計算式を残して値だけを消す方法 そんなモノ無い。 計算式があれば、計算結果が表示されるのは明白です。 ・・・ 計算を手動にしても、どこかのセルが編集され確定されたタイミングで計算が行われますので、これも使えないでしょう。 無理やり計算式だけを残すのであれば、計算式の入力されたセルの書式を「文字列」に変えるくらいでしょうか。 これなら計算結果の値ではなく「計算式が文字列」として残ります。
良かったですね。実証済みの事に少しお話をお聞き下さい。リカバリー直後ですので タスクバーに[W--10のグレードアップアイコン]がまだ表示されておらないかもしれませんがいずれは意に関わらず表示されます。１[コントロールパネル] ２[プログラムのアインストール] ３[インストールされた更新プログラム表示](左画面上) ４メニユー内に [KB 3035583]を[右]クリックで[アインストール]をクリックして下さい。５[今すぐ再起動]してください。 もう一度 ６[コントロールパネル]に戻って下さい。7 [システムとセキュリティー] 8 [Windows Update] 9 [更新プログラムの確認](１～２分かかります) 10 [利用可能なプログラム](重要推奨)(オプションにはチェックをしないでください) 開き 11 [KB 3035583]-[Windows10Homeバージョン1511,10586にアップグレード]を右クリック 12 [非表示]クリック 13 [非表示の更新プログラムの再表示]非表示になっているか確認して下さい。[✖]で閉じて下さい。タスクバーに[W--10グレードアップアイコン]が表示されましら1～13の動作をその都度行って下さい。長くなりました。
sheet2のK5セルに =sheet1!L2 と入れ、K5セルの表示形式のユーザー定義に [=1]"エビ";[=2]"イカ";G/標準 と入力する。 ただし、見た目がエビやイカになるだけでデータは1や2のままです。 「表記されるようにするには」というご希望だったので。
=COUNTIFS(データF!$B:$B,$B25,データF!$C:$C,$A25,データF!$Q:$Q,"",データF!$K:$K,"<>") です。
こんばんは！ 画像通りに配置だとするとSheet2のB4セルに =IFERROR(INDEX(Sheet1!$C$1:$C$1000,SMALL(IF(Sheet1!$A$1:$A$1000="○",ROW($A$1:$A$1000)),ROW(A1)+(COLUMN(A1)-1)*10)),"") 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　B4セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ B4セルのフィルハンドルで下へ13行目まで（10行分）コピー　→　そのまま右へコピーしてみてください。 こんな感じではどうでしょうか？m(_ _)m
こんばんは！ 何とか関数で！と思ったのですが、 4個以上連続の除外が面倒なのでVBAでやってみました。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆　ペースト　→　Excel画面に戻り（VBE画面を閉じて） マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long, k As Long, cnt As Long For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row If Cells(i, "A") = Cells(i + 1, "A") Then k = i + 1 Do While Cells(k, "A") = Cells(i, "A") k = k + 1 Loop If k - i = 3 Then cnt = cnt + 1 End If i = k - 1 End If Next i MsgBox cnt End Sub 'この行まで// こんな感じではどうでしょうか？m(_ _)m
こんばんは！ 画像の配置通りだとSheet2のA2セルに =IFERROR(INDEX(Sheet1!$A$1:$A$1000,SMALL(IF((Sheet1!$B$1:$B$1000=A$1)*(Sheet1!$C$1:$C$1000=""),ROW($A$1:$A$1000)),ROW(A1))),"") 配列数式になりますのでCtrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　Sheet2のA2セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 最後にA2セルのフィルハンドルで列・行方向にコピーしてみてください。m(_ _)m
VLOOKUPで、 シート２のB列にシート１のA:Bを指定 =VLOOKUP(E2,$A$2:$B$4,2,0) すれば、名前と一致した電話番号が 転記してくれるはずです。 いかがでしょうか？
全セルを選択した状態で「条件付き書式の設定」を図のようにします。
つづけてお邪魔します。 ＞tom04さんの方法でやってみましたが上手く行かないようです ん？どのように上手くいかないのでしょうか？ どんな結果が返りましたか？ こちらではお手元のデータがどのようになっているのか判断できませんので 具体的な結果を教えてもらわないとアドバイスのしようがありません。 考えられる原因としては ①　数値データが「文字列」になっている。 ②　「東京」のセルの前後に余計なスペースなどが入っている。 この程度しか思い浮かびません。 ※　前回は2行目以降の範囲としましたが、実際は1行目から範囲指定しても構いません。 「東京」の下のセルの合計が表示されますので =SUMIF(A1:G1000,"東京",A2:G1001) としてみたらどうなりますか？m(_ _)m
>セルにリンクさせるにはどうしたらいいでしょうか？ ActiveX 側の場合は、開発タブの中の青い三角定規をクリックして、デザインモードにしてから、オプションボタンを右クリックして、プロパティをクリック。 次に、"Linked Cell"に、該当するセルを書き入れます。
先ほど言ったようにサイトによって処理が違いますので、テストする事も出来ませんし、「SendKeys」は誤動作が多いのであまり使わない方が良いと思います。 「webセキュリティ」についてもブラウザの処理で対応した方が良いと思います。
まだ諦めていないのであれば、ご参考までに。 下記の例では、Sheet1のA列の”A”を数えて、その数だけSheet2のセルに色を付けるものとしています。 Sheet2の色を付ける部分は、A1、B1、C1、･･･です（連番が振ってあれば、どこでも良いのですが･･･）。 まず、Sheet2のA1セルから横に、１からの連番を振ります（”A"の数の上限まで振ります）。 次に、連番を振った範囲を選択して、次の条件付き書式を設定します。 【条件付き書式設定】=A1<=COUNTIF(Sheet1!$A:$A,"A") もし、連番が邪魔なら文字色を白にしてください。色が付いたときに数字が浮き出すので、逆にお洒落だったりします。
動的変更はVariant宣言して置けば可能です。 以下が解説です。 http://officetanaka.net/excel/vba/statement/ReDi …
No.1です。 投稿後気づきました。 ＞3)「Sheet2」はタテ1列で昇順で並べる必要があります を見逃していました。 ↓のコードに変更してください。（並び替えのコードを追加しています） Sub Sample2() Dim i As Long, j As Long, cnt As Long, wS As Worksheet Set wS = Worksheets("Sheet2") wS.Range("A:A").ClearContents '←Sheet2のA列データを一旦消去// With Worksheets("Sheet1") For i = 2 To .Cells(Rows.Count, "A").End(xlUp).Row '←2行目～A列最終行まで// For j = 2 To 11 '←B列～K列まで// If .Cells(i, j) <> "" Then cnt = cnt + 1 wS.Cells(cnt, "A") = .Cells(i, j) End If Next j Next i '▼追加（並び替え）// wS.Range("A:A").Sort key1:=wS.Range("A1"), order1:=xlAscending, Header:=xlNo End With End Sub どうも失礼しました。m(_ _)m
C2ルの式　=A2*TIMEVALUE("08:00")+B2 ※表示形式については、No1.B_oneさんのおっしゃる通りです。 念のため、出勤日数を25日にして、テストすることをお勧めします。
前回の質問 https://oshiete.goo.ne.jp/qa/9283188.html 前回の回答をしたので考えてはみたのですが、結局 No.1のtom04さんと同じです =INDEX(Sheet1!$A:$A,SMALL(IF(INDEX(Sheet1!$B$3:$D$6,,MATCH($A3,Sheet1!$B$2:$D$2,0))=B$2, ROW(Sheet1!$B$3:$D$6)),COUNTIF($B$2:B$2,B$2))) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる ↑数式は難しいので、C1、C2って分ければよいような気がします。
たびたびごめんなさい。 SUMIFS関数が使えました。 F9セルの数式を =IFERROR(SUMIFS(INDEX($3:$5,,MATCH(E9-DAY(E9)+1,$2:$2,0)),B$3:B$5,E9,C$3:C$5,D9),"") にしてみてください。 ※　前回のSUMPRODUCT関数でも大丈夫ですが SUMPRODUCT関数そのものが配列数式になりますので、 SUMIFS関数の方が良いかもしれません。 何度も失礼しました。m(_ _)m
C21は反比例と考えたときの値 =1/TREND(1/$B$2:$B$16,$A$2:$A$16,A21) D21は、上記のグラフから累乗近似させて出た数式をはめ込んでみた値 =62.623*A21^-1.0011
>file filterを変更すればいいのでしょうか？ はい。それで大丈夫です（すいません。細かいところの考慮が漏れていましたね）。 プログラムコードの４～5行目ですが、次のように　InitialFileName:="*.csv"　を入れた方が、さらに良いかもしれません。お試しください。 fileSaveName = Application.GetSaveAsFilename( _ InitialFileName:="*.csv", _ fileFilter:="CSV Files (*.csv), *.csv")
☆セルから自動抽出の場合 たとえば「Sheet1」というシートに下図のような物を作れば、以下の様にしても良いです。 ------------------------------------------ Sub test() Call データ抽出(Range("A2").Value,Range("B2").Value,Range("C2").Value) End Sub ------------------------------------------
私は、あまりこういうのは詳しくないけれども、ピボットテーブルでできるのではないでしょうか？ただし、例えば、日付、顧客名とか、アイテムとか、合計とか、項目行をつけないとできませんが。それとも、VBAマクロや関数で、セルに出力するのがお望みなのでしょうか。 ピボットテーブルなら、こんな具合です。
こんな風な物を作ればマクロから呼べます。 Sub test() Call データ抽出(#5/29/2016#, 1, 1) End Sub
どこが重複項目かも判断してA2セルに =IF(B2<>"",ISNUMBER(MATCH(B2,マスタ!B:B,0))*10000) +IF(C2<>"",ISNUMBER(MATCH(C2,マスタ!C:C,0))*1000) +IF(D2<>"",ISNUMBER(MATCH(D2,マスタ!D:D,0))*100) +IF(E2<>"",ISNUMBER(MATCH(E2,マスタ!E:E,0))*10) +IF(F2<>"",ISNUMBER(MATCH(F2,マスタ!F:F,0))) で重複しているマスタの行番号を返す (複数項目に重複が及ぶ場合は、左の項目優先で) =IF(A2=0,"",MATCH(INDEX(B2:F2,5-INT(LOG(A2,10))),INDEX(マスタ!B:F,,5-INT(LOG(A2,10))),0)) 余談ですが >=OR(B2=マスタ!B:B,C2=マスタ!C:C,Sheet2!D2=マスタ!D:D,Sheet2!E2=マスタ!E:E,Sheet2!F2=マスタ!F:F) は Sheet2!A2に入力しているとして =OR(B2=マスタ!B2,C2=マスタ!C2,D2=マスタ!D2,E2=マスタ!E2,F2=マスタ!F2) と同じ計算になります。
「対応済」にするときは、計算式が入っているあA2セルを潰して文字で上書きしてしまうのですか？普通、そんな事はしないと思います。 一般的には、開始日と終了日の２つのセルを用意して、開始日が未入力の場合は「未着手」。開始日が入力されたら「作業中」。終了日まで入力されていれば、「対応済み」とするのでは？
「$」を付けないと範囲がずれてしまいます。
こんにちは！ Sheet1のC2セルに =VLOOKUP(A2,Sheet2!A:E,MATCH(B2,Sheet2!$1:$1,0)) または =INDEX(Sheet2!A:E,MATCH(A2,Sheet2!A:A,0),MATCH(B2,Sheet2!$1:$1,0)) という数式を入れフィルハンドルで下へコピーしてみてください。 ※　エラー処理はしていません。m(_ _)m
こんにちは！ 列方向のデータは12月のＯ列まであるとします。 =IFERROR(SUMPRODUCT((B3:B9=E13)*(C3:C9=D13),INDEX(D3:O9,,MATCH(MONTH(E13),MONTH(D2:O2),0))),"") 配列数式ですのでCtrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　F13セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 こんな感じではどうでしょうか？m(_ _)m
No.1です。 画像のアップの仕方の質問について。 本題とは離れますが・・・ 色々やり方はあると思いますが、当方はPCに入っている「ペイント」を使っています。 やり方です。 ①　Altキー＋Print Scキーを押下 （何も変化はないのですが、ちゃんとモニタの画面が記憶されています） Altキーを押さない場合は画面全体が記憶されます。 Altキーを押すことでアクティブになっているアプリ画面だけが記憶されます。 ②　PC内の「ペイント」を立ち上げる このときキャンバス（白い部分）が広すぎるとキャンバス全体がアップされてしまいますので 極力キャンバスは小さくしておきます。（極端に小さくても構いません） ③　画面左上にある「貼り付け」ボタンを押下 これで先ほど記憶された画面が表示されます。 このままアップしたのでは必要部分が小さすぎて見えにくいので ④　メニューの「トリミング」の右側にある「選択」をクリックし必要部分をトリミング（マウスでドラッグし範囲指定）し、その中で右クリック　→　コピー ⑤　ファイル　→　新規　→　保存確認の画面が出ますが「保存しない」を選択 ⑥　もう一度白いキャンバスだけの画面になりますので、画面左上の「貼り付け」 これでトリミングした部分だけが貼りつきます。 ⑦　ファイル　→　名前を付けて保存　→　ファイルの種類でJPG形式を選択し好みの名前（「半角英数」だけの方が良いみたいです）を付けて保存します。 以上で画像の保存は完了です。 最後にアップする場合は「教えてgoo」のサイトの質問文を入力する左下にカメラのマークがありますので そこをクリックし先ほど保存した画像を選択すれば↓のように画像がアップされるはずです。
エクセルでは印刷サイズは印刷してみないとわかりません。エーワン、コクヨ、エルコムが無料で配布しているラベル印刷用のソフトを使いカスタム設定でラベルのサイズを指定して印刷されてはどうでしょう。 エーワン http://www.labelyasan.com/ コクヨ http://www.kokuyo-st.co.jp/stationery/awase/ エルコム http://www.elecom.co.jp/rakupuri20/
指定範囲を変えましたが普通に反映されます。 D121セルには計算式が入っている訳ですよね。
No.12の回答で回答者のナンバーを書き間違えていましたね。 No.5ではなくNo.6の回答ですね。 No.5の回答も参考になりますから、どれを採用するかの違いですね。 紛らわしい書き方をNo.12の回答でしたことを謝ります。
特定セルをA1とします。 Range("A1").Characters(Start:=Len(Range("A1")), Length:=1).Font.ColorIndex = 2 A1の文字列の長さをはかり、最後から数えて1文字目の色を2（白）に変えています。
こんばんは！ B4セルに =IF(AND(B2>=$A2,B3<=$A3),"○","×") という数式を入れフィルハンドルで右へコピー！ これではどうでしょうか？m(_ _)m
こんにちは。 私のセキュリティの場合、ハイパーリンク設定はあっても、メッセージが出て、開かないので、一応、その話は置いておきます。誰もおなじだと思っていたからです。 ◎先頭の4文字の一致でリンクを貼る様にしたい場合どのようにしたらよろしいでしょうか？ >C列が111となり、ファイル名が 『111 名前 所属.xlsm』の場合リンクが貼られずうんともすんとも言わない、といった状況です。 この場合は、先頭の4文字は、一意でおなじものがないという条件ですね。つまりインデックスというわけです。 >If Left(TargetFile, 4) = Cells(i, 3) Then それで、元のコードでは、こうなっていたわけですね。(この場合の文字比較は、ちょっと難しいです。） 私のコードは、ひとつ変えれば済むだけです。 私の考え方は、[111 名前 所属.xlsm]というファイル名のあるファイルを探して、あるか・ないか、というのが、目的となっていますから、 '//以下、2行の書き換えで済むはずです。 fn = Trim(Left$(Cells(i, 3).Value, 4)) '① TargetFile = Dir$(指定フォルダ & fn & "*.xlsm", vbNormal) '// ".xlsm" → "*.xlsm" と、アスタリスクを入れてください。 (.xlsx, .xlsm, .xls を探すなら、[xls?] です。） それと、念の為に、Trim 関数を用いました。 >C列の数字が68となっている場合、②のファイルを認識してリンクをはるということが可能なのでしょうか？ '①で、先頭の数字を探すというとこですね。それを間違えてしまうと、探しだせません。つまり、C列は、数字のみが入っているという条件ですね。 でしたら、問題はありません、数字にダブりがないことが条件です。 それと、余計な心配ですが、見つからなかった場合の記録を残すなら、以下のような方法でも可能です。 　If TargetFile <> "" Then　(ファイルが見つかった場合） 　 　Else 　　　''見つからなかった場合は、 　　　Debug.Print fn 　　　fn="" 　End If >手動でファイル名とC列の数字に0を足すなどして対応しようと思います。 >(5⇒0005)のように ゼロパディングですね。これ自体、マクロでも可能です。 手順は、手動でやるのと同じことですが、VBAマクロなら早いというだけです。 ただ、タイム・スタンプをそのままに残すというと、ちょっとややこしいような気がしました。これも可能だと思います。 それにしても、私も、これを手本にして、ファイルの整理をしようかと思うようになりました。いつも、月末にファイルを探していますからね。（^^;
#5です。 また間違えました。 そそっかしくてすみません。 　 C3セルには　=COUNTIF($N:$N,1) 　 D3セルに、 =COUNTIF($N:$N,2) 以下J列まで3，4，5・・・7，8と設定します。 K3(合計)は =Sum(C3:J3)
「Excel 2007 以降の場合、標準では用意されていないので、クイック アクセス ツール バーに追加などして機能を追加します。」 https://support.office.com/ja-jp/article/%E3%82% …
こんにちは！ 普通は金利計算等の問題があると思いますが、 今回は単純に左側の表の入力があれば右側のような表にしたい！というコトですよね？ ↓の画像で F6セルに =IF(OR(COUNTBLANK(D$6:D$10),D$7<ROW(A1)-1),"",ROW(A1)) G6セルに =IF(F6="","",TEXT(EDATE(D$6,F6-1),"e")*1) H6セルに =IF(F6="","",MONTH(EDATE(D$6,F6-1)) という数式を入れそれぞれをフィルハンドルでずぃ～～～！っと下へコピーしておきます。 I列だけは1行目と2行目以降の数式を変えます。 I6セルは =IF(D8="","",D8) I7セルに =IF(F7="","",D$9) という数式を入れ、I7セルのフィルハンドルで下へコピー！ これで画像のような感じになります。 ※　D10セルの合計金額とI列の合計が異なりますが、 それはそれで良いのでしょうか？m(_ _)m
COUNTIFとか範囲を返したいとか、説明とサンプルがかみ合ってないと思いました サンプルを信じて L2セルに =COUNT(1/(INDEX($B2:$D2,MATCH(L$1,$B$1:$D$1,0))="A"), 1/(INDEX($G2:$I2,MATCH(L$1,$G$1:$I$1,0))="A")) 右へ下へオートフィル 余談です。 エラーが出るならどのようなエラーなのか返答したほうが良いです たぶん、＃N/Aだとは思うのですが。 また、OFFSET関数も範囲を返しますが、INDEX関数でも範囲を返せます。
こんばんは。ママチャリです。mika_riririnさん、頑張って読んでくれてうれしいです。 「C列の値も同様にする」であってますよ。ただ、A列は単独のセルなので代入で実装しましたが、C列はC~最終列までを範囲で移送する必要があったので、Copyを使っています（最初、代入でやってみたのですが、うまく動かなかったのでCopyにしました）。 「○の数が同じ場合、一番上を残すようにする」には、次の行をちょっと直せば、いけるような気がします。 ElseIf Count○(MyRng.Rows(I)) > Count○(MyRng.Rows(I + 1)) Then mika_riririnさんの頑張に敬意を表して、今回はヒントだけにしました。
>>複数人による、データ入力を防ぐ >>相手のデータ【先に入力】した人のを消す事は出来ません。 これは競合の問題とは視点が違います。 根本的に「競合問題」の発想が間違っていると思います。 同時瞬間に競合が起こった場合、先取者を優先し、後者を待たせるのが競合問題を起こさせない排他制御。 排他制御や競合制御では、待たせた後、後者は書き込めるのです。 後者の書き込みが数秒遅れで発生したら、後者の書き込みは問題なく許されます。 質問内容は競合問題では無く、 「１箇所の書き込みは１人しか出来ない様にするにはどうしたら良いですか？」と言う問題です。 運用で逃げるしか方法は有りません。 排他競合制御の問題ではありません。
あ、そうだったんですか。 すいません。 過剰に反応してしまいました…
改定前の説明では以下の様になってますが同じではありませんか？ 本書 P.255の「1 模擬試験プログラムの起動」に記載しています。
=INDEX($B$3:$B$6,MATCH(D9,$C$3:$C$6,0))
”FY"　と　数字4桁の組み合わせなら ＝”FY"&Right(A1,4)+1 ”FY"　と　数字の組み合わせなら =”FY"&RIGHT(A1,LEN(A1)-2)+1 アルファベット2文字　と　数字の組み合わせなら ＝LEFT(A1,2) &RIGHT(A1,LEN(A1)-2)+1 このへんをやりくりすれば希望の結果になるでしょうか？
回答が付かないようなので、とりあえずです。 その前に確認なのですが、各データ（曜日とか）は、ひとつのセルにひとつずつ入力されているのですよね？ また、曜日は月~金で土日は無いのですよね？ であれば、こんな感じです（ユーザ定義関数です）。 ２行目A列から横に週データ、3行目A列から横に曜日が入力されているものとします。 適当なセルに、=MyCountIf(1,A3:I3,A2:I2)　のように入力します（I列までデータがある例です）。 1番目のパラメータは、第何週目を集計するかを指定します。 Function MyCountIf(週目 As Long, 曜日 As Range, 週データ As Variant) As Variant Dim i As Long Dim w As Long w = 1 For i = 1 To 曜日.Count If 週目 = w Then If 週データ.Item(i).Value <> "" And _ 週データ.Item(i).Value <> 0 Then MyCountIf = MyCountIf + 1 End If End If If 曜日.Item(i).Value = "金" Then w = w + 1 Next i End Function
こんばんは！ すでに回答は出ていますが、「A」SheetのH2セルにはシリアル値が入っているという前提です。 Sub Sample1() Dim wS As Worksheet Worksheets.Add After:=Worksheets(Worksheets.Count) Set wS = Worksheets(Worksheets.Count) With Worksheets("A") '←「A」は実際のSheet名に！ wS.Name = Format(.Range("H2"), "yyyy年m月") .Range("A1:F27").Copy wS.Range("A1") End With End Sub ※　元データのSheet名が「A」というコードにしていますので、 実際のSheet名にしてください。 ※　月に1度だけ実行するコードです。 2度以上実行するとすでに存在するSheet名にすることはできませんのでエラーになります。 （日付までをSheet名にするのであれば1日1度は可能です）m(_ _)m
添付図参照 I1セルに日付 J2セルに =IF(COUNTIF(INDEX($B$2:$G$20,,MATCH($I$1,$B$1:$G$1,0)),J$1&"")<ROW(A1),"", INDEX($A$2:$A$20,SMALL(IF(INDEX($B$2:$G$20,,MATCH($I$1,$B$1:$G$1,0))=J$1,ROW($A$2:$A$20)-1),ROW(A1)))) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 右へ下へオートフィル I:O列を切り取って貼り付け 適宜、範囲を変更してください 改行まではエラー処理なのでXL2007以降ならIFERROR関数使ってください 参考まで
念の為ですが 関連づけを一度別の物にして確定した後に、もう一度設定し直してもダメでしょうか？
出したい答えが 0から始まるただの連番だというなら 無駄を省けます。 元々あった A列を削除（あってもいいけど）して 先頭に1列挿入 B1：=SUM(A2,B2) データ最終行までコピー C2：=IF(B$1<ROW(C1),"",MATCH(B$1-ROW(C1)+1,B$1:B$100,-1)-1) 好きなだけコピー .....A.....B....C 1.........12 2....1...11....0 3....2....9.....1 4....0....9.....1 5....2....7.....2 6....1....6.....3 7....2....4.....4 8....0....4.....5 9....2....2.....5 10..1....1.....6 11..1....0.....7 12...............8 13...............9 14.. MATCHの検索範囲は列にしない方が軽いです。
ごめんなさい。記述ミスがありました。下記の部分を訂正してみて下さい。 誤）On Eror GoTo Err_fin 正）On Error GoTo Err_fin ちなみに、エラーが表示されるのは、コピーをせずにペーストしたような場合だけですよね？通常のコピペでできないような操作を行うと、MyPasteでも当然エラーになります。エラーになった場合は、"貼り付けに失敗しました。"のメッセージが表示されるはずです。
【訂正】 なので10^1/5をニュートン法で求める (誤)a[k+1]=f(a[k])/f'（a[k])　　(正)⇒a[k+1]=a[k]-f(a[k])/f'a[k] から ----------------------------------------------------------------------
sheet2のセルY1に「=VLOOKUP($A1,Sheet1!$A$1:$D$9,2,0)」 sheet2のセルZ1に「=VLOOKUP($A1,Sheet1!$A$1:$D$9,3,0)」 sheet2のセルAA1に「=VLOOKUP($A1,Sheet1!$A$1:$D$9,4,0)」 と入力してその数式を下へコピペしてみてください。 ちなみに参照元のsheet1のデータは現在A1からD9までの絶対参照になっているので、例えばD1000までデータがある時は「9」を「1000」に変えてあげてください。
根本的に発想を転換しないと出来ないような気がします。そこで… 作業グループというのをご存知すか？ シートを複数選択することにより、同時に複数のシートを操作するというものです。 例えば、Sheet1とSheet2を選択してから、Sheet1に行を挿入するとSheet2にも同様の行が挿入されるようになります。 これを使えば、Sheet2からSheet1を参照するための関数すら不要になります。 ただ、作業グループにするのを忘れてSheet1を編集してしまうと、その内容はSheet2に反映されません。 そこで、Sheet1をアクティブにしたタイミングで、必ず作業グループ設定するようなマクロを組み込むと便利です。 次のVBAをSheet1オブジェクトのWorksheet_Activateイベントプロシジャに張り付けて下さい。すると、Sheet1を開くたびに、Sheet1&２が作業グループ設定になります。 【Sheet1オブジェクト】 Private Sub Worksheet_Activate() Sheets(Array("Sheet1", "Sheet2")).Select End Sub 追伸 私の環境（Windows10、Excel2010)に問題があるのかもしれませんが、作業グループにした後、Sheet2の単独選択にしようとしてSheet2をクリックしても、作業グループが解除されませんでした。 もし同じ現象がでたら、Sheet2オブジェクトのWorksheet_Activateイベントプロシジャに次のVBAを張り付けてみて下さい（とりあえず、私の環境ではうまくいってます）。 【Sheet2オブジェクト】 Private Sub Worksheet_Activate() Sheets("Sheet2").Select End Sub
配列を使える関数は、全ての関数では無いから。 使える関数、使え無い関数があります。 少なくとも実行行が2行からなら、例えば $A$1:$A$999=A1は、E2列に入れるなら、２行目からの記述にして $A$2:$A$999=A2としてコピーしないとズレル。 ここで論争しても何も解決しません。 配列数式を色々調べて習得する方がマシです。 これで投稿終わりとします。
希望するものではないかもしれませんが。 4行目の「4月」から「3月」までは、EOMONTH関数で月末の日付を用意 して、表示形式で「4月」から「3月」にします。 （開始日を今年度の初日にして、列数から1引いた数で月数に） =EOMONTH("2016/4/1",COLUMN()-1) 月末を基準にすることで、その月内に指定の日があるかどうかを判断 して、[条件付き書式]で塗りつぶしをします。 ** 「承認日」の場合 ** =MONTH($A$2)=MONTH(A$4) これでA1とA4の月が一致すればTRUEになるので判断できます。 （8行目は、その判断をしていることを確認できるようにしたもの） ** 手続①の始めと終わりの場合 ** =AND($B$2<=A$4,EOMONTH($C$2,0)>=A$4) これは、B2とA4の月末と比較したものと、C2とA4の月末を比較したもの との両方がTRUEになるものを判断するものです。 （9行目は、その判断をしていることを確認できるようにしたもの） ** 手続②の始めと終わりの場合 ** =AND($D$2<=A$4,EOMONTH($E$2,0)>=A$4) これも同じことですね。 （10行目も同じ） たぶん2行目が増えても、同じような方法で対応できると思う。 これらを[条件付き書式]で利用すれば、希望していることに近いものが できると思います。
こんにちは。 マクロを勉強中とのことで。 大変なことも多いでしょうが頑張ってください。 ↓この部分のコードを Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _ :=False, Transpose:=True ActiveSheet.Paste ↓このコードに置き換える Selection.PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, SkipBlanks:= _ False, Transpose:=True コードを拝見するとおそらくマクロの記録から作られているコードなのかなと思いました。 置き換えるコードは貼り付ける時に[形式を選択して貼り付け]---[行列を入れ替える]にチェックをつけて実行したコードです。 やってみてください。
こんなのもありかな =SUM(SUMIF(B1:B31,"日",C1:C31),SUMIF(A1:A31,IF(TEXT(D1:D20,"aaa")<>"日",D1:D20),C1:C31)) とか =SUM(SUMIF(B1:B31,"日",C1:C31),SUMIF(A1:A31,D1:D20,C1:C31),-SUMIF(A1:A31,IF(TEXT(D1:D20,"aaa")="日",D1:D20),C1:C31)) いずれも [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 作業列で良いと思いますけどね =IF(OR(TEXT(A1,"aaa")="日",ISNUMBER(MATCH(A1,$D$1:$D$20,0))),C1,"") 下へオートフィル その合計が解
こんにちは。 質問文を何度か読み返してみたのですが具体的なファイル構成＆シート構成が見えてこず、どんなことがやりたいのかもイマイチ分かりませんでした。 実際にコーディングしたものがバグっているのならばバグっている箇所のコードを貼り付けてどのようなエラーが出ているのかを書かれると分かりやすいかと思います。 もしその前の段階で困っておられるならば例として具体的なファイル名、シート名などを登場させた上で「こことここからここへ貼り付けたいのだけれども・・・」などの質問方法にされると読み手もイメージが湧きやすく回答しやすいです。 もしこの回答を読まれましたら補足で書いてみてください。
どこにこのコードを記入していますか？ ワークシートモジュールのボタンクリックイベントに書き込んでいるならば、他のシートを操作する事は出来ません。 このコードは標準モジュールの「Sub OOO」～「End Sub」の間に書き込んで、ボタンクリックイベントには「Call OOO」としないとダメです。
VBカテゴリで気が付きましたので、訂正したものを出しておきます。 ただし、まだまだ、改良の余地があります。 ご自身で研究されて、より良いものを目指してもよいかと思います。 '// Sub Categorizing_Sample() 　　Dim objDic As Object 'New Scripting.Dictionary 　　Dim i As Long, m As Long, j As Long, k As Long 　　Dim LastRow As Long 　　Dim dat 　　Dim ar 　　Dim Wkb As Workbook 　　Dim fn As String 　　Dim myPath As String 　　Dim strErr As String 　　 　　myPath = Application.DefaultFilePath 　　If Right(myPath, 1) <> "\" Then myPath = myPath & "\" 　　'******************* 　　'ユーザー設定 　　'もしデフォルトのフォルダーを使わないなら、上記のもmyPath..+If Right.. 　　'の２行を削除して、この下の行に、myPath =(フルアドレスのフォルダーを書いてください 　　myPath = myPath & "Test1\" 　　 　　'******************* 　　LastRow = Cells(Rows.Count, "B").End(xlUp).Row '最後の行を探す 　　dat = Range("B5:D" & LastRow).Value '配列に置き換え 　　'**************************** 　　Set objDic = CreateObject("Scripting.Dictionary") 　　 　　For j = 1 To UBound(dat, 2) - 1 　　　　For i = 1 To UBound(dat) 　　　　　　If dat(i, j) <> "" Then 　　　　　　　　If objDic.Exists(dat(i, j)) Then 　　　　　　　　　　objDic.Item(dat(i, j)) = _ 　　　　　　　　　　objDic.Item(dat(i, j)) & "," & dat(i, UBound(dat, 2)) 　　　　　　　　Else 　　　　　　　　　　objDic.Add dat(i, j), dat(i, UBound(dat, 2)) 　　　　　　　　End If 　　　　　　End If 　　　　Next i 　　Next j 　　m = 0 　　 　　For i = 0 To objDic.Count - 1 　　　　fn = objDic.Keys()(i) '名前 　　　　If Dir(myPath & fn & ".xlsx") <> "" Then 　　　　　　Set Wkb = Workbooks.Open(myPath & fn & ".xlsx") 　　　　　　With Wkb.Worksheets(1)　　'シート1 　　　　　　　　.Cells(1, 1).Value = objDic.Keys()(i) 　　　　　　　　ar = Split(objDic.Item(objDic.Keys()(i)), ",") 　　　　　　　　k = UBound(ar) 　　　　　　　　.Cells(2, 1).Resize(k + 1).Value = Application.Transpose(ar) 　　　　　　　　m = m + 1 　　　　　　End With 　　　　　　Wkb.Close True 　　　　Else 　　　　　　strErr = strErr & " " & fn 　　　　End If 　　Next i 　　If Len(strErr) > 2 Then 　　　　MsgBox "Err: " & strErr 　　End If End Sub http://bit.ly/1VguE61 psw:このURLの/qa/以降の数字のみ 有効期間は、2016/05/24 17:30:08 - 5/31 同時間まで 場合によっては中途で削除することもあります。
質問の例だと、A1セルからC4セルまでにデータがあるのですね。 複数の条件が一致したセルを求めたいのなら、SUMPRODUCT関数と INDEX関数を組み合わせる数式を使ってみてはいかが。 =INDEX(B1:B4,SUMPRODUCT((A1:A4="東京")*(C1:C4="男性")*ROW(A1:A4))) これでB列の1行目の値が取得できます。 参考サイト http://www.eurus.dti.ne.jp/yoneyama/Excel/kansu/ … 一番下の【SUMPRODUCT関数を使い、複数条件でテータを取り出す】 と同じ方法です。
数式でやるならA1セルに =IF(COUNTIF($B$1:$AD$83,"*?")<ROW(A1),"", INDEX($B$1:$AD$83,SMALL(IF($B$1:$AD$83<>"",ROW($B$1:$AD$83)),ROW(A1)), MOD(SMALL(IF($B$1:$AD$83<>"",ROW($B$1:$AD$83)*100+COLUMN($B$1:$AD$83)-1),ROW(A1)),100))) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる
↓　説明の①が違ってました。 ①「E」と「F」の前についている「$」は絶対参照を意味します。 　・ G4セルに「E4」があった場合、H5セルにコピーをすると「F5」になります。 　・ G4セルに「$E4」があった場合、H5セルにコピーをすると「$E5」になります。 　・ G4セルに「E$4」があった場合、H5セルにコピーをすると「F$4」になります。 　・ G4セルに「$E$4」があった場合、H5セルにコピーをすると「$E$4」のまま変わりません。
＞組んだ日のデータしか有効でなかったのです どこが困っているのかよくわかりませんが タスクスケジューラで、決まった時間に毎日、マクロを実行させる。 データがあれば、取込、取込が終了すれば　Csvファイルを削除 データがなければ、何もしないマクロを準備しては如何でしょうか。
検索条件が単数ならば、SUMIF関数を使う。 検索条件が複数ならば、SUMIFS関数を使う。 ということなので、 ＞末尾の「 S」は、何の意味でしょうか？ という質問には答えようがありません。 定義された方に由来を聞くしかないと思います。 （類推ではわかるような気がしますが）
こんにちは。 マクロ自体は、こんな私でも可能なのですが、調べてみると、 http://talesoftech.blogspot.jp/2011/05/excel-on- … ADODB.Stream が使えないということで、Excel から、直接、UTF-8にエンコーディングできません。今、いろいろ探していますが、JavaScript さえ、どうか分かりません。Windowsとは事情が違うのです。そもそも、HTMLオブジェクトが使えるかさえ分からないです。 [Excel で UTF‐8 の CSV を作成したい] http://answers.microsoft.com/ja-jp/office/forum/ … こういう方法でも、エディタで変換というのもありますが、私として、こうした結論に落ち着くのは、ちょっとうまくないなって思います。 そう言えば、Unixツールの nkf.exe は、使えるそうですから、それを手に入れれば、UTF-8 に自動変換は出来ます。 http://qiita.com/kou_bacchus/items/6448608ee03b0 … $ nkf [options] [file] -w UTF8コードに変換する ファイルの文字コードをUTF-8に変換 $ nkf -w --overwrite hoge.html nkf は、Excelのファイルと同じ場所に置いて置けば大丈夫です。 '// Option Explicit Sub TestSample1() 　　Dim myPath As String 　　'パスが通っているか確認してください。 　　 myPath = "C:\Users\" & Application.UserName & "\Desktop\" 　　 　　Dim fn As String 　　Dim i As Long, j As Long 　　Dim ar1, ar2, buf 　　'--------- 　　Dim Fname As String 　　Dim FNo As Integer 　　Dim TextLine As String 　　'---------- 　　For j = 2 To 4 'D列まで 　　　　For i = 1 To 5 '1～5行 　　　　　　If buf = "" Then 　　　　　　　　buf = Cells(i, 1).Value & "," & Cells(i, j).Value 　　　　　　　　fn = Cells(i, j).Value 　　　　　　Else 　　　　　　　　buf = buf & vbNewLine & Cells(i, 1).Value & "," & Cells(i, j).Value 　　　　　　End If 　　　　Next i 　　　　Fname = myPath & "sample(" & fn & ").csv" 　　　　 　　　　　　FNo = FreeFile() 　　　　　　Open Fname For Output As #FNo 　　　　　　Print #FNo, buf 　　　　　　Close #FNo 　　　　buf = "": fn = "" 　　'nkf.exe を利用する 　　　　Shell "nkf.exe -w8 --overwrite " & Fname 　　Next j 　　MsgBox "終了しました。", vbInformation End Sub '//
「|」という表示になります。とは、カーソルの点滅の事でしょうか？ もしかしたらファイルが破損しているのかもしれません。 次のようにしてコピーした物はどうなりますか？ シートを全選択して「シートの移動またはコピー」で「移動先ブック名」を「（新しいブック）」にして「コピーを作成するにチェックを入れた状態で「OK」ボタンを押して作成したものでは動きますか？
他のシートの同じ項目の値を入力するセルに移動して、半角『=』を入力します。で、マウスを使って数値を入力するセルに移動し、そこでエンターキーを押せば同じ値が入力されるようになります。
15日で1サイクルなので、最右端の右隣りのセルに、その15個前のセルをコピペすれば良いはずです。 こんな感じです。1回のボタンクリックで、7日分を追加しています。 Sub sample() Dim LastCol As Long Dim I As Long LastCol = Cells(1, Columns.Count).End(xlToLeft).Column For I = LastCol + 1 To LastCol + 7 Cells(1, I - 1).Copy Destination:=Cells(1, I) Cells(1, I) = Cells(1, I) + 1 Cells(2, I - 15).Copy Destination:=Cells(2, I) Cells(3, I - 15).Copy Destination:=Cells(3, I) Cells(4, I - 15).Copy Destination:=Cells(4, I) Next I End Sub
一連の作業を手動で実行する事は出来るのですよね？であれば、それを自動記録してみてはいかがでしょうか？ ただ、それだけだとデータ表のファイル名とか最終行数などが固定値となってしまいますが、その部分を汎用化するだけで、そこそこのものは出来上がると思います。 また、自動記録したマクロを補足などにアップすれば、心優しい回答者さんがアドバイスしてくれるかもしれませんよ。
Sheet2!A列に ="" となるような計算結果の数式が書かれているとか？ Sheet2!A列の下の方にも記入済みのセルがあるとか？ 質問にご呈示の数式ではSheet3までの表示できますか？
https://oshiete.goo.ne.jp/qa/9280099.html で =SUMIF(INDEX($3:$3,31):INDEX($3:$3,140),"A",INDEX(4:4,31):INDEX(4:4,140)) を提示済み マクロが分かるなら、数式をマクロで書き直すだけのこと
複雑ですね~。こんな感じでしょうか？ B列のセルが結合されていた場合、その範囲中で○が一番多い行のみを残すようにしてみました。 ちなみに、同率1位がある場合は、複数行が残ります。後は目視確認して、手作業で削除してください。 下記、sampleが主モジュールです。その他にサブモジュールとファンクションがありますが、主モジュールであるsampleを起動してください。 Sub sample() Dim I As Long For I = Cells(Rows.Count, "A").End(xlUp).Row To 9 Step -1 If Cells(I, "B").MergeCells Then Call ExchangeMergeCell(Cells(I, "B").MergeArea.EntireRow) End If If Count○(Rows(I)) = 0 Then Rows(I).Delete Shift:=xlUp End If Next End Sub Private Sub ExchangeMergeCell(MyRng As Range) Dim I As Long For I = 1 To MyRng.Count - 1 If Count○(MyRng.Rows(I)) < Count○(MyRng.Rows(I + 1)) Then MyRng.Cells(I, "A") = MyRng.Cells(I + 1, "A") Range(MyRng.Cells(I + 1, "C"), MyRng.Cells(I + 1, Columns.Count)).Copy _ Destination:=MyRng.Cells(I, "C") MyRng.Cells(I + 1, "A") = "" Range(MyRng.Cells(I + 1, "C"), MyRng.Cells(I + 1, Columns.Count)) = "" ElseIf Count○(MyRng.Rows(I)) > Count○(MyRng.Rows(I + 1)) Then MyRng.Cells(I + 1, "A") = "" Range(MyRng.Cells(I + 1, "C"), MyRng.Cells(I + 1, Columns.Count)) = "" End If Next End Sub Private Function Count○(MyRng As Range) As Long Count○ = WorksheetFunction.CountIf(Range(MyRng.Cells(1, "D"), _ MyRng.Cells(1, Columns.Count)), "○") End Function
INDEXとMATCH関数の組み合わせ。 例えば、下のような表の場合、 C5 =INDEX($A$2:$A$3,MATCH($A5,C$2:C$3,0))
値で張り付けることもできます。こんな感じです。 それから、最初の日付は2行目だったのですね。それも直してみました。お試しください。 Sub sample2() Dim LastRow As Long Dim Dist As Range LastRow = Sheets("Sheet2").Cells(Rows.Count, "A").End(xlUp).Row If LastRow = 1 Then Set Dist = Sheets("Sheet2").Cells(2, "A") Else Set Dist = Sheets("Sheet2").Cells(LastRow, "A").Offset(2) End If Dist = Format(Now, "[$-411]ggge年m月d日") Set Dist = Dist.Offset(1) With Sheets("Sheet1") .Range(.Cells(3, "C"), .Cells(Rows.Count, "I").End(xlUp)).Copy Dist.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _ :=False, Transpose:=False End With With Sheets("Sheet2") With .Range(Dist, .Cells(Rows.Count, "G").End(xlUp)) .Borders(xlEdgeLeft).LineStyle = xlContinuous .Borders(xlEdgeTop).LineStyle = xlContinuous .Borders(xlEdgeBottom).LineStyle = xlContinuous .Borders(xlEdgeRight).LineStyle = xlContinuous End With End With End Sub
方法1 : Excel ブック「ファイル」「オプション」「詳細設定」「Dynamic Data Exchangeを使用する他のアプリケーションを無視する」のチェックを外す。 方法2 : Office 修復を試す。 （Windows 7の場合）「開始」「コントロール パネル」「プログラムのアンインストール」「プログラムのアンインストールまたは変更」Office 365クリック「変更」「クイック修復」再起動 方法3：Office 365をアンインストール、再起動、再インストール http://answers.microsoft.com/ja-jp/office/forum/ …
添付図参照 B10セルに =INDEX($A$3:$A$6,MATCH(B$9,INDEX($B$3:$D$6,,MATCH($A10,$B$2:$D$2,0)),0)) 日付が縦横の違いだけならもっと簡単な数式になりそう
一回、エクセルで例を書いて画像を載せて再質問したほうがいいですよ。
C3: =IF(MAX(E3:P3),MAX(E3:P3),"") D3: =IF(C3="","",INDEX(E$2:P$2,MATCH(C3,E3:P3,0))) 【余計な心配】 セル J5、P5 が同じ数値であるように、「最高数値」が複数あったら困っちゃわないのかしらン？
こんな感じでどうでしょう。 転記先のクリアやエラー処理は組み込んでいませんので、お好みで･･･。 Sub sumple() Dim r As Range Dim I As Long For Each r In Selection If r.Value = "" Then I = I + 1 Sheets("Sheet2").Cells(I, "A") = r.Address(False, False) End If Next End Sub
3種類程度ならOR関数と配列定数で =IF(OR(B11&"-"&D11={"品名1-白","品名2-白","品名3-白"}),-80,"提示の数式")
該当のシートのSheetオブジェクトのWorksheet_BeforeDoubleClickイベントプロシジャに下記のマクロを張り付けて下さい。 編集したいセル（＝A1が設定されているセル）をダブルクリックすると式を値に変換してくれるので、編集ができるようになります Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Target.Value = Target.Value End Sub
す、すみません m(_ _)m =IF(COUNTIF($B$1:$C$3,$E1)<COLUMN(A1),"",INDEX($A$1:$A$3,SMALL(IF($E1=$B$1:$C$3,ROW($A$1:$A$3)),COLUMN(A1)))) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる です。ROWとCOLUMNを間違ってました
スクリプトエラーは、以前は、IEのオプションで修正できたのですが、今は、それをやっても無理のようです。もうここの書き込みは、顧みられることもないかもしれませんが、#2で書いたものが中途半端ですから、完成形を作っておきます。 http://nikkei225jp.com/fx/ (VBAコード内で文字化けする可能性がありますので、再度、登録しなおしてください　strURL = http://nikkei225jp.com/fx/　　"URL"をコーテーションマークで囲んでください。） 取得先は、『日経の為替チャート』(他も試みましたが、失敗しました。） このマクロは、サーバーに負担を掛けるようなものではありませんが、ループして使うのは問題が残ると思います。なるべく、PC自体にも負担を掛けないためには、参照設定をしたほうがよいと思います。(その意味が分かる方のみに限ります） なお、サイトが更新されれば、取得できなくなる可能性がありますから、このコードは、2016/5/25のタイム・スタンプということにしておきます。 '// Sub OnTimeGetExRates() 　　Dim objIE As Object ''As InternetExplorer　'Microsoft Internet Control:参照設定 　　Dim ChgRates As Variant 　　Dim Countries As Variant 　　Dim strURL As String 　　Dim i As Long, j As Long, k As Long 　　Dim buf As Variant 　　Dim arBuf(5) As Variant 　　Dim Kinds As Variant 　　Dim StCell As Range 　　'20160525　 　　'最初の書き出しセルの場所 　　Set StCell = Range("A2") 　　 　　Set objIE = CreateObject("InternetExplorer.Application") 　　'Set objIE = New InternetExplorer '事前バインディングの場合 　　On Error GoTo ErrHandler 　　''************** 　　''取得先　at May 25,2016/ no guarantee after the future. 　　strURL = "http://nikkei225jp.com/fx/" 　　''************* 　　Countries = Array("ドル円", "ユーロ円", "ポンド円", "スイスフラン円", _ 　　　　　　　　　　　　　　　　 "豪ドル円", "ニュージーランド円", "ユーロドル", "ドルインデックス") 　　ChgRates = Array("511", "514", "515", "513", "516", "517", "523", "501") '"V518" 不明 　　Kinds = Array("V", "H", "L", "C", "Z", "T") 　　 　　objIE.Navigate2 strURL 　　j = 1 　　Do While objIE.Busy Or objIE.readyState <> 4: DoEvents: Loop 　　With objIE.document 　　　　　　　　For i = 1 To UBound(ChgRates) + 1 　　　　　　　　 On Error Resume Next 　　　　　　　　 buf = "" 　　　　　　　　 buf = .getElementByID("V" & ChgRates(i - 1)).InnerText 　　　　　　　　 For k = 0 To 5 　　　　　　　　　　arBuf(k) = .getElementByID(Kinds(k) & ChgRates(i - 1)).InnerText 　　　　　　　　 Next k 　　　　　　　　 If StCell.Cells(i, 1).Value = "" Then 　　　　　　　　　　　　 StCell.Cells(i, 1).Value = Countries(i - 1) 　　　　　　　　 End If 　　　　　　　　 For k = 0 To 5 　　　　　　　　　　 StCell.Cells(i, k + 2).Value = arBuf(k) 　　　　　　　　 Next k 　　　　　　　　 On Error Resume Next 　　　　　　　　Next i 　　　　End With ErrHandler: If Err.Number <> 0 Then 　　　　 MsgBox Err.Number & " :" & Err.Description End If objIE.Quit Set objIE = Nothing Beep End Sub '//
準備 新規シートの作成 オートフィルタで抽出 [Ctrl]+[Shift]+[*]表の範囲選択 [Ctrl]+[C]コピー 新規シートで[Ctrl]+[V]貼り付け ショートカットキーを使って、行ってください
IF(訪問データ!$A:$I="同行援護（身体）" 訪問データのA～Iの範囲が　「同行援護（身体）」に等しい、となっているからです。 他のIFは全部D18というように一つのセルで、ここだけ何故範囲ですか。
↓ 実際にパスワードをかけてそれを記録した方が条件にあうと思います。ただしパスワードは記録されないと思いますので、パスワードを使っている場合は「Password:="PW"」を追記してください。
こんにちは！ Sheet2のB2セルに =IFERROR(INDEX(Sheet1!B:B,MATCH($A2,Sheet1!$A:$A,0)),"") または =IFERROR(VLOOKUP($A2,Sheet1!$A:$D,COLUMN(),0),"") という数式を入れ フィルハンドルで右へ、下へコピーしてみてください。m(_ _)m
こんばんは！ 元データはSheet1にあり、Sheet2に表示させるとします。 データは1行目からあるという前提で・・・ 標準モジュールにしてください。 Sub Sample1() Dim i As Long, j As Long, cnt As Long Dim lastRow As Long, wS As Worksheet Set wS = Worksheets("Sheet1") Application.ScreenUpdating = False With Worksheets("Sheet2") .Cells.Clear wS.Range("A1").CurrentRegion.Copy .Range("A1") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row .Range("A:A").Insert With Range(.Cells(1, "A"), .Cells(lastRow, "A")) .Formula = "=row()" .Value = .Value For cnt = 1 To 5 .Copy .Cells(Rows.Count, "A").End(xlUp).Offset(1) Next cnt End With .Range("A1").CurrentRegion.Sort key1:=.Range("A1"), order1:=xlAscending, Header:=xlNo .Range("A:A").Delete For i = 1 To .Cells(Rows.Count, "A").End(xlUp).Row Step 6 cnt = i For j = 17 To .Cells(i, Columns.Count).End(xlToLeft).Column Step 15 cnt = cnt + 1 .Cells(cnt, "A") = .Cells(i, "A") .Cells(i, j).Resize(, 15).Cut .Cells(cnt, "B") Next j Next i .Activate End With Application.ScreenUpdating = True MsgBox "完了" End Sub こんな感じではどうでしょうか？m(_ _)m
> これをまとめた数式はございますか？ いっている意味がいまいち分からないのですが、 ＃3さんの回答、 　　=mod(d4-1,c4)+1 で良いのではありませんか。 例題のすべてのパターンと答えが一致していますが。
これではいけませんか？ =if(d4>c4,d4-c4,d4)
＞商品名が空白セルだった場合、　#N/A　を回避させるには ISNA関数で調べてみるとよいかと思います。
こんな感じでしょうか。 =IF(ISNA(VLOOKUP(A1,ブック2!A:B,1,FALSE)),"",VLOOKUP(A1,ブック2!A:B,2,FALSE))
#5の回答者です。 こういう場合、だいたい、回答者の一人が、業を煮やして、キメウチで作ってしまうケースが多いようです。しかし、今回も、こちらはコード見送りました。 言葉よりも、画像のほうが情報が速く正しく伝わりますから、一度、そういう説明の仕方も考えたほうがよいでしょうね。今回も画像を付けます。（ツールは、FastStones Capture for Windowを使用） 原則があって、各々の条件を導きだす方法のほうが楽ですね。 >Ð列の数値よりも空白かどうかを最優先する 　－－空白でなかったらコピーをしない >D１の数値が４だとしてもその下の段に1段しか空いていなければ1段のみのコピー 　－－つまり画像の②のような場合は、コピーしない。 　ということになります。 ◯画像では、行の終わりを取り入れて6行までとしました。 そうすると、余りがあっても、それもコピーしないとなります。
こんな事でしょうか？ Sub Sample1() Dim シート番号 As Long Dim 次行 As Long Sheets(1).Select Cells.Select Application.CutCopyMode = False Selection.Copy Sheets("一覧シート").Select Range("A1").Select ActiveSheet.Paste 次行 = Cells(Rows.Count, 1).End(xlUp).Row + 1 For シート番号 = 2 To Worksheets.Count If Sheets(シート番号).Name <> "一覧シート" Then If Sheets(シート番号).Cells(Rows.Count, 1).End(xlUp).Row >= 2 Then Sheets(シート番号).Select Range(Cells(2, 1), Cells(Cells(Rows.Count, 1).End(xlUp).Row, Columns.Count)).Select Application.CutCopyMode = False Selection.Copy Sheets("一覧シート").Select Cells(次行, 1).Select ActiveSheet.Paste 次行 = Cells(Rows.Count, 1).End(xlUp).Row + 1 End If End If Next End Sub なお、すべてのシートが同じレイアウトであり、一覧シートが１つ目でない事が条件になります。
No.4です。 (1)に関してはレイアウトにあまり関係なく、No.4と同様の回答。 F3セル： =SUM(INDEX(F:F,ROW()-1),IF($E3="①",-SUM($B3:$D3))) G3セル：=SUM(INDEX(G:G,ROW()-1),IF($E3="②",-SUM($B3:$D3))) H3セル：=SUM(INDEX(H:H,ROW()-1),IF($E3="③",-SUM($B3:$D3))) (2)に関しては、たぶん、こんな感じでできるとは思うが、範疇外。 シートモジュールに Private Sub Worksheet_Change(ByVal Target As Range) 　With Intersect(Range("E:E"), Target) 　 If Intersect(Range("E:E"), Target) Is Nothing Then Exit Sub 　 　 .Value = Left(.Value, 1) 　End With End Sub (3)に関しては、入力規則のリストを使う限りできない。 1,2,3の整数を入力後、丸付き数字に変化させるのならVBAで可能。
どのようにうまく行かないのでしょうか？ ２枚の写真の状態でコードを実行すると 商品コード「1234」は「5」に更新されます。 商品コード「2345」は、該当が無いので前の値が保持されます。消した方が良ければ消すことも出来ます。
たとえば「A5～A7」についてですが 結合セルになっていると思います。 ① 結合解除する ②「A5」と「A7」セルの文字色を「白」にする。 ③「A5」と「A7」セルに「=A6」の計算式を入れる。
単純にIFを使って 　D2は　=IF(C2+3=8,8,MOD(C2+3,8)) 　E2は　=IF(C2-3=0,8,MOD(C2-3,8))
可能です。 VBAでコードを組む必要がありますが。 で、ソースコードを載せて、って言ってます？
こんにちは ご質問の内容はマクロを用いることで実現可能と思われます。 手動で各シートの保護をしたり解除したりする操作と同様のものをまとめてマクロ化しておくことによって、以降は、そのマクロを実行させることで同様の処理を（自動的に、何度でも）再現できるという仕組みです。 （エクセルには手動の操作をそのままマクロに記録してくれる仕組みもありますので、試してみると雰囲気はわかると思います。ただし、自動記録では汎用的な処理の記述にはならないので、そのまま再利用はできないと思いますけれど。） 質問者様がすでにマクロをご存知でいらっしゃるなら、シートの保護はProtectメソッドを用いることで実現ができますので、これを対象とする各シートで実行するというものを作成すればよろしいかと思います。 https://msdn.microsoft.com/ja-jp/library/office/ …
こんばんは！ 1行目からデータがあるとすると EW1セルに =MIN(IF(EQ1:EV1>=2,COLUMN(EQ1:EV1)-146)) 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　EW1セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ Ew1セルのフィルハンドルで下へコピーしてみてください。 ※　エラー処理はしていません。m(_ _)m
こんにちは！ 一旦Dir関数の中身をクリアする必要があると思うのですが・・・ ＞Loop の前に ＞buf = Dir() を追加したらどうなりますか？ ※　細かい検証はしていませんので お望み通りにならなかったらごめんなさい。m(_ _)m
折りたたみを使ってみては？ http://www4.synapse.ne.jp/yone/excel2013/excel20 …
関数ではなくピボットテーブルで良いと思います。 ピボットテーブルはそのまま使うとデータ範囲が変わりませんので(バージョンで改善された気がするけど) [Ctrl]+[F3]名前の定義 名前 : PT範囲 参照範囲 : =$A$1:INDEX($C:$C,counta($A:$A)) ピボットテーブルウィザードの範囲で =PT範囲 とする ページフィールドに日付 行フィールドに 会社名 データフィールドに 売上(合計) また、ピボットテーブルで「並べ替えてトップテン表示」を使い 売り上げを基準に 降順 表示は 上位 3 添付図参照参考まで
まず、B列にチェックを入れる方法です。 次のVBAを該当シートのWorksheet_BeforeDoubleClickイベントプロシジャに張り付けます。 このVBAは、B列（B1~B15)がダブルクリックされた場合、そのセルが空白なら○。空白でなければ空白を設定するものです。○については、お好きな文字にしてください。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Application.Intersect(Target, Range("B1:B15")) Is Nothing Then Exit Sub If Target.Value = "" Then Target.Value = "○" Else Target.Value = "" End If Cancel = True End Sub 次にE列ですが、E1セルに次の数式を設定し、E15まで下にオートフィルします。 =IF(B1="","",D1)
＝IFERROR(VLOOKUP(’Sheet1'B1,Sheet2!$A:$B,2,0), ""） エラーなら空欄にする、という式にもできます。
条件付き合計ってことかな 3行目の品名が7列ごとに同じなら (「A」を品名として) =SUMIF(AE$3:EJ$3,"A",AE4:EJ4) しかし、 >７列ごとの固まりが毎週ごとに右の列に送られる状態 なので仮に7列挿入すると =SUMIF(AL$3:EQ$3,"A",AL4:EQ4) と変化してしまいます。 よって、変化しないセルを基準とした数式に変更することになります。 たしかにINDIRECTなら文字列ですので変化しません。 また、OFFSET関数なら変化しないセルを基準にすれば、範囲も指定できるので便利かもしれません しかし、最大の弱点が計算対象外のセルを変更したときでも計算してしまい、編集がままならなくなるほど遅くなることがあります。 なので、(名前の定義でOFFSET関数を使ってもOKですが) INDEX関数を使ってみます。 仮にX4セル(4行目のどの列でも良い)に入力するとして =SUMIF(INDEX($3:$3,31):INDEX($3:$3,140),"A",INDEX(4:4,31):INDEX(4:4,140)) =SUMIF(範囲,検索条件,合計範囲) 範囲：【行3,列31】のセル(つまりAE3)から【行3,列140】のセル(つまりEJ3)までの範囲、行は絶対参照、列は固定 検索条件："A” 合計範囲：【行4,列31】のセルから【行4,列140】のセルまでの範囲、行は相対参照、列は固定 とすることができます 仮に品名が7列ごとに入っていない場合再度考えますが、複雑になることは覚悟してください。 提示の数式を成り立つように変えるのは簡単ですが、 数式を理解せずに使うのもどうかと思いますので上記の説明をさせていただきました。 また、No.1のGooUserラックさんの質問にもお答えください。
＞画面が左（十字キーの方向）に動くだけで は[ScrollLock]押した後、矢印キーでなります 解除も[ScrollLock]キーです ＞Ctrl + Aで表全体を選択した状態 アクティブセルが一番左列にないとか？ [Ctrl]+[Shift]+[*]で表全体を選択してみましょう
面倒ですが、 コピー元のコピーしたい範囲を選択して、Ctrl+C。 ↓ メモ帳等のテキストエディタを開いて、Ctrl+P。 ↓ テキストエディタ上で、Ctrl+A → Ctrl+C。 ↓ コピー先のコピーしたい範囲を選択して、Ctrl+P。 でできます。
Unprotect メソッドで、シートの保護を解除すれば可能です。張り付け後に、Protectメソッドで保護します。
流れとしてはこんな感じですればいいかと。 1.Aシートの入力行数を取得する。（方法はいくつかありますがCTRL+Down相当が軽くて便利かと） 2.Aシートの入力行数分コピーしBシートへペースト。 3.必要なから行を追加 4.date関数で日付を取得し書き出し。
以下のような感じでどうでしょうか？ ■全く新規のブックを作成する場合 Dim Workbook As Workbook Set Workbook = Workbooks.Add() ～～転記処理を記載～～ Workbook.SaveAs (保存先) Set Workbook = Nothing ■テンプレートとなるシートを使って作成する場合 Dim Workbook As Workbook Sheets(テンプレートとなるシート名).Copy Set Workbook = ActiveBook ～～転記処理を記載～～ Workbook.SaveAs (保存先) Set Workbook = Nothing
たぶん vancomycin さんが実現したい事はチェックボックスを使う事になると思います。 ちなみに初期値でオプションボタンの値をTrueにしてあった場合は1回目に押してもFalseにはなりません。
X1=(A1<=624)*-54+A1*(A1>=625)*0.9136 この式は、論理式(大小判断)の一方が1の時他方がゼロになります。 IF文による不可解式を避けています。 但し、A1がこの間にある場合(624.5など)は、結果はゼロになります。 条件判断は、前者を624以下とするならば、後者は624超とすべきでしょう。
No.3です。 投稿後気づきました。 コード内の ＞Set myRng = Range(Cells(i, "D"), Cells(i, "AD")) の行を ＞Set myRng = Range(Cells(i, "D"), Cells(i, lastCol)) に変更してください。 前回のコードではAD列までの範囲になってしまいます。 どうも失礼しました。m(_ _)m
そもそもこのマクロ動かないと思うのですが。 誤：Workbook.Open Filename:=”C:¥共有¥マクロ.xlsm” 正：Workbooks.Open Filename:=”C:¥共有¥マクロ.xlsm” 誤：With Workbooks(”マクロ”) 正：With Workbooks(”マクロ.xlsm”) 【問題1】 Range("D7:G27").Value = "" で値をクリアしてしまっているからです。 【問題2】 可能です。様式シートに張り付けたのと同様の処理をほかのシートに対しても行えばよいです。
文字通りスライドしていきます。 Res!前々回日付 =　Res!前回日付 Res!前回日付 =　Res!当日日付 Res!当日日付 =　strToday 順序に注意。
科目の表が、セル結合されているので先頭の行位置がよくわからないのですが、例えば、3行目から設定されているものとすると　K3~L??に次の条件付き書式設定をします。 【K3~L??セルの条件付き書式設定】 =COUNTIFS($C:$C,$K3,$D:$D,$L3,$A:$A,"<="&TODAY()) 式の意味ですが、COUNTIFS関数で、次のすべての条件を満たす件数をカウントします（ゼロならFalse,ゼロ以外ならTrueです)。 ・課が等しい ・座学、実践が等しい ・カレンダー日付が当日以前である ちなみに、右側の科目表（N3:O??)の場合は、 =COUNTIFS($C:$C,$N3,$D:$D,$O3,$A:$A,"<="&TODAY())
すみません。私のミスでした。 >実行の結果としては、ORIGINからDESTINEへ同一のファイルが同一の名前で保存されるという結果でした。 自分のコードの以下の間違いがあります。 　　　　　　 With .ActiveSheet 　　　　　　newFn = .Range("C5").Value & " " _ 　　　　　　 & .Range("F5").Value & " " _ 　　　　　　 & .Range("C6").Value & " " _ 　　　　　　 & .Range("F6").Value 　　　　　　 End With 　　　　　　.SaveAs DESTINE & fn, xlOpenXMLWorkbookMacroEnabled　←ここがへん。新しいファイル名になっていません。newFn が正解でした。 　　　　　　.Close False 正しくは、新しいファイル名になっていなくてはならないので、newFn ですね。 　　.SaveAs DESTINE & newFn, xlOpenXMLWorkbookMacroEnabled　'←● 　　でしょうね。 p.s.PCがなくても、頭にPC画面が浮かべば、十分にコードを読みながらマクロの練習は出来ます。私は、道を歩いている時や電車の中で、コードが頭に浮かびました。今は、ちょっとそういう事情ではなくなりましたが。
重複がないなら 項目行を追加して DGET関数を使えばいいと思います。
最初の質問に忠実に実装してみました（これが本当に使えるのかどうかは疑問ですが･･･）。 該当シートのWorksheet_Changeイベントプロシジャに下記のマクロを張り付けて下さい。 A1セルに値を入力するとA3～A5に数式を設定します。 数式の内容は、A1の値を入力した日の60日後（A3の場合）以降に10%相当額を表示するというものです。 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address <> "$A$1" Then Exit Sub MsgBox "=IF(NOW()>=" & Now + 60 & ",A1*0.1,"""")" Range("A3").Formula = "=IF(NOW()>=datevalue(""" & Now + 60 & """),A1*0.1,"""")" Range("A4").Formula = "=IF(NOW()>=datevalue(""" & Now + 90 & """),A1*0.1,"""")" Range("A5").Formula = "=IF(NOW()>=datevalue(""" & Now + 120 & """),A1*0.1,"""")" End Sub
こんにちは。 >Prlen = Application.ExecuteExcel4Macro("INDEX(GET.DOCUMENT(46),1,6)") >の部分ですが、より下方の行数が得られるようで、ググってみましたがはっきり>した >内容がわかりませんでした。もう少し調べてみます。 私も分かりません（^^; 出てきた数字は、「66」と出ているはずです。この数字は、たぶん、物理的行数のような気がしています。 そのコマンド(GET.DOCUMENT)のヘルプを見ると、次のように出てきます。 マニュアルは、Microsoft のVer.4 マクロ関数です。 Microsoft が関数を増やしたので、新しいマニュアルを出してくれるとよいのですが、昔のままです。（それに、日本語版はどこに行ったのでしょうか？） https://support.microsoft.com/ja-jp/kb/128185 Microsoft Excel 4.0 マクロ関数のヘルプ トピックを表示するには、最初に、完全なマクロ関数のヘルプ ファイル (Macrofun.hlp) をインストールする必要があります。 （ダウンロードファイルの中身）　英語版です。 　Macrofun.cnt 182　　　　 CNTファイル　　　　　　1995/08/18 　Macrofun.hlp 936,351　　　ヘルプファイル　　　　1997/12/02 　Readme.txt　　 794　　　 テキストドキュメント　　1997/12/02 以下は日本語版ヘルプから。 (私は、Excelの古い日本語ヘルプが、HDに入れてあります） ---------- 書式 GET.DOCUMENT(検査の種類, ファイル名) 46　LINE.PRINT 関数で設定された次の 7 つの印刷設定の内容を、水平方向の配列として返します。 　-　制御文字列 　-　左余白 　-　右余白 　-　上余白 　-　下余白 　-　ページの長さ 　-　印刷の設定どおりに出力するときは TRUE 、そうでなければ FALSE --------- 作業中のワークシートに対する印刷設定 LINE.PRINT(コマンド, 制御文字列, 左余白, 右余白, 上余白, 下余白, 頁行数, 指定通り) --------- マクロ関数というのは、IDEのインターフェースを通してではなく、直接アプリ等から、設定値を取得する所がミソなのです。ですから、おそらくは、同じ数字を取得するのでも、マクロ関数のほうが、かなり速いはずです。 なお、この翻訳を作ったのは、Microsoft なのか、Ascii なのか、なんとなく文体が違うような気がしています。なお、Excelレガシー問題も、そろそろ幕引きのような気がします。私のVBAマクロの劣化も激しいようです。
こんにちは！ 一例です。 元データはSheet1にあり、Sheet2に表示させるとします。 Sheet2のA1セルに商品名を入力するとデータが表示されるようにしてみました。 ↓の画像のようにSheet2に作業用の列を3列設けます。 Sheet2のD4セルに =IFERROR(INDEX(Sheet1!$A$1:$C$1000,SMALL(IF(Sheet1!$B$1:$B$1000=$A$1,ROW($A$1:$A$1000)),ROW(A1)),MATCH(D$3,Sheet1!$A$1:$C$1,0)),"") 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　D4セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ D4セルのフィルハンドルで隣のE4セルまでコピー！ F4セル（配列数式ではありません）には =IF(OR(D4="",COUNTIF(D$4:D4,D4)>1),"",ROW()) という数式を入れます。 D4～F4セルを範囲指定　→　F4セルのフィルハンドルでずぃ～～～！っと下へコピーしておきます。 最後にA4セルに =IFERROR(INDEX(D:D,SMALL(F:F,ROW(A1))),"") B4セルに =IF(A4="","",SUMIF(D:D,A4,E:E)) という数式を入れ、A4・B4セルを範囲指定　→　B4セルのフィルハンドルで下へコピー！ これで画像のような感じになります。 ※　作業列が目障りであれば、遠く離れた列にするか 非表示にしてください。 ※　作業用の列の項目名はSheet1と同じ項目名を入れておいてください。m(_ _)m
「excel うるう年　カウント」で検索したら、参考になる回答があったので、 別の質問サイトですが載せておきます。 http://detail.chiebukuro.yahoo.co.jp/qa/question … ちょっと試してみたら、多分計算は正しくされているようです。 一応、再掲しておきます。 =MOD((B1-A1+DATE(2001,MONTH(A1),DAY(A1))-DATE(2001,MONTH(B1),DAY(B1))),365)
No.2です。 ＞元データがK列まで対応できるように出来ますか K列に限定せず、その行のデータがある最終列までとしてみました。 前回のコードは消去し、↓のコードにしてみてください。 Sub Sample2() Dim i As Long, k As Long, lastCol As Long, wS As Worksheet Set wS = Worksheets("Sheet2") Application.ScreenUpdating = False wS.Cells.Clear With Worksheets("Sheet1") .Rows(1).Insert .Range("A1") = "ダミー" .Range("A:A").AdvancedFilter Action:=xlFilterCopy, copytorange:=wS.Range("A1"), unique:=True For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row For k = 2 To .Cells(Rows.Count, "A").End(xlUp).Row If .Cells(k, "A") = wS.Cells(i, "A") Then lastCol = .Cells(k, Columns.Count).End(xlToLeft).Column Range(.Cells(k, "B"), .Cells(k, lastCol)).Copy wS.Cells(i, Columns.Count).End(xlToLeft).Offset(, 1) End If Next k Next i wS.Columns.AutoFit wS.Rows(1).Delete .Rows(1).Delete wS.Activate End With Application.ScreenUpdating = True End Sub ※　K列までと決まっているのであれば、 最初にある変数の宣言の lastCol As Long を消し（カンマも一つ消します） ＞lastCol = .Cells(k, Columns.Count).End(xlToLeft).Column ＞Range(.Cells(k, "B"), .Cells(k, lastCol)).Copy wS.Cells(i, Columns.Count).End(xlToLeft).Offset(, 1) の2行を ＞Range(.Cells(k, "B"), .Cells(k, "K")).Copy wS.Cells(i, Columns.Count).End(xlToLeft).Offset(, 1) としてみてください。m(_ _)m
こんにちは いろいろ不明なところがありますが勝手に仮定して、マクロとして作成してみました。 使い方がよくわかってませんが、とりあえず実行する毎に全てを作成し直すというものにしてあります。 ※ 以下を仮定しています。 ◇sheet1 ・1行目はタイトル行として利用、2行目以降にデータがあると仮定 ・日付欄はDate形式の値が入っているものと仮定 　（異なるデータ形式の場合はその行は無視します） ・1つの行のＡ～Ｅ列は必ず全て入力があるものと仮定 　（空白欄がある場合はその行のデータは無視します） ◇sheet2 ・1行目はタイトル行として利用、 　2行目以降から1行ごとに1日、2日・・・に対応すると仮定 　（n行目はn-1日と自動的に判断し、実際の内容はチェックしていません） ・マクロ実行時にＣ列（1行目も含む）以降は一旦全て消去されます ・病院名は文字列の完全一致で判断しています 　（違う場合は、異なるものとして判断） ・同日、同病院のデータが複数ある場合は一つのセル内に改行して記入されます ※ sheet1の日付データは日を利用していますが、年、月等は一切チェックしていません。 以下、ご参考まで。 Sub Sample() Dim source As Worksheet, dest As Worksheet Dim rgs As Range, rgd As Range, rg As Range Dim dict As Object Dim rwMax As Long, rw As Long, i As Integer Dim hname As String, str As String, f As Boolean Set source = Worksheets("sheet1") Set dest = Worksheets("sheet2") Set dict = CreateObject("Scripting.Dictionary") Set rgd = dest.Cells.SpecialCells(xlCellTypeLastCell) Range(dest.Cells(1, 3), rgd).ClearContents rwMax = source.Cells(Rows.Count, 1).End(xlUp).Row For rw = 2 To rwMax 　Set rgs = source.Cells(rw, 1) 　f = VarType(rgs.Value) = vbDate 　For i = 0 To 4 　　If rgs.Offset(, i) = Empty Then f = False 　Next i 　 　If f Then 　　hname = rgs.Offset(, 2).Text 　　If dict.Item(hname) = "" Then 　　　dict.Item(hname) = dict.Count 　　　Set rgd = dest.Cells(1, dict.Item(hname) * 3) 　　　rgd.Resize(, 3).Value = Array(hname, "時間", "内容") 　　End If 　　 　　Set rgd = dest.Cells(Day(rgs) + 1, dict.Item(hname) * 3) 　　For i = 0 To 2 　　　Set rg = rgd.Offset(, i) 　　　str = rgs.Offset(, Array(1, 3, 4)(i)).Text 　　　If rg <> Empty Then str = Chr(10) & str 　　　rg = rg.Text & str 　　Next i 　End If Next rw End Sub
Sheet2のA1セルに次の数式を入力して、下にオートフィルで、どうでしょう。 =IF(ISERROR(MATCH(LEFT(G1,3)&"*",Sheet1!F:F,0)),"","●")
ChromeはというよりIE以外はやめた方がいいです。 IEはブラウザで唯一Active XコンポーネントですのでVBAから直接HTMLやDOMを操作できるAPIがあります。 "VBA IE 操作"で検索してみてください。 3の部分が複雑になる件ですがDOMを検索してInnnerHTMLとかで取得してこればシンプルにできるかと。 ただ、２万件となるとVBAで処理すると数分かかるように思います。 パフォーマンスが気になるようならEdgeやIEを.NETで開発したOffice Plug-inから操作するとよいかともいます。 ChromeやFirefoxはそもそもそういった直接操作ができるAPIがないので自動操作用の拡張機能を用意してファイルベースで操作内容を受け渡すような事が必要になるのであまりお勧めできません。
遅くなりました。 こっちの方が分かりやすいですね。 http://www.eurus.dti.ne.jp/~yoneyama/Excel/vba/v … 要は、指定した列を上から順にIfを使って検索すればいいんです。 「検索について」 http://www.relief.jp/itnote/archives/excel-vba-i … 「Cells関数」 Cells(行，列)を使う。列を固定して、行を１増加させながら検索。検索にヒットしたら、その行番号から横一列のデータが取得できるわけです。そして、抽出データを反映させる時に行番号も保持しておくと。 更新するときは、その行番号を利用して上書きする。 こんな感じ。 いきなりすべて作りこまず、部分的に作っていきましょう。
作業のために、Sheet2 を使用します。添付図参照 此処では簡単のために、Sheet1(貴方の添付図)の 「請求金額(税抜)」は[金額」としておきます。私の添付図の Sheet2!D2 もネ。 Sheet2!B1: =MATCH(B$2,Sheet1!$D$2:$H$2,0) 此れを右２列にオートフィル Sheet2!A3: =SMALL(IF(Sheet1!$B$3:$B$9=Sheet1!$J$1,ROW(Sheet1!B$3:B$9),""),ROW(Sheet1!A1)) この式は配列数式として入力後、下方にオートフィル Sheet2!B3: =INDEX(Sheet1!$D$1:$H$9,$A3,B$1) 此れを右２列および下方にオートフィル Sheet2!E3: =B3+A3/10000 此れを下方にオートフィル Sheet2!F3: =SMALL(E$3:E$6,ROW(A1)) 此れを下方にオートフィル Sheet2!G3: =MATCH(F3,E$3:E$9,0) 此れを下方にオートフィル Sheet1!J3: =IFERROR(INDEX(Sheet2!$B$3:$D$9,Sheet2!$G3,COLUMN(A1)),"") 此れを右２列および下方にオートフィル
こんにちは。 ちょっと条件が多いかも知れませんが・・・ 「スペース」というのがいわゆるスペースではなく、""に相当する未入力状態のことで、Ａ列の対象が文字列に限定できるのであれば、 Ｂ1に、 　=INDEX(A:A,MATCH("*",A:A,0)) で求められるかと。
「Excelには土日祝を除く関数はありますが」というのは、NETWORKDAYS関数のことを指していますか？であれば、期間内の土日祝の日数が求まれば良いのですよね？ 期間内の全ての日数から土日祝以外の日数を引けば、求まりますよ。
こんにちは。 図が小さくて判別できないのと、コードではご説明にない範囲の値を参照したりしているので、これまたさっぱりなのですが・・・ ＞５・４・３・２・１と増えて行くのを１・２・３・４・５・・・・というように、 ＞若い番号から順序よくなるようにしたいと思っています マクロを実行すると7列単位で左側に追加されるのを右側に追加するようになさりたいという事かと想像します。 やっている内容を良く把握できていないで、回答するのもなんなのですが・・・ ご提示のコードの最初のところで、 ＞　Range("AE1:AK45").Value = Range("Q1:W45").Value ＞　Range("AE1:AK45").Insert Shift:=xlToRight としている2行が、それぞれ 　「Q1:W45」の範囲の値を「AE1:AK45」にコピー 　「AE1:AK45」を右に移動して7列分挿入 ということを行っています。 この結果、ご質問のようなことになっていると思いますので、 使用している最終列の次の7列に「Q1:W45」の範囲の値をコピーするようにしてあげれば、そのまま右側に追加されてゆくことになると思われます。 使用している最終セルは 　Cells.SpecialCells(xlCellTypeLastCell) でも取得可能かと思いますが、操作で一度使ったセルはカウントされてしまう可能性がありますので、値が必ず入っている行があるならば 　Cells(対象行、Columns.Count）.End(xlToLeft).Column という方法で取得する方がよろしいでしょう。求めた列+1の列から記入を始めれば良いはずです。 但し、その後で行っている38列～44列を対象とした操作は、新しく追加した値に対して行っているものと思いますので、対象列が上で求めた列からにかわってくるものと思われますので、調整が必要になると想像します。 （なんとなく繰り返しが多いので、もっと単純化できそうに見えますが・・・） ＞ＡＥ～ＡＫ列が累積を送るとすると、どうしても空いてしまっています。 ＞これをどうにかできればと思っています 仮に、今のままの方法で処理を行うにしても、現状は 　（空列に）「値をコピー」→「7列挿入して右にシフト」 としていますので、常に7列の空きができているものと思われます。 　「7列挿入して右にシフト」→「挿入したところへ値をコピー」 のように必要な時に列を挿入するように順序を変えるだけでも、実現が可能と思います。 最初に述べました右側に追加して行く方式の場合は、「列の挿入」自体を行わなくても良いので、初めから（中間に）空き列を設けておく必要はないものと思います。 ※ コード自体は理解できますが、処理の意味（意図）を理解できずに回答していますので、勘違いがあるかもしれません。その際はご容赦願います。
再度挑戦します。 >別のエクセルファイルの3列目をコピー ↓ >現在開いているエクセルファイルのA4をクリックして貼り付け >この作業をマクロで行うには、どのようにしたら良いでしょうか。 あくまでも、VBAマクロの話ですが、このマクロとしての出発点を、コピー前、つまり全部をひとまとめのマクロにした場合と、コピーした後からのマクロとでは、その難しさは、極度に変わりますね。 コピーした後、何が入っているかを検査し、そのクリップボードの中を一度、Rangeオブジェクトに戻してやる必要があります。それらは、VBAの範疇ではなかった気がします。Excelに付随しているクリップボードを応用できれば越したことがありませんが、私の技術力では、そう大したことができません。 とりあえず、ショートカットを、F11に入れて、範囲を文字列記憶して使う方法を考えてみました。 -------- まず、コードは、全部、標準モジュールに入れてください。 次に、 Sub Auto_Open() 　Call SetKey End Sub で、キーを登録してください。 F11の本来の機能はグラフ化ですが、F11を使う人は少ないかと思われます。 うまくなければ、適当な場所に替えてください。 実際の使い方は、範囲を選択したら、F11で範囲を登録します。 成功していれば、[ "貼り付けは、Ctrl + v" ] が出てきます。 そして、別の場所に移動して、Ctrl + v (小文字）にすれば、貼り付けは完了します。これを行うと、ショートカットの設定の 貼り付けは外れて、このマクロは最初のF11からでないと同じようにはできません。 '// Public strRng As String '文字型のほうが安定が良い Sub SetKey() 　　''選択範囲をクリップボードに入れる　　【F11】 　　Application.OnKey "{F11}", "CopyBuffer" 　　 　　'これを取り消す方法は、 　　'Application.OnKey "{F11}", "" 　　'とします。 End Sub Sub CopyBuffer() 　　　　If TypeName(Selection) = "Range" Then 　　　　　　　　strRng = Selection.Address(0, 0, xlA1, True) 　　　　　　　　Application.OnKey "^v", "PasteMacro" 　　　　　　　　MsgBox "貼り付けは、Ctrl + v" 　　　　Else 　　　　　　　　Exit Sub 　　　　End If End Sub Sub PasteMacro() If strRng = "" Then 　　　　 MsgBox "範囲が保存されていません。", vbCritical 　　　　 Exit Sub Else 　　　　 Set Rng = Range(strRng) End If 　　　　With Rng 　　　　　　　　If Rng.Rows.Count = Rows.Count Then 　　　　　　　　　　　　If ActiveCell.Row > 1 Then 　　　　　　　　　　　　　　　　Set Rng = Rng.Resize(Rows.Count - ActiveCell.Row) 　　　　　　　　　　　　End If 　　　　　　　　ElseIf Rng.Columns.Count = Columns.Count Then 　　　　　　　　　　　　If ActiveCell.Column > 1 Then 　　　　　　　　　　　　　　　　Set Rng = Rng.Resize(Columns.Count - ActiveCell.Column) 　　　　　　　　　　　　End If 　　　　　　　　End If 　　　　　　　　Rng.Copy ActiveCell 　　　　End With 　　　　Application.OnKey "^v", ""　　'マクロのショートカット機能消失 End Sub '//
ご質問のような条件付きで直接置き換えるようなことは、一般機能でできません。 よって、いったん別のセルを使った方法になります F2セルに =IF(A2=1,A$1,IF(A2="","",A2)) 1以外の入力が無いようなら =IF(A2="","",A$1) 右へ下へオートフィル 添付図参照 F2:I4セル範囲をコピー A2セルに 値の貼り付け
セルの内容をテキストボックスに表示するだけなら簡単です。 テキストボックスを挿入して選択し、[数式バー]に「=A1」と記入すれば、 テキストボックス内にA1の内容が表示されます。 http://hamachan.info/win7/Excel/textbox.html そのままテキストボックスを装飾すれば、希望のものになります。 A1セルの位置に置きたいなら、そのA1セルの文字を白色にしておけば 非表示に見えますので、テキストボックスを上に置くだけで済みます。 A1セルの内容を書き換えるときは、[名前ボックス]に「A1」と記入すれば [数式バー]に内容が表示されますので書き換えできます。 複数のテキストボックスでA1にリンクさせておけば、希望していることが できると思いますよ。
ご指摘された条件で５月を作りましたらチャント動作します。 祝日のデータがチャントなっていないのでは？ 祝日データのどこかを選択した時に、数式バーに「yyyy/m/d」のように表示されますか？
Sub sample() Dim i As Long i = 1 Do Until i > Cells(Rows.Count, "A").End(xlUp).Row Range("A" & i + 20 & ":B" & i + 39).Copy Destination:=Range("C" & i) Range("A" & i + 40 & ":B" & i + 59).Copy Destination:=Range("E" & i) Rows(i + 20 & ":" & i + 59).Delete Shift:=xlUp i = i + 20 Loop End Sub
excelは、現在のセルの含まれているデータ領域を空白セルで囲まれた範囲だと自動的に認識するので（vbaの　CurrentRegion)、自動での領域の取得に失敗しているとまず疑った方が良いと思います。 この場合、手っ取り早く解決するのは、手動で範囲を選択してからフィルターを掛けても良いですが、エクセルが自動での範囲の取得に失敗した原因がそのあとの操作に影響を与える場合があります。 もうひとつの方法は、自動で選択される範囲を調べる方法で、それに相当するショートカットキーがあります。 Ctrl+Shif+* (この＊はテンキーでない方の場合で　テンキーの * だと　Ctrl + * シフトキーを押さなくても* が選択されので） これで現在のセルが含まれるデータ領域が選択されるのであとはデータ領域の隅っこを移動するショートカットで端っ子が分かるように Ctrl + . で移動すればどこまで選択されているかわかります。 この範囲のすぐ外側か、端っ子にデータ領域を間違える原因となる問題のセルがあるはずです。
vba を使えばいろいろ手が考えられますが（ちなみにvbaを使う場合はセルごとに処理するのでなく、一旦配列に入れて処理しないと速度が桁違いに（下手すると2桁位は）遅くなります。 エクセルの関数でも出来そうですので（エクセルの組み込み関数は早い）ちょっと提案しましょう。 まず、シート2の貸主名のデータに重複がないとします。普通は重複があるといけないと思いますのでこの考えで問題ないと思います。 この貸主名の入力されている行が分かれば、その行の郵便番号や住所を拾ってくるだけですが、Vlookup関数は、検索するデータが範囲の先頭列に無ければいけないので今回のシート2の順番では使えません。 この場合は、match　関数で行で調べてindex関数で範囲のその行の希望の列を拾ってくれば良いです。 実際はひとつの式にまとめても良いですが、考え方を示すために別々の式で示します sheet2のデータ範囲を仮にA2:E1000　とします。(1行目はタイトルですね） sheet1の方は1行目がタイトルで2行目からデータが始まっているとします。 仮にH列に貸主のデータが入っている行を調べるmatch関数を入れることにします H2のセルの式 =match(B2,sheet2!$E$2:$E$1000,0) 3番目の引数を0にしないと、sheet2の方は貸主名でソートしないといけなくなります これでH2に貸主名の行が出てくるので（範囲が2行目からなので行数としては実際の行数より１少ない値です）idex関数で必要な値を引っ張ってくるだけです。 郵便番号の C2セルには =index(sheet2!$A$2:$ES$1000,$H2,2) 検索の範囲は、絶対参照ですが、行の値のセルへの参照はコピーする都合で列のHだけ絶対参照にしておきます。 これを住所1、住所2にコピーすると、3番目の引数の列の値が郵便番号の２のままですから、３と４に直せばOKです。 範囲指定の方法はもっと範囲を絞っても構いませんが（3番目の引数も直す）内部では配列で処理しているので範囲が広くても実行速度はほとんど変わらないようです。 慣れないうちはmatch関数の列を別にに設けた方が分かり易いですが、これをIndex関数に組込めばmatch列は不要になります。 たとえば =Index(sheet2!$A$2:$ES$1000,Match(B2,sheet2!$E$2:$E$1000,0),2) 範囲の指定は名前と言う機能を使いと可読性は上がりますが、範囲を広げる時は名前の管理で行うなど、ちょっと別のセンスが必要となります。
1代のパソコンで３つファイルを開いた状態で作業しているとします。 ファイル１とファイル２の作業中のシートから以下を実行するような ボタンを配置します。 取りあえずですが、入力した最後の行のデータがファイル3の最終行以下に 入ります。 Sub ボタン1_Click() With Workbooks("ファイル3").Sheets("Sheet1") GYOU1 = Range("A" & Rows.Count).End(xlUp).Row GYOU2 = .Range("A" & Rows.Count).End(xlUp).Row + 1 .Range("A" & GYOU2 & ":F" & GYOU2).Value = Range("A" & GYOU1 & ":F" & GYOU1).Value End With End Sub もし、複数のパソコンでファイル１、ファイル2を開いて ファイル3に書き込むとなると話は難しくなります。
G～AA列の入力件数をCountA関数でカウントして、ゼロの場合のみ、コピーをするようにしてはいかがでしょう。 例えば、こんな感じです。 If r.Value <> "" Then If r.Row <> 8 And _ WorksheetFunction.CountA(Range("G" & r.Row & ":AA" & r.Row)) = 0 Then Range("G" & r.Row & ":AA" & r.Row).Value = Range("G" & r.Row - 1 & ":AA" & r.Row - 1).Valu End If Range("J" & r.Row).Value = Format(Now(), "hh:mm")
No.4,5です No.5の下の回答は[Ctrl]+[Shift]+[Enter]で確定する必要があります たぶん↓一番短い数式。汎用性がないので、作業列を使った方がよさそうです =SUMPRODUCT((G11:G33={"日","遅1","遅2","遅3","A","B","C"})*{1;0;1;0;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1}*{8,8,8,5.5,5,4,5})
それでしたら、マクロを使って一連の流れ作業の操作をなさったらよろしいかと。
ご要望の件、数式では実現できないこと、ご理解いただけますよね。 条件付き書式でも無理です。条件付き書式で表示形式を指定すればできそうと思うかもしれませんが、表示形式は表示するものがあって初めて適用されるようです。よって、未入力のセルの場合、何も起こりません。 どうしてもやりたいのであれば、やはり、マクロ（VBA)で実装することになりますが、ここまでやる必要がありますか？ どうしてもやりたいのであれば、下記のマクロを該当シートのオブジェクトのWorksheet_Changeイベントプロシジャに張り付けてみて下さい。 さらに、該当のセルに、次の条件付き書式設定をします。 これで、該当セルを空白にすると「－」が表示されるようになります。 【条件付き書式設定】 「指定の値を含むセルだけを書式設定」を選択し、「次のセルのみを書式設定」で、「空白」を指定します。 【マクロ（VBA)】 Private Sub Worksheet_Change(ByVal Target As Range) Dim r As Range Dim c As Variant For Each r In Target If r.Value = "" Then For Each c In r.FormatConditions If c.Formula1 Like "=LEN(TRIM(*))=0" Then r.Value = "-" Exit For End If Next End If Next End Sub
区切り位置を指定してデータを分割してみては？ http://www.becoolusers.com/excel/text-to-columns … 区切り文字、その他でXを入力してデータを分割
＃２です > そのままマクロを作成してもコンパイルエラー　構文エラーが出ます。 ずっと考えていたのですが、何故エラーになったのかわかりません 新規ファイルを開いて、 標準モジュールに、コピー&貼り付けして、 Samp1 を実行すると、アクティブなシートに結果が表示されると思います ※ 本質問は、必勝法？についてのものになりますか？ >　　Const CNUM As Long = 37 ' 1 ～ >　　Const CCNT As Long = 7 ' 個数 この部分 　　Const CNUM As Long = 42 ' 1 ～ 　　Const CCNT As Long = 6 ' 個数 にすれば、1 ～ 42 から 6 つランダム抽出します ロト 云々とは直接関係ないものとして回答していました ※ 以下の条件は、条件ではなかったのですね > １～37までの数字から7つの数字を選ぶ > １００通りの組み合わせはすべて異なる組み合わせにしたい
シート２の C3 セルに「=IF(Sheet1!A1="","",Sheet1!A1)」を入れるだけではいけないのですか？
タイトル通りなら =TEXT(A1,"yyyy/m") =TEXT(A1,"yyyy年m月") 質問文の >計算式などでyyyy/mm/dd、もしくはyyyy年mm月に =TEXT(A1,"yyyy/mm/dd") =TEXT(A1,"yyyy年mm月")
こんにちは！ すでに回答は出ていますが、VBAでの一例です。 元データはSheet1のB・C列1行目からあり、Sheet2のA・B列に表示するとします。 Alt＋F11キー　→　メニュー　→　挿入　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long, k As Long, cnt As Long Dim myStr As String, wS As Worksheet Set wS = Worksheets("Sheet2") wS.Range("A:B").ClearContents With Worksheets("Sheet1") For i = 1 To .Cells(Rows.Count, "C").End(xlUp).Row If .Cells(i, "B") <> "" Then cnt = cnt + 1 wS.Cells(cnt, "A") = .Cells(i, "B") myStr = .Cells(i, "C") k = i Do k = k + 1 If .Cells(k, "B") <> "" Or _ k = .Cells(Rows.Count, "C").End(xlUp).Row + 1 Then Exit Do If .Cells(k, "C") <> "" Then myStr = myStr & vbCrLf & .Cells(k, "C") End If Loop wS.Cells(cnt, "B") = myStr i = k - 1 End If Next i End With wS.Activate End Sub 'この行まで// ※　関数でないのでデータ変更があるたびにマクロを実行する必要があります。 ※　B列のデータ（数値）が入っている行のC列は空白でない！という前提です。m(_ _)m
D列を作業用に使用します。D列を最終的には見えないように設定してください。（文字色を白にするなど） D1セルに「=A1*B1」 D2セルに「=IF(B2<>1,D1,A2*B2)」 D3セルより下はD2セルをコピー C1セルに「=IF(D1=0,"",D1)」 C2セルに「=IF(D1=D2,"",D2-D1)」 C3セルより下はC2セルをコピー
2の方の番号を削除した後、1の方のＢ列にでも作業列としてCOUNTIF式を入力。 範囲は2の方の数字が入っている列、検索条件は自セルの横にあるA列のセル。 下にずーっとコピーしていくと、2にデータがない場合は0、ある場合は1（複数あるならその数）になります。 数式はまずはご自分で調べて入れてみるのが一番です。 COUNTIFについて調べてみましたか？
単純に =CONCATNATE(A1,CHAR(10),A2,CHAR(10),A3,CHAR(10),A4) ではなく、 A1、A2、A3、A4としているところに、「空白であれば空白を返し、空白でなければその値を返す」関数を入れてやればよい。 そうすれば、詰めることもできる。 =IF(A1="","",A1&CHRA(10)) & IF(A2="","",A2&CHRA(10)) & IF(A3="","",A3&CHRA(10)) & IF(A4="","",A4) こんな感じ。 CONCATNATE関数を使わず「＆」で繋げるのだ。
Excel のバージョンはなんですか？ 「有効にして保存」のようなものを選べば良いと思いますが、バージョンが判らないので、メッセージ全部を書いてくれないと判りません。
No.4続き 四則演算の記号 足し算：+ 引き算：- 掛け算：* 割り算：/ 累乗：^ これを使って、算数の式を書く。算数と同じ様に途中に（）が有ってもOK。 =1+2/2+4*2 - 2^3 と書けば2/2=1,4*2=8, 2^3=8だから ２が求まる。 =1+(2/2)+(4*2)-(2^3)でも勿論OK。 セルの値を使うのなら =A1+B1/C1+D1*D2-E2^F2 の様に書く =A1+(B1/C1)+(D1*D2)-(E2^F2) でも良い。
集計機能を使った方が早いかもしれませんね
数値なので C1セルに =MIN(A:A) C2セルに =IF(OR(C1="",C1=MAX(A:A)),"",SMALL(A:A,1+COUNTIF(A:A,"<="&C1))) 下へオートフィル [Ctrl]+[F3]名前の定義 名前 : 桜 参照範囲: =$C$1:INDEX($C:$C,COUNT($C:$C)) 上記を入力規則のリストで =桜
考えてみました。画面をみないと、想像が付かないものがあるものですね。 質問にあるマクロをみると、 最初あった、　Range("$A$35:$DN$78")　これが、 だんだん、Rows("44:63").Select　とずれていますが、これは、削除した後に再度設定しなおしたからです。だから、まとめて行ってしまえばよいということだと思います。 >実際のシートのデータは　Ａ35　～　ＣＣ77までで　（,81） の部分ですが、 　Set Rng = .Range("A35:DN" & Lr)　のDNの部分を書き換えてください。 ※一番大事な所は、この部分です。 　Lr = Cells(Rows.Count, "B").End(xlUp).Row　' この数字を使いまわしします。B列というのは、結合セルがあると、A列には値が入っているけれども、B列は空になっているからです。 マクロのそのLrに、ブレークポイント（●）を入れて、ローカルモジュールなどで、数字か取れているか、最初に見たほうがよいでしょう。 ブレークポイントが面倒なら、 Msgbox LR を貼り付けてもよいです。 ここが取れていなかったら、アウトです。とれていないなら、リテラル値（あらかじめ数字を入れること）になってしまいますから、先頭はともかく、最後行をマクロで探さないと、二度目はまたエラーが出てしまいます。 たぶん、私が、マクロに対してどう考えているかは、以下のコードを見れば分かっていただけるように思います。 '// Sub TestMacro2() 　　Dim Rng As Range 　　Dim Lr As String 　　Dim a As String, b As String 　　Dim Ur As Range 　　' Keyboard Shortcut: 　　With ActiveSheet 　　　　Lr = Cells(Rows.Count, "B").End(xlUp).Row　'ここで最後の行数をとっている 　　　　 　　　　Set Rng = .Range("A36:O" & Lr)　'最初の範囲 　　　　 　　　　If .AutoFilterMode Then 　　　　　　 .AutoFilterMode = False 　　　　End If 　　　　With Rng 　　　　　　.Sort Key1:=.Cells(1, 1), Order1:=xlAscending, _ 　　　　　　Key2:=.Cells(1, 14), Order2:=xlAscending, _ 　　　　　　Key3:=.Cells(1, 15), Order3:=xlAscending, _ 　　　　　　Header:=xlYes, OrderCustom:=1, MatchCase:=False, _ 　　　　　　Orientation:=xlTopToBottom, SortMethod:=xlPinYin 　　　　End With 　　　　'行の削除の部 　　　　Set Rng = .Range("A35:DN" & Lr)　'CCまでなら、DN → CC と変えてください。 　　 　　　　　　Rng.AutoFilter Field:=14, Criteria1:="0:00" 　　　　　　On Error Resume Next 　　　　　　If Application.Subtotal(3, Rng.Columns(1)) > 1 Then 　　　　　　　　a = Rows("35:" & Lr).SpecialCells(xlCellTypeVisible).Address(0, 0) 　　　　　　End If 　　　　　　.ShowAllData 　　　　　　 　　　　　　Rng.AutoFilter Field:=14, Criteria1:="=*(*)*" 　　　　　　If Application.Subtotal(3, Rng.Columns(1)) > 1 Then 　　　　　　　　b = Rows("35:" & Lr).SpecialCells(xlCellTypeVisible).Address(0, 0) 　　　　　　End If 　　　　　　 　　　　　　If a <> "" Then　'セルの範囲のまとめ 　　　　　　　　Set Ur = Range(a) 　　　　　　　　If a <> "" And b <> "" Then 　　　　　　　　　　Set Ur = Union(Range(b), Ur) 　　　　　　　　ElseIf b <> "" Then 　　　　　　　　　　Set Ur = Range(b) 　　　　　　　　End If 　　　　　　End If 　　　　　　.ShowAllData 　　　　　　If Len(a & b) > 0 Then 　　　　　　　　Ur.Delete　'一度に削除 　　　　　　End If 　　　　　　 If .AutoFilterMode Then 　　　　　　 .AutoFilterMode = False 　　　　　　 End If 　　　　End With End Sub
誰も回答が付かないで、参考までに 問題は、日付のデータの個数が不定個になるので、この処理が厄介になるでしょうね。 VBAを使えば、A,B,C,Dでソートしたデータを上から順番に見て行き、A,B,Cが一つ上の行と同じなら、上の行の最終列の右のセルに新しいDの値を書き込むなどすれば、（書き込むのは別のシートがわかりやすい）比較的簡単にできます。 関数だけで処理しようとするよりも、遥かに簡単にできるでしょう。 一回だけで良いのなら、 １．A,B,C,Dの順番でソートしてA,B,Cが同じなら上の行のDに今のDを区切子を挟んで追加する。 ２．A,B,Cが下の行と一致しないならば、表示のためのフラグを、新たなE列に立てる。 ３．データのフィルターでフラグのたった行だけ表示して、可視のセルの選択で見えてる範囲だけコピーして、新しいシートに貼り付ける。 ４．コピーした先のD列を選んで、データ　の　区切り位置で、カンマやタブなどの区切り文字によってフィールドごとに区切られたデータ　で１の時に使った区切子を指定して展開 という方法もあります。 Excelも色々な機能があるので、ひょっとして、一発で処理できる機能があるかもしれませんが…　？？ （つい最近もカメラコピーという機能を始めて知った） でも、こんな不定個になるような集計方法が項目がほんとに必要なのか考えて、（目的を整理して）もっと素直なデータにならないか考えた方があとあと楽な場合も多いと思います。
No.2です。ちょっと、補足 定義した名前を 入力規則のリストに =定義した名前 という形で入れてください。
No.2 補足です。 フォームの製品名には事前に内容をセットしておく必要があります。 Private Sub UserForm_Initialize() ListBox1.AddItem "りんご" ListBox1.AddItem "みかん" ListBox1.AddItem "すいか" ListBox1.AddItem "梨" ListBox1.AddItem "柿" End Sub でセットしていますので、このPrivate Subに追加セットして下さい。
G列は考えていません。F列、昇順になっているとして C1セルに =INDEX(H:H,MATCH(B1,F:F)) フィルハンドルダブルクリック
まさかとは思って書きませんでしたが、Q5にその式を入れていませんよね? Q5に式を入れたらQ5が空白なんてありえないし、自分を参照することになります。
No.1です。 配置を明確にするための画像をアップし忘れていました。 ↓の画像のようにE列に「祝日」のシリアル値がある場合の数式が 前回の数式です。 どうも失礼しました。m(_ _)m
名簿に新規に追加するのは、「名簿（まとめ用）」としていいですか？ 仮に、Ａさん用の名簿を「名簿Ａ.xlsx」、Ｂさん用の名簿を「名簿Ｂ.xlsx」、Ｃさん用の名簿を「名簿Ｃ.xlsx」とし、「名簿（まとめ用）.xlsx」と同じフォルダーにあるとして。 「名簿（まとめ用）.xlsx」の Ｃ２のセルに、 =IF(OR('[名簿Ａ.xlsx]Sheet1'!$C2=1,'[名簿Ｂ.xlsx]Sheet1'!$C2=1,'[名簿C.xlsx]Sheet1'!$C2=1),1,"") と数式を入れ、範囲分下へコピー。 保存したら反映されるのでは無く、「名簿（まとめ用）.xlsx」ファイルを起動した直後に再計算されて反映されます。 これでいけるだろうと思います。
No.1の回答者さんが書いているように、ブックを閉じたときの仕様に なっていますので、SUMIFS関数を使うのならブックを開いておいて、 作業します。 https://support.microsoft.com/ja-jp/kb/260415 どうしてもブックを閉じて作業したいのなら、SUMIFS関数を使わずに 配列数式に変更して回避します。 ｛=SUM(IF((条件１)*(条件2),範囲))} http://ameblo.jp/pcroom123/entry-11742483652.html http://excel-magic.com/post-32/
回答が付かないようなので、直接の回答ではありませんが、ご参考までに ご質問の趣旨は、主軸と第2軸として設定したときに軸の値を重ならないで表示したいということですね。 残念ながらその方法はわかりませんが、 レーダーチャート　第2軸　でググった結果を示します。 http://www.excel.studio-kazu.jp/kw/2005071117204 … http://detail.chiebukuro.yahoo.co.jp/qa/question … どちらも、その方法は掛かれていませんが、レーダーチャートを利用するときは第2軸を使うような使い方は、考えた方が良いというようなことが掛かれているようです。
誤解があれば、ごめんなさい。 誰からも回答がないので…。 説明文を読んでもイメージがわかないのです。 転送するのは、日付と時刻だけですね。 それなら、わざわざ転送しなくても、直接ブック３に入力すればいいと思うのですが？ ①において、 毎日データを入力する前に前日のデータを消去する。このデータは保存しないのですか？ ブック２、ブック３のＢ１６セルには前日の日付、Ｄ１６セルには前日の時刻のみが表示されることになります。 ①から③の繰り返しなら、ブック２、ブック３のＢ１６セルには前日の日付、Ｄ１６セルには前日の時刻のみが記録されることになります。 だから、 ＞よって②③にはB16セル以降B17、B18、B19…、D16セル以降はD17、D18、D19…、となりB列は同じ日に点検を数回行う事もある為、5/8,5/9,5/9,5/10,5/10,5/10,5/11…となる事もあります。 というようなことはないのです。 ブック２とブック３の使い分けがよく分からない。 以上のようなことで、質問の回答ができないのです。
こんばんは！ 2015年4月10日～2016年3月10日 のように一つのセルにある場合は文字列になってしまいます。 一案です。 ↓の画像のように開始日と終了日を別セルに分けシリアル値にします。 そして画像でいう「図2」がSheet2にあるとすると ↓の画像ではまず、E2セルに =COUNTIFS(Sheet2!$C:$C,">="&$A2,Sheet2!$B:$B,E$1) という数式を入れ隣にF2セルまでコピー！ 最終行のE26セルには =COUNTIFS(Sheet2!$C:$C,"<="&$C26,Sheet2!$B:$B,E$1) という数式を入れ隣のF26セルまでコピー！ E3セルに =COUNTIFS(Sheet2!$C:$C,">="&$A3,Sheet2!$C:$C,"<="&$C3,Sheet2!$B:$B,E$1) という数式を入れ残りの列・行方向にフィル＆コピー！ これで画像のような感じになります。 ※　Excel2003までのバージョンをお使いの場合は COUNTIFSは使えませんのでSUMPRODUCTを使うようになります。 ※　一つ気になるのですが、 3月11日～4月9日までは無視されますが それでも良いのでしょうか？m(_ _)m
項目は違いますが https://oshiete.goo.ne.jp/qa/9269420.html の方の質問が参考になると思います。 ちなみに 勘定科目ごとのシートを作成するのはやめましょう。 セルに　勘定　を入力すると 以下に必要な部分が抽出される機能や関数を考えます。
Excel2016は見掛けがずいぶん変わっているので、マクロ自体の問題ではないかもしれません。 漠然とした問いかけでなく、具体的なコードを示さないと適切な回答は出てこないと思います （差し障りがない分だけにして　　もっともこれで原因が自分でも分かるかも）
G列入ってないのかな？ G1セルに =IF(MOD(ROW(G1),4)=1,INT(ROW(G1)/4)+1,"") 下へオートフィル G列使わないなら =INDEX($A$2:$E$5,MOD(ROW(H1)-1,4)+1,INT((ROW(H1)+3)/4)) 下へオートフィル =INDEX(配列,行番号,列番号) の「行番号」と「列番号」部分をそれぞれ別のセルへ入力して検証してみてください
こんにちは。 私は、マクロが未熟なせいか、変わった手順に思いました。 ふつうは、UserForm を立ち上げてから、選択します。 ただし、UserFormは、モードレスで立ち上げるのが通例です。 もちろん、ご質問者さんの方法もないとは言えません。 試行錯誤で確認できました。 >選択範囲が明示された状態を維持するには、どうしたらよいでしょうか？ まず、理由なのですが、それは、ActiveX コントロールを二重に使ったことが原因なのです。UserForm はActiveX コントロールですし、ボタンも同じですし、シートもそのひとつなので、オブジェクトによる取得が飛んでしまいます。 つまり、原因は、CommandButton にあります。対処法は、フォームコントロールのボタンに変えてください。また、マクロのコードも、そちら（標準モジュール側）に移してください。 立ち上げたモードが、モーダル／モードレスでも、選択範囲を失うような現象は現れません。ただ、Excel 2000以降では、通例モードレスが中心になることが多いようです。 なお、UserForm立ち上げの前に、選択範囲を確保するためにするコードは必要です。変数は、任意です。 '標準モジュール Public myRng As Range　　'これでユーザーフォームに橋渡し Sub ボタン1_Click() 　If TypeName(Selection) = "Range" Then 　　 Set myRng = Selection 　End If 　UserForm1.Show 0　　'0=vbModeless モードレス モード End Sub -------- UserFormモジュール Private Sub CommandButton1_Click() 　If Not myRng Is Nothing Then 　　 myRng.Interior.ColorIndex = 3 　End If End Sub ---------- Public myRng As Range　これをパブリック変数と読んで、氷樹モジュールの一番上方のプロシージャの外に書くことです。そうすると、プロジェクト内で共通に使えるようになります。ただ、あまり多数は作らないほうがよいそうです。
こんばんは！ 一例です。 標準モジュールにしてください。 Sub Sample1() Dim i As Long, lastRow As Long, wS As Worksheet Set wS = Worksheets("Sheet2") wS.Cells.Clear With Worksheets("Sheet1") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row .Range("D:D").Insert .Range("D1") = "ダミー" Range(.Cells(2, "D"), .Cells(lastRow, "D")).Formula = "=A2&""_""&B2" .Range("D:D").AdvancedFilter Action:=xlFilterCopy, copytorange:=wS.Range("A1"), unique:=True wS.Range("A:A").Sort key1:=wS.Range("A1"), order1:=xlAscending, Header:=xlYes .Range("A1").Resize(, 3).Copy wS.Range("A1") lastRow = wS.Cells(Rows.Count, "A").End(xlUp).Row With Range(wS.Cells(2, "C"), wS.Cells(lastRow, "C")) .Formula = "=SUMIF(Sheet1!D:D,A2,Sheet1!C:C) " .Value = .Value End With Application.DisplayAlerts = False wS.Range("A:A").TextToColumns Destination:=Range("A1"), DataType:=xlDelimited, _ Tab:=True, OtherChar:="_", FieldInfo:=Array(Array(1, 1), Array(2, 1)) Application.DisplayAlerts = True .Range("A1").Resize(, 3).Copy wS.Range("A1") .Range("D:D").Delete End With End Sub ※　A・B列の昇順で並び替えを行っていますので、Sheet2の順番が 質問通りにはなりません。 ※　個数の降順で並び替えを行いたいのでしょうかね？m(_ _)m
1行目が最大値/最小値だったらどうするのですか？　それは絶対ないという ことでしょうか。 この手の計算は INDEX関数を使った方がいいですね。それか SUMIF関数。 少なくとも INDIRECTを使ってまで A1参照形式にする必要はないと思います。
Sub Sample() Dim A As Long Dim L As Long Columns("A:H").Select Application.CutCopyMode = False Selection.Sort _ Key1:=Range("A2"), _ Order1:=xlAscending, _ Header:=xlYes, _ OrderCustom:=1, _ MatchCase:=False, _ Orientation:=xlTopToBottom, _ SortMethod:=xlPinYin Columns("I:P").Select Selection.Sort _ Key1:=Range("I2"), _ Order1:=xlAscending, _ Header:=xlYes, _ OrderCustom:=1, _ MatchCase:=False, _ Orientation:=xlTopToBottom, _ SortMethod:=xlPinYin A = 2 L = 2 Do While Cells(A, 1).Value <> "" If Cells(L, 9).Value = "" Then Exit Do If Cells(A, 1).Value = Cells(L, 9).Value Then Else If Cells(A, 1).Value > Cells(L, 9).Value Then Range(Cells(A, 1), Cells(A, 8)).Select Selection.Insert Shift:=xlDown Else Range(Cells(L, 9), Cells(L, 16)).Select Selection.Insert Shift:=xlDown End If End If A = A + 1 L = L + 1 Loop End Sub ☆ タイトル行が無い時は ① ２ヶ所ある「Header:=xlYes」を「Header:=xlNo」にして下さい。 ②「A = 2」を「A = 1」にして下さい。 ③「L = 2」を「L = 1」にして下さい。
＞マクロを使用する技術は当方にはありませんので、できる限り関数で出来ればありがたいです ですが、いたって簡単なので　マクロ案です。 データのシートが（シート名が　データ　として） A～D列で、1行名が項目であるとします。 別シートに 　　A　　B　 C　　D １　番号 ２　　１ ３ ４ ５　 番号　　部署名　　職位　　名前 とA1~A2に抽出する項目とデータをコピー 5行目に、表示する項目部部分をコピー シート名のタブを右クリック、コードの表示をクリック VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = ("$A$2") Then Sheets("データ").Columns("A:D").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("A1:A2"), CopyToRange:=Range("A5:D5"), Unique:=False End If End Sub を張り付けて閉じる。 A2セルに　１，２・・と番号を入れると、ご希望のデータが6行目以下に抽出されます。 フィルターオプションの機能をマクロ化しています。 詳しくは http://www.eurus.dti.ne.jp/~yoneyama/Excel/filte … などで勉強してみて下さい。
目的が分かれば、別案も考えられますが数式だけではわかりかねます 解析できた分 AQ4に 「あい うえお」と入力されているとして B4:AN4セル範囲の中から「あい 」(半角スペースまで)が頭に入っているものを探し、 そのセル範囲の中からいちばん右のもの列番号を数値で返す その列番号から40引く ここで問題があると思うのが、セル範囲の列番号の数値は2～40までで そこから40を引くので負か0となる それがOFFSET関数の[幅]にあたるため、0や負はあり得ない =OFFSET(基準,行数,列数,高さ,幅) というところで行き詰りました
＞E列全てのセルに、このBVAを適用するには ですので If Target.Column= 5 Then と指定します。
対象がA1セルならば =IF(A1>=1500,"G1",IF(A1>=1000,"G2",IF(A1>=500,"G3","G4")))
関数を用いて =CONCATENAT(A1,B1)
ここのいくつかはもう試されました？ https://support.office.com/ja-jp/article/%25E7%2 …
CELL関数で”filename”からシート名を読み出すという手もある。 CELL関数で得られたシート名をINDIRECT関数で範囲に置き換えて参照してはどうか。 =CELL("filename",A1) で、 C:\Users\abc\Documents\[sample.xls]Sheet2 のような文字列が返ってきます。 FIND関数で「 ] 」の位置を把握してMID関数やRIGHT関数でシート名だけを切り出せるでしょう。 あとはINDIRECT関数でそのシート名を使えばよい。 ・・・ もうこの時間なのでヒントだけで勘弁してください。
No.4です。数字が1～200までとして =SUBSTITUTE(TRIM(SUBSTITUTE(" " &LARGE(IF(ISERR(FIND(","&ROW(A1:A200)&",",","&A1&",")*FIND(","&ROW(A1:A200)&",",","&B1&",")),,ROW(A1:A200)),5)&" " &LARGE(IF(ISERR(FIND(","&ROW(A1:A200)&",",","&A1&",")*FIND(","&ROW(A1:A200)&",",","&B1&",")),,ROW(A1:A200)),4)&" " &LARGE(IF(ISERR(FIND(","&ROW(A1:A200)&",",","&A1&",")*FIND(","&ROW(A1:A200)&",",","&B1&",")),,ROW(A1:A200)),3)&" " &LARGE(IF(ISERR(FIND(","&ROW(A1:A200)&",",","&A1&",")*FIND(","&ROW(A1:A200)&",",","&B1&",")),,ROW(A1:A200)),2)&" " &LARGE(IF(ISERR(FIND(","&ROW(A1:A200)&",",","&A1&",")*FIND(","&ROW(A1:A200)&",",","&B1&",")),,ROW(A1:A200)),1)&" "," 0 ",""))," ",",") [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 計算 超重いので注意！！
Longで定義しているにもかかわらず、””ですか？ ということは、Sub Button_Clickプロシジャ内で、Dim ｎ As Variantとか書いていませんか？ プロシジャ内で同名の変数を定義した場合、別の変数とみなされます。
わたしに誤解があったら申し訳ないのですが、 在庫シートが集計すべきデータで、ホームシートが集計結果を出すシートですよね。 ホームシートに、商品コードごと　かつ　店番ごと　の在庫数を算出するという。 原始的ですが、以下のようにやってみました。ホームではなく、在庫データをループさせています。 データ数が分からないので、ホーム、在庫データとも1万件でやってみました。 もっといい方法もあるかと思いますがよろしければ一度どうぞ。 '--------------------------------------------------- Sub Shukei() '***　変数宣言　*** Dim WsH As Worksheet, WsZ As Worksheet Dim WSF As Object Set WsH = Worksheets("home") Set WsZ = Worksheets("zaiko") Set WSF = Application.WorksheetFunction Dim r As Long, c As Integer Dim LstRow As Long, Zaiko As Long Dim SCode As String, MiseCode As Integer Dim SRow As Long, MiseCol As Integer '***　在庫シートの最終行を取得　*** LstRow = WsZ.Cells(Rows.Count, 1).End(xlUp).Row Application.ScreenUpdating = False '***　在庫シートの2行目から最終行までループ　*** For r = 2 To LstRow SCode = WsZ.Cells(r, 3).Value '商品コード。在庫のC列 MiseCode = WsZ.Cells(r, 1).Value '店コード。在庫のA列 Zaiko = WsZ.Cells(r, 7).Value '在庫数。在庫のG列 SRow = WSF.Match(SCode, WsH.Columns(14), 0) '該当の商品コードがホームシートN列の何行目にあるか MiseCol = WSF.Match(MiseCode, WsH.Rows(1), 0) '該当の店番がホームシート1行目の何列目にあるか WsH.Cells(SRow, MiseCol).Value = WsH.Cells(SRow, MiseCol).Value + Zaiko 'ホームシートの該当セルに在庫数を加算 Next r Application.ScreenUpdating = True Set WSF = Nothing Set WsH = Nothing Set WsZ = Nothing MsgBox "End." End Sub '---------------------------------------------------------------------------------
別解です。 １．セル A2 を選択 ２．Ctrl+Shift+↓キーを１回だけチョーン ３．Shift+→キーを一発ツン(左端図) ４．[ジャンプ]→[セル選択]を実行 ５．“空白セル”に目玉入れ ６．[OK]ボタンをツン(左から2番目図) ７．キーボードから =C1 を入力(3番目図)、でも Enterキーは叩いちゃ駄目！８．そのマンマの状態で、Ctrl+Enterキーを「エイヤッ！」と叩き付け(4番目図) ９．範囲 C2:C3 を選択して、Deleteキーをパシーッ(右端図、完成！) 【補足】記述すると長～いけど、鼻歌交じりの手順に慣れるとアッという間に仕上がる！
ママチャリです。なぜでしょうかね～？？？ とりあえず、設定した条件式を補足に張り付けて頂いてもよろしいでしょうか？ 念のため確認なのですが、「1.5｣は数値として入力されているのですよね？文字ではないですよね？また、数式で求めたりもしていませんよね？さらに、1.54を四捨五入して1.5で表示していると云うこともないですよね？ その他、何か変わったことしていないでしょうか？
お勧めする訳じゃありませんが =LOOKUP(1,0/(FIND(LEFT(X4,FIND(" ",X4&" ")),B4:W4)=1),COLUMN(B:W)) 表の作り方を考え直した方がいいように思います。
下からvbaを組み込んだEXCELをダウンロード出来ます。 ZIP内に質問内容を実現したEXCELが入っています。 Sheet1にprivate subが３個入っています。 それを、そのままコピペすれば動きます。 EXCELのまま使っても動きます。 http://www.tfumi01.com/test/test.html 変なものは入っていませんので、安心の程を・・・。
No.2・3です。 ＞2016/4/2 6.98Km 0:58:37　6.98/0:58:37/24＝時速12313.38555㍍で計算が成り立たなくなりました。 ん？前回の画像の配置の各セルに数値（時間）を入力すれば 前回の数式（仮に2行目だと） =B2/C2/24 だけでちゃんと「7.14472・・・」と表示されると思うのですが。 あくまで単位はKmになります。 セルの表示形式は必ず「標準」にします。 （メートル換算にしたい場合は1000倍する。） 一つのセルにで完結したいのであれば =6.98/"0:58:37"/24 といった具体に時間の部分をダブルクォーテーションでくくってみてください。 ※　次にNo.2の ＞全体を24で割るとなぜ時速が出るのでしょうか についてですが、 時間（時刻）は小数点以下の部分になります。 仮に「6：00」と入力するとその数値は「0.25」となり 0.25日の意味ですので、 ある数値を時間（時刻）で割ると「日速」となります。 時速を求める場合は 単純に24で割り算しているだけです。 まずはこの程度で・・・m(_ _)m
こんばんは！ VBA向きの質問だと思います。 すでに回答は出ていますが、一例です。 画像通りの配置だとします。 シートモジュールにしてみてください。 Sub Sample1() Dim i As Long, j As Long, c As Range Range("H:J").ClearContents For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row Set c = Range("H:H").Find(what:=Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If c Is Nothing Then With Cells(Rows.Count, "J").End(xlUp).Offset(1) .Offset(, -2) = Cells(i, "A") .Offset(, -1) = Cells(i, "B") End With End If For j = 3 To 6 '←C列～F列まで// If Cells(i, j) <> "" Then Cells(Rows.Count, "J").End(xlUp).Offset(1) = Cells(i, j) End If Next j Next i Range("H1:J1").Delete shift:=xlUp End Sub こんな感じではどうでしょうか？m(_ _)m
A列のセルとB列のセルの関係がよく分からない質問ですね。 ・Ａセル12000000の2％以下の部分の240000迄は０％の0 ・2.0％超～3.0以下の部分の120000は20％の24000 ・3.0％超～4.0％部分の120000は30％の36000 ・4.0％超～の部分の520000は55％の286000 ・0+24000+36000+286000=346000 ・346000×75％＝259500 ということなので、 A列のセルの何％とB列のセルの何％かを加えた値の75％ということでよいのでしょうか。 以下、そのつもりで回答します。 ＞・Ａセル12000000の2％以下の部分の240000迄は０％の0 ＞・2.0％超～3.0以下の部分の120000は20％の24000 ＞・3.0％超～4.0％部分の120000は30％の36000 これをまとめると、 ”2％以下”と”○%超” の条件を無視して、 「A列のセルの値の0.2％」 「A列のセルの値の0.3％」 になります。 さらに ＞※520000の定義は[1000000(4%超部分)-240000(2%部分)-120000(3%部分)-120000(4%部分)=520000] の部分は、 「B列のセルの値からA列のセルの0.4%を引いた値」 ということになります。 結果、 「A列のセルの値の0.5％」と「B列のセルの値からA列のセルの0.4%を引いた値を加えた値の55%」の和の75％ ということになります。 これなら自分で数式を作れるのではないでしょうか。 関数は必要ありません。 四則演算だけです。 このように条件をしっかりまとめることで、式を簡単にすることができるので、 まずは数字がどんなことになっているのかを理解するようにしましょう。
ご意向にそぐっているか分かりませんが、以下のようにやってみました。 ＜主な流れ＞ ・シートは３つ用意してください。moto,kako,betsu 元シート（moto）、加工（kako）、別シート（betsu) ・元シートのデータ、日付ごとに全情報を一行に並べる（加工シートに） ・加工シートをもとに別シートに転記する。その場合、6つまでのデータは所定の箇所に記入し、 　それ以降（7番目以降）のデータはスルー ’------------------------------------------------------------------ '変数宣言 Dim WsM As Worksheet, WsK As Worksheet, WsB As Worksheet Dim WSF As Object Set WsM = Worksheets("moto") Set WsK = Worksheets("kako") Set WsB = Worksheets("betsu") Set WSF = Application.WorksheetFunction Dim Dic As Variant, Hiduke As Date Dim myKeys As Variant Dim r As Long, c As Long Dim TgtRow As Long, LstCol As Long Dim Joho As String Set Dic = CreateObject("Scripting.Dictionary") ' 加工シートに日付の非重複リストを作成 WsK.Cells.ClearContents r = 1 Do While WsM.Cells(r, 1).Value <> "" 　　Hiduke = WsM.Cells(r, 1).Value 　　If Not Dic.exists(Hiduke) Then 　　　Dic.Add Hiduke, Hiduke 　　End If 　　r = r + 1 Loop myKeys = Dic.keys For r = 0 To Dic.Count - 1 　　WsK.Cells(r + 1, 1).Value = myKeys(r) Next r '加工シートに日付ごとに全情報を一行にまとめて転記 r = 1 Do While WsM.Cells(r, 1).Value <> "" 　　For c = 2 To 3 　　　TgtRow = WSF.Match(WsM.Cells(r, 1), WsK.Columns(1), 0) 　　　LstCol = WsK.Cells(TgtRow, Columns.Count).End(xlToLeft).Column + 1 　　　WsK.Cells(TgtRow, LstCol).Value = WsM.Cells(r, c).Value 　　Next c 　　r = r + 1 Loop '加工シートのデータを別シートに転記 r = 1 Do While WsK.Cells(r, 1).Value <> "" 　　Hiduke = WsK.Cells(r, 1) 　　TgtRow = WSF.Match(Hiduke, WsB.Columns(1), 0) 　　LstCol = WsK.Cells(r, Columns.Count).End(xlToLeft).Column 　　For c = 2 To LstCol 　　　　Joho = WsK.Cells(r, c).Value 　　　　Select Case c 　　　　　　Case 2 　　　　　　　 WsB.Cells(TgtRow, 2).Value = Joho 　　　　　　Case 3 　　　　　　　WsB.Cells(TgtRow, 3).Value = Joho 　　　　　　Case 4 　　　　　　　 WsB.Cells(TgtRow + 1, 2).Value = Joho 　　　　　　Case 5 　　　　　　　WsB.Cells(TgtRow + 1, 3).Value = Joho 　　　　　　Case 6 　　　　　　　WsB.Cells(TgtRow + 2, 2).Value = Joho 　　　　　　Case 7 　　　　　　　 WsB.Cells(TgtRow + 2, 3).Value = Joho 　　　　　　Case Is >= 8 　　　　End Select 　　Next c 　　r = r + 1 Loop '変数開放 Set Dic = Nothing Set WSF = Nothing Set WsM = Nothing Set WsK = Nothing Set WsB = Nothing End Sub
なるほどです（度々ですいません）。では、これでいかがでしょう？ 次の式をD102～BU102セルに条件付き書式設定してみて下さい。 ただし、D102～BU102には、未入力（空白）は無いものとします。 =if(D102=0,countif($D102:D102,0)<=3,if(D102=1,countif($D102:$BU102,0)+countif($D102:D102,1)<=3)) 式の意味ですが・・・ D102が０の場合、＄D102～D102の０の個数が3以下の場合、Trueを返します。 D102が１の場合、＄D102～＄BU102の０の個数＋＄D102～D102の１の個数が3以下の場合、Trueを返します。
プリンタの余白の下限があるのでなんともですが。 ここに「余白の表示」ボタンがあります。
「hallo-2007」さんの物は、ボタンをクリックするごとに「単位」がついてしまいます。「単位」がついているか判定を行わないといけません。
図がまったく見えません。キャプチャしたものを貼り付けていただけませんか？簡単なやり方↓ ① エクセルを必要な所だけが見えるように小さくする。 ② [Alt]+[Print Screen] キーを押しキャプチャする。 ③ ペイントなどの画像ソフトを立ち上げ、そこに貼り付ける ④ 名前をつけて保存し、これに貼り付ける。
＃１です。補足拝見しました。 ＞後６つのところに入力したい ここの内容がいまいち不明ですが、７つおきでなく、AL～FU？列すべてということならば、 ループ のところ、Step7 ではなく、 For c=38 To 177 でOKです。 あるいは、補足に書かれているように、 AL~AR は全列、AS～FO　は７列おき、FO～FUは全列　ということなら処理は変わります。 もう少し具体的に示すと良い回答が付くでしょう。
セル B2 に式 =OFFSET($B4,ROW(A1),COLUMN(A1)-1) を入力して、此れを右隣にオートフィル
[No.6]で示した式はすべて Sheet2 におけるものなので、 各式の左端の「Sheet1!」は「Sheet2!」とすべきだったことを今頃になって気付きました。 それから、式の解読を容易ならしめるために、補助列を使用していますが、此れを幼稚過ぎると厭うならば、 Sheet2!A1: =OFFSET(INDIRECT("Sheet1!"&ADDRESS((INT((ROW(A1)-1)/12)+1)*3-2,1)),MOD(ROW(A1)-1,3)+1-1,MOD(INT((ROW(A1)-1)/3),4)+1-1)&"" としても構いません。この場合は、列Ｃ～Ｅは不要です。
添付図参照 １．範囲 A1:C8 を選択(←D列までは選択しないこと！) ２．[データ]→[フィルタ]→[フィルタオプションの設定]を選択 ３．[抽出先]として、“指定した範囲”にチェック入れ ４．“重複するレコードを無視する”にチェック入れ ５．[抽出範囲]ボックスにマウスカーソルを置いて、セル F1 をチョーン ６．[OK]をツン ７．セル I1 に次式を入力して、このセルのフィルハンドルを「エイヤッ！」とダブクリ！ ＿＿ =MAX((A$2:A$8=F2)*(B$2:B$8=G2)*(C$2:C$8=H2)*(D$2:D$8)) 【お断り】上式は配列数式として入力のこと
「実行時エラー’9’： インデックスが有効範囲にありません。 ブック名、シート名が存在しませんと云う事でしょう Workbooks("Cドライブデータ保存").Sheets("Sheet1"). Sheet1が存在するか確認してください。
Ctrl + Alt + Vで、「値のみ貼り付け」のラジオボタンをチェック+「行と列を入れ替える」のチェックボックスを選択でいかがでしょうか(Excel2007以降のみですが）。 キーボードのみで行くなら、Ctrl + Alt + V → Alt + V →　Alt + E → Enterとか。
こんにちは。 一応、私は、まったくの素人なのですが、言葉のやり取りからすると、「コードはなしで」という前提なのだと思います。 >表示した後に 表示した回数をカウント保存したいのですが、 >やり方がわかる方お教え頂けますでしょうか。 これは、初歩的な話で、コマンドボタン等で乱数発生時にクリックした時に、セルに書き出して、 Range("A1").Value = Range("A1").Value +1 (書き出す場所） ただ、本当に余計なお世話ですが、気になるのは、 >RANDBETWEEN関数で１から20000の数字をランダムで割り当て該当の行の問題が表示されます。 まず、VBAというのに、RANDBETWEEN関数を使うところが良く理解できないです。VBA関数と、ワークシート関数の、擬似乱数発生の度合いについての知識はありますか？ワークシート関数では、一様乱数は 32768 種しかありません。思ったように乱数の発生率が悪いのです。それを、RANDBETWEENで足切りしてしまうと、もっと性能が落ちます。 https://support.microsoft.com/ja-jp/kb/828795 http://www001.upp.so-net.ne.jp/isaku/rand.html [最も多くの人に使われている乱数であろう Visual Basic の Rnd の質は最低である。 ] VBAとも関数とも、ユニーク（一意）は確保されないのではないかと思います。 >それぞれの問題がユニークな番号が振られています。 ユニークとは、重複を許さないことです。擬似乱数ジェネレータでは、それができないので、一意を取るために、いくつかのノウハウが考えられます。これ以上のこうした話は、不要かもしれませんね。 失礼しました。
＞Excelでのテーブルスタイルを残すのが難しそうです。 　そのためにスタイルシートがあるのですよ。 1) HTMLの最大の目的は「どんな環境からもWebの情報を利用できるようにすべき( http://www.asahi-net.or.jp/%7Esd5a-ucd/rec-html4 … )」です。そのために、『プレゼンテーションに関する要素や属性は、次々と他の機構、とりわけスタイルシートに置換えられていく。( http://www.asahi-net.or.jp/%7Esd5a-ucd/rec-html4 … )』のであり、 「スタイルシートでは、行間の設定やインデントの設定、テキスト色や背景色、フォントのサイズとスタイル、その他様々なプロパティの設定が簡単にできる。( http://www.asahi-net.or.jp/%7Esd5a-ucd/rec-html4 … )」 　なのです。 2) excelは表計算ソフトですから、その表現力は極めて限定されています。 　table tr:nth-child(3n) td{background-color:aqua;} 　3n行の背景色は水色 　これをエクセルで行おうとしたら一仕事になるがスタイルシートだと、カチャカチャと、ものの数秒もかからない。 　私も膨大な表をHTMLに直すことが、しばしばありますが、基本的に 少なければ、正規表現の扱える EmEditor、多くなると テキスト処理が得意なPerl( https://ja.wikipedia.org/wiki/Perl#.E7.89.B9.E5. … )を使って処理します。 　スタイルシートを外部ファイルにしておけば、それこそ素のtableだけ置くことになる。 ★ファイルサイズは、数百kb以内で収まるでしょう。 　csvで出力して、その数倍が目安 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> <html lang="ja"> <head> ・・ ＿<link rel="styleSheet" type="text/css" media="print,handheld" href="./styleSheet/print.css"> </head> ★ エクセル出力のHTMLはローカルで、エクセル使わずに見るためだけの手段でしかありません。決してウエブ用には使えませんし。使ってはならない。
比較対象のセルにG11が2回登場しているのが、これって間違いですよね？とりあえず、無視して回答します。 Excelらしく、CountIfワークシート関数で、条件にあう件数をカウントしてみました。 Sub sample() Select Case WorksheetFunction.CountIf(Range("G11:G11:I11:H10"), "<" & Range("H11")) Case 1 '1つの場合の処理 Case 2 '２つの場合の処理 Case 3 '・ '・ End Select End Sub
全く同感ですが、考えられる理由としては、 Excelの選択は「セル」を選択しているのではなく「セルの範囲」を選択しているため、一部解除を許すと矩形でない範囲が残ってしまい処理が面倒になるからでしょう。 それにしてもいくらでもやりようはあるでしょうけど。例えば一部分でも解除しようとするとその選択範囲全体が消えるなど。 選択がセルでなく範囲であることは、選択範囲に罫線を付けると分かりやすいです。 例えば「A1:C3を選択し、続いてB2を選択した」状態で外枠の罫線を付けると2重の罫線が付きます。十文字に交差する選択範囲など複雑なことになります。 Excel2010か2013あたりからは、表示上も複数回選択したセルは色が濃くなるようになりました。
ワークシートの１番目に 　　A 　　|　B 1|りんご　|あか 2|みかん　|おれんじ 3|ぶどう　|むらさき 4|バナナ　|きいろ 5|メロン　|きみどり と入力されているとして、 （コード中に記述するのは面倒だったもので・・・） 適当なところを選択後 Sub てすと() Dim myData As Variant, rndV As Long Dim c As Range myData = Sheets(1).Range("A1:B5") Randomize For Each c In Selection rndV = Int((rnd * 5) + 1) c.Value = myData(rndV, 1) c.Offset(0, 1) = myData(rndV, 2) '添付画像用にしています。 Next End Sub という様なこと？ 勘違いならゴメン。
＞Excelシート上でカーソルを動かしている時に 俗に云う　MouseOver　と云ったところですか？ マウスがどこになるかですが、エクセルのシート上なのか、他のバーの上か デスクトップの上なのかも判断しなくてはならないので エクセルの機能では無理でしょう。 エクセルのシート上で クリック、ダブルクリック、右クリックなど、何らかのマウス操作でもって エクセルにシート上にマウスの位置を伝えるしかないと思います。
単に見た目だけ変えるのなら 別に条件付き書式を使わなくても 表示形式をユーザー定義するだけでいいと思います。 ユーザー定義で「[=-1]!0;G/標準」とすればいいです。
>Worksheet_Changeが既に書かれて If Target.Column = 8 Then If Right(Target.Value,1) = "N" Then 『T』に【いいえ】 Else 『T』に【はい】 End If End If の部分だけ追加すればよいでしょう。 Changeイベントは実行されますが If Target.Column = 8 Then の時だけ必要なコードが実行されるだけです。
No.2です。 前回の投稿で誤記がありました。 Sheet2の数式を入れるセルは ＞A2セルに ではなく ＞B2セルに ですよね！ どうも失礼しました。m(_ _)m
「完全一致じゃないとエラーになる」とのことですが、これはkronos_666さんが書いた検索ロジックに問題があるからですよね？テキストボックスにしたところで、解決するようなことではないような気がします。 どのような方法で検索しているのでしょうか？ 例えば、ワイルドカードを使うとか、Range.FindメソッドでxlPartを指定するとかすれば、完全一致でなくてもヒットしますよ。
こちらに書いておきます。 >何故か、その作ったデータを、開くとpersonalが開き、新規Excelを開くと、前につくったそのデータが開くのです。 PERSONAL というのは、PERSONAL.XLSBだと思います。 マクロをPERSONAL.XLSB（個人用マクロブック）に登録したものだと思いますが、その時、データもシートに書いてしまったものだと思います。 そのブックの内容が重要なら、エクスプローラー で、 C:\Users\(XXXX)\AppData\Roaming\Microsoft\Excel\XLSTART\ （XXXX)は、ユーザー名 PERSONAL.XLSB をデスクトップでも移動してください。 また、ファイル名は任意の名前に書き換えてください。 不要なら削除しても構いません。 なお、PERSONAL.XLSBにマクロを入れる時は、最初に、記録マクロで、ダミーのファイルを作ります。例えば、記録マクロのボタン(画面の左下）を押して、セルをクリックすると記録されます。手作業で作ると、とても面倒な作業が増えます。 まず、試してみてください。
根本的な部分ですが、元データの入力は？？ 元データをなくして、累計を残す方法は良くないですよ。 と云うか一般的でもありません。 入力間違いがあった時の原因もわからなくなります。 データが横方向に伸びるのも限界があります。 一案ですが シート　データ A　　　B　　　C　　　D 日付　事由　　部署　人数 5/1　　欠勤　　A　　２ ・・・ と日付と一緒にひたすら下方向へ入力していく ご希望の表示のシートのセルに　 集計開始日　集計終了日 5/1　　　　　　5/8 と入れると、ご希望のセルに集計数値が計算で得られるような 関数を考えます。
この質問は難しいですね。 私は、ド素人だから分からないかもしれませんが。 >イベントには関係がないプロシージャProN（例えばModule1の下で仮にInitialize）を二つ用意して,それぞれのプログラムをそれぞれUserForm1とModule1に別々においた状態で,別々に稼働させることは問題なくできますが, うーん、これさえ、どのように解釈して良いのかわからないですね。 プロシージャProN（例えばModule1の下で仮にInitialize） 「Initalize」 というのは、イベントの名前です。オブジェクトに対して命令する単語なので、ただのプロシージャ名としてしか扱われません。 通常、UserForm モジュールは、オブジェクトモジュールですから、プライベートキーワードがついています。それを外せば、外部からは呼び出しが利くようになります。ただ、それは、ちょっと変な言い方ですが、ルール違反になってしまいます。 それで、今試しに、イベントドリブン型で、標準モジュールから、 UserFormモジュール Private Sub UserForm_Initialize() 　　Me.TextBox1.Text = Now() End Sub となっているものを、 次に、標準モジュールから、 Sub Test1Macro() 　Call UserForm1.UserForm_Initialize End Sub そのままでは、起動しません。Private キーワードがありますから。しかし、キーワードを外しても、何も起こらないはすです。 理由は、UserFormそのものも、またTextBox1も、それぞれのインスタンスがないからですね。起動した時に、Initialize のイベントが走るわけですから、わざわざ外部から呼び出す必要はありません。 (インスタンスというのは、クラスという設計図で作られた、実体のあるオブジェクトという意味だと思います。） もう少し、具体的な内容なら、もしかしたら、詳しい人は分かるかもしれません。 以下のようにすれば、標準モジュールからは、UserForm内のコントロール・オブジェクトを制御できるようになります。 '標準モジュール Sub Test2Macro() With UserForm1 　　 .Show 0 　　 If MsgBox("I'm waiting your click", vbInformation + vbOKCancel) = vbCancel Then Exit Sub 　　 .CommandButton1 = True End With End Sub でも、こういう意味ではないのかもしれませんし、こういうマクロは、あまり使わない手法だと思います。なぜかというと、必要な項目は、UserForm モジュールのイニシャル・イベントの所に書けばよいからです。 Private Sub UserForm_Initialize() 　　 If MsgBox("I'm waiting your click", vbInformation + vbOKCancel) = vbCancel Then Exit Sub 　　 Me.CommandButton1 = True End Sub
条件付き書式設定で、余計な条件が付いていたりしませんか？ 例えば、=$A$1=""　のような書式が設定されていると、$A$1が未入力の場合、その書式設定が有効になってしまい、アンダーバーの書式が適用されないことがあります。 とりあえず、一旦、すべての条件付き書式をクリアして、再設定してみることをお勧めします。 それでもダメなようであれば、Excelのバグが疑われますが、もしそうなると、どうしようもないですね~。
#1さんの「Excelで作ったhtmlファイルのサイズを縮小したい」のレスを読んで、そうだったなって思うことと、もう一つ、以下のコードをみていて、xmlとほとんど変わらないというか、Excelでは、スタイルシートを使ってxml を出力するわけですよね。 しばらくやっていないので、すっかり忘れてしまっていました。 <table class="type01"> 　<tr> 　　<th scope="row">項目名</th> 　　<td>品名</td> 　</tr> 　<tr> 　　<th scope="row">項目A</th> 　　<td>Apple</td> 　</tr> 　<tr> 　　<th scope="row">項目B</th> 　　<td>Banana</td> 　</tr> 　<tr> 　　<th scope="row">項目C</th> 　　<td>Grape</td> 　</tr> </table> これ自体の表は、Excelとしてのオブジェクトは違いますが、構造的には、変換できるとは思いますし、これ自体の表もテキストとして、マクロで簡単に出力してしまいますね。要するに、取得する時と逆のことをすればよいのですから。何か、あまり難しく考えすぎたような気がしてならないのですが……。
＞COUNTIF()の中の{ , , }の意味、使い方が分かりません。 { , , }、この部分は、配列　ですよと指定してます。 { , , }の中の内容で繰り返し計算してね。 つまり COUNTIF(B2,"*東京都北区*") COUNTIF(B2,"*千代田区*") COUNTIF(B2,"*東村山市*") の3回を計算して、その合計　SUMと云う事です。
一応、こちらにも買い手おきます。 違いは、Range("B1:B7").Value 参考にしてじっくりと考えてみて下さい。 Sub ボタン1_Click() Workbooks.Open Filename:="C:\Users\○○\Documents\Cドライブデータ保存.xlsx" ThisWorkbook.Activate With Workbooks("Cドライブデータ保存") GYOU = .Sheets("Sheet1").Range("A" & Rows.Count).End(xlUp).Row + 1 .Sheets("Sheet1").Range("A" & GYOU & ":G" & GYOU ).Value = Sheets("入力データ1").Range("B1:B7").Value GYOU = .Sheets("Sheet2").Range("A" & Rows.Count).End(xlUp).Row + 1 .Sheets("Sheet2").Range("A" & GYOU & ":G" & GYOU ).Value = Sheets("入力データ2").Range("B1:B7").Value .Save .Close End With Sheets("入力データ1").Range("B1:B7").Value Sheets("入力データ2").Range("B1:B7").Value End Sub
Sheet2のA4に =SUMPRODUCT(Sheet1!AE4:GW4*(MOD(COLUMN(Sheet1!AE4:GW4)-30,7)=1)) と入れると、Sheet1のAE4～GW4までの、AE列を1列目として、7列目ごとのセル（合計25個のセル）に入っている数値の合計が表示されます。
こちらのサイトで紹介されている内容でしょうかね http://schoolpc.exblog.jp/19667491
他からも呼ばれているという事ですよね！ それで全部直すのが面倒というなら 例えば、元のマクロが「旧Macro」で、新しく付けたい名前が「新Macro」だったら Sub 新Macro() Call 旧Macro End Sub こんな感じで Call 文だけのマクロを作るのもありかも
1回きりの作業で、かつテキストの並びが必ず「Ａ(n)が3行連続、4行目がＢ(n)」という4行1組の規則的な繰り返しになっているという前提で… 手順1　テキスト全行を、そのままC列に貼り付ける。 手順2　A1とB1のセルに下記の式を入力する。 　　　　A1　=C1&CHAR(10)&C2&CHAR(10)&C3 　　　　B1　＝C4 　（注）CHAR(10)は改行コードです。 　　　　A列のセル書式は「□ 折り返して全体を表示する」を選択。 手順3　セルA1:C4を選択し、右下の角をポイントして「＋」が現れたらそのまま下にドラグする。 手順4　A列:B列を選択し、コピー ⇒ 値の貼り付け で、式の結果（値）を固定する。 手順5　C列を削除する。 手順6　A列かB列にフィルターを設定し、空白行を選択して削除する。 何度も繰り返し発生する作業の場合はマクロを組んだほうが手間が省けます。
存在の有無を判断したいのであれば、COUNTIF関数でもできますよ。 VLOOKUP(A1,B:C,2,false)　→　COUNTIF(B:B,A1)>0　とすればいけると思います。 もう一つのVLOOKUPも同じように修正して下さい。
図の件ですが、大きい範囲をキャプチャしてしまうと図のように縮小されてしまうので、必要な部分だけ入るようにエクセルをキャプチャするともっとハッキリ表示されると思います。
No.1です。 新しい質問にしてしまったのですね。図が小さすぎて拡大しても見えません。 必要な部分を拡大して載せ直すか、せめて式は質問文にコピペにして下さい。 こちらの質問は必要ないのであれば、終了させた方がいいと思います。
No1です。補足、拝見しました。 「通常の日付順である4月からの並び替え」ということですが、通常の日付順であれば、最初にmakun100さんがやった通り、1月～12月の順番で正しいですよね？ 4月～3月であれば、年度に相当する月順ということだと思うのですが、やりたいことはこちらでしょうか？ もしそうであれば、並べ替えキー用の作業列を用意して、その列を使って並べ替える必要があると思います。 具体的には、次のような感じでしょうか。 =IF(MONTH(C2)>3,MONTH(C2),MONTH(C2)+12)
全部開く時と開かない時でOSが違ってませんか？ Vistaからは、一括で開けるファイルが15個以下に制限されているようです。
すみません。私は、ご質問の、おっしゃっている内容が理解できません。 Excel VBAという限定ですと、Form というのは、フォーム・コントロールのことだと思います。ところが、フォーム・コントロールには、TextBox はありません。フォーム・コントロールには、ダイヤログボックスで使う、テキストフィールドしかありません。 Access やVBで、フォームというものが、Excelでは、UserForm に該当し、Active X コントロール(OLEオブジェクト）というものですが、これらを操作する場所は、オブジェクト・モジュールと言って、UserFormモジュールは、同じブックのプロジェクトに書いたとしても、独立したオブジェクトになってしまい、他のモジュールからは、細かく定義してあげないと呼び出せません。こういう階層的な書き方、コンテナ型と読んでいます。 また、ExcelやWordには、オートシェイプ(の類）には、TextBox というものがありますから、そのどれを指しているのか、もう少し正確におっしゃっていただかないと、どういうものは、少なくとも、私などには分かりません。 もしかしたら、ご質問の文面だけで、解答が分かる方もいらっしゃるかとは思いますから、私の書いていることは、無視して一向に構いません。 通常は、標準モジュールで変数を入れてから、グローバル変数(とそう呼ばれている、単にPublic キーワードつけたモジュール変数）を付けて、値だけを、個別のオブジェクトモジュールの橋渡しにさせます。 >FormでTextBox（仮にAAとします） オフジェクトそのものを変数に入れるという書き方をする人が、最近いますが、Class で、インスタンスにするならともかく、そのオブジェクトそのものを格納する必要はないと思います。テキストボックスでは、Text値(String型）を渡せば十分だと思います。 しかし、こうした言葉でいくら説明しても、もしかしたら理解できないのではないかと思います。VBAの質問で問題がある部分のコードを、明示していただいたほうが、答えは早く見いだせるような気がします。
貼り付け先のSheet状況によって方法は変わります。 ①どちらも、表のみのSheetなら、Sheetのコピー シート見出しで右クリックし、「移動またはコピー」→「コピーを作成する」にチェックし、挿入先を指定。 既存のシートに貼り付けなら、Ctrl+Aでシート全体をコピー。 貼り付け先のシートで、やはり、Ctrl+Aでシート全体を選択して貼り付け。 ②シート内の表のみ範囲選択しての貼り付け。 別シートに形式を選択して貼り付け→列幅→ＯＫ→そのまま続けて、右クリックから「貼り付け」 行の高さも同じにするには、対象となる表の行番号を範囲選択してコピー。 貼り付け先の行番号を範囲選択して、形式を選択して貼り付け→「書式」にチェックしてＯＫ。 ③コピーした表と貼り付け先のセル幅や行の高さが違うものに、コピー元と同じ幅や高さで貼り付けたい場合。 元の表をコピーし、貼り付け先で、Shiftを押しながら、編集→図の貼り付け。 貼りついた図の書式設定を開いて、色と線タブで「塗りつぶしの色」を「自動」にする。 以上、用途に応じ使い分けてください。
VBAでないと駄目なのでしょうか？ コピーしたものをクリップボードから貼り付けるなら、数式バーでも セル内でも可能ですよね。そこでクリップボード拡張ソフトを使って マウス操作で可能なものもあるのではないでしょうか？ 例えば【 Clibor 】の[定型文]に記号を登録して、キャレット位置へと 自動貼り付けするように設定すれば、ワンクリックで可能です。 http://www.vector.co.jp/magazine/softnews/090520 … 他にも【 ToMoClip 】も同じようなことが可能なソフトです。 http://www.vector.co.jp/magazine/softnews/020710 … マクロの勉強にはなりませんが、エクセル操作上のメリットとして、 記号挿入を求めるなら検討しても良いかと思います。 テンキーとマウスだけで作業するようなときに便利だと思いますよ。
\かバックスラッシュか、どちらか一方が入力可能です。人間への表示方法がどちらが登録されているかだけの違いで、パソコンにとっては同一コードです。
Sheet1のシートモジュール一例です。（これをボタンに登録します） 日付は31日分でAG1まで入っているとしています。 Sub Sample() Dim sh As Worksheet Dim wr As Range Dim i As Long, j As Long Application.ScreenUpdating = False Set sh = Worksheets("Sheet2") Set wr = sh.Range("A2:A" & sh.Cells(Rows.Count, 1).End(xlUp).Row) i = Application.Match(Range("B3").Value, wr, 0) Set wr = sh.Range("C1:AG1") j = Application.Match(Range("B2"), wr, 0) sh.Cells(i + 1, j + 2).Value = "○" Application.ScreenUpdating = True End Sub
No1です。 入力セルがいまいちはっきりしませんが、日付に「大会」「公欠インフル」・・・と「データ入力規則-リスト」などで入力するものと仮定します。 「週ごと」はそれぞれの個数をカウントする式をいれておきます。（Countif関数） 累計＝先週まで+週ごと 火～日の分の日付は週の最初C$3+1、C$3+2、・・・　月曜日の日付を入れれば残り7日は自動で入る。 マクロは Sub 更新() Range("X4:AD25").Value = Range("Q4:W25").Value　'「先週までの累計」に「累計」数値を入れる Range("C4:I18").ClearContents　'C4:I18をクリアする Range("C3").Value = Range("C3").Value + 7　'週の最初の日付を7日進める End Sub 以前のVBA標準モジュールのやり方でいいと思います。 マクロは1回実行するごとに7日進みます。 なお、マクロを実行するため「テキストボックス」「ワードアート」などにマクロを登録したほうが楽です。 これからGW休みで旅行です。
No2です。訂正です。 修正前 Workbooks(S).Worksheets(T).Cells(Rows.Count, "U").End(xlUp).Offset(1).PasteSpecial _ 修正後 Workbooks(S).Worksheets(T).Cells(rw, "U").PasteSpecial _ ① おそらくテスト用に新しいブックを立ち上げてマクロ起動したのかと思いますが、一度保存してから再度試して下さい。 ② おそらくバックスラッシュ（/の反対向き）は入力可能なのではないですか？\の代わりにそれで試して下さい。
こんばんは！ 一案です。 具体的な配置が判らないので、↓のような感じになっているとします。 Sheet1のG3セルに =IF(COUNTIF(A:B,Sheet2!A2),"",Sheet2!A2) H3セルに =IF(COUNTIF(D:E,Sheet2!B2),"",Sheet2!B2) という数式を入れそれぞれの列をSheet2のデータ数分だけの行数下へフィル＆コピーすると 画像のような感じになります。 これでなんとかお望みどおりにならないでしょうか？m(_ _)m
12で折り返すということは「1月,2月…11月12月」の「ユーザー設定リスト」が有効（優先）になっているのかもしれない。 まずは「ユーザー設定リスト」から、追加した「1,2,3…48,49,50」のリストを削除しよう。 そんなものいらないだろ。 必要なら１から50まで連続して入力し、その1～50の範囲のセルを選択して、フィルでコピーすればよい。 そうすると、1～50の値を繰り返してコピーできる。
文章での説明は分かり難いので図を参考に見てください。 作業列(下図の例では、E～H列)を設定して計算すれば時間計算にも使えます。 参考にI列で時間計算しています。 作業列が邪魔なら、非表示にしてください。
こんにちは！ 一例です。 各シートともシート名はカタカナの「シート」と半角の数値になっているとします。 （シート1・シート2・シート3・・・といった具合に） 「シート101」のA1セル以降に表示させるとすると A1セルに =INDIRECT("シート"&ROW(A1)&"!A1") という数式を入れフィルハンドルで下へコピーしてみてください。m(_ _)m
こういうことでしょうか？ =SUMPRODUCT((G4=$G$4:$G$11)+(G4=$I$4:$I$11)+(I4=$G$4:$G$11)+(I4=$I$4:$I$11))=2 OR使うと上記の真偽逆になりますが =OR(COUNTIF(G:G,G4)<>1,COUNTIF(I:I,I4)<>1,COUNTIF(G:G,I4)<>0,COUNTIF(I:I,G4)<>0) ということでしょうか？
まず「○○.txt」で保存しておいて エクセルで開くときに 「ファイルの種類(T)」を「テキスト ファイル(*.prm;*.txt;*.csv)」にし「○○.txt」を選択します。 「カンマや…データ(D)」を選び「次へ(N)」を押します。 区切り文字は「スペース(S)」にチェック入れ、他は外します。 「連続した…扱う(R)」にチェックが入った状態で「次へ(N)」を押します。 全部の列を「文字列(T)」にして「完了(F)」を押します。
こんにちは！ Sheet1にはSheet2のデータの下にSheet3のデータを羅列して表示するとします。 前提条件として、 ①　Sheet2・Sheet3とも1行目は項目行でデータは2行目以降にある。 ②　途中に空白行は存在しない。 とします。 ↓の画像でSheet1のA2セルに =IF(COUNTA(Sheet2!$A:$A,Sheet3!$A:$A)-2<ROW(A1),"",IF(COUNTA(Sheet2!$A:$A)-1>=ROW(A1),Sheet2!A2,OFFSET(Sheet3!A$2,ROW(A1)-COUNTA(Sheet2!$A:$A),,1))) という数式を入れ列・行方向にフィルハンドルでコピー！ これで画像のような感じになります。m(_ _)m
こんにちは！ 画像の配置でSheet2のB1セルが変動する（表示したい日付をB1セルに入力）とします。 Sheet2のA1セル項目の「氏名」は入力済みだとして、A2セルに =IFERROR(INDEX(Sheet1!$A$2:$AE$100,SMALL(IF(OFFSET(Sheet1!$A$2:$A$100,,MATCH($B$1,Sheet1!$1:$1,0)-1)>0,ROW($A$2:$A$100)-1),ROW(A1)),MATCH(A$1,Sheet1!$1:$1,0)),"") 配列数式になりますのでCtrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　A2セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 最後にA2セルのフィルハンドルで列・行方向にコピーしてみてください。 おそらくお望み通りになると思います。 ※　列範囲はとりあえず1か月分（31日まで）としています。m(_ _)m
SUMPRODUCT関数やCOUNTIF関数をどのようにしたのだろうか。 条件さえしっかり指定すれば、普通にカウント可能だ。 どのように条件を指定したのかを示してください。 何が原因で間違えているのか、何が不足しているのかを指摘したりアドバイスをすることができます。 ・・・が、 とりあえず、SUMPRODUCT関数を使った場合の考え方の解説をしてみます。 （このまま使用できるわけではないので、理解したうえで工夫をしてください） SUMPRODUCT関数は、指定した配列同士で掛け算をして、その合計を求める関数だ。 （面倒なので配列は2つで説明） ＝SUMPRODUCT(A1:A3,B1:B3) は、 ＝A1*B1 + A2*B2 + A3*B3 と等しい。 条件を設定して数をカウントさせる場合は、 ＝(A1="-A")*(B1="1月")+(A2="-A")*(B2="1月")+(A3="-A")*(B3="1月") のようにすればよいので、 ＝SUMPRODUCT((A1:A3="-A"),(B1:B3="1月")) とすればよいのだが、【配列の結果】がこのままでは"TRUE"と"FALSE"のままで、SUMPRODUCT関数内部計算は必ず0になるため、 カンマ（,）で配列を区切るのではなくアスタリスク（*）で直接「積」を求めるようにする。 （SUMPRODUCT関数は数値以外はすべて0として扱うことを考慮する必要がある） すると ＝SUMPRODUCT((A1:A3="-A")*(B1:B3="1月")) こうなる。 "TRUE"と"FALSE"をそれぞれ「1」「0」と扱うために ＝SUMPRODUCT((A1:A3="-A")*1,(B1:B3="1月")*1) としてもよい。 あとは、この「"-A"」「"1月"」の部分に適合するように配列部分の「A1:A3」や「B1:B3」をRIGHT関数やTEXT関数などで置き換えるだけだ。 例： 　RIGHT(A1:A3,2) 　TEXT(B1:B3,"m月") 自分なら COUNTIF関数ではなく、 COUNTIFS関数を使うが...。 （COUNTIFS関数はExcel2007から追加された関数です） COUNTIF関数を配列数式にすることでもできるがお勧めしない。
多分に１行目には、項目名がありますよね。 A列は日付なので 縦横に検索して合致したセルの値を Vlookup関数とMatch関数の組み合わせで表示させては 例えば、Sheet2の1行目に、希望する商品名を入れておいて Sheet２のB2セルに =VLOOKUP($A2,Sheet1!$A:$F,MATCH(B$1,Sheet1!$1:$1,FALSE),FALSE） と入れて右へコピー、下へコピーしてみてください。
作られた「Exce」lの状態を見ませんと、判断ができませんが、 次の２つの方法がありそうです。 現状を保存してから試してください。 ＜＜A＞＞「印刷の範囲」の変更を行います。 1)EXCEL作成時に「印刷の範囲」を設定しましたか？ 2)「印刷範囲のクリア」をクリックします。 3)最終罫線の行を含めて「印刷範囲の設定」をクリックします。 4)印刷のプレビューにて印刷の状態を確認します。 または、 ＜＜Ｂ＞＞「行の高さ」の数値を減らします。 1)左端の部分(行を示す数値)をドラッグ操作します。 2)マウスの右ボタンをクリックします。 3)ドロップダウンメニューが表示されます。 4)メニュー内の「行の高さ」をクリックします。 5)数値が表示されますので、適当な数値(例：－0.5位？) 　を減らします。 6)「OK」をクリックします。 7)行の高さが全行低くなります。 8)罫線が頁内に入りませんか？ 9)入らない場合は、1)からの作業を繰り返します。
Excel 2013 RTを使っていませんか？ http://www.relief.jp/itnote/archives/surface-rt- … Office 2013 RT のアプリケーションでは VBA を使えません。 ですから、不要な部分が非表示になっています。 http://www.relief.jp/itnote/archives/surface-rt- …
D2セルに　５　が表示されているとして E2セルに　式　=VALUE(TEXT(D2,"[m]")) を入力すれば(純粋な?)数値の５に変換出来ます。 また、式を　　　 　=(TEXT(D2,"[m]") にすれば(純粋な?)テキスト文字に変換されます。 なお作業列を挿入しないなら、上式中の　D2 を　C2-B2 に置き換えて　D2セルに入力します。 ハズレならごめんなさい。
書き方が悪かったですね。ごめんなさい。 フリーソフトなどのアドインです。 ベクターのこの辺にあるかもしれません。 http://www.vector.co.jp/vpack/filearea/winnt/bus …
こんなのでは？ ・今日から30日を切っているセル色を赤にする　=MIN(B2:D2)-30<TODAY() ・今日から60日を切っているセル色をピンクにする　=MIN(B2:D2)-60<TODAY() ・今日から90日を切っているセル色を黄緑にする　=MIN(B2:D2)-90<TODAY()
検索ワードの含まれている順番が判っていれば、 検索ワード①*検索ワード②*検索ワード③ のように「*」でつなげば出来ます。
もう少し細かく説明すると、HDDの場合「C:」や「J:」などのルートフォルダーはセキュリティなどの理由でソフトから変更できないようになっています。ソフトから変更をする場合は必ずフォルダーを作成してそこに保存して下さい。正確にはシステム設定されているドライブなので、HDDのパーティションを２つに分けた場合は２つ目のドライブは変更できます。もちろんUSBなどはシステム設定されませんのでルートフォルダーも変更できます。
こんにちは。 >「中断モードでコードを実行することはできません。」 久々、勉強させていただきました。 片方のマクロが何らかの原因で、マクロが止まった状態で、別のマクロを動かそうとした時に出るエラーです。止まっている状態のマクロを終わらせてあげれば動きます。 ご質問の答えとしては、 「中断モードでコードを実行することはできません。」 の対処法は VBEditor 画面で -------------- ▶　|| □ ----------- を見ていただくと、▶のところが明るくになっていて、|| が押せないようになっていますから、■　を押していただければ、マクロは止まります。 内容を修正します。 Sub Macro1() 　　　　　　　　　'修正部分 Dim i, As long　　'Dim i As long, j as Long 　　　　　　　　　　'Dim myString As String 　　　　　　　　　　j =1 Range ("A5")　　　'Range("A5").Select For i = 5 To 14 myString = Cells(i, j) myString = UCase(myString) '大文字　　本来は以下の1行で足りる Cells(i, j) = myString　　　　'Cells(i,j) = UCase(Cells(i, j)) Next i End Sub ------------------ というような感じにはなりますが、入門レベルでは、変数の宣言はあまり厳密にしなくてもよいと思います。最初は、Dim i, j, myString と型を入れません。 もし型を入れる場合は、整数型なら、Long, 文字型なら、String, オブジェクト型は、Object, ワークシートの数字の場合は、Double と決めてしまってもよいです。Sheet, Workbook という型も使うことも増えてくるかもしれません。 Excelは、64bit 時代に入っても、未だ32bit が主流ですが、変数の型は、それだけに、ややこしいかもしれません。 また、VBA関数は、VBAの入門編としては、3部のある内の2部に入るはずです。VBAには、文字列関数が多いようです。なかなか覚えきれないというのが正直なところです。だから、後回しになることも多いものです。なれない内は、一覧表で確認したほうがよいかもしれません。 リンク先の質問は、ちょっと趣旨が違うかもしれません。そちらの質問者さんの求めている答えには正解は出ていないようです。ベストアンサーではあっても、答えのコードではないと思います。
B車の場合はC9セルに以下の式でどうですか？ =MAX(C1:C8)-MIN(C1:C8)
もしかして複数のセルに表示するのでしょうか？ その場合のルールは？ 画像の貼り付け[Alt]+[PrintScreen]画面のハードコピーの活用はできないでしょうか？ =IF(SUMPRODUCT(COUNTIF(Sheet2!A1:B24,Sheet1!D1:D16)),"一致","") の考えは間違っているのでしょうか？
削除する範囲が決まっているなら、その範囲に名前をつけて、その範囲名で処理をしてはどうか。 そのほうがスマートな気がする。 マクロを使わなくても範囲名を指定することでDELキー一発で消せたりするし…。 ロックしたセルは保護対象なので、シートを保護すると削除やセルの変更はできなかった気がするんですけど。 マクロを使うときって関係なかったっけ？
どれが図２か図３かわからないので・・・ とりあえずOfficeのパッチレベルは最新になっていますか?
先ほど書いた物に当てはまらないのならば、とりあえず名前を４文字としてわけてしまって、住所でソートして違っているところを修正する。 日本人の名前が４文字の時が多いので割と手間が掛らないかもしれません。
一案です。C2セルに =IF(AND(B2="○",E2="C"),"×","")
ごめんなさい =IF(O2=100,"",IF(ISERR(FIND("Z",J2,1)),"","x")) でしたね
符号をつけることによって 計算できる文字(数字)が数値になります。 ただ、負の符号なのでもう一度、マイナス１を掛けることで元に戻します =1*TEXT(A1,"0.00E-0") とか =0+TEXT(A1,"0.00E-0") でもOK
EXCEL2007以上なら 左からA列、B列・・・・として、２行目から並んでいる、として。 =SUMIFS(A2:A○,B2:B○,"4",D2:D○,"<>""""",F2:F○,"現金")
フィルタがかかっているような気がします。 すべて選択にチェックをしても変化ありませんか？ https://support.office.com/ja-jp/article/%E3%83% …
VBAになってしまいますが、こんな感じでどうでしょう？ Sub sample() Dim ws As Worksheet Dim I As Long Dim J As Long I = 1 For Each ws In ThisWorkbook.Sheets If Not ws Is ActiveSheet Then For J = 2 To ws.Cells(Rows.Count, "A").End(xlUp).Row I = I + 1 Cells(I, "A") = ws.Cells(J, "A") Cells(I, "B") = ws.Cells(J, "B") Next J End If Next End Sub
何度もごめんなさい。 お遊びのコードは↓の方が判りやすいと思います。 Sub Acobi2() Dim i As Long For i = 1 To Selection.Count Selection(i) = i Next i End Sub どうも失礼しました。m(_ _)m
こんにちは。 >イントラサイトでやろうとしたらセキュリティがうんぬんかんぬん言われてしまい、一階で断念してしまいました…汗 それは、確かにその通りです。たかが、ここの『教えて！goo』でさえも、ログイン後の状態をVBAで取るのは容易ではありませんからね。 イントラネットも同様で、入るためにはお約束事があるということだと思います。私の考え方は、イントラサイトに入り込む事自体は、手動でも別の方法でも、VBAではしないわけです。 もちろん、以下のような方法がサマになっていると思います。 『EXCEL VBAからイントラネットにログイン』 http://oshiete.goo.ne.jp/qa/4761456.html でも、例えば、ここのサイトでも、入ってから、VBAで、Window　を切り取ってから、操作するということは可能なのですね。 それを最初からVBAで操作しようとすると、本当に大変な手間が掛かってしまうのです。インターネットでも、セキュリティ云々で、入れない所も時々ありますが、それを横取りすればできると思うのです。完璧にできるかどうかは約束はできませんが。 そのやり方は、いずれ、ご質問があった時にでもとは思いますが、可能だと思っています。 一応、キーワードだけ残しておきます。 Set objShellWin = CreateObject("Shell.Application").Windows() これで出てくるはずです。Window 切り取りして、その中身に何が入っているか、調べるわけです。 しかし、まるっきり話が違うことかもしれませんから、その時はご容赦願います。
No.1です。 やりたい事はだいたい理解できました。 補足の最後に書いていらっしゃるように、この場合はSheet1は不要だと思います。 マクロがわかるのであれば日付、番号、評価を入力して他のシートに文言でデータを蓄積していくことは可能ですが、マクロがおわかりか不明なので、ますマクロでない方法を書きます。 図のA1～B4に（位置はここでなくても可）番号と対応する評価文言を入力しておきます。 案1（4月1日） 1日に2列用意して、左の列（F列）に数値だけ入れる。 G3に =IFERROR(VLOOKUP(F3,$A$1:$B$4,2,FALSE),"") という式を入れておくと、数字入力と同時に文言が表示されます。 案2（4月2日） 入力規則を使って、直接4つの文言から選択させる。 入力に数字を使いたい（テンキー）なら案1ですが、マウスでいいのなら案2がお勧めです。
マクロならば以下のような感じです。 Private Sub Worksheet_Calculate() If Range("B1").Value = "" Then Range("B1").Value = Range("A1").Value End Sub 対象が複数の場合は「If … Value」の部分を、対象数増やして下さい。
さらに、エラー処理の応用編とか =IF(SUM(COUNTIF(B4:J4,{"会長";"立会"})), LOOKUP(1,0/((B4:J4="会長")+(B4:J4="立会")),$B$3:$J$3),"なし") ここまでしなくても、XL2007以降なら =IFERROR(LOOKUP(1,0/((B4:J4="会長")+(B4:J4="立会")),$B$3:$J$3),"なし") で。
J7セルに =AVERAGE(C7:I7) と入れておけば、自動で空白のセルは無視して 平均を計算してくれると思いますが 試されたのでしょうか。
データが例のように並んでいる前提での一例です。 Sub Sample() Dim rr As Long Application.ScreenUpdating = False For rr = 2 To Cells(Rows.Count, 1).End(xlUp).Row If InStr(Range("B" & rr).Value, "aaaa") > 0 Then If Range("C" & rr).Value <> Range("C" & rr + 1) Then Range("E" & rr).Value = "確認" Range("E" & rr + 1).Value = "確認" ElseIf Range("D" & rr + 1).Value >= DateSerial(2016, 5, 1) Then Range("E" & rr).Value = 0 Range("E" & rr + 1).Value = 0 Else Range("E" & rr).Value = 1 Range("E" & rr + 1).Value = 1 End If End If Next rr Application.ScreenUpdating = True End Sub
オブジェクトブラウザで調べます。 VBE の画面で、「表示」→「オブジェクトブラウザ」 <すべてのライブラリ> で検索してください。 --------------------------------------------- Const msoArrowheadOval = 6 Office.MsoArrowheadStyle のメンバー --------------------------------------------- と下の方に結果が表示されます。 定数の値を知りたいだけなら イミディエイトウィンドウで 　? xlAutomatic のようにしても調べられます。
こんにちは！ Sheet2のE・F列データはSheet1からコピー＆ペーストするのですね？ B1セルに =SUMIF(E:E,A1,F:F) として下へフィルハンドルでコピーしたらどうなりますか？ ※　エラー処理はしていません。m(_ _)m
過去ログの方法もありますが、私なら一度Wordに貼り付けますね。 https://oshiete.goo.ne.jp/qa/6537469.html Wordの機能に、[文字列を表にする]があります。 http://www.wanichan.com/pc/word/2010/04/02.html http://azby.fmworld.net/usage/windows_tips/20081 … http://www.eurus.dti.ne.jp/~yoneyama/Word/w-hyou … インターネットからお店情報の一覧をコピペします。 このときの貼り付けは[テキスト]で貼り付けると作業がしやすいです。 [文字列を表にする]で[文字列の区切り]を[段落]にします。 これで、[列数]と[行数]を指定しやすくなります。 [OK]で[列数]を6列などにしたものをExcelへと貼り付けすれば、罫線 などもついたままで作業できると思います。
No.1です。 新しい方の質問にも回答しましたが、 AVERAGE　関数を使うだけで解決だと思います。
》 編集画面では…実際紙印刷でも表れます。 そうなるのは、私の場合は[ページ設定]メニューで“白黒印刷”に設定している場合だけです。例え、カラープリンタを使用していても。 》 他に何が違うんでしょうか 全く分からないので、此処でサヨナラです。 【蛇足】「白黒印刷にもあえてしていません」を最初に明記してあれば、私が出しゃばることもなかった！
こんばんは！ 画像の配置だと B2セル以降の色付けしたいセルを範囲指定　→　条件付き書式　→　新しいルール　→　数式を使用して・・・　→　数式欄に =B$1=$A2 という数式を入れ　→　書式　→　塗りつぶしから好みの色を選択しOK これで大丈夫だと思います。m(_ _)m
＞請求額を入力すると差引金額と金額に応じて振込手数料を自動的に入れられる 差引金額はどうやって決まるの？？ 金額はどこにあるの？ と云っても仕方がないので 一万円以下は表示　=IF(金額のセル>10000,振込手数料,””） 1万円以下は空白 3万円以下は　540 3万円以上は　756 =IF(金額のセル<10000,"",IF(金額のセル<30000,540,756)) で考えてみてください。
Dim x As Long, i As Long 　With ActiveSheet 　x = .Cells(Rows.Count, "L").End(xlUp).Row 　For i = x To 7 Step -1 　 　If .Cells(i, "L") = "" _ 　 　 　And .Cells(i - 1, "L") = "" _ 　 　 　And .Cells(i - 2, "L") = "" Then 　 　 　.Cells(i, "L").EntireRow.Delete Shift:=xlUp 　 　End If 　Next i 　End With 人のふんどしで相撲を取るってやつなんでもっとうまい方法があるかと思いますが 空白を2行にするくらいだったら、もう1個and付ければいいかと。 つまり、3行連続で空白なら1行消す
ですと、ファイルが壊れているのでは？ 空白の新しいシートを作成し全コピーしてもダメですか？ (シートをまたぐ計算式が入っていると厄介ですけど)
一応。「計算式による空白以外」とありますが数式で「空白」は作れません。 空白文字列のことをおっしゃっているのなら 条件は少し変わります。 SUMIFS関数は変換できるものは文字列のままでは計算しませんから論外です。 =SUMPRODUCT(ISNUMBER(-B1:B4)*(B1:B4="")*(C1:C4="●"),A1:A4) 例えば。
こんにちは！ 一例です。 Sub Sample1() Dim i As Long For i = 21 To Cells(Rows.Count, "A").End(xlUp).Row Step 20 Cells(i, "A").Resize(20).Cut Cells(1, Columns.Count).End(xlToLeft).Offset(, 1) Next i End Sub こんな感じではどうでしょうか？m(_ _)m
> Windows(”¥¥feps¥home 〈以下省略〉.xlsx”).Activate > としています エラー内容が書かれてないので超推測ですが… Activeにしようとしているワークシートが、フォルダ位置まで指定されていますが、その場所に目的のワークシートがないせいでエラーになるのでは？
>データを今回の表からコピペしたらダメでした。 例えば、科目のデータに　空白がとか何かが含まれているとかは？ 科目の一つをコピー Ｂ２セルに張り付けてみては如何？？
こんにちは！ ＞検索範囲は30ｘ30くらいと仮定して下さい。 Excel2007以降のバージョンをお使いだとして 表示したいセルに =COUNTIFS(A1:AD30,"a",A2:AD31,"@") としてみてください。 検索条件範囲を1行ずらします。m(_ _)m
ここは参考になりませんかね。 https://support.office.com/ja-jp/article/%E8%A1% …
＞CからGの範囲の中で黄色をつけていくことにより、Hの数が増えていくようにエクセルでできないでしょうか？ セルを塗りつぶして『自動的』に「色日数」が計算されるという方法はありません。 また塗りつぶしたセルを直接計算させるという式もありません。 方法は、塗りつぶしたセルに名前を定義し、COUNTIF関数で塗りつぶした色の数を数える、という手順を踏む事になりますが、最終的には再計算をさせてあげないと色の個数が更新されません。 その為には「Ctrl」＋「Alt」＋ファンクションキーの「F9」を押して再計算させるか、簡単なマクロを作りボタンをを配置し、押すことで再計算させる方法になります。 excelのバージョン2010でのアドバイスとなります。（添付画像参照して下さい） 添付画像より説明。 セルＤ100をクリック（邪魔にならないセルを選択して下さい）しておきアクティブ状態にしておきます。 「数式」タブより「定義された名前」グループ内の「名前の定義」をクリック 「新しい名前」画面の「名前」に「色」とか、お好きな名前を入力します。 最下段の「参照範囲」に入力されている式を削除して「　=GET.CELL(63,Sheet1!D3)　」と入力し「ＯＫ」を押します。（文字色の場合は=GET.CELL(24,Sheet1!D3)です。） 次にセルＤ100に関連付けされた式を日付の分までオートフィル機能でコピーします。 セルＤ100からAG 100までをオートフィル機能でコピーした状態のまま（解除しない）、下方向へ人数分オートフィルコピーします。 「6」の数値が出ると思いますが、これは黄色の色番号です。 次にセルAH3をクリックしておき「　=COUNTIF(D100:V100,6)　」の式を入力し、下方向人数分（添付画像ではセルAH11まで）オートフィルコピー機能で式をコピーします。 これで塗りつぶしたセルの色の個数は算出されますが、新たにセルに塗りつぶしをしても自動計算はされませんので、「Ctrl」＋「Alt」＋ファンクションキーの「F9」のショートカットキーを押して再計算させます。 尚「Ctrl」＋「Alt」＋ファンクションキーの「F9」のショートカットキーを忘れそうならマクロコードを登録してボタンを配置し、ボタンを押すことで再計算させるといいでしょう。 「Ctrl」＋「Alt」＋ファンクションキーの「F9」をマクロに登録。 「Alt」＋ファンクションキーの「F11」キーを押してマクロ画面を起動。 「挿入」タブから「標準モジュール」をクリック。 入力部分に以下のコードをコピーして貼り付けます。 Sub 再計算() Application.CalculateFull End Sub 標準モジュールにコードを貼り付けたら、excel側の画面をクリックし「挿入」タブより「図形」からお好きな図形を選択し、AJの列にでも置いといて、図形を右クリックし、メニューから「マクロの登録」をクリックして「再計算」と書かれているマクロ名をクリックして「OK」 選択状態の図形を解除するとマクロボタンが出来上がりますので、新たにセルを塗りつぶしした後、作ったボタンを押すたびに再計算されます。
たしか元の質問は、 C4セルからC15セルまでの中の、 数値や文字が入力されているセルを削除して、 数式が入力されているセルは削除対象外にしたい という質問だったような気がするのですが…。 指定したセルを問答無用で削除するのであれば、 記録マクロで「範囲を決めて削除」の操作をマクロ化すれば良いですよ。
C1セル 空白 C2セルに =IF(A2=A1,C1&"、"&B2,B2) フィルハンドルダブルクリック D1セル 0 D2セル =SUM(A2<>A1,D1) フィルハンドルダブルクリック F2セル =IF(MAX(D:D)<ROW(F1),"",ROW(F1)) 下へオートフィル G2セル =IF($F2="","",INDEX(A:A,MATCH($F2,$D:$D))) 下へオートフィル H2セル =IF($F2="","",INDEX(C:C,MATCH($F2,$D:$D))) 下へオートフィル F:H列を切り取って別シートへ貼り付け
No.1です。 ＞なぜでしょう？いただいたコードを貼り付けたのですが全く反応しません…！！ コード自体は問題ないはずですが、考えられるコトといえば・・・ A列にはデータが入っていますか？ A列で最終行を取得していますので、A列にデータがない場合は反応しないと思います。 （お示しのコードがA列で最終行を取得しているようなので、敢えてそのようなコードにしています。） B列で最終行を取得する場合は ＞For i = Cells(Rows.Count, "A").End(xlUp).Row To 4 Step -1 を ＞For i = Cells(Rows.Count, "B").End(xlUp).Row To 4 Step -1 としてみてください。m(_ _)m
No.2です。 ＞条件が3つの場合はどうしたらよいでしょうか？ というコトは「日付」が条件に加わるのですかね？ 前回の配置通りとして、Sheet2のA2・B1・B2セルの検索条件が変化するとします。 Sheet2のA5セルに =IFERROR(INDEX(Sheet1!$A$1:$D$1000,SMALL(IF((Sheet1!$D$1:$D$1000=$A$2)*(OFFSET(Sheet1!$A$1:$A$1000,,MATCH($B$1,Sheet1!$1:$1,0)-1)=$B$2),ROW($A$1:$A$1000)),ROW(A1)),MATCH(A$4,Sheet1!$1:$1,0)),"") 前回同様配列数式ですので、Ctrl＋Shift＋Enterで確定し、列・行方向にフィル＆コピーしてみてください。 これでA2・B1・B2セルの変更があるたびに データ表示が変わると思います。m(_ _)m
こんばんは！ ＞ボタンを押すと・・・ Sheet上にコマンドボタンを配置するとします。 C4～C15セル限定でよいのですね？ Private Sub CommandButton1_Click() On Error Resume Next '←念のため Range("C4:C15").SpecialCells(xlCellTypeConstants).ClearContents End Sub くらいでOKだと思います。 数式はそのままで実データのみ消去されるはずです。m(_ _)m
思い切って、VBA案です。 それもフィルターオプションの機能を使っています。 シート名　データ 　A　　B　　　C　　　D　　E 番号　商品名　金額　個数　合計 ・・・ 別シート 　A　　B　　　C　　　D　　E 　　　商品名 　　　りんご 番号　商品名　金額　個数　合計　　 と準備します。 別シートのシート名を右クリックしてVBエディターを起動 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$B$2" Then Sheets("データ").Columns("A:E").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("B1:B2"), CopyToRange:=Range("A3:E3"), Unique:=False End If End Sub をコピー、エディターを閉じる B2セルの　りんご、みかんなど商品名を入力して変更することで ご希望のデータが抽出されます。 詳しくは、フィルターオプションで検索してみてください。
コメントの通りB列のインシデントレベルをD列に表示させたいということで大丈夫ですよね？ Sub 字下げレベルの表示() 'B列3行から250行目までの文字のインデントレベルをD列に表示させる Dim i As Integer For i = 3 To 250 'B列のインシデントレベルを取得し、D列に代入 Range("D"& i).Value = Range("B"& i).IndentLevel Next End Sub 参考程度に。
=OFFSET(A$1,(ROW(A1)-1)/8,MOD(ROW(A1)-1,8))
＞③やりたい事は毎月末にて売れた個数の入力 は紙ベースでしょうか？ エクセルデータではもらえないものでしょうか？ データをエクセルでもらって シート上にマクロボタンを配置して 指定したセルに取り込むマクロを作成します。 ボタンのクリックだけの作業になりますし 入力ミスもなくなります。
[Alt]押しつつ[D]→[O] フォーム で入力用のフォームが出てきます
LOOKUP系の関数を使えば可能 但し、そのベースとなる情報のキー項目(上の例なら、牛乳、林檎、卵)が、正しく昇順ソートされているという前提条件が付くけど まぁ普通は、名称だと紛らわしいから商品コードの様なモノを使うけどね
インデントの情報を取得するような関数は用意されていないようなので、VBAになってしまいます。 下記のサンプルは、B列に対してインデントレベルを判定し、インデントが設定されている場合、その左隣セル（A列）に転記した後、元セル（B列）をクリアしています。 Sub sample() Dim r As Range For Each r In Range("B1:B" & Cells(Rows.Count, "B").End(xlUp).Row) If r.IndentLevel <> 0 Then r.Offset(0, -1) = r.Value r.Clear End If Next End Sub
簡単な順番で ４、シート上にボタンを配置して Sub ボタン2_Click() UserForm1.Show End Sub 　でフォームを開く ３、ユーザーフォーム上にボタンを配置して Private Sub CommandButton1_Click() Unload Me End Sub ２、ユーザーフォーム上に更にボタンを配置 Private Sub CommandButton2_Click() Textbox1.Value=Sheets("シート名").Range("セルのアドレス").Value End Sub １、ユーザーフォーム上に更にボタンを配置 Private Sub CommandButton3_Click() Sheets("シート名").Range("セルのアドレス").Value=Txetbox1.Value End Sub
No.2です。 > MsOfficeがつくものがたくさんあって。。 スイート製品名があればそれ、 一品ごとインストールであればexcelです。 > また共有の設定をしていますが、誰もひらいていなくてもその現象はおきます。 ⇒修復後でも発生するのであれば、知識の範囲外です。スミマセン。 逃げの対策では、 そのファイルを開いて、新規EXCELにコピーして別名で保存してみてください。
回答になるかはわかりませんが 前提条件として １．シート１とシート２は同じカレンダー状の表が記載されている ２．塗りつぶしに関してはこだわりがなければ「■」を表示する これで良ければ簡単にできます シート２のＡ１セルに=if(sheet1!A1="","","■")と記載し あとはシート２の必要な場所すべて（表内）にＡ１をコピーしてください 前者の方々の仰るように条件付書式がお勧めですが 設定を間違うと大惨事になりますので(笑) ■ → 記号の「四角」（しかくと入力し変換で出てきます）
Application.Captionプロパティでは、いかがでしょうか？
絶対座標、相対座標、ソート（並び替え）。 この説明がチンプンカンプンだとすると、 「入力操作くらいで、実質Excelが解らない」って感じかと。 ＞なにか簡単で良いのでお作り頂けないでしょうか 　無理ですよ。 　ただ、ネット上に色々と無料のフォームがあるから検索されてはどう。
ＮＯ．３、５の方と同意見です ピボットテーブルを使う方法が簡潔でしょう 注意点ですがデータが増減することが想定されるなら データ選択領域を過分に取っておきましょう 例えば表のとおりなら選択エリアは「Ａ１：Ｄ１０００」 といったように入力数の上限を想定して選択し 別シートにピボットテーブルを貼り付けます 右下にガイド画面が表示されると思いますので 下部四分割の左上条件に空白を表示しない設定を 付け加えてください データシートに入力等の変更があった際には ピボットテーブルシートの表の上で右クリック データの更新を押すと最新の情報に更新されます
こんばんは！ VBAになりますが一例です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）データを入力してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) 'この行から// Dim j As Long With Target If .Count = 1 Then j = .Column Columns(j).AutoFit End If End With End Sub 'この行まで// こんな感じではどうでしょうか？m(_ _)m
こんにちは。 図形は自由な位置に描画できますが、その位置に合わせて文字を表示したいということだと推察しました。 セルの文字を記述することで実現なさろうとしているようですが、位置合わせに無理がありませんか？ 例えばその位置がたまたま、大きなサイズのセルだったりすると誤差が大きすぎないでしょうか？ 位置を自由に指定して文字を描きたければ、図形と同じようにテキストボックスを利用して、Shapes.AddTextbox で描いた方が良さそうに思います。 とは言うものの、ご質問は「セル」位置を割り出す方法なので・・・ セル幅や高さが全て一定であると仮定して良いのであれば、指定位置（Ｘ）÷セル幅で整数部分+1が該当セルの（横）位置、少数以下が誤差の部分となりますよね？ 高さも同様に算出が可能です。一番近いところを選ぶのなら、四捨五入的な処理をすれば宜しいかと。 少数以下部分に対して、細かな調整をするのであれば、セルのインデントを指定したりということになりそうですね。 セル幅や高さが一定ではない場合は、シート内の各セルのサイズを調べてゆくことになります。 例えば、横方向であれば、指定の値に対して、Ａ列から順にセルの幅を引いて行って、最初に負数になった列が該当列ということになりますよね？ 高さ方向も同様ですし、端数の意味するところも前記と同様になります。 くどいようですが、個人的なお勧めはテキストボックスの利用ですね。
vlookupのみで行うんやったら「商品コード識別する列」をまず追加！ そんでもってその列に「CONCATENATE関数」使こぉ〜て下記の関数を作るんや！ 6行目の場合：CONCATENATE(F6,P6) で、vlookup用のマスタを追加。 そこには「商品名＋通常列と金額列」「商品名＋夏季列と金額列」のマスタを作成 伝票金額欄にvlookupで「vlookup用のマスタ」を見るように設定する。 どうでっしゃろ？使えまっか？
エクセルのバージョンによって若干操作が異なるかも知れませんが・・・ 「挿入」-「図形」-「矢印付線」を利用して、オートシェイプの矢線（直線でも可）を引きます。 描いた図形を右クリックして、「図形の書式設定」-「線のスタイル」タブで 「始点（終点」の種類」からご希望のような三角形塗りつぶしの矢印を選択 「始点（終点）のサイズ」で矢印部分の大きさを選択 ・・・で、ほぼご希望のものができると思います。 他にも、線の太さや色などいろいろと設定可能になっています。 以下の、図解が分かり易いかも http://www.becoolusers.com/office/arrow-style.html
自分も ・関数ならSUMIF関数。 ・機能ならピボットテーブル。 で行うことを勧める。 No.2で答えられている配列数式を使っても良いのですが、 配列数式の考え方が分からないと正しい結果を得られないので、 試行錯誤しても理解できないのであれば避けるべきと思います。 （悲しいことに配列数式で解決した質問ってほとんど無いんですよ。同じ人が同様な処理で済む問題を何度も質問する） ・・・ 別のシートを参照する時は =Sheet2!A1 のように シート名＋！＋セル番地 で参照できる。
こんな感じで、どうでしょう。 MyPathで指定したフォルダ内の .xlsx ファイルを対象に一覧化します。 一覧は、A列にファイル名、B列以降に各ブック中の”集約”シートのA2～T2が表示されます。 ただし、”集約”シートが無い場合は、ちょっとおかしな動作をします。おかしな動作については、お楽しみ！！（元のファイルが壊れることは無いので、安心して実行してみて下さい） Sub sample() Dim MyPath As String Dim MyFile As String Dim I As Long MyPath = "C:\教えてGoo\" MyFile = "*.xlsx" MyFile = Dir(MyPath & MyFile) Do While MyFile <> "" I = I + 1 Cells(I, "A") = MyFile Range(Cells(I, "B"), Cells(I, "U")).Formula = "='" & MyPath & "[" & MyFile & "]Sheet1'!A2" MyFile = Dir Loop End Sub
ついでにショートカットキーの Ctrlキーを押しながらFキーも覚えておくとよいでしょう
No.1です。 VBA向きの質問内容になりますね。 VBAの方法はすでに回答済みですので、あえて関数でやってみました。 ↓の画像のように元データSheetに作業用の列を2列設けます。 作業列1のH3セルに =IF(COUNTIF(B$3:B3,B3)=1,ROW(),"") 作業列2のI2セルに =IF(COUNTA(D3:G3),B3&INDEX(D$2:G$2,SUMPRODUCT((D3:G3<>"")*COLUMN(A1:D1))),"") という数式を入れ、H2・I2セルを範囲指定　→　I2セルのフィルハンドルで下へずぃ～～～！っとコピーしておきます。 そしてSheet2のA2セルに =IFERROR(INDEX(Sheet1!B:B,SMALL(Sheet1!$H:$H,ROW(A1))),"") という数式を入れ隣のB2セルまでフィル&コピー！ C2セルに =IFERROR(INDEX(Sheet1!$D:$G,MATCH($A2&C$1,Sheet1!$I:$I,0),MATCH(C$1,Sheet1!$D$2:$G$2,0)),"") という数式を入れF2セルまでフィル＆コピー！ A2～F2セルが選択されている状態でF2セルのフィルハンドルで下へコピー！ これで画像のような感じになります。m(_ _)m
》 見切れていますが、… 貴方が仰る「見切れています」とはどういう意味ですか？
こんばんは！ すでに回答は出ていますが・・・ No.1さんと同じように列で最終行を取得しています。 Sub Sample1() Dim i As Long, myRng As Range For i = 5 To Cells(Rows.Count, "J").End(xlUp).Row If WorksheetFunction.CountBlank(Cells(i, "J").Resize(2)) = 2 Then If myRng Is Nothing Then Set myRng = Cells(i, "J") Else Set myRng = Union(myRng, Cells(i, "J")) End If End If Next i If Not myRng Is Nothing Then myRng.EntireRow.Delete End If End Sub こんな感じではどうでしょうか？m(_ _)m
こんばんは！ VBAになりますが、一例です。 両シートとも配置はそのままで、Sheet1のセルを「赤」にする方法です。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて） マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim c As Range, myFound As Range, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") .Cells.Interior.ColorIndex = xlNone '一旦色を消去 For Each c In .UsedRange If IsNumeric(c) And Len(c) = 5 Then Set myFound = wS.Cells.Find(what:=c, LookIn:=xlValues, lookat:=xlWhole) If Not myFound Is Nothing Then c.Interior.ColorIndex = 3 '←「赤」 End If End If Next c End With End Sub 'この行まで// ※　データ変更があるたびにマクロを実行する必要があります。 ※　条件付き書式が設定してあると、条件付き書式が優先されますので 色の変化はありません。 条件付き書式をなしにしてマクロを実行してください。m(_ _)m
想像で作ってみました（別々のBOOKの場合です）。参考になれば幸いです。 下記のプログラムをMCブックの標準モジュールに張り付けて下さい。 sample1を実行するとMCブックにTABLEシートをコピーして、実績時間（Q列）をクリアし、さらにフィルタをかけます。 実績時間を入力後、sample2を実行するとTABLEブックの実績時間を更新します。 Option Explicit Const strTABLE As String = "C:\Users\教えてGoo\TABLE.xlsx" Const strSHEET As String = "TABLE" Const strKEY As String = "MC" Dim wsTemp As Worksheet Sub sample1() Set wsTemp = Workbooks.Add(strTABLE).Sheets(strSHEET) wsTemp.Copy Before:=ThisWorkbook.Sheets(1) wsTemp.Parent.Close (False) Set wsTemp = ActiveSheet wsTemp.Range("Q2:Q" & Rows.Count).ClearContents wsTemp.Range("A1").CurrentRegion.AutoFilter field:=6, Criteria1:=strKEY End Sub Sub sample2() Dim wsTABLE As Worksheet Dim LastRow As Long Dim I As Long Dim RowNo As Long On Error GoTo ErrorHandler LastRow = wsTemp.Cells(Rows.Count, "A").End(xlUp) On Error GoTo 0 Set wsTABLE = Workbooks.Open(strTABLE).Sheets(strSHEET) For I = 2 To LastRow If wsTemp.Cells(I, "Q") <> "" Then RowNo = wsTemp.Cells(I, "A") wsTABLE.Cells(RowNo, "Q") = wsTemp.Cells(I, "Q") End If Next I wsTABLE.Parent.Close (True) ErrorHandler: End Sub それから、上記サブプロシジャの実行タイミングですが、MCブックを開く時にsample1を。閉じる時にsample2を実行するのが簡単かと思います。こんな感じです。 Private Sub Workbook_BeforeClose(Cancel As Boolean) Call sample2 ThisWorkbook.Saved = True End Sub Private Sub Workbook_Open() Call sample1 End Sub
こんばんは！ ＞各シートに20テーブルほど存在する どのような配置で存在しているのか判りませんが、 ↓の画像のように連続しているものとします。 VBAになりますが一例です。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて） マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long Dim myArea1 As Range, myArea2 As Range Dim c As Range, r As Range, myFound1 As Range, myFound2 As Range Dim wS1 As Worksheet, wS2 As Worksheet Set wS1 = Worksheets("Sheet1") Set wS2 = Worksheets("Sheet2") wS1.Range("A:D").Interior.ColorIndex = xlNone wS2.Range("A:D").Interior.ColorIndex = xlNone For i = 1 To wS1.Cells(Rows.Count, "A").End(xlUp).Row Step 2 Set myArea1 = wS1.Cells(i, "A").Resize(2, 4) Set myArea2 = wS2.Cells(i, "A").Resize(2, 4) For Each c In myArea1 If c <> "" Then Set myFound1 = myArea2.Find(what:=c, LookIn:=xlValues, lookat:=xlWhole) If myFound1 Is Nothing Then c.Interior.ColorIndex = 3 '←赤 End If End If Next c For Each r In myArea2 If r <> "" Then Set myFound2 = myArea1.Find(what:=r, LookIn:=xlValues, lookat:=xlWhole) If myFound2 Is Nothing Then r.Interior.ColorIndex = 8 '←水色 End If End If Next r Next i End Sub 'この行まで// ※　「青」だと文字が見えにくいので「水色」にしています。 ※　配置が1行でも異なれば全く意図しない動きになります。 ※　関数でないのでデータ変更があるたびにマクロを実行する必要があります。m(_ _)m
No.1です。添付図の「4月」は間違ってますよね？ Excelの問題ではなく、数学？算数？グラフを考えるとよいと思います。 もちろん、質問の表の考え方も非常に良いと思います。 y=ax+b の直線が3つの(グラフ)エリアに分かれていて、境界において合計金額が同じ。 aは傾き,bは切片、変数xが売上です 0～10,000,000 a=2.5％、b=0 10,000,000～20,000,000　a=2％、b=50,000 20,000,000～上限なし　　 a=1.5%、b=150,000 上記を踏まえて、CHOOSEとMATCH関数でエリア別に合計を計算してみました =INT(CHOOSE(MATCH(S2,{0,10000000,20000000}),S2*2.5%,S2*2%+50000,S2*1.5%+150000)) 参考まで 税率45％なんてなってみたいもんだ https://www.nta.go.jp/taxanswer/shotoku/2260.htm
＞グラフ上で平均点ラインをだしたのですが、第２横軸の出し方が・・・？ 何に対しての平均点ラインを出したいのか分かりませんが・・・ とりあえず一例として簡単に作成して、ついでに画像も添付しておきます。 平均点ラインを第2軸で作成するためには、まず平均点を出す列を作り その列を含めたグラフを作成し、グラフ化、そして第2軸の作成を作るという 手順を踏んでいきます。 添付画像ではG列に「平均点」ラインを作成するため セルG2に　=AVERAGE($F$2:$F$6)　の式を入れ下方向へ式をオートフィルコピーします。 グラフを作成するエリアは赤く囲われた部分ですのでセルA1～A6までとF1～G6までを 範囲指定しておきグラフを作成します。（添付画像は折れ線グラフを使用） 作成されたグラフの平均点のグラフラインを右クリック後、データ系列の書式設定から「第2軸」にチェックを入れるとグラフ右側に第2軸の縦軸が入ります。
No.3です。 ＞ROW(A:A)の処理がよくわかりません。 とありますが、 これはINDEX関数で範囲指定した行数分だけを数式に入れます。 「TRUE」の行の行番号を取得するためです。 必ず1行目から指定します。相対参照にしてしまうとフィル＆コピーするたびに 行番号がずれてしまうため、絶対参照にする必要があります。 数式を入れるセルが何行目であっても必ず ＞ROW(A$1:A$1000) のように1行目からの指定です。 そうしないとINDEX関数で範囲指定した何行目を返すか？という意味の数式ですので 結果がずれるのを防ぐためです。 ※　文章で色々説明しても一気に理解できないかもしれませんが ご自身で試行錯誤してみてください。m(_ _)m
ひょっとして、M12には元々スペースとか式で””が返った後に値にした状態などになっていたのではないでしょうか？ ISERRORでなければエラー値が出る結果だったけど、式のおかげで””になっていたということでは？だからISERRORにしていたのでしょう。 そこに数値を入れて消したのでデータがクリアされて0が出るようになったのでは？ M12が空欄時に0にしたくなければIFをネストしてM12が空欄なら空欄にする式を足したら如何でしょうか？
アドインで簡単です。
A列のデータ形式が何か、B列のデータ形式を何にしたいか（他の式や関数でどのように使いたいか）によって、方法が異なります。 ■ A列のデータが日付形式（シリアル値）の場合 （方法1） A列（日付） 　B列（日付）　　 2016/03/15　=A1　[注：セル書式を "yyyymmdd" に変更]　⇒ 日付の 20160315 （シリアル値 42,444） 2016/04/10　=A2　[注：セル書式を "yyyymmdd" に変更]　⇒ 日付の 20160410 （シリアル値 42,470） （方法2） A列（日付） 　B列（文字）　　 2016/03/15　=TEXT(A1,"yyyymmdd")　　⇒ 文字の 20160315 （ "20160315" ） 2016/04/10　=TEXT(A2,"yyyymmdd")　　⇒ 文字の 20160410 （ "20160410" ） （方法3） A列（日付） 　B列（数値）　　 2016/03/15　=TEXT(A1,"yyyymmdd")*1　　⇒ 数値の 20160315 （ 20,160,315 ） 2016/04/10　=TEXT(A2,"yyyymmdd")*1　　⇒ 数値の 20160410 （ 20,160,410 ） （方法4） A列（日付） 　B列（数値）　　 2016/03/15　=VALUE(TEXT(A1,"yyyymmdd")　⇒ 数値の 20160315 （ 20,160,315 ）　　 2016/04/10　=VALUE(TEXT(A2,"yyyymmdd")　⇒ 数値の 20160410 （ 20,160,315 ）　 ■ A列のデータが文字形式の場合 （方法1） A列（文字） 　B列（日付）　　 2016/03/15　=DATE(LEFT(A1,4),MID(A1,6,2),RIGHT(A1,2)) 　　　　　　　　　[注：セル書式を "yyyymmdd" に変更]　⇒ 日付の 20160315 （シリアル値 42,444） 2016/04/10　=DATE(LEFT(A2,4),MID(A2,6,2),RIGHT(A2,2)) 　　　　　　　　　[注：セル書式を "yyyymmdd" に変更]　⇒ 日付の 20160410 （シリアル値 42,470） （方法2） A列（日付） 　B列（文字）　　 2016/03/15　=LEFT(A1,4)&MID(A1,6,2)&RIGHT(A1,2)　　⇒ 文字の 20160315 （ "20160315" ） 2016/04/10　=LEFT(A2,4)&MID(A2,6,2)&RIGHT(A2,2)　　⇒ 文字の 20160410 （ "20160410" ） （方法3） A列（日付） 　B列（数値）　　 2016/03/15　=VALUE(SUBSTITUTE(A1,"/",""))　⇒ 数値の 20160315 （ 20,160,315 ）　　 2016/04/10　=VALUE(SUBSTITUTE(A2,"/",""))　⇒ 数値の 20160410 （ 20,160,315 ）　 （方法4） A列（日付） 　B列（数値）　　 2016/03/15　=LEFT(A1,4)*10000+MID(A1,6,2)*100+RIGHT(A1,2)*1　⇒ 数値の 20160315 （ 20,160,315 ） 2016/04/10　=LEFT(A2,4)*10000+MID(A2,6,2)*100+RIGHT(A2,2)*1　⇒ 数値の 20160410 （ 20,160,410 ）
>対象とするシートがＸの他に複数あることを伝え忘れておりました 対象範囲が同じなら =SMALL(Sheet2:Sheet3!$A$1:$A$11,ROW(A1)) のようにすることも可能なようです
参考ページ 徹底解説(VLOOKUP,MATCH,INDEX,OFFSET) http://excel-ubara.com/excel3/EXCEL015.html ただし、シート上では使わないほうが良い関数のOFFSETは不要です。 =VLOOKUP(検索値,範囲,列番号,検索の型) =INDEX(配列,MATCH(検査値,検査範囲,照合の型),列番号) あと、番号において、数値と数字(文字列)が違うと検索されませんので注意が必要です
No.1です。時間がなくて検証できませんでしたが、クロス集計なんですね。 ピボットテーブルもマスターしておくと便利だと思います。 とりあえず、SUMPRODUCT案 I2セルに =SUMPRODUCT(($B$2:$B$7= $H2)*($C$2:$C$7=I$1),$D$2:$D$7) 右へ下へオートフィル ピボットテーブルは添付図参照。月別や年別に集計することもできますよ。 参考まで
このご質問は、フィルターを掛けるのはともかく、どのフィールドに対して、検索をしたいのか、書かれていません。また、類似検索というのは、そういう類似検索用の辞書がないとできませんから、せいぜい、マクロでは「単語を含む(*単語*)」という検索のみになります。 なお、以下は、私自身が使う目的で、今回、新たに作ったものです。 仕様としては、若干そぐわぬものがあるかもしれません。 ・ボタンはトグルになっていますから、フィルター状態からボタンを押せば元に戻ります。 今回は、ボタンはActiveX コントロールになっていますが、本来は、フォームコントロールにしたほうが、マクロコードの節約になります。（フォームコントロール・ボタンでも切り替えれられるようなコードにしてあります。それ以上にするには、AdvancedFilterになります。） ・検索文字は、テキストボックス等にしたほうが、他から影響を受けることがなくベターです。本来は、もう一つテキストボックスを作って、AndやOr の後に、もう一つ検索文字を加えることが可能です。 ・データは、まったくないと動きません。今回は、O列に対して最終データを検索しています。 ・重要なのは、検索するデータのフィールド内にカーソルを置かないと、その場所を検索しません。C列でしたら、C10かそれ以下の場所にカーソルを置く必要があります。 '// Private Sub CommandButton1_Click() 　　Dim mData As Variant 　　Dim strTxt As String 　　Dim i As Long 　　With ActiveSheet 　　　　If .FilterMode = False Then 　　　　　　If .Cells(Rows.Count, "O").End(xlUp).Row > 11 Then 　　　　　　　　Set mData = .Range("A10", .Cells(Rows.Count, "O").End(xlUp)) 　　　　　　Else 　　　　　　　　MsgBox "データがないかもしれません。", vbExclamation 　　　　　　　　Exit Sub 　　　　　　End If 　　　　　　If .FilterMode = False Then 　　　　　　　　If Trim(.Range("C7").Value) = "" Then 　　　　　　　　　　Exit Sub 　　　　　　　　Else 　　　　　　　　　　strTxt = .Range("C7").Value 　　　　　　　　End If 　　　　　　If Intersect(ActiveCell, mData) Is Nothing Then 　　　　　　　　MsgBox "検索する列の上にカーソルを置いてください。", vbExclamation 　　　　　　　　Exit Sub 　　　　　　Else 　　　　　　　　i = ActiveCell.Column 　　　　　　End If 　　　　　　　　mData.AutoFilter Field:=i, Criteria1:="=*" & strTxt & "*", _ 　　　　　　　　Operator:=xlAnd 　　　　　　End If 　　　　Else 　　　　　　.AutoFilterMode = False 　　　　End If 　　End With End Sub
つづけてお邪魔します。 ＞行間を1行ではなく2行とか3行とかに増やしたい場合は・・・ とりあえず2行あける場合のコードを記載しておきます。 Sub Sample3() 'この行から// Dim i As Long, wS As Worksheet Set wS = Worksheets("Bデータ") wS.Cells.Clear With Worksheets("B") .Range("A:A").AdvancedFilter Action:=xlFilterCopy, copytorange:=wS.Range("A1"), unique:=True For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row .Range("A1").AutoFilter field:=1, Criteria1:=wS.Cells(i, "A") .Range("A1").CurrentRegion.SpecialCells(xlCellTypeVisible).Copy wS.Cells(Rows.Count, "B").End(xlUp).Offset(3) '① Next i wS.Range("A:A").Delete wS.Rows(1 & ":" & 3).Delete '② wS.Columns.AutoFit .AutoFilterMode = False For i = 1 To wS.Cells(Rows.Count, "A").End(xlUp).Row If wS.Cells(i, "A") = "製品名" Then wS.Cells(i, "A").CurrentRegion.Sort key1:=wS.Cells(i, "B"), order1:=xlAscending, Header:=xlYes End If Next i End With End Sub 'この行まで// ※　3行あけたい場合は ①の行を ＞.Range("A1").CurrentRegion.SpecialCells(xlCellTypeVisible).Copy wS.Cells(Rows.Count, "B").End(xlUp).Offset(4) に ②の行を ＞wS.Rows(1 & ":" & 4).Delete と変更してみてください。m(_ _)m
新たにフィールド（列)を設ける以外の方法はわかりませんので悪しからず。
A1の値が実は数値ではなく文字列なんて落ちはありませんか？ と、もう一度返答してみる。 文字列になっていたら、それは数値として0（ゼロ）扱いになります。 ためしにA2セルが空白ならそこへ数値を入力後、A1セルに =A2*1 と入力してみてください。 これで文字列であっても強制的に数値へ変換されます。
文脈からすると勘違いしているように思う。 検索した結果「該当する値が無い」という意味だから、それ。 「1405」と入力されたセルがB列の検索範囲（B1:B300）に存在しないということだ。 No.1でも示されているようにエラー状態をERROR関係の関数で置き換えることを勧める。 （No.1ではIfERRORを勧めていますが、IsERROR関数ならバージョンを問わず利用できます）
こんばんは！ 画像の配置だとB18セルに =IF(C5="",$B5,INDEX($B$12:$B$13,MATCH($A18,C$12:C$13,0))) という数式を入れ、列・行方向にフィルハンドルでコピーではどうでしょうか？ ※　細かい検証はしていません。m(_ _)m
こんばんは！ ＞C列にプルダウンにてAかBが選択できるような設定になっており というコトですので B1セルに =A1*IF(C1="A",1,2) という数式を入れフィルハンドルで下へコピーしてみてください。 ※　エラー処理はしていません。m(_ _)m
一案です =IF(ISNA(LOOKUP(2,1/COUNTIF(C4:V4,作業主任者))),"","主") でもいいかも。参考まで
No1です。 ＞ 計算式はほかのファイルからリンクしています。 ではないかと思いました。 エクセルでもデータの持ち方とシートの構成が決め手となります。 私だったら、マクロを利用して 他のファイルあるデータを取り込むマクロを考えて データを一枚のシートに纏める方法を考えます。 次に、表示のためのシートがあると思いますので このシートに必要な情報が表示される関数を考えます。 もちろん、一枚のシートで条件に応じて表示が変わる様にします。 ない様な表示用のシートを100枚も作ることはしません。
こんにちは！ 仮にA列に条件付き書式を設定するとします。 A2セル以降色を付けたいセルを範囲指定　→　条件付き書式　→　新しいルール　→　数式を使用して・・・　→　数式欄に =IF(A2<>"",A2<LOOKUP(10^10,A$1:A1)) という数式を入れ書式から塗りつぶしで「赤」を選択してみてください。m(_ _)m
オプションで”R1C1参照形式を使用する”にチェックをいれて　R3C3セルに名前をつけて（仮にＸとする）すべての奇数セルの数式が「R[-1]C/X」となります Ctrl+Alt+intでコピーでもいいし。
関数以外の方法です。ご参考ください。
元々が文字であれば、文字として「00」にしてしまって良いのですよね。 であれば、=LEFT(A1,LEN(A1)-2)&"00"　でどうでしょう？
あれ？変なものが入った&quot;を"にする。 =IF(OR(O14="日曜日",O14="指定休日"),"ー","")
[No.3]へのコメント、 提示式中の「ROW(Sheet1!A$1:A$1000)」は少し冗長でした。 「ROW(A$1:A$1000)」に修正願います。(7文字分短くなる!)
添付図参照、比較的簡単な関数を単純な使い方でやってみました。 質問が文章だけなので解釈が違っているかもしれません。 F1セルに目的の1文字 D2セルに =SUM(D1,ISNUMBER(FIND($F$1,B2))) 下へオートフィル F2セルから下へ1から連番 G2セルに =MATCH(F2,D:D,0) 下へオートフィル H2セル =IF(ISNA($G2),"",INDEX(A:A,$G2)&"") 右へ下へオートフィル J2セル =IF(ISNA($G2),"",INDEX(C:C,$G2)) フィルハンドルダブルクリック
ひとつのセルに複数のデータを記入するよりも、 単純に複数のセルを使ったほうが何かと便利ではないかと。 ｜　A列　　｜B列 ｜　C列　　｜ ｜ 10月2日 ｜ ～ ｜ 10月5日 ｜ 　 こうしておくと、日数計算（ C － A）などもでき、データの可用性が高まります。 B列の "～" は、自動で表示するような式を入れておけば、入力の手間が省けます。 　　 =IF(C1="","","～") "～" の前後の罫線が邪魔なら「白の罫線」にすれば見えなくなります。
>E列の文字数が５ケタ以上の場合 の質問文が、解釈を分けています 文字列なら文字数、数値なら桁数です。 正の整数なら1万以上で5桁以上になりますね。
個人用マクロ ブック (Personal.xlsb) に保存したということはないですか？
こちらマイクロソフトのテンプレートに家計簿があります。 どのような表示になるのかも見れますので参考にすると 良いと思います。 「テンプレートダウンロード」からダウンロードできます。 ちゃんと自動で計算されますよ！ https://www.microsoft.com/ja-jp/office/2013/styl …
》 "#e"が表示されているものだけを 「もの」なんて抽象的に言わないで、行全体とか、行全体とか、該当セルと直下の行との２行A、Ｂ列とか、具体的に言わなきゃあ～！コマッタポン！
そりゃそうでしょう。 If .Cells(i, 4).Value = strSerch1 And .Cells(i, 5).Value = strSerch2 これが成立したときのみ、Sheet2の３番目にデータを格納し、次に又成立したら４番目に格納。・・・・・ endif の後にj=j+1を書いたら、成立するしないに関らず、格納位置をカウントアップしてしまう。 例えばi=2から10までfor文で回したとして、i=5の場合のみifが成立したら。 i=2,3,4の時には不成立なのにｊは毎回1カウントアップされる。 i=4を終わった段階でj=6になっている。 i=5で成立したらj=6になってるから6番目に格納してしまう。 正しくは３番目。
No.5です。 では、おそらく、半角スペースが14個入っていることになりますので、IF文には次の様に記載するといいと思います。 =IF(セルのアドレス=" ",空白の場合の式, 空白ではない場合の式) もしくは、 =IF(TRIM(セルのアドレス)="","空白の場合の式,空白ではない場合の式) でもOKです。後者は、TRIM関数で半角空白のみ削除しますので、空白しか入っていない場合は、長さ0の空き文字列を返すことになりますので、""で判定ができます。空白14個入力するよりは、こちらの方がメンテナンスはしやすいかと思います。
う～ん、抽出系はちょっと苦手なんですが一案として… 作業列として、D列を使います。フィルタリングしているということは1行目は見出しということでしょうから、 D2=SUBTOTAL(3,B2) として、下までコピーします。こうしておくことでフィルター後に表示されているセルにだけ1が入ります。 B5=SUMIFS($B$2:$B$4,$D$2:$D$4,1,$A$2:$A$4,"<>×") で如何でしょうか？
1つ忘れていました。 表示を分単位というのは、24時間を1440分と表記したいということだろうか。 ならば表示形式をユーザー書式として ”[m]:s" と、分に相当する部分を 「[　]」で囲めばよい。 分を最小単位として表記したいということであれば、 土曜に "h:m" とすればよい。 ついでに時間を上記のように "[h]:m" のようにすると24時間を越えても「77:00」のように表示することもできる。
No.1です。 標準モジュールの方がよかったのでしょうか？ ↓のコードを標準モジュールにしてください。 Sub Sample2() Dim i As Long, j As Long Dim lastRow As Long, lastCol As Long Dim myRng As Range With ActiveSheet lastRow = .UsedRange.Rows.Count lastCol = .Cells(1, Columns.Count).End(xlToLeft).Column Range(.Cells(2, "A"), .Cells(lastRow, lastCol)).UnMerge For i = lastRow To 3 Step -1 Set myRng = Range(.Cells(i, "A"), .Cells(i, lastCol)) If WorksheetFunction.CountBlank(myRng) > 0 Then For j = 1 To lastCol If .Cells(i, j) <> "" Then .Cells(i - 1, j) = .Cells(i - 1, j) & "、" & .Cells(i, j) myRng.Offset(-1).HorizontalAlignment = xlLeft End If Next j .Rows(i).Delete End If Next i .Columns.AutoFit End With End Sub これでアクティブになっているSheetが 前回のような動きになるはずです。m(_ _)m
「シート1にオートフィルタをかけた際に、シート2にもシート1に表示されている部分のみを表示する」が具体的にどういうことなのかサッパリポンです。
ご参考ください。
購入したパソコンにエクセル２００７がインストールされているのですよね http://marketspeed.jp/guide/rss.html の下の方に楽天RSSの設定方法がありますが ダメだってこと？？ エクセル２０１０を購入すればよいだけですが 世の中は、既にエクセル２０１６になっています。
少しお邪魔します。 ワークシートのチェックボックスがどういうスタイルになっているかにもよるかと思います。たぶん、#1さんの方法のほうが管理は楽だと思います。多少のセルが必要なのと、アンタッチャブルな領域が出てくるということだけだと思います。 ただ、私はマクロで少しシュミレートしてみました。ActiveXコントロールの場合は、たぶん、インスタンスが必要かなと思っているのですが、まだ手をつけていません。というか面倒なのです。結局、取り付け方から教えるということも、また面倒です。 フォームコントロールは、クリックした時にオブジェクトの固有の名前を保持しているのですが、ActiveXコントロールは、固有の名前を保持していないので、名前を付けてあげなくてはならない、というやや面倒な手間が必要なのです。 これらのマクロの利点はアンタッチャブルな領域が、ワークシート上では存在しない、設定は一瞬で済むということです。ただ、既存のものにつける以上、多少複雑なものなります。 一度、シュミレートしてみることをお薦めします。 理屈は、既存でついている名前を、シートごとに1から順に同じ名前に統一していくというものです。 '既存のチェックのボックス向けです。 Sub ChangeCheckBoxesName() 　　Dim sh As Worksheet 　　Dim i As Long, j As Long, t As Long, k As Long 　　Dim Chk As CheckBox 　　For Each sh In Worksheets　　'ブック全体で探す 　　　　t = sh.Shapes.Count 　　　　If t > 0 Then 　　　　　　j = 1 　　　　　　For i = 1 To t 　　　　　　　　If TypeName(sh.Shapes(i).DrawingObject) = "CheckBox" Then 　　　　　　　　　　Set Chk = sh.Shapes(i).DrawingObject 　　　　　　　　　　Chk.Caption = "" 'キャプションの非表示 　　　　　　　　　　On Error Resume Next 　　　　　　　　　　Chk.Name = "chk_" & j 　　　　　　　　　　If Err.Number > 0 Then 　　　　　　　　　　　　Do 　　　　　　　　　　　　　　Chk.Name = CStr(k) '臨時の名前付け 　　　　　　　　　　　　　　DoEvents 　　　　　　　　　　　　　　k = k + 1 　　　　　　　　　　　　Loop Until Err.Number = 0 　　　　　　　　　　　　Chk.Name = "chk_" & j 　　　　　　　　　　End If 　　　　　　　　　　On Error GoTo 0 　　　　　　　　　　Chk.OnAction = "OnOff_ChkBox" 'マクロをつける 　　　　　　　　 '' Chk.TopLeftCell.Offset(, 2).Value = Chk.Name '名前の確認 　　　　　　　　　　Set Chk = Nothing 　　　　　　　　　　j = j + 1 　　　　　　　　End If 　　　　　　Next 　　　　Else 　　　　　　MsgBox "このシートにはオブジェクトが見当たりません。", vbExclamation 　　　　End If 　　　　j = 0 　　　　k = 0 　　　　Application.ScreenUpdating = True 'シートを活性化する 　　Next sh End Sub '------------------------ 'これが、実際のチェックボックスに使われるマクロ Sub OnOff_ChkBox() Dim n As String Dim obj As Object Dim indx As String Dim bln As Long Dim sh As Worksheet n = Application.Caller indx = ActiveSheet.Shapes(n).Name '名前取り bln = ActiveSheet.Shapes(n).DrawingObject.Value　　'値取り Call allCheckes(indx, bln)　　'シート全体で同じものを探す End Sub Sub allCheckes(ByVal indx As String, bln As Long) Dim sh As Worksheet 　　For Each sh In Worksheets 　　 If ActiveSheet.Name <> sh.Name Then 　　　　On Error Resume Next 　　　　sh.Shapes(indx).DrawingObject = bln 　　　　On Error GoTo 0 　　 End If 　　Next sh End Sub '======================== オマケの実験用マクロです。 'シュミレート用のサンプルチェッボックス　1行ずつ入ります。 Sub AddChkBoxes() 'テスト用のチェックボックス設置 Dim sh As Worksheet Dim Chk As CheckBox Dim i As Long For Each sh In Worksheets 　For i = 1 To 10 　　 With sh.Cells(i, 2) 　　　　Set Chk = sh.CheckBoxes.Add(.Left + 3, .Top, .Width, .Height) 　　　　Chk.Caption = "" 　　　　Chk.Name = "chk_" & i　　'チェックボックスの名前の偏向 　　　　Chk.OnAction = "OnOff_ChkBox" 'マクロを取り付ける 　　　　'Chk.LinkedCell = .Offset(, 2).Address　'リンクするセル 　　　　'.Offset(, 3).Value = Chk.Name　'名前をセルに出す 　　 End With 　　 Application.ScreenUpdating = True 'シートを活性化する 　Next i Next sh 　　 MsgBox "シート" & Worksheets.Count & "枚にすべてのチェックボックスを付けました。", vbInformation 　　 On Error GoTo ErrHandler 　　 Call OnOff_ChkBox 　　 Exit Sub ErrHandler: 　　 If Err.Number = 1004 Then 　　　　　　　　MsgBox "OnOff_CheckBox のマクロが必要です。", vbExclamation 　　 Else 　　　　　　　　MsgBox "設定は正常に終わっています。" 　　 End If End Sub Sub ObjectDelte() 'チェックボックスの削除用 　　Dim sh As Worksheet 　　Dim obj As Object 　　For Each sh In Worksheets 　　　　On Error Resume Next 　　　　For Each obj In sh.Shapes 　　　　　　If TypeName(obj.DrawingObject) = "CheckBox" Then 　　　　　　　　''obj.TopLeftCell.Offset(, 3).ClearContents　　'名前を出している時 　　　　　　　　obj.Delete 　　　　　　End If 　　　　Next obj 　　Next sh End Sub
=IF(A1="","",CONCATENATE(A1,"御中"))　でどうでしょ。表示形式はなし。
こんにちは！ F列すべてを選択　→　条件付き書式　→　新しいルール　→　数式を使用して・・・　→　数式欄に =IF(COUNT(E1:F1)=2,AND(E1<=0,F1<=0)) とし　→　書式　→　塗りつぶしから「赤」を選択してみてください。m(_ _)m
まず、LEFT関数を使われている場合、1～9月と10月～12月で、桁数が変わってきますので、難しくないでしょうか？MONTH関数を使われることをおすすめします。 連番のリセットですが、次の様な考え方でやると実現できます。 月の値×1000と、最大値を比べて大きい方を取る。大きい方の値+1にすることで実現できます。 具体的には、表題を1行目、内容の列から順にA列と仮定してみます。 表題の移動・入職・退職が間違っている様なので、左から入職・退職・移動と考えています。 C2セルには、次の式を入れます。 =IF($A2="入職",MONTH($B2)*1000+1,"") D2/E2には、コピーしてそれぞれ、入職のところを退職・異動に変えてください。 次のD3セルですが、次の式を入れます。 =IF($A3="入職",IF(MONTH($B3)*1000>MAX(C$2:C2),MONTH($B3)*1000,MAX(C$2:C2))+1,"") D3/E3にも、この式をコピーし、入職を退職、異動に書き換えてください。あとは、そのまま下の行までコピーすれば、完成です。
曜日より祝日を優先して考えるのですね。 =IF(AND(WEEKDAY($C6)=1,COUNTIF(休日!A:A,$C6)=0),"C",IF(AND(WEEKDAY($C6)>5,COUNTIF(休日!A:A,$C6)=0),"B","A")) で出来ると思います。
こんにちは！ A列にデータがあるとすると表示したいセルに =SUMPRODUCT(ABS(A1:A1000)) としてみてはどうでしょうか？m(_ _)m
エラーコード12007-1ではなく、12007-4では ありませんか？ 12007-4であればofficeインストール時のエラー コードです。 インターネット接続、ウイルス対策ソフトウェア、ファイアウォール、またはプロキシ設定により、インターネット経由で Office をインストールできない場合、このエラーが表示されることがあります。 と記載がありますのでMicrosoftサポートを 参考にしてみてください。 https://support.office.com/ja-jp/article/Office-のインストール時にエラー-コード-12002-4、12007-4、または-12152-4-が表示される-c0268dd1-bf7d-4c0f-8b53-e125b6073f5b 同じようにダウンロード版でLANの設定が原因で ダウンロードできなかった方もいらっしゃいます。 http://answers.microsoft.com/ja-jp/office/forum/ …
NO.2 逆だった 等しく無いの意味。「≠」の記号が使え無いから<>と書く。
この表からだと、勤務体系がいま一つわかりづらいので、明確な答えは書きにくいかと思います。 例えば、木曜日ですが、12:00～17:00で休憩時間が1時間であれば、4時間の労働時間になるかと思いますが、5時間になっていることや、この日に20:00まで労働された場合は、2時間の残業とするのか、それとも通常労働時間にするのかといったところで、大きく式が変わってきます。 ここでは、18:00を過ぎた分を残業時間と仮定させていただいた場合、次の式となります。 1行目を表題、A列を日付、B列を曜日、以下出勤、退勤、休憩、労働、残業と考えた場合、G2セルには、次の式を入れてください。 =IF(B2="日",D2-C2,IF(D2>TIME(18,0,0),D2-TIME(18,0,0),0)) 続いて、G2セルの書式設定を時刻に変更してください。 あとは、G2セルをコピーし、G3:G8に複写し、G9セルに =SUM(G2:G8) とし、G9セルの書式も時刻に変更すれば完成です。 時間の計算は、単純そうなんですが、日付・時刻関数を使わないとうまくいかないことがあるので、そのあたりがポイントになってきます。また、日付を超えた場合の計算は、全く違う仕組みになります。
Wxcelは一過性の表計算に過ぎません 是非Accessをご使用下さいませ Accessですと、共有化し入力、閲覧が可能に成ります
Excelは一過性の表計算に過ぎません 是非Accessをご使用下さいませ Accessですと、共有化し入力、閲覧が可能に成ります
No1のhallo-2007さんの言う通り、ひとつのボタンのクリックで異なる処理を行うのは、ロジックが複雑になるので、できれば避けたいところです。ただ、いたずらにボタンを増やせば良いかというと、それも考えものです。例えば、状況によってボタンを押せなくしたりする余計なロジックが増えてしまいます。 セルの内容をテキストボックスに表示したり、逆にセルに反映するには、テキストボックスの ControlSourceプロパティで、リンクを張ると便利です。プログラムで意識的に代入を行わなくても、勝手には映してくれますので…。 とりあえず、サンプルを書いてみましたので、ユーザフォームの下に張り付けて実行してみて下さい。 ちなみに、ユーザフォームを表示するロジックは含めていないので、ここだけは自力でお願いします。 全体のステップ数は多いですが、それぞれのプロシジャは単純なので、見て頂ければ内容は理解できると思います。 Option Explicit Dim curRow As Long Private Sub CT_Click() If CC.Value = 0 Then CC.Value = 1 Else CC.Value = 0 End If End Sub Private Sub ET_Click() AA.ControlSource = "" AA.Text = "" BB.ControlSource = "" BB.Text = "" CC.ControlSource = "" CC.Text = "" CT.Enabled = False ET.Enabled = False curRow = curRow + 1 End Sub Private Sub ST_Click() CT.Enabled = True ET.Enabled = True If AA.ControlSource = "" Then AA.ControlSource = "Sheet1!A" & curRow CC.ControlSource = "Sheet1!C" & curRow Else If BB.ControlSource = "" Then AA.ControlSource = "Sheet1!A" & curRow BB.ControlSource = "Sheet1!B" & curRow Else curRow = curRow + 1 AA.ControlSource = "Sheet1!A" & curRow BB.ControlSource = "" BB.Text = "" CC.ControlSource = "Sheet1!C" & curRow End If End If End Sub Private Sub UserForm_Initialize() AA.ControlSource = "" AA.Text = "" BB.ControlSource = "" BB.Text = "" CC.ControlSource = "" CC.Text = "" CT.Enabled = False ET.Enabled = False curRow = 1 End Sub
Sheet1!C2セルに =IF(ISNA(MATCH(B2,Sheet2!$B:$B,0)),"",VLOOKUP(B2,Sheet2!B:C,2,FALSE)) 下へオートフィル XL2007からはIFERROR関数などもあります せめてバージョンに応じたExcel入門書を一冊マスターしましょう
よく読んでもらえば分るかと思うのですが・・・。 "決定通知書2"のSQL文を上げてもらわないと具体的な回答はできません。 PS. 自ファイルを対象としているのでDAOの方が簡単な気がします。 #083 パラメータクエリーをVBAから使うには http://www.tsware.jp/tips/tips_083.htm Microsoft Office 14.0 Access database engine Object Library または Microsoft DAO 3.6 Object Library に参照設定のチェックを入れて試してみては？ なお、 Dim rst As Recordset → Dim rst As dao.Recordset に修正しておいた方が吉。
ピボットテーブルのデータを取り出すことはできます GETPIVOTDATA関数を使います。 たぶん、適当なあいているセルに = を書いて ピボットテーブル内のデータフィールドをクリックすればできていると思います 参考まで
A1に24時間で作成した個数があって、分単位で経過時間を表示したい ということでしょうか？ A1の個数を24時間を割れば経過が出ますが、このままだと時間表示に なりませんので、さらに1日である24時間で割ります。 これで、1個での経過時間になります。 =(24/A1)/24 [表示形式]を[ユーザー定義]で「 [mm]"分" 」にする またはテキスト関数を使って表示する。 =TEXT((24/A1)/24,"[mm]分")
考え方は Sサイズの総数-Sサイズの貸与数の合計 と云う事ですよね。 ＝C5-SUMIF(C$12:C$21,B5,D$12:D$21) と入れて下へコピーします。
フォントの種類は関係ありません E12セルに =(D12="a")*1 E25セルまで下へオートフィル(一致するときは1、しないときは0、求めたいのはその合計) として、一致するはずなのにしない行を探してみては？
2枚目もそうですが、このシステムは解像度が低いので添付図の画質が落ちます。 無駄な部分は削って投稿するようにしてください。 XL2003でエラー処理なしですが N5セルに =SUMPRODUCT(($E$5:$E$9=K5)*($F$5:$F$9=L5)*($G$5:$G$9=M5),$H$5:$H$9) XL2007以降なら IFERROR と SUMIFS を組み合わせるとすっきりすると思います なお、見たところ表1に重複はないようですが、重複があると加算され合計が出ます 日本語にしてみると「複数条件付き合計」といったところでしょうか
処理完了日のセルを「A1」、処理したい行は「1行」として 設定したいセルを選択してから次の作業をすればできるはずです。 ホームタブの条件付き書式を選択 新しい書式ルールを選択 ルールの種類の選択 　　数式を使用して、書式設定するセルを決定を選択する ルールの内容を編集 次の数式を満たす・・・・ 式を「=$A1<>""」 書式を選択すれば 塗りつぶし パターンの種類 「ＯＫ」 でできるはずです。 ポイントは $A1 「$」使うことです。 以上
No.2です。 補足を読みました。B勤務の場合残業開始は5:15ではないか、深夜の割増などまだ疑問がありますが、そのままでのサンプルです。 なお、連続24時間以上の勤務はないことを前提にしています。 金額の端数は仮に切り上げにしています。ここはご自分で変更して下さい。 作業列を2列使います。式を長くしない為です。 1.日を跨ぐ勤務があるので、計算上の退勤時間（M列） 2.残業開始時間（N列） どちらも書式はユーザー定義で　[h]:mm　にします。 M2 =IF(B2="","",IF(A2<B2,B2,B2+"24:00")) N2 =IF(A2="","",IF(A2<"20:15"*1,"17:15"*1,"30:15"*1)) C2 =IF(A2="","",IF(A2<"20:15"*1,90,75)) D2 =IF(A2="","",M2-A2-C2/24/60) E2 =IF(A2="","",ROUNDUP(1000*D2*24,0)) F2 =IF(A2="","",MAX(0,M2-N2)) G2 =IF(A2="","",ROUNDUP(1000*0.25*F2*24,0)) H2 =IF(A2="","",MAX(0,MIN(N2,"29:00")-MAX(A2,"22:00"))) J2 =IF(A2="","",ROUNDUP(1000*0.25*H2*24,0)) K2 =IF(A2="","",E2+G2+J2) 添付図は見やすくする為にあえて2段に分けています。
こんばんは！ VBAになりますが一例です。 シートモジュールにしてみてください。 Sub Sample1() Dim i As Long, myRng As Range For i = 2 To Cells(Rows.Count, "A").End(xlUp).Row If Cells(i, "C") = "" Then With Cells(i, "C").End(xlUp).Offset(, 1) .Value = .Value & "," & Cells(i, "B") If myRng Is Nothing Then Set myRng = Cells(i, "B") Else Set myRng = Union(myRng, Cells(i, "B")) End If End With End If Next i If Not myRng Is Nothing Then myRng.EntireRow.Delete End If ActiveSheet.Columns.AutoFit End Sub こんな感じではどうでしょうか？m(_ _)m
こんにちは！ 具体的な配置がどのようになっているか判らないので やり方だけ・・・ ↓の画像でC2セルに =IFERROR(VLOOKUP(IF(B2="",A2,B2),E:F,2,0),"") という数式を入れフィルハンドルで下へコピーしています。m(_ _)m
オークションです。 http://closedsearch.auctions.yahoo.co.jp/closeds …
それなら普通はVLOOKUP関数1つでできる。 C1セルにA列にある値を入力して、その値に対応するB列の値を読み出すなら ＝VLOOKUP(C1,A1:B10,2,0) これでよい。 MATCH関数を使うならINDEX関数との組み合わせになる。 INDEX関数の行指定をMATCH関数で与えればよい。 MATCH関数で上から何番目に一致するセルがあるかを調べて、その値を使ってINDEX関数でB列の値を取得するのだ。 ＝INDEX(B1:B10,MATCH(C1,A1:A10),1) それぞれの関数の使い方はヘルプや解説本などで確認することを勧める。 MATCH関数はINDEX関数と組み合わせて使うことが多いので、多くの書籍はこの組み合わせについての説明が記載されている。 関数についての詳しい説明がなされているサイトもあるので、そこを参考にするのもよいだろう。 個人サイトではあるが、 http://www.eurus.dti.ne.jp/~yoneyama/Excel/kansu … は、ほぼすべての関数についてバージョンを問わず書かれている。（自分はど忘れしたときに利用させてもらっている）
フォームのコントロールを使って、グループボックス、その中にオプションボタンを作成します オプションボタンのコントロールボックスからリンクするセルを設定する (オプションボタンを選択して[Ctrl]+[1])と そのセルに番号が表示されます(添付図A1セル) また、正誤チェックのチェックボックスもコントロールの書式設定でリンクさせます(B1セル) 条件付き書式で数式を使い、正誤のチェックを判定させます。 (選択、即正誤チェックならチェックボックスはいらないですが) 複数質問されると思いますのでグループボックスがポイントです。 ちなみにH1セル =IF(OR(A1="",B1<>TRUE()),"",IF(A1=G1,"正解","×"))
恐らくですがシート２からシートｎまでを選択した状態で、シート１と同じ座標(この場合A1)に『=シート１!A1』と入力後、A1からA31までコピーすれば完成かと．．． 最後にシート１を選択すればシート２からシートｎまでの選択は解除されます 質問の意図が汲み取りにくいですが、こういうことでしょうか？
「4文字以上」は「4文字」を含みます。条件合ってますか？ =IF(COUNT(FIND(LEFT(B1&CHAR(9),5),A1)),B1,"") > 解説付きで教えてください。 お断りします。
=IF(A1="","",IF(B1="",A1,B1))*8%
多分に、関数を使うメリット、マクロを使うメリットがよくわかっていないのでは？ エクセルの機能は １、関数 ２、機能（印刷、フィルター、ピボットテーブルなど） ３、グラフ に分けることが出来ます。 マクロを生かすメリットは、２の機能の部分にあります。 手で操作している作業を組み合わせて、ワンクリックで連続した操作を可能にします。 無理に、関数をマクロ化する必要なないと思います。 次に、パソコンを使う仕事は １、入力作業 ２、出力作業（印刷など含む） ３、データの抽出、集計 ４、分析 です。 マクロが生きるのが２です。複雑な操作をしていた作業がボタンひとつに 集約出来ます。 それと、１に活用するのも効果があります。 しかし、ボタンのワンクリックにはできませんよね。 以下にして、最も手がかかる入力作業を自動化するかは腕の見せ所です。 それには仕事の流れを知っている人が出来ます。 中には、手入力して作業を、元データから取り込むことができれば ワンクリックで作業が完成しますよね。 VBAの基本を知ることも必要ですが、どこで生かせるか？ 関数など比較して、どの部分にマクロを使うか？ 経験も必要ですが、諸先輩のファイルや会社のシステムの流れなども勉強してみましょう。 また、コマンドは基本ですので http://excelvba.pc-users.net/ のようなサイトで一度、キチンと勉強してみましょう。
No.2です。 ＞.Cells(3, Val(sN)) = wS.Range("F816")でエラーになります。 ん？3行目にデータを入れたいのでしょうか？ それはいいとして・・・ エラーの原因はおそらくSheet名がちゃんと取得できていないのでは？ ＞表示したい列はB列からでした。 以上のことを加味してもう一度最初からコードを載せてみます。 Sub Sample2() Dim k As Long, wS As Worksheet, sN As String On Error Resume Next '←念のため// With Worksheets("合計") For k = 1 To Worksheets.Count Set wS = Worksheets(k) If wS.Name <> .Name Then sN = Right(wS.Name, 2) .Cells(3, Val(sN) + 1) = wS.Range("F816") '←3行目に変更・下二ケタが01の場合はB列から// End If Next k End With End Sub ※　Sheet数は2桁以内という前提です。m(_ _)m
ExcelやwordのOfficeのファイル形式から 画像ファイルを取り出す事は可能ですので、まずは そのエクセルを保存しておいて新しく開き直してから保存する時に拡張子を変更します。 こちらに詳しく載っていますので参考してください。 http://taiju.hatenablog.com/entry/20090804/12493 …
全文字数（①）から赤以外の文字数（②）を引けば、赤の文字数（③）になりますね。 というわけで、添付図のようにA1を全文字数、B１を赤以外の文字数、C1を赤の文字数として、２行目にそれぞれ数式を入れていきます。 A2 = {SUM(LEN(データ範囲))} B2 = {SUM(LEN(SUBSTITUTE(データ範囲,"赤","")))} C2 = A2-B2 ※A2、B2は配列確定が必要ですので、数式を入力してCtrl+Enterで確定をする必要があります。
理解が完全でないかもしれませんが、おそらくVBAの力を借りることになります。 似たようなところで「データ追跡機能付きテンプレートウィザード」というアドインもあります（した？）が。 入力シート(入力フォーマット)=印刷シート(印刷フォーマット)ではありませんか？ 必ず、入力シートで入力しなければいけませんか？ マクロの自動記録程度はできますか？ 上記、すべてYESなら 修正することはありますか？ また、そのデータ1件全部を削除することもありますか？ など、考えなければいけないことも多くあります。 非常に労力を要します しかし、入力シートにこだわりがないなら、台帳(データベース)に直接入力、 または、一般機能の「フォーム」を使って、 印刷シート(今の入力シート)に、INDEX/MATCH、VLOOKUPなどの関数を使ってデータを引っ張ってきます。 http://www.d3.dion.ne.jp/~jkondou/excelvba/GA2.htm
誰もレスを付けないと思いましたので、こちらでも作りましたのでアップしておきます。 #1の方とは、少し意味が違う部分があるかと思います。 以前、ここの掲示板で出したことがあると思うのですが、もう見つかりません。 一応、今回は、自分用で作ってみました。プロバイダからクレームが付きそうな気がしましたが、実行してしまいました。常識の範囲でお使いください。あまり速くはありませんが、ハングはしませんでした。 リンク先のチェックは、838件を一気にチェックしてしまいましたが、これほどはやらないほうが良いかもしれません。100件やって休むとかしたほうが良いような気がします。 ユーザー定義関数の戻り値は、いくつかあります。ステータス200は、◯ですが、その他は、種類がいろいろありますので、×にせずに数値や文字にしました。基本的に、ステータスコードの200は、全部返しました。 数字については、ステータス・コード表をごらんになってください。 http://www.asahi-net.or.jp/~ax2s-kmtn/ref/status … 例： 404 サイトがなくなっています。 403　アクセス権限がないということですから、ログインしなければ分からないかもしれません。 他にも、いくつか種類が出てきます。 n.a と出るのは、サーバーが受け付けないものだと思います。 アンチウィルスソフトで、禁止区域に入った時は、メッセージが出てきました。しかし、そのままで続いていきます。 このマクロ使用中でも、スクロールは可能です。 場所は標準モジュールです。 ''//-- Private Declare Sub Sleep Lib "kernel32.dll" (ByVal dwMilliseconds As Long) Private objHTTP As Object Sub Main_URLChecking() 　　Dim c As Range 　　Dim i As Long 　　''Microsoft WinHTTP Service, version 5.1 '参照設定する場合 　　''Set objHTTP=New winHttp.WinHttpRequest ' 　　For Each c In Range("B2", Cells(Rows.Count, 2).End(xlUp)) 　　　　If LCase(c.Value) Like "http://*" Then 　　　　　　c.Offset(, 1).Value = CheckURL(c.Value) 　　　　　　Sleep 200　　'Wait を掛ける 　　　　　　DoEvents　　　'ESCで離脱できるようにする。 　　　　End If 　　Next 　　 Set objHTTP = Nothing End Sub Function CheckURL(ByVal strURL As String) As Variant 　　Dim num As Variant 　　On Error GoTo ErrHandler 　　If objHTTP Is Nothing Then 　　　　 Set objHTTP = CreateObject("WinHttp.WinHttpRequest.5.1") 　　End If 　　objHTTP.Open "GET", strURL, False 　　objHTTP.Send 　　If objHTTP.Status = 200 Then 　　　　CheckURL = "◯" 　　Else 　　　　CheckURL = objHTTP.Status 　　End If 　　Exit Function ErrHandler: 　　If Err() <> 0 Then 　　　　CheckURL = "n.a" 　　End If End Function ''//-- なお、今度は、これを、ハイパーリンクのリストに反映しないといけないのかな？
条件付き書式を以下のようにしてはいかが。 =AND(OR(A8>A7+1,A8=""),A7<$D$3) 下のセルが一日以上とぶ場合か空白の場合のどちらかを満たす場合で、 有効期限の最終日より前の日付だった場合のみTRUEを返します。
OSのBitが異なっても、動くアプリケーションが同じなら、同じ。 互換性も同じってことになります。 Office 32bitとOffice 64bitでは、アドオンの互換性がなかったり、扱える領域に違いがあったりします。 64bitアプリは、Windows x64上でしか動作しないが、Windows x64上では、32bit及び64bitアプリが動作するので、アドオン等の互換性を注意するなら、どちらの方を入れようが問題ない。 企業だと、アドオンの互換性ってことで、32bitを使っているところもあるでしょうから、MSも、簡単に32bitアプリを切る捨てるわけにはいかないので、どちらも提供されているのでしょう
まさか、VBAのオプションで「変数の宣言を強制する」にチェックが入っているだけじゃないんですか？ http://www.accessclub.jp/vba/vba_016.htm であれば、以下で終了です。 Sub セル値の結合とPDF入力() Dim i As Long '<---これを追加 Range("D5").Select 変数宣言は省略すると、のちのち困ったことになりやすいので、横着をせず今のうちに宣言することを習慣化すべきです。
色を付けなくてよいなら =TEXT(A1*8/108,"内消費税(\0)") など。 セルが基本単位となりますので一般機能では色まではできない (無理やり画像のリンク貼り付けでできなくはないが、画像なのでボケる)
関数（セルに入力する数式）で色を変えることは、非常に難しいです（できないとは言いませんが…）。 一般的に色を変えるには、条件付き書式を使います。 例えば、C2セルに下記2つの書式を設定すれば、土日に色を付けりことができます。これを全体に適用すれば、ほぼ要望通りのものが出来上がるのですが…。 Exceは祝日の情報を持っていません。よって、自前で定義する必要があります。これに関するやり方は、ネットに転がっていると思いますので、別途、調べてみて下さい。 【C2セルの書式設定】 =WEEKDAY(DATEVALUE(B$1&B2&"日"))=7　･･･土曜日用です。書式を青に設定してください。 =WEEKDAY(DATEVALUE(B$1&B2&"日"))=1　･･･日曜日用です。書式を赤に設定してください。 （注記） 月（B1）は、文字として設定されているものとします。 年の情報が無かったので、当年を適用します。来年、このブックを開くとその年の曜日で色が付きます。
色番号がExcel2003までのパレット表示なのですね。 http://fnya.cocolog-nifty.com/blog/2011/12/excel … が参考になるかも。
No.1です。 ＞「注文」という文字列をC列に挿入する場合は・・・ について Sample1の場合は ＞Range(Cells(2, "A"), Cells(lastRow, "A")).SpecialCells(xlCellTypeConstants).Offset(, 1) = "注文" を ＞Range(Cells(2, "A"), Cells(lastRow, "A")).SpecialCells(xlCellTypeConstants).Offset(, 2) = "注文" に Sample2の場合は ＞Cells(i, "B") = "注文" を ＞Cells(i, "C") = "注文" に 変更してみてください。m(_ _)m
＃４です 勘違いしていたようです > ４回戦 ということで、４回戦する時間帯での組合せを求めていましたが、 1人が４対戦･･･時間帯的には、５回戦分なのですね 提示した処理で奇数人の場合、回戦毎に休む人を切り替えてましたが、 最後に、対戦数の少ない休みの人たちで組合せを組もうとした時、 それまでの処理で既に組合せを使っている場合があり、 きれいに４対戦を組むことができてませんでした 捨ててください ※ 以下はどのように読むことが正しいのでしょうか > 組み合わせは > 15人は > １－２　３　４　５ > ２－１　３　４　６ １番目の人は、1回戦は２の人、２回戦は３の人･･･ なら、 ２番目の人の２回戦目は、３の人が終わるまで待つ？ １１番～１４番の４回戦目は、１５の人？ １５番目の人は、３回戦分は見てるだけ？ ７回戦分の時間帯がある？ リーグ戦もどきで４回戦しかしないのなら、 リーグ戦表を記述して １回戦目の対戦のみを指示して 終わった人から、リーグ戦表上で対戦を決めていけば･･･ １５人とかなら、 終わった人群から対戦相手が見つからない･･･少ないように思います 運用的には、この表が大きな紙に書かれていて、 磁石で掲示していたとした場合、例えば ・左の氏名部分に磁石 ・１回戦目の相手を確認し･･･ ★・対戦中は、その行の対戦相手の所に磁石移動 ・終わったら、その部分に結果を記述して ・左の氏名部分に磁石移動 ・氏名部分に磁石のある人の対戦状況をみて未対戦なら ★へ 以上　失礼しました
必ずB,D,F,H列の奇数行(B3,B5,B7・・・H11)にはデータが入ること A4,A6,A8,A10, B4,D4,F4,H4,B6,D6,・・・,H10セルと B15:E15セルが合致しないこと。 を条件に =SUM((IF($B$3:$I$11="",$A$3:$H$11,$B$3:$I$11)=B15)*1)/2 [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 空白セルに左隣のデータを持ってきて、対象を数え半分にしている
あまりおっしゃる意味が解りませんけど，こんな感じで出来ればいいのでしょう？ セルの結合とか使えばいい話。 これが解らないならば，まず誰かに教えて貰った方がいいです。ここでは手取り足取り教えるの難しい。
＞マクロだと出来るのですが、データーが重いので関数で出来ないかと考えていました。 マクロが可能であれば、先に紹介しました フィルターオプションを使えば、相当の量のデータであっても 瞬時に抽出できますよ。
「マクロの記録」で記録できない操作がありますが、ボタンをクリックする操作も、そのひとつのようです。 「ぼたん1」に登録しているマクロ（例えば、Macro1 とか）を直接、Runメソッドで指定すれば、いけると思います。 ただし、マクロは標準モジュールになければいけません（･･･たぶん。･･･いい加減な回答ですいません）。 例、「ぼたん1」に登録されているマクロが、「Macro1」であれば、Application.Run ”Macro1" また、Call Macro1 でもいけるはずです。基本的には、こちらがお勧めです。
元データ内に 会員申告リストの在籍期間が 「完全に含まれる」鈴木太郎、 「一部含まれる」う、え 「２期間にまたがって含まれる」い 「加入期間外～加入期間外ではあるが含まれる」お 「完全期間外」あ、大田次郎 もっと条件はありますが、上記判定を書かれていない(読解できない)部分があるので、 たたき台となります。 E8セルに =SUMPRODUCT(($B$2:$B$4=B8)*($C$2:$C$4<=D8)*($D$2:$D$4>=C8)) 下へオートフィル
B7セル　=COUNTIF(B$2:B$5,"*A*") B8セル　=COUNTIF(B$2:B$5,"*B*")
補足のように ＞A1に○があれば なら(添付図左側) A2:C6セルまでA2セルから選択 条件付き書式 [数式が]=FIND("○",$A2) 質問文のように >A1が○ならピンク なら(添付図右側) A2:C6セルまでA2セルから選択 条件付き書式 [数式が]=$A2="○" 上記、XL2003なので「書式」は3種類までの設定となる
>オンラインエクセル編集だと、パスワード等の設定は無効になってしまうのです。 読み取りパスワードを掛けたものをアップロードしましたが有効でしたよ？ ただし、オンラインExcelは対応しないので、個々のExcelでの編集になりました ただ、 >共有する際に発行するリンク等を第三者に知られると中身を見られてしまうのではないか の部分が理解できていないので、求める回答になっていないかもしれません
では、マイナーシリーズPart.2 (フィルタオプションと)データベース関数とテーブル機能 条件表の作成 E1セル タイトルの管理コード E2セルは空白のまま 管理コードは データ - フィルタ - フィルタオプションの設定(詳細設定) で重複するレコードは無視する にチェックして抽出する F4セルに =DSUM($A$1:$C$20,3,$E$1:$E$2) E4:F8セルを選んで データ - テーブル 行の代入セル は空白のまま 列の代入セル $E$2 計算速度が遅く作るの面倒なので、普段紹介しないけどね。
こう云う事で良ければですが 仮に1行目から順に下方向に入力していくとします。 10行目、20行目、30行目・・・で音を鳴らす。 シート名のタブを右クリック コードの表示をクリック VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Int(Target.Row / 10) * 10 = Target.Row Then Beep MsgBox ("注意") Beep End If End Sub を張り付けて説いてる 10行単位で、編集した際に音とメッセージが出ます。 ＞ビープ音を連続で数回鳴らし、 連続音で注意するのも良いですが、一般的にはメッセージボックスで いったん手を止めさせた方が良いような？ 或いは 自動でサンプリングのプログラムを実行させるとか？
こんばんは！ 画像の配置だとB16セルに =COUNTIFS($B3:$H11,B15,$C3:$I11,"")+COUNTIFS($B3:$H11,B15,$C3:$I11,"<>")/2 という数式を入れ フィルハンドルでE16セルまでコピーではどうでしょうか？m(_ _)m
2行目からデータが並んでいると仮定。 B列とD列で１個以上差が有ったら最終行の次行へコメント。 シート名をSheet1とする（cellsは行列が解りずらいのでRangeを使う） Sub 例題() Dim Cnt As Long Dim UP As Long Dim Sh As Worksheet Set Sh = Worksheets("Sheet1") 'Shをシート名にする UP = Sh.Range("E65536").End(xlUp).Row '最終行 For Cnt = 2 To UP If Sh.Range("B" & Cnt).Value <> Sh.Range("D" & Cnt).Value Then Sh.Range("C" & UP + 1).Value = "差異有" Sh.Range("E" & UP + 1).Value = "差異大" GoTo OWARI End If Next Cnt OWARI: Application.StatusBar = False End Sub
Sheet2を作業シートとします=1行にまとめた「ヤマダさん情報」はSheet2に表示されます。 Sheet1のA列をコピーして、Sheet2のA列に貼り付けます。 Sheet2で、データタブ→重複の削除、を選択して、同じ名前を削除します。 Sheet2のA1に「ヤマダ」が入力されているとして、B1~E1にそれぞれ B1: =SUMIFS(Sheet1!B:B,Sheet1!A:A,Sheet2!A1) C1: =SUMIFS(Sheet1!C:C,Sheet1!A:A,Sheet2!A1) D1: =SUMIFS(Sheet1!D:D,Sheet1!A:A,Sheet2!A1) E1: =SUMIFS(Sheet1!E:E,Sheet1!A:A,Sheet2!A1) と入力します。 SUMIFSではなく、COUNTIFSでも同様にできると思います。
エクセルは、アクセスなどデータベースソフトと違って 同時編集が出来ないのが難点なのですよね。 同時にエクセルを開くと、後から開いたときに 「通知する」がありますので、こちらを使って開いておいて チェックが終わってファイルを閉じたらメッセージがでて そられから、３人の誰かが作業する。 このような方法しかありません。 もしＶＢＡとか使える人がいれば ３人にそれぞれの入力専用ファイルを配布して作業をしてもらう。 作業が終了したら、ファイル名を変えて作業済ファイルとして保存 チェック者が作業済みファイルを開いてチェック チェックが完了したらホンファイルにデータを追加して保存 このような流れが良いかもしれません。
A1を入力するセル（例でいう15を入力する）とします。 B1からB20に、1~20までの数字を入力します。 C1に、=IF($A$1=B1,"♪”,"")と入力します。 C2からC20までコピーします。 A1に、例えば15を入力すれば、C15に♪が表示されます。
取りあえずは、マクロの記録でコードを作成します。 ５の（ダイアログを出す）部分だけ修正できれば 大丈夫だと思います。
一枚のシートに入力して印刷するまでのシートですよね。 １　例えば、Ｄ２セルに日付が入っていて 　　Ｄ３セルに　=(TEXT(D2,"yyymmdd")&"01")*1 　　とすれば、日付の後に　０１が付いた番号が出ます。 　　Ｄ４セルには　=D3+1 と入れて下までコピーしていけば 　　連番になります。 ２　これも仮に　2３０個であれば、2００個が１０％割引 　　３０個は通常ですよね。 　　一番わかりやすいのが 　　価格表に 　　商品Ａ（通常）　　　１０００円 　　商品Ａ（１００個割引）９００円 　　と価格表を分けておいて、発注書にも 　　２行に分けて 　　　商品　　　　　　　　発注数　　　単価　　　小計 　　商品Ａ（通常）　　　　　３０　　１０００　　　３００００ 　　商品Ａ（１００個割引）２００　　　９００　　１８００００ 　　・・・ 　　と云う表にした方が受け取る側にもわかりやすいと思います。 　　或いは 　　商品Ａ（通常）　　　　１０００円 　　商品Ａ（１００個割引）－１００円 　　と価格表を分けておいて、発注書にも 　　２行に分けて 　　　商品　　　　　　　　発注数　　　単価　　　小計 　　商品Ａ（通常）　　　　２３０　　１０００　２３００００ 　　商品Ａ（１００個割引）２００　　－１００　－２００００　　 　　と表示させるかでしょうね。 ３　２ができれば、ＳＵＭ（小計）で出来ますよね。
データが入っている列を選択 リボン　＝＞データ 中央部分にある　重複の削除　をクリックします。
こんにちは 添付の図はよく読めないので、ご質問文だけで判断していますが・・・ 各ブックについて、処理1～3で、データ（シート3枚分）をコピーし関数によって得られた計算結果1行を処理4で集計して行くということですよね？ 最終結果は上記4を集めた約300行分ということでよいのでしょうか？ 使用頻度が不明ですが、毎回シート3枚をコピーして1行を得ることを300ブック分繰り返すのはあまり効率が良さそうには思えません。 各データのあるブックに関数シートまでを入れておいて、マクロでの処理はそれぞれのブックの結果の1行を集計するだけにしてしまう方が良さそうに思います。 このような処理であれば、ご提示の参考サイトの考えがほぼそのまま利用できますね。 もしも、参照対象となるデータのブックが固定の場合は、マクロを利用しなくとも、集計用シートにブック間のリンクを貼っておくだけでも実現はできそうに思います。 もしも、現状のデータのブックにシート4（関数のシート）が存在しない場合は、1回だけの作業なので、手作業で頑張るか、または、シート4の追加をマクロで一括処理することも可能です。 マクロで行う場合は、一つのものを各ブックにコピーするということになり、やはり参考サイトの考えが利用できます。 ただし、この場合は、コピー元とコピー先を逆にする必要がありますが、処理としてはほとんど同じと言えますね。 ところで、 ＞以下のURLを参考にしてはみたもののどうしても理解しきれず、 ＞質問するに至りました。 とのことですが、ご提示のＵＲＬと同じ内容の情報でも、ここの回答欄には納まりきらないのではないかと思います。（図も自由には使えないですし） ですので、それ以上にこと細かな説明を欲しいとの意図でしたら、この回答欄では無理ではないでしょうか？ そのサイトを読んでみて 　1）まったくわからない。 　2）ほとんどわからない。 　3）なんとなくはわかるが、どうしていいのかわからない。 　4）だいたいはわかるが、わからないところがある。 　5）ほぼわかる。 1）～3）の場合は「急がば廻れ」でエクセルのＶＢＡについての知識を深めた方がよろしいかと思います。そのような説明サイトも数多くありますし、書籍を利用してもよろしいでしょう。 一方で、ご質問のアイコンが「急いでいます」となっていますので、時間がないということであれば、特に1）～2）の場合は、周りの詳しい方に相談なさるか、いっそのこと外部に依頼するという方法も選択肢に加えた方が良いかも知れません。 4）の場合は、全体に関する漠然とした質問をするのではなく、わからないところを切り分けて質問なされば詳しい回答もつくと思いますし、何回かご質問なさるうちにできあがるのではないかと想像します。 5）の場合は、多分このご質問にはならないと思いますので、該当はしないのかな・・
デスクトップのフォルダ名はパソコンによって変わります。 C:\Users\会社User\Desktop　と固定にしているのがまずいです。 この、マクロを入れるブックをどのパソコンであってもデスクトップにすれば ThisWorkbook.Path でデスクトップのフォルダが取得できます。
No.です。 > もう一つ質問ですが、 > 再度試してみようと思い、sheet2として別のページを開き、A列をゼロになるくらいまでドラッグして狭くしてみました。 > そして最上段のBという文字の左にｶｰｿﾙを合わせると、あっけなくドラッグできる表示になり幅を変える事ができてしまいました。 > 先程の質問のケースと同じようにA列は無いに等しいくらい狭くなっていたのに、前回はｶｰｿﾙを合わせてもｶｰｿﾙの表示が変化せず、今回は変化して幅を変える事ができました。 > この２種類のA列の幅はどのような違いなのでしょうか？ 普通は今回のような位置でマウスポインタが変化しますが、時に、マウスポインタが反応しない時があります。 最初のように意図しない(ユーザーが操作しない)で、列が極端に狭くなった場合、マウスポインタが正常に反応しないように思います。
> ただし、セルBにセルA以前の年月日を入力すると、セルFに任意のエラーメッセージを表示し、B〜Eには何も表示しない。 > ただし〜以降の部分がいくらやっても出来ません。 『セルFに任意のエラーメッセージを表示』 IF関数で、A列セル＞B列セル の場合、「エラーメッセージ」を表示しては如何ですか？ 『B〜Eには何も表示しない』 D列、E列は元々空白なので、B列のセルに、「条件付き書式」を設定し、A列セル＞B列セル の場合、「書式」にフォントの色を「白」に設定する方法は如何ですか?
No.1です。 ＞出来れば、A列分類「魚介」「肉」「野菜」以外に10以上あった場合とかできますか？ ん～～～出来るとは思いますが、一気にすべての分類を表示するとなると 結構厄介だと思います。 そこで一案ですが、↓の画像のように表示したい「分類」を入力すると そのデータを表示させる方法はどうでしょうか？ ↓の画像でSheet2のB1セルに「分類名」を入力するとします。 （データの入力規則から「リスト」表示させるのが簡単かもしれません） 今回も元データのSheetに作行用の列を設けます。 Sheet1のD2セルに =IFERROR(IF(ISNUMBER(FIND(A2,Sheet2!B$1)),RANK(C2,C:C),""),"") という数式を入れ、しっかり下へコピーしておきます。 そしてSheet2のA4セルに =IFERROR(INDEX(Sheet1!A:A,MATCH(SMALL(Sheet1!$D:$D,ROW(A1)),Sheet1!$D:$D,0)),"") という数式を入れフィルハンドルで右へ・下へコピーすると 画像のような感じになります。 ※　今回は配列数式ではありません。 ※　Sheet2のB1セルには必ずSheet1のA列のデータを入れます。 （魚or野菜といった表記では何も表示されません） とりあえずはこの程度で・・・m(_ _)m
VBAの力を借りないと無理ですね。 Sheet1のシート名のタブを右クリック コードの表示をクリック VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$B$1" Then Sheets("Sheet2").Range("D1:F1").ClearContents If Target.Value = 1 Then Sheets("Sheet2").Range("D1").Value = Range("A1").Value If Target.Value = 2 Then Sheets("Sheet2").Range("E1").Value = Range("A1").Value If Target.Value = 3 Then Sheets("Sheet2").Range("F1").Value = Range("A1").Value End If End Sub を張り付けて閉じます。 B1セルに　１，２，３と数値を入れてからSheet2の変化を確認してみてください。
lr = sh.Cells(ActiveSheet.Rows.Count, 1).End(xlUp).Row sh.Rows("1:" & lr).Copy の意味は理解できているのでしょうか。 lr = sh.Cells(ActiveSheet.Rows.Count, 1).End(xlUp).Row コピーするシートの最終行の行番号を取得しています。 最終行が総合計で不要なら lr = sh.Cells(ActiveSheet.Rows.Count, 1).End(xlUp).Row-1 で良くないでしょうか。 sh.Rows("1:" & lr).Copy も1行目から取得した行までと云う事です。 仮に　8行目から良ければ sh.Rows("8:" & lr).Copy と云う事ですが。 一度、試してみてください。
同じファイルの別シートであればできそうです。 完全に別のファイルにデータを反映させるとなると、別のファイルに反映させる関数を組めばできなくはなさそうですが、動作は重くなると思います。 マクロを組めば動作の重さは解消されますが、ファイル名を変えてしまった時などは改めてマクロを組み直さなくてはならなくなり、あまり現実的ではなさそうです。
もう一度読み直したら、 >その枚数に単価を乗じた金額から2パーセントが控除され、この価格を基本価格に加算することになります。 なので超えた分にのみ98%の乗算ですかね？ だとしたら、No.4の回答は無視してください =IF(A1<=200,2000,2000+ROUNDDOWN(ROUNDDOWN(LOOKUP(A1-200,{1,6;301,5.5;501,5})*A1+LOOKUP(A1-200,{1,-1200;301,-950;501,-600}),0)*98%,0)) 以前のコストを下回るには約14210枚を超える必要がありそうです ただし、C4セル=1020+ROUNDDOWN(ROUNDDOWN((A4-200)*5.1,0)*98%,0)
セルDはmike_gさん案で訂正。 ただ、 https://oshiete.goo.ne.jp/qa/9226614.html 返答もなく↑は、不快だ
re.re.さんの都合でデータベースブックを考えたのだと思っていました。事情を知らず申し訳ありません。 そこで、データベースブック内のすべてのシートをひとつのテンポラリシートにまとめるマクロを書いてみました。 テンポラリシートを元に、re.re.さんの書いたAdvancedFilter メソッドを実行すれば実現可能と思います。 Sub sample() Dim wbDB As Workbook Dim wsDB As Worksheet Dim ws As Worksheet 'テンポラリシート Set wbDB = Workbooks.Open("C:\hoge\data\DataBook.xlsm", , True) For Each wsDB In wbDB.Worksheets If ws Is Nothing Then '最初のシートの場合は、そのままコピーして新規ブックを作成。 wsDB.Copy Set ws = ActiveSheet Else '2番目以降のシートの場合は、2行以降をコピーして追加。※見出し行数に応じて要調整！！ wsDB.Rows("2:" & wsDB.Cells(Rows.Count, 1).End(xlUp).Row).Copy ws.Rows(ws.Cells(Rows.Count, 1).End(xlUp).Row).PasteSpecial End If Next Application.DisplayAlerts = False wbDB.Close Application.DisplayAlerts = True 'ここから先は、re.re.さんが書いたコードです。 Sheets("検索結果").Select ws.Range("A3:X10000").AdvancedFilter _ Action:=xlFilterCopy, CriteriaRange:=Range("検索!Criteria"), CopyToRange:= _ Range("A3:V3"), Unique:=False End Sub
No.3の回答の一部に間違いがありましたね。 > 10進数の「１」から「15」を「1,2,3,4,10,11,12,　～　23,24,25」に の25は誤りで30になりますね。 「10進数の「１」から「15」を「1,2,3,4,10,11,12,　～　23,24,30」に」 と書くべきでした　m(__)m
単純にオートフィルで対応するなら、No.1さんのアドバイスにある大きい 数字とその次の数字を入力して、範囲選択後にオートフィルをすれば、 簡単にできると思います。 http://www.eurus.dti.ne.jp/yoneyama/Excel/input_ … でも、来年以降も利用するのなら、基準年（今年）を用意しておいてから その基準年から用意した西暦などを引き算する計算式を入れたほうが 良いと思いますよ。 http://www.eurus.dti.ne.jp/~yoneyama/Excel/jituy …
Sheet1をコピーして、Sheet3を作ります。 Sheet2のA1:F13をコピーして、Sheet3のA1に張り付けます。 最後に、Sheet3全体をSheet2にコピーして、Sheet3を削除すれば出来上がり。 当然、マクロ化ですようね。
こんばんは！ 極力お示しの配置通りでやってみました。 元データはSheet1にあり、Sheet2に表示するようにしています。 ↓の画像でSheet2のB1セルに =SUM(IF((MOD(COLUMN(Sheet1!$A$1:$M$1),2)=1)*(Sheet1!$A$1:$M$1=A$1),Sheet1!$B1:$N1)) 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　Sheet2のB1セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 B1セルが選択選択されている状態で、セルの上下左右どこでもよいのでマウスポインタを移動させ 上下左右の小さな矢印になったところでCtrlキーを押しながら D1セルへドラッグ　→　そのままF1セルにドラッグ これでB1セルの数式がD1・F1セルにコピーされましたので 各列のフィルハンドルで下へコピー！ これで画像のような感じになります。m(_ _)m
「データ」タグの中に、「並べ替えとフィルタ」の「詳細設定」というのがあるのですが、これを使うと簡単に抽出ができます。ちょっと取っ付きにくいかもしれませんが、非常に便利です。是非、習得してみて下さい。ヘルプでも丁寧に説明されていますので、確認してみてください。 上記の操作をマクロ記録して、ちょこっと修正すれば、ご希望の抽出ができます。 ちなみに、ちょこっと修正したマクロは次のようになるはずです。ただ、これは店番ひとつ分なので、必要なだけ繰り返してください。 Sub Macro1() Sheets("Sheet1").Range("A:H").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Sheets("Sheet2").Range("A1:A2"), _ CopyToRange:=Sheets("Sheet2").Range("A3:G3"), Unique:=False End Sub
>この程度の日報をExcelで作ることすら難しいです。 独学で勉強するなら http://www.eurus.dti.ne.jp/~yoneyama/Excel/Exl-_ … などのサイトを参考に夜な夜な勉強しましょう。 一週間もあれば初心者レベルはクリアできると思います。 a4サイズの紙にめいいっぱい敷き詰めること ・印刷画面（プリントプレビュー）で確認して、余白、倍率などで調整します。 青赤黄色で塗ったところの作り方？ ・セルの塗りつぶし、罫線と呼ばれる機能です。
それはルールがおかしいからです。 現行のルールでも式はできますが、面倒です。 ＞売上が500万以上で利益率が30%以上の場合、特別報酬に10万支払う ＞ことになりました 売上（特別報酬を除く）が500万以上で、利益率（特別報酬を除く）が 30%以上の場合 とルール変更した方がわかりやすいでしょう。 支払額にはそんな大きな差はないはずです。 何より、社員には目標が明確になり、モチベーションが上がるでしょう。 モチベーションのための特別報酬ですから。
アンケートのテンプレートが沢山ありますので、あなたのイメージに近いものを選んで、編集されると良いと思います。 「アンケート」の書式テンプレート http://www.bizocean.jp/doc/category/208/ 「アンケート用紙の作り方・書き方 例文...」 http://template.k-solution.info/2008/01/01_word_ … 「Word アンケート 作成 テンプレート」のWeb検索結果 https://www.google.co.jp/#q=word+%E3%82%A2%E3%83 …
私からも疑問をひとつ ＞B1-B3のセル削除、B4のセルのみを残す A列が4行単位で結合で、B列は3行が空白 結合する意味ってあるの？ と思うのですが。
次のマクロを「頭シート」のWorksheet_Activateイベントプロシジャに張り付けてみて下さい。 「頭シート」以外の日毎のシートは、必ず「１日」「2日」のように日付として認識できる名前にしてください。 日付として認識できない名前のシートがあるとエラーになります。 Private Sub Worksheet_Activate() Dim MyMaxDay As Variant Dim MySheetDay As Variant Dim ws As Worksheet For Each ws In ThisWorkbook.Worksheets If Me.Name <> ws.Name Then MySheetDay = DateValue("1月" & ws.Name) If MyMaxDay < MySheetDay Then Me.Range("A1") = ws.Range("A1") MyMaxDay = MySheetDay End If End If Next End Sub
> Excel関数で比較をしたいのですが〜！ > 前月と当月の表で商品名と数量を比較して > 商品名の数量増減比較と商品名追加項目の確認をしたいのですが〜良い方法がありますでしょうか？ まず比較云々以前に、具体的にどういうシートを作成したいのでしょう。 例えば1行名が見出し行でA列から順に商品名、1月、2月、3月・・・とあり、2行目以降のA列に商品名が行方向（縦方向）に並び、B列以降に各商品の月別販売個数が並ぶといったものでしょうか？ それですと商品別の1月と2月の差（増減数）、2月と3月の差（増減数）は何処にどのように表示するかが問題になります。 といった具合にどういう情報をどのように配置、表現するかをまず考えてください。ようするに「具体的にどういう様式の管理資料が欲しいのか」です。 それが分かれば増減はあるセルにある値と、あるセルにある値の引き算です。 参考まで。
＞試しにA列に51と入力しても【A*1500】と表示されて計算してもらえません。 ””で囲われた文字列で返すような数式だから、当然と言えば当然。 C1に0 C2に51 C3に61 C4に71 D1に50 D2に60 D3に70 D4に999999 E1に1000 E2に1500 E3に2000 E4に2500 を入力して B1に =VLOOKUP(A1,C$1:E$4,3,1)*A1 と入力。 B2セル以降はB1セルをコピーして必要な行まで貼り付ければ出来上がり。 VLOOKUP関数で指定する4つ目の値が１またはTRUEの時は、 検索する値が見つからない時、検索する値より小さい値の中で最も大きい値を検索結果とし、それに対応する値を返します。 ただし値は上から小さい順（昇順）に並んでいる必要があります。 この方法は、条件が非常に多い場合に便利です。 また、あとで条件が変更する必要がある場合も簡単に変更することが可能です。
『１、２、３、４、休み』が循環して繰り返されれば良いということでしょうか？ B2に以下を入力して、下方にフィルコピーでいかがでしょう？ =IF(MOD(IF($B$1="休み",0,$B$1)+ROW()-1,5)=0,"休み",MOD(IF($B$1="休み",0,$B$1)+ROW()-1,5))
画像だからじゃないの？
VLOOKUPでいけます。
A列中の結合されたセルのうち、結合行数が8行未満のものに対して行を追加して8行結合にするマクロです。 よろしかったら、お試しください。 Sub sample() Dim I As Long Dim J As Long Dim ma As Range For I = 1 To Rows.Count If I > Cells.SpecialCells(xlCellTypeLastCell).Row Then Exit For Set ma = Cells(I, "A") If ma.MergeCells Then J = ma.MergeArea.Rows.Count If J < 8 Then Rows(I + 1 & ":" & I + 8 - J).Insert Shift:=xlDown, _ CopyOrigin:=xlFormatFromLeftOrAbove End If End If Next I End Sub
=S5-R5+IF(R5>=S5,1)　←この計算式おかしいですよ？ 通常は次のような式になります　 セルT2=(R2+IF(R2-S2<0,1,0))-S2　の式を入れ下方向へオートフィルコピー。 一応簡単な時間処理の方法を添付しますので参考にしてみてください。 一番下の合計時間のセルは、ユーザー定義より[h]:mm に変更することで正しい結果が返ってきます。
こんにちは 作業がデータの追加があると、その整理のために行われるたぐいのものであるならば、ご質問のマクロは最初の一回のみに有効で、その後は毎回ゼロから処理する必要もないように感じられます。 その場合は、追加された内容を既存のシートに挿入するような処理の方が適切のような気がします。 （最初の1回は、下の説明を手作業でやってもよいので・・・） それとも、別ファイルなどでデータのセットがまとめて作成されて、毎回それを処理するためにご質問のような作業が必要になるということなのかな。 考え方として、まず元のデータ（シート1）を保存しておくために、そのコピーを作成してそこで作業しちゃいます。 一度全部をのデータを対象に、Ｆ列をキーにして全体をソートしてしまうのが手順としては簡単かと思います。 あとは、好きな割振りで各シートにコピーしてゆくだけになりますので。 作業したシートは、必要がなければ、コピー終了後に削除してしまえば良いですね。 ご質問文のシート２以降の例でＦ列が抜けているのは、単にＦ列が抜けているだけなのか、Ｇと表記しているのがＦのつもりなのかよくわかりませんが・・・ 前半のソートするところまでを、簡単に作ってみました。 Ｆ列はコピーしないのかと思いましたので、コピーしやすいようにＦ列とＧ列を入れ替えるところまでの処理にしてあります。 各シートへのコピーは比較的簡単だと思いますが、ルールがよくわからないので、適宜作成してみてください。 （よく理解できていないところがある気がしますので、ご参考までに。） Sub Sample() Dim sht As Worksheet, rw As Long Dim data As Range, key As Range 'シート１に該当するシートをセットすること Set sht = ActiveWorkbook.Worksheets("sheet1") sht.Copy After:=sht Set sht = ActiveSheet rw = sht.Cells(Rows.Count, 6).End(xlUp).Row Set key = sht.Cells(1, 6).Resize(rw, 1) Set data = sht.Cells(1, 1).Resize(rw, 7) With sht.Sort .SortFields.Clear .SortFields.Add key:=key, SortOn:=xlSortOnValues, _ Order:=xlAscending, DataOption:=xlSortNormal .SetRange data .Header = xlYes .Orientation = xlTopToBottom .Apply End With sht.Columns("F:F").Copy Destination:=sht.Columns("H:H") sht.Columns("F:F").Delete End Sub
=IF(INT(LOG10(A1))>1,ROUND(A1,1-INT(LOG10(A1))),INT(A1))
こんにちは！ VBAでもそのままワークシート関数が使えますので・・・ 一例です。 （最終行は385行目だと決まっているのですね？） Sub Sample1() With Range(Cells(2, "E"), Cells(385, "E")) .Formula = "=IFERROR(VLOOKUP(D2,A:B,2,FALSE),"""")" .Value = .Value End With End Sub 方法②（1行ずつループさせる方法） Sub Sample2() Dim i As Long On Error Resume Next '←念のため// For i = 2 To 385 Cells(i, "E") = WorksheetFunction.VLookup(Cells(i, "D"), Range("A:B"), 2, False) Next i End Sub ※　一般的には最終行を取得し、 その後「操作」という場合が多いと思います。m(_ _)m
➀重複を削除したい表の中の 1 つのセルを選択している状態で、 [データ] タブの [重複の削除]をクリック。 ②特定の項目が同じである行を削除したい場合は、その項目だけ にチェックを付けます。特になければすべての項目をチェックしている状態で [OK] を押します。これで重複している行が削除されます。
元データの重複（会員番号と購入週）を削除してからピボットしてはどうですか？ https://www.microsoft.com/ja-jp/atlife/tips/arch …
いちおう計算速度上昇させた数式 作業列は同じ B16セル =MATCH(0,B8:K8) 下へオートフィル(二分検索なので早いはず) C16セル =IF($K8<C$15,"",MATCH(C$15,$B8:$K8)-SUM($B16:B16)) 右へ下へオートフィル 総計算するCountifは理解しやすいですが、こちらの方が計算が早いと思います
ActiveWorkbook.Names("ACELL").RefersToR1C1 = "=!R1C1"
> s = 2 ここをコメントにして、どうなりますか
INDEX/MATCH または VLOOKUP関数を使えばよいように思います http://excel-ubara.com/excel3/EXCEL015.html
No.2のママチャリさんの表を参考に考えてみました G2セルに =IF(E2="","",CHAR(LOOKUP(E2,$A$2:$A$10,CODE($B$2:$B$10))+(LOOKUP(E2,$A$2:$C$10)<=F2))) 下へオートフィル
あ、早まった。 右から２文字ではなくて、２番目なんですね。 そしたら、右から２文字とって、その後、左から１文字切り取ればいいので、Left(Right(Cells(1, 1), 2),1)になります。
残念ながら決定的な固有名は無いようです。ただ、ActiveSheet.ListObjects(1) とすれば、アクティブシートの1番目のテーブル（ListObjects）を指定することはできます。でも、２つ以上のテーブルがある場合は使えませんよね。 ListObjectの名前はブック上でユニークでなければならないので、同じ名前は付けれれません。コピー先のテーブル名を必ず「テーブル0」にするには、今ある「テーブル0」を消すか、リネームする必要がありますが、めんどくさいですよね。 そこで、次のような方法で、目的のテーブルを探してみてはいかがでしょうか。 Sample1は、アクティブなテーブル（作業中のセルがリスト範囲内にある）を探します。 Sample2は、テーブルの左上のタイトルが「顧客番号」のテーブルを探します。 Sub sample1() 'アクティブなテーブルを見つけ名前を表示する。 Dim MyTable As Object Dim MyActiveTable As Object For Each MyTable In ActiveSheet.ListObjects If MyTable.Active Then Set MyActiveTable = MyTable Exit For End If Next If MyActiveTable Is Nothing Then MsgBox "アクティブなテーブルがありません。" Else MsgBox MyActiveTable.Name End If End Sub Sub sample2() 'タイトル行の左端が「顧客番号」のテーブルを見つけ名前を表示する。 Dim MyTable As Object Dim MyTargetTable As Object For Each MyTable In ActiveSheet.ListObjects If MyTable.Range.Cells(1, 1) = "顧客番号" Then Set MyTargetTable = MyTable Exit For End If Next If MyTargetTable Is Nothing Then MsgBox "該当するテーブルがありません。" Else MsgBox MyTargetTable.Name End If End Sub
どうしてもやりたいんですよね？手段は選びませんよね？･･･であれば、こんな感じでどうでしょうか。 下記のプログラムをブックBのシート１のWorksheet_SelectionChangeイベントプロシジャに張り付けます。 次にブックBのシート１のA1セルに入力規則でリストを設定します。リストの内容は、とりあえず適当でOKです（マクロ内で再設定するので･･･）。ただし、入力時メッセージのタイトルは、”MyList”としてください。 それから、ブックAとBは同時に開かれていることが前提となります。また、氏名にカンマが含まれていると姓と名が別々のリストとして表示されてしまいます。 【プログラムの仕様】 入力規則のタイトルが、”MyList"であるセルが選択された場合、リストの表示内容をブックAのシート１のA列からダイナミックに設定します。 Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Target.Validation.InputTitle <> "MyList" Then Exit Sub Dim ws As Worksheet Dim I As Long Dim MyList As String Set ws = Workbooks("A.xlsx").Sheets("Sheet1") For I = 1 To ws.Cells(Rows.Count, "A").End(xlUp).Row If MyList <> "" Then MyList = MyList & "," MyList = MyList & ws.Cells(I, "A") Next I Target.Validation.Modify Formula1:=MyList End Sub
置換するとき，全角スペース と半角スペース の違いではないですよね？ セルの空白をコピーして 置換のところでペーストしてもだめですか？
No.1です。 質問文の最初の部分（数式を除いて）を見落としていました。申し訳ありません。 複数の場合と単独セルの場合で分けないと出来ないようです。 If Selection.Count > 1 Then Selection.Cells.SpecialCells(xlCellTypeConstants).ClearContents Else If Not ActiveCell.HasFormula Then Selection.ClearContents End If End If
以下、ご参照↓ https://technet.microsoft.com/ja-jp/library/cc73 … バッチファイルはコマンドのテキスト化なので、これで可能と思います。
グラフでNA関数を使ってプロットしているのですね。 http://www.relief.jp/itnote/archives/000855.php ブランクの場合などでのエラーを非表示にしたいなら、ISERROR関数や ISNA関数を条件付き書式に設定すれば、フォントの色指定で非表示に 見せることは可能です。 http://www.relief.jp/itnote/archives/000471.php http://www.geocities.jp/excel_graph1/kowaza/kowa …
こんばんは！ 数式を拝見する限りでは わざわざ配列数式にする必要はないように思えます。 U列に重複データがないという前提であれば =IFERROR(INDEX(I:I,MATCH(Z1,U:U,0)),"") としてみてはどうでしょうか？ ※　U列に重複がある場合、 最初の行のデータが表示されます。m(_ _)m
セルQ1には、=E1*G1と入っていて、それを書式設定でゼロは非表示としているということですよね？ 書式設定でゼロを非表示にしても見た目は空白になっても、値としてはゼロです。よって、それを参照しているセルO1もゼロと見做してしまします。 そこで、Q1の式を「ゼロだったら空白とする」に変えてみてはいかがでしょうか。 具体的には、=IF(E1*G1=0,"",E1*G1) のように･･･。
見せたくないシートを非表示にして編集不可でBook保護しては？
何もそんなに難しい事しないでも良いのに・・・。 Sheet名と言うシートのB3に=Sheet名'!A24の演算子と入れたいのなら Worksheets("Sheet名").Range("B3") = "=Sheet名!A24" これだけ。 >>指定先のA24がA~Cと24～25まで結合してあるセル これは関係ない
>エクセルの知識がないので関数の入ったセルを消してしまったり、 数式ですね ついでに言えば、 ”関数｢&｣を”　＆は関数ではありません演算子です 本筋に戻る >エクセルの知識がないので関数の入ったセルを消してしまったり、 セルやシートの保護をすれば消されることは無いですね 或いは、セルの背景色を使って、入力セルと数式セルを区分しておくとか 工夫の余地はありそうです VBAで自動化するのもアリですが、汎用性柔軟性を考慮しないと逆に使いにくい構造になったりするのでご注意を
次のようなリストがあったとします。 　　　Ａ　　　　Ｂ １　名前１　　　○ ２　名前２　　　○ ３　名前３　　　○ ４　名前４　　　× ５　名前５　　　×　　　　　 　セル　B5に入れる式は=COUNTIF(B1:B5,"○")となります。 　もしも面接者を増やしたければ、上の式のB5を人数に応じて変えるだけです。
実際にどんな状況で使われるのか分からないので、他の処理に影響が出るかもしれませんが、とりあえず、ご参考まで。 処理内容は以下の通りです。 まず、移動先（BA列以降）をクリアします。 次に、A4:AZ4から"大"を検索。見つかった場合、さらに後ろから検索し、最後の"大"を特定します。 最終的に見つけた"大"が検索範囲A4:AZ4の最後セル（$AZ$4）の場合、何もしません。 最終セルでない場合、"大"の右側の列からAZまでに空白列を挿入することにより、移動させます。 Sub sample() Dim c As Range Range(Columns("BA"), Columns(Columns.Count)).Delete With Range("A4:AZ4") Set c = .Find("大", LookIn:=xlValues, LookAt:=xlWhole) If Not c Is Nothing Then Set c = .FindPrevious(c) If c.Address <> "$AZ$4" Then Range(Columns(c.Column + 1), Columns("AZ")).Insert Shift:=xlToRight End If End If End With End Sub
=AND(COUNT(A4)=1,COUNTIF(祝日,A4)=1) でいいんじゃないでしょうか。
Excel2013でも同じですよ。 たぶんExcel2010を以前は使っていたのだと思います。 MDIからSDIに仕様変更があったためですので。 http://www.relief.jp/itnote/archives/018148.php タブレット対応にするためらしいですが、MDIに慣れていたユーザーには 不便になったかもしれませんね。 切り替えできませんから諦めるしかないと思いますよ。
》 軽く表を作成致しました お示しの表、「軽く」ありません。 初心者はとかく着色に加えて、罫線引きやセル結合のオンパレードにしたがるけど、老婆心ながら、そういう体裁を施すことはやめた方が得策です。 老眼等のために見易くするには、フォント・サイズを大きくしたり、ズーム倍率を大きくすれば済むことです。
[No.2お礼]へのコメント、 》 添付図を見ることが出来ませんでした 貴方は、添付図を見れない端末で[教えて!goo]にアクセスしている、ということですか？
[No.1お礼]へのコメント、 繰り返しになるけど、…(そう させないでぇ～) 》 印刷範囲設定は？ Excel 2013 の場合で言えば、[ページレイアウト]→[印刷範囲]→[印刷範囲の設定]を実行していましたか？ 》 印刷プレビュー画面と印刷結果は同じ？ どうでしたか？
KB用紙で検索してみました http://kokuyokopi1.spsmile.biz/entry1.html にあるようにコクヨのビジネス用紙と云う事の様です。 サイズは色々とあるようですので ＞何％に縮小すればいでしょうか は、手元にある用紙サイズに合わせてください とか答えがないと思います。 A4サイズならA4用紙と云う事です。
誤　Nifs file systemエラー 正　Ntfs file systemエラー だろうか。 システムファイルが壊れてしまったことによるエラー表示です。 Windows10は自身でシステムの復旧においてファイルを上書きするので、その影響を受けているのかもしれない。 とりあえず「システムの復元」を試みてはどうか。
>営業所は全部で４つあるので、まだ長い式になると思います。 元々のデータの持ち方に無理があります。 一例ですが 　A　B　　C　　D　　E　　F 　　　　　　　　　　ABC　A営業所 　　　　　　　　　　DEF　A営業所 ・・ 　　　　　　　　　　WXY　A営業所 　　　　　　　　　　XYZ　B営業所 ・・・ といった具合に、縦方向にデータをもって、その横に対応する営業所を入れていきます。 =Vlookup(B1,E:F,2,False) と云ったVlookup関数だけで済みます。 仮に、B1セルに入力する際にも入力規則でE列を選択しておけば 入力作業も楽ですし、間違いもおきなくなります。 配列関数は、多用すると急にパソコンの動作が遅くなりますで注意しましょう。
失礼しました。エクセル2013でしたね。 「ファイル」タブをクリック⇨「オプション」ボタンをクリック⇨「Excelのオプション」画面が開きますので左側にある「詳細設定」をクリック⇨「詳細設定」を選択したら右側の「編集設定」欄にある「フィルハンドルおよびセルのドラッグアンド ドロップを使用する」のチェックを外す。⇨OKボタン これで直るはずです！
PFDをテキストやExcelに変換するソフトがあるようなので、ググってみて下さい。 この辺を使えば、ご希望のことができるかもしれません。
No.3です。 今回もユーザー定義関数でやってみました。 セル内の文字数に制限はなく、最後の数値のあとに数値以外の文字列があっても 結果は最後の連続する数値を表示するようにしています。 Function suuti(myRng As Range) Dim k As Long, str As String, myStr As String, myFlg As Boolean For k = Len(myRng) To 1 Step -1 str = StrConv(Mid(myRng, k, 1), vbNarrow) If str Like "[0-9]" Then myFlg = True myStr = str & myStr End If If myFlg = True Then If Not str Like "[0-9]" Then Exit For End If Next k If Len(myStr) > 0 Then suuti = Val(myStr) Else suuti = "" End If End Function ※　ファイルを保存するときは 「マクロ有効ブック」として保存します。m(_ _)m
該当行のF列に「1」をセットする一例です。わかりやすいように作業列を複数使います。 3行目の式が書いてあったので、データを3行目からとします。 G列は明細の該当のものに1を設定 H列は該当明細の部名 I列は該当明細のチーム名 F3 =IF(G3=1,1,IF(OR(AND(COUNTIF(B3,"*合計"),COUNTIF($H:$H,SUBSTITUTE(B3,"合計",""))),AND(C3<>"",COUNTIF($I:$I,SUBSTITUTE(C3,"合計","")))),1,"")) G3 =IF(AND(ISERROR(FIND("合計",B3)),ISERROR(FIND("合計",C3)),ABS(E3)>=100),1,"") H3 =IF(G3=1,B3,"") I3 =IF(G3=1,C3,"")
１．データ表の作成 　同じ横軸上に縦棒と折れ線を描画するには、データ表も同じように並べる必要があります。 「グラフの作り方」 http://www.tipsfound.com/excel2010/05001 ２．グラフの作成 　棒グラフと折れ線グラフを１つに描くには、複合グラフの作成法を使います。 「複合グラフを作成する | Microsoft Office 2010 活用 TIPS」 https://www.microsoft.com/ja-jp/office/2010/busi … ３．多数の同じサイズ、書式のグラフを作成 　ユーザー定義のグラフを登録して利用します。 「Excel2010：ユーザー定義のグラフを登録する」 http://office-qa.com/Excel/ex145.htm
＞シート1とシート2を合わせて計算するとことは可能でしょうか？ シート1にある数値とシート2にある数値を加算（減算？）できるか？という意味ですか？ であれば、もちろんできます。 ＞A4サイズを二枚作りたいです。 印刷の際に、部数を指定しましょう。 ＞数段ずらして同じようなのを二部作らないといけません。 20日～翌20日迄を範囲選択して印刷。同様に、1日～月末迄を範囲選択して印刷で良いのでは･･･。 ＞表を丸々コピーすることはできるのでしょうか？セル1マス1マスコピーしなければならないのでしょうか？ どちらも可能です。やりたいこと次第です。 ＞やり方等教えて頂きたいです。 やりたいことを教えて頂きたいです。
=Index(B1:E1,3) って=D1 とほぼ意味なので、置き換えては？
こんにちは。 私は、もう、あまりマクロは書いていませんが、一応、どんな感じかという紹介程度にさせていただきます。VBAを知っている人なら、このレベルのマクロは誰でも分かると思います。 誰が使ったかはシステムにお任せになってしまいますが、何時にどのぐらいの時間で、どのファイルを触ったかの記録は残りますので、自分のアリバイと、そこにいた人物の特定には可能ではないかと思います。これは、サーバー内では試していませんので、もしかしたら、問題があるかもしれませんが、必ず、Excelアプリの本体のあるHDからのアドインのとり付けになります。 このマクロは、アドインを外しても、外した時の記録が残ります。このパターンを利用して、ファイル自体のバックアップも可能です。ファイル自体は、マクロある・なしを問いません。ただ、現状では、同じ種類のマクロですとコンフリクトを起こして、エラーが発生します。発生場所は、標準モジュールですから、On Error Resume Next ～ On Error Goto 0　で囲えば、エラーだけは防げます。 現在、保存等の記録は、デフォルトパスのフォルダに record.iniという名前に排出されます。1M に達すると、そのファイルは.bak ファイルとなり、新しいファイルになります。ただし、記録は、1世代前までです。1日でも、使い方によっては、相当に大きくなる可能性があります。 クラスの中の、FilesizeCheckの以下の部分の[>=1 ]は、1Mbyte ですから、常識の範囲で、大きくしてもよいかもしれません。 If objFile.Size / (1024 * 1024#) >= 1 Then ハングした場合も、途中までは記録されるはずです。もし、もっと隠すのでしたら、別のフォルダ（C:\Users\[ユーザー名]\AppData\Roaming\Microsoft\Excel\ は、以下のように組み込みます。） 　 myPath = Application.StartupPath 　 i = InStrRev(myPath, "\") 　 myPath = Mid$(myPath, 1, i) で決めることもできます。 なお、最終的には、パスワードを付けて、マクロの中身を見れないようにしてください。秘匿化していませんので、技術力の高い人なら、パスワード越しでも、見破られてしまいますが、逆に、見破るような人は、数多くはいないはずです。 アドイン化の方法は、マクロを貼り付けたら、保存の際に、.xlamを選べばよいのですが、書き換え等が発生したおりは、VBEモジュール内のみで行ってください。Excelファイル自体には、一切、マクロはありませんから、csvでも、記録に残ります。 不要になったら、アドインは外してください。 --------------------- ファイル名は、RecordAddin.xlam '//-------- 'ThisWorkbook モジュール Private Sub Workbook_AddinInstall() 　　Call Module1.Auto_Open End Sub '標準モジュール　Module1 Public myClass As Class1 Sub Auto_Open() 　　Set myClass = New Class1 　　Set myClass.myApp = Excel.Application End Sub 'クラスモジュール Class1 Public WithEvents myApp As Excel.Application Private Reco As String Private objFS As Object Private myFold As String Private myPath As String Private Const INIF As String = "record.ini"　　'記録ファイル名 Private Sub Class_Initialize() myFold = Application.DefaultFilePath myPath = myFold & INIF If objFS Is Nothing Then 　　　　Set objFS = CreateObject("Scripting.FilesystemObject") End If Call FilesizeCheck Reco = "App_Ini" & ", " & Format$(Now, "yymmdd hhMMss") Editline Reco End Sub Private Sub myApp_NewWorkbook(ByVal Wb As Workbook) '新しいブック Reco = Wb.Name & ",new_book," & Format$(Now, "yymmdd hhMMss") Editline Reco End Sub Private Sub myApp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean) '保存前 Reco = Wb.Name & ",close," & Format$(Now, "yymmdd hhMMss") Editline Reco & vbCrLf End Sub Private Sub myApp_WorkbookBeforePrint(ByVal Wb As Workbook, Cancel As Boolean) '印刷 Reco = Wb.Name & ",print," & Format$(Now, "yymmdd hhMMss") Editline Reco End Sub Private Sub myApp_WorkbookOpen(ByVal Wb As Workbook) '既存のブックを開ける Reco = Wb.Name & ",open,　　" & Format$(Now, "yymmdd hhMMss") Editline Reco End Sub Sub Editline(strTxt As String) Dim UName As String Dim objFile As Object Dim objTxt As Object Dim objFold As Object UName = Application.UserName If objFS Is Nothing Then 　　　　Set objFS = CreateObject("Scripting.FilesystemObject") End If If Dir(myFold & INIF) <> "" Then 　　 Set objFile = objFS.GetFile(myPath) 　　 Set objTxt = objFile.OpenAsTextStream(8, 0) 　　 objTxt.WriteLine UName & "," & Reco 　　 objTxt.Close Else 　　 Set objFold = objFS.GetFolder(myFold) 　　 Set objFile = objFold.CreateTextFile(INIF) 　　 objFile.WriteLine Reco 　　 objFile.Close End If Set objFile = Nothing Set objFold = Nothing End Sub Sub FilesizeCheck() Dim objFile As Object 　　 If objFS.FileExists(myPath) Then 　　 Set objFile = objFS.GetFile(myPath) 　　 If objFile.Size / (1024 * 1024#) >= 1 Then 　　　　　　On Error Resume Next 　　　　　　objFS.DeleteFile myFold & "record.bak", True 　　　　　　objFile.Name = "record.bak" 　　　　　　On Error GoTo 0 　　 End If 　　 Set objFile = Nothing 　　 End If End Sub
仕事で使うのであれば ハードウェアプロテクト（「USBドングル」で検索すれば判ると思う） の購入を考えても良いのでは無いでしょうか 開発キットが約１万 USBのドングルが １台あたり 約 3000円 占用の USB をハードに刺さないとプログラムの利用が出来ない 仕組みになる為 >ファイルの無断コピー＆転送や計算式だけを盗み取り、 >別の書式で新たなものを作成されたり こういう関連の処理を考えなくても良くなります。
セルの書式設定→表示形式→ユーザー設定で、 セル入力が日付入力であるならば、(aaa)　を指定 文字入力である場合は、"("@")"　を指定 ご確認を。
>列、A～Hまであり、Hが合計になります。 > 時によってはA～Fまでで、Fが合計になるときもあります。 J列に =MAX(A2:I2) として下へコピーしておいては駄目なのでしょうか。
[検索]で単語を指定して、[すべて検索]を実行してはいかが。 http://www.officetanaka.net/excel/function/tips/ … [すべて検索]で、見つかったセルの一覧が項目として表示されます。 先頭項目が選択されている状態で[ Shift ]キーを押し、リスト最終項目を 選択すれば、フォントの色やセルの塗りつぶしなどの書式をリボンなどで 設定することができます。
win7に戻してみて下さい。 知り合いがエクセル・ワード共に開かなくなり 戻してました。 アップグレード後30日以内なら、 「設定」→「更新とセキュリティ」→「回復」で「Windows7に戻す」のメニューから元に戻せます。
PDFをテキストに変換（Adobe Reader使用）して、そのテキストの全文をEXCELに 貼り付けるでは、ダメなのでしょうか。 どうしても、VBAでということならわかりません。すみません。ほかの方、お願いします。
"文字列” の文字列自体に”が有る場合は""と続ける ="テキスト<font""●"">テキスト</font>テキスト"&C1&"テキスト" ”そのもをだったら ="""" (文字列を意味する"で囲んで、"が２個必要） ””だったら ="""""" (文字列を意味する"で囲んで、"が4個必要）
データが入力されているお隣のセルに、左から２文字だけを抽出した文字を表示させその列をフィルタリングで使用してはいかがでしょうか？ ちなみに今回はセルA1に「a1」を入力し、セルB2に「=LEFT(A2,2)」と入力しています。
Excel2013以降であれば，フラッシュフィルという方法がありますよ。 詳細は，エクセルの新規作成をするように開くと，”空白のブック”の隣あたりに，「ツアーに参加する」と大きな文字で書いてある”Excelへようこそ”というところをクリックすると，ツアーが始まります。 ”始めましょう＞”をクリックすると”１．塗りつぶし”というタブに移動します。 ここには，たくさんの，メールアドレスが１列に入力されたサンプルが入っています。 そこに書いてあるように，C5セルに，”Tomoko"と入力してみましょう。この段階では何も起きません。 次に，C6セルに，”Toshiyuki"と入力します。”Toshi"あたりまで入力すると，C7セル以降に自動的に”Akihide" ”Mariko"と”.”の前の部分が自動的にすべて切り取られます。 詳細は， https://support.office.com/ja-jp/article/%e5%85% … こうすれば，あとは簡単です。D5セルに”AA01”，D6セルに”AA02"という風に規則的に通常のフィルをします。 （多分こういうことをしたいのですよね？） さらに，同じくフラッシュフィルを用いて，拡張子をE列に切り取ります。フラッシュフィルを使うには，切り取られる対象の列が，直前の列でなければならないようなので，C列に新規の列を挿入し，これまで，C列だった列がD列，D列だったところがE列になります。 新しくC列になった，C5セルに”PNG”と拡張子を入力します。次のC6セルにも拡張子を入力すると，さきほどと同じように，拡張子がC列にフラッシュフィルされます。 あとは，C，D，E列に入っているデータを，F列に文字列として加算すればよいと思います。 つまり，F５列に，”＝D5＆E５&"."C5”と入力して，F列をオートフィルすればよいと思います。 アナログな感じですが，ほかの方と違う方法ということで回答してみました。お試しください。
こんばんは！ データは2行目以降にあるとすると C2セルに =FIND("#",SUBSTITUTE(B2,"、","#",A2))-1 という数式を入れフィルハンドルで下へコピーしてみてください。 ※　エラー処理はしていません。m(_ _)m
No.3です。とりあえずエラー処理なしで =MATCH(99,FIND({"りんご","ゴリラ","ラッパ"},A1)) 別表を作るなら =MATCH(99,FIND($D$2:INDEX($D:D,COUNTA($D:$D)),A1)) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 結果は添付図
エクセルでの一案です、 特定のセルを選択 リボン　データ 中央部分にあるデータの入力規則 リスト　を選択 元の値　×　（適当なマークを一つ） 空白を無視する　のチェックを外してOK 最初は　空白の状態から　入力（×）を入れると 他の文字の入力、空白に戻すことも出来なくなりますが。
O2: =C2&D2&"."&F2&"."&H2 P2: =TODAY() o3:=DATEDIF(O2*1,P2,"y")
If Cells(Rows.Count, 1).End(xlUp).MergeCells　Then RowNum =10 Else RowNum = Cells(Rows.Count, 1).End(xlUp).Row +1 End IF と云った感じでは？？ A列の最終セルが結合されていれば　１０ それ以外は
該当する名前が何行目にあるかを探る関数です。 B2セルに　=SUMPRODUCT((D$2:H$100=A2)*ROW(D$2:H$100)) で　添付の場合では　２と表示されると思います。 あとは、空いているセルに 　１　　A 　４　　B 　７　　C ・・・ と対応表を準備しておいて =Vlookup(SUMPRODUCT((D$2:H$100=A2)*ROW(D$2:H100)),対応表の範囲,2,True) として下へコピーしてみてください。
>合計を個数で割れば単価が出て入力すれば問題ないのですが、都合上 それはできないです。 仕入伝票の資料ですよね。基本的に 単価＊個数＝合計 この関係を手修正してしまえば、台帳としての信頼性を失いますよ。 一案ですが、個数の隣に　単位　という列を準備して 　　単価　個数　単位　合計　とします。 単価不明の場合は 個数＝１　単位　Set　とかでは如何でしょうか。 あくまでも　G列（合計の式は） =IF(OR(E2="",F2=""),"",E2*F2)) の式で統一します。
文字列を数式に組み込む場合、"(ダブルクォーテーション)で囲む必要があります。 「 」かぎかっこみたいなものだって思えばいいのかな。 その中身が空なので、D5セル または D7セルに何も書いていないなら、何も書かない(長さ0の文字を返す) 逆にD5,D7セル両方とも書いてあるなら、D7/D5の計算しなさいってこと。 つまり、エラー処理も考慮した割合を求める数式ですね。
あたらこさんの使い方とちょっと違うかもしれませんが、こんなのでどうでしょう。 使い方は、まず、下記のMyMenuAddサブを実行します。これは最初に１回だけ実行すればOKです。これにより、右クリックのメニューに「魔法の張り付け」が追加されます（テンポラリなのでブックを閉じるとリセットされます）。 その後、コピー元（Sheet1)のデータ行をコピー。コピー先のシートの任意のセルを選択し、右クリックして「魔法の張り付け」をクリックすると見出し行（Sheet1の１～３行目）とコピーしたデータ行が縦にペーストされます。 Sub MyMenuAdd() Application.CommandBars("Cell").Reset With Application.CommandBars("Cell").Controls.Add(Before:=1, Temporary:=True) .Caption = "魔法の張り付け" .OnAction = "MyPaste" End With End Sub Private Sub MyPaste() On Error GoTo Fin Dim Target As Range Set Target = ActiveCell Target.Offset(0, 3).PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, _ SkipBlanks:=False, Transpose:=True Sheets("Sheet1").Range("1:3").Copy Target.PasteSpecial Paste:=xlPasteAll, Operation:=xlNone, _ SkipBlanks:=False, Transpose:=True Application.CutCopyMode = False Fin: Target.Select End Sub
＞A3の値の重複を確認したい場合D2:E3を指定範囲とし 関数を下へコピーしても D2セルは変更されたくない　と云う事？ =IF(ISNA(VLOOKUP(A3,D$2:E3,1,FALSE)),"","重複") と＄マークを付けます。
No.1 です。 > 右クリックした図形のみ上手くいきました。 > 他の図形は移動できませんでした。 マウスで右クリックした時、他の図形の選択が外れてしまったのだと思います。 マウスでの右クリックの代わりに、キーボードの右側の[Alt]キーと[Ctrl]キーの間にある「アプリケーション」キー または [Shift＋F10]のショートカットキーを押してみて下さい。 この方法なら、マウスで右クリックのように選択が外れるようなことはありません。 「Windowsキーボードの覚えておくと便利な特殊キーを15個紹介します！PrintScreenとかEscとか！」 http://jmatsuzaki.com/archives/13004
VBエディターは起動するのでしょうか？ Moduleを右クリック VBProjectのプロパティをクリック 保護のタブには？？
こんばんは！ オートフィルではなく、一気に数式を入れる方法ですが・・・ Dim lastRow As Long lastRow = Cells(Rows.Count, "B").End(xlUp).Row Range(Cells(5, "F"), Cells(lastRow, "F")).Formula = "=IF(COUNT(D5:E5)=2,D5*E5,"""")" としてみてはどうでしょうか？m(_ _)m
そのファイルだけ上書きできないのですよね。 書き込みたいファイルは確保しておいてくださいね。 DOS プロンプトを起動して該当のフォルダに入り、 DEL コマンドで一旦削除してみてください。 具体的には E:\data\excel.xlsx というファイルだとすると、 DOSプロンプト起動 xx> E: と入力 E:\> cd \data と入力 E:\data> del excel.xlsx と入力 無事に消せればエラーメッセージは出ません。 ファイル名にスペース(空白文字)がある場合は、 excel.xlsx の前後を " ダブルクオテーション で囲んでください 例. del "例です 空白があります.xlsx" この方法だとロックが回避できることがあります。 あとは、消したファイル名で保存です。
数式の速度改善の為には、どのような数式を使っていて、どのような結果が欲しいのか、根本的な部分が読み取れていないんです。 前回質問された時に添付された画像の荒さにより どのような結果が得たいのかわからない その回答に示されている2つの数式のどっちを使っているかによって 計算スピードが全く異なるってことです。 そこで、計算速度上昇の観点をやめ、別視点での案のがクエリーだったです。 項目が毎回異なるようなら使えませんが、すべてのデータを持ってくることが可能で、その際並び替えることもでき、そのデータは閉じるときに破棄も出来るのでファイルサイズは小さくなります それ以外にも問題点があるのでクエリー案は強く押すことはできないです。
Vlookup関数で別の列に表示してみては 　　A　　B　　C　　　D　　E　　　F　 品質　品揃え　単語　数値　品質　品揃え 　　　　　　　良い　　１ 　　　　　　　普通　　２ 　　　　　　　悪い　　３ とC,D列に対応表を準備します。 他にも色々とあるでしょうから対応表は必須でしょうね。 E2セルに =VLOOKUP(A2,$C$2:$D$4,2,FALSE) と入れて、隣へコピー 下へコピーしてみてください。
一例です。 １　　　1 2 3 4 5…2930 　　　出勤 公休 欠勤 特休 年休 ２　　　　　　　　　　　　　　　日　休　欠　　特　年 と２行目に、検索文字を入れておきます。 その下には　=COUNTIF($B3:$AF3,AG$3) と入れて右へコピー、下へコピーします。 ２行目は、通常非表示としておきます。 修正も簡単だと思いますが。
Workbook_BeforePrintイベントプロシャに書いちゃうっていう手もありますよ。（すいません。プログラムはNo.2さんのパクリです） Workbook_BeforePrintイベントプロシャは、印刷の指示を行った時、その印刷の前に実行されます。 ただし、これには致命的欠点があります。これだとSheet２を印刷しても補完してしまいます。 やっぱり、No.2さんのが正解ですね。 Private Sub Workbook_BeforePrint(Cancel As Boolean) Dim GYOU As Long Cancel = True 'Trueを設定すると印刷動作はキャンセルされます。テストが終ったらこの行は削除してください。 With Sheets("Sheet2") GYOU = .Range("A" & Rows.Count).End(xlUp).Row + 1 .Range("A" & GYOU).Value = Date .Range("B" & GYOU).Value = Range("A2").Value .Range("C" & GYOU).Value = Range("B2").Value .Range("D" & GYOU).Value = Range("C2").Value End With End Sub
ちょっと訂正いたします。 ＞変数宣言とSub ボタン1_Click()はどこに書いたらいいでしょうか？ ＞シートモジュールでしょうか？ ＞それとも標準モジュールでしょうか？ 標準モジュールに書きますが Declare Function GetAsyncKeyState Lib "User32.dll" (ByVal vKey As Long) As Long だけで十分です。 Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) は余計な部分をコピーしてしまいました。
＞ところでIF文も入れるとしたらどうなるのでしょうか？ 具体的な条件分岐が提示されていないので、何とも回答のしようがないのですが・・・ 仮にA1セルが空白だったらエラーになりますので Sub Sample3() Dim wS As Worksheet For Each wS In ThisWorkbook.Worksheets If wS.Range("A1") <> "" Then wS.Name = wS.Range("A1") End If Next wS End Sub といった具合になると思います。 ※　他にも同じSheet名は付けられないのでその回避の方法等々・・・ 色々な場合に使います。 これは結構面倒になりますので、今回は割愛します。 後はネット上でいくらでも検索が可能ですので、 調べてみてください。m(_ _)m
バージョンによって動作が異なる、という話もありますが Shift キーを押しながら ダブルクリックで開く。 これで、 Workbook_Open が実行されません。 これがダメなら 問題の ブックを開いておいて（見えませんが） 別のブックをダブルクリックで開く。 ２つのブックが見える状態になります。 Win7、 Office2010 SP2 で確認。
こんばんは！ 一例です。 ↓のコードを「集計.xls」Bookの標準モジュールにしてください。 Sub Sample1() Dim cnt As Long, myPath As String, myFile As String, wB As Workbook myPath = "保存場所のパス" & "\" myFile = Dir(myPath & "*.xls") Application.ScreenUpdating = False Do Until myFile = "" cnt = cnt + 1 With ThisWorkbook.Worksheets("Sheet1").Cells(cnt, "A") .Value = myFile Workbooks.Open (myPath & myFile) Set wB = ActiveWorkbook .Offset(, 1) = wB.Worksheets(1).Name .Offset(, 2) = wB.Worksheets(1).Range("A1") .Offset(, 3) = wB.Worksheets(1).Range("A2") .Offset(, 4) = wB.Worksheets(2).Name .Offset(, 5) = wB.Worksheets(2).Range("B1") .Offset(, 6) = wB.Worksheets(2).Range("B2") End With wB.Close savechanges:=False myFile = Dir() Loop Application.ScreenUpdating = True MsgBox "完了" End Sub ※　コード内の「保存場所のパス」の部分は実際の保存場所のフルパスに変更してください。 （プロパティの「場所」で確認できます） こんな感じではどうでしょうか？m(_ _)m
No.2・3です。 たびたびごめんなさい。 もっと簡単な数式で大丈夫です。 前回のコードは消去し ↓のコードに変更してください。 Sub Sample2() Dim i As Long, myRng As Range, wS As Worksheet Set wS = Worksheets("ｄａｔａ貼り付け") Set myRng = Range("G2").Resize(12) For i = 2 To 4448 Step 13 If myRng Is Nothing Then Set myRng = Cells(i, "G").Resize(12) Else Set myRng = Union(myRng, Cells(i, "G").Resize(12)) End If Next i myRng.Formula = "=VLOOKUP(A2&""_""&E2,ｄａｔａ貼り付け!A:L,8,FALSE)" End Sub どうも失礼しました。m(_ _)m
NO2です。 >フィルターオプション機能について、検討してみます。 フィルターオプションで抽出できるようになったら マクロの記録でマクロ化します。 メーカー名には入力規則のリストで ドロップダウンリストから選択するようにします。 後は、ボタンを押してフィルターオプションのマクロを実行するか ドロップダウンリストで変更したときにマクロが自動で実行されるように するか。 これで、だれでも使えるシートになります。
補足コメントより いくつのセルを結合しているかによります。 データがこわれるわけではないので、ご自分でやってみる事をお勧めします。 そうしないとスキルアップになりませんので。
単にA1セルの空白処理です 1900年１月１日の９０日以降は表示してねってこと。
こんばんは！ 画像の配置だとK2セルに =IF(J2="","",SUMPRODUCT((A$1:A$100=J2)*(B$1:F$100=I$2),C$1:G$100)) という数式を入れフィルハンドルで下へコピーしてみてください。 ※　SUMPRODUCT関数の参照範囲が 1列ずれているコトに気を付けてください。m(_ _)m
もう一つおまけですが、空いているセルに関数を入れておきます。 =SUMPRODUCT((F7:Z7>F12:Z12)*1) で７行目の数値が大きい場合の数がでますので VBAで、この答えを利用します。 If Rnage(関数のセル)>0 Then ２回に分けて計量する End If こちらの方がわかりやすかも。
Private Sub Worksheet_Change(ByVal Target As Range) If Target.Column = 1 Then Select Case Target.Value Case "a" Target.Offset(0, 1).Value = 500 Target.Offset(0, 2).Value = 800 Case "b" Target.Offset(0, 1).Value = 600 Target.Offset(0, 2).Value = 900 Case Else Target.Offset(0, 1).Value = "" Target.Offset(0, 2).Value = "" End Select End If End Sub となりますが 皆様ありがとうございます。ただ、何が書いてあるかチンプンカンプンで・・ ならば、採用しないでください。後々、苦労するのが見えています。 関数で 別シートに a 600　800 b　900　950 対応表を準備して Vlookup関数を　B列、C列に入れておく方が 後々、対応に変更があった場合に対応表を変更するだけですので 無難ではないでしょうか。
＞50名分のファイルを作成すればよいのかもしれませんが、集計したい商品が頻繁に増えますの・・・ マクロの前にデータの持ち方、入力の仕方などを改善された方が良いと思います。 初心者が陥る失敗で、元々のシート構成の間違いがあります。 この部分での訂正をしないと 限りなく複雑なマクロを組み続けることになります。
No.3ママチャリです。申し訳ありません。こまごまミスっておりました。 次の式で試してみて下さい。もし、これでダメなようであれば、hirobotさんが設定した式を補足あたりにアップしてください。確認してみます。 =AND(TODAY()>=EDATE(DATEVALUE($A2&"26日"),-1),TODAY()<=DATEVALUE($A2&"20日")) 念のため確認なのですが、A列の月は、文字として”１月”と入力されているのですよね？実際には日付（2016/1/1とか）が入力されていて、書式設定で１月と表示している訳ではないですよね？
一度整理してください。 ①　具体的なレイアウトはどのようになっているのか？ ②　Sheet1のどの列を検索し、挿入したい列はどこからどこまでの列なのか？ ③　Sheet2の「品名」列と行挿入数が表示されている列はどこなのか？ 小さくて見えにくいかもしれませんが↓の画像の配置で Sample4　を実行すると 画像上側のSheet1（左側）の配置が右側のようになります。 ※　1列・1行でも異なれば意図しない動きになりますので、 具体的なレイアウトが判らないといくらコードを載せても無意味になります。m(_ _)m
入れ違いになっていますが、こちらが確認したいのはエクセルのバージョンでした。 SUMIFSが使えないのは2003以前ですが、貴方のエクセルのバージョンはいくつですか？　SUMPRODUCT関数は配列関数なので、出来ればSUMIFSを使う方がいいのです。 >Ｚ列は１、Ａ列は初で固定なのですが、ＡＤだけ１～３が対象で >ＡＤの個数の合計を出したいのです。 これだと、貴方が作成した式はまた列が違っていますよ。 =SUMPRODUCT((A$3:$A$1938="初")*($Z$3:$Z$1938=1),(AD$3:$AD$1938)) ですかね。 わかりやすく簡単な列にして、かえって解決が遅れてしまいます。 何の列が何の項目か、正確に書いて下さい。
> 要は参照元のブック名やシート名が変わっても お勧めする訳じゃありませんが 複製した方を次の原本にしたらどうですか？ > 参照元であるBook1のシート「原本」をコピーしてシート「4月」を作成すれば そもそも何故シートを分けるのでしょう…… データをそのまま同じシートに入力し続ければいいでしょうに。 必要な情報だけにしたければ フィルタを掛けるなり数式で別シートに表示させ るなり どうとでもなるのですから ただ月が違うくらいのことで 流用するデー タを別シートに分けてしまうのはメリットが少ないように思います。
「祭日」がいつかなんて 国際的なソフトである Excelには分かりません。 話があいまいで何がしたいのかはよく分かりませんが 祝祭日一覧を別に 作成しておく必要が最低でもあるかと思います。
＃３です。 失礼！ 単純にシート１の該当月をコピーしてシート2にペーストすればいいのではないですか？
結合されている場合はF列の★も最初の行だけ、という事であれば。 Sheet2のA2 =INDEX(Sheet1!A:A,SMALL(INDEX(((Sheet1!$F$2:$F$1000<>"★"))*10000+ROW($A$2:$A$1000),),ROW(A1))) 右へB列と下へコピー A列とB列の書式は、ユーザー定義で　m/d;;　として下さい。
こんにちは iの値によって処理対象のシートを変えたいのであれば、ANo1様の回答のようにシートを配列に入れておいてもよいですが、ご質問のように単純なケースなら普通にif文で判断しても可能だと思います。 変数名を計算で算出することができないのはANo2様の回答の通りです。 そのような処理をやり易くするために、配列や連想配列が考え出されたのではないでしょうか。 Dim tmpWS As Worksheet ' ～～～～～～ '　　iの値を設定 '　～～～～～～ If i = 1 Then Set tmpWS = ws1 Else Set tmpWS = ws2 ' 以降はtmpWSを用いて処理を行う 　tmpWS.Cells(1, 1) = "*****" 行う処理が代入1回だけなら、もっとプリミティブでもよろしいかと。 （というか、これで済むくらいなら、iを設定するところで処理してしまえば、わざわざ後から分岐処理する必要もなくなりますね） If i = 1 Then 　 ws1.Cells(1, 1) = "*****" Else 　 ws2.Cells(1, 1) = "*****" End If
「ウィンドウ枠の固定」でなく、「ウィンドウの分割」を利用されたら如何かと。設定法は同じだけど、左(右)ウィンドウに這入ると右(左)ウィンドウが固定されます。左右２分割の場合ですね。 上下２分割、上下左右の４分割も出来る筈。 添付図は Excel 2013 の場合です。
fuhsyaさんはユーザ定義関数を理解できますか？ もし、少しでも理解できるのであれば、こんなのでどうでしょう。 まず、標準モジュールを追加して、下記のユーザ定義関数を張り付けます。 条件付き書式設定で、=MyFutoji()　と入力し、書式を太字に設定すれば、ご希望通りになるはずです。 Function MyFutoji() As Boolean Dim ws As Worksheet Dim Target As Range Set Target = Application.ThisCell Set ws = Target.Parent If Target.Row = 38 Then MyFutoji = True On Error GoTo Err_Fin If Target.Value + 1 = Sheets(ws.Index + 1).Cells(1, Target.Column).Value Then MyFutoji = False Exit Function End If Exit Function End If MyFutoji = False If Target.Value + 1 <> Target.Offset(1).Value Then MyFutoji = True Exit Function End If Err_Fin: Exit Function End Function
お考えの取り、条件付き書式を設定すればよいでしょう。 そして、後半の「一定範囲までいくと次のSheetに映らなければい」という条件も加えればよいと思います。 三つの条件のor、或いは条件を三つ指定してもよい。 ところで、後半の「一定範囲までいくと」の条件は何ですか? 行数であれば、それをカウントすれば良い。 月末であればそれを確認すれば良い。 次シートの特定セルに入力がある場合であればそれを確認すれば良い。
「ブック1.xlsm」のマクロを実行しているのであれば ThisWorkbook.Activate 他のブックのマクロなら Dim bk As Workbook Set bk = ActiveWorkbook ・・・・ bk.Activate
エクセルのフィルタ機能を使うのがよいと思います。 フィルタを使うのであれば消す必要はなく、フィルタ機能で表示されなくするだけでよいと思います。 ■手順(Windowsなので若干違うかも) １．データ範囲を全選択（データのあるセルを１つ選択した状態でCTRL+Aで全選択できます） ２．メニューから、データ　→　フィルタ ３．D列の最上行の▼マークをクリック　→　『NULL』のチェックをはずす　→　OKをクリック これで完了です。 空白を消したいということであれば、上記の手順3で『NULL』だけにチェックをつけてOKをクリック。表示されたセルを消去(削除)します。
まず、MicrosoftOfficeのソフトは、インストール自体はメディアがあれば可能です。 プロダクトキーというのは、正規品認証のためのコードです。 よって、製品を使用するにはメディアからインストール後、プロダクトキーにて 正規品であることをインターネットを通じてなどの手段で認証しなければなりません。 質問者様が手に入れたOfficeソフトは、価格、出荷元から類推して非正規品であると推察します。 プロダクトキーも添付されていたとして非正規のものである可能性が非常に高いです。 対処としては、今インストールしてあるOfficeをアンインストールすること オンラインで正規のプロダクトキー（製品）を購入することです。 また、可能であれば非正規の方のプロダクトキーをMicrosoftに報告すると良いでしょう。
>機種検索した時に必要な印刷範囲が表す事 とは、具体的にどのようなことなのでしょうか？ 例えば、あるセルに「B機種」と入力すると、その隣のセルに「点検表名①」、「点検表名③」、「点検表名④」と表示する？ それとも、あるセルに「B機種」と入力したら、該当する点検表①③④を印刷する？
３の処理で、該当の項目（16桁の数値）を指示書（ひな型）に張り付けていると思いますが、どのような方法で実装されていますか？ 数式であれば、TEXT関数で。マクロであれば、Format関数で16桁の文字に変換して、ひな型に張り付ければ良いと思います。
他の方からの回答を期待して、下記を補足願います。 ・やりたいことを、やる順序どおりに、短い文章で、具体的に、箇条書きで書いてください。 ・自分でいれたコードを記載してください。 下記以外にもありますが、わからないことが多いです。 >セルc7に入っている文字をsheet2で検索して、 セルc7のsheet名は何？ >縦にペーストしたいです。 何をペーストするのでしょうか？ >あればsheet1の1行(b7:r7)を1例に(縦)ペーストしたいです。sheet2に。 sheet2のどこに？
ん？　返したいのは番号ではなくて ラベルの方ですか？ =IFERROR(INDEX(A:A,SMALL(IF(B$2:D$6=A$10,ROW(B$2:D$6)),ROW(A1))),"") Ctrl + Shift + Enterで確定
「互換性がある」というのは「開いて使うことができる」という意味で しかありません。 動作を保証するものでも 何の問題も起きないことを 確約してくれるものでもありません。 > 新しいexcelはいつまでのものが互換性があるのでしょうか? 概ね古いバージョンについても「互換性」はあります。 > 廉価な類似ソフトも出回っておりますが互換性は如何でしょうか? 類似ソフトにもよりますが これも「互換性」はあります。ただし今後 のサポート上今日に逐一対応してくれるかどうかは微妙ですから 誰に も迷惑が掛からない環境以外ではお勧めしません。 というか問題が起きるかどうかを評価する為に プレビュー版が提供さ れているのですから 期限内に問題がないか試してみたらどうでしょう。 https://products.office.com/ja-jp/home?OCID=WIP_ …
テーブルの構造化参照になっているだけですね。 Excel2007以降 テーブル書式は基本中の基本の使い方なので必ず 勉強して使えるようになっておくべきだと思います。
通りがかりで失礼します。お酒も飲んだので・・・ 私がよく使う手ですが VBSで、WMPlayer.OCX　を操作します。 メモ等を開いて Dim wmp Set wmp = CreateObject("WMPlayer.OCX") wmp.settings.volume = 100 '音量設定 wmp.URL = "C:\Windows\Media\Alarm06.wav" '再生するwavファイルパス For i=1 To 5 wmp.Controls.play()'再生 Do WScript.sleep 5 Loop Until wmp.playState = 1 '停止迄待つ wmp.Controls.currentPosition = 0 '冒頭に巻き戻す Next を張り付けて、拡張子を .vbs　として保存 上記の例では、５回再生、ボリュームの設定も可能 こんなファイルを幾つか準備 エクセルからは Sub ボタン1_Click() Dim strPath As String Dim RetVal As Variant strPath = "パス\test.vbs" RetVal = Shell("WScript.exe """ & strPath & """") End Sub で希望のvbsファイルを実行させます。 他にも IEのBGMで音楽と映像（メッセージ）を流すとか・・ メモ帳開いて <html> <head> <title>アラーム</title> <bgsound src="C:\Windows\Media\Alarm06.wav" loop="5"> </head> <body> <marquee height="100" scrollamount="3" direction="up"> <FONT size="7"> <FONT color="red"> <Center> もう時間ですよ。 </body> </html> </marquee> 名前を付けて保存で 拡張子　.html クリックすると　IEが起動して、音楽が流れる。 繰り返し再生は　loop="infinite"
既に CEILING関数で回答が付いてますので蛇足ですが > IF、RIGHT、REPLACE、FIXED、ROUNDUP等いろいろ組み合わ > せてやってみたんですが、 考え方次第では CEILINGを知らなくてもできるはずです。 =ROUNDUP(B2*2,-1)/2
適当なフォルダにExcelブックを作って、そのブックの標準モジュールに、このプログラムコードを張り、一旦、保存します。 保存したExcelブックを開いて、マクロを実行すれば動きそうですね。 ただし、同じフォルダ内に、これとは別のExcelブックが存在しないと何も起こらないかもしれません。
No.1さん、No.2さんのおっしゃる通りだと思います。でも、面白そうなので作ってみました。 ppiroさんのイメージと、ちょっと違いますが、お暇なら試してみて下さい。 【仕様】 クラス番号を入力（または変更）すると、その生徒を該当クラスの箇所にリアルタイムで移動します。 下記の準備を行った後、名前、ID、クラスを入力してください。 ちなみに、クラスを入力（変更）したタイミングで移動が発生しますので、先にクラスを入力すると中途半端な状態で移動させてしまいます。クラスは最後に入力しましょう！！ コピペ等で複数セルが一挙に変更された場合、最初の生徒のみが移動対象となります。2番目以降の生徒は、一人ずつ手でクラスを入力して、移動させる必要があります。 【準備】 Sheet1の1行目を見出しと、次のように入力します。（見出しなので、文字は適当でもOKです） A1セル　名前 B1セル　ID C1セル　クラス１　※ここまでで、1クラス分です。このパターンで必要なだけ作成してください。 D1セル　名前 E1セル　ID F1セル　クラス2 　・ 　・ 　・ 次に、Sheet1のコードモジュールに次のコードを張り付けます。 Private Sub Worksheet_Change(ByVal Target As Range) Dim MyRange As Variant Dim Seito As Range For Each Seito In Target If Seito.Row <> 1 And _ Seito.Column Mod 3 = 0 Then MyRange = Seito.Address() Call MoveSeito(Seito) Range(MyRange).Select End If Exit For Next End Sub Public Sub MoveSeito(ByVal Target As Range) Dim FromRange As Range Dim ToRange As Range Dim ClassColumn As Long Dim I As Long Cells.Interior.Pattern = xlNone Set FromRange = Range(Target, Target.Offset(0, -2)) With FromRange.Interior .Pattern = xlSolid .PatternColorIndex = xlAutomatic .Color = 49407 .TintAndShade = 0 .PatternTintAndShade = 0 End With ClassColumn = Target.Value * 3 For I = 2 To Cells(Cells(Rows.Count, ClassColumn).End(xlUp).Row, ClassColumn).Row + 1 If Cells(I, ClassColumn).Offset(0, -1) = "" Or _ Cells(I, ClassColumn).Offset(0, -1) > Target.Offset(0, -1) Then Set ToRange = Cells(I, ClassColumn) Set ToRange = Range(ToRange, ToRange.Offset(0, -2)) Exit For End If Next I Application.EnableEvents = False FromRange.Copy ToRange.Insert Shift:=xlDown FromRange.Delete Shift:=xlUp Application.EnableEvents = True End Sub
ピボットテーブルは試されましたか？ 1行目に項目があるとして B~I列を選択して、挿入のリボンの ピボットテーブル 取りあえず、新規ワークシートでOKして次へ ピボットテーブルが出来たら 行には　B列の項目 値には　I列、値フィールドの設定で　合計　を選択すれば 一発ですし、次回から、ピボットテーブルの更新を 実行すれば、再集計してくれます。
フィルターオプションをマクロで実行する例です。 シート２に 　　A　　　　B １　クラス ２ ３　氏名　　　ID とA1セルと３行目に項目を入れておく シート名タブを右クリックして コードの表示 VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$A$2" Then Sheets("シート１").Columns("A:C").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("A1:A2"), _ CopyToRange:=Range("A3:B3"), Unique:=False End If End Sub を張り付けて閉じる。 A2セルに、クラス　１　とか　２とか入力すると ３行目以下にご希望の情報が抽出されます。
ＥＸＣＥＬで「ドロップダウンリスト」（または「プルダウンリスト」）とを作られたら簡単にできると思います。 「ドロップダウンリスト」の作り方は以下のサイトにアクセスしてください。 www.relief.jp/itnote/archives/001190.php
突っ込みどころ満載のコードですね。 致命的な問題点は、myNendoに値が入っていないことだと思います（myYearに代入されている？）。 それから、日付形式の整形時点で、filename は「平成28年度度02月試験」となっています。よって、WorkBook.SaveAsメソッドでは、余計な文字を結合する必要はないです。 正確な仕様が分からないので、間違っていたら申し訳ないのですが、次のようなコードでどうでしょうか。 Sub book保存() Dim strDate As String '文字型の日付 Dim varDate As Variant '内部形式の日付 Dim strPath As String Dim MyNendo As Long Dim MyMonth As Long Dim m strDate = Sheets("EHP検針").Range("A3") 'セルから文字を取得 strDate = Replace(strDate, "指定月度 ", "") '指定月度を削る strDate = Replace(strDate, "度", "") '度を削る varDate = DateValue(strDate) '内部形式の日付に変換 MyNendo = Format(varDate, "ee") '年度の取得 MyMonth = Format(varDate, "mm") '月の取得 strPath = Format(varDate, "gggee年度mm月試験") 'Path日付形式 If MyMonth < 10 Then strPath = "D:\テスト\" & strPath '9月までは「D:\テスト」へ Else strPath = "D:\kenshin\" & strPath '10月以降は「D:\kenshin」へ End If If Dir(strPath, vbDirectory) = "" Then m = 0 MsgBox "フォルダが存在しない。 " & strPath Else m = 1 Workbooks(2).SaveAs Filename:=strPath & "\test.xlsx" End If End Sub
最終行の取得としては、たとえば、 Dim LstRow As Long LstRow=Cells(Rows.Count,1).End(xlUp).Row で行けます。 つまり、A列の最終行から上に遡ってぶち当たる行、ということです。 同様に最終列の取得は、たとえば Dim LstCol As Long LstCol =Cells(1,Columns.Count).End(xlToLeft).Column で行けます。 １行目の最終列から左に遡ってぶち当たる列、ということです。 データの入力状況に応じて、上記の「A列」や、「１行目」のところはアレンジしてください。 それを踏まえて、ご質問の状況に当てはめれば、たとえば以下。 Dim Rng1 As Range, Rng2 As Range, LstRow As Long, LstCol As Long LstRow=Cells(Rows.Count,1).End(xlUp).Row　　　’最終行を変数LstRowに入れる LstCol =Cells(1,Columns.Count).End(xlToLeft).Column　’最終列を変数LstCol に入れる Set Rng1 = Range(Cells(5,1),Cells(LstRow,43)) 'A5～AQ最終行の範囲を変数Rng1に格納 Rng.Sort _ Key1:=Cells(5,2), Order1:=xlAscending,Header:=xlYes Set Rng2 = Range(Columns(6),Columns(LstCol)) 'F列から最終列の範囲を変数Rng2に格納 Rng2.ColumnWidth=12 Set Rng1=Nothing Set Rng2=Nothing とか。
アクティブセルって、選択されたセルの中で、 今まさに入力するセルの場所。単一セルです。 つまり、名前ボックスに表示されているセル（定義された名前を除く） で一つのセルしか存在しません 参考まで
マクロは全部書くようにして下さい。 多分bufという変数の定義が Dim buf As Long のような整数型になっているのだと思います。 Dim buf As Double にすれば解決するのではないでしょうか。
こんばんは！ すでに回答は出ていますので、参考程度で・・・ 標準モジュールです。 Sub Sample1() Dim i As Long, k As Long, myCol As Long Dim sN As String, wS As Worksheet, myFlg As Boolean Application.ScreenUpdating = False With Worksheets(1) myCol = .Cells(1, Columns.Count).End(xlToLeft).Column + 2 .Range("C:C").AdvancedFilter Action:=xlFilterCopy, copytorange:=.Cells(1, myCol), unique:=True .Columns(myCol).Sort key1:=.Cells(1, myCol), order1:=xlAscending, Header:=xlYes For i = 2 To .Cells(Rows.Count, myCol).End(xlUp).Row For k = 2 To Worksheets.Count If Worksheets(k).Name = .Cells(i, myCol) Then myFlg = True Exit For End If Next k If myFlg = False Then Worksheets.Add after:=Worksheets(Worksheets.Count) Worksheets(Worksheets.Count).Name = .Cells(i, myCol) End If sN = .Cells(i, myCol) Set wS = Worksheets(sN) myFlg = False wS.Move after:=Worksheets(i - 1) wS.Cells.Clear With .Range("A1").CurrentRegion .AutoFilter field:=3, Criteria1:=.Cells(i, myCol) .SpecialCells(xlCellTypeVisible).Copy wS.Range("A1") End With Next i .AutoFilterMode = False .Columns(myCol).Clear End With Application.ScreenUpdating = True End Sub こんな感じではどうでしょうか？m(_ _)m
>エクセルでセル高さをまとめて変えたいのです。 「まとめて」とは、つぎのどれですか。 任意のセルのみ?・・・これは不可能です。 ひとつの行のみ? 任意の複数行? シート全体? >（ひとつひとつなら変えられます） その操作手順を補足してください。 MS Excelなら、それが判れば、まとめて変更する方法を答えられそうです。
シート1!C2セルに =ISNA(MATCH(A2,シート2!A:A,0)) フィルハンドルダブルクリック シート2!C2セルに =ISNA(MATCH(A2,シート1!A:A,0)) フィルハンドルダブルクリック 同じものはどちらのシートでも良いのでFALSEを抽出してコピペ 違うのは各々のシートでTRUEを抽出してコピペ 上記の抽出を数式で行うのはかなり面倒なので、下記の続きはどうしてもなら考える D1セルに0 D2セルに=SUM(D1,C2*1) E1セルに0 E2セルに=SUM(E1,1-C2)
fnfnnis3さんの症状を調べてみました。 同じように困っている方がいるみたいです。 マイクロソフトの方が詳しく説明しています。 http://answers.microsoft.com/ja-jp/office/forum/ … こちらで解決できると良いですね！
No.4で、画像を添付し忘れました。 A列の値をC列で参照し、[セルの書式設定]で万単位風にしました。
>点滅後にマウスでスクロールすると白太矢印に変わってしまいます。 https://support.office.com/ja-jp/article/ScrollL … >fx部分に表示されるのはカーソル部分ではなく、そのセルの最初の行の文言が表示されます。 まさか、「32,767 文字」を超えているとか？ https://support.office.com/ja-jp/article/Excel-% … >スクロールさせなければ見えない位置までくるとカーソルの表示が消えてしまいます。 ならば「数式バーの「右端の✅」をクリック。数式バーを広げて、下端部分を下げればどうでしょう？
すみません。, が抜けてました。 ActiveSheet.ExportAsFixedFormat Type:=xlTypePDF, _ Filename:=Left(ThisWorkbook.FullName, InStrRev(ThisWorkbook.FullName, ".")) & "pdf"
失礼しました。パスの指定が不完全でした。これでどうでしょう。 Sub sample() Dim Fs, Fl, Fn, wb Set Fs = CreateObject("Scripting.FileSystemObject").GetFolder(ThisWorkbook.Path).Files For Each Fl In Fs Fn = ThisWorkbook.Path & "\" & Fl.Name If Right(Fn, 5) = ".xlsx" Then Set wb = Workbooks.Open(Fn) Fn = Left(Fn, Len(Fn) - 5) & ".xlsm" Application.DisplayAlerts = False wb.SaveAs Filename:=Fn, FileFormat:=xlOpenXMLWorkbookMacroEnabled wb.Close Application.DisplayAlerts = True End If Next End Sub
少なくともエクセルの機能にはありませんので マクロで作成することになります。 一案ですが 新規にエクセルのファイルを作成 セルにファイルがあるフォルダを記述しておく マクロボタンを押すと 指定したフォルダー内のエクセルファイルを順に開いて 名前を付けて保存 ファイルを閉じる 上記を繰り返す。 こんな感じをマクロを作ることになると思います。
こんばんは！ 一例です。 シートモジュールになります。 Private Sub Worksheet_Change(ByVal Target As Range) Dim lastRow As Long, c As Range, myRng As Range Dim kenmei As String If Target.Address = "$B$1" Then lastRow = Cells(Rows.Count, "B").End(xlUp).Row Set myRng = Range(Cells(2, "B"), Cells(lastRow, "B")) With Target Set c = myRng.Find(what:=.Value, LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then kenmei = c.Offset(, -1) End If End With MsgBox kenmei '←確認の意味// End If End Sub こんな感じではどうでしょうか？m(_ _)m
こんばんは！ すでに回答は出ていますので、 参考程度で・・・ 標準モジュールです。 Sub Sample1() Dim i As Long, j As Long, k As Long, lastRow As Long Dim sN As String, myStr As String, wS As Worksheet, myAry As Variant With Worksheets("条件") For i = 2 To .Cells(Rows.Count, "B").End(xlUp).Row sN = .Cells(i, "B") Set wS = Worksheets(sN) wS.Range("B:B").Interior.ColorIndex = xlNone If .Cells(i, "A") = 1 Then For j = 3 To .Cells(1, Columns.Count).End(xlToLeft).Column If .Cells(i, j) = "×" Then myStr = myStr & .Cells(1, j) & "," End If Next j If Len(myStr) > 0 Then myAry = Split(Left(myStr, Len(myStr) - 1), ",") If wS.Range("B2") = "" Then wS.Range("B2") = "ダミー" End If lastRow = wS.Cells(Rows.Count, "B").End(xlUp).Row For k = 0 To UBound(myAry) wS.Range("B:B").AutoFilter Field:=1, Criteria1:=myAry(k) If wS.Cells(Rows.Count, "B").End(xlUp).Row > 2 Then Range(wS.Cells(3, "B"), wS.Cells(lastRow, "B")).SpecialCells(xlCellTypeVisible).Interior.ColorIndex = 40 End If Next k wS.AutoFilterMode = False End If myStr = "" If wS.Range("B2") = "ダミー" Then wS.Range("B2").ClearContents End If End If Next i End With End Sub こんな感じではどうでしょうか？m(_ _)m
＞マクロを実行するような数式はありますか？ 残念ながらありませんので、考え方だけです。 マクロのイベントに　シートのChangeイベントがあります。 シート名を右クリック、コードの表示をクリックして VBエディターを起動 Private Sub Worksheet_Change(ByVal Target As Range) If Rnage("関数のセル").Value = "条件の値" Then ここに、実行したいマクロ End If End Sub こんな感じでは如何でしょうか。 シート上で変更が発生したら Private Sub Worksheet_Change　を実行します。
文章中の数式が前後して説明がおかしなことになっているので修正。 ■誤記■ ＞1日が土曜日であったことを無視すると、「７」からWEEKDAY関数で返ってきた値を引くと第一金曜日の「日にち」になることが分かると思う。 ＞=7-MOD(WEEKDAY(日付),7) ■訂正■ ＞1日が土曜日であったことを無視すると、「７」からWEEKDAY関数で返ってきた値を引くと第一金曜日の「日にち」になることが分かると思う。 ＞=7-WEEKDAY(日付) 読みにくい文章で申し訳ありません。
Personal.xlsb を使用してできませんかね。 どのブックからでも使用できます。 Personal xlsb でググった結果 https://www.google.co.jp/search?q=personal+xlsb& …
普通に時間を引き算すればよい。 そしてNo.1で示されているように「セルの表示形式」を「ユーザー定義」にして、[h]:mmを設定すれば時間は24を越えても表示できるようになる。 ※ "[ ]" がポイント。
こんばんは！ A列は14桁数値が羅列してあるだけですね？ VBAになりますが一例です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて） マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim lastRow As Long lastRow = Cells(Rows.Count, "A").End(xlUp).Row Application.ScreenUpdating = False Range("A:A").Insert With Range(Cells(2, "A"), Cells(lastRow, "A")) .Formula = "=DATE(LEFT(B2,4),MID(B2,5,2),MID(B2,7,2))+TIME(MID(B2,9,2),MID(B2,11,2),RIGHT(B2,2))" .Value = .Value .NumberFormatLocal = "yyyy.mm.dd.hh:mm" .Copy Range("B2") End With Range("A:A").Delete Range("A:A").Columns.AutoFit Application.ScreenUpdating = True End Sub 'この行まで// ※　14桁というコトは「秒」まで表示しようと思えば可能です。 ＞.NumberFormatLocal = "yyyy.mm.dd.hh:mm" の部分の表示形式で調整してみてください。m(_ _)m
何度も失礼して申し訳ありません。 >ファイル数が10ほど、それぞれシートが10以上あるので、時間がかかりそうですσ(^_^;) >通常業務以外の仕事なので、週末時間をとってやってみます。 No2の方がおっしゃり様に、手間がかかっても一枚のシートに纏める これが正解だと思います。 シートは （例）会社名｜商品番号｜商品名｜価格｜等の必要な項目を入れた後 が良いです。 ひたすコピー（Ctrl＋C)と貼付け（Ctrl+V)を繰り返して データを整理しましょう。 必要な検索だけでなく、オートフィルターなどを使って 必要な情報に絞り込んで表示させてなどいくらでも応用が出来 実務に使えるファイルになります。 たぶんに、最初からそうしておけば良かった だけだと思います。
Sub putCsv() Dim csvFile As Variant Dim fIdx As Integer Dim startLine As Integer Dim endLine As Integer csvFile = Application.GetOpenFilename(FileFilter:="ＣＳＶファイル,*.csv", MultiSelect:=True) startLine = Range("B65536").End(xlUp).Row If startLine <> 1 Then startLine = startLine + 1 End If For fIdx = 1 To UBound(csvFile) With ActiveSheet.QueryTables.Add(Connection:="TEXT;" & csvFile(fIdx), Destination:=Cells(startLine, "B")) .TextFileCommaDelimiter = True .Refresh BackgroundQuery:=False End With endLine = Range("B65536").End(xlUp).Row With Range(Cells(startLine, "A"), Cells(endLine, "A")) .Value = Dir(csvFile(fIdx)) End With startLine = endLine + 1 Next End Sub
[外部データの取りこみ]でテキストファイルを指定します。 [テキストファイルウィザード]を使い[列のデータ形式]を[日付]にすれば、 日付の列の区切り文字を変換して日付として認識できるようになります。 http://www11.plala.or.jp/koma_Excel/contents10/m …テキストファイルウィザード 貼り付けたものなら、列指定して[区切り位置指定ウィザード]で[日付]に すれば同じように変換してくれます。 http://www.relief.jp/itnote/archives/001908.php
そんな難しくない繰り返し構文なんですけど、なぜエラーになるかはわかりません。 Sub Sample4() 　Dim i As Long '変数の定義 正の整数 　For i = 2 To Worksheets.Count 'iに2を入れる。戻ってきたらi+1 　 　 '右からi番目のシートのE5セルに "=参考!H"に数字iをつなげた数式を入れる 　 　Worksheets(i).Range("E5").Formula = "=参考!H" & i 　Next i 'For i～まで戻る。iがワークシート数になったら抜ける End Sub 数式 =INDEX(参考!H2:H1000,LOOKUP(999,(RIGHT(CELL("filename",A1),{1,2,3})*1))) でも使えるならこれでも良いと思います。 シート名の右から１文字、2文字、3文字を拾ってきて、数値化(1を掛け算できる) 3つの中で桁数の多い数値を拾ってくる 拾ってきた数値をもとに参考!H2:H1000セル範囲から引っ張ってくる
最終的に、どのくらいの行が残る想定ですか？ もし、1048576を超える行が残る可能性があるのであれば、Excelでは効率が悪すぎると思います。 削除後の行数が30万行くらいになるのであれば、十分可能です。 削除前の行数、削除後の行数をどの程度と想定しているのか教えてください。
ツール→オプション→計算方法に、自動、手動という設定があるのでご確認ください。 エクセルの不具合ではなく、エクセルの使い方、でしょう。
こんにちは！ 両SheetともA列の並びは一緒なのですね？ Sheet1のB2セルに =IF(OR($A2="",B$1=""),"",INDEX(Sheet2!$A:$Z,ROW(),MATCH(B$1,Sheet2!$1:$1,0))) という数式を入れフィルハンドルで列・行方向にコピーしてみてください。 （Sheet2のセル全体を範囲指定しても良かったのですが、無意味のようなのでA～Z列を範囲としてみました） ※　両SheetのA列並びが異なる場合は =IF(OR($A2="",B$1=""),"",INDEX(Sheet2!$A:$Z,MATCH($A2,Sheet2!$A:$A,0),MATCH(B$1,Sheet2!$1:$1,0))) という数式にしてください。m(_ _)m
何故 VLOOKUP関数限定？ 誕生日がシリアル値で入力してあるなら ＝SUMIF(社員番号列,社員番号,誕生日列) でいいはずです。ある訳ないと思いますが 社員番号に重複はないもの としてます。
No.1です。 「AAA」のみ重複禁止なのですね？ 手っ取り早くVBAにしてみました。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて） データを入力してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) 'この行から// If Intersect(Target, Range("D4,D13")) Is Nothing Or Target.Count > 1 Then Exit Sub With Target If .Value = "AAA" Then If .Row = 4 Then If Range("D13") = .Value Then MsgBox "すでに入力済み" .Select .ClearContents End If Else If Range("D4") = .Value Then MsgBox "すでに入力済み" .Select .ClearContents End If End If End If End With End Sub 'この行まで// ※　簡単にできる方法があれば ごめんなさいね。m(_ _)m
> 作業中どこにアクティブセルをおいていても それを書かないと…… Dim rng As Range Set rng = ActiveCell Cells.Copy Cells.PasteSpecial Paste:=xlPasteValues Application.CutCopyMode = False rng.Activate Set rng = Nothing
I5セルに =IF(OR(G5<>"",H5<>""),INDEX(I:I,ROW()-1)+G5-H5,"") フィルハンドルダブルクリック 行の削除は対応します。
No.2です。 投稿後気づきました。 休憩時間は1時間と決まっているわけではなく、A3セルの値ですね？ ①の数式を =TEXT(Sheet1!A1,"h時m分～")&TEXT(Sheet1!A2,"h時m分")&TEXT(Sheet1!A2-Sheet1!A1-Sheet1!A3,"(h時間m分)") に変更してください。 どうも失礼しました。m(_ _)m
こんにちは！ =INT(A1/450000)*2 としてみてはどうでしょうか？m(_ _)m
一応こんな方法でもいいみたい。 B19:B20セルを選択して =IF($A19="","",INDEX(B6:B16,MATCH($A19,$A6:$A15,0)+{0;1})) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 右へオートフィル
$マークの位置がおかしくない？ 範囲もA列だけ？ =VLOOKUP(Sheet1!B1,Sheet2!$Ａ1$:$A10$,2,FALSE) は =VLOOKUP(Sheet1!B1,Sheet2!$Ａ$1:$B$10,2,FALSE) 答えは =VLOOKUP(Sheet1!B1,Sheet2!$Ａ$1:$B$10,2,FALSE)+1 ひょっとしたら =VLOOKUP(B1,Sheet2!Ａ:B,2,FALSE)+1 の事かも
ペイントでGIF形式で保存し、Excelで図の挿入 図ツール‐書式-色-透明色を指定 でなんとなくできたかな
例えば領収書を確実にパソコン上で発行することが出来るでしょうか？ 　どんなに優れたソフトでも偽造でないという証明はどう考えても不可能だと思います。 もしも誰かに領収書を偽造されたら貴方の貸した借金は全てチャラになります。ですからパソコン所で発行した判子入りの文章なんて何の意味もありません。
No.2の回答者さんの数式で可能だと思いますが、[入力規則]を設定する のに[ユーザー設定]ではなく[リスト]で使うほうが簡単だと思います。 [入力値の種類]を[リスト]にして、[元の値]で「H」のみを記載するだけで、 特定の文字のみにできると思います（大文字・小文字の区別もします）。 http://www.hitachi-solutions-west.co.jp/mail_mag … http://www.eurus.dti.ne.jp/~yoneyama/Excel/n-kis … [ドロップダウンリストから選択する]のチェックを入れれば、入力の手助け として楽に入力できます。[エラーメッセージ]などを設定しないでもわかり やすいと思いますよ。 ちなみに、[ユーザー設定]として[数式]を指定するのに別案もあります。 =B2="H" これでもExact関数と同じ結果になります。
こんにちは。 印刷範囲が設定されていると、プレビューではそれ以外の範囲がグレーアウトされた状態になります。 ご質問の状況は、多分、それではないかと推測します。 何らかの入力がある範囲を全て対象にしたければ、印刷範囲の設定をクリアしておけば宜しいと思います。 明示的に、プレビューの範囲を指定したければ、マクロの処理内で対象範囲は分かると思いますので、 　Worksheets().PageSetup.PrintArea で、新しい印刷範囲を再設定しておけば宜しいでしょう。
>ActiveWindow.SmallScroll Down:=-27 バージョンの違いなどで詳しくわかりませんが、 少なくとも上記以前の部分は(上記含め)不要です
拡張子がxlsxのファイルはExcel onlineで開きます。 そういう仕様です。 excelで開きたいときは、対象ファイルを右クリックして、「excelで開く」を選びます。
＞３００くらいある商品を、商品の種類ごとに１～５０の番号に自動で＞分類したいです。表１のフォーマットを縦横逆にする等、何か作り変＞える必要があるのでしょうか。 とにかく最初のシート構成を間違うと後から後から苦しくなります。 エクセルでも、データベースと云う考え方を最初からきちんと導入しましょう。 商品に対して分類番号を準備するシート 　　A 　　B 商品名　分類番号 ペン　　　　１ 鉛筆　　　　１ 消しゴム　　１ ・・・ といった構成です。 しかし、仕事を知るという事も重要です。 商品番号を重複しない番号を付けていくことをお勧めします。 　A　　　　B　　　 管理番号　商品名　 １００１　ペン　　　 １００２　鉛筆　　　 １００３　消しゴム　 ２００１　キウイ　　 ・・・ といった具合に準備しておくと後々の追加の作業に対しても 使えるはずです。 この場合　F3セルに入る関数は =LEFT(Index(A:A,MATCH(G3,B:B,FALSE)),1) 下へコピーします。
Sub コピペ() Range(Cells(1, 1), Cells(4, 1)).Copy Range(Cells(1, ActiveCell.Column), Cells(4, ActiveCell.Column)) Range(Cells(6, 1), Cells(10, 1)).Copy Range(Cells(6, ActiveCell.Column), Cells(10, ActiveCell.Column)) End Sub 2行目、3行目：前半がコピー元、後半がコピー先の範囲指定です。
No.1です。 ＞その列の１～３行目、それと5行目にテスト と入力したい場合 色んなやり方がありますが、 Sub Sample2() Dim j As Long j = Selection.Column Union(Range(Cells(1, j), Cells(3, j)), Cells(5, j)).Value = "テスト" End Sub こんな感じではどうでしょうか？m(_ _)m
問題はないですが、せっかくユーザ関数を作ったのに、セルに入力する式が複雑にしてしまっては意味がないです。 ユーザ関数内で対応した方がスマートです。こんな感じで。 Function MyWeekday(MyRange As Range, MyWeek As Variant, MyDay As Variant) As Variant Dim Rng As Range, wkWeek, wkDay MyWeekday = "" On Error GoTo Fin_Function wkWeek = 1 For Each Rng In MyRange wkDay = Weekday(Rng) If wkWeek = MyWeek And wkDay = MyDay Then MyWeekday = Rng Exit Function End If If wkDay = 7 Then wkWeek = wkWeek + 1 End If Next Fin_Function: End Function
標準の関数では難しいのではないでしょうか（少なくとも私には無理です） そこで、ユーザ定義関数を作りましょう。 下記のユーザ関数は、指定したカレンダ範囲の中から、第ｎ週のｍ曜日に該当する日付を返すものです。 具体的にはセルに、=MyWeekday("A2:A32",2,1) と指定するとA2~A32の中から第２週の日曜日に該当する日を返します。（セルの書式は日付型にしてください） ちなみに曜日は、日曜＝１、月＝２、･･･土＝７ で指定します。 Function MyWeekday(MyRange As Range, MyWeek As Variant, MyDay As Variant) As Variant Dim Rng As Range, wkWeek, wkDay MyWeekday = "" wkWeek = 1 For Each Rng In MyRange wkDay = Weekday(Rng) If wkWeek = MyWeek And wkDay = MyDay Then MyWeekday = Rng Exit Function End If If wkDay = 7 Then wkWeek = wkWeek + 1 End If Next End Function
次のように操作すれば、できるはずです。 ①入力済みのどこかのセルをクリックし、アクティブにします。 ②「並べ替えとフィルター」リボンから「ユーザ設定の並べ替え」を選択します。 ③「並べ替え」ウィンドウの「オプション」ボタンをクリックします。 ④「並べ替えオプション」ウィンドウの「方向」で「列単位」を選択し「OK」。 ⑤「並べ替え」ウィンドウで次のように次のように指定して「OK」 　「優先されるキー」→「行6」※今回の場合、合計行です。 　「順序」→降順
＞④"sheet2"のA１：G１０までの表で、A列が空欄の行全体を削除 で③で貼り付けた表が一部削除されてしまって良いのでしょうか？ 違うならこんな感じかなあ Sub Sample2() Dim SNo As Long Dim DLA As Long Dim n As Long For SNo = 1 To 10 　 　With Worksheets("Sheet" & SNo) 　 　n = 10 　 　For DLA = 10 To 1 Step -1 　 　　 　If .Range("A" & DLA) = "" Then 　 　　 　　 　.Range("A" & DLA & ":G" & DLA).Delete Shift:=xlUp ’① 　 　　 　　 　n = n - 1 　 　　 　End If 　 　Next DLA 　 　If n <> 0 Then 　 　　 　.Range("A1:G" & n).Sort Key1:=.Range("A1"), Order1:=xlAscending, Header:=xlGuess, _ 　 　　 　OrderCustom:=1, MatchCase:=False, Orientation:=xlTopToBottom, SortMethod _ 　 　　 　:=xlPinYin, DataOption1:=xlSortNormal ’② 　 　　 　Worksheets("Sheet" & SNo + 1).Range("H1:N" & n) = .Range("A1:G" & n).Value ’③ 　 　End If 　 　End With Next SNo End Sub
こんばんは！ Sub Sample1() Dim i As Long Application.ScreenUpdating = False Range("I:J").Insert For i = 10 To 20 Cells(i, "I") = Len(Cells(i, "E")) If Left(Cells(i, "E"), 1) Like "[A-Za-z]" Then Cells(i, "J") = Asc(Left(Cells(i, "E"), 1)) End If Next i Range("E10:J20").Sort _ key1:=Range("I10"), order1:=xlDescending, Header:=xlNo, _ key2:=Range("J10"), order1:=xlAscending, Header:=xlNo Range("I:J").Delete Application.ScreenUpdating = True End Sub ※　細かい検証はしていませんので 不具合が出たらごめんなさい。m(_ _)m
No.2ママチャリです。 リストのA4の行が入力済み(最終行)の場合、次の行に転記するようにしたのですが、仕様の理解が間違っていたらゴメンナサイ。 リストの4行目以降をクリアしてから実行すれば、A4に転記できるようにしたつもりなのですが…。
記載されているプログラムコードの他に、プログラムコードはありませんか？ 特に、ThisWorkbookオブジェクトのWorkbook_BeforeCloseイベントプロシジャあたりに･･･。
INDEX(範囲,行番号,列番号,領域番号) と MATCH(検査値,検査範囲,照合の型) でやってみました D7セルに =IF(C7="","",MATCH(C7,INDEX(($B$3:$F$4,$G$3:$K$4,$L$3:$P$4,$Q$3:$U$4), MATCH(B7,$A$3:$A$4,0),,MATCH(A7,{"男性t","男性ｙ","女性t","女性y"},0)))) 入力の単位が0.1刻みの条件付きです。
私には質問内容が理解できないサッパリポンなのに、回答を寄せられている tom04さんも CoalTarさんも凄い！ 【独白】読解力が落ちたのかなぁ～
[No.2]にまたまたまた間違い発見、次のように訂正します。今度こそ最終版！ Q2: =INDEX(C$1:N$1,MATCH(1,1/(C2:N2>0),0)) 【お断り】この式は配列数式として入力
そのExcel2003はパソコンを買った時の付属品でしょうか？ 付属していた物であれば「付属していたパソコン」以外は使用禁止です。 パソコンとは別に単独で購入した物であれば2台まで可能。 　　　 しかし2003のサポートは切れています、セキュリティーも危険状態。 新しいOfficeを買って下さい。
こんにちは！ No.1さんが回答されているように作業用の列を設けるのが無難だと思います。 （一気にやるとしてもかなり長い数式になり、修正が大変ですので） 一例です。 ↓の画像のように毎回の取得ポイントを他の列に表示させておけば簡単にできます。 画像ではK4セルに =IF(I4="","",ROUNDDOWN(I4/10000,1)+IF(D4="新規",5,3)) としておき J4セルに =IF(OR(E4="",COUNTIF(E:E,E4)<>COUNTIF(E$4:E4,E4)),"",SUMIF(E:E,E4,K:K)) という数式を入れ J4・K4セルを範囲指定　→　K4セルのフィルハンドルで下へコピー！ これで画像のような感じになります。 ※　E列の並びがバラバラでも大丈夫です。m(_ _)m
こんな感じでしょうか。 該当のシートがアクティブな状態で、下記のマクロを実行してください。 実際にプリントする際は、PrintPreview → PrintOut に修正してください。 Sub subPrint() Dim ws As Worksheet Dim PrintRow As Long Set ws = ActiveSheet For PrintRow = 3 To 51 If ws.Range("M" & PrintRow) = "○" Then ws.Range("A1") = ws.Range("O" & PrintRow) ws.Range("L3") = ws.Range("S" & PrintRow) Calculate ws.Range("A1:J64").PrintPreview End If Next PrintRow End Sub
No.2です。 うまくいかなかったようなので・・・ おそらく配列数式になっていないのではないか？と思われます。 あまり難しくせずに別案です。 ↓の画像のように作業用の列を設けてみてはどうでしょうか？ 画像ではSheet1のH2セルに =IF(B2=Sheet2!H$2,ROW(),"") という数式を入れずぃ～～～！っと下へフィル＆コピーしています。 （これ以上データは増えない！というくらいまでしっかり下へコピーしておいた方が良いと思います） そしてSheet2のA2セルに =IFERROR(INDEX(Sheet1!A:A,SMALL(Sheet1!$H:$H,ROW(A1))),"") という数式を入れ、列・行方向にフィルハンドルでコピー！ A列日付は好みの表示形式に整えます。 これで画像のような感じになります。 前回回答したように、元データが空白の場合は「0」が表示されてしまいますので 「ゼロ値」をひょうじしないようにするか、 A列に数式はそのままで、別途B2の数式を =IFERROR(INDEX(Sheet1!B:B,SMALL(Sheet1!$H:$H,ROW(A1)))&"","") とし、F2までフィルハンドルでコピー！ 最後にA2～F2セルを範囲指定　→　F2セルのフィルハンドルで下へコピー！ これでも「0」は表示されません。 こんどはどうでしょうか？m(_ _)m
Excel 2007 以降をお使いなら、 下図のセルF2、G2、H2 に次の数式を挿入して、下にオートフィルコピーして下さい。 F2　=SUMIF($A$2:$A$7,E2,$B$2:$B$7) G2　=SUMIFS($B$2:$B$7,$A$2:$A$7,E2,$C$2:$C$7,"A") H3　=SUMIFS($B$2:$B$7,$A$2:$A$7,E2,$C$2:$C$7,"B")
印刷できないシートですが、個別に印刷してもダメなのでしょうか？ 印刷できないシートの用紙サイズって、何になっていますか？（印刷できるシートは？） ブック全体印刷で、ページ指定（例えば、4~８ページ）とかになっていませんよね？
ThisWorkbookオブジェクトの下のWorkbook_BeforeCloseイベントプロシジャに、次のコードを書いてください。 Private Sub Workbook_BeforeClose(Cancel As Boolean) Sheets("e").Copy ActiveWorkbook.ActiveSheet.Name = "z" ActiveWorkbook.SaveAs Filename:= _ "C:\参照フォルダ\z.xls", FileFormat:=xlExcel8, _ Password:="", WriteResPassword:="", ReadOnlyRecommended:=False, _ CreateBackup:=False ActiveWindow.Close End Sub
No.4です。d-q-t-pさんの案より =IF(MOD(A1*10^3,10)=5,ROUND(A1/2,2)*2,ROUND(A1,2)) でもよさそう。小数点誤差までは検証してないけど、 たぶん、d-q-t-pさんは小数点誤差も考えていられる。 >検証してみたところ、やはり一部で結果が奇数となってしまうようです・・・ その一部の希望とかなわない数値を示していただかないと改善できませ～ん
冗長ですが、 Sub 納品書印刷2() 　Dim myRow As Long 　Dim AKS As Worksheet 　Set AKS = ActiveSheet 　For myRow = 7 To Cells(Rows.Count, 18).End(xlUp).Row 　 　If Cells(myRow, 18).Value = "●" Then 　 　 　Sheets(Cells(myRow, 17).Value).Select 　 　 　calculate 　 　 　ActiveWindow.SelectedSheets.PrintOut 　 　 　AKS.Select 　 　End If 　Next myRow End Sub としてみるとか(地震ないけど) 他には繰り返し構文の前にプレビューを入れてみるとか
No.2・3です。 もう一度「お礼欄」をじっくり読み返してみました。 どうしても質問にあるコードの ＞c.Offset(, 2) が引っかかるのですが、 ＞wS2.Range(c.Offset(, 2)) = Target の行が ＞wS2.Range(c).End(xlDown).Offset(1) = Target というコトでしょうか？ これであれば、シート3のB列セル番地を取得し、シート2のそのセルから下へ検索していき データがある最終行の下のセルに「Target」が表示されます。 ※　対象セルもしくはその1行下にデータがない場合はエラーになりますので、 エラー処理のためにもう一つ変数を追加し Private Sub Worksheet_Change(ByVal Target As Range) Dim c As Range, r As Range Dim wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("シート2") Set wS3 = Worksheets("シート3") With Target If .Count > 1 Or .Value = "" Then Exit Sub Set c = wS3.Range("B:B").Find(what:=.Address(False, False), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then Set r = wS2.Range(c) If r = "" Then r = .Value ElseIf r.Offset(1) = "" Then r.Offset(1) = .Value Else r.End(xlDown).Offset(1) = .Value End If End If End With End Sub こんな感じをお望みだったのでしょうか？m(_ _)m
下記をご参考ください。
こんな感じでどうでしょう。 Sheets("Sheet1").Range("A3").CurrentRegion.Cells.Copy Sheets("もともとあるシート名").Range("A3").PasteSpecial Paste:=xlPasteValues, _ Operation:=xlNone, SkipBlanks:=False, Transpose:=False もし、「もともとあるシート」の方が広い範囲を使っていて、今回コピーする範囲の方が小さい場合、はみ出した部分が残ってしまいます。事前に「もともとあるシート」の内容をクリアしておいた方が良いかもしれません。 Sheets("もともとあるシート名").Cells.Clear
「条件付き書式」の「ユーザー書式」にて対応可能。（「新しいルール」などで作ることができる） 条件に数式を設定して、書式を指定すれば良い。 数式は前の回答者さんたちが答えてくれています。
今回の場合は、別シートに抽出するよりもフィルタ機能を使うほうがよいと思います。（一般的です） <手順> １．データの見出し行(見出し行がなければ最上行の一つ上の行)を選択 ２．メニュー　→　データ　→　フィルタ ３．フィルタを掛けたい列（Ｂ列）の▼マークをクリック ４．表示したい商品のみチェックをつける 　　（商品A,B,Cにチェックをつけて、他の商品のチェックをはずす） ５．必要に応じて手順４を繰り返す 　　（商品D,E,Fにチェックをつけて、他の商品のチェックをはずす）
ANo2です。 間違えた説明記述をしてしまいました。訂正です。 誤：『各列について、７行目以降の合計値が0ならその行を削除』 　　　　　　　↓　↓　↓ 正：『各列について、７行目以降の合計値が0ならその列を削除』
>足の文字数に制限があってこれ以上答えられなくなりました。 今までのことを整理し、リンクを張り、画像も明瞭なものにして 質問し直してはどうでしょうか？ ちなみに、回答で .Range("A1:J64").PrintPreview としているので、そのまま印刷せずに閉じれば次の行の処理に移ります。
0の加算を除く必要がないからSUMIFはいらなかったですね(^^; INDEX案 =SUM(INDEX(A:A,(C2-1)*35+1):INDEX(A:A,(C2*35)))/COUNTIF(INDEX(A:A,(C2-1)*35+1):INDEX(A:A,(C2*35)),">0") 参考まで
売上データから納品書を作成されるのですよね。 エクセルのフィルターオプションの機能を使います。 便利にするために、マクロの記録からVBAを作成します。 詳しくは http://www.eurus.dti.ne.jp/~yoneyama/Excel/filte … を参考にして下さい。 画像が見にくいので、一例ですが 　A 　　B　　　　C　　D　　E　　F 販売日　客先名　品名　数量　単価　金額 と一行目に項目を入れて２行からデータを入れていきます。 納品書シートに 　A　　　　B　　　　 客先名　　販売日　　 Aさん　　2016/2/1 販売日　品名　数量　単価　金額 と納品書シートを準備して 客先名と納品書を作成する日付を入れるセルを準備 あとは、上記サイトの手順でフィルターオプションの操作で 希望するデータが抽出されます。 あとは、マクロの記録で、フィルターオプションをマクロ化 ボタンを配置して実行すれば、簡単に、希望する納品書が作成できます。
> Excelで作成した表を印刷しようとすると、One Noteを起動しないと印刷出来ないと表示 「通常使うプリンター」として「OneNoteに送る」または「Send To OneNote」が設定されています。 下記URLのページをご覧になって、お使いになっているプリンターを「通常使うプリンター」に設定してみて下さい。 「印刷時にOneNoteが起動する場合の対処方法」 https://121ware.com/qasearch/1007/app/servlet/re …
>シートＡに反映したいのですが この部分の説明がないので、各シートのP列に入れる部分だけです。 シートＡのB5セルは、書式をユーザー定義で　0"月"　として数値だけを入力して下さい。 標準モジュールです。 Sub Sample() Dim tuki As Variant Dim sh As Worksheet Application.ScreenUpdating = False tuki = Worksheets("SheetA").Range("B5").Value If tuki = "" Then MsgBox "月が入力されていません" Exit Sub End If For Each sh In Worksheets With sh If .Name <> "SheetA" Then .Activate .Range(Cells(3, 5), Cells(58, 5)).Copy Destination:=.Range("P3") End If End With Next sh Application.ScreenUpdating = True Worksheets("SheetA").Select End Sub
他の回答にもあるように、ウィンドウズ版のExcelが他の表計算シートとの 互換性があるように設計したためですね。（Lotus 1-2-3との互換性） https://support.microsoft.com/ja-jp/kb/214058 http://www.724685.com/word/wd140917.htm なので、1900/3/1以降なら曜日なども正しく表示されますが、これ以前は 間違った答えが表示されます。 http://www.eurus.dti.ne.jp/~yoneyama/Excel/waza/ … http://www4.synapse.ne.jp/yone/excel2010/faq/kei … こういったやり取りは、様々なところでも質問されています。 その回答を見ると、Excelの仕様が違うところも認識出ますね。 http://answers.microsoft.com/ja-jp/office/forum/ … 閏年を計算するのに簡単だった1904/1/1で作成された初代のMac版 Excelを受け継いでいればなら、このような問題も起きません。 http://pc.nikkeibp.co.jp/article/NPC/20070626/27 …
Excelヘルプを紐解けば、諄いは説明不要！
No.1です。ちょっと改良 作業列 G2セルに 0 特定行の個数を数える。G3セルに =IF(MOD(ROW(),4)=3,SUM(COUNTA(B3:F3),G2),G2) 下へオートフィル 参考値。M3セルに =MATCH(I3-1,$G$2:$G$16) 時刻を引っ張ってくる。J3セルに =IF($G$17<$I3,"",INDEX($A$2:$A$16,MATCH($I3-1,$G$2:$G$16))) 室を引っ張ってくる。K3セル =IF($J3="","",INDEX($B$2:$F$17,MATCH($I3-1,$G$2:$G$16),COUNTIF($J$3:$J3,$J3))) ※「室」置換するなら=IF(J3="","",SUBSTITUTE(INDEX($B$2:$F$16,MATCH(I3,$G$2:$G$16),COUNTIF(J$3:J3,J3)),"室","",1)) L3セル =IF($J3="","",INDEX($B$3:$F$17,MATCH($I3-1,$G$2:$G$16),COUNTIF($J$3:$J3,$J3))) J3:M3セルを下へオートフィル I:M列を切り取ってSheet2に貼り付け 以上。
ピボットテーブルで集計すればいいかと思います。 > 初心者なのでよくわかりませんでした。 困っていることだけ調べようとせずに 初心者ならまずは基本的な 使い方を まんべんなく勉強された方がいいと思います。
数式案です。 まず、Sheet2のエラーコードの範囲を可変にし、名前を付ける Sheet2において[Ctrl]+[F3]名前の定義 名前ErrCode 参照範囲 =Sheet2!$A$2:INDEX(Sheet2!$A:$A,COUNTA(Sheet2!$A:$A)) Sheet1!G2セルに =SUMPRODUCT(COUNTIF(B2:F2,ErrCode)) 下へオートフィル Sheet1!B2:F5セル範囲をB2セルから選択して [Alt]+[O]→[D]条件付き書式 数式が▼ =MATCH(B2,ErrCode,0)
=IF(ISNA(INDEX(A3:A40,MATCH(1,H3:H40,0))),"",INDEX(A3:A40,MATCH(1,H3:H40,0)))
当方では添付図のようなことは再現できませんでした(XL2003) エクセル2010基本講座：集計(小計)の使い方 http://www4.synapse.ne.jp/yone/excel2010/excel20 …
正規分布において、約３分の２がその範囲内に入るとのこと。 平均と標準偏差 http://www.cap.or.jp/~toukei/kandokoro/html/14/1 …
C9セルには =10+20+30+40 D9セルにも =10+20+30+40 以下同様。 C10セルには ＝50 D10セルにも ＝50 以下同様。 黄色（12行目）は、いつ在庫を使い、いつ補充したかが不明なため作成できない。
①　印刷したいエクセルシートを別のエクセルシートに画像をトリミングという方法を使ってコピーします。 ②　そして不要な部分をトリミングして印刷すればＯＫです。 注記　エクセル画面で、メニュー「ファイル」から印刷する方法では、あなたが望むことは出来ません。 詳細は、以下のアドレスにて確認してください。 www.excelist.net/tips/07.html
画像ではよくわからないのですが、次の行の　syuukei_　の前に空白がひとつ入ってしまっていました。ごめんなさい。 誤）If Left(st.Name,8) = " syuukei_" then 正）If Left(st.Name,8) = "syuukei_" then それでもだめなら、画像ではなく、プログラムコードをペーストしてください。
0000のように0が4つつながった時、000は1と数えるのでしょうか？2と数えるのでしょうか？ 前者 =(LEN(A1)-LEN(SUBSTITUTE(A1,B1,"")))/LEN(B1) 後者 =COUNT(1/(MID($A$1,ROW($A$1:INDEX(A:A,LEN($A$1))),LEN(B1))=B1)) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる ただし、A1セル、B1セルともに文字列(数字)であること
在庫の計算方法は 入荷数の合計ー出荷数の合計＝在庫　です。 SUMIF関数などを使いますが =SUMIF(取り外し車両!品名の列＝希望の品名,入庫数) -SUMIF(取り付け車両!品名の列＝希望の品名,出庫数) といった式になります。
Excelで複数の条件に合致する値を別ブックに返したい https://oshiete.goo.ne.jp/qa/9173729.html
こんにちは！ ↓の画像で説明します。 C列のキーワードの範囲指定する場合は空白セルを範囲指定しないようにします。 そのために今後キーワードが増えても対応できるように「＊」アスタリクスで埋めています。 B2セルに =IF(OR(ISNUMBER(FIND(C$1:C$10,A2))),INDEX(C$1:C$10,SUMPRODUCT(ISNUMBER(FIND(C$1:C$10,A2))*ROW(C$1:C$10))),"") 配列数式になりますので、Ctrl＋Shift＋Enterで確定！　→　フィルハンドルで下へコピー！ これで画像のような感じになります。 ※　条件として、A列文字列にキーワードは複数含まれない！というのが大前提です。 仮に「青白い光」のようにキーワードが複数ある場合は とんでもない結果になります。m(_ _)m
こんにちは ANo6様の案に似ていますが、「入力用の表」だけで済ませてしまおうというアイデアです。 まず、 ＞=TODAY()と、今日の日付を表示しています。それ以降の日付は=B2+1等としています。 については、お気づきのように諸問題の原因なので、これはやめましょう。 準備として、2行目（全体）の表示形式を日付にしておきます（年月日でも月日でも好きな形式で良いです）。 B2に（例えば）2016/02/15と入力して、B2を選択してフィルハンドルを右に動かせば翌日、翌々日・・となるはず。 （うまくいかない場合は、2つのセルを選択するか又はctrキーを押しながらでできるはず） 曜日はC3に =MID("日月火水木金土", WEEKDAY(B2),1)　と式を入れて、やはり右にフィルコピーです。 未入力の日を新しく追加したい場合は、日付、曜日の2セルを選択して右へフィルコピーすれば追加できますね。 日曜、土曜などを色で表示したい場合は、３行目（全体に）条件付き書式で設定しましょう。 （本題でないので説明は省略しますが、意味不明の場合は検索してみてください。） ここまでで、何か月でも対応可能な表の準備ができました。 さて、ご質問の内容は「この表を２列目に今日が表示されるようになさりたい」ということだと思いますが、いくつかの方法が考えられます。 以下に何種類か記しますが、いずれも簡単なマクロにしてブックのオープン時に自動実行することも可能です。 でも、多分、手動でも問題ないと想像しますので、手動の方法として記しておきます。 ◆方法１ 昨日までのデータは必要ないのであれば、新しく開いた時にB列（昨日の列）を削除する。 （1日1回操作が必要） ◆方法２ 表示上で過去の分は非表示にする。（列を選択して右クリック→非表示） （1日1回操作が必要。古いデータは再表示すれば見られます。） （たくさんデータが溜まったら、古い部分を消去するか、別のブックに移すなど） ◆方法３（多分、これが宜しいのではと思います） B1セルを選択した状態で、表示→ウィンドウ枠の固定でＡ列の表示を固定 （左右にスクロールしても常にA列が表示されている状態になります） 古いデータもそのままスクロールで見ることができます。 （たくさんデータが溜まったら、古い部分を消去するか、別のブックに移すなど） ※ 横に長い表になるので、『「今日」がどこか一目でわかるようにしたい』という要求がでてくるかも知れませんね。 　これも、上で触れた「条件付き書式」で可能です。 　例えば、日付（２行目全体を選択）で、ホーム→条件付き書式→セルの強調表示ルール→日付で、今日に当たる日付に対して書式を設定しておくと、今日の部分がその書式で表示されます。（背景色の指定や文字表示をboldにするとか） ※ 上でも述べましたが、これらの方法はマクロにして自動化することも可能ですが、多分、手動でも良いのではないかと想像しました。
=INDEX(A:A,SMALL((MMULT((B$2:I$2-"2016/2/15">=0)*(B$2:I$2-"2016/2/18"<=0)*(B$4:I$14=1),1^ROW(A$1:A$8))=0)*15+ROW(A$4:A$14),ROW(A1)))&"" Ctrl + Shift + Enterで確定 理屈がさっぱり分からないようなら 表自体を考え直した方がいいと思 います。
元データが一行目の項目で２行目以下にデータがなるのであれば フィルターオプションを使って別シートへデータを抽出 再度、フィルターオプションで重複の削除を行っては如何でしょうか。 詳しくは http://www.eurus.dti.ne.jp/~yoneyama/Excel/filte … などを参考にして下さい。 抽出するシートに 　　　A １　抽出条件の項目 ２　条件 ３ ４　抽出する項目 ５ と準備します。
＞Training一覧にある「年」「月」「日」を"/"で結合して日付化してるのですが、これがご指摘の「文字列になっている」ということと同義でしょうか？ 「＆」で結合したら、文字列になります。 この場合の解決方法がNo.1の回答に示されています。 ＞＞=Vlookup(検索値,範囲,列番号,検索の型)*1 この「*1」がそれです。 Excelでは文字列で記述された「数値と見なせる値」に「０（ゼロ）」を加減算したり「１」を乗除算すると文字列から数値に変わると言うものです。 ＝"20"&"16" は、"2016"という文字列ですが、 ＝("20"&"16")*1 は、2016と言う数値になります。 ="平成27年"&"2月"&"15日" は文字列になりますが、 =("平成27年"&"2月"&"15日")*1 は日付を示す数値（シリアル値）になります。
sheet1に、 A1セル＝1、A2セル＝2、A3セル＝3 と入力します。 sheet2に、 A1セル＝1、A2セル＝2、A3セル＝3 と入力します。 B1セル＝1C、B2セル＝2C、B3セル＝3C と入力します。 最後にsheet1に、 B1セル=VLOOKUP(A1,Sheet2!A:B,2,FALSE) B2セル=VLOOKUP(A2,Sheet2!A:B,2,FALSE) B3セル=VLOOKUP(A3,Sheet2!A:B,2,FALSE) と入力します。
> 原因や対処法をご存じの方 セル番地と混同されるような名称は不可です。
仕事で使うと用途が限られるため、使う構文も決まって来ます。同じコードを何度も書くと、自然とそのコードはすらすら書けるようになります。 あーかったるい、毎回毎回同じじゃねーかと思うようになったら、引数付きSubとして独立させましょう。構造化プログラミングですよ。 調べものは専らネットです。Googleとお友だち、師匠はoffice Tanakaとmoug、MSDNは教典です。コピペは私もしますが、内容理解は後追いでもいいからすべきです。 コード書き 我々片手間プログラマは、マクロ作成が本業ではありません。コード書いてる間に手作業で終わってしまったら、どうなるでしょう？給料泥棒です。常に時間対効果を気にしつつ作成する必要があります。初心者のうちは自宅でやることを勧めます。私もコーディングは自宅、業務中は動作確認です。
=IF(A1<1　,TEXT(A1,"0.00")　,IF(A1<10　,TEXT(A1,"0.0")　,A1)　) 「1より小さい」の条件が成立していなければ、そのまま「10より小さい」の条件で比較。
こんばんは！ 「シートA」はシート見出しの一番左にあるという前提です。 標準モジュールにしてください。 Sub Sample1() Dim k As Long, c As Range, wS As Worksheet, myFlg As Boolean Set wS = Worksheets(1) For k = 2 To Worksheets.Count With Worksheets(k) Set c = .Cells.Find(what:=wS.Range("D15"), LookIn:=xlValues, lookat:=xlPart) If Not c Is Nothing Then myFlg = True .Activate c.Select Exit Sub End If End With Next k If myFlg = False Then MsgBox "該当データなし" End If End Sub こんな感じではどうでしょうか？m(_ _)m
＞52年に一度は同じ数字が割り当てられることになります これは更に１３を引くのではないですか？
作業の流れですが １、売り上げシートで行を選択 ２、納品書シートに移動して ３、ボタンをクリック ４、売り上げシートに戻り、次の行の選択 この作業が手間ではないでしょうか？ 一案ですが 売り上げシートのシート名のタブを右クリック コードの表示をクリックして　VBエディターを起動 以下を張り付けて閉じる。 Private Sub Worksheet_SelectionChange(ByVal Target As Range) Sheets("納品書").Range("F1").Value = Selection.Row End Sub これで、売り上げシートで選択範囲を変更したら 納品書のシートのF1セルに、選択した範囲の最初の行番号が出ます。 納品書のシート B2　=INDEX(売上データ!A:A,F1) C3　=INDEX(売上データ!B:B,F1) C4　=INDEX(売上データ!C:C,F1) C5　=INDEX(売上データ!D:D,F1) と入れておけば、ご希望のデータが表示されると思います。 あと、必要であれば、売り上げデータのシート上にボタンを配置 Sub ボタン1_Click() Sheets("納品書").Range("A1:D10").PrintPreview End Sub ボタンをクリックして印刷 こうしておくと、 １、行の選択 ２、印刷ボタンのクリック の作業だけで済みます。 VBAも関数と組み合わせることで、最小限の使用になります。
ご希望通り並ぶようにしてみました。色も付きます。 シート名は、以下のように正確に設定してください。 1点だけ命名規約を変えさせて頂きましたので、ご了承ください。（「半角スペースを入れる」の部分です） 記入 年間人件費 NNN明細　　（NNNは名前） NNN X月　　（NNNとX月の間に半角スペースを入れてください。全角スペースはNGです） X月 給料　　（X4月と給料の間に半角スペースを入れてください。全角スペースはNGです） 祭日 1月雛形 上記の命名規約に違反しているシートタブは、黄色になりますので、正しい名前に訂正してください。 以下、ソースです。SortSheets サブを実行してください。 Sub SortSheets() Dim i, j For i = Sheets.Count - 1 To 1 Step -1 For j = 1 To i 'MsgBox SortKey(Sheets(j).Name) & "×" & SortKey(Sheets(j + 1).Name) If SortKey(Sheets(j).Name) > SortKey(Sheets(j + 1).Name) Then Sheets(j).Move After:=Sheets(j + 1) End If Next j Next i For i = 1 To Sheets.Count Select Case Left(SortKey(Sheets(i).Name), 1) Case "0" Sheets(i).Tab.ColorIndex = 6 Case "4" Sheets(i).Tab.ColorIndex = 3 Case Else Sheets(i).Tab.ColorIndex = xlColorIndexNone End Select Next i End Sub Function SortKey(MyName As String) As String Dim MySplit As Variant Select Case MyName Case "記入" SortKey = "1" Exit Function Case "年間人件費" SortKey = "2" Exit Function Case "祭日" SortKey = "8" Exit Function Case "1月雛形" SortKey = "9" Exit Function End Select If Right(MyName, 2) = "明細" Then SortKey = "3" & MyName Exit Function End If MySplit = Split(MyName, " ", 2) If LBound(MySplit) = UBound(MySplit) Then SortKey = "0" & MyName Exit Function End If If MySplit(UBound(MySplit)) = "給料" Then SortKey = MyMM(MySplit(LBound(MySplit))) & String(10, Chr(65535)) Exit Function End If SortKey = MyMM(MySplit(UBound(MySplit))) & MyName End Function Function MyMM(MyMonth As Variant) As String Dim MM As String On Error GoTo ErrorHandler MM = Format(DateValue(MyMonth & "1日"), "mm") If MM = Format(Now, "mm") Then MyMM = "4" & MM Else MyMM = "5" & MM End If Exit Function ErrorHandler: MyMM = "0" Exit Function End Function
ＣＳＶファイルをエクセルシートに貼り付けたのですかね。その場合にメニュー「データ」で区切り位置の処理を選択した際に、区切りの方法に間違いはないですか。またセルの幅を大きくとって見え隠れした文字を確認されてはどうですか。
なるほど、そういうことを言いたかったわけですか。 説明に苦労したわけですね。 No.1の回答では数式に「ワイルドカード」を使っていますので、横方向の条件（１３通りあるもの）によっては思ったような結果が返ってこないことがあります。 注意してください。 ※「ワイルドカード」についても調べて勉強してみましょう。 質問の例では順番に数字が並んでいるので問題はありませんが、これが シート１のB1セルに”2,7,12”、C1セルに"1,6,11"が記入されていると、 シート２のB1セルに”１”を入力してもシート１のC列の値ではなく、シート１のB列の値を拾ってきます。 これは、”12”の”1”が検索した結果該当し、それ以降の検索を停止するからです。 ・・・ 名前にすると分かりやすいかもしれないので示してみます。 森田、小森、森、大森 この名前を、「森」を検索する時に、 =MATCH("*"&"森"&"*",{"森田","小森","森","大森"}) このようにワイルドカード（"*"）を使って検索すると、「"森"の文字を含む名前で一番初めに見つかったのは何番目？」と言う意味になります。 最初に見つかるのは”森田”ですから１番目という事で”１”が結果として返ってきます。 ”森”の”３”は返ってきません。 …このように分かりにくい挙動をすることがります。十分注意してください。
回答者の皆様、252さんに代わり説明させていただきます。 画像のシートを「シート１」とします。 これとは別の「シート２」のA1セルに”赤１”、B1セルに 11を入力したら、 C1セルに、次の値を返してくれる式を書きたいです。 値の求め方は、シート１のA列を”赤１”で検索、さらにシート１の1行目を 11 で検索し、 交わったセルの値とします。 ちなみに、シート１の1行目は、ひとつのセル中に複数の数字が設定されています。 具体的には、B1セルに、”1,6,11" といった具合です。この中のいずれかに該当した場合、 その列を採用することになります。 以上です。この回答でベストアンサー取れますかね？
こんにちは！ 一例です。 =B2+130*IF(B2<131,1,-1) としてみてください。m(_ _)m
CELL関数は第二引数を省略すると アクティブセルのシート名が表示 されてしまいます。 =REPLACE(CELL("filename",A1),1,FIND("]",CELL("filename",A1)),"")
応用が利かないので半分遊びで =INDEX({0,123,456,0},1+MODE(A1:C1,3,3))
後になって「やっぱりヤ～メタ」とならぬための確認です。 》 土日と祝日が重なる場合は祝日にカウント ご承知のとおり、振り替え休日てのはホントは日が祝日。 「日と祝日が重なる場合は祝日にカウント」するなら、振り替え休日は平日扱いですか？それとも両方とも祝日？！
またまたお邪魔します。 No.3の ＞もうひとつ、I2のセルに入っている数字を基準に、順番に1づつ足した数字を表示させたいのですが、13を超えた場合はまた1に戻りたいのですが、（数字の表示は１から１３まで） の件について、 No.3の数式そのままでMOD関数の「除数」を変えるだけで対応できるはずです。 =IF(MOD(I$2+ROW(A1),13),MOD(I$2+ROW(A1),13),13) としてフィルハンドルで下へコピーしてみてください。 ※　ROW(A1)の意味がよくわからないので・・・ 試しにどこか使っていないセルに =ROW(A1) としてみてください。 「1」が表示されるはずです。 （列番号はA列でなくてもZ列でもどこの列番号でも構いません、単純にA列にしているだけです） これをフィルハンドルで下へコピーしてみてください。 数式バー内で確認してもらうと =ROW(A2)　→　=ROW(A3)・・・ となり、2・3・4・・・と順に表示されます。 詳しくは「ROW関数」で調べてみてください。 この際ですので、COLUMN関数も同じ使い方（列方向へフィル＆コピーした場合） になりますので、 COLUMN関数も調べてみてはどうでしょうか？m(_ _)m
>ExcelでB2のセルに入る数字が > 「20,40,80,100,120,140,160,180,200,220,240,260」の場合は「黄色」 上の数値を20で割った余りは0である > 「1,21,41,61,81,101,121,141,161,181,201,221,241」の場合は「赤」 上の数値を20で割った余りは1である > 「2,22,42,62,82,102,122,142,162,182,202,222,242」の場合は「白」 上の数値を20で割った余りは2である。という規則性を利用する。 余りを出す関数は =MOD(数値,除数) (MacのNumbersにも存在する) http://www.apple.com/jp/mac/numbers/compatibility/ =MOD(B2,20) で余りが出る。 全部で0～19となり20通りとなるが、1加算して1～20にする。 =MOD(B2,20)+1 元の数値が1～20になったので、対応表から引っ張りやすい (逆に言えば対応表から引っ張りやすくするために1足した) E2:E21セルに対応表を書いておく(D列は不要(説明用)) すると、関数 INDEX(1列のセル範囲,何番目(1～20)か) を使って引っ張ってくる C2セルに =INDEX(E2:E21,MOD(B2,20)+1) 下にコピーしたとき、対応表は下にずれては困るので絶対参照にし =INDEX($E$2:$E$21,MOD(B2,20)+1) これで分からないようなら「500円でわかる エクセル関数」という本がある。 INDEX、MATCH、MOD、VLOOKUP関数くらいは載っているはず。 読解力がないなら補足に追加質問を書かないこと。どっちの回答なのかもわかってないんじゃ？ 以上、銀鱗さんの回答の詳細説明でした
対応表を作ってVLOOKUPなどの検索系関数で変換します B1セルに =VLOOKUP(A1,$D$2:$E$4,2,FALSE) (添付図は下へオートフィル)
No.2です。 前回のコードで「End If」の位置を間違っていました。 どこを修正！といっても判りにくいと思いますので、もう一度コードを載せておきます。 前回のコードは消去し↓のコードに変更してください。 Private Sub Worksheet_SelectionChange(ByVal Target As Range) Dim wS As Worksheet If Intersect(Target, Range("A:A")) Is Nothing Or Target.Count > 1 Then Exit Sub Set wS = Worksheets("Sheet2") With Target If .Row > 1 And .Value <> "" Then wS.Range("B2") = .Value wS.Range("C4") = .Offset(, 1) wS.Range("C5") = .Offset(, 2) wS.Range("C6") = .Offset(, 3) If MsgBox("商品No:　" & .Value & vbCrLf & "商品:　" & .Offset(, 1) & vbCrLf & "個数:　" & .Offset(, 2) & _ vbCrLf & "売上場所:　" & .Offset(, 3) & vbCrLf & vbCrLf & "です。印刷しますか？", vbYesNo) = vbYes Then wS.PrintPreview '★// Else MsgBox "印刷を中止します。" Exit Sub End If End If End With End Sub ※　検証せずに投稿してごめんんさい。m(_ _)m
アンインストール不要 併用可能 先に2010が居る環境で2013をインストールすれば併用可能 但し、excelのデータファイルを開くと常に2013を起動するので 2010で開きたいときには一工夫必要
> 通常ワークシートが3枚扱える画面となります。 その仕様は Excel2010までです。バージョンはいくつなのでしょう。 書かないと回答に差し支えます。 > どこか妙なキーをそれと知らず触ってしまったのでしょうか？ シート見出しが表示されていない場合 [Excel のオプション]→[詳細設定]の中の[シート見出しを表示する] のチェックが外れている可能性があります。 バージョンによって微妙に異なる可能性もありますが どこかにはあ るはずなので ご自分で探して下さい。
タイトルを読んで「二千文字変換すると Excel がエラーになる」と解釈しました(*^_^*) [検索/変換]の「変換」と思い込んでいたので、本文を読み終わって茫然自失していました。(ﾄﾎﾎ)
こんばんは！ すでに回答は出ていますので、参考程度で・・・ 「○○」を「××」に置換するコードです。 Sub Sample1() Selection.Replace what:="○○", replacement:="××", lookat:=xlPart End Sub の3行で大丈夫だと思います。m(_ _)m
実際にブックが保存されている場所にアクセスできないという内容のメッセージのように思う。 Excelのブックそのものではなく、ブックへのリンクが貼られていたという事ではないだろうか。 所有者が公開したつもりで、実は公開できる状態ではなかったというパターンかもしれない。 （いわゆるデスクトップに作った「ショートカット」を送りつけてきたってこと） 相手の方に確認をしてもらおう。
見た感じ、そんなに難しい表ではないように思う。 セルの結合を適切に行えばよいだけではないだろうか。 セルを結合した状態で1行分作成し、その行をコピーしていくだけだ。 難しくも手間でもないように思う。 （記入フォームの枠を切ることに限れば、慣れている人なら5分くらいで作ってしまえる内容だ） ・・・ 「図として貼り付け」は確かに簡単多方法ではあるが、印刷範囲全体の横幅がソートごとで異なると 一番左の「項目」の欄の幅が一致しないなどの弊害が出る。 （報告書として適切かは別問題ではあるが、見た目が凄くカッコ悪い）
https://www.google.co.jp/search?q=%E5%B8%AD%E6%A …
結合したいセルとは別に、結合したいセルと同様に結合したセルを用意する。 (…くどい) その結合したセルをコピーし、データを残して結合したいセルに書式のみ貼り付ける。 で如何でしょうか？
式の変換ができればよいのですが、今回の指数関数は複雑ですし、他にも複雑な関数があり式の変換が容易でない場合がよくあります。 そういう場合は、ゴールシーク機能を使います。 <やり方> A1セルに式を入力。今回の場合は、=(1E+21)*EXP(-0.245*A2) データ　→　What If分析　→　ゴールシーク　とします。 ゴールシークの入力ウィンドウが表示されるので、 数式入力セル　：　A1セルを指定 目標値　　　　：　任意の値 変化させるセル：　A2セルを指定 OKをクリック これで式を解いてくれます。
No.1・6です。 ちゃんと配列数式になっているというコトなので、少し数式を変えてみました。 画像ではSheet1の1行目～16行目がどのような状態かわからないのですが、 何らかのデータが入っているとエラーになるのかもしれません。 今回はSheet1の実データ行（18行目以降）をINDEX関数の範囲としてみました。 Sheet2のA4セルを =IFERROR(INDEX(Sheet1!$A$18:$Q$1000,SMALL(IF(ISNUMBER(FIND("1111",Sheet1!$A$18:$A$1000))*(Sheet1!$B$18:$B$1000="りんご"),ROW($A$18:$A$1000)-17),ROW(A1)),MATCH(A$3,Sheet1!$17:$17,0)),"") （前回同様の配列数式です。） としてみたらどうなりますか？m(_ _)m
こんばんは！ 一例です。 B列に表示するとします。 B1セルに =IF(LEN(A1)-LEN(SUBSTITUTE(A1,"区",""))=2,"○","") という数式を入れフィルハンドルでダブルクリック！ これで「区」が二つ入っている行に「○」が表示されます。m(_ _)m
リーグ戦の対戦表って基本的には、こんなんですよね（図１）。 これであれば、縦列のＡＢＣＤを入力し、横列は、縦列の参照で、 簡単にできると思います。 （図１） 　 A B C D A|＼ × × ○ B|○ ＼ × ○ C|× ○ ＼ × D|○ × × ＼ もし、No.1さんのような対戦表を作るのであれば、次のようにすると 良いらしいです。（http://www.hsbad.com/tool/index.html　より） １，２，３，４，５の場合（人数が奇数の場合の例です） 【1回戦目】両端の人同士から内側に向かって対戦を組みます。 具体的には、１×５、２×４、3はお休み。 【2回戦目】最右端の人を先頭に移動して、同じことを行います。 具体的には、５，１，２，３，４として、 ５×４、１×３、２はお休み。 【3回戦目以降】 ２回戦目と同じことを繰り繰り返します。 1が最右端になるまで繰り返せば、総当たり完了です。 【人数が偶数の場合】例１，２，３，４，５、６の場合 とりあえず、6を除いた形で、5人の場合と同じ要領で対戦を組みます。 5人の場合、1回戦目で３がお休みですが、それを6と対戦させます。 具体的に1回戦目は、１×５、２×４、3×6 2回戦目以降も同様に休みの人と６を対戦させます。 上記のこと（人数に応じて最適な対戦表を作る）をExcelでやろうとすると、 それなりのVBAを組む必要があります。 もしそれができないようであれば、人数毎の対戦パターンを手で作成しておいて、 No.1さんの回答のような方式で名前を割り当てた方が現実的のような気がします。 その場合、対戦パターンが決まってしまうので、対戦番号を経由しないで、直接名前を 参照した方が、手っ取り早いかもしれません。
例えばB1セルに何か入力した場合にA1セルの塗りつぶしの色を変える場合は、 A1セルを選択→条件付き書式→新しいルール→数式を使用して、書式設定するセルを決定→ その下の「次の数式を満たす場合に値を書式設定」の部分に「=B1<>""」と入力→その下の「書式」で塗りつぶしの色を選択してOK で、できるはずです。
こんなんでいかがでしょう。 ActiveSheet.Shapes("角丸四角形 10").Cut ActiveSheet.Paste Destination:=Range("A1") ちなみに、"角丸四角形 10" は切り取られて、無くなってしまいます。 ペーストされたものには、別の名前が付きます。
>エクセルでデータ管理のひな型を作っています。 どこの部分がデータの管理なのかわかりませんが まだ、間に合うのであれば むやみにセルの結合を使うのをやめましょう。 セルの幅を変更します。貼付けなどの操作時に苦労しますよ。 添付の図を参考にして下さい。 日付も　月だけでよろしいのでしょうか。 もしかして　Sheet2に何らかのデータがあるような？？ データベースとして取り扱いやすいシートの構成にすれば エクセルの限界内ですべての作業が自動化できます。 この部分を間違うと厄介な作業を強いられたり むやみに複雑なVBAが必要になったりします。
フィルタオプションでワイルドカード（＊と？の記号）を用いて抽出する。 絶対に7桁と決まっているのであれば、オートフィルタを使い、フィルタオプションの抽出条件に 「11?????」 と、「1」を2つ、「？」を5つ並べ、 「と等しい」 として実行すればよい。 ・・・ 「11?????」は、先頭の２つ「11」で以下任意の5桁の値が入ることを示している。
codedreamさんのコードをExcel2010で実行してみましたが、 「エラー箇所」でエラーを発生させることができませんでした。 環境の違いによるものであれば、この回答は読み捨ててください。 codedreamさんのやりたいことは、シートAの選択範囲AをシートBの選択範囲Bへ コピーする（シートAとシートBは別ブック）ということですよね。 これを実現するには、マクロの実行中に、アクティブブックを切り替える必要があります。 しかし、私の環境では、ブックの切り替えができませんでした。（シートの切り替えはできました） よって、ブックA、ブックB、および、アクティブブックは、すべて同じブックとなってしまいます。 「エラー箇所」でエラーを発生させるには、アクティブブック内に、シートBがない状況を 作る必要があります。しかし、アクティブブックはシートBと同じブックなので、当然、 シートBは存在します。よって、「エラー箇所」でエラーにはなりませんでした。 実際にエラーが発生したのは、2行下の Sheets(Name_b).Range_b.Select　でした。 マクロ実行中にアクティブブックの切り替えができない限り、ブック間のコピーは 不可能と思います。（同一ブック内のシート間であれば、可能かもしれません）
＞いろいろ調べてみましたが、PDFとVBAの関係が、わかりませんでしたので エクセルのバージョンがわかりませんが ファイル＝＞名前と付けて保存 ファイルの種類に　PDF　がありませんでしょうか？ これがあれば、必要なコードはマクロの記録で取得できます。 別の方法では 印刷する際に、PDFに切り替えて印刷するマクロを考える この場合は、複雑になります。

他アプリをダウンロードしてよいのであれば MS　の　Microsoft Access 2013 Runtime　を使ってみては 如何でしょうか。当然、無料です。 マクロを使わなくても、シート上に　RQコードが作成できます。 詳しくは http://wtakemo.hatenablog.com/entry/2014/03/10/0 … Excel2013でQRコードを作る
質問文の上から順番に関数を立てるとやり難いので順番を入れ替えつつ，なるべく条件が変わらない様に解釈を変えて関数を組み立てると =IF(MAX(A1:A3)=A3,IF(SUM(A1:A2)>=11,"契約先","掘り起し"),IF(A1>A2,"上得意","得意先")) 質問文を読み違えてなければ先ずA3のセルが最も大きい場合には2パターンあって，それぞれA1+A2が11以上の場合と10以下の場合に契約先と掘り起こしのいずれかが表示される． ここで１つ"A1からA3のセルに入力される数値が整数且つ同じ数値にはならない"という前提条件があれば，A1+A2が11以上の場合とそれ以外の場合という書き方になるので，IF(SUM(A1:A2)>=11,"契約先","掘り起し")とまとめる事ができます． ではA3が最大の値ではない場合についてはA1の場合では上得意，A2の場合では得意先とすればよいので，IF(A1>A2,"上得意","得意先") IF(SUM(A1:A2)>=11,"契約先","掘り起し")とIF(A1>A2,"上得意","得意先")を1つにまとめるにはA3のセルが最大値なのか，最大値ではないのかを判定すればよいので =IF(MAX(A1:A3)=A3で判定すればよいと考えました． もし厳密にA1+A2が11以上または10以下（10超11未満の値の判定は不明なのでとりあえず空白とします）を記載する必要があるなら IF(SUM(A1:A2)>=11,"契約先","掘り起し")の部分を IF(SUM(A1:A2)>=11,"契約先",IF(SUM(A1:A2)<=10,"掘り起こし","")) に書き換えて下さい．
> エクセルで表示設定を変更した場合、（例：パーセント→数値） > 表示上は数値になっているようですが > グラフには反映されず、数値として認識してくれません。 表示形式を『パーセント→数値』でなく、パーセント→標準ですと、 即 グラフに反映されると思います。
NO.1・3です。 ＞メッセージボックスの一番最後に改行して、「表の組み合わせは上記のとおりです」と追加表示できるのでしょうか。 コード内の ＞Next i ですべてのループが完了し、その後にメッセーボックスが表示されますので、 ＞MsgBox myStr の行を ＞MsgBox myStr & vbCrLf & "表の組み合わせは上記のとおりです" とするだけで大丈夫だと思います。m(_ _)m
> 'パスを変数に格納 > fp = Range("A1").Value & "\*.*" この部分、元と違ってる。
何をしたいのかよくわかりませんが、 J7=(((1-AA7)*K7-AB7-AC7)*(H$2-2.5)-J7*(1-J$1+H$1)-Z7*J$2)/0.3/（(1-J$1+H$1)+Z7*J$2)*30/(20+(30/(W7/(N7+1)))) ということでしょうか？
こんにちは！ コードを拝見するとP列には必ずG22セルの値を表示させればよいのでしょうか？ そうであれば、値のコピー＆ペーストになっていますので、 単に値の代入の方が早いと思います。 Sub Sample1() Dim i As Long For i = 4 To Cells(Rows.Count, "O").End(xlUp).Row Range("E9") = Cells(i, "O") Cells(i, "P") = Range("G22") Next i End Sub こんな感じではどうでしょうか？ ※　G列もループさせる必要があるような気がしますが、お示しのコードから判断できるのは この程度でしょうかね。m(_ _)m
C列に=B-Aと入力がしてあり、C5セル以降に何も値が表示されていないってことは、何かしらのセルの書式設定がしてあり、０のときは見えないようになっているだけかと。 C列が空白であれば、=IF(C3="","",D2+C3)で良いですが、今回のケースでは、D3セルに=IF($C3=0,"",SUM($C3,$D2))と入力し、以降はフィルハンドルで埋めていけば、行けるのではないかと思います
銀鱗さん》 この改ページプレビューが嫌いだ 私も。見たことあるけど、使ったことなし！
NO4です。もう一つの方法を紹介するのを忘れていました もうひとつのInputBox　Application.InputBox　を使います。 Application.InputBox(Prompt:=myPrompt_s, Type:=1) にすると日付として認識できる、或いは数値のみ入力できます。 間違って数字を入力されたときは挙動不審になります。 詳しくは http://officetanaka.net/excel/vba/tips/tips37.htm この辺りを！！
J=4ですが、＋１してから代入しているので、正確にはA列5行目ですね。 ご質問に書かれているコードを拡張するならば、10班用の変数、および、 判定等のIF文を追加することになると思います。とりあえず、10班用の 変数Lを追加したコードを下記に書いてみました。 しかし…10班もあるのですね？もしかして、もっと多いのでしょうか？ このままだと班の数だけ変数やIF文を追加しなければならないので、 冗長なプログラムになってしまいますね～ 同じような変数（今回の場合はJ,K,Lなど）をたくさん使う時は、配列に すると便利ですよ。頑張って勉強してみてください。 Sub test() Dim i As Long, j As Long, k As Long, L As Long Dim ws As Worksheet Set ws = Worksheets(2) j = 4 k = 4 L = 14 For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row If Cells(i, 3) = "1" And Cells(i, 5) = "" Then j = j + 1 ws.Cells(j, 1) = Cells(i, 4) End If If Cells(i, 3) = "2" And Cells(i, 5) = "" Then k = k + 1 ws.Cells(k, 2) = Cells(i, 4) End If If Cells(i, 3) = "10" And Cells(i, 5) = "" Then L = L + 1 ws.Cells(L, 1) = Cells(i, 4) End If Next i End Sub
ママチャリです。 それはひどいですね。残念ですが参照式やVBAでは無理そうなので、この機会に手作業で整理しましょう。 新しいシートを作成する際は、今までの回答内容を考慮して、便利なものを作成してください。 ご検討をお祈りします。
「セルに設定する数式を簡単にできないか」とのことですが、関数を組み合わせて数式を作る以上、難しいと思います。 今回やりたいことは、MATCH関数で求めた行位置を2か所の参照式で使いたいということです。 関数を使う以上、2か所の参照式で、それぞれ同じMATCH関数を書く必要があります。 これを回避するには、作業用の列を作って、MATCH関数で求めた行位置を一旦格納。目的のセルの参照式では、作業用列を参照するようにすれば、MATCH関数を重複して書く必要はなくなります。 しかし、分かりやすさという観点では、？？？です。 そこでお勧めなのが、ユーザ定義関数の作成です。 ちょっとしたVBAの知識があれば、簡単につくろことができます。 ちなみに、今回の要件を満たす関数は、こんな感じです。 Function MyLookUp(検索値 As Variant, 範囲 As Variant) As Variant Dim Ro As Long Ro = WorksheetFunction.Match(検索値, 範囲.Columns(範囲.Columns.Count), 0) MyLookUp = 範囲.Cells(Ro, 1) & 範囲.Cells(Ro, 2) End Function 使い方は、=MyLookUp(A1,Sheet1!A1:D5) A1が検索値で、Sheet1!A1:D5が検索範囲です。 検索範囲の最右端の列を検索し、該当行の１、２列目の値を結合して返します。 検索値が見つからない場合は、エラーを返します。
No.5 です。 先の回答の誤記を訂正させてください。 何をどう間違えたのか･･･ 3. ○ [D]キーを10回押しますと、右斜め下に10本のコピーができます。 　 × [D]キーを11回押しますと、右斜め下に11本のコピーができます。 4. ○ 合計11本の縦線をすべて 　 × 合計12本の縦線をすべて
Excel（エクセル）「ファイルが破損しているため開くことができません」 http://jisaku-pc.net/hddhukyuu/archives/3331
No.4の回答を投稿したママチャリです。 実際に作ってみて思ったのですが、後から商品を追加する場合、名前の定義を 追加するなど、ちょっとした修正が必要になります。 作成当初は、直すべき個所を覚えているの問題ないと思いますが、時間が経過したり、 他の人が追加作業を行うような場合は、修正を漏らす可能性があります。 そんな場合、商品シートを追加するだけで、対応できたら便利ですよね。 上記のことを実現するには、moto_koukouseiさんのNo.2の考え方が最適です。 以下、No.2を参考に仕様をまとめました。もし、気に入って頂けたら、No.2の moto_koukouseiさんに、ベストアンサーをお願いします。 ”商品”シートを作成します。これは空でOKです（後からマクロで設定します）。 ”商品_ｘｘｘ”シートを作成します。XXXは商品名です。（例、”商品_アイス”） ”商品_ｘｘｘ”シートのA列に種類、B列に金額、C列に内容量を入力します。 シート１の1行目は見出し行とします。A１に商品、B1に種類、C１に金額、 D１に内容量と入力します。 つづいて、2行目に次の入力規則、または、式を設定します。 A2セルの入力規則　=商品!$A:$A B2セルの入力規則　=INDIRECT("商品_"&A2&"!$A:$A") C2セルの式　=IF(A2="","",VLOOKUP(B2,INDIRECT("商品_"&A2&"!$A:$C"),2,FALSE)) D2セルの式　=IF(A2="","",VLOOKUP(B2,INDIRECT("商品_"&A2&"!$A:$C"),3,FALSE)) A2：D2を範囲選択して、下へ必要なだけオートフィルして伸ばします。 最後に、シート１の Worksheet_Activate イベントプロシジャに、次のマクロを書きます。 このマクロは、シート名を検索して”商品”シートに商品名を転記するものです。 エクセル初心者とのことなので、ちょっとハードルが高いかもしれませんが、頑張ってください。 Private Sub Worksheet_Activate() Dim Ws As Worksheet Dim Ro As Long Worksheets("商品").Cells.Clear For Each Ws In ThisWorkbook.Worksheets If Left(Ws.Name, 3) = "商品_" Then Ro = Ro + 1 Worksheets("商品").Range("A" & Ro) = Mid(Ws.Name, 4) End If Next End Sub
張り付け先の行を指す変数ｋが、一つしかないのが原因です。 この変数は、班の数だけ必要なので、とりあえず、変数ｊを 追加して、ｊ（１班用）、ｋ（２汎用）としてみました。 Sub test() Dim i As Long, j As Long, k As Long Dim ws As Worksheet Set ws = Worksheets(2) j = 4 k = 4 For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row If Cells(i, 3) = "1" And Cells(i, 5) = "" Then j = j + 1 ws.Cells(j, 1) = Cells(i, 4) End If If Cells(i, 3) = "2" And Cells(i, 5) = "" Then k = k + 1 ws.Cells(k, 2) = Cells(i, 4) End If Next i End Sub
VLOOKUP関数ではできないのでINDEXとMATCH関数を組み合わせます =INDEX($F$102:$F$202,MATCH(A1,$A$100:$A$200,0)) とか =INDEX($F:$F,101+MATCH(A1,$A$100:$A$200,0))
質問文の中に、「作成完了させてしまい」と記述されていますが、「作成完了」とは具体的に、 どのような状態なのでしょうか。単にブックを保存するだけですか？ もし、そうであれば、まだ作成中の可能性もあるのですよね？ そこで、入力担当者に完了を明示させるために「作成完了」ボタンを作成することをお勧めします。 （ボタンの名称はなんでもよいのですが、これを押さないと「完了にならないよ」みたいな名称が良いです） 「作成完了」ボタンでもチェックマクロが回るようにします。 できれば、「ブックの保護－最終版にする」命令を追加して、以降の入力を制限してもよいでしょう。 「ActiveWorkbook.Final = True」で最終版にすることができると思います。 もし、mame1216さんが集計する時点で、最終版になっていないものがあれば、催促することができます。 「必ずチェックマクロを回してください」と言うよりも「期限までに作成完了してください」と言ったほうが、 強制力があるように感じると思います。 蛇足ですが、「エラーが無くなるまで保存できない」ようなマクロは組んではいけません。 忙しい入力担当者は、「とりあえず入力しておいて、エラーは後で訂正しよう」と考えるかもしれません。 忙しい時にエラーで保存できないようなシステムは、反感を買って、使ってもらえなくなります。 「作業者の業務効率化を図る」とのことですが、集計担当者のことだけを考えてはいけません。
たぶんシート１のA1セルには、貼り付けた行の行数をカウントする関数が入っているのでしょうか。 想像で書きましたが、以下のコードでやりたいことをカバーしていれば、と思います。 実行後は元に戻せませんので必ずバックアップを取ってからやってください。 ’---------------------------------------------------------------------- Sub ZZZ() '変数の宣言 Dim Ws1 As Worksheet, Ws2 As Worksheet Dim Rng As Range, LstRow As Long, TgtRow As Long 'Sheet1、2を変数Ws1,Ws2に格納 Set Ws1 = Worksheets("Sheet1") Set Ws2 = Worksheets("Sheet2") Ws2.Select 'Sheet2のA2:Z2を変数Rngに格納 Set Rng = Range(Cells(2, 1), Cells(2, 26)) 'Sheet2の前回分を消す LstRow = Cells(3, 1).End(xlDown).Row Range(Cells(3, 1), Cells(LstRow, 26)).ClearContents 'Sheet2でずらす必要のある行数（Sheet1に貼ったデータ行数）を変数TgtRowに入れる TgtRow = Ws1.Cells(Rows.Count, 1).End(xlUp).Row - 4 '範囲Rngを、TgtRow までオートフィルする Rng.AutoFill Destination:=Range(Cells(2, 1), Cells(TgtRow, 26)), Type:=xlFillDefault '変数開放 Set Rng = Nothing Set Ws1 = Nothing Set Ws2 = Nothing MsgBox "End." End Sub ’---------------------------------------------------------------------- いちおう逐一コメントを入れてあるので読んでください。 なお、繰り返し使用することを想定し、オートフィル前にSheet2の前回分を消すフローを 入れてあります。消しに行く範囲は、３行目から、EndのxlDownとしてあります。 不具合あれば適宜いじってください。 また、コードを見ていただくと分かりますが、オートフィルの最終行は、 シート１のA1セルから取得していませんので、もしやりたいことと違ったらすみません。 （＝シート１のA1セルが無くても回ります）
上のＡ列とＢ列のデーターをSheet1として、別のシート（ｓｈｅｅｔ２）に以下のように入力する。 　　Ａ　　　　Ｂ １　Ａ１　　１／３ ２　Ａ２　　１／４ ３　Ａ３　　１／５ ｓｈｅｅｔ１が下の様な場合 　　Ａ　　　　Ｂ　　　　Ｃ １　１　　　　Ａ１ ２　１　　　　Ａ１ ３　１　　　　Ａ２ ４　１　　　　Ａ３ 　　Ｃ１には以下の式を入力する。 　Ｃ１＝VLOOKUP(Sheet1!$B$1:$B$3,Sheet2!$A$1:$B$2,1,0) 　あとはＣ１の式をコピーして下にドラッグします。
こんにちは！ わざわざ変数にする必要はないように思われますが・・・ ＞Range(Cells(F_gyou, "BF"), Cells(L_gyou, "BF")) または ＞Range("BF" & F_gyou & ":" & "BF" & L_gyou) としてみてはどうでしょうか？ ※　個人的には前者の方を使うことが多いです。m(_ _)m
> セルの入力で　年月日を入力したいと思ってます。入力は　月日のみ入力をしてます。 > 例　2.3 （２月３日）を入力　⇒　Ｈ27.2.３と　表示するようにする。 > 　　セルの書式設定　ユーザー定義　”Ｈ27.”＃＃.＃＃にしました。一部を除きできましたが 　　２.10（２月１０日）⇒　Ｈ27.2.1と表示されます。最後の0が表示されません。 > 　１０日、２０日、３０日も同様に　0が省略されます。 ユーザー定義『”Ｈ27.”＃＃.＃＃』を "27."##.#0 に変更すれば、 H27.2.10，H27.2.20，H27.2.30 と表示されますが、2.1，2.2 などでも、 H27.2.10，H27.2.20，H27.2.30 と表示されてしまいます。 これは、##.##，##.#0 の部分を見ていただければ分かるように、Excelで小数点以下の数値の表示形式そのものです。 従って、2.1，2.10 などの入力値では、ご希望のような月日を表示できません。 2.1，2.10 などに近い入力方法をするなら、 ユーザー定義を ”H27."#"."#0 として、201，210，1231 などと、3～4桁の数値を入力すれば、H27.2.01，H27.2.10，H27.12.31 などと表示されます。
質問の内容がわからないです。　（No.1の方と同じ感じ受けました） "重複カウント"ではないのではないでしょうか。 一週間の利用者のカウントという場合、どうカウントしたいのかが、またわかりません。 仮に下図を作成してみました。 利用する可能性のあるメンバー8名で、月～金の５日で、 利用したのは７名。 延べの利用者数は２２人日。 各日の利用者数と名簿、あるいは各人の利用日数、 介護度の二行の意味がわからない。 １日では、午前/午後/全日利用の状況を問わない、介護度の区分も問わないで、何かカウントしたいのであれば、４つのセルの状態を調べて（０，１）にわけて、その状態をカウントしてしまうのが、楽ちんだと思います。マクロを使わずに関数だけで集計するならば、作業列や作業行を作って、対象とする４つのセルの状態を調べて（０，１）を作業セルに入れて、それを集計するのが手早いような気がします。 とにかく、やりたいことや条件がはっきりしないと、やりようもないです。
こんばんは！ 結局Sheet2の「DATA4」と「DATA5」は関係ないのですね？ VBAになりますが、一例です。 Sheet3に表示するようにしていますので Sheet3は使用していない状態にしておいてください。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 Sub Sample1() 'この行から// Dim i As Long, lastRow As Long, wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") Application.ScreenUpdating = False wS3.Cells.Clear With Worksheets("Sheet1") .Range("A1").Resize(, 3).Copy wS3.Range("A1") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row For i = 2 To wS2.Cells(Rows.Count, "A").End(xlUp).Row .Range("A1").AutoFilter field:=1, Criteria1:=wS2.Cells(i, "A") If .Cells(Rows.Count, "A").End(xlUp).Row > 1 Then Range(.Cells(2, "A"), .Cells(lastRow, "C")).SpecialCells(xlCellTypeVisible).Copy _ wS3.Cells(Rows.Count, "A").End(xlUp).Offset(1) End If Next i .AutoFilterMode = False End With Application.ScreenUpdating = False wS3.Activate End Sub 'この行まで// ※　関数でないのでデータ変更があるたびにマクロを実行する必要があります。 こんな感じではどうでしょうか？m(_ _)m
目的のファイルのURLはサーバーサイドのプログラム中にあってプログラムで書き出されたHTMLには存在しないとおもいますのでIEでファイルを開いて実際のURLを確認してみては？
enunokokoroさんご指摘ありがとうございますm(_ _)m >-INT(A1)/4999.9 INTが思いつきませんでした。 No.3の回答では、正の整数のみの対応でした 別案 0以上、空白処理無し =MID("EDCBAS",1+MIN(5,A1/5000),1) 負も対応 空白処理なし =MID("EDCBAS",MAX(1,1+MIN(5,A1/5000)),1) 参考まで
こんにちは。 ①のファイルに列を追加してもよければ、 日付をシリアル値から文字列に変更した欄を作成して、 グラフに反映させる日付は文字列に変更した欄を使用すれば、 ②のファイルでもシリアル値になりません。 ※シリアル値を文字列に変更（一例です。） =TEXT(日付が入力されているセル,"yyyy/mm/dd")
こんばんは。 回答されている皆さんみたいに詳しい者ではないのですが、 コメント失礼します。 回答から、「OFFSET」「MATCH」を使用してサンプルファイルを作成してみました。 よろしければご確認頂ければと思います。 http://firestorage.jp/download/3d907cbdb7ea20011 … ファイル名：サンプル_.xlsx 解決になっていなかったらすみません。 こちらの質問とても勉強になりました。 他の回答者の方々もありがとうございました。
こんにちは！ やり方だけ・・・ ↓のような配置だとします。 No○　のセルはセルの表示形式のユーザー定義から "No"0 としておき、数値データだけの入力とします。 まず、E・F列に初期値を表示させておきます。 そしてC2セルに =IF(A2="","",COUNTIF(A$2:A2,A2)+IF(COUNTIF(E:E,A2),VLOOKUP(A2,E:F,2,0))) という数式を入れフィルハンドルで下へコピーすると 画像のような感じになります。m(_ _)m
こんにちは！ 一例です。 前提条件として、範囲内に最大値は複数存在しない！とします。 ↓の画像でB1セルに =MAX(IF((Sheet2!A1:A100>=A1)*(Sheet2!A1:A100<=A2),Sheet2!B1:B100)) 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は上記数式をドラッグ＆コピー　→　B1セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 B2セル（同じく配列数式です）に =INDEX(Sheet2!A1:A100,MAX(IF((Sheet2!A1:A100>=A1)*(Sheet2!A1:A100<=A2)*(Sheet2!B1:B100=B1),ROW(A1:A100)))) とし、Ctrl＋Shift＋Enterで確定！ ※　万一最大値が複数存在する場合はB2に最後の時刻が表示されます。 （最初の時刻を表示したい場合はB2セルの数式内の「MAX」を「MIN」に変更します。） ※　エラー処理をしていません。 エラー処理をする場合はExcel2000だというコトですので、 ISERROR関数等を併用する必要があると思います。m(_ _)m
補足の数式の >DATE(YEAR($C1),MONTH($C1),DAY($C1))<DATE(YEAR($G1),MONTH($G1),1) は$C1<$G1 で良いと思います。 数式をコピーする方向が不明のため絶対参照の$を外してあります =CHOOSE(2-SIGN(TEXT(C1,"yymm")-TEXT(G1,"yymm")),"", SUMIF(H1:K1,"<="&DAY(C1),H2:K2)/COUNTIF(H1:K1,"<="&DAY(C1)), SUM(H2:K2)) 同年かつ同月の場合は、AVERAGEIFSで作成してください
[No.1お礼]へのコメント、 米国産の表計算ソフトに日本独特の「ルビ」にそういう機能を求めるのは無理があるかも。 どうしても当該機能を希望されるなら、純国産の表計算ソフト（私は使ったことがないけど、五郎丸だか三四郎だかの名前のソフトがあったような）を検討されたら？ 最近は使わないけど、Word の最新版はどうなんでせう？
こんばんは！ お示しのコードはおそらく当方が投稿したコードだと思います。 コードの内容だけだとセルの表示形式を判断しているだけで 表示形式には手を付けていません。 すなわち原因はユーザー定義関数ではないように思われます。 他のマクロがどのようなコードになっているのか判らないのですが そちらの方に原因があるのでは？ お役に立てなくてごめんなさいね。m(_ _)m
https://www.youtube.com/watch?v=IxImuQVQ5SQ&inde …
数値を文字列に変換しておいて、左から一文字づつ空白を入れてゆく考え方でどうでしょうか？ 例えば、A1に入力されている値を処理する場合の例です。 Sub test() 　Dim txt As String, res As String, i As Integer 　txt = Range("A1").Text 　res = Left(txt, 1) 　For i = 2 To Len(txt) 　　res = res & " " & Mid(txt, i, 1) 　Next i 　MsgBox res End Sub
実はCSVと言う事はないですよね。
[No.2補足]へのコメント、 》 上手く表示されません… 私が書いた【お断り】を詠みました？「配列数式」って分かりますか？ 分からなかったら、そう言わなきゃ～！
VBAの操作が分からないとのことなので、次のような力技はいかがでしょうか。 ①B列に変換したい元の文字列を張り付ける。 ②「区切り位置指定ウィザード」を使って、B列を分割する。（B列以降に各数値が入る） 　※「区切り位置指定ウィザード」の使い方は、Excelのヘルプを参照してください。 ③A列に、次の式を入力し、オートフィルで下へ必要なだけコピーする。 　=　IF(B1<>"",B1+1,"")　&　IF(C1<>"",","&C1+1,"")　&　IF(D1<>"",","&D1+1,"") 上記の式は、B列以降の各セルを＋１して連結するものです。 例では、3つまで（B、C、D列）しか連結していませんが、必要に応じて増やしてください。
INDIRECT関数で範囲を指定してはどうか。 ADDRESS関数でエラーになるなら、指定方法が適切でないと思われる。 ならば他の手段で範囲を指定することを考えてみよう。 …するとINDIRECT関数になるのではないだろうか…
[No.2]に提示した式を下記のとおりに訂正します。済みませんでした。 =LEFT(A1,FIND("（",A1)-1)
こんにちは 確かにご指摘のように表示されるパレットの内容が変わるようですね。 図形を右クリックした時の「図の書式設定」のダイアログがないか探してみましたが見当たらないようでした。（ID=1～2000まで見てみました。) ご質問の操作がどのようなシチュエーションを想定なさっているのかよくわかりませんが、上述のように右クリックのメニューからダイアログを出せますし、クイックツールバーに「図の塗りつぶし」を登録しておくことでも1クリックでダイアログを出せるようにできます。 これって、マクロを実行するのと手間としてはほとんど変わらないような気がしますが・・・ などと言っているばかりでは回答にならないので、代替案を考えてみました。 一つは、質問者様がなさろうとしていることの延長上で、もう一つは少し違った方法です。 一つ目の考え方は、 　1）（使わない）セルを選択した状態でダイアログを出す 　　　（ユーザの操作が終わると、セルに色が反映されている） 　2）セルの色を取得する 　3）2で取得した色で、図形を塗りを行う というマクロを作成するものです。 お考えの方法より、若干手順が長いかも知れませんが、一応目的は達成できるかと思います。 二つ目の方法は、マクロでコマンドリボンの操作を行うという考え方です。 通常の設定だと、ALT、Ｈ、Ｈ、Ｍの順でキーを押すと「その他の色」のダイアログが表示されますので、これを行うだけのマクロです。 （ショートカットなどを変更している場合は、キーの内容が変わりますのでご注意。） 以下はこの方法のサンプルです。（図形を選択した状態でマクロを実行してください） Sub test() SendKeys "%H", True SendKeys "HM", True End Sub 長々と書きましたが、最初に記しましたように、マクロを実行する手間とほぼ同様の操作で手動でダイアログの表示ができてしまうので、あまり有用な気はしないのですが・・・
1-9年後まではキャッシュフローが無く、10年後に100万円入る。 =NPV(3%,0,0,0,0,0,0,0,0,0,1000000)
「1ヶ月後」がいつかよく考えた方がいいと思います。 > =Date(Year(A1),Month(A1)-1,Day(A1)) これだと「2016/3/31」の 1ヶ月前が「2016/3/2」という ことになりますけど これで大丈夫ですか？ EDATE関数を使った方がいいのではないかと思います。
後でまとめる必要があるなら シートを１日ごとに分けるのを止めた方が いいです。同じデータは１箇所に集めるのが表計算の基本です。ワープ ロ感覚で表を作っていると紙に入力しているのと何も変わりませんよ。 「エクセルの方が効率がいい」のは 効率よく計算できるように表を作っ た場合に限られます。 １つのシートにデータをまとめて 抽出はフィルタ。集計はピボットテー ブルを使えば 手で計算する必要はほとんどなくなります。
No.3のばか者で～す。見事なまでに間違ってたm(_ _)m 集計して累計を出す部分が違った(^^; A8セル =IF(ROW(A1)>SUM($B$2:$D$4),"",INDEX($A$2:$A$4,MATCH(ROW(A1)-1,MMULT(TRANSPOSE(MMULT($B$2:$D$4+0,ROW($B$2:$D$4)^0)),(COLUMN($A$1:$C$1)>ROW($A$1:$A$3))*1)))) B8セルは同じ =IF(A8="","",INDEX($B$1:$D$1,MATCH(COUNTIF(A$8:A8,A8)-1,MMULT(INDEX($B$2:$D$4,MATCH(A8,$A$2:$A$4,0),)+0,(COLUMN($A$1:$C$1)>ROW($A$1:$A$3))*1)))) 素直に集計と累計を作業列に出すべきか(^^;
こんにちは！ ＞入力数字は１から最高は１２までの数字で・・・ 10行目のデータを上に向かって表示できるのは9行上までですよね？ コピー＆ペーストではないのですが、一例です。 Sub Sample1() Dim myCnt As Long If Range("A5") > 0 And Range("A5") < 10 Then Range("B1:D9").ClearContents myCnt = Range("A5") With Range("B10") .Offset(-myCnt).Resize(, 3).Value = .Resize(, 3).Value End With End If End Sub こんな感じではどうでしょうか？m(_ _)m
ピボットテーブルを使ってみてはいかがでしょう？いろいろと応用できます。 目的に応じてアレンジしてください。 <やり方> １．ラベルを含むデータ範囲を全選択 ２．挿入→ピボットテーブル ３．今回はとりあえず、そのままOKをクリック（ニーズにあわせてアレンジ） ４．花の名前を行ラベルの枠内にドラッグ ５．花の色を行ラベルの枠内にドラッグ ６．販売日を列ラベルの枠内にドラッグ ７．販売日をΣ値の枠内にドラッグ ８．（今回は不要）Σ値のアイテムをクリックして『データの個数』にする
取りあえず。一案です。 先に紹介したように、関数で空白部分を埋めた取り込みシートを準備 N1セルに　=COUNT(予定表!I:I) とでも入れてデータの件数を計算させておく。 マクロのファイルを特定のフォルダに保存 メールでブックAとブックBが添付されて来る。 添付のブックAを手作業で、マクロのファイルと同じフォルダに名前を付けて保存。 その際に、名前は取込データとする。 次からは、それぞれのファイルへ上書きして保存する事になる。 マクロのファイルには、データ　というシートを準備 1行目A～Kに項目名を入れておく。 実行するマクロ Sub 予定表作成() ' 予定表作成 Macro Sheets("データ").Select GYOU=Range("G" & Rows.Count).End(Xlup).Row+1 '蓄積されているデータの最終行の一つ下の行番号を取得 Workbooks.Open(Filename:=ThisworkBookPath & "\取込データ.xls") Sheets("取り込みシート").Select KENSU=Rnage("N1").Value ThisWorkBook.Sheets("データ").Range("A" & GYOU & ":K" & GYOU+KENSU).Value=Range("A3:K" & KENSU+3).Value Sheets("予定表").Rnage("A3:M1000").ClearContents ActiveWorkbook.Save 'ボタン操作ミスで重複取込防止のために取り込んだら空白にして保存 ActiveWorkbook.Close Sheets("元のシート").Select End Sub ボタンをクリックするとデータのシートに値が入る。 メールを操作してブックBを取込データのファイルへ上書きして保存する。 マクロを実行 データのシートの下の行に値が入るはずです。 実証はしていませんのでスペルミスなどあれば修正しながら活用してみてください。 >毎月異なるファイル名の指定方法が分からないので 同じフォルダに同じ名前で上書きして使うと良いです。 コピーではなく ThisWorkBook.Sheets("データ").Range("A" & GYOU & ":K" & GYOU+KENSU).Value=Range("A3:K" & KENSU+3).Value 指定した範囲の値を入れるというやり方です。
http://hamachan.info/win7/Excel/narabekae.html いいのがありました、ご参考にどうぞ！
１．Ctrl+Fで検索ボックスを表示 ２．オプションボタンを押し、詳細設定画面を出す ３．書式ボタンを押し、指定した背景色と同色を選択 ４．すべて検索ボタンを押す ５．検索結果が表示されるので、下の小窓でCtrl+Aを押すと、指定した色と同色すべてが選択される ６．セルはクリックせずに、ウインドウをクリックしてアクティブにする ７．「１」と入力しCtrl+Enterを押すと選択した同色すべてのセルに１が入力される ８．白色セルも同様の操作で、「０」を入力しCtrl+Enterで入力 以上により、色つきセルと色なしセルに１と０が入力される。 あとはSum関数を使うなりして、個人点数を集計する。
こんにちは！ 部分一致ではなく完全一致ですね？ （「東京都」が含まれているセルではなく、「東京都」のセルそのもの） 一例です。標準モジュールにしてください。 Sub Sample1() Dim k As Long, c As Range, myFlg As Boolean For k = 1 To Worksheets.Count With Worksheets(k) Set c = .Cells.Find(what:="東京都", LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then myFlg = True .Cells.Replace what:="東京都", replacement:="静岡県", lookat:=xlWhole .PrintOut End If End With Next k If myFlg = False Then MsgBox "該当シートなし" End If End Sub こんな感じではどうでしょうか？m(_ _)m
#1です。 あれ。そんなところにチェックが入りますか。 Sub 検索() Cells.Find "", , xlValues, , , , , False CommandBars.FindControl(ID:=1849).Execute Application.SendKeys "%T{TAB 2}{DOWN 2}%D{TAB}" Application.SendKeys "%T{TAB 2}{DOWN 2}%D{TAB}" End Sub これでどうですか？
>　以前にこのサイトで質問させて頂き　内容が変わったので改めて質問させて頂きます。　(以前の質問に答えて頂いた方、本当にありがとうございました） >　以前、質問した際は　《ＩＤとコードが一致したら明細表に記載するというマクロを教えて頂いた》のですが >　今度は、《ＩＤと項目と内容が一致したら料金を記載するという３つ一致したら記載する》ケースで、さらに明細側のシートの項目がセル結合している箇所があるので行き詰まっています。 ～～～～～～～～～～～～～ 以前の回答内容がわかりません。以前の質問と回答のあるURLはどれですか。 質問者ヒトゲノムさんの質問履歴を開示してください。 《ＩＤと項目と内容が一致したら料金を記載するという３つ一致したら記載する》日本語がよくわかりません。　一致する3つとは何のことでしょうか。 【転記先の番号とＣ列の項目とＤ3~L3の項目が一致した金額を別シートへ転記します】この日本語もよくわかりません。　別シートとはどのシートでしょうか。 セルが結合している個所が、マクロ作成上で注意を要するようには思えないです。 どのようなコードを使い、その結果どうなって、どこで躓いているのかを、記載していただくのが、アドバイスをもらう上で大事だと思います。
No.１です。 大の月・小の月の兼ね合いがあるみたいですね。 =IF(A1=EOMONTH(A1,0),A1,EDATE(A1,-1)+1) としたらどうなりますか？ ※　制度の詳しい仕組みは判らないので 単に日付重視でやっています。m(_ _)m
続けてお邪魔します。 ＞用紙が正副と続きになっておりまして・・・ そういう理由があったのですね。 それではもう一度コードを載せてみます。 Sheet2とSheet3のレイアウトは同じ配置だとします。 今回も標準モジュールです。 Sub Sample2() Dim i As Long, wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") With Worksheets("Sheet1") For i = 2 To .Cells(Rows.Count, "A").End(xlUp).Row '▼Sheet2の処理// wS2.Range("B1") = .Cells(i, "A") wS2.Range("C4") = .Cells(i, "B") wS2.Range("I4") = .Cells(i, "C") '▼Sheet3の処理// wS3.Range("B1") = .Cells(i, "A") wS3.Range("C4") = .Cells(i, "B") wS3.Range("I4") = .Cells(i, "C") '▼両Sheetを印刷// wS2.PrintOut wS3.PrintOut Next i End With End Sub ※　粛々と順番にやっているだけです。m(_ _)m
こんにちは！ 一例です。 Sheet2の表示したいセルに =IFERROR(INDEX(Sheet1!$2:$2,,SMALL(IF(Sheet1!$2:$2<>"",COLUMN($1:$1)),ROW(A2))),"") 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　Sheet2の表示したいセルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 このセルのフィルハンドルで下へコピー！ これで何とかお望み通りにならないでしょうか？m(_ _)m
=RIGHT(MODE(A1:A20*10000+B1:B20),4)*1 ついでに =LEFT(MODE(A1:A20*10000+B1:B20),9)*1
こんにちは！ すでに回答は出ていますが、一例です。 A～D列に「東京会場」から始まるセルは1セルしか存在しないという前提です。 とりあえず「範囲を選択」に止めています。 Sub Sample1() Dim c As Range Set c = Range("A:D").Find(what:="東京会場*", LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then c.Resize(36, 4).Select End If End Sub ※　複数存在する場合は別の方法を考える必要があります。 こんな感じではどうでしょうか？m(_ _)m
"=A1"　がNG =COUNTIFS($D:$D,"=A1",$E:$E,"=1",$F:$F,"=1") これの意味していることは、D列の値がA1ならば・・・という事になります ここで、A1はA1セルの内容と比較しているのではなく、A1という文字列とイコールかどうかを判定しています。 A1セルの内容と比較したいのであれば、"="&A1　と直してください
> 数字は必ず6種類で ということなら A列にデータがあるとして B1：=MIN(A:A) B2：=SMALL(A:A,COUNTIF(A:A,"<="&B1)+1) B2を B5までコピー
やりたいことは平日の出勤日の抽出ですよね？ 平日の出勤日に『出』と表示する式です。あとは適当にアレンジください。 F5セルに下式を入力して下方向にコピペです。 =IF(MID(INDEX($I$5:$I$18,WEEKNUM(B5,2)),WEEKDAY(B5,2),1)="出","出","") ※セル参照は修正が必要です。 添付図を参照ください。この例ではシート２のデータ(非稼働・出勤データ)も便宜上同じシートに記入しています。 非稼働日／出勤日の表示は、漢字にするよりもアルファベットのほうが入力しやすいとおもいます。わかりにくくなるので、あくまで参考ですが・・・。 例（非稼働日：休、出勤日：出）⇒（非稼働日：H、出勤日：S）　等、
こんばんは。 こちらの続きですね。 https://oshiete.goo.ne.jp/qa/9155380.html 前のご質問とカテゴリが替わっていたので気が付きませんでした。 Access使いなので、あまり Excel のところは見ないので。 相変わらず手抜きです。エラー処理を全く入れていません。 ブックが見つからない場合など無視するだけです。 Sub Sample() 　　Dim wBook As Workbook 　　Dim h As Hyperlink 　　Dim rng As Range 　　On Error Resume Next 　　ChDir ThisWorkbook.Path　　'相対アドレスに対応 　　For Each h In ThisWorkbook.ActiveSheet.Hyperlinks 　　　　Set rng = h.Range 　　　　Set wBook = Workbooks.Open(rng, False, True) 　　　　rng.Offset(0, 1).Value = wBook.Worksheets("Format").Range("A1").Value 　　　　wBook.Close 　　Next End Sub 表示文字列ではなく、ハイパーリンクアドレスで処理するなら 　　Set wBook = Workbooks.Open(h.Address, False, True) のように。 ついでに yokomaya さんへ > その前になぜループ内でオープン、クローズしているのでしょう？ 質問者さんの > 以下に記載したのは、１列目に入っているi行目のファイルのパスを開き、 という記述、 すなわち、行ごとに異なるファイル名が書かれていて、それを順に処理するからです。
他には A１セルに ☆C2 A２セルに ☆D2 A1:A2セル範囲を選択して下へオートフィル その範囲選択したまま[Ctrl]+[H]置換 ☆ → = に「すべて置換」する
「頭」の定義(左から何文字目までとか、場合によって変わるなら「どんな場合にどうするとか)は？
> 2行目と4行目と5行目のように空白になっている > 行を一気に解除する関数か何か方法 次のような方法があります。 1. ああああ ～ うううう 間のセルを選択します。 2. [Ctrl]キーを押しながら[G]キーを押すと、「ジャンプ」ダイアログボックスが表示されます。 3. 「セル選択」ボタンを押して、表示される「選択オプション」で、「空白セル」をオンにして「OK」ボタンを押すと、空白セルだけが選択されます。 4. 「ホーム」タブの「セル」グループにある「削除▼」→「シートの行を削除」をクリックします。 5. 「削除」ダイアログボックスが表示された場合は、「上方にシフト」をクリックします。 「空白セル（空欄セル）のある行だけを一気に削除して上づめするには」 http://kokodane.com/2013_waza_008.htm
'初質問かつエクセル詳しくないので、言葉足らず、 なので次のように推量します。C6の値は 2016/1/23 のように入力として 条件式は =OR(C6=DATE(YEAR(C6),MONTH(C6),8-WEEKDAY(DATE(YEAR(C6),MONTH(C6),1))),C6=DATE(YEAR(C6),MONTH(C6),22-WEEKDAY(DATE(YEAR(C6),MONTH(C6),1))))
こんにちは！ 画像通りの配置だとしての一例です。 Sub Sample1() Dim j As Long, cnt As Long Dim myFound As Range, myFirst As Range Range("J2:O13").ClearContents For j = 10 To 15 cnt = 0 Set myFound = Range("A:D").Find(what:=Cells(1, j), LookIn:=xlValues, lookat:=xlWhole) If Not myFound Is Nothing Then Set myFirst = myFound cnt = cnt + 1 Cells(cnt + 1, j) = myFound.Offset(2) Do Set myFound = Range("A:D").FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do cnt = cnt + 1 If cnt > 12 Then Exit Do Cells(cnt + 1, j) = myFound.Offset(2) Loop End If Next j End Sub こんな感じではどうでしょうか？m(_ _)m
あくまでも、考え方だけですが そのＪＰＥＧ変換したい領域を 新しいブックに画像貼り付けして それをさらにコピーしてＪＰＧで貼り付けます。 その新しいブックを名前を付けて保存して 拡張子をｘｌｓｘからＺＩＰに変更して その中からＪＰＥＧファイルを解凍して取り出します。 これをマクロ化すれば出来るのではないでしょうか？
ほかの方がおっしゃるように 大項目　中項目　小項目　と列を準備して 順に絞り込みながら入力規則の作業を行う方法が一般的ですね。 もう少し簡単な方法として リストデータに項目行を追加していきます。 例 　A 　A1234 　A1235 　A1236 　B 　B1234 　B1235 　C 　C1234 ・・・ といったように途中、途中に大項目を入れておく セルに入力作業時 　まず　Bと入れてから、プルダウン 　Bの行から表示が始まります。
表１と表２は全く別ファイルであり、 いくつも種類があるので２つのファイルを統合させて計算式を入れていくのは恐らく大変だと思います。 どこが難しいのか質問からわかりにくいのですが 表2のシートの右側の空いているセルに、仮の表1を準備する 仮表１ A・・・・L　M 　　　　A社 　　　　B社 　　　　C社 として、M列に　=SUMIF関数で売り上げ金額を計算 表1の部分をコピー 別ファイルに値として張り付けるでは駄目でしょうか。
こんばんは！ 列番号に規則性がないのですね？ 一例です。 Sub Sample1() Dim c As Range, myRng As Range, myArea As Range Set myArea = Range("C39:F39,H39:J39,N39:O39,Q39:R39,T39:Y39,CL39:CP39,CR39:CT39") For Each c In myArea If c <> "" And c = 0 Then If myRng Is Nothing Then Set myRng = c Else Set myRng = Union(myRng, c) End If End If Next c If Not myRng Is Nothing Then myRng.EntireColumn.Hidden = True End If End Sub ※　規則性がないセルを一旦範囲指定し、その範囲を順にループさせるだけです。 こんな感じではどうでしょうか？m(_ _)m
日付を１個入力したら「オートフィル」すれば大の月小の月もちゃんとやって埋めてくれますがな。 曜日の表示は、そのセルを =TEXT(そのセル,"aaa") って指定すれば曜日の漢字「月火水木金土日」を区別して表示してくれます
No.3です カテゴリ数が3つ以上ないとLOOKUP関数はまずいのでVLOOKUP関数に修正 =VLOOKUP(B14,INDEX($B$2:$B$9,MATCH($A14,$A$2:$A$9,0)):INDEX($D$2:$D$9,MATCH($A14,$A$2:$A$9,0)+COUNTIF($A$2:$A$9,$A14)-1),3)

まだ閉じられていなかったので VBA で専用の処理を記述するのはアリですか？ 無ければスルーということで･･･ 以下手順で、新規ファイルで確認してみてください 以下を標準モジュールに記述します Public Sub testData() 　　Const CROWH As Long = 5000 　　Const CVWIDTH As Long = 300 　　Dim vA(1 To CROWH, 1 To 1) As Variant 　　Dim i As Long 　　Randomize 　　For i = 1 To CROWH 　　　　vA(i, 1) = Int(CVWIDTH * Rnd()) + 10000 　　Next 　　Cells.Delete 　　Range("A1").Resize(CROWH).Value = vA End Sub Public Sub Samp1() 　　Dim dic As Object, dicC As Object 　　Dim vA As Variant, v As Variant 　　Dim i As Long, j As Long, k As Long 　　Const CNUM As Long = 10 　　Set dic = CreateObject("Scripting.Dictionary") 　　Set dicC = CreateObject("Scripting.Dictionary") 　　With ActiveSheet 　　　　With .Range("A1", .Cells(Rows.Count, "A").End(xlUp)) 　　　　　　vA = .Value 　　　　　　If (Not IsArray(vA)) Then 　　　　　　　　v = vA 　　　　　　　　ReDim vA(1 To 1, 1 To 1) 　　　　　　　　vA(1, 1) = v 　　　　　　End If 　　　　End With 　　End With 　　For i = 1 To UBound(vA) 　　　　If (vA(i, 1) <> "") Then 　　　　　　j = dicC(vA(i, 1)) 　　　　　　k = j + 1 　　　　　　dicC(vA(i, 1)) = k 　　　　　　If (Not dic.Exists(k)) Then 　　　　　　　　dic.Add k, CreateObject("Scripting.Dictionary") 　　　　　　End If 　　　　　　dic(k)(vA(i, 1)) = Empty 　　　　　　If (j > 0) Then dic(j).Remove vA(i, 1) 　　　　End If 　　Next 　　ReDim vA(1 To 3, 1 To 1) 　　k = 1 　　For i = dic.Count To 1 Step -1 　　　　j = dic(i).Count 　　　　If (j > 0) Then 　　　　　　ReDim Preserve vA(1 To 3, 1 To j + k - 1) 　　　　　　j = 0 　　　　　　For Each v In dic(i).Keys 　　　　　　　　vA(1, k + j) = k 　　　　　　　　vA(2, k + j) = v 　　　　　　　　vA(3, k + j) = i 　　　　　　　　j = j + 1 　　　　　　Next 　　　　　　k = k + j 　　　　　　If (k > CNUM) Then Exit For 　　　　End If 　　Next 　　Application.ScreenUpdating = False 　　With ActiveSheet 　　　　With .Range("C1").Resize(UBound(vA, 2), 3) 　　　　　　.EntireColumn.ClearContents 　　　　　　.Value = WorksheetFunction.Transpose(vA) 　　　　　　.Sort .Cells(1), xlAscending _ 　　　　　　　　, .Cells(2), , xlAscending, Header:=xlNo 　　　　　　.Columns(1).NumberFormatLocal = "0"" 位""" 　　　　　　.Columns(3).NumberFormatLocal = "0"" 回""" 　　　　End With 　　End With 　　Application.ScreenUpdating = True 　　Set dic = Nothing 　　Set dicC = Nothing End Sub 記述し　testData　を実行すると、 アクティブシート A列に確認用データが出来上がります Samp1 を実行すると、アクティブシートの A列データより 上位 10 までのデータが C1 から書き出されます A列入力のたびに表示を更新するために工夫します Samp1 をまるごと下側にコピーし、以下３箇所を変更します > Public Sub Samp1() ↓ Public Sub Samp2(wsIn As Worksheet, wsOut As Worksheet, sAdr As String) 前半部分の >　　With ActiveSheet ↓ 　　With wsIn 後半部分の >　　With ActiveSheet >　　　　With .Range("C1").Resize(UBound(vA, 2), 3) ↓ 　　With wsOut 　　　　With .Range(sAdr).Resize(UBound(vA, 2), 3) 操作するシートに以下コードを記述します Private Sub Worksheet_Change(ByVal Target As Range) 　　If (Intersect(Target, Columns("A")) Is Nothing) Then Exit Sub 　　If (Target.Rows.Count = Rows.Count) Then Exit Sub 　　Application.EnableEvents = False 　　Call Samp2(Me, Me, "C1") 　　Application.EnableEvents = True End Sub これを記述したシートのA列に変更があったら >　　Call Samp2(Me, Me, "C1") 自分のシートを対象に、自分のシートの C1 に結果表示 自分のシートに書き出すので、イベントを抑止しつつ･･･ 以下変更すると、結果は Sheet2 の A1 に書き出されます >　　Application.EnableEvents = False >　　Call Samp2(Me, Me, "C1") >　　Application.EnableEvents = True ↓ 　　Call Samp2(Me, Worksheets("Sheet2"), "A1") シートをまっさらにしてからのA列入力や testData　実行後の変更など、色々いじってみてください なお、実行させる状態を網羅しているわけではないので、 適宜変更してください。 ※ A列に入力されるものは、数値でも、文字列でも･･･
私だったら、フィルターオプション（AdvancedFilter ）を使いますね。 Sheets2の 　B1に　数量 　B2に　>=1 ３行目に、抽出する項目を入れておいて Sub Adfilter2() 　With Sheets("Sheets1") 　　.Columns("A:R").AdvancedFilter _ 　　　　Action:=xlFilterCopy, _ 　　　　CriteriaRange:=Range("B1:B2"), _ 　　　　CopyToRange:=Range("C3:R3"), _ 　　　　Unique:=False End With End Sub 詳しくは http://www.eurus.dti.ne.jp/yoneyama/Excel/vba/vb … のサイトなどにあります。
条件書式設定で、数式指定をすれば、指定したセルに反映できるので簡単です。 条件書式設定＞書式ルールの編集＞数式を使用して、書式設定するセルを決定＞ ＝（対象セル番地（例えばＡ1に5000と入れておくとして））<=9000 実入力例 =A1<=9000 設定後 >書式（Ｆ）をクリック セルの書式設定＞ユーザー定義＞種類　”0”　と　新規で作る　＞OK そのあとセルをコピーすると、設定が反映します。 条件書式設定をひらいてみると、設定範囲が設定されています。 最後のイメージを画像添付します。 Ａ1には5000と入力しましたが、0となっています。 Ａ6には9500と入力しましたので9500となっています。
NO2です。 ＞項目を増やしたいのですが（項目６まで増やしたいのです） 抽出する条件の項目ですかね。 　　A列　、Ｂ列 、C列 1　項目１　項目２　項目３ ２ #48700　AAA　＞１００ とか準備して Sheets("Sheet1").Columns("A:C").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("A1:C2"), CopyToRange:=Range("A3:B3"), Unique:=False とかすれば良いです。
此処は国語の教室ではないけれど、・・・ 「過去10年の年月日」があるのに、貴方は「その年」をどのセルに指定しているのかを説明しなきゃあ！
シート１の成約の部分は自分で手入力するとして、 Dim r as integer Dim i as integer i = Sheets("Sheet2").Range("B"&Rows.Count).End(xlUp).Row+ 1 'とにかく成約であればシート１の名前をシート２に入力する。 Do until Sheets("Sheet1").Cells(r,4) = "" If Sheets("Sheet1").Cells(r,4) = "成約"　then Sheets("Sheet2").Cells(i,2) = Sheets("Sheet1").Cells(r,3) i = i + 1 Endif Loop ’同性は削除 r = 1 Do until Sheets("Sheet2").Cells(r,2) = "" i = r+ 1 Do until Sheets("Sheet2").Cells(i,2) = "" if Sheets("Sheet2").Cells(r,2) = Sheets("Sheet2").Cells(i,2) Then Sheets("Sheet2").Cells(i,2).EntireRow.Delete i = i - 1 end if i = i + 1 Loop r = r + 1 Loop 的な？
ん～、やりたいことが 入力作業用のシートとデータのシートがあって、 作業用のシートに入力後、マクロのボタンを押すと データのシートの最後尾に追記されてほしいと結う事ですかね？ 作業用のシート 通しＮＯ　商品名　　　型番　　　　金額 　　　　　センサー　　ｋ３４５　　2000　 A2セル（通しＮＯ）は、=MAX(データ!A:A)+1 と入れておけば常に新しい番号になりますよね。 適当場場所に、ボタンを配置して Sub ボタン1_Click() With Sheets("Sheet2") GYOU = .Range("A" & Rows.Count).End(xlUp).Row + 1 .Range("A" & GYOU & ":D" & GYOU).Value = Range("A2:D2").Value End With End Sub では如何でしょうか？
まだ、良くわからないのですが、 旅費交通費　と云うシートがあって １～１２月の１２枚のシートから、適応項目　が旅費交通費のデータを 引っ張ってくる。 同様に、別の適応項目の名前のシートがあって、 １２枚のシートからデータを持ってくる これの繰り返し？ 合計で、シート数は何枚になるのでしょうか？ この結果が使いやすいとも思えないのですが？
貴方が「作ってみた」式がナッチョランです、はい。 でも「惜しいッ！」とも言えます。次の式を試してみて、何処がナッチョランか見極めてください。 N4: =SUMIFS(AQ5:CV5,AQ4:CV4,">="&K1,AQ4:CV4,"<="&L1)
説明の必死さはよくわかるが、結局理解できない。どこでつまづいたのだろうか？ =HYPERLINK(Sheet2!A1) とすれば、Sheet2!A1セルに書かれているURLをみることができる 表示を変えたい場合 =HYPERLINK(Sheet2!A1,”クリック”) そうではなく、Sheet2!A1セルにHYPERLINK関数で数式が書かれているとするならば その参照しているリンク先を参照すればよい たとえば、Sheet2!A1セルに =HYPERLINK(A2,”クリック”) ならば Sheet1!A1セルに =HYPERLINK(Sheet2!A2,”クリック”)
こんにちは！ ＞Application.EnableEvents のTRUEとFALSEが逆なのでは？ お示しのコードでは「イベントを止める」で終わっていますので そこでマクロそのものが止まってしまうと思います。 あくまで個人的見解ですが 今回のコードでは ＞Application.EnableEvents = False と ＞Application.EnableEvents = True の2行は不要な気がします。 （検証はしていません） 一般的にはChangeイベントなどで無限ループに陥るのを防ぐ場合、 この使い方をすることが多いと思います。 ※　万一エラーでマクロが止まったのであれば Application.EnableEvents = True の1行だけの別マクロで戻してあげないと お示しのプロシージャそのものがうんともすんとも言わなくなるのでは？ （これも未検証なので無意味だったらごめんなさい）m(_ _)m
No.1です。 修正しました。 原因はセルに数式を入れる指示にクォーテーションマークが足りていなかったためです。 自分は英数字のシート名で検証していたため問題なかったのですが、日本語(スペース入り)だとダメなようです。 数式がはいるB12セルが黄色になるようにしています。確認後、不要なら削除ください。(該当行はわかるようにしています) Sub ひな型コピー() '追加開始 Dim LastSheetName, ActiveSheetName As Variant Dim FirstFlag As Integer FirstFlag = 1 '追加終了 Range("i7").Select Range(Selection, Selection.End(xlDown)).Select Set 処理範囲 = Selection.Worksheet.Range(Selection.Address) For Each 処理セル In 処理範囲 On Error Resume Next Sheets("ひな型").Copy after:=Sheets(Worksheets.Count) ActiveSheet.Name = 処理セル.Value '追加開始 ActiveSheetName = ActiveSheet.Name If FirstFlag = 0 Then Sheets(LastSheetName).Range("B12").Formula = "='" & ActiveSheet.Name & "'!B44" Sheets(LastSheetName).Range("B12").Interior.Color = 65535 'この行は不要なら削除 End If FirstFlag = 0 LastSheetName = ActiveSheet.Name '追加終了 Next 処理セル End Sub
フィルタ機能です。 日本語で言うと絞り込みですね。不要な行を非表示にできます。 機能としてはExcel2013以前からあるものです。ファイルごとに設定するもので、勝手に追加されることはないはずです。 気にならないなら、そのまま使っても全く問題ありません。 その機能を使いたくないなら、メニュー　→　データ　→　フィルタ　でON/OFFできます。
No.3です。 ご提案のやり方でも可能と思います。 作業する上で注意する点としては、不要セルの削除の際に数式のまま削除すると結果が変わってしまいますので、削除する前に値に変換(値で貼りつけ)しておく必要があります。 以下に配列数式を使用しない代案も紹介しますので、更新頻度と作業の手間、待ち時間を天秤にかけて、使いやすいやり方を選んでいただくのがよいと思います。 代案です。（処理時間はこちらのほうが圧倒的に短かったです） ■配列数式を使わないやり方 元データはA2セル以下にある前提です。 １．B列を作業列にします ２．B2=IF(COUNTIF($A$2:A2,A2)=1,ROW()-1,"") と入力して、下にコピーします(元データと同じ行まで) ３．C2=IF(ROW(A1)>COUNT($B$2:$B$8000),"",INDEX($A$1:$A$8000,SMALL($B$2:$B$8000,ROW(A1)))) ４．C2の式を下にコピーします(種類数と同じ行まで) ５．D列はNo.6同じです(種類数と同じ行まで) まずは少なめのデータで試してみてください。試す際には手順３の8000(元データ数)も小さい値にしたほうがよいと思います。
優先順位は 新聞>ラジオ>ネット の順 ネットラジオ → ラジオメディア =INDEX({"","ネットメディア","ラジオメディア","新聞メディア"},MATCH(99,FIND({" ","ネット","ラジオ","新聞"},A1&" ")))
[No.2お礼]へのコメント、 》 ちなみにA列が　yyyy/mm/dd だった場合も対応できますか 「ちなみに」で再質問しないでください。 するなら、試してからそうしてください、２つも提示したのだから。
えと･･･ Sheet2のA1に ="吾輩は"&Sheet1!A1&"である" ？
[No.2お礼]へのコメント、 タイトルにも明記されていた「重複を除いて」を見落としていました。 「作業列を使わず」ともあるので、私にはそれを満足する能力はナシです。 ただし、何処でも好い、遠い彼方の僅か２個のセルだけのご使用を許可いただけるなら、次のように[フィルタオプションの設定]を利用して、チョー簡単に実現できそうです。ご一考ください。 １．範囲 A1:B1 を[コピー]してセル E1 に[貼り付け] ２．何処か邪魔にならない場所(此処では 範囲 H1:H2)の 　　上のセル H1 は空白のままに放置して、下のセル H2 　　に式 =C2>=10000 を入力 ３．次の条件で[フィルタオプションの設定]を実行した 　　結果を添付図に示しました。 　　　抽出先→ 指定した範囲 　　　リスト範囲→ $A$1:$C$9 　　　検索条件範囲→ $H$1:$H$2 　　　抽出範囲→ $E$1:$F$1 　　　“重複するレコードは無視する”にチェック入れ 最後の「チェック入れ」がミソです！
[No.2]の tom04さんが仰ったように =CODE(C1) をオートフィルして並べ替えする前(貴方の添付図のマンマ)の夫々の戻り値を、参考までに、教えて下さい。
条件１用のMacro1を修正しました。シートTotal1に追記していきます。 条件２用のMacro2を追加しました。シートTotal2に追記していきます。 Sub Macro1() Const DataStep As Long = 8 Const strCheck As String = "い" Dim num As Long Dim wsTT As Worksheet Dim i As Long Set wsTT = Worksheets("Total1") For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row Step DataStep With Range(Cells(i, "A"), Cells(i + DataStep - 1, "AI")) num = Application.WorksheetFunction.CountIf(Range(.Cells(1, "H"), .Cells(DataStep, "H")), strCheck & "*") If num = DataStep Then .Copy Destination:=wsTT.Cells(Rows.Count, "A").End(xlUp).Offset(1, 0) End If End With Next i End Sub Sub Macro2() Const DataStep As Long = 8 Const strCheck1 As String = "あ" Const strCheck2 As String = "い" Dim num1 As Long Dim num2 As Long Dim wsTT As Worksheet Dim i As Long Set wsTT = Worksheets("Total2") For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row Step DataStep With Range(Cells(i, "A"), Cells(i + DataStep - 1, "AI")) num1 = Application.WorksheetFunction.CountIf(Range(.Cells(1, "H"), .Cells(DataStep, "H")), strCheck1 & "*") If num1 > 0 Then If num1 < DataStep Then num2 = Application.WorksheetFunction.CountIf(Range(.Cells(1, "H"), .Cells(DataStep, "H")), strCheck2 & "*") If num1 + num2 = DataStep Then .Copy Destination:=wsTT.Cells(Rows.Count, "A").End(xlUp).Offset(1, 0) End If End If End If End With Next i End Sub
Sheet2!D2: =SUMPRODUCT((Sheet1!A$2:A$100=A2)*(Sheet1!B$2:B$100=B2)*(Sheet1!C$2:C$100=C2),Sheet1!D$2:D$100) ついでながら、貴方の質問文は今回の内容に関する限り問題ナシ、と断言します。Excel 使いに慣れた者ならソレで充分です。
A列で降順または昇順で並び替えられているとする 1. C1セルに =INT(SUMPRODUCT(1/COUNTIF($A$1:A1,$A$1:A1))*10^3+COUNTIF($A$1:A1,A1)) 　フィルハンドルダブルクリック 2. Sheet2!A1セルに =INDEX(Sheet1!$A:$A,MATCH((ROW(A1)+1)*10^3,Sheet1!$C:$C)) 下へオートフィル 3. Sheet2!B1セルに =IF(COUNTIF(Sheet1!$A:$A,$A1)<COLUMN(A1),"",INDEX(Sheet1!$B:$B,MATCH(ROW(A1)*10^3+COLUMN(A1),Sheet1!$C:$C,0))) 右へ下へオートフィル
コピーして、入れ替えて張り付けを実行せよ。
数字の間に｢.｣が2つ入ってますね これは、文字であり数値ではありません 従って、合計や平均を出すなどの計算はできません。 ［ 数値と数字 ］ 日常生活では数値も数字も同じ意味の言葉かもしれませんが、 コンピュータの世界では明確に区別されています。 数値は数を表現するもので、計算に使うことが出来ます。 数字は(人間の都合上)数値と同じ見た目であるに過ぎず、 コンピュータにとって数を表現するものではなく、計算に使えません。 http://detail.chiebukuro.yahoo.co.jp/qa/question …
両ファイルともシート名が分らないので、テキトーです。正しい名前を入れて下さい。 With Workbooks("B.xlsm").Worksheets("Sheet1") Workbooks("A.xlsm").Worksheets("Sheet1").Range("C1:C301").Copy _ destination:=.Cells(1, 1).End(xlToRight).offset(0,1) .Range("C1:XFD1000").Copy .Range("C1").PasteSpecial Paste:=xlPasteValues End With ＞Cells(1, 1).End(xlToRight).Columns(lastCloumns + 2).Select 変わった事をしてますね。Columns(lastCloumns + 2) lastColumnsはEmptyなので利いてませんが、１行目データ最終列のセルを求めて、そこを起点に２番目の列すなわち１つ右のセルを求めてます。最初はエラーと思いましたが、正常動作してます。
>C2に自動で入る文字に対して、それぞれの違うマクロを実行させようとしております。 Private Sub Worksheet_Change_1(ByVal Target As Range) If Target.Address <> "$A$2" Then Exit Sub End If ここまでは、同じ　そのあとに If Range("C2").Value ="特定の値" Then 実行したいコード End If 或いは、 Select Case Range("C2").Value Case 値1 Range("C2").Value=値1の場合の処理 Case 値2 Range("C2").Value=値2の場合の処理 Case Else Range("C2").Value=値1、変数=値2を満たさなかった場合の処理 End Select こういったコードになると思いますが A2セルに、入力して、Enter　を押したら C2の関数が実行されて Private Sub Worksheet_Change_1(ByVal Target As Range) が実行されます。
VBAを使うことでお望みのことはできるでしょう。 下記のサンプルは B1のセルに番号を入れると、 "色が変わる"シート見出しの色を変える サンプルソースです。 シート名のところで ①右クリック ②コードの表示を選択 ③VBE画面表示 ④下記のコードを貼り付け で動きを確かめてみてください。 Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Target.Address <> "$B$1" Then Exit Sub If Target = "1" Then Worksheets("色が変わる").Tab.ColorIndex = 1 If Target = "3" Then Worksheets("色が変わる").Tab.ColorIndex = 3 If Target = "5" Then Worksheets("色が変わる").Tab.ColorIndex = 5 End Sub これを応用すれば、お望みのことは できると思われます。 いかがでしょうか？
No.3 の回答した者です． B列としましたがH列でした．わかると思いますが，念のため． =IF(COUNT(H6:H21)=COUNTIF(H6:H21,H6),"○","×")
No.2が参照しているのは間違いでNo.1が正解です。 =IF(A1-(13/24)<0,A1+(11/24),A1-(13/24)) 1900年1月0日0時が0ですからマイナスにはなれません。 todayでは時刻の値は返らず時刻は0:00になるので、時差計算はできません。
>出来高が変数で毎日入っていきます。 既に、マクロを使っているのですかね。 だとしたら、シートの構成から直しましょう。 日々のデータは、縦方向にします。 　　A　　　B　　C 年月日　出来高　残数 1/1 1/2 ・・・ この方が、セルを移動する時にマウスのスクロールが使えて便利ですよね。 パソコンは、データは縦方向に入力する様に作られています。 データの抽出においても、フオートフィルター、フィルターオプションなど機能が使えます。 フィルターも縦方向だけですよね。
こんにちは ブック間の制御はクセがありますので、参考になればと思いました ※切り替えたとたんに相手ブックに依存するのが面倒なところです 'ここから Sub test() Dim myName As Variant myName = Application.GetOpenFilename("Excelファイル (*.xls;*.xlsm),*.xls;*.xlsm") If myName = False Then Exit Sub 'ここで相手先ブック名が入力されます(使わせて頂きました) DIM WB as Workbook Set WB=Workbooks.Open(myName) 'ここから相手先ブックに制御が移ります 'この間、好きに相手先ブック内を編集できます '例えば Cells(1,1)=Cells(2,1) Cells(2,1)=Cells(2,2) Cells(3,1)=Cells(2,3) 'など全て相手ブック内で動作します WB.Close SaveChanges:=true '仕事が終わったら、相手先ブックを保存終了させます(肝心なところ) Set wB=Nothing 'オブジェクトの開放(忘れずに) 'ここから自ブックの制御に戻ります End Sub 'ここまで ブック間の制御は面倒です では
単純にA列全体に「 13??? 」から始まる というテキストフィルタをかけてはどうでしょう。 １行下げてA1は空白にしたほうが見やすいかも。
VBA で良かったでしょうか？ ダメならスルーということで 処理範囲の行は A3 ～ A列データのある行とします 行の範囲を求めたら、B列 ～ F列を配列に読み込みます （C列は非表示？） 修理業者をベースに Dictionary にデータを覚えていきます Dictionary は３段構成 １段目キー：修理業者名 ２段目キー：行番号 ３段目キー：日付 Dictionary に展開できたら、 各修理業者の異なる行番号での日付差をグルグルチェックしていきます ※ B列 ～ F列を読み込んだ配列 vA は、 Dictionary に覚えたら不要になるので、 vA の１列目を結果書き出し用に再利用しています Public Sub Samp1() 　　Dim dic As Object 　　Dim vA As Variant, vK As Variant 　　Dim vRp As Variant, vRc As Variant 　　Dim vDp As Variant, vDc As Variant 　　Dim i As Long, j As Long 　　Dim bSkip As Boolean 　　Const CDAYW As Long = 6 　　Const CMOJI As String = "調整" 　　Set dic = CreateObject("Scripting.Dictionary") 　　With Range("A3", Cells(Rows.Count, "A").End(xlUp)) 　　　　vA = .Columns("B:F").Value 　　　　For i = 1 To UBound(vA) 　　　　　　If (vA(i, 1) <> "") Then 　　　　　　　　For j = 3 To UBound(vA, 2) 　　　　　　　　　　If (vA(i, j) <> "") Then 　　　　　　　　　　　　If (Not dic.Exists(vA(i, 1))) Then 　　　　　　　　　　　　　　dic.Add vA(i, 1) _ 　　　　　　　　　　　　　　　　, CreateObject("Scripting.Dictionary") 　　　　　　　　　　　　End If 　　　　　　　　　　　　If (Not dic(vA(i, 1)).Exists(i)) Then 　　　　　　　　　　　　　　dic(vA(i, 1)).Add i _ 　　　　　　　　　　　　　　　　, CreateObject("Scripting.Dictionary") 　　　　　　　　　　　　End If 　　　　　　　　　　　　dic(vA(i, 1))(i)(vA(i, j)) = Empty 　　　　　　　　　　End If 　　　　　　　　Next 　　　　　　　　vA(i, 1) = "" 　　　　　　End If 　　　　Next 　　　　For Each vK In dic.Keys 　　　　　　For Each vRp In dic(vK).Keys 　　　　　　　　If (vA(vRp, 1) = "") Then 　　　　　　　　　　bSkip = False 　　　　　　　　　　For Each vDp In dic(vK)(vRp).Keys 　　　　　　　　　　　　For Each vRc In dic(vK).Keys 　　　　　　　　　　　　　　If (vRp <> vRc) Then 　　　　　　　　　　　　　　　　For Each vDc In dic(vK)(vRc).Keys 　　　　　　　　　　　　　　　　　　i = Abs(DateDiff("d", vDp, vDc)) 　　　　　　　　　　　　　　　　　　If (i <= CDAYW) Then 　　　　　　　　　　　　　　　　　　　　vA(vRp, 1) = CMOJI 　　　　　　　　　　　　　　　　　　　　vA(vRc, 1) = CMOJI 　　　　　　　　　　　　　　　　　　　　bSkip = True 　　　　　　　　　　　　　　　　　　　　Exit For 　　　　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　　　Next 　　　　　　　　　　　　　　　　If (bSkip) Then Exit For 　　　　　　　　　　　　　　End If 　　　　　　　　　　　　Next 　　　　　　　　　　　　If (bSkip) Then Exit For 　　　　　　　　　　Next 　　　　　　　　End If 　　　　　　Next 　　　　Next 　　　　.Columns("G").Value = vA 　　End With 　　Set dic = Nothing End Sub
=Sheet1!N2/Sheet２!B42 の代わりに下式を入力 =Sheet1!N2/OFFSET(Sheet2!$B$42,ROW(A1)-1,ROW(A1)-1) これを下方向にコピー＆ペーストすればできると思います。 >試してみたのですが反映されませんでした。 No.1さん、NO.2さんへのお礼に書かれたこの文章の意味は、セルに質問文に記入されたとおりの式(以下参照)が入力されることを期待されているのでしょうか？ =Sheet1!N2/Sheet２!B42 =Sheet1!N3/Sheet２!C43 =Sheet1!N4/Sheet２!D44 もしそうだとすると、関数ではできません。 記述は同じではありませんが、上に書いた式で期待されている計算結果が得られます。 この推測が間違っているのなら、期待されている回答を得るためにも、『反映されなかった理由』『どんな結果を期待されているか』を具体的に書いていただきたいです。 同じ記述にするにはマクロを使えば可能です。しかし、これだけのためにマクロを組むのは時間と労力の無駄です。 ただし、マクロの勉強としてならよいと思いますが・・・。
> グラフを作成する問題4で、赤丸の箇所の「データラベルを“男のみに設定”」となっていますが、可能なのでしょうか？ 可能です。 次のように操作します。 1. 削除したいデータラベルをゆっくり２回クリックすると、２回クリックしたラベルだけが選択されます。 2. [Delete]キーを押して、削除します。 この操作を応用すると、特定のデータが目立つように、棒やマーカーの色を変えたりサイズや形を変えたりできます。 「ここに注目！Excelの棒グラフで“強調したい1本”だけ棒の色を変える」 http://itpro.nikkeibp.co.jp/article/COLUMN/20060 …
PowerPivot for Excelは、Windowsのバージョンに依存するものではなく、Excelのバージョンに依存するのではないでしょうか？ そんなに行数が必要なら、Accessを使用されたほうがよいです。ファイル容量2GB以内ならレコード数(行数)の制限はありません。 そんな行数を使って何をするのかわからないので、一つの提案として書いています。
No3です 添付図忘れたので再回答です。 質問文の数字とは違いますが、答えの式は変わりません。 ア. A1以上A2以内を入力。 イ. 除外する値を　A6,A7 に入力。 以上の条件で ウ. B1　に式　+A1　を入力。 エ. B2 に次式を入力。 　　+IF(B1="","",IF(B1+1>$A$2,"",IF(OR(B1=$A$6-1,B1=$A$7-1),B1+2,B1+1))) オ．B2セルを　必要なだけズル・・・ズルッと　オートフィルコピーする。 【追記】 もし除外値がA8 に追加されたら 上式　OR( )の中は　OR(B2=$A$6-1,B2=$A$7-1,B2=$A$8-1)と追記してください
こんばんは 「新たにopen表示になった時だけ」 →ということは、新たに表示される前のデータをどこかに保持しないといけませんね。 なので、IF文に条件を付け足し、ループの最終行に状態を保持する式を いれました。 Private Sub Worksheet_Calculate() Dim j As Long For j = 1 To 3 'sheet1のB列がopenになった時、sheet2と比較して、新たにopenであればIFの処理内容へ、既にopenであればEndIFへ If Range("B" & j).Value = "open" And Range("B" & j) <> Sheets("sheet2").Range("B" & j) Then With Application .EnableEvents = False .Speech.Speak "新たに " & j & "行目 " & Range("B" & j), True .EnableEvents = True End With End If 'sheet2にB行、ループ実行列の状態を保持する Sheets("sheet2").Range("B" & j) = Range("B" & j) Next j End Sub ところで、ワークシートのA列に入力されるたびにマクロ内のループが発動されてしまいますが、良いのでしょうか？ 入力が変わったセルだけ対象にするのであれば、ループをやめて、入力セルの行だけスピーチ対象にしたほうがいい気がします。
考え方の一つに、文字列の長さを調べて、必要な文字の長さを切り出すという方法がある。 ＝LEFT(A1,LEN(A1)-4） No.1で答えられているような、切り出した文字列を元の文字列から削除（空白に置き換える）と言う方法もありだろう。
印刷時にすべてのページに表の見出し行を挿入するには、 下記URLのページをご覧になってお試し下さい。 2007　以降のExcelをお使いの場合、 「印刷タイトルで見出しを固定」 http://www.becoolusers.com/excel/print-titles.html 2003 以前のExcelをお使いの場合、 「印刷タイトルで行・列を固定」 http://kokoro.kir.jp/excel/print-title.html
こんにちは！ コードは表示・非表示を一気にやっていますので、確認できません。 表示と非表示を別コードにしてみました。 横位置の右端はO列左端からコメント幅の　1/10　離しています。 Sub コメント表示() With Range("O25").Comment .Visible = True With .Shape .Left = Range("O25").Left - .Width * 1.1 '←横位置は適宜好みで！ End With End With End Sub ※　上記コードでは表示されっぱなしですので、非表示のコードが↓です。 Sub コメント非表示() Range("O25").Comment.Visible = False End Sub こんな感じではどうでしょうか？m(_ _)m
略 SendKeys "%fa", True '名前を付けて保存のダイアログ画面を表示する Call Sleep(500) '0.5秒だけ処理を休止する SendKeys ThisWorkbook.Path & "\Memo.txt", True 'ファイル名をフルパスで指定する Call Sleep(500) '0.5秒だけ処理を休止する SendKeys "%s" 'ファイルを保存する こうっすかね。バッファかな？メモリかな？ってところですが正確には原因は特定できませんでした。 自身で1秒処理を止めている辺り気付いているんでしょうけど、一番のボトルネックになっているのは視覚効果かと推測。 ttp://www.yakushima-tonbo.com/windows/Windows7/Windows7_reiryo_2.htm Windows8や10は知らんですが、似たようなオプションがあるので切るという手を試してみてください。 上記よりもうちょい確実に、と考えるなら数回に分けるのが無難かと思います。 ・SendKeysで半角スペースをファイル名欄に送る、またはDELかBSを送ってデフォルトの「*.txt」を消させる ・SendKeysで本来のパスを送る （フルパスの先頭が空白だったら無視されるのでそのまま保存できる） これだと1回目のSendKeysでコケても問題は出ないと思います。
2010でもできますよ？もう一度やり方をよく見てトライしてください ttps://121ware.com/qasearch/1007/app/servlet/relatedqa?QID=012825 それでも、できないのであればマクロを利用する方法がありますが、とりあえずは上記の方法でやってみてください。
ご質問と回答の次元が違ってたらごめんなさい。 普通に表示されますが？ 右クリック→セルの書式設定で数値→小数点以下の桁数は6になっていますか？
郵便局が提供している年賀はがき作成ソフト「はがきデザインキット 2016」（無料）をお勧めします。 http://yubin-nenga.jp/design_kit/
ここで説明して伝えるのは、難しく、困難だと思っているのですが、少しチャレンジしてみます。もともと、自分でも関数だけで実現出来るとは思ってなかったのですが、関数を使いまわして、それっぽいのが出来たので、自分の覚えのつもりでもあります。 １）日付の入力は整数とし、startからfinishは一ヶ月は超えず、startの日付は当月、finishの日付は(startの日付と同日～月末日の日付なら当月中)(startの日付より若い日付なら翌月の日付)とみなす。 ２）同じcode番号では、担当者は1名～5名まで指定可能。6名以上をアサインする場合はcode番号に添え字をつけて対応する。（例　ANA-004とANA-004-2のように） ３）一度あるCODE番号で担当をアポイントしたあとで、キャンセルに変更した場合は、当月中はそのcode番号と担当の指定状況は画面上残すが、翌月はリストから削除する。当月もカレンダには集計の対象としても扱わないし、担当者別の当月就業記録にも(なかったもの)として扱う。一度キャンセルにしたcode番号のCANCELLの文字を削除した場合は、そのCODE番号の担当を割り当ては復活する。 ４）結果の表(シート名Result)には、担当者全員の就業と休業の記録がカレンダー上の日付で識別表示され、就業日が同じCODE番号で連続する場合は、最初の日付にのみCODE番号を表示する。ある就業日に複数のCODE番号で就業した場合は、その件数と1つのCODE番号を表示する。また結果の表(シート名Result)には、当月の暦日日数、就業した当月の日数、休業登録した当月の日数を表記する。 ５）当月の入力や修正の結果で、翌月に引き継ぐべきCODE番号とその担当の指名状況はシート名NextMに反映させ、次月に値のコピー貼り付けの元データに出来るようにしておく。ただし、当月のスタート日付は継続させず、初日(ついたち)からスタートするような表記にする。 ６）担当の名前は、別のシート(STAFF)にシストとして入れておく。 ７）上記の処理を関数だけで行うために、入力や修正のために使うシート(CtrlPanel、STAFF)に作業領域を設ける他、作業用シート(PresentM、nextM、Pic、DAYOFF)を使用する。 ８）関数の可読性を高めるため、名前定義をつかう。 ９）対象行を抽出させるために、CtrlPanelのU～AC列に、対象行として認定するところに１，その１の個数集計(順位番号)、その行のROW位置を入れておく。そして、例えば、INDEX(RawDATA,VLOOKUP(ROW()-3,NextPosi,2,0),1)とか、INDEX(NextPosi,VLOOKUP(ROW()-3,NextPosi,2,0),11)などの関数を使用して、必要なデータを選択させている。 10）指定したstartとfinishの日付は、カレンダーのcolumnの番号と大小比較して、該当日を勤務日あるいは休暇申請日として扱う。例えば、Picシートでは、Pic１～Pic５を縦に並べ、各Pic毎にcode番号とそのPicでの担当名が入っていて（その自動反映の方法は別途記載する）、例えば、次の式　IF(AND(U$9>=$H905,U$9<=$I905),$E905,"")　この場合9行目に月初を1としての日数が入っていて、H905にstart、I905にfinishがあれば、E905の担当者名を入れるようにしている。 11）Picシートでは、10)のようにpic１～５で、code番号×日付の交差セルに担当者を入れたものを、担当者別×日付の交差セルに、例えば、=IF($E15="","",IF(COUNTIFS(U$100:U$2090,$E15)=0,"",IF(COUNTIFS(U$100:U$2090,$E15)>1,COUNTIFS(U$100:U$2090,$E15)&":"&INDEX($A$100:$A$2090,MATCH($E15,U$100:U$2090,0)),INDEX($A$100:$A$2090,MATCH($E15,U$100:U$2090,0)))))　のような式で、担当にとってその日付で就業するcode番号INDEX($A$100:$A$2090,MATCH($E15,U$100:U$2090,0))を表記させる。その場合、同じ日付で複数のCODE番号があれば、その件数COUNTIFS(U$100:U$2090,$E15)を先頭に付して表記させる。 12）結果の表（カレンダー表示）では、条件付き書式で、セルの背景を色分けをする際、ヒダに位置するセルと同じ文字列になっているセルの文字はセルの背景色と同じにすることで、見た目のわずらわしさを回避している。また結果の表（カレンダー表示）では、翌月の日付に該当する列の背景色も変更している。当月の個人別稼働日数や休暇申請日数、なんの指定でもない日数は、COUNTIFS(OFFSET($G5,0,0,1,$A$2),$A5)のように、$A$2の当月の月末日付=DAY(EOMONTH(A1,0))とOFFSET関数で集計対象を可変にして集計している。
ANDを使う以外に、大文字小文字それぞれで判定しているところはまとめられます。どうせ大文字でも小文字でも良いのであれば、UCase関数で全部大文字に変換しちゃえば一回で判定できると言う発想です。 オリジナル： If Range("CV" & gyou).Value = "S" Or Range("CV" & gyou).Value = "s" Then 変更後： If UCase(Range("CV" & gyou).Value) = "S" Then さらに短くしたければ、Valueを省略してしまう手があります。RangeオブジェクトのデフォルトプロパティがValueなので、以下のようにも書けます。 さらなる変更後： If Range("J" & gyou) = 1 Then If UCase(Range("CV" & gyou)) = "S" Then これとANDを組み合わせれば、IF文が劇的に短く済むでしょう。やってみてください。
別案ですが 関数が入っているセルを選択 右クリック＝＞セルの書式設定 表示＝＞ユーザー定義で 0_ ;[赤]-0 ; にすると、０の時だけ表示しなく出来ます。 その他には、条件付き書式の設定で ０の時に、文字色を背景の色と同じにする 方法があります。
残念ながら軸のラベル（TickLabels）にはインデントの設定ができません。 やや力技になりますが、事前にラベルに使用するセル内で改行しておけば、それっぽく出るかと思います。 揃えたい文字数が一緒なら改行だけで済むんですが、やはりあまった文字は中心に描画されます。 なにぬねの はひふへほ まみ　　　. 　というように、全角スペースと目立たない半角コンマで誤魔化す手法もあります。 縦書き自体がアジア圏以外では殆ど使用されないので機能として今後追加される可能性は低いかもしれません。 ちなみに、JustCalc（旧:三四郎）では出来たりします。
何度もすみません。No8、６のやり方はちょっと無理がありました。 Range("AKR1:ALX8").Copy Range("AKR" & St & ":ALX" & En).Select ActiveSheet.Paste の3行は必要かも？
こんばんは。 セルの許容範囲の限界値を越えているのではないでしょうか。 それと、補足で書かれた取得元のURLって、XMLデータでした。 私のExcel は、今のところ、2010なので、一旦XMLとして保存し、データ－その他のデータソースからインポートしました。 XMLなので、データベースとして見れればよいような気がしますが、どのようにして見れればよいのでしょうか。 こちらのワークシートは、以下のようになりました。特に、問題はなさそうでした。
止めたいときは『ESCキーを押す』です。 ただし、すぐには止まりませんし、止めたところから再開はできません。 作動確認をしたいということでしたら、VBA編集画面のメニューから『デバッグ』⇒『ステップイン』（F8キーで代用可）で1行ずつ実行させることができます。
オーソドックスな方法では 記号の下に、　Ｖｌｏｏｋｕｐ関数で、対応する数値を表示させて 最後に　Ｓｕｍ関数で合計します。 例えば 仮に　A1～B6が記号と数値の対応表で 9行目のA列から右に記号はあるとして =Vlookup(A9,A$1:B$6,2,FALSE) 右へコピーみたいな。 配列関数を使えば、一発で出す方法もありますが・・・ =SUM((A1:A6=A9:AF9)*B1:B6) と入れて　Ctrl＋Shift＋Enterで決定して 配列関数（式が　｛｝でくくられる）にしてみてください。
これで似たような結果になりますか？ =MATCH(LARGE(INDEX((L$9:L$15)+(M$9:M$15)*0.1,),ROW()-8),INDEX((L$9:L$15)+(M$9:M$15)*0.1,),0) 上のは、N列に入れる関数です。
こんにちは。 私は、数式は不得意ですから、どなたも、こちらの数式の不備についてのご批判は遠慮していただきたいのですが、数式だけなら、以下のようでいいのかなって思います。空白は、「0」を返します。 G4: =OFFSET(INDIRECT($G$2),ROW($A2)-1,COLUMN(A$1)-1) 下にドラッグコピー(セル2つ) H2: =OFFSET(INDIRECT($G$2),ROW($A1)-1,COLUMN(A$1)-1) 右にドラッグコピー(セル2つ)
武藤　玄さんのコラムに http://vbae.odyssey-com.co.jp/column3/s30702.html がありましたので紹介しておきます。 ＞カーソルをたとえば「A3」の「2」に移動するだけで エクセルには、マウスを移動した時にイベント発生する機能はありませんので セルを選択した時とかダブルクリックした時になってしまいます。 ご希望に合うか分かりませんが 選択した行に色を付ける 方法などは如何でしょうか。 検索してみると幾つかの方法が紹介されています。
こんばんは！ 横からお邪魔します。 G1セルに =SUM((A1>0)*B1,(C1>0)*D1,(E1>0)*F1) ではどうでしょうか？m(_ _)m
続けてお邪魔します。 Sheet1のA列には対象データが複数存在する場合があるのですね？ どうも失礼しました。 ↓のコードにしてみてください。 Sub Sample3() Dim i As Long, lastRow As Long Dim myStr As String, wS As Worksheet Dim myFound As Range, myFirst As Range Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row If lastRow > 1 Then Range(.Cells(2, "F"), .Cells(lastRow, "F")).ClearContents End If For i = 2 To wS.Cells(Rows.Count, "A").End(xlUp).Row myStr = wS.Cells(i, "A") & "*" & wS.Cells(i, "B") Set myFound = .Range("A:A").Find(what:=myStr, LookIn:=xlValues, lookat:=xlPart) If Not myFound Is Nothing Then Set myFirst = myFound myFound.Offset(, 5) = wS.Cells(i, "C") Do Set myFound = .Range("A:A").FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do myFound.Offset(, 5) = wS.Cells(i, "C") Loop End If Next i End With End Sub こんどはどうでしょうか？m(_ _)m
[No.2お礼]へのコメント、 》 …選ぶこと出来ない状態になっています ということは(他のファイルを呼んでいる)セルは存在しない、ということです。 なお、同一ブックの他シートのセルを呼んでいる状態は、一般に「リンク」とは申しません。 「リンク」とは外部参照のことです。
空白処理してないけど、条件付き書式ならこんなでも =OR(A$1=$B$6:$B$9,WEEKDAY(A$1,2)>5)
>途中の"*?" は、ワイルドカードとして検索するということでしょうか…？ その通り ?は1文字 つまり*?で1文字以上あるってことです まぁ9行めのように文字列しか対応しないのが痛いところですが。
No.1です。 ＞たとえば範囲がB3：P14などはどのように・・・ 前回のコードの ＞Intersect(Target, Range("A:A")) の部分が2か所ありますので、それを ＞Intersect(Target, Range("B3:P14")) に変えるだけで大丈夫だと思います。 もう一度全コードを記載すると Private Sub Worksheet_Change(ByVal Target As Range) 'この行から// If Intersect(Target, Range("B3:P14")) Is Nothing Or Target.Count > 1 Then Exit Sub '★ Application.EnableEvents = False With Target If .Value <> "" Then .Value = .Value + Range("Z1") End If End With Application.EnableEvents = True End Sub Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Intersect(Target, Range("B3:P14")) Is Nothing Or Target.Count > 1 Then Exit Sub '★ Range("Z1") = Target End Sub 'この行まで// といった感じになると思います。m(_ _)m
こんばんは！ https://oshiete.goo.ne.jp/qa/9137974.html とまったく同じコトです。 ちょっとコードを変えてみました。 Sub Sample2() Dim c As Range For Each c In Range("G19:S19") If c < Range("E1") Then c.EntireColumn.Hidden = True End If Next c End Sub といった感じで大丈夫だと思います。m(_ _)m
#1の補足です。 マイクロソフトのコミュニティは、ご確認済みかと思いますが、念のため。 Excel２０１３にて動作が停止と言っても、Cドライブに基本があると思われる７か８で、同種の問題が起こっています。 それを解決することから始めてみたら良いのかもしれません。 ＜７の場合＞ http://answers.microsoft.com/ja-jp/office/forum/ … http://answers.microsoft.com/ja-jp/office/forum/ … https://support.microsoft.com/ja-jp/kb/2848815 ＜解決例＞ オフィスの再インストールで解決。 http://answers.microsoft.com/ja-jp/office/forum/ … 尚、新機種で１０proを新たにインストールしたPCは、実に快適で、上記の症状は起きません。因みにｈｐです。 NECでも問題なしでした。
質問文だけを読むと《AAセルの9～1008に商品JANコードが入力されています》《AFセルの9～1008に入荷日が入力されています》は関係がないようです。 要望 『シート1(在庫表)のY列9～1008行の1000行』の【データの重複を削除した上で、そのデータを昇順に並べ替えた結果を、シート２の(D列)の(3行目から下に)表示するだけ 方法 一番簡単な方法は、excelのデータツールの｢重複の削除｣と並べ替えの｢AZ↓｣を使用する方法だと思います。 1)単純に、(シート1のY列9～1008行の1000行)をコピーし、シート2のD3セルを選択して、貼り付けます。 2)そのまま、｢データツール｣の｢重複の削除ボタン｣をクリックし（いくつかのダイアログをOKします）、続いて｢並べ替えとフィルタ｣の｢AZ↓ボタン｣をクリックします。 3)12月以外のデータを削除します。 関数、配列の処理《例=IFERROR(MIN(IF(MONTH(Sheet1!Y$9:Y$1008)=12,Sheet1!Y$9:Y$1008)),"")》をするのは、数式を配置するセルの位置によって異なる結果を生んだり、自分が勝手に期待しているのと異なる結果が出たときに、かなり知識がないと原因を絞ることが出来ません。　初心者向きではないと思います。　 初心者は、わかり易い処理を段階を経て希望する結果をえるようにした方がイイと思います。 excelのブックに関数の構造を埋め込めば、《一種の自動変換器になって、シート1のデータを置き換えれば、シート２に即時に反映した結果が出ている》となりますが、仕組みを自分で理解できていないと、困ってしまうことも多くなります。
こんばんは。 最初に、日本語の問題のような気がしてきます。 >①C2の最終列を把握する >②C2の最終行の下のセルにaverageを計算する C2の最終列というのは、右側にデータがあることなんでしょうか。 >③最終列まで繰り返し 数式を繰り返すのでしょうか。ふつう、数式を1つずつ埋め込むことはありません。 '// Sub TestMacro1() Dim c As Variant For Each c In Range("C2", Cells(2, Columns.Count).End(xlToLeft)) 　　With Range(c, Cells(Rows.Count, c.Column).End(xlUp)) 　　　　.Offset(1, 0).Cells(.Count).Formula = "=AVERAGE(" & .Cells.Address(0, 0) & ")" 　　End With Next c End Sub マクロというのは、こうした組み立てのロジック自体が重要で、マクロができる人はが、組み立ての設計図は書けますが、そうでない方は、どこかちゃんと書けていないことが多いです。質問内容には、抜けて書かれていない部分があります。 もし、マトリックス(縦横の四角形)になっているなら、以下のようにすればよいのです。 Sub TestMacro2() Dim r1 As Range, r2 As Range Dim i As Long Set r1 = Range("C2") Set r2 = Cells(Rows.Count, 3).End(xlUp) 　i = Range("C2", Cells(2, Columns.Count).End(xlToLeft)).Columns.Count 　With r2.Offset(1).Resize(, i) 　　 .Formula = "= AVERAGE(" & Range(r1, r2).Address(0, 0) & ")" 　　' .Value = .Value '定数値に変える 　End With End Sub '///
よくわからないところがありますが、回答がないみたいなので・・・ ご質問の文章から、「常に空白の1行が表示された状態にしておきたい」ということかと想像しました。 前提条件として、ご提示の図でグレーの「次期繰越」（？←よく読めない）と書かれた行が、Ｃ列で記入されている最終行で、それ以下の行は何も入力がないと仮定しています。（それで最終行を判定していますので） そして、このＣ列の最終行の一つ上のセルに何か入力されたら一行空白行を追加する処理を行えばよい、と読み取りました。 やっていることは、 　1）上記の位置のセルの値が変わったら 　2）その一行前に行を挿入（書式等がコピーされます）し 　3）入力していた行の内容を挿入行にコピー（式等がコピーされます） 　4）入力していた行（新しい最終行＝元の最終行）の内容を式以外は消去する というものです。 ＞Vlookup関数、収支欄の数式も新しい行に追加できるようにできたらなお嬉しいです。 とありましたのでこのようにしていますが、式の内容がコピー・ペーストで正しく意味の通る形式になっていない場合は、いらぬお世話になってしまいますね。 そのような場合でも、式の作り方を再考していただくか、あるいは行追加後にマクロから式を設定するといった処理を追加することで対応可能だろうと想像します。 ※ 勝手に想定している部分がありますので、ご質問の通りか不明ですが参考にでもなれば。 　　以下を該当のシートのチェンジイベント処理のマクロとして設定します。 　　（インデントは全角空白になっています） Private Sub Worksheet_Change(ByVal Target As Range) 　Dim rng As Range 　Dim rw As Long, r As Long 　 　Set rng = Intersect(Target, Columns(3)) 　If Not rng Is Nothing Then 　　If rng.Count = 1 Then 　　　Set rng = rng.Cells(1, 1) 　　　If rng <> "" Then 　　　　rw = Cells(Rows.Count, 3).End(xlUp).Row 　　　　r = rng.Row 　　　　If 4 < r And r = rw - 1 Then 　　　　　Application.EnableEvents = False 　　　　　rng.EntireRow.Insert (xlShiftDown) 　　　　　rng.EntireRow.Copy Destination:=rng.Offset(-1, 1).EntireRow 　　　　　rng.EntireRow.SpecialCells(xlCellTypeConstants).ClearContents 　　　　　Application.EnableEvents = True 　　　　End If 　　　End If 　　End If 　End If End Sub ※ とりあえず、変更したセルがＣ列で一か所の場合のみ動作するようにしてあります。 　（コピペなどでＣ列の複数セルが変わった場合は動作しません）
＞指示通りにしましたが何も変化がありません あれま～、どうしてでしょうかね。 一応、コードを説明しておきますね。 １、シート名のタブを右クリック、コードの表示をクリック それぞれのシートにシートモジュールがあるので、そこに記述します。 標準モジュールではありません。 Private Sub Worksheet_Change(ByVal Target As Range) ↑このシートでセルの値に変更があったら実行するイベント If Target.Column = 1 Then ↑もし、変更があったセルの列が Ａ列だったら If Target.Value = 1 Then ↑もし、変更があったせるの値が　１　だったら Range("C1:C100").Value = "" Target.Offset(0, 2).Value = "LAST" ↑Ｃ列を空白にして、変更があったセルに二つ右を　ＬＡＳＴ と云う意味のコードです。
報告書様式が下図の場合の説明です >後で行を並び替えたり特定値を抽出 出来るように 1.【列Ａ】整理番号を入力順に付ける。・・・(並替え対策) 2.【列Ｂ】入力項目に実際のデータを入力・・・(抽出対策) 3.【列Ｃ】表示項目を設定・・・(直上と同じ値であれば自動的に「〃」対策) 　　　　　セルC2　に式　=IF(B2=B1,"〃",B2)を入力して 　　　　　必要なだけ下まで、オートフィルコピーする。 　　　　<注> 見かけ上完成ですが、並べ替えると化けることもあるので4.へ進む。 4.【列Ｃ】のデータ(図の場合は　c2:c10)をコピーして 　　　　　C2に形式を選択して貼り付ける、 　　　　　値　を選択してクリックする。・・・(並び替た場合の整合性対策) ここまでで一応完成です。 報告書として印刷するには 【列Ｂ】など不要な列を非表示に設定する。 以上で如何ですか。 追記 後から【列Ｂ】のデータ修正が予想されるなら 上記　4.では 　　　【列Ｃ】のデータ(図の場合は　c2:c10)をコピーしたら 　　　　この列はのこしたまま、新たに【列Ｄ】を追加して 　　　　D2に形式を選択して貼り付ける、 　　　　値　を選択してクリックする。・・・(並び替た場合の整合性対策) 　　となります。
以下でどうなりますか 項目「サイズ」が　B1 にあるものとして CurrentRegion　で表データが入手できるものとします 「サイズ」列は、すべて埋まっているものとし、 「S」「M」以外が存在していても良いです アクティブシートを処理対象に、結果は新規シートに出力します 出力後の表をさらに処理すると、ほぼ前の表が出来上がります ※ ほぼ･･･ 色・袖丈部分は並べ替えしているので順が入れ替わるだけですが なお、表は変数（配列）上で作成しているので、 データ量によってはエラーになるかも Public Sub Samp1() 　　Dim dic As Object, dicE As Object 　　Dim rng As Range 　　Dim vA As Variant, vC As Variant 　　Dim vK1 As Variant, vK2 As Variant, v As Variant 　　Dim i As Long, j As Long, k As Long 　　Const CSZ As String = "サイズ" 　　Const CHIN As String = "品番" 　　Set dic = CreateObject("Scripting.Dictionary") 　　Set dicE = CreateObject("Scripting.Dictionary") 　　vA = Range("B1").CurrentRegion.Value 　　For j = 3 To UBound(vA, 2) 　　　　vA(1, j) = Replace(vA(1, j), CHIN, "") 　　Next 　　For i = 2 To UBound(vA) 　　　　If (vA(i, 1) <> "") Then vC = vA(i, 1) 　　　　dicE(vC) = Empty 　　　　For j = 3 To UBound(vA, 2) 　　　　　　If (vA(i, j) <> "") Then 　　　　　　　　If (Not dic.Exists(vA(1, j))) Then 　　　　　　　　　　dic.Add vA(1, j) _ 　　　　　　　　　　　　　　, CreateObject("Scripting.Dictionary") 　　　　　　　　End If 　　　　　　　　If (Not dic(vA(1, j)).Exists(vA(i, 2))) Then 　　　　　　　　　　dic(vA(1, j)).Add vA(i, 2) _ 　　　　　　　　　　　　　　, CreateObject("Scripting.Dictionary") 　　　　　　　　End If 　　　　　　　　dic(vA(1, j))(vA(i, 2))(vC) = vA(i, j) 　　　　　　End If 　　　　Next 　　Next 　　i = 0 　　For Each vK1 In dic.Keys 　　　　i = i + dic(vK1).Count 　　Next 　　ReDim vA(1 To i + 1, 1 To dicE.Count + 2) 　　vA(1, 2) = CSZ 　　vC = mySort(dicE.Keys) 　　For i = 0 To UBound(vC) 　　　　j = i + 3 　　　　vA(1, j) = vC(i) & CHIN 　　　　dicE(vC(i)) = j 　　Next 　　i = 2 　　For Each vK1 In mySort(dic.Keys) 　　　　vA(i, 1) = vK1 　　　　For Each vK2 In dic(vK1).Keys 　　　　　　vA(i, 2) = vK2 　　　　　　For Each v In dic(vK1)(vK2).Keys 　　　　　　　　vA(i, dicE(v)) = dic(vK1)(vK2)(v) 　　　　　　Next 　　　　　　i = i + 1 　　　　Next 　　Next 　　Application.ScreenUpdating = False 　　Worksheets.Add After:=ActiveSheet 　　With Range("A1").Resize(UBound(vA), UBound(vA, 2)) 　　　　.Value = vA 　　　　.Rows(1).HorizontalAlignment = xlCenter 　　　　.Columns(1).HorizontalAlignment = xlCenter 　　　　With Range(.Cells(2, 1), .Cells(.Rows.Count, 1)) 　　　　　　On Error Resume Next 　　　　　　For Each rng In .SpecialCells(xlCellTypeBlanks).Areas 　　　　　　　　With rng 　　　　　　　　　　.Offset(-1).Resize(.Count + 1).Merge 　　　　　　　　End With 　　　　　　Next 　　　　End With 　　　　.Borders.LineStyle = xlContinuous '　　　　.EntireColumn.AutoFit 　　End With 　　Application.ScreenUpdating = True 　　Set dic = Nothing 　　Set dicE = Nothing End Sub Private Function mySort(ByVal vA As Variant) As Variant 　　Dim v As Variant 　　Dim i As Long, j As Long 　　For i = LBound(vA) To UBound(vA) - 1 　　　　For j = i + 1 To UBound(vA) 　　　　　　If (vA(i) > vA(j)) Then 　　　　　　　　v = vA(i) 　　　　　　　　vA(i) = vA(j) 　　　　　　　　vA(j) = v 　　　　　　End If 　　　　Next 　　Next 　　mySort = vA End Function
こんにちは！ 行・列合わせだけの問題だと思います。 表示したいSheetのセルに =INDIRECT("Sheet"&MOD(COLUMN(B1),2)+1&"!"&ADDRESS(ROW(A1),INT(COLUMN(B1)/2))) という数式を入れ、列・行方向にフィル＆コピーではどうでしょうか？m(_ _)m
こんにちは！ 安直な方法としては Excelのオプション　→　詳細設定　→　次のシートで作業するときの表示設定　→　「ゼロ値のセルにゼロを表示する」のチェックを外す。 ※　この場合そのSheetすべてが対象となりますので、 ０を表示したいセルも表示されなくなります。 セルの書式設定でやる場合は 範囲指定　→　ユーザー定義の種類の欄に [=0]"";[<10]#.0;0;@ または [=0] ;[<10]#.0;0;@ （=0]　と　セミコロン(;)の間にスペースを入れています） としてみてはどうでしょうか？m(_ _)m
http://miyahorinn.fc2web.com/faq/faq002.html#1 で、できそうな。
こんばんは！ 一例です。 Book1の表示したいSheetのA5セルに =INDIRECT("[Book2.xlsx]Sheet"&COLUMN(A1)&"!A1") という数式を入れフィルハンドルで右へコピーしてみてください。 ※　Sheet名には手を付けてなくて Sheet1・Sheet2・Sheet3・・・というSheet名になっているという前提です。 ※　Excelのバージョンは 2007以降だとしています。m(_ _)m
No.2です。 URLがうまく開けないようです。 要するに、Outlookに添付されたExcelファイルなど読み取り専用で開かれていると、質問のような現象が生じます。 Outlookの場合はそういう仕様なので、どうしようもありません。
当方XL2003なので、細かい説明ができていないと思われます。 [Windws]+[R]ファイル名を指定して実行 excel.exe /s と入力してセーフモードで起動したEXCELでやってみても同じでしょうか？ また、バージョンも提示してください。
製造コードをリスト式にしてvlookupでちゅうしゅつしました。b9のセルの式を表示させていますので参考にしてください。 これで、別シートにデータを入れてvlookupで抽出すればうまく言うと思います。
No.1です。 投稿後気づきました。 タイトルに「VBA・・・」とありますので、VBAの方をご希望だったのですね。 どうも失礼しました。 Sub Sample1() Dim i As Long, c As Range, myVal As Variant For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row If Cells(i, "B") <= 100 Then myVal = WorksheetFunction.Max(myVal, Cells(i, "B")) End If Next i Set c = Range("B:B").Find(what:=myVal, LookIn:=xlValues, lookat:=xlWhole) Range("D1") = c.Offset(, -1) End Sub 今回もエラー処理はしていません。 こんな感じではどうでしょうか？m(_ _)m
No.2です。 データが、日付と記述は異なるセルに入力されていて、同じ日付は必ず2行、ということでしたら、以下でできます。 データがA列、記述がB列として、回答します。 C１に　=TEXT(A1,"yyyy/mm/dd")&-1 C２に　=TEXT(A2,"yyyy/mm/dd")&-2 を入力。 C1～C2を選択して、マウスポインタをセル右下角にあわせて、ポインタが十字になったらダブルクリックしてコピペします。 必要なら、コピー⇒値のみ貼りつけ　で置き換えます。
参考にされた記事をよく読んでいますか？ http://www.moug.net/tech/exvba/0150095.html 引用 　　このサンプルを実行するには、あらかじめ 　　「Microsoft Shell Controls And Automation」 　　に参照設定しておきます 上記で書かれているように、メニューバーの[ツール]から[参照設定]にて チェックを入れていないと、コンパイルエラーになります。 http://officetanaka.net/excel/vba/tips/tips100.htm [ Microsoft Shell Controls And Automation ]にチェックを入れ[ OK ] をして、マクロを実行すれば指定のダイアログが開くようになります。 [システムのプロパティ]ダイアログを開くサンプルが記載されています。 これを試してから、別のことができないかを質問するようにしてね。
>9.は、入力値の種類：リスト、元の値：社名一覧でよろしかったでしょうか？ 入力値の種類: リスト 元の値: =社名一覧 となり、=(イコール)が入ります。端折ってしまってすみません あと、セルの入力・編集したセルの行のリストが反映されるので、 あらかじめA列にカタカナを入れておくのは、2度手間になります。
こんばんは。 直接の回答ではありませんが、Excel上で使えば、PCのスペックが上がっても、思ったようには速度は上がらないはずです。 もし、ソルバーを本格的に使いたいのでしたら、その製作会社から、ソルバーを購入することも視野にいれたらどうでしょうか。 以前、ここのカテゴリだったか、ソルバーですることをVBAマクロで組んだ方がいましたが、断然マクロの方が速かった覚えがいります。 今でこそ、ソルバー(本体はCで作られています－Solver.dll)は、VBAマクロで動いていますが、以前は、Ver.4 マクロで中身のバージョンアップは長い間していなかったのです。 http://www.solver.com/ http://www.solver.com/#tab2　Optimization and Excel Solver なお、今は値段が出ていないようですが、高いものになると十数万円していたような記憶があります。明らかに企業向けで、今は、ライセンス契約のようになるのでしょうか、それで、プライベートユースの人たちは、OpenSlover を使うようになりました。 http://www.opensolver.org/ こちらは、まだダウンロードして、Excelのアドインにしただけです。
ファイルのサイズが、OneDrive のサイズ制限10 GB を超えていないこと。 最新の Windows 更新プログラムがインストールされていること。 OneDrive が最新バージョンであること。 同期しているか確認。 OneDrive アカウントが Windows に関連付けられているか確認 OneDrive の設定：エクスプローラーを開き、OneDrive フォルダーをクリックし、「OneDrive の設定を完了」ウィザードで、同期するファイルとフォルダーを選ぶ。
セルの名前を定義すると、セル参照を使用する数式の意味が分かりやすくなるというメリットがあります。 セル参照だけでなく、頻出する数値や文字列も、特定セルに記入して名前で参照するようにしておくと便利です。 （ドキュメント性が高まり、後々のメンテナンスが容易になる） ただし、セルの意味や目的、値の属性などを明確に表していない名前は逆効果になる恐れがあります。 名前をたくさん付けるときは、無秩序に（思いつくままに）付けると訳が分からなくなるので、初めにネーミングルールを決めておくとよいでしょう。他の人が見て理解できるか、1年後に自分が見て分かるか、などがポイントです。 要らなくなった名前は放置せず削除すること、後々名前が中身にふさわしくなくなった場合は適切に変更すること、など、きちんとメンテナンスすることも重要です。 あとで名前を変えたくなった場合、参照側の数式は「置換」で一括変換できますが、手順を間違えると面倒なことになります。 例：「名前A」を「名前Ｂ」に変更、「名前Ｂ」を「名前Ａ」に変更したいとき。 →①「名前Ａ」を「名前Ｘ」に変更、②「名前Ｂ」を「名前Ａ」に変更、③「名前Ｘ」を「名前Ｂ」に変更。
こんにちは！ No.1さんが回答されている通り COUNTIF関数は一つの条件しか検索できませんので、 お使いのバージョンがExcel2007以降であれば COUNTIFS関数になります。 ↓の画像でSheet2のB5セルに =COUNTIFS(Sheet1!B:B,">="&D$1,Sheet1!B:B,"<="&E$1,Sheet1!C:C,A6) という数式を入れフィルハンドルで下へコピーしています。 ※　Excel2003までの場合は =SUMPRODUCT((Sheet1!B$1:B$1000>=$D$1)*(Sheet1!B$1:B$1000<=E$1)*(Sheet1!C$1:C$1000=A6)) といった数式で対応するようになります。m(_ _)m
エクセルでは、表示が時刻形式の場合でもシリアル値と呼ばれる数値としてもっています。これは分数(無限小数になる場合あり)でかつ2進⇔10進の変換を行っているため、演算を行うと小数位の小さい部分で誤差が発生します。 そのことが思った通りの結果がでない原因です。 解決策は以下です。 C10に下式を入力します。 =TIMEVALUE(TEXT(B10-A10, "h:mm")) 同様の計算をしているC列にもコピペします。
No.1（No.3）の回答者です。 個人用マクロブック[ PERSONAL.XLSB ]がないのですね。 一番簡単なのは、[マクロの記録]にて[保存先]を[個人用マクロブック]に すれば、新規に作成されます。 http://www.excel-vba.net/excel-macro-005.html 作成後は、ここの標準モジュールに記録すれば利用できます。 No.1のマクロをすべて同じモジュールに記録すれば利用できます。 Excelが起動したときに自動実行するなら、以下のAuto_Openマクロを追加 して、Excelを再起動してください。 （終了時に保存の確認がされますので、保存をしておいてください） Sub Auto_open() 　Call AddMenu End Sub Call AddMenuで、同じモジュールにあるマクロ名を呼び出しますから、 右クリックに起動時から表示されます。
引続き、小手先でやってみましょう。 (1)．「レベル」「担当者」項目が順不同の場合やマスターシートを変更したくない場合は、シートをコピーします。 (2)．5行目以降をすべて選択し、メニューバー[データ][並べ替え]で「並べ替え」ダイアログを表示したら、最初のキーに「レベル：昇順」を選び、2番目のキーは「担当者：昇順」を選んで、[OK]します。 (3)．E5セルに、=IF(B5=B6,0,1) と入力して、E10までオートフィル（下方向へコピー）します。 (4)．F5セルに、=IF(OR(C5<>C6,E5=1),1,0) と入力して、F10までオートフィル（下方向へコピー）します。 (5)．G5セルに、=IF(E4=1,F5,G4+F5) と入力して、G10までオートフィル（下方向へコピー）します。 (6)．G5セルを選択して、メニューバー[書式][条件付き書式]を選んだら、「条件付き書式」ダイアログに「数式が」「=$E5=1」と入力、[書式]ボタンを押して、[フォント]タブの[太字][白]を選択、[パターン]タブの[黒]を選択して、[OK]します。 (7)．そのまま、右クリックでG10までオートフィル（下方向へコピー）して、[書式のコピー]を選択します。 (8)．レベルごとに担当者の頭数がわかります。
詳しくないのと、状況がよくわからないのと、両方なので、以下のコメントは【見当違い】かもしれません。 ➀(現状ではない)エクセルは起動中で、何かの外部データの連続自動取り込みに基づき、O42:O62が書き換わるのではない。 ②(現状は)エクセルは起動中で、B42:B62の範囲で、どこかのセルに【機番１Ａ】とか【機番４C】とかの文字列を入力すると、入力でWorksheet_Changeでセルの値が変換したことで、その文字列を読み取り、該当する条件に従って外部データを取り込み、それを同行のO列のセルに取り込む仕様に作っている。 ③(現状は)Worksheet_Changeの際に、For-NextでAN42～AN62行をすべてチェックし、そのチェック結果で、１となる行のすべてに関して、各２回読み上げをさせている。 ④(現状は)Worksheet_Changeでマクロを実行中にイベント発生を無効にしている。 コメント a)　B42:B62の範囲で、どこかのセルに【機番１Ａ】とか【機番４C】とかの文字列を入力にしたときに、その入力の行われた行のAN列だけを調べて、セルの値が１ならば、（その行のB列に入力された文字列)と（温度上昇）を読み上げるようにしてはいかがでしょうか。 b)　B42:B62の範囲で、どこかのセルに【機番１Ａ】とか【機番４C】とかの文字列を入力にしてから、温度を取り込みC列に表示、AN列に0/1を表示させるまでの処理がどうなっているのか不明ですが、Worksheet_Changeでマクロを実行中にイベント発生を無効にするメリットがないような気がします。 c)　次のようなコードでも、動いたりしませんか。 Private Sub Worksheet_Change(ByVal Target As Range) If Cells("AN" And Target.Row) = 1 Then Application.Speech.Speak Range("B" & Target.Row).Value & "ondo High High" Application.Speech.Speak Range("B" & Target.Row).Value & "ondo High High" End If End Sub
ほとんどMOUGのままですが Sub Sample2() 　Dim sFile As String 　Dim sWB As Workbook 　Dim dWS As Worksheet ' 変更 　Dim dSheetCount As Long 　Dim i As Long 　Dim n As Long '追加 　Const SOURCE_DIR As String = "D:\Data\Source\" 　Const DEST_FILE As String = "D:\Data\AllReports.xls" 　 　Application.ScreenUpdating = False 　 　'指定したフォルダ内にあるブックのファイル名を取得 　sFile = Dir(SOURCE_DIR & "*.xls") 　 　'フォルダ内にブックがなければ終了 　If sFile = "" Then Exit Sub 　 　Set dWS = ActiveSheet '追加 　n = 1 '追加 　Do 　 　'コピー元のブックを開く 　 　Set sWB = Workbooks.Open(Filename:=SOURCE_DIR & sFile) 　 　 　 　 　'変更 　 　dWS.Columns(2 + n) = sWB.Worksheets("報告書").Columns(1).Value 　 　n = n + 1 　 　 　 　 　 　 　 　'コピー元ファイルを閉じる 　 　sWB.Close 　 　 　 　'次のブックのファイル名を取得 　 　sFile = Dir() 　Loop While sFile <> "" 　 　Application.ScreenUpdating = False End SubreenUpdating = False End Sub
EXCELの前に戻ってきたので、再度 D2セルに=MAX(B:B) D3セルに =IF(OR(D2="",MIN(B:B)=D2),"",LARGE(B:B,COUNTIF(B:B,">="&D2)+1)) 下へオートフィル
こんばんは。初心者ながらコメントいたします。 サンプルファイルを作成してみました。（サンプル.xlsx ） http://firestorage.jp/download/4264dec8023ae1d55 … Sheet1で、商品名と在庫数を入力し、条件1～4（色名にしています） のどれに当てはまるかを判別する欄を作成しました。 Sheet2で、色名に対応する条件付き書式を設定しました。
もしも、次のようならば ➀　シート２に関しては、問題無く表示がされるのです。　⇒　期待通りの機能を実現 ②　シート３に関しましては、表示がされず、空白になってしまいます。　⇒　期待外の状況 ❸　シート２の数式をどの様に変更すれば宜しいのでしょうか？ △　｢シート２に入力されている数式が空白の場合、空白になっておらず、シート３に入力されている数式が、エラー認識しており、空白になってしまっているのではないかと思っております｣ △の意味がよくわかりません。 シート３には、シート２を参照する数式などないようです。　 そうであれば、シート２の内容をどう変更しようが、シート３が期待の動作をする可能性はないと想います。 シート３の｢　=IFERROR(INDEX(………),””）｣で｢""空白｣が表示されるなら、左記のINDEX(………)がエラーになっているからでしょう。 INDEX(Arg1,Arg2,0)のArg2になっている｢MATCH(SMALL(Arg３，Arg4),INDEX(………),)｣がエラーになっている可能性があると想像します。 たぶん、INDEX(………)には検査値SMALL(Arg３，Arg4)がなかったので#N/AエラーがMATCHで起きたのでしょう。 Arg4が｢ROW(AF1)｣だとROW(AF1)は１ですから、SMALL(Arg３，Arg4)=SMALL(Arg3,1)になります。 【(('2015年1２月 端末在庫表一覧'!$W$9:$W$1020<>"在庫")*(ROW('2015年1２月 端末在庫表一覧'!$W$9:$W$1020)<=1009)+('2015年1２月 端末在庫表一覧'!$W$9:$W$1020&'2015年1２月 端末在庫表一覧'!$AA$9:$AA$1020&'2015年1２月 端末在庫表一覧'!$AB$9:$AB$1020&'2015年1２月 端末在庫表一覧'!$AC$9:$AC$1020&'2015年1２月 端末在庫表一覧'!$AD$9:$AD$1020&'2015年1２月 端末在庫表一覧'!$AE$9:$AE$1020&'2015年1２月 端末在庫表一覧'!$AF$9:$AF$1020&'2015年1２月 端末在庫表一覧'!$AG$9:$AG$1020="0"))*10^5+『('2015年1２月 端末在庫表一覧'!$AF$9:$AF$1020)+ROW('2015年1２月 端末在庫表一覧'!$W$9:$W$1020)/10^5』】の中の最小値を 『('2015年1２月 端末在庫表一覧'!$AF$9:$AF$1020)+ROW('2015年1２月 端末在庫表一覧'!$W$9:$W$1020)/10^5』の中から 検索しても、見つからない（　⇒　MATCHで#N/Aが返る） 何を期待しているのかがわからないですが、シート３は記述された式の通りに動作しているではないでしょか。
保存する際に、 「名前をつけて保存」 「ファイルの種類」を「Webページ（*.htm,*.html）」を選択。 適当な名前をつけて保存。 コテコテのHTMLが出力されるので、サンプルのような綺麗なタグではありませんが・・・。
こんにちは！ ＞それぞれの商品に最低限必要な数量が異なる為・・・ これが結構厄介ですね。 一つ一つ条件付けするより↓の画像のように別列に必要数を表示させておいてはどうでしょうか？ 画像ではM列にしていますが、実際は遠く離れた列にしておいてもかまいません。 その上で、1行目は項目行でデータは2行目以降に入力する！という前提です。 前回同様操作したいSheetのシートモジュールにしてみてください。 Private Sub Worksheet_Change(ByVal Target As Range) If Intersect(Target, Range("E:E,G:G,I:I")) Is Nothing Or Target.Count > 1 Then Exit Sub With Target If .Row > 1 Then If Cells(.Row, "K") < Cells(.Row, "M") Then MsgBox Cells(.Row, "A") & vbCrLf & "が" & Cells(.Row, "M") & "未満になりました", vbExclamation End If End If End With End Sub ※　↓の画像のように「必要在庫数」の列がある場合は わざわざVBAにしなくてもK列に条件付き書式で色付けする方が 判りやすいかもしれませんね。m(_ _)m
ちなみに、持ってきたいデータが数値なら同じような発想でSUMIFでも。 =SUMIF($A$2:$A$7,D2,$B$3:$B$8)
グーグルクロムとエクセル以外に開いているものがあれば、最小化しておく。 タスクバー上で右クリック　⇒　ウィンドウを左右に並べて表示
こんにちは１ 質問文の回答をそのまま投稿すると Range("AQ" & TR).Formula ="=IF(AND(AN42=1,M42=O42,O42=AP42),1,0)" といった感じになると思います。 ワークシート関数の数式がそのまま使えます。 （ただし、数式に文字列が含まれる場合はダブルクォーテーションが必要になります） ＞TRは行番号で42です わざわざ変数を行番号に持ってきているのは、ループさせたい！とお考えなのでしょうか？ あくまで個人的見解ですが、 今回のようの場合はわざわざVBAにせず、Excelの機能でできることはExcelにやらせた方が簡単だと思います。 （単に数式をドラッグ＆コピーするだけのようなので・・・） 一気にある範囲に数式を入れたい！という場合は 仮にAQ42～AQ100セルに数式を入れるとすると Sub Sample1() Range("AQ42:AQ100").Formula = "=IF(AND(AN42=1,M42=O42,O42=AP42),1,0)" End Sub とすればAQ100セルまでフィル＆コピーした数式が入ります。 ただ、ここまでやるのであれば Sub Sample2() With Range("AQ42:AQ100") .Formula = "=IF(AND(AN42=1,M42=O42,O42=AP42),1,0)" .Value = .Value End With End Sub としてやれば、値のみのデータになりますので、 数式をそのまま残すよりファイル容量は少なくなるはずです。 ※　直接の回答になっていないかもしれませんが まずはこの程度で・・・m(_ _)m
そのPCでは、EXCELだけでなく他のプロセスも動いているので全部をEXCELに割り当てる事は無理です。 タスクマネージャを開いてどんなプロセスが動いているのか調べてみるとよく分かります。 Windowsを起動しているだけでもメモリは消費しているのですから。 それにメモリをフルに使ってしまうとHDDへのメモリスワップが起きるためかえって遅くなりますよ。
２つやり方があります。 １．フィルタ機能を使う ＜やり方＞ 1行目を選択 データ　→　フィルタ A1セルの▽をクリック　→　条件でフィルタ　→　『なし』と書いてある部分をクリック　→　『次を含むテキスト』を選択　→　直下の枠内に任意の文字を入力（"a"など）→　OK ２．関数を使う E2セルに以下の式を入力して、E2～F13セルにコピペ =if(iserror(find($A$1,$A2)),"",A2) データの加工等が必要でしたら、コピーして値のみ貼りつけを行う。
こんばんは。 前回回答した者として、一度、文章で整理しなおしたほうが良いかと思われます。 ご質問者が書いたコードは、まるで、英語をまったく知らない人が単語を寄せ集めたり、会話集を継ぎ接ぎしただけのもののようで、分かっている人からは、修正できるレベルではありません。 今のコードは、あえて表現するなら、「無残な」という所でしょう。 ご質問者さんは、まず、自分がしたいことを、もれなく、位置などを含めて、文章で書いてくださるようにお願いします。 今の段階では、私は、あまり積極的にコードを書しても無駄になりそうです。 私としては、内容的にみて、ご質問者さんのコードは、最初から書き直しレベルです。意味を理解していない分だけ、まずい所だらけです。
数式が　　=MAX(($B$1:$B$9<50%)*($B$1:$B$9))=$B1
MODE関数での最頻値は数値を対象としてますが、文面から文字列を対象としているような印象を受けます。 どちらにせよ、ピボットテーブルが活用できないでしょうか？ 作成後降順で並べ替えればよいと思います
よくエラーデータがあるかどうかを判断するのにＳＵＭ関数を使います。 =IF(ISERROR(SUM(ALF$11:ALF$30)),"エラーのデータがあります",今の式) では、いかがでしょうか。
こんばんは！ ＞TRUE,FALSEの判定まではいけたのですが・・・ というコトですのが、画像の配置だと I3セルに =IFERROR(INDEX(B$1:B$7,SMALL(IF(G$1:G$7=TRUE,ROW(G$1:G$7)),ROW(A1))),"") I10セルに =IFERROR(INDEX(B$1:B$7,SMALL(IF((G$1:G$7<>"")*(G$1:G$7=FALSE),ROW(G$1:G$7)),ROW(A1))),"") どちらも配列数式ですので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式を各セルにドラッグ＆コピー　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 そしてI3・I10の各セルのフィルハンドルで 下へコピーしてみてください。m(_ _)m
こんにちは。 ちょっと、流れを読んでいたのですが、コードは、見よう見まねというところでしょう。 ただ、ご質問の内容の流れを、完全にマクロ上で再現するには、UserForm上ではないと、できないはずです。 Workbookを開くまではよいにしても、その先、マクロを一旦離れて、任意のシート指定をする方法は、ありません。シート名や位置が決まっていれば、そのまま可能ですが、そこらが煮詰まっていないというところでしょうか。 なお、 myOldFile = Application.GetOpenFilename("Excelファイル (*.xls;*.xlsm),*.xls;*.xlsm") myName = Mid(myOldFile, InStrRev(myOldFile, "\") + 1) こう繋がるのは、カレントディレクトリにある場合のみですが、わざわざ、このようなことをする必要はありませんね。 >Sub ファイルを開く() >' ファイルを開く Macro >' Ｅｘｃｅｌファイルを開きます >Application.Goto Reference:="ファイルを開く" >End Sub まさか、Ver.4 マクロではないでしょう？ Application.Goto は、セル位置に飛ぶ場合です。 Call マクロ名、または、そのまま、マクロ名を呼び出します。(基本的には、標準モジュールで、Private キーワードがついていないマクロの場合に限ります。) >ボタンの作り方がわかりません。 開発タブの挿入のフォームコントロールの中から、ボタンを選んで、セル上でドラッグすれば、ボタンになりますから、後は、ダイアログが出ていましたから、一旦、閉じてしまって、マクロを書いてから当たらに登録してください。 列の数値を0にするというのは、 数値があれば、それらは全部0にするなら、こうなります。Error トラップも含めてください。 On Error Resume Next ActiveSheet.Columns(1).SpecialCells(xlCellTypeConstants, xlNumbers).Value = 0 On Error GoTo 0 >その中の指定したシートを別シートに保存する よく意味が分かりませんが、同じブックの右に、新しいシートとしてコピーするなら、 ActiveSheet.Copy After:=Worksheets(Worksheets.Count) というところでしょうか。
エラー対策はしていません。 ハイパーリンクを設定したい範囲を選択した状態で動作させます。E列のみでしか施さないのならE列全体を選択した状態で行ってください。 Sub 教goo() 　Dim c As Range 　　Selection.SpecialCells(xlCellTypeConstants, 23).Select 　　　For Each c In Selection 　　　　c.Hyperlinks.Add c, _ 　　　　Address:="http://oshiete.goo.ne.jp/" & c.Value 　　　Next c End Sub
こんばんは！ 今回の質問限定のユーザー定義関数を使ってみてはどうでしょうか？ Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻ります（VBE画面を閉じる） Function Eval(myRng As Range) 'この行から// Dim str As String str = myRng If InStr(str, "×") > 0 Then str = Replace(str, "×", "*") End If If InStr(str, "÷") > 0 Then str = Replace(str, "÷", "/") End If Eval = Evaluate(str) End Function 'この行まで// そしてA3セルに =Eval(B3) としてみてください。 ※　とりあえず加減乗除に対応できると思います。 （結果は実データになります） ※　保存時はマクロ有効ブックとして保存します。m(_ _)m
整数と言うことなので、ROUNDDOWN関数ではなくINT関数を使って小数点以下を切り捨てる。 「小数点以下」を切り捨てる数式 ＝INT(100/6) 「小数点以下」をまとめた数式 ＝MOD(100/6) A1セルに端数をまとめるとして、B１セルに次の数式を入力し、それを右方向へコピー ＝IF(100-SUM($A1:A1)<0,"",INT(100/6)) A1セルには ＝INT(100/6)+MOD(100,6) ※ただし動作未検証。
続けてお邪魔します。 No.2の列変更等を訂正していました。 前回の標準モジュールはすべて消去し、↓のコードにしてみてください。 Sub Sample1() 'この行から// Dim lastRow As Long, c As Range Dim myRng As Range, wS As Worksheet Set wS = Worksheets("Sheet2") Application.ScreenUpdating = False With Worksheets("Sheet1") lastRow = .Cells(Rows.Count, "E").End(xlUp).Row If lastRow > 1 Then .Range("U:U").Insert Range(.Cells(2, "U"), .Cells(lastRow, "U")).Formula = _ "=TEXT(T2,""00000"")&""_""&TEXT(LEFT(E2,4),""0000"")" Set c = .Range("U:U").Find(what:=Format(wS.Range("A1"), "00000") & "_" & _ Format(wS.Range("A2"), "0000"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then Set myRng = .Cells(c.Row, "O") .Range("U:U").Delete Application.ScreenUpdating = True .Activate myRng.Select Exit Sub Else MsgBox "該当データなし" .Range("U:U").Delete End If End If End With Application.ScreenUpdating = True End Sub 'この行まで// ※　Sheet2のシートモジュールはそのままで大丈夫です。 尚、細かい検証はしていませんので、 不具合があればごめんなさいさいね。m(_ _)m
エクセル2010では、ないのですが。 B2セルの「#DIV/0!」は、０除算のエラーですが、実際にエラーを発生させていますか？ 文字列として「#DIV/0!」を入力していませんか？ B2セルを「=10/0」にすると、「#DIV/0!」が表示されます。 この状態でテストされてE2が０になっているのでしょうか？ 少なくとも、私の環境では０除算のエラーが発生している状況ではE2でもエラーが発生します。
RIGHT関数で行けますよ 文字列として取り出す場合 =RIGHT(取り出したいセル,1) 数値として取り出す場合 =VALUE(RIGHT(取り出したいセル,1))
こんばんは！ 「整数」を選択するのではなく、「ユーザー設定」を選択し 数式欄に =OR(N40=1,N40=2,N40=3,N40=41,N40=42,N40=43) としてみてはどうでしょうか？m(_ _)m
>>=LOOKUP("ー-",MID(A2,FIND($F$2:$F$5,A2),LEN($F$2:$F$5))) >もしよろしければ意味を教えて頂けると嬉しいです！ 1. FIND($F$2:$F$5,A2) は皆さんと同じ、4行1列の配列を返す数式。=FIND(検索文字列,対象) 　 2. LEN($F$2:$F$5) も4行1列の配列。=LEN(文字列) 3. MID(A2,FIND($F$2:$F$5,A2),LEN($F$2:$F$5)) も中身が配列になっているので4行1列の配列。=MID(文字列,開始位置,文字数) 4. =LOOKUP("ー-",MID(A2,FIND($F$2:$F$5,A2),LEN($F$2:$F$5))) 　VLOOKUP関数の検索の型をTRUE とか、MATCH関数の照合の型を1として考えてください。 　で仮に=MATCH(8^8,B:B,1) としたとき、B列に入力してある数値の一番下、その行番号を返します。 　ただし、数値は8の８乗(16777216)未満であること。 　を踏まえて、 　今度はその文字列版。"ー-"は単純に文字として大きいと判断されます。 　"ー"(長音)だけでも良かったのですが、遊び心ですm(_ _)m 　だから、投稿した後、もうちょっと顔文字っぽく 　=LOOKUP("ーー",MID(A2,FIND($F$2:$F$5,A2),LEN($F$2:$F$5))) 　とすればよかったと、若干後悔してました。(ってそんなことで後悔するなって) 5. エラー処理は当方、EXCEL2003なのでIFERROR関数を使えないから 　=IF(COUNT(FIND($F$2:$F$5,A2)),LOOKUP("ーー",MID(A2,FIND($F$2:$F$5,A2),LEN($F$2:$F$5))),"なし") 　Find関数で見つからない場合エラー値しか返さないのでCOUNTの結果は0。つまり、Falseと判断される 　逆の場合、1(以上)でTrueと判断される 注1. 数字だけを検索することがないと判断してます 注2. 検索するセル範囲(F列)は すべて文字が埋まっているものとしています。
エクスプローラでPersonal.xlsbを右クリックし プロパティの属性を読み取り専用にすれば 『PERSONAL.xlsbは編集のためロックされています』は出てこなくなりました。 （Excel2010では） Personal.xlsbの変更の際には属性を戻してください。 ご参考まで。
ごめんなさい。説明不足でした。 条件付き書式を以下のようにしてください。 【A2セル（りんご）】 =AND(INDIRECT("Sheet1!B2")>0,INDIRECT("Sheet1!C2")>0) =INDIRECT("Sheet1!B2")>0 =INDIRECT("Sheet1!C2")>0 【A3セル（いちご）】 =AND(INDIRECT("Sheet1!B3")>0,INDIRECT("Sheet1!C3")>0) =INDIRECT("Sheet1!B3")>0 =INDIRECT("Sheet1!C3")>0 【A4セル（バナナ）】 =AND(INDIRECT("Sheet1!B4")>0,INDIRECT("Sheet1!C4")>0) =INDIRECT("Sheet1!B4")>0 =INDIRECT("Sheet1!C4")>0 【A5セル（みかん）】 =AND(INDIRECT("Sheet1!B5")>0,INDIRECT("Sheet1!C5")>0) =INDIRECT("Sheet1!B5")>0 =INDIRECT("Sheet1!C5")>0
> エクセルで三つ折りのリーフレットを作っております。 > 両面を印刷します。 > しかし3辺が均等にならないので、三つ折りが出来ません。 > 適したテンプレート等をお教えくださいませ。 Excelの場合は、寸法が画面と同じように印刷できませんので、Wordをお使いになることをお勧めします。） Wordの「新規作成」から、「サンプルテンプレート」にある「カタログ」、 または、「Office. com テンプレートの検索」から「3面パンフレット」のキーワードで検索して、テンプレートをダウンロードしてください。 （Word 2010での例ですが、他のバージョンでも可能と思います。） 「ワードで三つ折りパンフレットを作るには」 http://ameblo.jp/sumitak1329/entry-11474527016.h …
縮小されない…。 分からない。 自分の環境では普通に縮小される。（MS Pゴシック（本文）使用） Excelは画面の拡大/縮小によって表示される文字の大きさが極端に変わるので、そのせいではないだろうか。 画面の拡大を50％/100％/150％にしたとき、それぞれどのように見えるのかを確認してみよう。 （右下にあるスライドで簡単に変更できる） あるいはフォントの問題かもしれない。 Windowsの表示フォントを125％などと拡大していると、セルからはみ出すかもしれない。（未検証） 15インチクラス以下のノートパソコンでは、初期設定で125％が設定されていたような気がする。 100％では文字が小さくなりすぎ見づらいのだ。 コントロールパネルから「ディスプレイ」の設定で変更できる。 ・・・ ExcelのWYSIWYGは飾り程度のものなので、過大な期待をしてはいけない事も併せてアドバイスしておきます。
誤記訂正 誤　=COUNTIFS(点数の入力されている範囲,">=87"点数の入力されている範囲,"<=90") 正　=COUNTIFS(点数の入力されている範囲,">=87",点数の入力されている範囲,"<=90") カンマが一つ抜けた（汗
>数字を並び替えるために手打ちをする必要があるのですが なんで並び替えに手打ちなのか、疑問が残ります。 セルの端っこを持って、[Shift]押しならがドラッグ&ドロップ 切り取り&切り取ったセルの挿入のマウス操作になります。 作業列案 1. C2セルから下へ1から100までの連番 2. D1セルに 0 3. D2セルに 　=SUM(ISNA(MATCH(C2,$A$1:$A$100,0)),D1) 　フィルハンドルダブルクリック 4. E2セルに 　=IF($D$101<C2,"",LOOKUP(C2-1,$D$1:$D$100,$C$2:$C$101)) 　フィルハンドルダブルクリック 計算速度重視の案なので参考まで
＃２です 雛形シートの内訳名とコードのものを抜き出すと考えれば、 転記できない金額があっても構わない･･･になりますね ということで、以下でどうなりますか Public Sub Samp2() 　　Dim dic As Object, dicE As Object 　　Dim vA As Variant, v As Variant 　　Dim vB As Variant, vHI As Variant, vK As Variant 　　Dim sS As String 　　Dim i As Long 　　Const CSEP As String = vbTab 　　Const CSRCNM As String = "Sheet1" ' 原本シート名 　　Const CDESTNM As String = "Sheet2" ' 雛形シート名 　　Set dic = CreateObject("Scripting.Dictionary") 　　Set dicE = CreateObject("Scripting.Dictionary") 　　With Worksheets(CSRCNM) 　　　　With .Range("B4", .Cells(Rows.Count, "B").End(xlUp)) 　　　　　　With .Offset(, -1) 　　　　　　　　vB = .Columns("B").Value 　　　　　　　　vHI = .Columns("H:I").Value 　　　　　　　　vK = .Columns("K").Value 　　　　　　End With 　　　　End With 　　End With 　　With Worksheets(CDESTNM).Range("B3").CurrentRegion 　　　　vA = .Rows(2).Resize(2).Value 　　　　For i = 4 To .Columns.Count 　　　　　　sS = vA(1, i) & CSEP & vA(2, i) 　　　　　　If (sS <> CSEP) Then dicE(sS) = i 　　　　Next 　　　　For i = 1 To UBound(vB) 　　　　　　sS = vHI(i, 1) & CSEP & vHI(i, 2) 　　　　　　If (dicE.Exists(sS)) Then 　　　　　　　　If (Not dic.Exists(vB(i, 1))) Then 　　　　　　　　　　dic.Add vB(i, 1), CreateObject("Scripting.Dictionary") 　　　　　　　　End If 　　　　　　　　dic(vB(i, 1))(sS) = dic(vB(i, 1))(sS) + vK(i, 1) 　　　　　　End If 　　　　Next 　　　　If (dic.Count > 0) Then 　　　　　　ReDim vA(1 To dic.Count, 1 To .Columns.Count) 　　　　　　i = 1 　　　　　　For Each vK In dic.Keys 　　　　　　　　vA(i, 1) = i 　　　　　　　　vA(i, 2) = vK 　　　　　　　　For Each v In dic(vK).Keys 　　　　　　　　　　vA(i, dicE(v)) = dic(vK)(v) 　　　　　　　　Next 　　　　　　　　i = i + 1 　　　　　　Next 　　　　　　Application.ScreenUpdating = False 　　　　　　If (.Rows.Count > 3) Then 　　　　　　　　.Rows(4).Resize(.Rows.Count - 3).Clear 　　　　　　End If 　　　　　　With .Cells(4, 1).Resize(UBound(vA), UBound(vA, 2)) 　　　　　　　　.Value = vA 　　　　　　　　.Borders.LineStyle = xlContinuous 　　　　　　End With 　　　　　　Application.ScreenUpdating = True 　　　　End If 　　End With 　　Set dic = Nothing 　　Set dicE = Nothing End Sub ※ 細かい仕様がわからないので Samp1 / Samp2 とも 同一ID内の内訳名＆コードが同じものは加算してました
通りがかりですが、横から失礼します。 ANo1様の回答でできるはずですが、補足のような事象が起こる原因として推測してみると・・・ Ｃ列のセルの文字の標準書式が赤になっているのではないかと思います。 試しに、Ｃ列の対象セルを選択して、（通常の）文字表示を黒にしてみてください。 （ホーム→書式→セルの書式設定→フォントタブで設定） それでも直らない場合は、ANo1様ご回答の条件付き書式が正しく設定できているかを再確認してみてください。 蛇足ですが、考え方として 　・標準を黒表示。条件付き書式でA列が空欄なら赤表示 　・標準を赤表示。条件付き書式でＡ列が空欄でなければ黒表示 という二通りの設定の方法が考えられますが、どちらも意味合いは同じなので、見た目は同じ動作に見えるはずです。
こんばんは！ B列だけでフィルタを掛けている訳ですね？ 画像では東京・北海道が一つだけのようですが、 フィルタで絞り込んだ後に東京・北海道も複数行データがあるときは最初の行だけにデータを入力すると E列が空白の場合、入力されているデータを表示するようにしてみました。 Sub Sample1() Dim i As Long, k As Long, lastRow As Long With ActiveSheet If .AutoFilterMode Then If .AutoFilter.FilterMode Then lastRow = .Cells(Rows.Count, "A").End(xlUp).Row For i = 2 To lastRow If .Rows(i).Hidden = False And .Cells(i, "E") <> "" Then For k = i + 1 To lastRow If .Rows(k).Hidden = False And .Cells(k, "E") = "" Then .Cells(k, "E") = .Cells(i, "E") End If Next k End If Next i End If End If End With End Sub ※　もっと効率的な方法があるかもしれませんが、 まずはこの程度で・・・m(_ _)m
どうしてもSUM関数を使う必要があるのであれば、 ＝SUM(A3:A10 , A12:A20) と範囲を分ければよい。
E1: =SUMIF(A$1:A$6,D1,B$1:B$6)+SUMIF(A$1:A$6,D1,C$1:C$6)
http://www.excel.studio-kazu.jp/tips/0045/ 上記後参照ください。エラーの表示のようです。 2003についても下方に記されています。
76.726を３日４時４３分にする書式は知らないので 図のような配置で作業域を設けて結果が表示されることは出来ました。 青色のセルには、その上の黄欄の式を入力します。 ピンクの答えには、その下の紫欄の式を入力します。
1行目に対して結合を行います（これも素早くというのなら、クイックアクセスツールバーにボタンを登録するとか、Alt + H 、 M とアクセスキーを押下してその後C か A か Mを押すとかになります）。 その後、1行目からn行目までの同列のセルを選択した状態でCtrl+Dを押下すればn行目までセルの内容と書式がコピーされます。 セルの内容がコピーされると困るのなら、1行目の結合したセルを選択してた時に右下に表示されるフィルハンドルを右クリックしながら下方向にn行目までドラッグし、ドラッグを止めたときに表示されるリストの中から「書式のみコピー（フィル）」を選択します。
こんばんは！ 両シートとも商品名は入力済なのですね？ そうであれば簡単です。 ↓の画像で注文書SheetのD2セルに =IF($C2="","",SUMIF(内訳!$C:$C,$C2,内訳!D:D)) という数式を入れ、列・行方向にフィルハンドルでコピーしています。 こんな感じで良いのでしょうか？m(_ _)m
関数だとめんどくさいので、マクロで レイアウトは私の添付図通りとします。 すなわち A１：作業者名、B１：班 A２～9：作業内容 B２～9：班 A13、B13：空セル A14～A24：作業内容の転写先 B14～B24：班を転写し転写先 D1：A班 D２～J8：A班のテーブル内容 以下、１行スペースをあけて、A班と同サイズの表のB班、C班とする 転写先のセル内容に何か変化があると転写イベント発生。 シート上でAlt+F11を押し、Visual Basic Editorに以下の内容を転写 して完成 Private Sub Worksheet_Change(ByVal Target As Range) 'A14:B24に何か変化があれば実行される If Target.Row > 13 And _ Target.Row < 25 And _ Target.Column < 3 Then Dim i, j, k, a, b, c As Integer '表の作業者の初期化 For i = 1 To 3 For j = 1 To 5 Cells(9 * i - 7, j + 5) = "" Next Next 'A14:B24に記載された作業者を表に振り分ける If Cells(11, 1) <> "" Then a = 6 b = 6 c = 6 For k = 14 To 24 Select Case Cells(k, 2) Case "A" Cells(2, a) = Cells(k, 1) a = a + 1 Case "B" Cells(11, b) = Cells(k, 1) b = b + 1 Case "C" Cells(20, c) = Cells(k, 1) c = c + 1 End Select Next End If End If End Sub
No1です。 あらま ＞転記のコードがうまくいきませんでした。 具体的にどうだったのでしょうかね。 >MsgBox Cells(i, 1).Value & Cells(1, j).Value >MsgBox Cells(i, j).Value >の部分を修正してみてください。 の部分も含めて、 最終的にどのようなコードにされたのでしょうか。
5.新規エクセルB列から重複を削除し並びかえ(昇順) の部分は含みませんが、とりあえずひな形です。 A列に　ファイル名 B列に　シート名 C列に　B2セル以下の値にしてあります。 Sub ボタン1_Click() Dim myFile As Variant myFile = Application.GetOpenFilename("Excel ファイル (*.xls; *.xlsx),*.xls; *.xlsx") If VarType(myFile) = vbBoolean Then MsgBox "キャンセルされました" Else Workbooks.Open myFile cnt = 2 With ThisWorkbook.ActiveSheet For i = 1 To Worksheets.Count For j = 2 To Range("B2").End(xlDown).Row .Cells(cnt, 1).Value = ActiveWorkbook.Name .Cells(cnt, 2).Value = Sheets(i).Name .Cells(cnt, 3).Value = Sheets(i).Cells(j, 2).Value cnt = cnt + 1 Next j Next i End With End If ActiveWorkbook.Close End Sub
ファイルの属性を操作するなら専用ツールを使った方がラクですよ。 http://www.vector.co.jp/vpack/filearea/win/util/ …
エクセルでは、数値の　１　を1日として計算するシリアル値を使っています。 試しに A1セルに　2015/12/4 と入れて A2セルに　=A1+1　と入れると翌日の日付が表示されます。 では、A1セルを　セルの書式設定　＝＞　表示形式で　数値に変更してみます。 ４２３４２　と訳の分からない数値が出ます。 A2セルも　同様に　数値にすると ４２３４２　です。 エクセルが　数値　１　と　1日で計算している証拠です。 更に、　A3セルに　数値の　１　を入れます。 セルの書式設定　＝＞表示形式で　日付にします。 1900/01/01　と表示されます。 エクセルでは　1900年1月1日　を　数値に１で、1日を　数値の１で計算して 日付を表示していることが分かります。 ちなみに =A1+0.5 と入れて、日付と時刻を表示させると　2015/12/04/ 12:00:00 と12時を計算します。 つまり　1時間であれば　=A1+1/24　で計算されます。 参考にしていただければ幸いです。
No.3です。 No.1さんのお礼欄に ＞A1に数式が入っているんですが・・・ とありますが、 A1セルに表示させたい！というコトでしょうか？ 現在入っている数式が判らないので A1セルに =MIN(現在の数式,43200) （エラー処理はしていません） としてみてください。m(_ _)m
両方のブックを開いておき、コピーして、リンク貼り付け するだけ。 「メッセージを表示しないで、リンクの自動更新を行う」ことも可能だと思います。 また、外部データの取り込みで取り込むのも一案です。 その場合、保存時には削除しておくことも可能です。 さらに、SQLを使って並び替えや抽出も。 ただし、この方法は元のデータはデータベース形式となっていること。
こんばんは！ ↓の画像で説明します。 BSheetのB列は問題ないと思いますので、 C2セルに =IF(VLOOKUP($A2,B!$A:$C,3,0)=C$1,1,"") という数式を入れ、列・行方向にフィルハンドルでコピーしています。m(_ _)m
1.印刷用のボタンを並べるシートを追加します。 2.印刷する各シートについて、以下の作業をマクロとして記録します。 　　印刷する範囲を選択して、印刷設定を施す 　　印刷する操作を「マクロの記録」でマクロを記録する 3.各シートごとに作成したそれぞれのマクロを実行するボタンを最初に作ったシートに並べる 4.各ボタンにマクロを登録する が一連の流れになります。 No.4のURLの手順をそのまま使っています。詳細はURLを確認してください。 >シート毎に範囲名を別に をやりたいのであれば、 https://www.moug.net/tech/exopr/0070059.html の手順を参考にしてください。
ゴリ押しで良ければ。 指定フォルダのファイルから番号を抜き出し、それぞれ比較をして、最終的にMaxNoのファイルを開くマクロです ※ファイルが複数のフォルダにばらけている場合は、更にコードを編集する必要があります ※数カ所、ご自身の環境に合わせて修正が必要な箇所があります ※何の種類のファイルを開きたいのか分からなかったので、とりあえずエクセルファイルとしています Sub sample() Dim KanriNo, MaxNo, myBook myBook = Dir("C:\*.xls") 'Cフォルダに各ファイルが保存されている場合です。環境に合わせてパスや拡張子を変更してください 'それぞれのファイルから番号を抜き出し、最大値をMaxNoに保管します Do Until myBook = "" KanriNo = TrimNo(myBook) If KanriNo >= MaxNo Then MaxNo = KanriNo myBook = Dir() Loop 'MaxNoの桁数を、開くファイルに揃えるために先頭にゼロを補完します '数字の桁数は環境に合わせて、０の数を変更してください 'このサンプルでは３桁の数字に揃えています Select Case Len(MaxNo) Case 2 'MaxNoが２桁だった場合、先頭に０を１つ足して３桁（００＊）の形式にします MaxNo = "0" & MaxNo Case 1 'MaxNoが１桁だった場合、先頭に０を２つ足して３桁（００＊）の形式にします MaxNo = "00" & MaxNo End Select 'ファイルを開きます。日付はDate関数で得られるYYYY/MM/DD形式からReplaceを用いて８桁表示にしています '拡張子がxlsでない場合は、環境に合わせて変更してください Workbooks.Open "c:\" & Replace(Date, "/", "") & "_販売管理_" & MaxNo & ".xls" End Sub 'ファイル名から番号を抜き出すユーザー関数です Function TrimNo(strings) If strings <> "" Then _ TrimNo = CInt(Replace(Mid(strings, InStrRev(strings, "_") + 1, Len(strings) - InStrRev(strings, "_")), ".xls", "")) End Function
No.1です。 質問文に ＞シートの数は操作以外のシートは２つだったり４つだったり数は変動します。 とありましたので、誤解していました。 ご自身でSheetを選択するのではなく、 Sheet見出しの2番目以降にある全てのSheetが対象なのですね？ 前回のコードは消去して↓のコードにしてみてください。 （今回は各SheetのBC列を検索対象列にしています） Sub Sample2() Dim i As Long, j As Long, k As Long, lastRow As Long Dim wS As Worksheet, c As Range, myFlg As Boolean Dim sN As String, buf As String Application.ScreenUpdating = False With Worksheets(1) .Cells.ClearContents For k = 2 To Worksheets.Count Set wS = Worksheets(k) sN = wS.Name lastRow = wS.Cells(Rows.Count, "BC").End(xlUp).Row If lastRow > 1 Then .Cells(Rows.Count, "A").End(xlUp).Offset(2) = sN & "のシート" Range(wS.Cells(1, "BC"), wS.Cells(lastRow, "BC")).Copy .Cells(Rows.Count, "A").End(xlUp).Offset(1) For i = .Cells(Rows.Count, "B").End(xlUp).Offset(2).Row + 2 To .Cells(Rows.Count, "A").End(xlUp).Row myFlg = False buf = "" For j = 2 To Worksheets.Count If Worksheets(j).Name <> sN Then Set c = Worksheets(j).Range("BC:BC").Find(what:=.Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then myFlg = True buf = buf & Worksheets(j).Name & "・" End If End If Next j If myFlg = True Then .Cells(i, "B") = Left(buf, Len(buf) - 1) & "にあり" Else .Cells(i, "B") = sN & "のみ" End If Next i End If Next k .Range("1:2").Delete .Columns.AutoFit .Activate End With Application.ScreenUpdating = True MsgBox "完了" End Sub 今度はどうでしょうか？m(_ _)m
>P,Q,R　列に　値の入ったセルが下行にずっと続いています P,Q,R　列に　関数の入ったセルが下行にずっと続いています ではないですか？ マクロで処理したら値になりますが 関数であれば、ISNAとか　ISERROR関数があります。 一例ですが、現在のP列の式を =IF(ISNA(P列の式),IF(ISNA(Q2),IF(ISNA(R2),P列の式),R2),Q2,P列の式) といった考え方ではダメなのでしょうか。
No.１です。 同じ色で良いのですね？ ①　重複セルすべての場合 ②　２回目以降出現の場合 というコトですが、お手元の表のレイアウトがこちらでは判らないので、A列に氏名が羅列してあるとし、 A列だけに色を付けるとします。 A列すべてを範囲指定　→　条件付き書式　→　新しいルール　→　数式を使用して・・・　→　数式欄に ①　の場合は =COUNTIF(A:A,A1)>1 という数式を ②　の場合は =COUNTIF(A$1:A1,A1)>1 という数式を入れ　 書式　→　塗りつぶし　→　好みの色を選択しOK ※　①と②では微妙に数式が異なります。 こんな感じではどうでしょうか？m(_ _)m
１．隣のセルが空白でない ２．AB21セルが0 ３．AB21セルが-2 条件の追加はこの３つでしょうか。 そして、この条件が一つでも成立したら空白にすると言うことで良いのでしょうか。 B1セルに数式を入力して、A1セルを隣のセルとするならば、 =IF(A1="","",IF(AB21=0,"",IF(AB21=-2,"",　IF(AN21=10,IF(G21<=K21,2,″″),″″)　))) こんな感じになる。 A1セルが空白なら空白を返し、違えば次の条件。 を繰り返せば良い。 条件が多すぎてExcelに怒られたら、条件式を前後に分割すれば良い。 C1=IF(A1="", TRUE ,IF(AB21=0, TRUE ,IF(AB21=-2, TRUE , FALSE ))) 　A1が空白なら「真」を返し、違えば次の条件。 　AB21が0なら「真」を返し、違えば次の条件。 　AB21が-2なら「真」を返し、違えば「偽」を返す。 B1=IF(C1,"",　IF(AN21=10,IF(G21<=K21,2,″″),″″)　))) 　C1が「真」（空白条件成立）なら空白を返し、「偽」ならば次の条件...。 こんなだ。 なお、質問文にある =IF(AN21=10,IF(G21<=K21,2,″″),″″) が正しく動作しているのかは考慮していない。
Sub Macro1() Dim a As String a = Sheets("データ").Range("A1").Value Sheets(a).PrintOut End Sub ページ範囲を限定したい場合は引数Fromに開始ページ、引数Toに終了ページを指定します。 Sheets(a).PrintOut From:=1, To:=3 さらに一度プレビューを表示してから印刷したい場合は引数Previewを追加します。 Sheets(a).PrintOut From:=1, To:=3, Preview:=True プレビューだけなら Sheets(a).PrintOut Preview:=True
>　1日目から曜日を取得すると1900/1/1の曜日を取得して ただ　１だと、1900/1/1になるでしょう。 年月を何らかの方法で指定しないと、１だけでは1900/1/1にみなされると思います。 例えば、C9に[=DATE(2015,12,1)]といれておくと、C9は[１]と表示されますが、実態はC9は2015/12/1＝42339になっています。 C10に[=C9+1]といれると、42340と表示されるかもしれません。 セルの書式を、ユーザ定義で　d　としておくと、C9が｢2015/12/1＝42339｣なら[１]と表示され、C10が｢=C9+1｣なら[２]と表示されます。 F9が｢=TEXT(WEEKDAY(C9,2),"aaa")｣で、C9が｢2015/12/1＝42339｣なら、F9は[月]と表示されます。 C9:E9がセル結合され、F9:H9がセル結合されていても同じです。 C10:E10の結合、F10:H10のセル結合を、下方にドラッグコピーすればそれで目的は達成出来る可能性があります。 日曜日に(F*:H*が[日]の行の場合に)、同行のY*:AB*の結合セルを条件付き書式の数式で灰色に塗りつぶさせることは可能です。 しかし、祝日の指定が同行のどこかで判定できない場合は、Y*:AB*の結合セルを条件付き書式の数式で灰色に塗りつぶさせることは無理です。祝日がどの日なのかを別のサイトや表から判定できるロジックを持ってこないとできません。 http://www.gold-power.net/next.html 祝日の表をどこかに作ってあれば、表を検索して日付が祝日に該当するときに条件付き書式の機能で灰色に塗りつぶすことはできます。 また条件付き書式の指定では、たぶん、太い罫線は表示できません。普通の太さの罫線は使えますが、たぶん、セル結合のところでは不完全にしか表示できません。
こんばんは！ ＞Publicステートメントを使って宣言した変数は、宣言したモジュールはもちろん、すべてのモジュール内の、すべてのプロシージャで使用できます。 といった内容の説明がサイト上でなされていますので、とても便利だとは思います。 ただし、すべてのプロシージャの前で宣言してやる必要があるはずです。 お示しのコードをそのまま使用すると Public upB14 As Boolean Private Sub Workbook_Open() upB14 = False End Sub といった順になるかと思います。 ※　Boolean型の変数の初期値は「FALSE」ですので わざわざ ＞ upB14 = False とする必要なないと思います。 すなわちブックを開いた状態で、すでに「FALSE」になっています。m(_ _)m
こんばんは。 >10分の金額は500円（2人で10分） 金額は、2番目の位置にありますが、この順番が替わるようですと、ワークシート関数では無理ではないかと思います。 #1さんとは別のスタイルで、#2さんの「負がなく小数点や桁区切り含め」をいただき、回答とさせていただきました。以下のように正規表現を使いますと、いろいろな対応が可能になります。 百千万億兆　などか入ったものは、以下の正規表現パターンを替えなくてはなりません。 　"(([△\-+]?[\d,]+[百千万億兆]*)+)円" 'アラビア数字と漢数字混じりの時 '// Sub PickNumbers() Dim c If TypeName(Selection) = "Range" Then 　For Each c In Range("A1", Cells(Rows.Count, "A").End(xlUp)) 　　c.Offset(, 1).Value = WhichNumYen(c)　'右隣のセルに記述　c.Offset(,1)の1が右隣セル1個 B列に出力 　Next c End If End Sub Function WhichNumYen(ByVal rng As Variant) 　Dim Matches 　Dim n As String 　Dim m As Variant 　Dim buf As String 　If TypeName(rng) = "Range" Then 　　n = rng.Value 　Else 　　n = rng 　End If 　n = StrConv(n, vbNarrow) 　With CreateObject("VBScript.RegExp") 　　.Pattern = "([△\-+]?[\d,\.]+)円"　'正規表現パターン 　　.Global = True 　　.IgnoreCase = False 　　 　　Set Matches = .Execute(n) 　　If Matches.Count > 0 Then 　　　For Each m In Matches 　　　　buf = buf & "＋" & m.SubMatches(0) 　　　Next m 　　End If 　End With 　WhichNumYen = Mid(buf, 2) End Function '///
表示させるセルに『=MAXA(A1:A100,A200:A300)』と打ち込めば出ますよ
[No.1お礼]へのコメント、 》 例２ セルＢ6の値が文字のPの時にセルＢ7に15と表示 何度も説明をし直されているようだけど、なぜ「15」なのかもキチンとお願いします！
少し手間を入れますが，下記の様な作業で如何でしょうか？ ①まず先頭の=を消して文字列にする． ②空いているセルに=SJ11&","""")"を入れる→　($SI$6-NS11*$NS$6)*100/NS11,"")　と表示されると思います． ③　②の数式をコピーしてSJ11に値として貼り付ける． ④置換で置換前の文字を(　，置換後の文字を=IFERROR(にする． ⑤　②の作業セルを削除する この①～④の作業で希望する数式に変える事ができます．ポイントは②の作業セルを用いる方法ですが，これは当然作業列，作業行としても使う事ができます． （つまりSJ2～SQ30と同じ範囲で②の式を空いているセルにコピーすると語尾に,"")が付いたセルを作ることができる．）
ミスった Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Dim myStr As String myStr = "HH" If Target = Cells(3, 1) Then If (InStr(Cells(10, 2).Value, myStr) >= 1) Then _ Cells(10, 2) = Replace(Cells(10, 2), myStr, "") End If End Sub
ディスクトップではなく、机の上で使うＰＣなのだから「デスクトップ」ですね。 「おにぎり」って「Rapture」のことでしょうか。 企業のソフトと違ってフリーウェアは名称をキチンと書かないと作者に失礼です。 ＰＣ関連の質問をする際は必ず自分の使用環境も書きましょう。 最低限でもＯＳの種類とExcelのバージョンを。 ページ数が倍になるというのは貼り付けた画像の幅が大き過ぎるだけなので、サイズを小さくすればページ数も減ると思いますよ。 またはページレイアウトで画像が収まるような印刷範囲に調整して下さい。
=COUNT(1/FREQUENCY(A1:A200*200+B1:B200,A1:A200*200+B1:B200))
こんにちは、以下のコードをコメント部にいれてみて下さい。 'ここから 'この行はとりあえずコメントにしました '''''ActiveSheet.PasteSpecial Format:="図 (JPEG)", Link:=False, DisplayAsIcon:=False '変数設定はループの外(上の変数設定の部分)でして下さい dim wWIDTH as long dim wHIGHT as long dim wRITU as double dim MyShape as shape dim oPIC as stdole.IPictureDisp cells(i,1).select '<--- 画像を貼り付けるセルを選択しています Set oPIC=LoadPicture(fName(i)) '指定したセルの高さに合わせる場合(今回は高さに合わせました) wHIGHT=Selection.height 'セルの高さ wRITU =wHIGHT/oPIC.height '比率=セルの高さ / 実画像の高さ wWIDTH=int(oPIC.width*wRITU) '指定したセルの横幅に合わせる場合 '' wWIDTH=Selection.width 'セルの幅 '' wRITU =wWIDTH/opic.width '比率=セルの幅 / 実画像の幅 '' wHIGHT=int(oPIC.height*wRITU) Set MyShape=ActiveSheet.Shapes.AddPicture(Filename:=fName(i),LinkToFile:=False,SaveWithDocument:=True, _ Left:=Selection.Left,Top:=Selection.Top,Width:=wWIDTH,Height:=wHIGHT) 'ここまで では頑張ってください
2名前は2文字以上で12文字未満(変更可)ということにして =TRIM(MID(SUBSTITUTE(ASC(A1)," ",REPT(" ","10")), FIND("様",SUBSTITUTE(ASC(A1)," ",REPT(" ","10")))-12,13))
こんばんは！ 他の方がお考えになったコードに手を加えるのは本意でないので、 当方なりにやってみました。 今回の場合はフラグは考えなくて良いと思います。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Dim str As String, myArea As Range With Target If .Address = "$B$14" Then Cancel = True str = Left(.Value, 1) Set myArea = Range("B15:CT50") If str = "↑" Then myArea.Sort key1:=Range("B15"), order1:=xlAscending, Header:=xlNo .Value = Replace(.Value, str, "↓") Else myArea.Sort key1:=Range("B15"), order1:=xlDescending, Header:=xlNo .Value = Replace(.Value, str, "↑") End If End If End With End Sub こんな感じでよいのでしょうか？m(_ _)m
G3=SUMPRODUCT((A3:A10=F3)*(B3:B10>0)*(B3:B10)) で出ますね。
[No.3]ですが、私が書いた式中の一部がなぜか文字化けしています。 次のように、訂正願います。 FIND(&quot;:",A1) 　　　↓ FIND(":",A1)
また何かご縁があればと思います。 VBAは奥が深いので頑張ってください。
こんには r.EntireRow　を r.Offset(0, 1).Resize(1, 72)　とか Cells(r.Row, 2).Resize(1, 72)　などに 置き換えることで実現できないでしょうか？
Excel2013以降スタートから立ち上げても同じインスタンスで開かれるようになりました。 http://blog.livedoor.jp/blackwingcat/archives/19 … Altキーを押しながらExcelを立ち上げるか、 Excel.exe本体を探して、そのショートカットをデスクトップなどに作成し、 そのプロパティを開きリンク先が下記のようになっているので "C:\Program Files (x86)\Microso・・中略・・・\EXCEL.EXE" ↓ "C:\Program Files (x86)\Microso・・中略・・・\EXCEL.EXE" /x として保存。 これからExcelを立ち上げれば別のインスタンスで開かれます。 マクロを実行するファイルを別のインスタンスで開けば大丈夫じゃないかな？
No.6 です。 範囲を間違えていました。 下記のように訂正します。 =IF(AND(B1<=MIN(A1:A1000),C1>=MAX(A1:A1000)),"TRUE","FALSE")
>最初の文字を大文字にしてしまいます 2000ですか･･･古いですね。 確か、ツール→オートコレクト→オートコレクトタブ □文の先頭文字を大文字にする のチェックを外すのでは如何でしょうか？ 参考リンク http://www.relief.jp/itnote/archives/000407.php
SetTimer関数は知らなかったので調べてみました。。。 http://note.phyllo.net/?eid=1106267 コードが不明なので・・・どこかでKillTimer SetTimerを繰り返す必要がありそうです。 となるとPrinterのQueやStatusを検出する必要も出てきそうな気がします。 なので別案 Declare Function timeGetTime Lib "winmm.dll" () As Long Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) t1=timegettime call proc1 t2=timegettime if t2-t1 <500 then sleep 500-(t2-t1) end if みたいな感じで余った分だけSleepではダメ？ でこれをループ処理。 http://homepage2.nifty.com/DreamyCat/APIpage1.htm
ISBLANK関数は演算により空白（””）を返しているセルを空白と見なしません。 あとは文字列の長さが０なら…。 ということで、 空白ではない AND 文字列の長さが０ を条件にすればよいので、No.1の回答と似たような形になりますが、 =AND(NOT(ISBLANK(A1)),LEN(A1)) でしょうか。
回答したいのですが，質問文が分からないところがありまして， A列が日勤の場合で、B列が350,000、 A列が夜勤の場合で、B列が450,000、 B列が隔勤の場合で、B列が400,000、 とありますが，１行目と2行目でともにA列で日勤と夜勤とありますね． この時，A列が日勤であるかをどの様に判定するのでしょうか？夜勤も同様です． 3行目は隔勤がB列で，値もB列にあるのですね．これもどうやって区別するのでしょうか？ 私が思ったイメージではA列には日勤，夜勤，隔勤のいずれかの文字が入り，B列にそれぞれの数字が入るとする．上述のようにある数値を超えた場合（以上ではなく超過）にはC列にB列の2%を掛ける数式を入れたい，であれば下記の様な関数で組めます． =IF(OR(AND(A1="日勤",B1>350000),AND(A1="夜勤",B1>450000),AND(A1="隔勤",B1>400000)),B1*0.02,"") IF関数は論理式と真の値，偽の値を指定する関数です． 論理式には質問文の条件である，"日勤で350,000超である事/夜勤で450,000である事，隔勤で400,000である事のいずれかが当てはまる"を下式を入れています． OR(AND(A1="日勤",B1>350000),AND(A1="夜勤",B1>450000),AND(A1="隔勤",B1>400000)) 真の値は論理式の条件にあてはまる場合の式を入れています． B1*0.02 偽の値は論理式の条件に当てはまらない式（この場合は空白）を入れています． ""
添付図参照 =IF(A2="ﾌﾙﾀｲﾑ",B2*45%,IF(A2="定時",B2*48%,"")) でＯＫでしょ、社長！
Sheet1の 》 B1に=floor(A1,"1:00") の式を =FLOOR(MOD(A1,1),"1:00") に変更してみてください。
書き込めないようにするにはマクロを使うしかない。 あるいは斜線を入れて記入が無効であることを示すかですね。 以下、記入が無効であることを示す斜線を条件付書式で入れるものとして回答してみる。 （概念だけ示すので分かりにくいとは思うが…） ・日付を1日から31日まで＋１して作成し、もしも翌月の日付になったら斜線を入れるようにすれば良い。（29日から31日のセルでのみ行えばよい） =MONTH(今月1日の日付が記入されたセル)<>MONTH(比較する日付が記入されたセル）　（←これは今月の1日の月と、セルの月が等しくなければ翌月と判断している） ・休日出勤をした時に対応ができなくなるので、祝日まで記入できなくすることはお勧めできない。セルの色を変えるくらいにしておこう。 ・曜日はWEEKDAY関数で得られる。 =WEEKDAY(日付が記入されたセル,2)>5　（←これは土日であるかを検査している。WEEKDAY関数について理解しておくこと！） ・またセルの表示形式で日付をそのまま曜日表示にできる。 （ユーザー書式に「aaa」と"a"を３文字続けて指定すると日月火水木金土の表示になる。曜日のセルは曜日を入力ではなく数式で「=日付が記入されたセル、=A2」などとすると良い） これらを条件付書式で判定して斜線やセルの色を変えるなどしよう。 今日の日付はTODAY関数で求めても良いが、記入欄の日付は1日の欄だけは年月日を指定、2日以降は上のセルに＋１して求めよう。 そしてセルの表示形式でユーザー書式で日だけを表示するようにする。 （ユーザー書式に「ｄ」の一文字を指定） 祝日などの指定は、他のシートに祝祭日の一覧を作成し、カレンダーの日付がその一覧に含まれたら祝日と判定するようにするとよい。 MATCH関数で日付が該当するかを調べたときに該当が無い場合はエラーになるが、 条件付書式内で関数を使う時エラーはFALSEとして扱われるので、単純に「該当なし」と判断される。 祝祭日のシートは毎年作成し直す手間はあるが、 春分の日や秋分の日はルールはあるが国が指定するので都度作り直す必要がでてくるので気にしてはいけない。 （「祝祭日シート」のA列に祝祭日の一覧を記入したら、=MATCH(日付が記入されたセル,祝祭日シート!A:A)>0 で調べることができる）
#1 です。 いえ、その場合でも、A3セルが、 =IF(AND(A1="",A2=""),"",SUBTOTAL(9,A1:A2)) としておけば、先の回答のA5の式で機能するはずです。 SUBTOTAL関数については、詳細はお調べいただくとして、 SUBTOTAL(集計方法、範囲）という書式です。 ここの集計方法を「９」とすれば、合計を計算しますので、 SUBTOTAL(9,範囲）で、SUM関数と同じ役割を果たします。 AGGREGATE関数は、 AGGREGATE(集計方法、オプション、範囲）となっています。 同じく、集計方法「９」で合計、 そして、オプションのところは、「０」としますと、 「入れ子となっているSUBTOTAL,AGGREGATE関数を無視」 となりますので、今回やりたいことに合致しています。
No.1のそのままだと"シート1"と"シート2"に固定されます Sheets(Array("シート1", "シート2")).Select この部分を削除して、都度選択した状態でマクロを起動する事が良いかと思いますが、 そうなるとNo.2の方が示されている方法が実務としては単純な解決法となります
#1 です。 すみません。訂正です。 元の式が残っちゃってました。 ループ必要ないですね（汗。 '-------------------------------------------------------------- Sub BBB() Dim Lstrow As Long Lstrow = Range("C" & Rows.Count).End(xlUp).Row Range("D11").AutoFill Destination:=Range("D11:D" & Lstrow), Type:=xlFillCopy End Sub '--------------------------------------------------------------
チェックボックスは、フォームのチェックボックスとして Sheet2!B2セルにリンクしており、TRUE/FALSEが連動して入力されるとします。 また、Sheet2!J46セルは何も入っていないとします [Ctrl]+[F3]名前の定義 名前 判子 =IF(Sheet2!$B$2,Sheet2!$I$46,Sheet2!$J$46) 適当なセルをコピー Sheet1!GR8セルに 図のリンク貼り付け 数式バーに =判子 に修正 ※当方、XL2003なので図のリンク貼り付けは [貼り付け▼]リストから選択できるとは思いますが、 未確認です。キーワード検索してみてください。
四角形の4辺のうち、左辺と上辺は辺の上で文字が切れるようにします。後でトリミングするほうが楽です。（添付図の赤破線部参照） 重複する部分ができるようにとりこみます。 文字を基準に画像をカーソルキーで動かして微調整する。（添付図右側） 文字が切れている画像が前面になるように重ねていきます。つまり地図の上から下へ、左から右へとりこんでいけば、調整が容易になります。 なお、お約束ですが、著作権にはご注意ください。
[セルの書式設定]の[表示形式]タブ→[ユーザー定義]で設定すれば出来るのではないでしょうか？ http://www.excel.studio-kazu.jp/lib/e3g/e3g.html …
sgtioo様、こんばんは。 知っていることなら、何でもお答えします。 まず、 >それと私のＰＣは64bitＯＳですがエクセルは32bitのものです。 >この場合、教えて頂いた通りの型でいいのでしょうか？ 基本的には、Excelは32bit 上で動かすことを目的にしたアプリですから、大別すると、整数値はLong型、小数値はDouble型と選んでおけば間違いがありません。私がいInteger型やSingle型を使うことは、ほぼありません。他に、Currency型やByte型は、特殊な目的です。 >Gn=Arrayの所で(i-1)の意味　（どういう仕組みで、iで切り取った１文字とＭ～Ｈの文字を対応させるのでしょうか？） Gn = Array("M", "T", "S", "H")(i - 1) Array 関数は、配列ですから、配列の添字(Index)は、0から始まります。i (1～4) ですが、配列の入れ物は、0～3　までなので、1を引きました。 言葉では分かりにくいですよね。こういう時に、ローカルウィンドウを使います。そしてブレークポイントを左の縁に付けます。(クリックをする） ユーザー定義関数　DateChangeのコード中のGnの手前に以下のようなコードを臨時に置きました。 ar = Array("M", "T", "S", "H") 'ar という変数を臨時に置きました。 Gn = Array("M", "T", "S", "H")(i - 1) 後は、添付画像をみてください。 >If IsDate(buf)でエラーを出させる意味 >日付型として多分文字型のbufを比較＝偽ならbufにエラーを入れる（文字？数字？） 本来、日付値として認識できるものかどうかについては、IsDate 関数の判定が簡単なのです。基本的には文字になります。日付値の変換は、DateValue関数やCDate関数を利用しますが、その前に、IsDate関数でチェックします。なお、VBAの中では、日付値と時間値は、一緒に扱われることは、人為的に行わない限りは、ありません。そのどちらかです。 ここのカテゴリの「エクセルの書式設定」という質問に、「2015年11月22日(日)15:16」を日付値で貼り付けられないかというご質問は、解決しないままに終わりましたが、IsDate で試してみれば分かりますが、False になります。 例： t = "2015年11月22日(日)15:16" MsgBox IsDate(t)　'False 　　　↓ t = "2015年11月22日 15:16" MsgBox IsDate(t)　'True いろんなバリエーションはあるけれども、日付値として認識するのは、このIsDate を使わないかぎりは、なかなか難しいです。むろん、その質問の回答は、クリップボードの中を加工する特殊なプログラムが必要です。 他の例 t = "2015年11月31日15:16"　　'11月には31日はありませんからFalseになります。 MsgBox IsDate(t)　'False となります。 >色々あって、そのエラーをSubの方のDateChangeに戻す？であっているでしょうか？ その通りです。プロシージャにエラーを戻すのはおかしな話なのですが、ユーザー定義関数で返ってきた値をSubプロシージャに戻しています。これは、他にも汎用できますし、その状況に合わせて出力も変えることが可能です。 なお、ユーザー定義関数は、ワークシート上でも使えます。 また、今回、私の書いたものは、中途半端ですから、できれば、sgtiooさん自身で手直しをしたり、自分の目的にあったものに書き換えてください。 最後に、VBAでも、だんだん消えてしまう技術と、新しい技術とか交錯する時期なのかもしれません。VBAには、非常に古い技術も残っていますし、VBAの中では、それも使えるようになっていますが、それらは、どこにも載っていませんから、忘れ去られてしまうものも増えてくるような気がします。
こんばんは！ おそらくセルの書式設定のユーザ定義は最大3個までしか設定できなかったともいます。 ユーザー定義の欄に [赤][<0]-#,##0;[青][<10]0.0;[青]#,##0;@ としてみてください。 ①　マイナスの場合のフォント色は「赤で3桁のカンマ区切り」 ②　プラスの場合で10未満の場合は「青で小数点以下一けた表示」 ③　プラスで10以上の場合は「青で3桁のカンマ区切り」 その他（文字列）の場合は「自動」（黒） 以上のような表示になると思いますが、 「0」の場合の設定ができません。 「0」の場合の表示桁数は一桁でフォント色は「自動」がお望みなのではないでしょうか？ おそらく手動でのセルの書式設定のユーザー定義ではどれか一つを犠牲にする必要があるのではないかと思います。 （できる方法があればごめんなさいね。） ただ、お望みの方法ではないかもしれませんが、 上記条件付き書式のセル変更があればマクロで書式を変えてやる方法があります。 マクロでやるとなるとわざわざセルの書式設定を手動でやる意味がないので 敢えて今回はこの程度で・・・m(_ _)m
こんばんは！ Excelに貼り戻したデータは文字列なのですね？ そうであれば書式設定だけでは対応できないと思います。 別セル表示でよいのであれば一例です。 仮にB1セルに文字列をコピー＆ペーストするとC1セルにシリアル値を表示させるとします。 B1セルに文字列で 2015年11月22日(日) 19:15:08 のようになっている場合、 C1セル（セルの表示形式はユーザー定義で　yyyy/m/d h:mm　）に =LEFT(B1,FIND("(",ASC(B1))-1)+TRIM(MID(B1,FIND(")",ASC(B1))+1,10)) としてみてください。 まずはこの程度で・・・m(_ _)m
こんにちは。 ここのカテゴリは、かなりVBAができる方が多いようですが、そうではなくて、私が進歩していないのでしょうね。今回のこの内容は、もう10年以上も前の技術です。OkWaveとの分離前には、初期のBasic ライクのコードを書いている人がいましたが、私からすると、それはそれでオツなのですが。(w) さて、 >２ application.inputboxについて >これまで使ったことはありませんでした。これを使えば数式、文字列、数値、rangeオブジェクトなどを入力 Helpなどでみるよりも、実際は、もっと複雑なのですが、簡単にいうと、戻り値は、String型、Long型などの数値型だけでなく、Boolean型も含まれます。戻り値を、Variant 型にすることによって、""(長さ0の文字列）なのか、数値の0なのか、キャンセルキーを押した時の、Boolean型なのか、Vartype関数によって、判定ができます、という言葉でいうと、難しいことが可能になります。それを、Input関数で行うというと、ポインターの位置とか、VBAでは出てこないような内容になってしまうのです。 ベテランさんのコードでは、そういうワザも見られます。 >一度に開きたいのです。（一つのＩＥに３つのタブを開きたい） ずいぶん昔にやっただけですから、思ったものと同じかどうか分かりません。 >３か所のセルのハイパーリンク先を３つ一度に開きたいのです。（一つのＩＥに３つのタブを開きたい） マクロの順番に開いていくだけですが、よろしいでしょうか。s ポイントは、Navigate2 URL, &H800 ということなのです。 ActiveSheet の　A1～A3 に以下のように入れました。 http://www.yahoo.co.jp/ http://www.msn.com/ja-jp http://www.rakuten.co.jp/ '------------------------- '// 'Wait として使うには、これが一番軽い。なくても可能だと思います。 Private Declare Sub Sleep Lib "kernel32.dll" (ByVal dwMilliseconds As Long) Sub OpenIE() 　Dim objIE As Object 　Dim c As Range 　Dim arURL(0 To 2) As Variant　'配列の意味はないけれども、見やすさのためです。 　Dim i As Long 　'3つのURLを調べるお約束 　For i = 1 To Range("A1:A3").Cells.Count 　　With Range("A1:A3") 　　 arURL(i - 1) = .Cells(i).Hyperlinks(1).Address 　　End With 　Next i 　Set objIE = CreateObject("InternetExplorer.Application") 　objIE.Visible = True 　'①　ここが元です。だから、Navigate で、2ではありません。 　objIE.Navigate arURL(0) 　Do While objIE.Busy Or objIE.ReadyState <> 4: DoEvents: Loop 　　Sleep 1000 '1秒停止 　　'② 　　objIE.Navigate2 arURL(1), &H800 　　Do While objIE.Busy Or objIE.ReadyState <> 4: DoEvents: Loop 　　　Sleep 1000 '1秒停止 　　　'③ 　　　objIE.Navigate2 arURL(2), &H800 　　　Do While objIE.Busy Or objIE.ReadyState <> 4: DoEvents: Loop 　　　　MsgBox "終了", vbInformation　'これは、IEの画面が出ていると出てきません、不要かも。 End Sub '///
P6の数式を　P7から、O列の最終行までの繰り返し でよろしいですよね。 Sub Macro1() For i = 7 To Range("O" & Rows.Count).End(xlup).Row Range("P" & i ).Formula = Range("P6").Formula Next End Sub と3行で可能です。 Range("O" & Rows.Count).End(xlup).Row は、O列の一番下から上へ移動して空白でないセルへ移動し その行番号 と云う意味です。
こんばんは。 Range("BI" & TR).Formula = "=IFERROR(SUM(BK" & TR & ": BT" & TR )",""ERR"")" 　　 ↓ Range("BI" & TR).Formula = "=IFERROR(SUM(BK" & TR & ": BT" & TR & "),""ERR"")" 後ろのTRの後の「 & "」 が抜けているようです。 本格的なマクロするなら、数式を入れるのではなくて、SUMの値を変数に入れたほうがよいですね。 その値は、Variant 型にしておけば、エラー値も取れますから、エラーになったら、ERRの文字を代入すれば、Formula で数式を入れる必要はありませんね。
こんばんは。 もし、意味を取り違えていたら、すみません。 ご質問の例の場合は、 a　　あ　　1 c　　あ　　1 c　　あ　　1 c　　あ　　1 こういう状況で、「2 」の解を出すということでしょうか。 もしそうでしたら、E列を補助列にして、 E2に以下のような式を置きます。 =IF(SUBTOTAL(3,A2)>0,A2&","& B2 &"," &C2,"") (カンマでくくるのは、同じ文字列が、横のセルに発生することを考慮したからです） 上の式をフィルをドラッグしてコピーします。 上から、このように出できます。 a,あ,1 c,あ,1 c,あ,1 c,あ,1 データが20行目まであるならば、 =SUM(1/COUNTIF(E2:E20,E2:E20))-1 で、Shift+Ctrl - Enterで、配列の確定をします。 1を引くのは、該当しないものは、0になるからです。余計な数式は入れないことです。 なお、データ量が可変する場合は、 =SUM(1/COUNTIF(OFFSET(E2,,,COUNTA(E2:E10000)),OFFSET(E2,,,COUNTA(E2:E10000))))-1 として、最後の行を探します。E列のデータの下には何もいれないでください。 P.S.私が、年に数回の関数の回答する時は、だいたい不条理なことが起きます。例えば、数式の「E10000」する理由などはありません。これは任意ですから、ご質問者さんが決めてください。
Sub サンプル() Sheets(2).Activate With Sheets(1) .Range(Cells(1, 1), Cells(1, 3)).Interior.ColorIndex = 48 End With End Sub これは実行するとエラーになります。 With Sheets(1) .Range ピリオドを打っているので、対象はSheets(1)になります。 ところがRangeの中のCellsの前にピリオドがないので、Cellsの対象はアクティブシートSheets(2)になります。 それが定義エラーの原因です。 .Range(.Cells(1, 1), .Cells(1, 3)).Interior.ColorIndex = 48 ピリオドを打つことで Sheets(1).Range(Sheets(1).Cells(1, 1), Sheets(1).Cells(1, 3)).Interior.ColorIndex = 48 と同じ意味になります。
B1:F○○セル範囲をB1セルから選択し、 条件付き書式の数式が、 =FIND("B4010",$A1) で設定する
[Alt]キー押しつつ、[メニュー]キーかな？ オートフィルするときに、マウスの右ボタンを使うのも一案です。
再び参上です。 ＞もしそうだとしたら変数をリセットして、初期状態（表の一番上からやり直す）ボタンみたいなものが作れるのでしょうか。 最初に投稿したように何番目の表からの検索開始か？を指定するために カウンター用としてHI1セルに数値を表示させるようにしています。 そこを「0」にしてやれば1番目の表からの検索になりますので、 コマンドボタンをもう一つ追加し↓のコードにしてみてください。 Private Sub CommandButton2_Click() Range("HI1") = 0 Range("HJ3").Resize(8, 4).ClearContents End Sub ※　コマンドボタンのプロパティから Caption（タイトル）は「リセット」などのような感じにしてみてください。 ついでにHJ3～HM10のデータも消去しています。m(_ _)m
いつのまにかシートが別になっているし、図だけではよくわからないです。 各セルにどういった式をいれているのか、どういう条件で色をつけたいのか言葉で説明していただけますか？
misopal様、こんにちは。 丁寧なご説明をしていただいて、ありがとうございました。おっしゃっている概要をクリアできないと、例え、いかなる分野のユーザーであっても、ExcelのVBAの使い手としては失格かなっていう気がしてきます。私は、もう引退のつもりではいたのですが、とても、良い刺激になりました。新しく覚えようとしている人たちには、敵わないと思ったからです。 1、設計　～7、ERP/MRPの部品番 の各項目は、本来は、VBA・マクロの領域の話のようです。そのデータを管理するものが、データベースであり、MySQL などのデータベースエンジンだと思います。 実は、私自身は、DAO から、ADO のExcelアプリ添付のデータベースエンジンで十分だと思っていたのですが、しばらく見ない間に、MySQLがこれほど進化しているとは思っていませんでした。 ADOは、ご存知の通り、Access のデータベースエンジンで、Access を持っていなくても使えますから、私は、大した技術もありませんが、VB6のADO/DAOの資料を何冊も購入し、見よう見まねでVBAで開発してしまうことが多いのです。しかし、Office 2007以降、Excel自体も、最大行が、2^20 行になりましたので、それ以上のデータは別としても、十数万行のデータでも、そのまま扱えるようになりました。 >私はプログラミングにまったく興味がない ここらの度合いにもなりますが、掲示板でマクロ入手やVBAのメインテナンスを維持している方もいらっしゃいます。ただ、多くの人は、業務命令の中で行っているようですので、説明的に不足していて応答にも辛いものがあります。 misopal様のような、技術畑の人の質問は、私の知る範囲では、あまり多くありません。たぶん、よほどのことがない限りは、掲示板のアドバイスは不要だからなのだと思います。また、そういう方なら、ここは一般掲示板ですが、VBA専門掲示板でも、たぶん維持できるはずです。要点がまとまっていれば、かなりピンポイントの内容で、仮にVBAマクロでも、入手できるものだと信じています。 ご趣旨は、プログラミングはなしでということだと思いましたが、回答として目的とは違う内容にしてしまいすみません。
Private Sub Sample() 　　Dim lngMaxRow As Long 　　Dim NippoWs As Worksheet 　　Dim GeppoWs As Worksheet 　　Dim rng As Range 　　Dim lngRow As Long 　　Dim lngCol As Long 　　Set NippoWs = Workbooks(ThisWorkbook.Name).Sheets("日報入力") 　　Set GeppoWs = Workbooks(ThisWorkbook.Name).Sheets("月報売上") 　　lngMaxRow = GeppoWs.Cells(Rows.Count, 1).End(xlUp).Row 　　Set rng = GeppoWs.Range("A:A").Find(NippoWs.Cells(3, 2)) 　　If NippoWs.Cells(3, 2) = "" Then 　　　　MsgBox "日付が入力されていません" 　　　　Exit Sub 　　ElseIf rng Is Nothing Then 　　　　MsgBox "日付がありません" 　　　　Exit Sub 　　End If 　　lngRow = 0 　　For lngRow = 1 To lngMaxRow Step 1 　　　　If NippoWs.Cells(3, 2) = GeppoWs.Cells(lngRow, 1) Then 　　　　　　GeppoWs.Cells(lngRow, 2) = NippoWs.Cells(6, 2) 　　　　　　GeppoWs.Cells(lngRow, 3) = NippoWs.Cells(6, 3) 　　　　　　GeppoWs.Cells(lngRow, 4) = NippoWs.Cells(6, 4) 　　　　End If 　　Next End Sub こんな感じでどうでしょうか？
No.1です。 ＞さらにもう一つ条件が加わったらどう書けばいいですか？ ＞例えばＵ15＝1に加えてＦ15＝1という条件も満たす必要があるときは・・・ AND関数の条件を増やすだけで大丈夫だと思います。 数式を =AND(T15=1,F15=1,MOD(H15,U15)=0) としてみてください。 ※　（　）がいっぱいあって難しいですが というコトですが、ご自身で直接手入力しても問題ないと思いますが 数式が長くなると間違いのもとですので、 どこか使っていないセルに直接数式を入れてみます。 この場合は関数の引数ダイアログボックスが使えます。 結果が「TRUE」もしくは「FALSE」だと数式そのものは合っているはずです。 その数式をそのままコピー＆ペーストするのが間違いないかもしれません。 ただ、結果がお望みどおりになるかどうか？は別問題ですが・・・m(_ _)m
No.1・3です。 あ～～～そういうコトですかぁ～！ B11セル以降に数値データが5個以上あったときにマクロが実行されればよいのですね？ その時に最大値・最小値を一つずつ消去すれば良い！というコトだとすると ↓のコードにしてみてください。 Sub Sample3() Dim lastRow As Long, myArea As Range Dim c As Range, myMax, myMin lastRow = Cells(Rows.Count, "B").End(xlUp).Row If lastRow > 10 Then Set myArea = Range(Cells(11, "B"), Cells(lastRow, "B")) If WorksheetFunction.Count(myArea) > 4 Then '範囲内に数値データが5以上の場合// myMax = WorksheetFunction.Max(myArea) myMin = WorksheetFunction.Min(myArea) Set c = myArea.Find(what:=myMax, LookIn:=xlValues, lookat:=xlWhole) c.ClearContents Set c = myArea.Find(what:=myMin, LookIn:=xlValues, lookat:=xlWhole) c.ClearContents End If End If End Sub ※　今回も最初に出現する「最大値」・「最小値」のみを消去するようにしています。 今度はどうでしょうか？m(_ _)m
こんにちは！ お示しの数式で「中野管材」分も表示されているのであれば、同じく配列数式で =IFERROR(INDEX($L$1:$L$1000,SMALL(IF(($T$1:$T$1000=AB$55)*(K$1:K$1000<>"中野管材"),ROW($T$1:$T$1000)),ROW(A1))),"") としたらどうなりますか？ 配列数式内の ＞IF($T$1:$T$1000=AB$55,・・・ の部分の条件に「中野管材」以外を加えます。 ※　当然どこかのセルにK列の除外するデータを入力し、そのセルを参照することも可能です。 その場合は ＞(K$1:K$1000<>"中野管材") の部分を ＞(K$1:K$1000<>参照セル) のようにします。m(_ _)m
Sheet2!B1セルに =INDEX(Sheet1!B:B,MATCH(2,MATCH("*"&Sheet1!$A$1:$A$6&"*",A1,0))) [Ctrl]+[Shft] ＋[Enter] で確定、配列数式。{ }で挟まれる 下へオートフィル
こんばんは！ Sub Sample1() Dim cnt As Long Do cnt = cnt + 1 Cells(cnt, "A").Resize(, 11).Copy Cells(cnt, "M") If cnt = 30 Then Exit Do Loop End Sub でも大丈夫だと思います。m(_ _)m
こんにちは！ すでに解決済みなら読み流してください。 セルの書式設定ではどうでしょうか？ 範囲指定　→　右クリック　→　セルの書式設定　→　「表示形式」タブのユーザー定義で [<10]#.0;0 とし、OK　m(_ _)m
http://amaotolog.com/excel/47 AndとOrの組合せではAndを先に処理するそうです。 ご質問の例では、 (AFが1 かつ Cがs) または (CがS) を判断していることになります。 If Range("AF" & i).Value = 1 And (Range("C" & i).Value = "s" Or Range("C" & i).Value = "S") Then というように、先に処理したいところをカッコでくくると、うまくいくそうです。
こんばんは。 >えーそりゃないよ引数付はダメじゃん、が感想です。 こんな感じで処理することもあります。 '// 'TestBook1.xlsmが同じフォルダーにある場合 num = 5 Application.Run "'TestBook1.xlsm'!Module1.MyTestArg(" & num & ")" 'ただ、あまりうまくいくとはいえません。これは、文字の引数が受けられません。 'やはり、Call の方が上です。 '-------------- Public Sub MyTestArg(arg) If IsNumeric(arg) Then 　MsgBox arg ^ 2 Else 　MsgBox "文字？ " & arg End If End Sub '//
そのマクロは手作り？それとも既製品？ 原因は、論理に間違いがあるか使用条件に間違いがあるんでしょうね デバッグ実行すれば、どのポイントでエラーになるか程度は切り分け出来そうだが
>ちなみに、D5～D65535にはif(A1="","",A1)のような数式が入っており だったら =IF(A5="","",IF(SUBTOTAL(2,A5)=0,"",A5)) ような感じにしてはどうでしょうか？
並べ替えを[マクロの記録]し、それを書き換えてる方法もありますよ。 http://officetanaka.net/excel/vba/tips/tips148.htm http://www.relief.jp/itnote/archives/excel-vba-s … 記録された ActiveWorkbook.Worksheets("Sheet1").Sort. の部分を、 ActiveSheet.Sort に変えれば、開いたシートでマクロ実行するだけで 同じ並べ替えをしてくれると思います。 すべてのシートで実行するなら、以下のマクロを追加して実行します。 Sub 全シート()　 Dim st As Worksheet 　For Each st In Worksheets 　　st.Activate 　　Call マクロ名 '（マクロの記録で登録した名前） 　Next End Sub マクロ関連サイト http://kokodane.com/2013_macrokouza1.htm
表示させるだけでしたら、No.1さんの回答でよいと思います。 セルの値(文字)自体を変更する必要がある場合のやり方です。 A1セル以下に元データがあるとして、A2セルに下記の式を入力してコピペする ="D"&A1
追加 （レジストリを弄るより先に） トラブルのときは、 （1）デバイスマネージャでプリンタのデバイス右クリック「プロパティ」「ドライバ」「削除」再起動でWindows汎用ドライバを再生成してみる。 （2）該当のプログラム（Office)をアンインストール、再起動、再インストールしてみる。（Administratorでログオン後インストール実行） （レジストリ操作を間違えるとOSが起動しなくなることがあります）
[フィルタオプションの設定]でも実現可能です。 添付図参照 セル G4 に式 =G4=B$1 を入力しておいて、 抽出先→選択範囲内 リスト範囲→$B$3:$G$1000 検索条件範囲→$G$1:$G$2 【余計なお世話】既に多くの回答が得られているのに、ナシのツブテを決め込んでいるのはナゼ～？
勝手に質問を解釈してお答えします。（一応、マクロ案です） データのシート（Sheet1） 　　A　　B　　　C　　　E　　　F　　G １　NO　品名　送り先　種別　出荷　納品日 ２ と一行目に項目を入れて、二行目以下にデータを入れる形にします。 抽出のシート（Sheet2) 　　A　　B　　　C　　　E　　　F　　G １　納品日 ２ ３　NO　品名　送り先　種別　出荷　納品日 と、A1セルに抽出したい項目、A２セルに　抽出する日付を入れるとします。 3行目に、更に項目名を入れておきます。 Sheet2の名前のタブを右クリック、コードの表示をクリックして VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$A$2" Then Sheets("Sheet1").Columns("A:G").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("A1:B2"), CopyToRange:=Range("A3:G3"), Unique:=False End If End Sub を張り付けて、VBエディターを閉じる。 Sheets2のA2セルに日付を入れると 納入日が、その日付のデータだけが4行目以下に表示されます。 このマクロは、フィルターオプションをマクロ化したものです。 参考までに、納入日が日付順に並んでいれば、簡単な関数でも安納です。 提示してあるシートでも可能ですが、データは1行目に項目、2行目以下にデータを入力する事が鉄則と思ってください。 あくまでも出荷日＝納入日　として考えました。
Sheet2にフィルタをかけるだけなので、Sheet1は、編集されませんよ。 どうしても、フィルタを使いたくないのであれば、マクロを使うしかありません。 関数で、別シートに反映させることは、不可能です
該当データが複数ある場合の抽出法の一例です。 D列を作業列にしています。 D11に条件式を入力して、データの最下行までコピペしました。 =AND(A11=$A$1,C11<=$B$1,$B$1<B11) C1セルには次の数式を入れました。 =COUNTIF(D:D,TRUE) 結果は3でした。 条件を満たすデータが3件あります。 E1:M7にはこのような数式を入力してあります。 =IFERROR(INDEX(E$1:E$1000,SUMPRODUCT(LARGE(($D$1:$D$1000=TRUE)*ROW($D$1:$D$1000),$C$1-ROW()+1))),"") E$1:E$1000 この箇所だけ列が相対参照になっています。 ------------計算A-------------- ($D$1:$D$1000=TRUE)*ROW($D$1:$D$1000) 条件を満たした場合 (TRUE)*行番号=行番号 満たさない場合 (FALSE)*行番号=0 ------------------------------ LARGE(計算A,$C$1-ROW()+1) $C$1-ROW()+1が、LARGE関数の順位になります。 【E1セル】 (3-1+1)=3 3がLARGE関数の順位になります。 計算Aが3番目に大きい値になります。 言い換えると一番小さい値になります。(0を含みません） 条件を満たさない場合が0なので、LARGEの変わりにSMALL関数を使うと、0が一番小さい値になります。 ※条件を満たさないデータを取り出すことになります。 LARGE関数を使用して、(条件を満たすデータの個数-ROW()+1)にします。 【E2セル】ROW()の返り値が変わるので($C$1-ROW()+1)=2になります。 【E3セル】($C$1-ROW()+1)=1になります。 【E4セル】($C$1-ROW()+1)=0　 エラー処理をしてない場合はエラー値が返ります。 IFERROR関数でエラー処理をしているため、条件を満たすデータを順番に取り出して、それ以降は空白を返します。 条件を満たすデータの個数によって表示されるデータ数が変わります。 1件しかない場合は、1件しか表示しません。 0件の場合は、何も表示しません。
解決策ではないのですが、 about:blank にハイパーリンクを設定すると新しくIEが開くようです Vista&EX2003&IE9
こんばんは！ タイトルには ＞値で貼り付けたデータの置換 とありますのが 質問文では ＞検索対象の欄に【数式】しか見つかりません。 となっていますね。 タイトル通りだと ペーストの時に形式を選択して貼り付け　→　「値」を選択しOK という操作に思えるのですが・・・ その場合は↓のマクロを実行してみてください。 Sub Sample1() Dim k As Long, myAry As Variant myAry = Array("#DIV/0!", "#N/A", "#VALUE!", "#REF!") For k = 0 To UBound(myAry) Selection.Replace what:=myAry(k), replacement:="", lookat:=xlWhole Next k End Sub 後者の場合（数式バーに数式が表示されている場合）は↓のマクロを実行してみてください。 Sub Sample2() On Error Resume Next '←念のため// Selection.SpecialCells(xlCellTypeFormulas, xlErrors).ClearContents End Sub ※　どちらのマクロも必ず範囲指定をしたのちに実行してください。 おそらく列全体を範囲指定しても大丈夫だと思います。m(_ _)m
次のようなコードをSheet1に書くと、 Private Sub Worksheet_Change(ByVal Target As Excel.Range) With Target　 'Sheet1の単一セルに数値入力した場合 If .Count = 1 And IsNumeric(.Value) Then adr = .Address 　　　’Sheet2の相応するセルに、入力した値が加算されて表示されます Sheets(2).Range(adr) = Sheets(2).Range(adr) + .Value End If End With End Sub 1）Sheet2が空白なら、0から次々と累計されます。 2）開始前にshee1に出ている数値は加算の対象にはなりません。 3) 加算は、A1～FF345のようなどのセルに入力した場合も、Sheet1で入力したセルと同じ番地のSheet2のセルで行われます。
いつもマクロに頼っていらっしゃるようですが、これはマクロを使用することなくできる作業です。 A列の前に列を挿入して、そこにデータの有無を示す値を入れればあとは ・オートフィルタでデータのある行を表示 ・ジャンプ（Ctrl+G）でアクティブセル（表示されているセル）を選択 ・コピー ・別のシートに貼り付け ・B列からW列をコピー ・元のシートに挿入したA列を削除してデータ有無のマークを消す。 ・元のシートのX1セルを指定して貼り付け の手順で作業が完了します。 左上の範囲を示す箇所に「A1:A80000」と入力し、A1セルに =CONCATENATE(B1,C1,...V1,W1） と入力し確定したら Ctrl+Dでその数式をコピーすれば準備は完了です。 ※「A1:A80000」の範囲は実際にデータのある行の範囲を指定してください。 このようにExcelの基本操作とちょっとした関数式で実行可能です。 どうしてもマクロ化したいということであれば、 この一連の作業を記録マクロに登録してはいかがでしょう。
E2:I2セルはシリアル値で○○年○○月1日で入力 数式でE3セルに =$D3/($C3-$B3+1)*MAX(0,1+MIN($C3,DATE(YEAR(E$2),MONTH(E$2)+1,0))-MAX(E$2,$B3)) 右へ 下へオートフィル ただし、小数点以下未処理
No.2の回答と同じです。　マクロを使わない方法。 対象のSheetをSheet1だとすると、Sheet1を選択して、Ctrlを押したまま移動してSheet1(2)を作ります。（Sheet1の現況をSheet1(2)に控えた） 別のSheet（仮に名前を”Sheet差”とします）のA1セルに（=Sheet1!A1-'Sheet1 (2)'!A1）と式を入れて、それをすべてに広げます。Sheet1とSheet差を並べて表示します。 こうすると、Sheet1とSheet1(2)で異なるところがすぐにわかります。 マクロを使う方法。 次のコードを、Sheet1（問題にしているシート）に入れます。 Private Sub Worksheet_Change(ByVal Target As Range) With Target If .Count > 1 Then Exit Sub tadr = .Address tvla = .Value Application.EnableEvents = False Application.Undo tvlb = .Value Sheets(2).Range(tadr) = tvlb & " → " & tvla .Value = tvla Application.EnableEvents = True End With End Sub このようにすると、2枚目のシート(Sheets(2))に、Sheet1で変更したセルの変更状態が表示されます。（数値、数字、文字とも）
とりあえずは、利用者の一覧を作れれば問題は解決しますよね。 一案は、ピボットテーブルです。 ネットで検索してみて下さい。色々な集計が可能です。 仮に 　A　　B 日付　利用者名 10/1　　A 11/1　　A 11/2　　B ・・・・ とデータが入っているします リボン　挿入 左端の　ピボットテーブル ウィザードが起動したら、新規シートでOK 行　に　利用者氏名 列　に　日付 値　に　再度利用者氏名 日付ごとに利用回数が集計されますので、列の日付をクリック グループ化　年、月　を選択すると 毎月の利用回数が集計されます。 関数を使っても結構ですが 11月以前が　０回、11月　1以上の方が新規 10月が１以上　　　11月　0回が脱会者と考えられます。 別案は、フィルターオプションです。 空いている列（仮にF1セル）に　利用者名　と入れておく リボン　データ 中央部分にある　詳細設定　 ウィザードが起動したら 指定した範囲に　チェック リスト範囲　　　B列 抽出範囲　　　　F1 重複するセルは無視する　チェック OK　をクリックすると、利用者氏名の一覧が出来ます。 仮に　G1セルに　11/1　と日付を入れておく G2セルに　Countifs関数　で　=COUNTIFS(B:B,F2,A:A,"<"&G$1) と入れて下へコピーすれば 11/1以前の利用回数が表示されますので 0の方が新規の利用者になります。
数式じゃないので全然やり方が変わるんですが、統合とかは如何ですか？
＞・合成されたセルの場合は出来ない。 ”「結合」されたセル” の間違いだろうか。 折り返して表示している場合は、そりゃ無理な話だ。 しかし、半自動という方法がある。 マウスカーソルを列記号の境目に持っていき手動で幅を変えるとき、 ドラッグではなく、ダブルクリックすると適切な幅にリサイズされる。 これなら印刷時に文字が切れることはない。
コピーして貼り付ける。 ・一覧から該当する行（行単位だよね？）をコピーする。 ・申込書のシートの1行目に貼り付ける。（空いている行ならどこでも良い） ・貼り付けたデータを拾ってフォームに貼り直す。 元のデータを大幅に編集したりファイル名や保存場所が変わると修正に大変な思いをすることになるだろう。 アナログ的なやり方（チカラワザとも言う）ではあるが、 数十件程度ならこの方が理解しやすく、 間違いが少ない気がする。
＞別のシートのA1に出したいです。 なら =COUNTIFS(データ!A:A,"野菜",データ!B:B,15) と云ったようにCountIfs関数を使います。 A列が　野菜で B列が　15　の数を計算します。 どうせ一発でやるなら、ピボットテーブルが便利だと思います。 エクセル　ピボットテーブル　で検索してみてください。
Range(＂A2＂).Value=Range(＂A3＂).Value
> 「＃」が「%20-%20」に変わって 本当に「＃」なのですか？ 「%20-%20」はURLがエンコードされたものだと思います。 この「%20」は半角スペースを示すものですから。 つまり、「 - 」のように「半角スペース＋ハイフン＋半角スペース」の 部分が「%20-%20」なのです。 http://www.glamenv-septzen.net/view/1170 エンコードやデコードすることで確認もできます。 http://www.tagindex.com/tool/url.html 質問にあるURLをアドレスバーからコピーをして、Excelに貼り付けて ハイパーリンクを設定しても、文字化けしませんでしたよ。 警告の後でPDFファイルを開くことも可能でしたしね。
元のデータをどのように非表示にしているかにもよるかと。 列や行を非表示にしたり、列幅や行高をゼロにする方法はリンク図にも影響があります。 （見た目に対する加工とみなされるのだと思います） 元のデータのシートを非表示にした場合はリンク図に影響はありません。
No４でオブジェクト名を直接セルに入力するようにしておりましたが ワンクッション入れてなんとか走るようになりました Sub test() Dim SHAPEOBJ As Shape Dim KMG As String Dim CT As Long With ActiveSheet CT = 0 For Each SHAPEOBJ In .Shapes KMG = SHAPEOBJ.Name .Range("WS20").Offset(CT,0) = KMG CT = CT + 1 Next SHAPEOBJ End With End Sub これの記述で問題なく動作しましたので、セル"WS20"から下に全オブジェクト名が抽出できると思います
ご利用中の証券会社で、WebAPIサービスの提供されていることが必須です。 ただし、本来の利用方法は、マクロを利用してといったような簡単なものではなく、Webアプリケーションを作成するといったようなものです。 このため、Java・php・C#などを利用して、プログラミングして自分のWebサイトに機能として組み込むといった利用方法が一般的です。 それなりの知識が必要だということです。 Excelの場合、2013からWeb用の関数が利用できるようになったため、マクロを利用しなくてもWebAPI機能を利用することができるようになりました。 http://www.ka-net.org/blog/?p=1933 仕組みは上記サイトを参考にしてくださいとしか言えません。 https://www.click-sec.com/corp/news/info/2007050 …
No.1で回答されているようにシート毎の印刷設定が優先されます。（カラー印刷や白黒印刷などの設定も同様） シート毎の設定を無視して両面印刷をするのであれば、プリンタ側の設定で両面印刷を指定しましょう。 「コントロールパネル」から「デバイスとプリンタ」を選び、該当するプリンタの「印刷設定」で設定できるはずです。(プリンタの上で右クリック）
またまたお邪魔します。 ＞「Sheet1」のみです。 というコトは今までのコードは意味がないですね。 ↓のコードにしてみてください。 Sub Sample3() 'この行から// Dim k As Long, wS1 As Worksheet, wS2 As Worksheet, mySh As Worksheet Set wS1 = Worksheets("Sheet1") Application.ScreenUpdating = False If Worksheets.Count > 1 Then Application.DisplayAlerts = False For k = Worksheets.Count To 2 Step -1 Worksheets(k).Delete Next k End If Worksheets.Add after:=wS1 Set wS2 = Worksheets(2) wS1.Range("A:A").AdvancedFilter Action:=xlFilterCopy, copytorange:=wS2.Range("A1"), unique:=True For k = 2 To wS2.Cells(Rows.Count, "A").End(xlUp).Row Worksheets.Add after:=Worksheets(Worksheets.Count) Set mySh = Worksheets(Worksheets.Count) wS1.Range("A1").AutoFilter field:=1, Criteria1:=wS2.Cells(k, "A") wS1.Range("A1").CurrentRegion.SpecialCells(xlCellTypeVisible).Copy mySh.Range("A1") mySh.Name = wS2.Cells(k, "A") mySh.Columns.AutoFit Next k wS1.AutoFilterMode = False wS2.Delete Application.DisplayAlerts = True Application.ScreenUpdating = True wS1.Activate MsgBox "完了" End Sub 'この行まで// ※　一旦Sheet1以外のSheetを削除し、 新たにSheetを追加するようにしています。m(_ _)m
Excel 2011 for Macなど単体のインストールでなくOffice for Macをインストールしましたか？ 外部のHDDを接続したままではありませんか？ 他のアプリを終了してインストールしましたか？ 「アップル」 メニュー「強制終了」 言語が、Office for Mac の言語と一致していますか？ インストールしたOffice for Macをアンインストール、再起動、再インストール 削除して、Office 2011 for Mac を再インストールします。
別案です。フィルターオプションを使います。 その前に、データの入力ですが データのシート　 　A　　　B　　　　C　　　D 顧客名　担当者名　契約月　金額 ・・・ と必ず、一行目に項目名をいれて 2行目からデータを入力します。 別シートには 　　　A　　　　　　　B １　担当者名　　　　契約月 ２　やまだたいち　2015年10月 ３ ４　顧客名　　　　金額 ５ と準備します このシートの名前のタブを右クリック コードの表示をクリック VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$A$2" Or Target.Address = "$B$2" Then Sheets("データのシート名").Columns("A:B").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("A1:B2"), CopyToRange:=Range("A4:B4"), Unique:=False End If End Sub を張り付けて閉じます。 A2セルの　担当者名　Or B2セルの　契約月 を変更すると、その条件にあったっデータの一覧が表示されます。 フィルターオプションについては http://www.eurus.dti.ne.jp/~yoneyama/Excel/filte … などを参考に勉強してみてください。 保存する時は、マクロ付きのファイル形式で保存してください。
NO,1です。やはり関数が組み込まれたセルだったのですね。 仮に、隣の列（J列）にデータが下まで入っているのであれば オートフィルで一発で済みます。 K1～BY20　を選択 NY20の右下にマウスを移動させると　表示が　＋　になります。 その状態で　ダブルクリックすれば、J列のデータが入っている行まで 自動で、式がコピーされます。 詳しくは http://www.becoolusers.com/excel/autofill-wc.html のサイト名で調べてみてください。
No.1の回答者です。 別視点で探してみました。 http://www.tipsfound.com/VBA/07031.vbhtml これを応用することで簡易ですが可能みたいです。 指定列は2つしかありません。 範囲列などは必ず指定してください。 Public Function subtotal_countifs(rg1Select As Range, moji1 As String, rg2Select As Range, moji2 As String) 　Dim rg1, rg2 As Range 　Dim cot As Long 　Dim a, b As Long 　Dim i As Integer ' 行番号を取得 　a = rg1Select.Column 　b = rg2Select.Column 　i = b - a For Each rg1 In rg1Select ' 非表示セル 　If Rows(rg1.Row).Hidden = True Then 　　GoTo Continue 　End If ' 第一条件 　If rg1.Value <> moji1 Then 　　GoTo Continue 　End If ' 第二条件 　If rg1.Offset(0, i).Value <> moji2 Then 　　GoTo Continue 　End If 'カウンタ 　cot = cot + 1 Continue: Next 　subtotal_countifs = cot End Function 簡易版なので応用ができるか未確認ですが、一応使えます。
＞ST11に転記するにはどうしたら 画像に「値」とあるのでマクロか手作業なのでしょうか？ 列ごと値複写して、そのまま選択を変更せずに 「ジャンプ」-「セル選択」-「定数」-「エラー値」でOK →DELキー ではダメですか？
No.2です。 ＞下から５行目の「.Rows(1 & ":" & 6).Delete」が何を意味するのか教えて頂けませんか？ について・・・ 試しにその行を削除してマクロを実行してみてください。 1～6行目に不要な行があるため、最初の行を4行目に調整するためです。 ※　10行おき（場合によっては13行おき）と規則的に処理を行いたいため このようになってしまいました。 ※　＞For Each mySp In .Shapes　 の行から7～8行は不要かもしれませんが、 ①　Sheet4のデータを一旦すべて消去（画像も含む） ②　Sheet1～Sheet3で最大行を取得 以上の2点の処理を行っています。m(_ _)m
No.1です。 ＞最少行がRR以外でも可能なのでしょうか？ 実際に試してみてください。 どの列でもよいので、一旦最終行を取得する必要があります。 今回はRR列でとりあえず最終行を取得しています。 （最終行を取得しなければ、最小値は「0」になってしまいます） あとはワークシート関数のMIN関数ですので、RR列よりもデータ量が少ない場合、 変数「myMin」には最も行数の少ない列の行番号が格納されます。 ※　MAX関数の場合はすぐにループに入っても問題ありません。m(_ _)m
No.1 です。 > 結果の数字の意味は理解できたのですが、この数字は何を意味しているのでしょうか…？ > t値ですか？それともこれは0.1％水準で有意ですよ、ということを示しているのですか？ 下記URLのページの「Excelの関数で算出するｔ検定」の項に、次のように書かれていますので、帰無仮説が棄却できる確率(p値)のようです。 『 ttest関数は検定結果として帰無仮説が棄却できる確率（p値）を算出する』 「平均値の検定」 http://www.aoni.waseda.jp/abek/document/t-test.h … ご参考 「T.TEST関数／TTEST関数でt検定を行う」 https://dekiru.net/article/4597/ 「対応のある場合のｔ検定…例題・問題」 http://www.geisya.or.jp/~mwm48961/statistics/tte …
こんにちは！ Sheet1のデータをSheet2に集計するとします。 一例です。 ↓の画像のように作業列を設けてみてはどうでしょうか？ 画像ではSheet1のG2セルに =IF(COUNTIF(B$2:B2,B2)=1,1000+COUNTIF(B:B,"<"&B2)+COUNTIF(B$2:B2,B2),"") H2セルに =IF(COUNTIF(D$2:D2,D2)=1,3000+COUNTIF(D:D,"<"&D2)+COUNTIF(D$2:D2,D2),"") という数式を入れ　G2・H2セルを範囲指定　→　H2セルのフィルハンドルでこれ以上データは増えない！という句依頼まで下へコピー！ そしてSheet２のA2セルに =IFERROR(INDEX(Sheet1!B:D,SUMPRODUCT((Sheet1!G$1:H$1000=SMALL(Sheet1!G$1:H$1000,ROW(A1)))*ROW(A$1:A$1000)),INT(SMALL(Sheet1!G:H,ROW(A1))/1000)),"") B2セルに =IF(A2="","",SUMIF(Sheet1!B:D,A2,Sheet1!C:E)) という数式を入れ、A2・B2セルを範囲指定　→　B2セルのフィルハンドルで下へコピーすると 画像のような感じになります。m(_ _)m
こんなんでもいいかも B8セルに =CHOOSE(COLUMN()-1,$B$7,$C$6,$D$5,$E$4,$F$3) とか =INDEX(B:B,9-COLUMN()) 右へオートフィル
＞・2015/10/1801 （01は任意で付番しています） の意味が分からないので、見なかったことにする。 セルの表示形式で yyyymmddhhmm とすればよい。 そうすれば 20151018112 になる。 他のセルに表示させるのであれば、No.1の回答のようにTEXT関数でこの表示形式を指定するのもありだろう。
失礼しました。 =MATCH(O1,O12:O1000,1)+11-7 は =MATCH(N1,O12:O1000,1)+11-7 でした。
参考例です。 Private Sub Worksheet_Change(ByVal Target As Range) If Application.Intersect(Target, Range("A1:A10")) Is Nothing Then Exit Sub If Target.Value = 0 Then MsgBox "０ですよ" End Sub
失礼しました。 不等号のダブルクォーテーションの書き方を誤った回答でした。 申し訳ありません。
計算の種類がデフォルトの『個数』のままのようですので、変更しましょう。 ＜やり方＞ 添付画像の左側のように、ピボットテーブルの設定画面のΣ値の下に『データの個数』と表示されているはずです。 画像中央のように、『データの個数』の部分をクリックして『値フィールドの設定』を選びます。 画像の右側の画面がでるので、表示したい形式を選択してOKをクリックします。 当方、EXCEL2007なので、ピボットテーブルの設定画面が微妙に違うかもしれません。 質問の意図を理解するのが難しかったですね。
画像が小さく読み解く気にならなかったですがなんとか。 二分探索案 F1セル0 F2セル =SUM(IF(B2>1,0,COUNTIF(A:A,A2)>1),INDEX(F:F,ROW()-1)) 下へオートフィル ただし、参加者データに重複なきこと。 H2セルに =IF(LOOKUP(8^8,F:F)<ROW()-1,"",ROW()-1) 下へオートフィル I2セルに =IF(H2="","",INDEX(A:A,MATCH($H2-1,$F:$F)+1)) 右へ、下へオートフィル H:M列を切り取ってSheet2へ貼り付け 参加者が多く計算速度が遅いようなら検討してみてください
No.2です。連投ですみません。 直接コードを書きましたが、実行方法わかりますかね？ 一応、操作の一例を書いておきます。 ①VBEを起動（Excel開いた状態で、Alt＋F11で開くかと思います） ②メニューの「挿入」→「標準モジュール」を選択 ③開いた画面に、No.2の回答に記載したコードをコピペ 　（Sub createMergeFile()　～　End Sub　まで） 　※「C:\work\」の部分を実際に作業するフォルダパスに変更しておく！ ④Excelの画面に戻って、マクロの選択画面を表示　（Alt＋F8？） ⑤「createMergeFile」を選択して、「実行」ボタン押下 以上です。 ＜注意点＞ ※上記⑤で即実行されますので、念のため参照するファイル（東京の水　等）はバックアップとっておいてから実行してください（＾＾； ※上記③でのフォルダのパスの最後には必ず「\」が入れてくださいね ※元ファイルの拡張子は「xlsx」を想定してます。違ってたら「Const FileExt As String = ".xlsx"」の部分を変更してください。
前半の疑問 はい、その通り。短いコードなのでヘルプなども参考にして追って行ってください。 後半の疑問 >現在はM1から貼り付け（コピー）が開始されるのですが、A1から貼り付けを行うには 適当なファイルで提示したを試しましたが、 「連結」シートのA1から始まりましたけど？ 意味を取り違えてしまっているかもしれないので、 こちらでも再現できる、 なるべく単純な例、 を示せますか。
COUNTIFS関数で検索条件範囲が複数ある場合は、検索条件範囲の列数を合わせる必要があります。 =COUNTIFS(V11:W15,1,Y11:AA15,2) 検索条件範囲1【２列】_検索条件範囲2【３列】 これだと、エラーになります。（添付画像左上の例） =COUNTIFS(V11:W15,1,Y11:Z15,2) 添付画像下部の2つのデータにはこの関数が入っています。
A1セル =RAND() B1セル =IF(A1<0.5,"A",IF(A1<0.8,"B",IF(A1<0.9,"C",IF(A1<0.95,"D","E")))) とすれば、B1セルにA～Eが表示されます。 値の更新はF9キーです。 いかがでしょうか？ ちなみに、添付のC～G列は10000行まで式を入れて集計した結果です。じゅうぶんにランダムといえると思います。
管理者がいるなら、その管理者に丸投げでよいような気がするのだが。 InternetExplorerのバージョンが不明で最新なのか分からないのでは話にならない。 インターネット一時ファイルを削除しても古いバージョンしか表示されないのであれば Webページの作りがそうなっているのだろう。 この場合問題なのは、現在使用しているパソコンのシステム。 イントラネット内なら管理者の指示に従うのが鉄則だ。
＞税金計算は結果を百円未満切捨てします。税法で決められています。 ●承知しています。 ＞よって１９８，９９７→１９８,９００となるのです。 万能だと思っていたエクセルでもこの計算ができないということがよくわかりました。 ●いえ、だからそれでいいのでしょ？ ＃７の回答の訂正　26,533×7.5＝198,997　→　198,900（百円以下切り捨て） いっていること分かりますか？ つまり、一発で計算しちゃダメです。 318,400÷12=26,533（少数以下切り捨て）　で　個別計算結果を出す。 エクセルではこの中間値をセルを設けてそこに収録します。 次にそのセルに対して7.5倍して百円以下切り捨てればいいのです。 どうしても中間値をセルに設けたくないのであれば、 rounddown(rounddown(○/12,0)*7.5,-2) ・・・・・＃４の回答と同じ
他の方が仰るように、リボン　挿入　から 図形　四角　をいくつか配置します。 ところで、仮に 右上に　捺印枠　を配置したとして 捺印枠なしを印刷したら、空白が増えると思います。 全く、同じ金額などになるようなシートを（或いは　同じシートの左右に）2枚準備 取引先提出用、片方には、捺印枠有にして社内確認用にします。 上司に確認してもらうときには、2枚印刷して確認してもらいます。 片方を社内保管用にでもします。
この場合エラーをそのままにするよりも ＃DIV/0! のエラーを解決する方が先と思います。 ゼロで割るという破綻したアルゴリズムということは何か間違いを犯していると考えられませんか。 エラーをそのまま表示するならエラーのあるセルをそのまま参照すればいいです。 =RW106 ISERROR関数またはISERR関数で対象がエラーであるかをチェックできます。 ＝ISERROR(RW106) 対象がエラーならTRUEが返るので、IF関数の条件に使用できる関数です。
こんにちは！ セルの表示形式の方法はNo.1さんが回答済みですので、 仮にA2セル以降にシリアル値が入る場合、B2セルに =TEXT(A2,"aaa") としフィルハンドルで下へコピーしてみてください。 ※　「月曜日」のように曜日まで表示したい場合は =TEXT(A2,"aaaa") のように「a」を4つ並べます。 （セルの表示形式でも同様です）m(_ _)m
表を組み替える必要がありますが、ピボットテーブルが分析に使えます ピボットテーブルでその家の月ごとの平均をだし、その計算結果を持ってくることもできます また、全体的な月ごとの平均をだしたのち、係数を算出しても良いのかも。 その場合、ガスの冷暖房の有無は別にしたほうが良さそうです。 いずれにせよ、予測の仕方を決めるのは会社です。 当方のような自宅のデータしか知らないような回答者では、自宅のものしか予測できません。 よって、上司に相談するのが良いと思います。 データから、このような予測方法が良いのではないかと提案しても良いと思います。 そのときに、ピボットテーブルが役立つわけですが、、、。 添付図参照(黄色部分は数式を入力する) 現在の表なら2007以降の条件付き書式でグラフっぽくすることで傾向と対策がつかめるかもしれませんね (もちろん、単位は書式設定で付け、数値にしておく必要があります)
・セルの書式設定で表示形式をパーセント表記にする ・リボンの中にある％のアイコンをクリックする
E3セルに、=MAX(A3,C3) F3セルに、=MIN(B3,D3)
エクセル単体でも、コピー＆貼り付け（図）にしてしまえば出来ると思います。 適当なセルに　あいう　と入力、コピー 貼り付けで、ウィザードの下段にある　図　を選択 張り付けてできた図を縦長（横長）にする
こんばんは！ VBAになりますが一例です。 データは2行目以降にあるとします。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long, k As Long, cnt As Long Dim myCnt As Long, myRng As Range For i = 2 To Cells(Rows.Count, "A").End(xlUp).Row - 1 If WorksheetFunction.CountIf(Range(Cells(2, "A"), Cells(i, "A")), Cells(i, "A")) = 1 Then myCnt = WorksheetFunction.CountIf(Range("A:A"), Cells(i, "A")) If myCnt >= 2 Then If myRng Is Nothing Then Set myRng = Cells(i, "A") Else Set myRng = Union(myRng, Cells(i, "A")) End If cnt = 1 For k = i + 1 To Cells(Rows.Count, "A").End(xlUp).Row If Cells(k, "A") = Cells(i, "A") Then cnt = cnt + 1 If cnt = myCnt Then Exit For Set myRng = Union(myRng, Cells(k, "A")) End If Next k End If End If Next i If Not myRng Is Nothing Then myRng.EntireRow.Hidden = True End If End Sub 'この行まで// ※　尚、再表示のコードも必要かと思いますので、↓の3行のコードを同じ画面に追加し 再表示したいときはこちらのマクロを実行してください。 Sub 再表示() ActiveSheet.Rows.Hidden = False End Sub こんな感じではどうでしょうか？m(_ _)m
できません。
少しでも、検索のウィザードを簡単に表示したいと云う事ですよね Excel2010に上部分に　クイックアクセスツールバーがあると思いますので そこに、検索　を登録しては如何でしょうか。
Excelのバージョンはなんでしょう？ いずれにせよ、No.1の添付図ではH4セルのみ選択していますが、そのH4セルを選択した状態で「並び替え」ボタンをクリックするだけだと思います。 あと、「フィルタをかける」とは、抽出することであり、並べ替えと別にお考えください。
No.1です。 この場をお借りして・・・ No.2のmike_gさんへ！ 画面を拡大してもやはり限度があります。 ほとんど憶測で回答しています。 （そのため、的外れの回答も多々あるかもしれません） 今回の場合、ある程度の予測ができたので自分なりに表を作成して回答しただけです。 もちろんいくら拡大しても判らないものは判らないので 回答は控えるようにしています。 ※　的外れの回答でも質問者様が補足していただければ ある程度お役に立てるコトがあるかもしれませんので・・・m(_ _)m
こんばんは。 >ログインが必要なサイトのデータを取り込みたく、 ということは、ログイン自体は、WebBrowserの中で行うという意味でしょうか。 正直、そういうスタイルの方式ではやったことはありません。 試しにやってサンプルを作ってみました。 このページのタイトルを取るものです。 決まったスタイルというものはありませんが、.getElementsbyClassName("q_article_info clearfix")　などは、自分で探して持ってこなければなりません。この場合、私は、FireFox の　'FireBug' を使います。InternetExplorer にも、強力なツールが標準でついていますが、これは好きずきです。 むろん、WebBrowser1.Document の時点で、全部、 WebBrowser1.Document.Body.InnerText　として内容をダウンロードさせてしまうという方法もないとは言えません。必要な情報を、「正規表現」で抜き取るのが一番楽です。「正規表現」は、お好きなツールを使えばよいのですが、VBAでは、標準的に、VBScript.RegExp と呼び出して使います。 '//UserForm, WebBrowser, CommandButton Private Sub UserForm_Initialize() 'アクセスの方法は、いろいろありますから、これだけではありません。 　Const URL As String = "http://oshiete.goo.ne.jp/qa/9099834.html" 　UserForm1.WebBrowser1.Navigate2 URL End Sub Private Sub CommandButton1_Click() 　Dim objHTML As Object　'←実際に、HTMLfile オブジェクトでした 　Set objHTML = WebBrowser1.Document 　With objHTML 　　Dim q_a_a 　　Dim sTitle As String 　　Set q_a_a = .getElementsbyClassName("q_article_info clearfix")　'←マニュアルで探す 　　If q_a_a.Length >= 0 Then sTitle = q_a_a(0).ChildNodes.Item(3).innerText 　　End If 　End With 　If Len(sTitle) > 0 Then 　　MsgBox "タイトル: " & sTitle 　End If End Sub '///
>しかし、肝心の合計金額が表示されません。 > 集計作業は綺麗に並んでいました。 いや合計も出ると思いますが、一般的には ピボットテーブルは 集計、分析のツール、ピボットグラフとの連携が出来る。 オートフィルター、フィルターオプション、Vlookup関数などが 抽出のためのツールと分類されると思います。
補足を拝見しました。そうですね、IDが一個もなくても、頭の部分の転記はせねばならないんですね。 以下でどうでしょう。IDの有無を判別するIf文を追記して若干アレンジしました。 私の手元のダミーデータでは正常稼働しました。 これで行けてるかなあ？なにかありましたらまたどうぞ。 '--------------------------------------------------------------------- Option Explicit Sub Tenki3() '変数宣言とセット Dim Ws1 As Worksheet, Ws2 As Worksheet Dim r As Long, c As Long Dim Heada As Range, Rng As Range, Cnt As Integer Dim TgtRow As Long Set Ws1 = Worksheets(1) Set Ws2 = Worksheets(2) '前回結果（Sheet2）をクリア Ws2.Select Set Rng = Ws2.Cells(1, 1).CurrentRegion If Rng.Rows.Count > 1 Then 'まだクリアされてないなら 　Set Rng = Rng.Offset(1, 0).Resize(Rng.Rows.Count - 1, Rng.Columns.Count) 'Sheet2の見出し行を除く範囲をRngにセット 　Rng.ClearContents End If Application.ScreenUpdating = False 'Sheet1を縦にループ r = 2 With Ws1 　Do While .Cells(r, 1).Value <> "" 　　Set Heada = .Range(.Cells(r, 1), .Cells(r, 11)) 'ヘッダ（A～K列）をHeadaに格納 　　Cnt = Application.WorksheetFunction.CountA(.Range(.Cells(r, 12), .Cells(r, 91))) '当該行L～CM列、空白でないセルの個数 　　If Cnt = 0 Then 'ひとつもIDが入ってないなら 　　　　TgtRow = Ws2.Cells(Rows.Count, 1).End(xlUp).Row + 1 　　　　Heada.Copy Ws2.Cells(TgtRow, 1) 'ヘッダをSheet2の最終行にコピペ 　　ElseIf Cnt > 0 Then '一つ以上IDがあるなら 　　　　For c = 12 To 88 Step 4 'L～CJ列を4つおきにループ 　　　　　　If .Cells(r, c).Value <> "" Then 'IDがあるなら 　　　　　　　　TgtRow = Ws2.Cells(Rows.Count, 1).End(xlUp).Row + 1 　　　　　　　　Heada.Copy Ws2.Cells(TgtRow, 1) 'ヘッダをSheet2最終行A列にコピペし、 　　　　　　　　Set Rng = .Range(.Cells(r, c), .Cells(r, c + 3)) 　　　　　　　　Rng.Copy Ws2.Cells(TgtRow, 12) '大中小分類をSheet2最終行L列にコピペ 　　　　　　End If 　　　　Next c 　　End If 　　r = r + 1 　Loop End With Application.ScreenUpdating = True MsgBox "Completed." End Sub ’----------------------------------------------------------------- それぞれのステートメントにコメントを振りましたので、お分かり頂けると思いますが、メンテの際について。 ＞項目数やIDの詳細数が変わる可能性があるので、その際気を付ける変更場所 ・項目数 　上のコード内では「ヘッダ」と呼んでいる箇所。A～K列の部分をいじってください。 　変数Heada のところとか。 　それに伴い、Sheet2のL列からデータを貼っていますので、そこに該当する部分も。 ・IDの詳細数 　L～CJ列のループを入れているところとか、変数Rngに格納する部分をいじる必要が出てきます。 上記のようにコードの修正をするときや、エラーが出た時、想定外の挙動を見せた時など、一段階ずつコードを 実行させながら動きを確認していくことも有効です。 ステップ実行と呼ばれるものですが、コード内にカーソルを置き、F8キーを押していくと、一段階ずつ進んでいきます。 あわせて、VBE画面の「表示(V)」＞「ローカルウィンドウ(S)」も表示させて、併用すると、各変数が どのような動きをしているかも見られます。 ------------------------------------------------------------------- 行列両方向のループについて このように縦横両方向へのループはかなり高い頻度で使用されます。 今回の例でいえば、Sheet1の元データを2行目から下方向へ見ていく。 んでもって、各行において、ID1～ID20まで右方向へ見ていく。 ループ回数が決まっているとすれば、縦横ループは以下の形がまずは基本。 例） Dim r As Integer,c As Integer For r=1 to 10 　For c=1 to 10 　　Cells(r,c).Value=r*c 　Next c Next r 今回は縦方向のデータ数が不定なので、縦のループは、Do Loopを使いました。 このように、縦方向のデータ数不定、でも、右方向の項目数は固定、というのは最も多いパターンです。 したがって、Do Loop と、For Next との使い分けも意識してみてください。 また、それぞれのループを内側に置くか、外側に置くかで結果が変わることもありますので いろいろ研究してみましょう。 ※なお、縦（下）方向のカウンタは行（Row)という意味で r 、 列（右）方向のカウンタは列（Column)という意味で c と置くのが、わたしは好きですが、 決まりではありませんので誤解なさらぬよう。
> ただし、文字の入力はしたいんです。 質問者も回答者も時間がもったいないからはじめに書こうね。 IF文で該当セルが数値の場合と、該当セルが文字の場合の処理を書き分ければいいと思うよ。 Excelシートがどうなってて何が目的のシートが分からないけど。
条件付き書式設定画面を開きます。 Ver2003などでは、条件の箇所を「数式」にします。 Ver2013ではルールの種類を「数式を使用して、書式設定するセルを決定」を選びます。 B1セルに次のように入力します。 =AND((COLUMN()-1)<=$A$1,$A$1<=10) $A$1 絶対参照にします。 色を決めたら完了です。 B1セルをコピーして、C1からK1に貼り付けます。 これでOKです。
ほとんど数式(^^; Sub Sheet2へ転記する() Application.ScreenUpdating = False 　 Dim 最終行 As Long 　 最終行 = Worksheets("Sheet1").Range("A" & Rows.Count).End(xlUp).Row 　 Worksheets("Sheet2").Range("A:B").ClearContents 　 With Worksheets("Sheet2").Range("A2:A" & 最終行 * 6 - 6) 　 　 .FormulaR1C1 = "=IF(MOD(ROW(),6)=1,"""",INDEX(Sheet1!R1,MOD(ROW()-2,6)+1))" 　 　.Value = .Value 　 　.Offset(, 1).FormulaR1C1 = _ 　 　 "=IF(RC[-1]="""","""",INDEX(Sheet1!C[-1]:C[3],(ROW()-2)/6+2,MOD(ROW()-2,6)+1))" 　 　 .Offset(, 1).Value = .Offset(, 1).Value 　 End With Application.ScreenUpdating = True End Sub
No.2です。 補足のサイトのコードを拝見しました。 確認です。 ① ＞For i = 2 To Cells(Rows.Count, "A").End(xlUp).Row が ＞For i = 5 To Cells(Rows.Count, "A").End(xlUp).Row となっているので、A5セル以降A列の最終行までで良いのですね？ （1行目～4行目は何もしません） ② ＞For j = 2 To 8 が ＞For j = 5 To 29 というコトは、E列～AC列までとなりますが、 これもよいのですね？ （A～D列・AD列以降は無視） ①・②で間違いないのであれば その範囲内で「25％灰色」のセルが一つでもあればその行は非表示になるはずです。 ※　それでも反応がない場合、考えられる原因としては 「灰色」が「25％灰色」ではなく「他の灰色」になっている可能性があります。 試しに灰色に塗りつぶされているセルを一つ選択し↓の3行のマクロを実行してみてください。 Sub カラーインデックス確認() MsgBox Selection.Interior.ColorIndex End Sub 灰色のカラーインデックス番号が表示されるはずですので「15」でない場合は ＞If Cells(i, j).DisplayFormat.Interior.ColorIndex = 15 Then の「15」の部分を実際のカラーインデックス番号に変更しマクロを実行してみてください。 とりあえずはこの程度で・・・m(_ _)m
No.1です、再度のお礼ありがとうございます。 ＞１点目 ＞判定部分のH３には　＃N/A　のエラーが表示される場合がありその場合にも、データありの判定をしたい。 エラー値の場合、エラーが発生してしまうということですね。 一応確認したいのですが、エラー表示の際にデータありの判定をしたいとのことですが、 エラー値であればデータが入っている時と同じくコピーや貼り付け、位置の更新は行うということでよろしいでしょうか。 エラー値であってもコピーや貼り付けを行う場合、 g3 = Range("HF" & g1).Valueの前に空白の判定、エラー値かどうかの判定を行う処理を追加することで可能です。 空白を判定する場合にはIsEmptyというものを使用し、 エラー値かどうかを判定する場合には、IsErrorというものを使用します。 (空白判定を行わずエラー値の判定のみを行うと、空白を受け付けなくなってしまうため) 処理の流れとしては、最初にデータがあるかどうかの判定を行い、 データが入っていればエラー値の判定を行うという流れになります。 そしてエラー値の場合、g3 = Range("HF" & g1).Valueをするとエラーになるため、 g3に強制的に値を代入し、後のデータがあるかどうかの判定を回避する処理にします。 コードとしては、g3 = Range("HF" & g1).Valueの部分を下記に変更すると処理ができます。 ---------- 'コピー場所のデータが空白かどうか判定 If Not IsEmpty(Range("HF" & g1)) Then 'データあり、エラー値かどうか判定 If IsError(Range("HF" & g1)) Then 'エラー値のため、g3に値を強制的に代入 g3 = "あ" Else 'エラー値ではないため、セルの値を代入 g3 = Range("HF" & g1).Value End If End If ---------- エラー値の場合にはコピーや貼り付けを行わない場合だとちょっと処理が変わりますので、 お礼や補足で追加していただければと思います。 ＞２点目 ＞恣意的に変数をリセットし、再度　HF3～HH11　の部分からやり直したい場合 こちらに関しましては、リセットするためのボタンをもう1つ追加し、新しいマクロを作成するのが良いでしょう。 処理としては、リセットボタンを押すとg1、g2、g_flgをリセットする、といった流れです。 コピーの解除やメッセージボックスが必要なければ、下2行は削っていただければと思います。 下記コードをボタン17_Clickの下に追加することで処理は可能です。 ---------- Sub ボタン2_Click() '位置情報、フラグを初期化、コピーを解除しメッセージボックスを表示 g1 = 0 g2 = 0 g_flg = 0 Application.CutCopyMode = False MsgBox "リセットします。" End Sub ----------
> B3～H３の幅で、C列の最終行を基準に全選択したいのです。 下記のように操作してみてください。 1. C列のデータのある任意のセルを選択して、[Ctrl]キーを押しながら[↓]キーを押すと、C列の最終行がアクティブになります。 2. [←]キーを１回押して、B列に移動した後、「名前ボックス」に「H3」と入力して、[Shift]キーを押しながら [Enter]キーを押すか、 または、 [Shift]キーを押しながら、マウスで「H3」セルをクリックすると、ご希望の範囲が選択されます。
ボタンはマクロを登録しないと使えないので、ボタン使用ならマクロ必須になります。 オプションボタンとかでは駄目でしょうか？ ○男性 ●女性 などと使用してもいいですし、他のセルに結果を表示させたいならリンクするセルを作ってその結果で表示を変える事ができます。 （好みですがActivexコントロールよりフォームのオプションボタンの方が使いやすいと思います。） http://www.kenzo30.com/ex_kisotoku/ex_ks_tokubet …
変数の型 Single 単精度浮動小数点数型 og = Range("L15").Value L15の値が文字列などの場合、エラーになります。 型の指定を省略して、Variant型にしてみます。 Sub Worksheet_Calculate() Dim og1 As Single Dim og2 As Single Dim og3 og1 = Rnd() * -1 og2 = Rnd() * 10000 og3 = "あ" MsgBox og1 & vbCrLf & og2 & vbCrLf & og3 End Sub
こんばんは！ Sub Sample1() Dim k As Long, myAry As Variant With ActiveSheet If .Range("A1") = "" Then If .Range("B1") = "りんご" Or .Range("B1") = "ぶどう" Then myAry = Array("あ", "い", "う") Else myAry = Array("あ", "い", "う", "え", "お") End If Else myAry = Array("あ", "い", "か", "き", "く") End If For k = 0 To UBound(myAry) Worksheets(myAry(k)).PrintPreview '★ Next k End With End Sub ※　プリントアウトせず「印刷プレビュー」で止めています。 こんな感じでよいのでしょうか？m(_ _)m
確実な方法は、Shiftキーを押しながらグラフを選択しコピー その後別のシートなりブックに貼り付けてください。 選択時、グラフエリアに隅にある黒い四角ではなく、白丸になっていればOKです。 添付の画像はネットで拾ったものですが、Excel2003まではこの選択方法でグラフの大きさや書式は維持されたかと思います。
編集不可と数式非表示はできますが、編集不可はつまりフィルコピーも不可能ということです。 だって、セルの内容が変わっていくということでしょ？ >B列以降の数式を選択 の部分がよくわからないのですが、先に数式をいれておくことはできないのですか？ どうせ見えなくするんですよね。 A列が空白なら空白、入力があれば数式とかをIFで作るとかにしておけばいいのでは？ ちなみに、編集不可はシートの保護でできます。 編集「したい」セルを選択して、右クリック→保護タブ→ロックのチェックを外す→OK その後 校閲タブ→シートの保護→（パスワードが必要なら入力して）→OK これで、ロックを外したセル以外は編集できません。 数式を表示したくないセルは、 該当セル選択→右クリック→保護タブ→表示しないにチェックを入れる→OK 校閲タブでシートの保護をすれば数式バーには何も表示されなくなります。
二つ目のデータで =(B1&A1)*1 表示形式でお好きな表示に変更では如何でしょうか？
置換で >を>123456789-に置換 <を>に置換 >123456789-を<に置換 これで無理ですかね？
添付図参照 セル B2 に検索条件式 =MOD(DAY(A2),5)=0 を入力して、列Ａをリスト範囲、範囲 B1:B2 を検索条件範囲、セル C1 を抽出範囲、とする[フィルタオプションの設定]でイッパツで「5の倍数の日だけ抽出」できます。
解決されたようですが、以下の様なものはどうでしょう A 列の = 処理後、何らかの修正/追加等があった場合 再度の実行で振り直す （ = 後の半角数字は読み飛ばしながら採番しなおす･･･） Public Sub Samp1() 　　Dim vA As Variant 　　Dim sS As String 　　Dim i As Long, j As Long, k As Long, n As Long 　　With Range("A2", Cells(Rows.Count, "A").End(xlUp)) 　　　　vA = .Value 　　　　n = 1 　　　　For i = 1 To UBound(vA) 　　　　　　sS = "" 　　　　　　j = 1 　　　　　　While (j <= Len(vA(i, 1))) 　　　　　　　　k = InStr(j, vA(i, 1), "=", vbTextCompare) 　　　　　　　　If (k > 0) Then 　　　　　　　　　　sS = sS & Mid(vA(i, 1), j, k - j + 1) & n 　　　　　　　　　　n = n + 1 　　　　　　　　　　j = k + 1 　　　　　　　　　　While (Mid(vA(i, 1), j, 1) Like "[0-9]") 　　　　　　　　　　　　j = j + 1 　　　　　　　　　　Wend 　　　　　　　　Else 　　　　　　　　　　sS = sS & Mid(vA(i, 1), j) 　　　　　　　　　　j = Len(vA(i, 1)) + 1 　　　　　　　　End If 　　　　　　Wend 　　　　　　vA(i, 1) = sS 　　　　Next 　　　　.Offset(, 1).Value = vA 　　End With End Sub ※ >　　　　.Offset(, 1).Value = vA 現状、結果を B 列に書き出していますが、 上書きで良ければ、 .Value = vA　に変更してみてください
A1を選択してコピー A2を選択し、右クリックして表示されたメニューの「形式を選択して貼り付け」(「書式」だったかな？) で、「数」だけをチェックし他はチェックを外して実行。 これでA1の計算結果の値がA2にコピーされます。
関数で、少し説明付き。(計算速度の速い二分探索にすることも可能ですが、初心者ということでわかりやすい線形探索で) 1. H1セルに 「条件」 2. H2セルに 　=SUM(F2>0,INDEX(H:H,ROW()-1)) 　下へオートフィル ○条件が一致した場合に、一つ上のセルに加算する ○INDEX関数やROW関数を使っているのは並べ替えに対応するため ○and条件やor条件が発生した場合、AND関数やOR関数で対応できる 3.Sheet2!A1セルに 連番 4.Sheet2!A2セルより下へ1から連番を入力する 5.Sheet2!B2セルに 　=IF(MAX(Sheet1!H:H)<A2,"",MATCH(A2,Sheet1!H:H,0)) 　下へオートフィル ○上から順次検索して、見つかった行を返す ○不要な検索はしないよう処理 6.Sheet2!C2セルに 　=IF($B2="","",INDEX(Sheet1!A:A,$B2)) 　右へ、下へオートフィル ○目的の値を持ってくる(Sheet2!J列は参考まで) 作業列を使わないで行うこともできますが、理解できないと思うのでパス
あまりお勧めはしませんが =SUM((F5:L5)-(F4:L4)) としてCtrl+Shift+Enterで確定。
No1の方が言われている条件付き書式を利用します。 ① D２のセルでの設定例です。D2を選択して条件付き書式の新しいルールをクリックして「数式を利用して書式設定するセルを決定」をクリック。 ② 入力ボックスに「=A2<>””」と入力して、書式ボタンで文字の色を決定してOK。（カギカッコはなしで） 続けて①に戻り②で入力する式を「=B2<>””」と入力して文字の色を決定 さらに①に戻り②で入力する式を「=C2<>””」と入力して文字の色を決定。 これを↓フィルコピーします ③ A列を選択して条件付き書式の新しいルールをクリックして「数式を利用して書式設定するセルを決定」をクリック。 ④ 「指定の値を含むセルだけを書式設定」をクリックしてA列に入力されるべき範囲を下段にある入力ボックスに入力して色を決定しOK。 B列C列もそれぞれ③→④を設定すればできると思いますよ。
こんばんは！ 一例です。 ↓の画像のようにK列は使わずにやってみました。 一つだけ大切なコトがあります。 順位のJ列を単純にRANK関数でやってしまうと同順位があった場合にちゃんと表示されないと思いますので、 J列の数式から手を加えます。 J3セルに =IF(I3="","",COUNTIF(I:I,">"&I3)+COUNTIF(I$3:I3,I3)) という数式を入れフィルハンドルでこれ以上データはない！というくらいまで下へコピーしておきます。 （これで同順位であっても上側の行の順位が上位になります） C3セルに =INDEX(G$1:G$100,MATCH($B3,$J:$J,0)) という数式を入れ列・行方向にフィル＆コピー！ これで「全体ベスト5」は完了です。 次に、「a」「b」「c」を含むものに関しては 画像のようにセルに検索したい文字を入力しその文字が含まれるデータを表示するようにしてみました。 「a」の場合のベスト5はC12セルに =IFERROR(INDEX(G$1:G$100,MATCH(SMALL(IF(ISNUMBER(FIND($B$10,$G$1:$G$100)),$J$1:$J$100),ROW(A1)),$J$1:$J$100,0)),"") 配列数式ですので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　C12セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 C12セルのフィルハンドルで列・行方向にフィル＆コピー！ これで「a」を含むベスト5は完了です。 このままでB10セルのデータを入れ替えるだけで好みのベスト5が表示されるはずですが、 どうしても他のデータも同様に表示させたい場合は C12セルを選択　→　数式バー内の数式をドラッグ＆コピー　→　Escキー　→　C20セルを選択　→　数式バー内に貼り付け →　表示されている数式の　FIND($B$10)　を　FIND($B$18) に変更し =IFERROR(INDEX(G$1:G$100,MATCH(SMALL(IF(ISNUMBER(FIND($B$18,$G$1:$G$100)),$J$1:$J$100),ROW(A1)),$J$1:$J$100,0)),"") という数式にし、Ctrl＋Shift＋Enterで確定！ そして列・行方向にフィル＆コピー！ C28セルも同様の操作で =IFERROR(INDEX(G$1:G$100,MATCH(SMALL(IF(ISNUMBER(FIND($B$26,$G$1:$G$100)),$J$1:$J$100),ROW(A1)),$J$1:$J$100,0)),"") という数式に変え、配列数式　→　列・行方向にフィル＆コピー！ これで画像のような感じになります。m(_ _)m
こんにちは！ 一例です。 ↓の画像のように表を作成しておくのが判りやすいと思います。 画像ではD2セルに =10000+IF(B2>120,(B2-120)*C2) という数式を入れフィルハンドルでD5セルまでコピー！ 最後に合計欄のD6セルは =SUM(D2:D5) としています。m(_ _)m
N列に発着時間の差分を入れたいのは分かるのですが，どういうアウトプットが良いのでしょう？ カンマで区切っているということは，例えばF列の差分，H列の差分，J列の差分，L列の18:30と18:52の差分がカンマ区切りで一様に表すことができるという事で宜しいですか？ アウトプットイメージを入れて，そのアウトプットになる数式を下に書きます． アウトプットイメージ F差分,H差分,J差分,L差分（全て分単位） 数式 =ROUND((F5-F4)*60*24,0)&","&ROUND((H5-H4)*60*24,0)&","&ROUND((J5-J4)*60*24,0)&","&ROUND((L5-L4)*60*24,0) アウトプットイメージ F差分,H差分,J差分,L差分の合計値 数式 =F5-F4+H5-H4+J5-J4+L5-L4
If(A<B,"",A-B) (AやBは計算に使うセル、A2とかB4とか) これで、計算結果がマイナスの時は何も表示されなくなります
補足を拝見しました。 Do While の行ですが、ご認識は違います。 Do While は、〜している間はループし続けろという構文ですから、 ここでは、シート1のA列が空白でない間はループし続けろ、 つまり、データがなくなるまで処理せよ、という文です。 今回は配達先の増減がある、つまり、何人分かは不定ですから、 Do While 〜 Loopで回しています。 もし、配達先が20人で固定なのであれば、 For r=2 To 21 などのように、For Next で回せばよいですが。 で、Do Loop の場合は、For Nextのようにカウンタの初期値や、 増加は勝手にしませんから、2行めから処理を開始ということで、 ループ開始前に、r=2 で初期値を与え、最後のLoop の前に、 r=r+1 として、カウンタを増加させています。 1行目は見出し、データは2行めから開始という認識で組んだ コードですが、A列（配達先）において、途中で空白セルは 存在するのでしょうか。 それは想定していませんでした。A列は2行めから最後まで空白無しを 前提としています。 A2セルが空白ということは、1行めが見出しとして、いきなり空白？ ならばコードは変わります。 最初に、シート1の最終行を取って、For r=2 To 最終行 〜Next で回すとか。 >シート2に結果を出すときA3から TgtRow を取得する時にIf分岐をかまして、TgtRow <3 なら、TgtRow=3 としとけば 良いと思います。 で、Else それ以外なら今の取得方法。 >配達0回の人も表示 これは、CからAGの合計が>0なら、というIf文を外せばよいでしょう。 今回のコードは良く見ていただくと分かると思いますが、 この作業を、人間が手作業でやった時の動きをコードにした だけのものてす。 特に複雑なロジックは無いと思います。 データの始まりから順に下に見ていく。データの終わりまで。 これがDo Loop。 2行めから1行づつ見て、配達回数（CからAGの合計）が、一回以上ならシート2に名前を転記。 （書いてませんけど、配達回数がゼロならスルー） これが、If 文のところ。 転記する先は、シート2で、今データが入っている最終行の次に なるわけですから、これの取得が、TgtRow。 データの転記については、回数があるセルだけ、日付と回数を、 シート2の該当行に、左詰めで書いていくわけなので、左詰めは どこかを探すのが、TgtCol。 で、そこに、日付と回数を転記していく。 結局、手作業でやる時も、こうやって処理するはずです。 あまり難しく考えなくていいですよ。 ご不明点あればまたどうぞ。
これ、左隣のセルに入ってませんか？ セルを選択した時、数式バーに文字が見えてますか？
こんにちは！ 色々やり方はあると思いますが、 B3セルに =IF(MONTH(WORKDAY(B$1-1,ROW(A1),祭日))=A$2,WORKDAY(B$1-1,ROW(A1),祭日),"") という数式を入れフィルハンドルで下へコピー！ ではどうでしょうか？m(_ _)m
何度もすみません 11!も約4000万になり、Excel2010の最大行数(100万強)を超えています やはり、順列は無視(固定)なのでは？
OFFSET関数とROW関数の使い方を理解されていないようですね。 このままでは問題の先送りになってしまいそうですが、答えてみましょう。 （問題の解決を他の人に肩代わりしてもらい、目の前の問題を解決しても 　理解していないため、同様な問題を自力で解決できない…） 解説を加えてみますので理解するよう努めてください。 OFFSET関数は指定したセルから「どれだけずれたセル」を指定する関数だ。（Offset：オフセット：ずれ、差） 基準になるセルを指定し、そのセルから行、列方向にいくつずれるかという形で記述する。 =OFFSET(基準,行数,列数) =OFFSET(A1,9,1) A1セルから下へ9つ、右へ1つ目のセルを指定。（B10がセル範囲として返る） ROW関数は指定した範囲の左上のセルの行番号を返す関数だ。（Row：ロウ：並び） 範囲の指定がない場合は関数が入力されたセルの行番号を返す。 ＝ROW(範囲) ＝ROW(A11:C15) A11からC15の範囲の左上のセルの行番号。（11が数値として返る） ＝ROW(A11) A11の行番号。（11が数値として返る） ＝ROW(A12) A12の行番号。（12が数値として返る） ＝ROW() その関数が入力されている行番号。（D4セルに入力されていれば４。など） 数式が入力されたセルを下にフィルでコピーした場合、数式に含まれるセル番地の行数が自動で増加する。 この特性を活かしROW関数で連続した数値を得ることができる。 この場合、ROW関数で得た数値をOFFSET関数の列数に入れることで 縦にコピーしても横方向にセルを選択できるようにしている。 ・・・ 説明・解説・前置き…はこのくらいでよいだろうか。 少し試行錯誤すれば理解できる程度の説明はしたつもりだ。 N2　=M2/シート2!B$42 N3　=M3/シート2!C$42 N4　=M4/シート2!D$42 ならば N2　=M2/OFFSET(シート2!A$1,41,1)　…（=M2/OFFSET(シート2!A$42,0,0)　でも間違いではない） N3　=M3/OFFSET(シート2!A$1,41,2) N4　=M4/OFFSET(シート2!A$1,41,3) と書き直せる。 増えている箇所にROW関数を入れればよい。 N2　=M2/OFFSET(シート2!A$1,41,ROW(A1)) N3　=M3/OFFSET(シート2!A$1,41,ROW(A2)) N4　=M4/OFFSET(シート2!A$1,41,ROW(A3)) このように書き換え、完成。 N2セルを下にコピーすればよい状態になった。 ※ OFFSET関数はセル単体を指定するのではなく、セル範囲も指定することができる。 =OFFSET(基準,行数,列数,高さ,幅) 高さと幅の指定を省略すると単体のセルを指定することになる。 SUM関数など、範囲を指定する関数に使用することもできるので覚えておくとよい。
この問題について、空にしたゴミ箱からファイルを復元できるデータリカバリウィザードを使ってみてください。高性能のため、Vector復元部門賞を受賞しました。また、心配なら実際に復元可能なフリー版を試してみよう。 無料ダウンロード：http://jp.easeus.com/data-recovery-software/drw- …　 ご参考程度に！
もし，C列の4行目以降に品名が空きなく入力されていて，D列の最終購入日を一括して出したいのであれば，以下の様なマクロをいれては如何でしょうか？ Sub lastdate() Dim lastcol As Long Dim i As Long Do lastcol = Cells(i + 4, Columns.Count).End(xlToLeft).Column If lastcol >= 4 Then Cells(i + 4, 4) = Cells(3, lastcol) End If i = i + 1 If Cells(i + 4, 3).Value = "" Then Exit Do End If Loop End Sub マクロの使い方が分からない場合ですが，簡単な方法で説明するとExcelを開いている状態でAltキーを押しながらF11キーを押します（Visual Basic Editer-以下VBEと記します-が開かれます）． VBEの左側にプロジェクト(VBAProject)というのがあって，その下にMicrosoft Excel Objectsで右クリックして，挿入，標準モジュールを選びます． 標準モジュールに上述のマクロ（Sub～～End Subの内容）をコピーして貼り付けます． Altキーを押しながらF8キーを押します（マクロというウィンドウが開かれます）おそらくマクロ名にlastdateというのが入っていると思います． オプションをクリックするとショートカットというのが出てきますので，例えばShiftキーを押しながらdを押します． ショートカットにCtrl+Shift+Dとなっていると思いますので，この状態でOKをクリックしてウィンドウを閉じます． あとはExcel上でCtrlキーとShiftキーを押しながらdを押すとそれぞれの最終購入日が出てきます． もし日付ではなく数字が出てきましたら，D列を選択してセルの書式設定から表示形式を日付にして下さい． ※図はマクロを実行した後の画面です．
》 PCがどこかから遠隔操作されているように感じることがあります 案外貴方の被害妄想かも。 インストールしているセキュリティ(ウィルス対策)ソフトにスケジュールスキャン(選択した時刻と頻度でパソコンを自動的にスキャンさせること)を設定していたことを忘れて、遠隔操作感を持ったのがスキャン中だったとかのオチはないですか？ パソコンがスキャンされているときは、操作がギクシャクするものです。
こんなやり方はどうでしょうか？ Sheet1のデータエリアをコピーして、別シートの同じ位置にペーストします。 Sheet1を複製してもOKです。 複製したシートのB2セルに、 =Sheet1!B2*COLUMN(B2)-1 と入力します。 入力したら、データエリアにペーストします。 セル参照は相対的に変わります。 E4セルの場合 =Sheet1!E2*COLUMN(E2)-1 =Sheet1!B2*COLUMN(B2)-1 この計算結果は、Sheet1!B2がFALSEなので =FALSE * 2-1 FALSEと数値を乗算すると、0になります。 =FALSE * 2-1 =-1 =Sheet1!M7*COLUMN(M7)-1 Sheet1!M7はTRUEです。 TRUEと数値xを乗算すると、xになります。 =TRUE*13-1 =13-1 =12 1をマイナスしたのは、質問の列番号と合わせるためです。 計算結果を求める表を作成します。 結果表の最初のセル（図参照）●が付いているセルに =MAX(B2:N2) その右横のセルに =LARGE(B2:N2,2) 次に両方のセルをコピーして、結果表のエリアに貼り付けます。
雰囲気以下でどうなりますか Public Sub Samp1() 　　Dim vA As Variant, vB As Variant 　　Dim i As Long, j As Long, k As Long, n As Long 　　Const CROWH As Long = 8 　　With Range("A1", Cells(Rows.Count, "A").End(xlUp)) 　　　　n = ((.Rows.Count - 1) \ CROWH + 1) * CROWH 　　　　With .Resize(n) 　　　　　　vA = .Value 　　　　　　ReDim vB(0 To n - 1, 1 To 1) 　　　　　　i = 1: j = n - CROWH 　　　　　　While (i < n) 　　　　　　　　For k = 0 To CROWH - 1 　　　　　　　　　　vB(j + k, 1) = vA(i + k, 1) 　　　　　　　　Next 　　　　　　　　i = i + CROWH: j = j - CROWH 　　　　　　Wend 　　　　　　.Offset(, 2).Value = vB 　　　　End With 　　End With End Sub
開きたいExcelファイルを右クリックして、コンテキストメニューの「プログラムから開く･･･」などからExcelを指定して開けないでしょうか？
NO3です。 excelのバージョンが古いのでしたら、分析ツールアドインから「分析」にチェックを入れる事でEDATEも使えるようにはなりますけどね　＾＾； 分析ツールアドインを組み込む 　　　↓ http://www.relief.jp/itnote/archives/excel-edate …
No.１です。 ＞画像の場合、答えが9人になるような式が欲しく・・・ というコトですので、一例です。 ↓の画像のように作業用の列を設けるのが簡単だと思います。 画像ではD2セルに =IF(C2>0,IF(COUNTIFS(A$2:A2,A2,C$2:C2,">0")=1,1,""),"") という数式を入れ、フィルハンドルでダブルクリック！ 今後データが増える可能性がある場合は これ以上データはない！という位まで下へコピーしておきます。 結果のF2セルには =SUM(D:D) という数式を入れています。 ※　作業列が目障りであれば非表示にしてください。 こんな感じではどうでしょうか？m(_ _)m
＞指定日が起算日より前なら、起算日を基準にして、5年後は・・・？ ＞指定日が起算日より後なら、指定日を記入にして、5年後は・・・？ IF関数を使って次の式で行けます。 どうせなら曜日も自動表示させるとなおわかりやすいと思います。 添付画像を参照していただいて、セルC2には次の式を入れます。 =IF(B2>A2,EDATE(B2,60),EDATE(A2,60)) 次にセルの書式設定から、ユーザー設定で設定を『yyyy,m,d (aaaa)』と変更します。 例えば、2020年5月7日 （水曜日）　のような日付の表示形式にしたいのでしたら 『　yyyy年m月d日 (aaaa)　』とユーザー設定で変更します。
NO.2の回答を修正します。 Hypnomaticさんの読図を参考に考えた場合、エクセルの表の一部を変えたらどうなのかなと思いました。 参照するテーブルを変更した図を添付します。
100とか150と言うのが店舗番号だろうか。 ならばシート名があるならそれを使って参照先を指定できる。 文字列から参照先を指定する場合、INDIRECT関数を使う。 すると、 =IF(シート1!A1=100,シート1!C1,"") が、 =IF(INDIRECT(A1&"!A1")=B1,INDIRECT(A1&"!C1"),"") のようになり、 =IF(ISERROR(MATCH(100,シート1!A:A,0)),"",シート1!C1) が、 =IF(ISERROR(MATCH(B1,INDIRECT(A1&"!&A:A"),0)),"",INDIRECT(A1&"!C1")) のようになる。 この場合、C1セルに相当する部分がどう紐付けされているのか不明なので、 そこは自身で「工夫してくれ」。 ※条件（情報）が明らかに少なく、推測では答えられない。 もう一つアドバイス。 自身の手に負えない物件は早めにできないと申告すべき。
No.２です。 補足を拝見するとA2セルに関しては月末ではなくA2セルのシリアル値そのもので良いのですね？ =MIN(EOMONTH(DATE(2015,LEFT(A1,FIND("月",A1)-1),1),0),A2) としてみたらどうなりますか？ ※　No.３さんのご指摘通り、わざわざTEXT関数の入れ子にせずセルの表示形式で処理した方が 数式が少し短くなります。 上記数式を入れたセルの表示形式をユーザー定義から mm月dd日まで としてみてください。 今度はどうでしょうか？m(_ _)m
こんばんは。 お久しぶりです。 >別のエクセルアプリケーションを立ち上げた理由は、ベースのエクセルシート(マクロを含むBook) を開いた状態で、小さなWindowで"book1.xlsx"・・・を表示させたかったからです。 何か、難しいことをされているようですが、再現性が得られません。もしかしたら、こういうことをおっしゃっているのでしょうか。ちゃんと理解しているわけではありませんが、この場合は、Aで非表示でも、Bのマクロは、前面にTest1.xlsxが出てきます。単独で、Bでも可能です。むしろ、Aのマクロは意味がありません。使わなくてもよいです。 しかし、オートメーション・オブジェクトを4つも作ったら、たぶん、いろんな所で支障がでるかもしれません。 '// Sub TestA() 　Dim objExcel2 As Excel.Application 　Dim wb2 As Workbook 　Dim fn As String 　fn = "C:\Users\User1\My Documents\Test1.xlsx" 　Set objExcel2 = CreateObject("Excel.Application") 　'objExcel2.Visible = True 　Set wb2 = objExcel2.Workbooks.Open(fn) 　Set objExcel2 = Nothing End Sub Sub TestB() 　Dim wb2 As Excel.Workbook 　Dim objExcel2 As Excel.Application 　Dim fn As String 　fn = "C:\Users\User1\My Documents\Test1.xlsx" 　On Error Resume Next 　　Set wb2 = GetObject(fn) 　Set objExcel2 = wb2.Application 　objExcel2.Visible = True 　If Err() <> 0 Then 　　Set objExcel2 = CreateObject("Excel.Application") 　　objExcel2.Visible = True 　　Set wb2 = objExcel2.Workbooks.Open(fn) 　End If 　On Error GoTo 0 　With objExcel2 　　.Width = 330 　　.Height = 390 　End With 　Set wb2 = Nothing 　Set objExcel2 = Nothing End Sub '///
流れを読まずに回答してみる。 B1=x,C1=y,D1=(x-y)*10000,E1=D1 なら、D1に入力する計算式は =(B1-C1)*10000 E1に値を入力するなら、そのセルの値は入力した値になるので 　【E1にD1の値を入れることはできない】 し、やったら循環参照になるのでエラーになり計算できない。（←これの意味をしっかり理解すること） 次の式の最後にあるE1+D2のE1も入力した値になる。 B2=x,C2=y,D2=(y-x)*10000,E2=E1+D2 なら D2=(B2-C2)*10000+E1 になる。 …まさかA1とC1を勘違い、E1とF1を勘違いと言うことだろうか？ 数式の選択は、 ＝IF(C1="shot",【計算式１】,IF(C1="long",【計算式２】,"")) こんなでいいのではないか？ これで何か問題があるのだろうか。
＃３です 元のデータが２行以上であれば Samp5 で動きますが １行だけのデータならおかしな動きとなったと思います > rngC.Columns(x).SpecialCells(xlCellTypeConstants) が意図しない動きとなっているようです （私が知らなかっただけなのかも） なので、全パターンを展開する際、行数＝１と以外に分けてみました １行だけの場合、単なる組み合わせ結果になると思います ただし、０個、１個の時には削除していたので、 ２個の時、３個の時、・・・・ Public Sub Samp6() 　　Dim rngC As Range 　　Dim rng As Range, r As Range 　　Dim sS As String 　　Dim i As Long, j As Long 　　Const CROWTOP As Long = 7 　　Const CCOLL As String = "A" 　　Application.ScreenUpdating = False 　　Set rngC = Range("A1").CurrentRegion 　　Rows(CROWTOP & ":" & Rows.Count).ClearContents 　　If (rngC.Rows.Count = 1) Then 　　　　Cells(CROWTOP, CCOLL).Offset(1) = rngC(1) 　　　　Set rng = Cells(CROWTOP, CCOLL).Resize(2) 　　　　For i = 2 To rngC.Columns.Count 　　　　　　With rng.Offset(rng.Rows.Count) 　　　　　　　　rng.Copy .Cells(1) 　　　　　　　　.Columns(i) = rngC(i) 　　　　　　End With 　　　　　　Set rng = Range(Cells(CROWTOP, CCOLL) _ 　　　　　　　　　　, Cells(Rows.Count, rng(1).Column + i - 1).End(xlUp)) 　　　　Next 　　Else 　　　　rngC.Columns(1).SpecialCells(xlCellTypeConstants) _ 　　　　　　.Copy Cells(CROWTOP, CCOLL).Offset(1) 　　　　Set rng = Range(Cells(CROWTOP, CCOLL) _ 　　　　　　　　　　　　, Cells(Rows.Count, CCOLL).End(xlUp)) 　　　　For i = 2 To rngC.Columns.Count 　　　　　　j = 1 　　　　　　For Each r In rngC.Columns(i).SpecialCells(xlCellTypeConstants) 　　　　　　　　With rng.Offset(j * rng.Rows.Count) 　　　　　　　　　　rng.Copy .Cells(1) 　　　　　　　　　　.Columns(i) = r 　　　　　　　　End With 　　　　　　　　j = j + 1 　　　　　　Next 　　　　　　Set rng = Range(Cells(CROWTOP, CCOLL) _ 　　　　　　　　　　, Cells(Rows.Count, rng(1).Column + i - 1).End(xlUp)) 　　　　Next 　　End If 　　With rng.Resize(, rng.Columns.Count + 2) 　　　　j = .Columns.Count - 1 　　　　With .Columns(j) 　　　　　　.FormulaR1C1 = _ 　　　　　　　　"=IF(COUNTA(RC[" & 1 - j & "]:RC[-1])>1" _ 　　　　　　　　& ",COUNTA(RC[" & 1 - j & "]:RC[-1]),"""")" 　　　　　　.Value = .Value 　　　　End With 　　　　sS = "" 　　　　For i = 0 To j - 2 　　　　　　sS = sS & "&RC[" & i - j & "]" 　　　　Next 　　　　With .Columns(j + 1) 　　　　　　.FormulaR1C1 = "=" & Mid(sS, 2) 　　　　　　.Value = .Value 　　　　End With 　　　　.Columns(1).Resize(, j - 1).Delete xlShiftToLeft 　　　　.Sort .Cells(1), xlAscending _ 　　　　　　　　, .Cells(2), , xlAscending, Header:=xlNo 　　　　.Columns(1).SpecialCells(xlCellTypeBlanks) _ 　　　　　　.EntireRow.Delete 　　　　.Columns(1).Delete xlShiftToLeft 　　End With 　　Application.ScreenUpdating = True End Sub
No.1です。勘違いしていたようです。 休憩の開始(外出)は22:00以前が有効、つまり、外出の最大値は22:00、という事ですね？ であれば、休憩時間=戻り-min(外出、22:00)　となります。 ここで、外出<=戻り のみを有効にするならば、次になります。 =max(戻り-min(外出、22:00)、0)、或いは、 =(戻り-min(外出、22:00))*(外出<=戻り) つまり、結果が整数のみを有効とし、負数はゼロとします。IF分は使わなくて済みます。 しかし、これらの計算結果は時間のシリアル値です。 例えば、1:00(1時間)は、0.04167となります。 時間単位の整数値で出したいときは、結果を24倍すれば良いです。 この意味は、1日=1なので、1時間が1/24で表示されるからです。 そうすれば、計算結果(勤務時間)に時間単価をかければ、経費が出ます。
> E2の所定時間は出勤より２２:００までの勤務時間－休憩時間（２２:００以前に取った場合のみ） > という計算がほしかったです。 > なので、この場合所定時間が１２時間となります。 ．　 A　　　　 B　　　　 C　　　　 D　　　　 E　　　　 F 1|　出勤時刻　退勤時刻　外出時刻　戻り時刻　所定時間　超過時間 2|　　 9:00　　 23:00　　 21:00　　 23:00　　 12:00　　 5:00 Ｅ２セルを、 =IF(B2<=TIME(22,0,0),B2-A2,TIME(22,0,0)-A2)-(IF(C2>=TIME(22,0,0),0,IF(D2<=TIME(22,0,0),(D2-C2+IF(C2>D2,1)),TIME(22,0,0)-C2))) とします。 【訂正】 Ｆ２セルを、 =IF((B2-A2+IF(A2>=B2,1))-(IF(C2>=TIME(22,0,0),0,IF(D2<=TIME(22,0,0),(D2-C2+IF(C2>D2,1)),TIME(22,0,0)-C2)))>TIME(8,0,0),((B2-A2+IF(A2>=B2,1))-(IF(C2>=TIME(22,0,0),0,IF(D2<=TIME(22,0,0),(D2-C2+IF(C2>D2,1)),TIME(22,0,0)-C2))))-TIME(8,0,0),"-") とします。 ※外出せずに、外出時刻、戻り時刻が空白の場合でも対応しています。
(1)．見出し行の行番号（グレー色）をクリックしてメニューバー、[データ][フィルタ][オートフィルタ]を実行します（添付画像）。 (2)．[登録番号]列のプルダウンメニュー[▼]をクリックして、該当の登録番号を選択すると一致するデータのみ表示されます。 (3)．[登録番号]列、[日にち備考]列のプルダウンメニュー[▼]をクリックして、登録番号、日にちをそれぞれ選択すると、両者が一致するデータのみ表示されます（添付画像）。 (4)．必要なデータのみ表示されたところで、セル範囲を選択してコピー＆ペーストが可能です。 (5)．プルダウンメニュー[▼]をクリックして、[すべて]を選択すると、すべてのデータが表示されます。
No.1・3です。 ＞0が入るケースの場合は・・・ というコトですが、「0」の場合も表示してもよいのであれば No.3の数式で大丈夫だと思います。 「0」の場合を除外したい場合はA1セルを↓の数式にしてみてください。 （Excel2003でも対応できるはずです） =IF(COUNT(Sheet1!$A$2:$J$2)-COUNTIF(Sheet1!$A$2:$J$2,0)<COLUMN(A1),"",INDEX(Sheet1!$A1:$J1,,SMALL(IF(Sheet1!$A$2:$J$2<>0,COLUMN($A$1:$J$1)),COLUMN(A1)))) 今回も今まで同様、配列数式です。 ※　Sheet1!$A$2:$J$2<>""をSheet1!$A$2:$J$2<>"0"に変えれば良いのでしょうか？ とありますが、ダブルクォーテーションでくくってしまうと文字列になります。 "0"　としてもお望みの結果にはなると思いますが、 質問では数値だと思いますので、そのまま　0　だけで大丈夫です。 しかし、No.3の数式を =IF(COUNT(Sheet1!$2:$2)<COLUMN(A1),"",INDEX(Sheet1!$A1:$J1,,SMALL(IF(Sheet1!$A$2:$J$2<>0,COLUMN($A$1:$J$1)),COLUMN(A1)))) としてしまうと、「0」のセル数だけエラーが表示されてしまいます。 エラー処理まで考えると今回のような数式になると思います。m(_ _)m
こんにちは！ 絶対参照にすれば大丈夫だと思います。 画像の配置だとF1セルに =IF(A1=100,COUNTIF(A$1:A1,100),"") または =IF(A1=100,COUNTIF(A$1:A1,A1),"") という数式を入れフィルハンドルで下へコピーしてみてください。m(_ _)m
お昼休憩開始時間と退社時間を比較、小さい方の時間を採用。 お昼開始時間と、定時出勤時間と出社時間を比較した大きい方の時間を比較し、小さい方の時間を採用。 引いて午前中の就業時間を求める。 ＝MIN("12:00",退社時間)-MIN("12:00",MAX("8:00",出社時間)) 定時退社時間と退社時間を比較し、小さい方の時間を採用。 お昼終了時間と、定時退社時間と出社時間を比較した大きい方の時間を比較し、小さい方の時間を採用。 引いて午後の就業時間を求める。 ＝MIN("17:00"-退社時間)-MIN("17:00",MAX("13:00",出社時間)) 定時の所定時間においては上記の式を足すことで就業時間を求められる。 ＝MIN("12:00",退社時間)-MIN("12:00",MAX("8:00",出社時間))+MIN("17:00"-退社時間)-MIN("17:00",MAX("13:00",出社時間)) 同様に、残業時間と深夜残業時間を求めればよい。 MIN関数とMAX関数が何をしているのかを理解できれば難しいことではない。 是非チャレンジしてみよう。 上に示した計算式では午前中に早退した場合エラーになります。午前中に早退した場合を考慮して所定時間の計算を修正してみてください。 また、早朝残業の計算もやってみましょう。 （理解できて初めて問題解決と自分は考えているので、宿題的な回答になることをお詫びします）
B列に作業列を挿入して B1セル 0 B2セル =COUNTA($C$2:K2) 　下へオートフィル B11セルに 連番 A11セルに 　=INDEX($C$2:$K$9,MATCH(B11-1,$B$1:$B$9),ROW(A1)-LOOKUP(B11-1,$B$1:$B$9)) 　下へオートフィル C11セルに 　=INDEX($A$2:$A$9,MATCH(B11-1,$B$1:$B$9)) 　下へオートフィル あとはVLOOKUPやINDEX/MATCH関数など使って検索すればよいと思います
No.1のコードを修正しました。 xxxx担当者○xxxx.xlsを次々に開いて転記するのはNo.1のコードと同じです。 各xxxx担当者○xxxx.xlsの【B51～B列の最終行のAE列】を転記するデータにしました。 マスターブックの転記開始位置は【B列の最終行+1】なので、異なる行数のデータを転記しても、既にデータが存在している行に転記してしまうことはありません。 各xxxx担当者○xxxx.xlsの転記が完了したら、マスターブックのデータを最終行から調べて、転記したデータの空白行を削除します。【B列からAE列に一つも値が入力されていない行】 Sub Macro02() Dim MasterBook As Workbook Dim PathName As String Dim FileSh As Worksheet Dim i As Long, k As Long, t As Long Dim PasteCell As Long Dim MasterSh As Long Dim Value1 Set MasterBook = ThisWorkbook Application.ScreenUpdating = False MasterBook.Activate Set FileSh = Sheets("ファイル一覧") 'マスターファイルに[ファイル一覧]という名称のシートが存在しないとエラーになります。 PathName = "F:\データ\" 'パス名を変更してください。 For i = 1 To Sheets.Count If Mid(Sheets(i).Name, 5, 1) = "年" And _ Right(Sheets(i).Name, 1) = "月" Then MasterSh = i Exit For End If Next 'このFor～Nextでマスターファイルのシートから、データシートを探します。 For k = 1 To FileSh.Range("A" & Rows.Count).End(xlUp).Row Workbooks.Open Filename:=PathName & FileSh.Cells(k, 1).Value '[ファイル一覧]シートのA1からA列の最終行までの値を順番に取り出して、 'PathNameと連結させたものが、Workbooks.OpenのFilenameになります。 For i = 1 To Sheets.Count If Mid(Sheets(i).Name, 5, 1) = "年" And _ Right(Sheets(i).Name, 1) = "月" Then t = Sheets(i).Cells(Rows.Count, 2).End(xlUp).Row Value1 = Sheets(i).Range(Cells(51, 2), Cells(t, "AE")) Exit For End If Next 'xxxx担当者○xxxx.xlsの【B列の最終行】を貼り付けるデータの最終行としました。 MasterBook.Sheets(MasterSh).Range("B" & Rows.Count).End(xlUp).Offset(1).Resize(t - 50, 30) = Value1 ' masterbook.Sheets(mastersh).range("B" & rows.Count). 'マスターブックのデータシートに転記します。転記開始位置はマスターブックのB列の最終行+1です。 'B列の最終行+1に転記するので、データの行数が変わっても問題ありません。 ActiveWorkbook.Close 'xxxx担当者○xxxx.xlsブックを閉じます。 Next '次のxxxx担当者○xxxx.xlsブックを開きます。 For k = Range("b" & Rows.Count).End(xlUp).Row To 45 Step -1 If WorksheetFunction.CountIf(Range(Cells(k, 2), Cells(k, 10)), "*") = 0 Then Rows(k).Delete shift:=xlUp End If Next 'マスターブックの最終行から45行の【B列からAE列に一つも値がなかった場合、その行を削除します】 Application.ScreenUpdating = True End Sub
No.1 の方のご回答を図解したページがありますので、参考までに、ご一読ください。 「セル参照」 http://www.becoolusers.com/excel/cell-reference. …
まぁ、マクロでやりたいというなら、以下サンプルになります Sub Selection() Set MyRange = Cells(11, 1) For i = 1 To 8 'A列からH列まで 　For m = 11 To 700000 Step 4 '11行めから７0,000行目まで、４行おき 　　Set MyRange = Union(MyRange, Cells(m, i)) 　Next Next MyRange.Select　'格納したセルを選択する End Sub
No.1 です。 > 画像を貼るやり方が分からなかったので自力で解決させました。 自力解決とのこと良かったです。 画像を貼る方法は、下記URLのページをご参照ください。 但し、少し前に画面が変更になっており、「参照」ボタンが「カメラ」のアイコンになっていると思います。 「使い方ガイド > 質問する(動画・画像を添付する)」 https://oshiete.goo.ne.jp/guide/question/multime … 「使い方ガイド > 教えて！gooとは」 https://oshiete.goo.ne.jp/guide/about
No.1,2 です。 > 一人７時間働くとして、１５人がいるとすると、この工場の総労働時間は１０５時間だとします。 > この場合、各製品に振り分けるべき労働時間の比率をどうすべきかというのを考えています。 その考え方は、一定期間の生産比率が決まっている場合には成り立ちますが、通常では非常に稀なケースではないでしょうか？ 製品１個当たりの必要加工時間を算出しておけば、各製品の予定生産数が決定すれば簡単に、『労働時間の配賦比率』を算出できるのではないでしょうか？ > 添付のような情報がある場合、どのように各製品の労働時間の配賦比率を出すべきか、アイデアがあればお教えください。 各製品の必要生産数が未定のままでは、『労働時間の配賦比率』を算出することは不可能と思います。 過去のデータを集計すれば、『労働時間の配賦比率』の実績値を算出することはできます。 （単純な四則計算のみですから・・・）
Xの値をAの列，Yの値をBの列に入れるとした時，A列には任意の値を入れて，B列には以下の式を入力します． =-1*10^(-9)*A2^3+9*10^(-7)*A2^2+0.0034*A2-0.0037 上述の式ではXの値がA2に入っているとします． E-09というのは10の-9乗を示したものです．従ってエクセルでは10^(-9)と入力しても計算できます． 累乗は ^ を使います．
こんなのどうでしょう。 元に戻せませんので必ずバックアップを取ったうえでお試しください。 '--------------------------------------------------------------------- Sub Tenki() Dim r As Long, p As Long p = 50000 r = 1 Do While Cells(r, "SB").Value <> "" Range(Cells(r, "SB"), Cells(r, "SI")).Copy Cells(p, "MN").PasteSpecial Paste:=xlPasteValues p = p + 4 r = r + 1 Loop MsgBox "End." End Sub '---------------------------------------------------------------------
#5です。間違えました。 正「Sheet2のB2に以下を貼り付けて」 誤「Sheet2のA3に以下を貼り付けて」
No.4の回答者です。 > まだどうやって改行したり文字サイズを変えたりするのか [ Enter ]キーなどで改行してくれるわけではないので、挿入したラベル の枠で横幅を狭くするなどで対応します。 ラベル幅を変更する方法以外だと、新規ラベルを追加し、2つのラベルで 改行風にする方法もありますね。 文字サイズなどは[プロパティ]やマクロ指定でできると簡単にできると 思います。 http://www.239-programing.com/excel-vba/ufm/ufm0 … http://www.officepro.jp/excelvbaform/form_label/ … [ ForeColor ]がフォントの色で、[ Font ]でフォント名やサイズを指定 できます。 そのほかの項目も、いろいろ試してみれば理解できると思います。
条件付き書式設定が一般的でしょう。 設定するセルをまとめて選んでから、 書式→条件付き書式で、セルの値が→次の値より小さい→ここで「10」※　を設定、 同じところの「書式」で、フォントやセル色などが設定できます。 ※　直接「10」と入力してもかまいませんが、この値を後で変更するのが面倒です。 別なセルに「10」を記入しておき、そのセルを指定する方法があります。 この場合、「10」を記入したセルを書き直すと、条件を簡単に変えることができます。
「郵便番号変換ウィザード」 が使えるならそれが一番手っ取り早い。 インターネット上にはこの情報が図解入りで解説されているサイトが多数あるので、 入手・設定・使い方についてはそちらを参照してはどうか。 （情報提供だけということでよろしく）
アドバイスと云う事で ＞指定日を過ぎたら入力してあったセルのデータを削除することはできますか？ データは削除せずに、記録として残しておきます。 指定日前のデータを別シートの抽出する機能、関数などを考えます。
作業列としてD列、F列、G列 添付図参照 1. D1セルに 0 2. D2セルに 　 =D1+ISNUMBER(MATCH(C2,{4,5},0)) 　 下へオートフィル 3. F列に連番 3. G2セルに 　 =IF(MAX(D:D)<F2,"",MATCH(F2-1,D:D)+1) 　 下へオートフィル 4. H2セルに 　=IF(G2="","",INDEX(A:A,$G2)) 　 右へ 、下へオートフィル 5. F:J列を切り取って 別シートへ貼り付け
添付ファイル（文中のPDFファイル）のダウンロードが行えない状況ですか？ http://answers.microsoft.com/ja-jp/windows/forum … http://www.pc-memo.info/windows8/627/ http://answers.microsoft.com/ja-jp/windows/forum … もそうですが、お相手がYahoo！メールなら諦めるしかないかもしれませんね
> 実際は数千件程度のデータ ということなので、VBA で設定するのはどうでしょう 数式を設定しなおすだけなので、ファイルサイズはそう大きくならないと思います Public Sub Samp1() 　　Dim vA As Variant 　　Dim i As Long, j As Long 　　j = Int(Val(Range("B2").Value)) 　　If (j <= 0) Then Exit Sub 　　With Range("B5", Cells(Rows.Count, "B").End(xlUp)) 　　　　ReDim vA(1 To .Rows.Count, 1 To 1) 　　　　For i = 1 To UBound(vA) 　　　　　　If ((i Mod j) = 0) Then 　　　　　　　　vA(i, 1) = "=SUM(R[" & 1 - j & "]C[-1]:RC[-1])" 　　　　　　End If 　　　　Next 　　　　i = UBound(vA) 　　　　vA(i, 1) = "=SUM(R[" & 1 - i & "]C:R[-1]C)" 　　　　i = i - 1 　　　　If (vA(i, 1) = "") Then 　　　　　　vA(i, 1) = "=SUM(R[" & 1 - (i Mod j) & "]C[-1]:RC[-1])" 　　　　End If 　　　　.Offset(, 2).FormulaR1C1 = vA 　　End With End Sub ※ B2 を色々と変更後、Samp1 を実行してみてください B2 が書き換わったら設定しなおすことも可能ですが、必要であれば・・・
＃７です >　　Const CCOLR As String = "D" ' A ～ この列まで これを指定させるのはどうだろうか・・・と思っていたのですが > 空白は無視するので、とびとびでも この、とびとび・・・ CurrentRegion　で、最終列を取得できるのか？？ で、最終列を記述してもらうものにしてましたが、 空白あるのは各列の行後半・・・ という使い方なら CurrentRegion で取得できるので 使い勝手は向上するのかなということで Samp2 からの変更点は ★ 部分だけです Public Sub Samp3() 　　Dim rng As Range, r As Range 　　Dim i As Long, j As Long, k As Long 　　Application.ScreenUpdating = False 　　k = Range("A1").CurrentRegion.Columns.Count ' ★ 　　With Columns(k) ' ★ 　　　　.Offset(, 1).Resize(, k + 2).ClearContents 　　　　.SpecialCells(xlCellTypeConstants) _ 　　　　　　.Copy .Offset(, k + 1).Cells(1) 　　　　Set rng = .Offset(, k + 1).CurrentRegion 　　End With 　　For i = k - 1 To 1 Step -1 　　　　j = 0 　　　　For Each r In Columns(i).SpecialCells(xlCellTypeConstants) 　　　　　　With rng.Offset(j * rng.Rows.Count) 　　　　　　　　If (j > 0) Then rng.Copy .Cells(1) 　　　　　　　　.Columns(1).Offset(, -1) = r 　　　　　　End With 　　　　　　j = j + 1 　　　　Next 　　　　Set rng = rng.CurrentRegion 　　Next 　　Application.ScreenUpdating = True End Sub ＃４のお礼に > やっている事は解らないのですが とあったので、チョット解説を・・・数学的な話にはならない？かな？ 図にあるように、3 x 3 で説明してみます For の前までに何をやっているか まず、結果を表示する列幅＋左右１列の範囲をきれいにしておいて 処理対象の最終列の内容をコピーして、塊として覚えます（赤枠） （図上段） For に入って 最終列の前の列から順に、１データずつ 「A」の時は、覚えていた塊の１列目左の範囲に「A」を 「B」の時は、塊単位で行をずらしてコピーして（図中段） その塊の１列目左の範囲に「B」を 「C」も同様の処理を繰り返し、その列を処理しきると（図下段） その状態を、塊として覚えなおして さらに前の列「1」の時には、その塊の１列目左の範囲に「1」を 「2」の時は、塊単位で行をずらしてコピーして、 その塊の１列目左の範囲に「2」を・・・と繰り返していきます 列数が多いと、塊として覚えなおす回数が増えますが、 それは Excel さんがやってくれることなので・・・
銀鱗さんに加えて =IF(3-COUTA(A1:C1)>0,"",IF(OR(MAX(A1:C1)>F1 , MIN(A1:C1)<E1) , "×" , "○")) 3は、テストの枚数です。これでどうでしょう？
> 2ページ目以降のフッター色を『白』にするにはどうしたらいいかpp添え頂ければ嬉しいです。 １ページ目と２ページ以降の「ヘッダー/フッター」が異なるのは、 1. 「ページ設定」の「その他」タブの「ヘッダー/フッター」欄が、「先頭ページのみ別設定」にチェックが入っている場合。 2. １ページ目と２ページの間に、「ページ レイアウト」タブの「ページ設定」グループの「区切り」から「セクション区切り」を挿入した場合。 の２つのケースです。 > 他の色ではちゃんと2ページ目以降も指定した色で表示されます。 が気になりますが、念のためご確認ください。
1と2は私はあまり使いませんが、3のウォッチウィンドウは離れたところにある計算結果を確認するのに使います。 使ってみると結構便利ですけどね。
前回答者の通りですが、タイトル文字など一部の文字だけならワードアートを使ってはどうでしょうか？ 挿入タブ→ワードアート→文字を入力→書式(描画ツール)→文字の効果→変形→形状→四角(一番左上のabcd これで、大きさ比率が自由に変えられます。あとは、文字のフォントや色や輪郭などはお好きにかえてください。 Excelの場合は入力画面と印刷画面の位置にずれが生じますので必ずプレビューで確認してください。
> Excel 2007 テキストボックス > 張り付け後下図が隠れて見えませんので No.1 の方のご回答の通り、『下図が隠れて見え』ないのは、「塗りつぶし」されているからです。 下記のように操作して「塗りつぶしなし」(＝透明)に設定してみてください。 1. そのテキストボックスの上で右クリックして、表示される右クリックメニューの「図形の書式設定」を選択します。 2. 表示されるダイアログボックスの左窓に、「塗りつぶし」が選択されていますので、右窓の「塗りつぶしなし」のラジオボタンをオンにして 「閉じる」ボタンを押します。
№2＋№8で解決すれば、このセルを使ってさらに計算が出来ます。 №6の手法ですと、A1、B1セルは数値でない状態のままなのでその後の計算には不向きです。 ただ、それだけです。
×　=AVERAFEIF(A1:A12,C1,B1:B12) ○　=AVERAGEIF(A1:A12,C1,B1:B12) 綴り間違えたｗ
マクロで一瞬で実現できるはずですが、ひとまずその回答は譲ります。 (1)．A1～AE42セルを選択して、[右クリック][コピー]。 (2)．Sheet2のA2セルで、[右クリック][形式を選択して貼り付け][行列を入れ替える][OK]を実行。 (3)．C1セルに、=B2 と入力。 (4)．B1～C1セルを選択。フィルハンドルを掴んで、右方向にAO1セルまでドラッグ。 (5)．1行目全体を選択し、[右クリック][コピー]して、同じ行位置で[右クリック][形式を選択して貼り付け][値][OK]を実行。 (6)．Ctrl を押しながら、B列、D列、F列…、と選択していき、[右クリック][削除]を実行。
F9キーを押したら演算結果が返ってくるなら「計算方式が手動になっている」で間違いない。 設定を自動に変えればよい。 複数のシートを選択した状態で終了させるとき、上書き保存をするか聞いてくるウインドウが出て、そこで上書き保存を選択すると 演算方式が自動から手動に変わるという、Excelの仕様があるので注意しよう。 （Microsoft社はこれを2010だったか2007でバグを仕様と開き直った）
１．範囲 G4:H4 を選択 ２．“ユーザー定義”で ＿＿　0"以上";;"500未満" ＿＿に書式設定した後で、セル G4、H4 にそれぞれ数値 ＿＿0、500 を入力 以上の結果を添付図に示していますが、貴方が示したＧ、Ｈ列が入れ替わっていることにご注意ください。 (MATCH関数を昇順で使用可能ならしめる為にそうしています) ３．セル D3 に次式を入力して、此れを下方にズズーッとドラッグ＆ペースト ＿＿ =IFERROR(INDEX(G$4:H$9,MATCH(B3,F$4:F$9),MATCH(C3,G$4:H$4)),"")
ＥｘｃｅｌでＶＢＡを使っていることが実はほとんどがセル関数で処理できます。 しかし、このような時間にかかわることはＶＢＡでないと処理できません。 ワークシート関数にNow()というのもありますが、入力した時間のシリアル値で、つねに手動で更新する必要があります。
目的は、SUBTOTALを配列で返したい。 でも、おきまりのINDEX関数が使えず、断念して作業列案出しました。 それに、作業列のほうが融通が利くしね で、解析してみた =SUMPRODUCT(SUBTOTAL(3,OFFSET(U2,ROW(A3:U63)-2,))*(U3:U63="完了")) でもOK OFFSET関数を使えば、SUBTOTAL関数で配列が返せるんですね(*^_^*) ならばとついでにもうひとつ =SUMPRODUCT(SUBTOTAL(3,INDIRECT("U"&ROW(U3:U63)))*(U3:U63="完了")) INDIRECT関数でも、配列が返ってきました とりあえずの回答ですが、上記で全く意味不明なら「配列数式」で検索してみてください
Excelファイルを開く際…ですよね？ 標準の方法では無理。 Excelにそのような機能は無いからです。 マクロで「パスワードを設定して保存」させることができるので 「○月○日以降、パスワードが違うとメッセージが表示されたら、次のパスワードを使ってください」 的な事はできるが、 ○月○日以降の最初に開くときは元のパスワードで開き、その後にパスワードを変更して保存するので勘違いされることが懸念される。
こんばんは！ Sub Sample1() Dim i As Long, lastRow As Long lastRow = Cells(Rows.Count, "B").End(xlUp).Row Range("A:C").Borders.LineStyle = xlNone For i = 1 To lastRow If Cells(i, "A") = "" Then If Cells(i + 1, "A") <> "" Then GoTo 1 End If Else If Cells(i, "A") <> Cells(i + 1, "A") And Cells(i + 1, "A") <> "" Then GoTo 1 End If End If If i = lastRow Then GoTo 1 End If 0: Next i Exit Sub 1: With Cells(i, "A").Resize(, 3).Borders(xlEdgeBottom) .LineStyle = xlContinuous .Weight = xlMedium End With GoTo 0 End Sub こんな感じで良いのでしょうか？m(_ _)m
>=OFFSET('サンプル'!$B$2,0,0,1,COUNT('サンプル'!$B$2:$M$2)) COUNTは数値の個数を返す関数ですよね COUNTAは空白でないセルの個数です >項目に入っている1月や2月の月を消して数字にしてみると、参照していました 今のままの数式を使うなら、1月～１２月のセルを数値だけにして、表示形式をユーザー定義にして「0月」としてみられたらいかがでしょうか（＾－＾）
＃４です 色々確認しやすいように変更してみました その中でのやり方等も参考になれば Samp1からの変更点 ・番号２と６で 100 になるとしていた場合 　Samp1 では、２と６、６と２の行に色をつけていましたが、 　２と６のみに色をつけるように ※ 色を付ける処理は ▲ を使って、 　色付けと同時に G:I 列に文字でも表示するように また、環境作成 testData も変更して J2 に G 列 の個数（-1 の組み合わせ） J3 に H 列 の個数（一致の組み合わせ） J4 に I 列 の個数（+1 の組み合わせ） J6 に -1 / +1 の合計数 J8 に 組にならなかった番号数 を表示するようにしました 添付図の様にフォームコントロールのボタンを配置して そのボタンにマクロを割り当てれば、すぐに確認できると思います このシートが出来上がると、 別のところから A、B 列に値を設定するようにすれば Samp2 / Samp3 ボタンで確認は容易になるかと･･･ Public Sub testData2() 　　Dim r As Range 　　Application.ScreenUpdating = False 　　Randomize 　　Cells.Clear 　　With Range("A1:F1") 　　　　.Value = Array("番号", "値", "合計値" _ 　　　　　　　　　　, "対番号(-1)", "対番号(一致)", "対番号(+1)") 　　　　.HorizontalAlignment = xlCenter 　　　　.Interior.ColorIndex = 15 　　End With 　　Columns("D:F").AutoFit 　　For Each r In Range("A2").Resize(200) 　　　　r = r.Row - 1 　　　　r.Offset(, 1) = Int(100 * Rnd()) + 1 　　Next 　　Range("A1").CurrentRegion.Borders.LineStyle = xlContinuous 　　Range("J2").Formula = "=COUNTA(G:G)" 　　Range("J3").Formula = "=COUNTA(H:H)" 　　Range("J4").Formula = "=COUNTA(I:I)" 　　Range("J6").Formula = "=J2+J4" 　　Range("J8").Formula = "=MAX(A:A)-SUM(J2:J4)*2" 　　Application.ScreenUpdating = True End Sub Samp3 は、Samp2 をコピーして、 ★ Samp3　部分を有効にして、その上の行をコメントにしてください Samp2 / Samp3 の違いは、-1 / +1 どちらを先に行うかだけです Samp2：Samp1 と同じく +1 / -1 の順 Samp3：-1 / +1 の順 Public Sub Samp2() 　　Dim dic As Object 　　Dim r As Range 　　Dim vA As Variant, v As Variant 　　Dim vS As Variant 　　Dim i As Long, j As Long, k As Long, n As Long 　　Dim jj As Long, kk As Long 　　vS = InputBox("合計値の入力", , "100") 　　vS = Int(Val(vS)) 　　If (vS < 1) Then Exit Sub 　　Set dic = CreateObject("Scripting.Dictionary") 　　Application.ScreenUpdating = False 　　Range("J1") = 2 '　　Range("J1") = 3 ' ★ Samp3 　　Columns("G:I").ClearContents 　　With Range("A2", Cells(Rows.Count, "A").End(xlUp)) 　　　　.Resize(, 6).Interior.ColorIndex = xlNone 　　　　vA = .Resize(, 2).Value 　　　　For i = 1 To UBound(vA) 　　　　　　If (Not dic.Exists(vA(i, 2))) Then 　　　　　　　　dic.Add vA(i, 2), CreateObject("Scripting.Dictionary") 　　　　　　End If 　　　　　　dic(vA(i, 2))(vA(i, 1)) = i 　　　　Next 　　　　ReDim vA(1 To UBound(vA), 1 To 4) 　　　　For Each v In Array(Array(0, 3), Array(1, 4), Array(-1, 2)) '　　　　For Each v In Array(Array(0, 3), Array(-1, 2), Array(1, 4)) ' ★ Samp3 　　　　　　i = 0 　　　　　　While (i < dic.Count) 　　　　　　　　j = dic.Keys()(i) 　　　　　　　　k = vS - j + v(0) 　　　　　　　　If (j = k) Then 　　　　　　　　　　If (dic(j).Count > 1) Then 　　　　　　　　　　　　jj = dic(j).Keys()(0) 　　　　　　　　　　　　kk = dic(k).Keys()(1) 　　　　　　　　　　　　n = dic(j)(jj) 　　　　　　　　　　　　vA(n, v(1)) = kk 　　　　　　　　　　　　vA(n, 1) = vS + v(0) 　　　　　　　　　　　　n = dic(k)(kk) 　　　　　　　　　　　　vA(n, v(1)) = jj 　　　　　　　　　　　　vA(n, 1) = vS + v(0) 　　　　　　　　　　　　dic(j).Remove jj 　　　　　　　　　　　　dic(k).Remove kk 　　　　　　　　　　　　If (dic(k).Count = 0) Then dic.Remove k 　　　　　　　　　　Else 　　　　　　　　　　　　i = i + 1 　　　　　　　　　　End If 　　　　　　　　ElseIf (dic.Exists(k)) Then 　　　　　　　　　　jj = dic(j).Keys()(0) 　　　　　　　　　　kk = dic(k).Keys()(0) 　　　　　　　　　　n = dic(j)(jj) 　　　　　　　　　　vA(n, v(1)) = kk 　　　　　　　　　　vA(n, 1) = vS + v(0) 　　　　　　　　　　n = dic(k)(kk) 　　　　　　　　　　vA(n, v(1)) = jj 　　　　　　　　　　vA(n, 1) = vS + v(0) 　　　　　　　　　　dic(j).Remove jj 　　　　　　　　　　If (dic(j).Count = 0) Then dic.Remove j 　　　　　　　　　　dic(k).Remove kk 　　　　　　　　　　If (dic(k).Count = 0) Then dic.Remove k 　　　　　　　　Else 　　　　　　　　　　i = i + 1 　　　　　　　　End If 　　　　　　Wend 　　　　Next 　　　　.Offset(, 2).Resize(, 4).Value = vA 　　　　On Error Resume Next 　　　　For Each v In Array(Array(4, 36), Array(5, 34), Array(6, 36)) 　　　　　　For Each r In .Columns(v(0)).SpecialCells(xlCellTypeConstants) 　　　　　　　　If (r.Offset(, 1 - v(0)) < r) Then 　　　　　　　　　　r.Offset(, 1 - v(0)).Resize(, v(0)) _ 　　　　　　　　　　　　.Interior.ColorIndex = v(1) 　　　　　　　　　　r.Offset(, 3).End(xlUp).Offset(1) = _ 　　　　　　　　　　　　r.Offset(, 1 - v(0)) & "_" & r 　　　　　　　　End If 　　　　　　Next 　　　　Next 　　End With 　　Application.ScreenUpdating = True 　　Set dic = Nothing End Sub
以下でどうなりますか データ１のシート名：Sheet1 データ２のシート名：Sheet2 それぞれの表は A1 から出来上がっているものと仮定します Public Sub Samp1() 　　Dim dic As Object 　　Dim vA As Variant, vB As Variant, v As Variant 　　Dim i As Long, k As Long 　　Set dic = CreateObject("Scripting.Dictionary") 　　With Worksheets("Sheet2") 　　　　vA = .Range("A1", .Cells(Rows.Count, "A").End(xlUp)) _ 　　　　　　　　.Resize(, 2).Value 　　End With 　　ReDim Preserve vA(1 To UBound(vA), 1 To 3) 　　vA(1, 3) = "個数" 　　For i = 2 To UBound(vA) 　　　　dic(vA(i, 1)) = i 　　Next 　　With Worksheets("Sheet1") 　　　　vB = .Range("A1", .Cells(Rows.Count, "A").End(xlUp)) _ 　　　　　　　　.Resize(, 3).Value 　　End With 　　ReDim Preserve vB(1 To UBound(vB), 1 To 4) 　　vB(1, 4) = vB(1, 3) 　　vB(1, 3) = vB(1, 2) 　　vB(1, 2) = vA(1, 2) 　　For i = 2 To UBound(vB) 　　　　vB(i, 4) = vB(i, 3) 　　　　vB(i, 3) = vB(i, 2) 　　　　k = dic(vB(i, 1)) 　　　　If (k > 0) Then 　　　　　　vB(i, 2) = vA(k, 2) 　　　　　　vA(k, 3) = vA(k, 3) + vB(i, 4) 　　　　Else 　　　　　　vB(i, 2) = "" 　　　　End If 　　Next ' ★～ 　　Application.ScreenUpdating = False 　　For Each v In Array(vB, vA) 　　　　Worksheets.Add After:=Worksheets(Worksheets.Count) 　　　　With Range("A1").Resize(UBound(v), UBound(v, 2)) 　　　　　　.Value = v 　　　　　　.Sort .Cells(.Columns.Count), xlDescending _ 　　　　　　　　　　, .Cells(1), , xlAscending, Header:=xlYes 　　　　　　With .Rows(1) 　　　　　　　　.Interior.ColorIndex = 15 　　　　　　　　.HorizontalAlignment = xlCenter 　　　　　　End With 　　　　　　.Borders.LineStyle = xlContinuous 　　　　　　.EntireColumn.AutoFit 　　　　End With 　　Next 　　Application.ScreenUpdating = True ' ～★ 　　Set dic = Nothing End Sub 上記では、結果を別々のシートに出力していますが ★～　～★　間を以下に変更すると、別シート１枚に連続出力します 出力順は　Array(vB, vA)　の記述順 　　Application.ScreenUpdating = False 　　Worksheets.Add After:=Worksheets(Worksheets.Count) 　　i = 1 　　For Each v In Array(vB, vA) 　　　　With Cells(i, "A").Resize(UBound(v), UBound(v, 2)) 　　　　　　.Value = v 　　　　　　.Sort .Cells(.Columns.Count), xlDescending _ 　　　　　　　　　　, .Cells(1), , xlAscending, Header:=xlYes 　　　　　　With .Rows(1) 　　　　　　　　.Interior.ColorIndex = 15 　　　　　　　　.HorizontalAlignment = xlCenter 　　　　　　End With 　　　　　　.Borders.LineStyle = xlContinuous 　　　　End With 　　　　i = i + UBound(v) + 1 　　Next 　　Columns.AutoFit 　　Application.ScreenUpdating = True
＃２です 結構長くかかるんですね 表内はどのような内容になっているのでしょうか？ 以下参考まで 以前の Samp は、 消す行 / 残す行 に印をつけて、Sort で偏らせて・・・してましたが Sort ではなく、重複の削除（ RemoveDuplicates ）を使ってみました （重複の削除は結構速い） 処理する値として、 削除しない：行番号、削除する：空白 最終的に、空白は１つ残るので、それを探して削除・・・ Samp22 は、Samp2 のチェックする表単位（分割）バージョン Samp33 は、Samp3 を変更したバージョン 雰囲気的には、Samp3 or Samp33 ？ Public Sub Samp22() 　　Dim rng As Range, r As Range 　　Dim vA As Variant 　　Dim i As Long, j As Long, k As Long 　　Dim bDel As Boolean 　　Const CROWH As Long = 8 　　Const CCOLW As Long = 11 　　Const CCUTNUM As Long = 500 ' チェックする表単位 　　Application.ScreenUpdating = False 　　Application.Calculation = xlCalculationManual 　　With ActiveSheet.UsedRange 　　　　With .Resize((((.Rows.Count - 1) \ CROWH) + 1) * CROWH, CCOLW) 　　　　　　ReDim vA(1 To .Rows.Count, 1 To 1) 　　　　　　For i = 1 To UBound(vA) 　　　　　　　　vA(i, 1) = i 　　　　　　Next 　　　　　　bDel = False 　　　　　　k = 1 　　　　　　While (k < .Rows.Count) 　　　　　　　　On Error Resume Next 　　　　　　　　Set rng = Nothing 　　　　　　　　Set rng = .Rows(k).Resize(CROWH * CCUTNUM) _ 　　　　　　　　　　　　　　　　.SpecialCells(xlCellTypeFormulas, xlErrors) 　　　　　　　　On Error GoTo 0 　　　　　　　　If (Not rng Is Nothing) Then 　　　　　　　　　　bDel = True 　　　　　　　　　　For Each r In rng 　　　　　　　　　　　　i = ((r.Row - 1) \ CROWH) * CROWH + 1 　　　　　　　　　　　　For j = 1 To CROWH 　　　　　　　　　　　　　　vA(i, 1) = "" 　　　　　　　　　　　　　　i = i + 1 　　　　　　　　　　　　Next 　　　　　　　　　　Next 　　　　　　　　End If 　　　　　　　　k = k + CROWH * CCUTNUM 　　　　　　Wend 　　　　　　If (bDel) Then 　　　　　　　　With .Resize(, CCOLW + 1) 　　　　　　　　　　.Columns(CCOLW + 1).Value = vA 　　　　　　　　　　.RemoveDuplicates CCOLW + 1, xlNo 　　　　　　　　　　With .Columns(CCOLW + 1) 　　　　　　　　　　　　.SpecialCells(xlCellTypeBlanks).EntireRow.Delete 　　　　　　　　　　　　.ClearContents 　　　　　　　　　　End With 　　　　　　　　End With 　　　　　　End If 　　　　End With 　　End With 　　Application.Calculation = xlCalculationAutomatic 　　Application.ScreenUpdating = True End Sub Public Sub Samp33() 　　Dim vA As Variant, vB As Variant 　　Dim i As Long, j As Long, k As Long 　　Dim bDel As Boolean 　　Const CROWH As Long = 8 　　Const CCOLW As Long = 11 　　Application.ScreenUpdating = False 　　Application.Calculation = xlCalculationManual 　　With ActiveSheet.UsedRange 　　　　With .Resize((((.Rows.Count - 1) \ CROWH) + 1) * CROWH, CCOLW) 　　　　　　vB = .Value 　　　　　　ReDim vA(1 To UBound(vB), 1 To 1) 　　　　　　For i = 1 To UBound(vA) 　　　　　　　　vA(i, 1) = i 　　　　　　Next 　　　　　　bDel = False 　　　　　　i = 1 　　　　　　While (i <= UBound(vB)) 　　　　　　　　For j = 1 To UBound(vB, 2) 　　　　　　　　　　If (IsError(vB(i, j))) Then 　　　　　　　　　　　　bDel = True 　　　　　　　　　　　　i = ((i - 1) \ CROWH) * CROWH 　　　　　　　　　　　　For k = 1 To CROWH 　　　　　　　　　　　　　　i = i + 1 　　　　　　　　　　　　　　vA(i, 1) = "" 　　　　　　　　　　　　Next 　　　　　　　　　　　　Exit For 　　　　　　　　　　End If 　　　　　　　　Next 　　　　　　　　i = i + 1 　　　　　　Wend 　　　　　　If (bDel) Then 　　　　　　　　With .Resize(, CCOLW + 1) 　　　　　　　　　　.Columns(CCOLW + 1).Value = vA 　　　　　　　　　　.RemoveDuplicates CCOLW + 1, xlNo 　　　　　　　　　　With .Columns(CCOLW + 1) 　　　　　　　　　　　　.SpecialCells(xlCellTypeBlanks).EntireRow.Delete 　　　　　　　　　　　　.ClearContents 　　　　　　　　　　End With 　　　　　　　　End With 　　　　　　End If 　　　　End With 　　End With 　　Application.Calculation = xlCalculationAutomatic 　　Application.ScreenUpdating = True End Sub
シート1とシート2がペアなら、2枚のシートを作業グループにして（シート１の見出しをクリックしてCtrtキーを押しながらシート2の見出しをクリック）作業グループになったらどちらかのシート見出しを右クリックして「移動またはコピー」を選択してコピーにチェックを入れ挿入先を指定してOKをクリックすればできると思いますよ。
こんなのどうでしょうか。 '-------------------------------------------------------- Sub aaa() Dim Rng As Range, r As Integer If ActiveSheet.AutoFilterMode = True Then 　　Set Rng = ActiveSheet.AutoFilter.Range 　　r = Rng(1).Row 　　MsgBox r Else 　　MsgBox "フィルタが設定されていません" End If End Sub '--------------------------------------------------------
メモリーを増やしても再インストールしてもダメだった。最終的なリカバリーしても変わらず。それで思いついたのは、根本的なところ(ファイル）が壊れているのではないかと思った。HDDを交換したら治りました。 ＞また、インターネットエクスプローラーに関しても、同様？の症状が出ており それです。この現象以外でもおかしなことがあった。思いたることは数か月前に、重くなったので不要なソフトやデーターを整理したことがあった。リソースもいじったし。それだろう。
＃６です > 何分、マクロに関しては素人ですので、 回答した、回答いただいてるので、色々聞かれたら良いと思いますよ 質問者さんが補足等で聞かれる分には、遠慮はいらないと思います ご質問内で、リンク設定して･･･とあったので、 ハイパーリンクでの記述を提示してみましたが、 ハイパーリンクを使わない理由に（私は）興味ありますけど ハイパーリンクを使わないから、 シートモジュールへの記述が発生していると思われるので 素人ゆえに、機能を増やす/削る等の判断は重要かと 機会があれば、色々な事を知っておいた方が良いかも それによって、VBA での記述量/難易度が変わってくると思います ※ > 同一フォルダ内にある20ぐらいのエクセルファイル これらのファイルの性質はどのようなものだったでしょうか 随時更新され続けるものだったでしょうか？ 言葉で記述してませんでしたが ・AddFile してから Search するまでの間に ・Search してから Search するまでの間に ファイルサイズが変わったら、読み込みしなおすようにしてました 不要であれば、Size 比較部分等削除ください ファイルサイズが変わらない場合でも、現状で動くと思います サイズで判別していましたが、更新日時を使うとか・・・ 履歴の様なもので今後変更ないのであれば、 Access にでも１枚テーブルに読み込んでおけば And 検索等も楽にできるような気がします ※ そのまま 使えるもの を提示しているつもりは無いので、 検証を重ねて、できるもの から、使えるもの にしてください 例えば、Samp0 でのファイルの指定方法とか CPATH のフォルダにある Excel ファイルを AddFile に指定しますが、 ファイル名先頭が "~" なら除外してました これは、自分が（誰かが）そのファイルを開いた時に出来上がる バックアップファイル（？）の ~$ファイル名 を対象外とするだけです なので、普通に "~" で始っているとか > マクロを設定したエクセルをデータがあるフォルダと同じフォルダに保存 には対応できてません ファイル名を得るために FileSystemObject のメソッド を使ってました FileSystemObject のメソッド https://msdn.microsoft.com/ja-jp/library/cc42807 … Dir を使っても良いと思います どのような指定をしたら、どのようなものが得られるのか等 また、それによって、どのような判別すれば良いのか・・・ 色々試してみてください
No4です 質問を誤解していました No1さんは正解です
添付図に限るなら、下記の式で“御の字”かと。 Sheet2!A3: =VLOOKUP(A2,Sheet1!A:B,2)
こんばんは！ お望みの方法でないかもしれませんが、 VBAでの一例です。 データはA列に入るものとします。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）A列にデータを入力してみてください。 Private Sub Worksheet_Change(ByVal Target As Range) 'この行から// Dim k As Long, lastCol As Long, myAry As Variant If Intersect(Target, Range("A:A")) Is Nothing Or Target.Count > 1 Then Exit Sub With Target lastCol = Cells(.Row, Columns.Count).End(xlToLeft).Column If lastCol > 1 Then Range(Cells(.Row, "B"), .Cells(.Row, lastCol)).ClearContents End If On Error Resume Next '←念のため★ myAry = Split(StrConv(.Value, vbNarrow), ">>") For k = 0 To UBound(myAry) Cells(.Row, k + 2) = myAry(k) Next k End With End Sub 'この行まで ※　A列データは直接入力でもコピー＆ペーストでも構いませんが、 必ず1セルずつ入力してみてください。 （一気に複数セルにコピー＆ペーストした場合は何も変化しません）m(_ _)m
No2です 誤回答でした、無視してください。 失礼しました、ごめんなさい。
＃１です。補足拝見しました。 だったら、タイトルの通り、IF関数を使えばよいのでは？ ちょっと冗長ですが。 =IF(FLOOR(B1,"0:10")-CEILING(A1,"0:10")=0,"0:10"*1,FLOOR(B1,"0:10")-CEILING(A1,"0:10")) 引き算結果が０だったら、0:10を返す。 そうでないなら引き算結果。 意図にそぐってないようならすみません。
「アドイン」タブを表示するには、「郵便番号変換ウィザード」アドインを有効にすると、自動的に「アドイン」タブが表示されるので最も簡単です。 郵便番号変換には、「Office 郵便番号辞書」のインストールが必須です。 「Office 更新プログラム: 郵便番号辞書 (2013 年 5 月版) 」 https://www.microsoft.com/ja-jp/download/details …
こんにちは。 'エラーを特定せずに、削除します。 Sub DeleteErrorRows() 　Dim Rng As Range 　Application.ScreenUpdating = False 　With ActiveSheet.UsedRange 　　On Error Resume Next 　　Set Rng = .SpecialCells(xlCellTypeFormulas, xlErrors) 　　On Error GoTo 0 　　If Not Rng Is Nothing Then 　　　Rng.EntireRow.Delete 　　End If 　End With 　Application.ScreenUpdating = True End Sub
こんにちは。 追伸の追伸です。 かなり難しい内容にしてしまいました。 >もし、余裕があるのでしたら、こちらも考えてみてください 解決策のひとつです。 たまたま、マクロを作っいたら、同じ現象が現れたので、その解決策を http://oshiete.goo.ne.jp/qa/9073173.html で書きましたが、OnTime メソッド使って、途切れたマクロの線路を補填してやればよいのです。
こんばんは。 確かに、分析ツールで行列内に、数字以外のデータがあれば、エラーが発生しますが、そのデータをブランクにしても、0とはカウントしていないようですね。 分析ツール自体よりも、CORREL　関数を直接使ったほうが良いかもしれません。ブランクや数値以外のものは飛ばして計算しています。 試しに、こちらでは、ユーザー定義関数で、数値以外をカウントしないようにして作ってみました。組み込みのCORREL関数と、結果は変わりませんでした。 一度、そのデータを別シートで、CORREL 関数で計算しなおしてみたらいかがですか？もしくは、分解して計算するかどちらかです。 必要なら、ユーザー定義関数の中身(VBA)を出します。
必要な関数は、 MIN関数（範囲内の最小値を求める） COUNTIF関数（条件を決めてセルの数を数える） するとB1セルに入力する関数式はこうなる。 =COUNTIF(C1:G1,"<="&MIN(C1:G1)*1.1) あとはこれを必要な列までコピーするだけ。 ※COUNTIF関数は条件を文字列で与える必要がある。
添付図参照 F9: {=SUMPRODUCT((A$2:A$8=E9)*(B$2:B$8)*(VLOOKUP(C$2:C$8,E$3:F$6,2)))} 【注】この式は配列数式(←分かる？)です。
> 通知で開いた場合、相手がファイルを閉じると「編集可能になりました」というメッセージが出てきますが、 > この場合、このまま私が編集して保存すると相手が編集した所はどうなりますか？ > 相手が入力した所は消えてしまうと思っていましたが、実際の所どうなんでしょうか？ 編集には保存が含まれますので、 『相手がファイルを閉じると「編集可能になりました」というメッセージ』が表示されたと云うことは、保存は終了しているはずです。 保存されたことをキッカケに、「編集可能になりました」というメッセージを表示していると思います。 （何故なら、保存していない間は編集中ですので･･･）
IF(Ａ<B,A,B) 二者択一ならこれが簡単です。 難点は、A=Bの場合ですが、Bが選択されます。 同じ値だから問題ないと思います。
NO.１です。 投稿後気づきました。 「6421」から始まるのではなく、「6241」ですね！ どうも失礼しました。 お判りでしょうが、前回のコードの ＞・・・"6421????",・・・ の部分を ＞・・・"6241????",・・・ に訂正してください。 どうも失礼しました。m(_ _)m
OFFSETやINDIRECT関数はワークシート上で使うと、 計算に関係のないセルの編集後でも計算が走るようです。 (XL2007以降、未検証なので変更されたかも) 案1 1. D1セルを選択 2. [Ctrl]+[F3] 名前の定義 　名前 過去3か月 　参照範囲 =A1:C1 　 　(勝手にシート名が入ります) 3. D1セルに 　=SUM(過去3ヶ月) 案2 D1セルに =SUM(INDEX(1:1,COLUMN()-3):INDEX(1:1,COLUMN()-1))
No1のesupuressoです。 前回のB列の文字位置に関して、左からインデント「1」で設定して文字位置を右方向へ少しずらしています。 多分この文字位置をスペースでずらしたのではないでしょうか？ 勘違いするような表を作ってしまい申し訳ありません。　彡Ｏ┓ﾍﾟｺﾘ 本来はこのような添付画像のように文字位置は左側ですので、もう一度お試しくださいませ。 （スペースは一つも入っておりません） 数式は特に問題ないです　＾＾； =IF(E5="","",IF(B5="営業",D5-C5,"0:20"+(D5-C5)))
こんばんは。 >セルに入力すると自動でチェックが入る数式というのはあるのでしょうか？ それは、Excel 2003時代までは、そういう種類の特殊な関数を作っていた人がいます。しかし、私は、ある程度のCOMアドインを勉強しましたが、そこまでは行きませんでした。 ただ、作り方を教わっても、一般的にはVB系のコンパイラーがないし、インストールなどしていないので、数式の設定までは、結構手間がかかります。 以下はその代用品です。 イベント・ドリブン型マクロといいます。 取り付け方は、 シートタブを右クリックして、コードの表示を選択します。 後は、このようにコードを貼り付けてください。 修正部分の下の行の範囲の部分を適当に変更してください。 以下は、日付がなくなると、チェックも消えるようになります。 複数の貼り付けの場合でも、対応できるようにしました。 なお、チェックボックスは、図の見た目の判断から、フォーム・コントロールのものといたしました。 '// Private Sub Worksheet_Change(ByVal Target As Range) 　Dim i As Long 　Dim chk As CheckBox 　Dim c As Range 　For Each c In Target 　　'修正部分：入力が可能な場所は、日付値が、A1～D20 までの範囲です。 　　If Not Intersect(c, Range("A1:D20")) Is Nothing Then 　　　For Each chk In Me.CheckBoxes 　　　　If Not Intersect(chk.TopLeftCell, c.Offset(, 1)) Is Nothing Then 　　　　　If IsDate(c.Text) Then 　　　　　　chk.Value = xlOn 　　　　　Else 　　　　　　chk.Value = xlOff 　　　　　End If 　　　　End If 　　　Next chk 　　End If 　Next c End Sub '///
こんばんは　　いろいろ試した結果、「リストA」及び「リストB」に中間に作業エリアを設ければ、関数で処理することが出来ることがわかりました。 顧客Noを入力すると、L 列に単価が表示されます。 　単価は色やサイズによって相違する事を前提に、作業エリア（V列）を使用することとしてあります。 数式を記載しましたので、試してみてください。 ●リストA １　　単価(L列)　…　色（M列)　サイズ(N列) 　　品番(S列)　　顧客No.(T列) 　　作業エリア（V列) ２　　　　　　　　　　　L　　　　　L　　　　　　AAA　　　　N000000002 ①　　AAALL ３　　　　400　　　　　L 　　　 　M　　　　　　AAA 　　　　　　　　　11 ②　　AAALM 4　　　　　　　　　　　B　　　　　M　　　　　　AAA　　　　　空欄　　　 　　　AAABM ５　　　　　　　　　　 B　　　　　M　　　　　　BBB　　 　　　空欄　　 　 　　　BBBM 6　　　　800　　　　　B　　　　　S　　　　　　BBB　　　　　 空欄　　 　 　　　BBBBS 7　　　 1000　　　　　B　　　　　L　　　　　　BBB　　　　　 空欄　　 　 　　　BBBBL 8　　　　400　　　　グレー　　　200　　　 　　CCC　　　　　　空欄　　　 　　　CCCグレー200 ………… 　　① 　　　　　 ② ③ 　④ 　　　　　　　　⑦ 単価(L列) 　① L2 =IF(ISERROR(INDEX([リストＢ.xlsx]Sheet1!$J$3:$K$12,MATCH(V2,[リストＢ.xlsx]Sheet1!$J　$3:$J$12,0),2))=TRUE,"",INDEX([リストＢ.xlsx]Sheet1!$J$3:$K$12,MATCH(V2,[リストＢ.xlsx]Sheet1!$J$3:$J$12,0),2)) 　　(以下、下へコピー） 　②カラー(M列)、③サイズ(N列）、④品番(S列)　 文字で入力 顧客No.(T列) 　⑤ T2　顧客Noを入力 　⑥ T3　=MATCH(T2,[リストＢ.xlsx]Sheet1!B1:B65536,0) 　　（T2に入力された顧客のNoが、「リストB」のB列の何行目に表示されているかを求める。） 検索用作業エリア （V列） 　⑦　V2 =S2&M2&N2 　　(以下、下へコピー） ●リストB 同一品番のものでも色やサイズによって単価が変わることを前提に、リストBに「色（F列)」、「サイズ(G列) 」を加えました。 作業エリアとして、I列、J列、K列が加えてあります。 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 ⑪　　 　⑫ (A列）　(B列）　　　(C列） (D列）　(E列）（F列) (G列) (I列） （J列) 　 (K列) 顧客名　顧客No　 品番　商品名　単価　 　色 サイズ　 ⑧ 11 品番　 　単価 　株　N000000001　AAA　　(略）　500 　 L L　　　 ⑨ 11 AAALM 400 　式　N000000001　BBB　　　　　 650　　　L LL　　 ⑩ 12 BBBBS　 800 　会　N000000001　CCC　　　　 　900 黒 400 13 BBBBL　 1000 　社　N000000001　AAA　　　　 　450 B M 14 DDDGM 600 　●　N000000001　EEE　　　 　300　 グレー　 M　　　　 15　 EEEH400 500 　●　N000000001　EEE　　　　 　200　　 黒 L 16 CCCグレー200 400 ※※※※※1行挿入※※※※ 17 顧客名 顧客No 　品番 商品名 単価 色　 サイズ 18 株　N000000002 　AAA　　(略）　400 L M 19 式　N000000002 BBB　　　　　　800 B S 20 会　N000000002　BBB　　　　　 1000 B L 21 社　N000000002　DDD　　　　　 600　　G M ▲　N000000002　EEE　　　　　 500　　H　　 400　　　　　 ▲　N000000002　CCC　　　　　　400 グレー 200 ●I２　行番号の取り込み ⑧ I2　=[リストA.xlsx]Sheet1!$T$3 　リストA　のT2　の顧客のNoが、このシート の何行目に表示されているかを「リストA」のT3から取り込む。 ●I列　行番号の表示 ⑨ I3 =I2 ⑩ I4 =I3+1 　　（以下、下へコピー） ●J列　品番　（顧客Noの欄に入力された品番の表示） ⑪ J3 =IF(INDIRECT(ADDRESS(I3,3,1))=0,"",IF(J2="","",INDIRECT(ADDRESS(I3,3,1))&INDIRECT(ADDRESS(I3,6,1))&INDIRECT(ADDRESS(I3,7,1)))) 　　（以下、下へコピー） ※　品番は、色とサイズを合せたものとします。 ●K列　品番　（顧客Noの欄に入力された品番に係る単価の表示） ⑫ K2 =IF(INDIRECT(ADDRESS(I3,3,1))=0,"",IF(K2="","",INDIRECT(ADDRESS(I3,5,1)))) 　　（以下、下へコピー） 注）色やサイズで単価が変わらない場合は、次のように数式を変更。 　●リストA の「検索用作業エリア （V列）」 　⑦　V2 =S2 　●リストBの　J列　品番　（顧客Noの欄に入力された品番の表示） 　⑪ J3 =IF(INDIRECT(ADDRESS(I3,3,1))=0,"",IF(J2="","",INDIRECT(ADDRESS(I3,3,1))))
1234円と表示されているセルを選択して、上の数式バーには何と記入されているか。 具体的に示そう。 文字列で”1234円”と記入されているか、数値で入力されているがセルの書式設定で「通貨」などを選択して”円”を表示させているかを明確にする必要があるのだ。 文字列ならば「対象のセルを全て選択」して「置換」、 セルの書式設定で表示しているなら、セルの書式を「数値」にすればよい。 結果が気になるので返答を望む。
小文字のｘをギリシャ文字のχ（カイ）にしてはどうか。 明朝体なら数学で方程式などに用いられるｘと「同じ形」になる。 このサイトはゴシック体なので大文字のXと似た形になっていると思うが この質問をコピーしてメモ帳など明朝体フォントを使える物に貼り付けてフォントを変えて確認してみて欲しい。
No.1 です。 すみません。　早とちりでした。 先の回答を無視してください。 マクロなら可能性がありますが、普通の操作ではできません。
添付図のようなことですかねぇ～ １．範囲 D1:D5 を選択 ２．[数式バー]上に式 =((A1:A5)-(B1:B5))*(C1:C5) を ＿＿入力（→添付図上段） ３．Ctrl+Shift+Enterキーを「エイヤッ！」と叩き付け！ ＿＿（→添付図下段）
＃１１です 複数列一気になら、雰囲気 Samp3 でどうなりますか Public Sub Samp3() 　　Dim ws As Worksheet 　　Dim dic As Object, dicS As Object 　　Dim vW As Variant, v As Variant 　　Dim sS As String 　　Dim i As Long 　　Const CERRCHR As String = "★" 　　Set dic = CreateObject("Scripting.Dictionary") 　　Set dicS = CreateObject("Scripting.Dictionary") 　　Application.ScreenUpdating = False 　　With Worksheets("入力用") 　　　　For Each ws In Worksheets 　　　　　　If (ws.Name <> .Name) Then 　　　　　　　　dic.Add ws.Name, ws 　　　　　　　　ws.Cells.Clear 　　　　　　End If 　　　　Next 　　　　With .Range("B5", .Cells(Rows.Count, "B").End(xlUp)) 　　　　　　ReDim vW(1 To .Rows.Count, 1 To 1) 　　　　　　For i = 1 To .Rows.Count 　　　　　　　　sS = GetPho(.Cells(i).Value) 　　　　　　　　If (Len(sS) > 0) Then 　　　　　　　　　　If (Not dic.Exists(sS)) Then 　　　　　　　　　　　　Set ws = Worksheets.Add _ 　　　　　　　　　　　　　　　　(After:=Worksheets(Worksheets.Count)) 　　　　　　　　　　　　ws.Name = sS 　　　　　　　　　　　　dic.Add sS, ws 　　　　　　　　　　End If 　　　　　　　　　　If (Not dicS.Exists(sS)) Then 　　　　　　　　　　　　Set dicS(sS) = .Cells(1).Offset(-1) 　　　　　　　　　　End If 　　　　　　　　　　Set dicS(sS) = Union(dicS(sS), .Cells(i)) 　　　　　　　　Else 　　　　　　　　　　vW(i, 1) = CERRCHR 　　　　　　　　End If 　　　　　　Next 　　　　　　.Offset(, -1).Value = vW 　　　　End With 　　　　.Activate 　　End With 　　For Each vW In dicS.Keys 　　　　With dic(vW) 　　　　　　dicS(vW).EntireRow.Copy .Cells(4, "A") 　　　　　　.Columns.AutoFit 　　　　End With 　　Next '　　For Each v In dic.Keys ' データのないシート削除 '　　　　If (Not dicS.Exists(v)) Then '　　　　　　Application.DisplayAlerts = False '　　　　　　dic(v).Delete '　　　　　　Application.DisplayAlerts = True '　　　　End If '　　Next 　　Application.ScreenUpdating = True 　　Set dic = Nothing 　　Set dicS = Nothing End Sub Private Function GetPho(vSrc As Variant) As String 　　Dim sS As String 　　Const COUTCHR As String = "!#$%&'(*/<>[{" 　　If (Len(vSrc) = 0) Then Exit Function 　　sS = Application.GetPhonetic(vSrc) 　　If (Len(sS) = 0) Then Exit Function 　　sS = Left(StrConv(Left(sS, 1), vbKatakana + vbNarrow + vbUpperCase), 1) 　　If (sS Like "[A-Z]") Then 　　　　sS = "A-Z" 　　ElseIf (InStr(COUTCHR, sS) > 0) Then 　　　　sS = "" 　　Else 　　　　sS = StrConv(sS, vbHiragana + vbWide) 　　End If 　　GetPho = sS End Function
> Offise2013で行でも列でも飛んでいるセルの値を合計した平均値を求める方法は有りますか？ まず、平均値を出したい数値が入力されているすべてのセルを、[Ctrl]キーを押しながら選択してください。 最下辺のステータスバーを見てもらうと、「平均」「データの個数」「合計」の値が自動的に表示されます。 離れた位置にある複数のセルの平均値を特定のセルに表示するには、そのセルに[合計]/[データの個数]などの数式を入力する必要があります。
こんばんは！ ＞囲み付きテキスト文内 がいまいち判らないのですが、オートシェイプだとしての一例です。 ↓の画像ではオートシェイプの「大かっこ」を挿入し、A1セルのデータを表示させています。 やり方は ①　まず好みのオートシェイプを挿入 楕円などの場合は塗りつぶしを自動にしたり、 挿入したオートシェイプ上で右クリック　→　テキストの編集　等の操作が必要になります。 ②　オートシェイプが選択されている状態で 数式バーで参照先セルを選択します。画像では数式バー内に =A1 と手入力しています。 これでA1セルデータがそのままオートシェイプ上に表示されます。 ※　的外れならごめんなさいね。m(_ _)m
＃２です > 仕事場に持ち込み試してみます。 その後どうされてましたでしょうか？ これまでの内容は、詳細の情報が無かったので 想定勤務表を作る testData を提示してみました また、その出来上がったものを対象に 夜中帰宅者表、タクシー票を別々のシートに作成する･･･ Samp1 がそうでしたが･･･ どちらもかけ離れたものになっていたでしょうか？ 実際の勤務表のレイアウト等提示あれば、 それ用のものを提示できると思いますが･･･ ※ 実際のデータが必要なわけではありません ・どこに、 ・どういう内容が書かれており、 ・それをどう解釈して ・どうしたい また、ここの記述は何しているの？ とかあれば････
>>まさか、Workbooks.Open [ファイル名] は使ってはないと思います。 >え？使ってますが、問題あるのですか？Book2を開いてないとマクロ2は使えないので。 開いてないと使えないのではなくて、呼び出しすると、一般のワークブックなら開くはずです。 Application.Run で、マクロの呼び出しをする場合に、Workbooks.Open [ファイル名]　は、使ったことかありません。使っても、特には問題はないはずですが、Workbooks.Open だと、いろんな付帯条件があるので、マクロを使うために、開くということはしませんね。 最初に別のブックを開いておくのは別ですが。
＞横に並んだA1,A2,A3の3つのセルをコピーした際 A1,A2,A3は縦に並んでいます。 状況がよくわかりませんが、貼り付け時に［形式を指定して貼り付け］で ［行列を入れ替える］で縦横の方向が変わります。 このあとえ、これをコピーして他のソフトに貼り付ければいいでしょう。
> メンバーのドロップダウンリスト(５人分)は、Ａ5からＡ149の全ての行に なるほど、条件がつながりました。じゃあやっぱりSUMIF関数でできます。 まず入力とは別の場所、例えばセルF5にもその5人の集計用ドロップダウンを作ってください。で、式はこうなります。どこに入れちゃっても構いません。 =SUMIF(A5:A149,F5,D5:D149) なんとなく意味が解るかと思いますが、セルA5:A149が検索対象で、セルF5が検索条件です。検索対象と検索条件が一致する行があれば、セルD5:D149の中からその行が合計対象として選ばれます。
売上管理シートに作業列を設ける。 たとえばD列に、来店有無という項目を作る。 D2セル: =IFERROR(MATCH(B2,来店管理!B:B,0),"") 下に引っ張る。 こうすれば、来店のあった顧客には２以上の数値、来店履歴のない顧客は0と判別できます。 あとは売上管理でCOUNTIFS関数。 条件1には店舗名、条件２には、来店有無が>0。 ただし、この方法は、A店に来店記録がある顧客がC店で買ったケースなども含まれます。 それがまずいなら、店舗名と顧客コードを&で連結したうえで上の処理を。 A1010101 と、C1010101 を区別するといことです。
たびたびすみません。 No.7の続きです。 A1のセルが正しく「NG」と表示されている時に、No.7のマクロを実行したら、 セル内が「NG」になって数式が消えてしまいました。 自動化した場合、A1のセルの表示が数式のままか、数式の結果かを確認できないので、 No.7のマクロは危険ですね。 すみませんでした。
#1の回答者です。 >どのPCでもこのファイルを開いたときは自動更新されるという理解で良いですか？ いいえ、リンク元だけが、開いた時に更新されます。リンク先は、リンク元のデータを呼びたすだけですから、リンク元が更新されていれば、その値を呼び出します。リンク元が更新されていなければ、リンク先も、更新されていない値を呼びこむだけです。 >PC端末への設定ではなく、ファイルへの設定ということでしょうか。 PC端末というのは何を指すかはわかりませんか、全ファイルへの設定ということになります。 おそらく、元のご質問には叶っているかとは思いますが、#2様の回答の、個別のファイルへの設定としては正しいかと思います。
パソコンに、今回は作業内容が2件と云う事とどうやって知らせる事が出来るでしょうか。 キー操作だけで行うのであれば、作業内容5までエンターキーを押すしかないと思います。 もし、2件で終了であれば、マウスを使って入力ボタンを使って、パソコンに終わりを知らせる事になります。 後は、考え方です。全てをキーボード入力にするか マウス操作にするかです。 時代の流れで云えば、マウス操作です。 顧客コード、件名、作業内容などすべてのリストを準備します。 ＴｅｘｔＢｏｘも全て、コンボボックスにします。 操作を全てマウスにしてしまえば、今回の問題も解決すると思います。 他、先に回答しましたように、作業内容を1件入力したら、 そのたびに入力ボタンへ移動して、エンターキーを押して登録させていくかですね。 注 先に回答に RnageとRangeのスペルミスが多数ありますので編集の上、ご確認ください。
以下でどうなりますか Option Explicit Public Sub Samp1() 　　Dim dic As Object, dicE As Object 　　Dim vA As Variant 　　Dim sS As String 　　Dim i As Long, j As Long 　　Const CMK As String = "☆" 　　Set dic = CreateObject("Scripting.Dictionary") 　　Set dicE = CreateObject("Scripting.Dictionary") 　　With Worksheets("管理票") 　　　　With .Range("A2", .Cells(Rows.Count, "A").End(xlUp)).Resize(, 3) 　　　　　　vA = .Value 　　　　　　For i = 1 To UBound(vA) 　　　　　　　　sS = "" 　　　　　　　　For j = 1 To UBound(vA, 2) 　　　　　　　　　　sS = sS & "_" & vA(i, j) 　　　　　　　　Next 　　　　　　　　If (dic.Exists(sS)) Then 　　　　　　　　　　vA(i, 1) = CMK 　　　　　　　　　　vA(dic(sS), 1) = CMK 　　　　　　　　　　dicE(vA(i, 2)) = Empty 　　　　　　　　Else 　　　　　　　　　　vA(i, 1) = Empty 　　　　　　　　　　dic(sS) = i 　　　　　　　　End If 　　　　　　Next 　　　　　　.Columns(1).Offset(, 6).Value = vA 　　　　End With 　　　　If (dicE.Count > 0) Then 　　　　　　.Activate 　　　　　　MsgBox "下記の管理番号が重複しています" & vbCrLf & vbCrLf _ 　　　　　　　　　　& Join(dicE.Keys, vbCrLf) 　　　　End If 　　End With 　　Set dic = Nothing 　　Set dicE = Nothing End Sub 重複チェックする部分を vA に読み込みます （A2 ～ A最終行範囲の３列分） 行単位で１つの文字列 sS を作成して（列間に "_" ） その文字列が dic にあるか確認して ・あったら、 今の行と dic に覚えていた行の１列目に ☆ メッセージ用に管理番号を dicE のキーとして覚えておく （同じ管理番号が何度も重複して出現した際に１つにするため） ・なかったら 今の行を覚え、１列目をきれいに（ Empty ）しておく これは、結果出力用に vA １列目を使いまわしするため （そもそも vA の内容は dic に覚えてしまうと不要になるので） 上記処理が終わったら、 >　　　　　　.Columns(1).Offset(, 6).Value = vA １列目基準の Offset で G 列指定して 結果出力 ３列ある vA を代入しても左辺は１列分しかないので１列分だけ出力 シートへの書き出しは、この１回だけなので Application.ScreenUpdating での描画云々は不要と思います dicE の中身がカラでなかったら重複があったことになるから 管理票を見せつつメッセージの出力 ってな流れになります
＞範囲で名前を定義した時の空白をリストに表示させない方法、あるいは可変範囲の名前でエラーを解消する方法のどちらかで良いので教えてください。 別案ですが、名前は定義せず「データの入力規則」の「リスト」に式を入れるだけの方法もできます。 セルG13をアクティブセルにしておき、「データの入力規則」の「リスト」に =OFFSET(A13,0,0,1,COUNTA(13:13))　の式を入れます。 次にセルG14をアクティブセルにして、同じく、「データの入力規則」の「リスト」に =OFFSET(A14,0,MATCH(G13,A13:E13,0)-1,COUNTA(OFFSET(A14,0,MATCH(G13,A13:E13,0)-1,100,1)),1)　の式を入れます。（100行目まで対応できる式です。） これでセルG13とG14のドロップダウンリストが連動されますので試してみてください。 ＜注意＞セルG13をドロップダウンで変更した場合は、必ずセルG14も変更すること。
スマホのソフトがアップルでは回答がつかないと思いますよ。 アップルのiphoneを使ってるということですか？ もしくはさらにiphoneの上でアップルのnumbersを使ってるということですか？ iphoneだけど、MS Officeを使ってますか？ もはや、めったに顔を会わさない同僚の方に聞いたかもしれませんが。
こんにちは。 直してみました。 原因は、TypeOf は、そのオブジェクトの上位のクラスを読むものですが、他ブックからですと、共有していませんから、そのクラスを見つけることができないからだと思います。間違った考えかもしれませんが、例えでいうなら、親が誰かわかっているところで、その子供の親を識別できるけれども、子供だけだと、誰の親か分からない、という所ではないでしょうか。 '// Sub Check_Off_All() 'No. 9059904 　Dim ctrl As Object 　Dim wsKitReq As Worksheet 　Set wsKitReq = Workbooks("帳票.xlsx").Worksheets("sheet1") 　'コントロールツール(OleObjects) 　For Each ctrl In wsKitReq.OLEObjects 　If TypeName(ctrl.Object) = "CheckBox" Then 　　ctrl.Object.Value = False 　End If 　Next ctrl End Sub '決まった所にチェックを入れる Sub Test2b() 　''No. 9059904-2 　　Dim i As Variant 　　Dim wsKitReq As Worksheet 　　Set wsKitReq = Workbooks("帳票.xlsx").Worksheets("sheet1") 　　For Each i In Array(1, 3) 　　　　wsKitReq.OLEObjects("CheckBox" & i).Object.Value = True 　　Next i 　End Sub '/// 参考： https://msdn.microsoft.com/en-us/library/s4zz68x …
こんにちは。 >sScriptFile = "C:\Desktop\UWSC.exe　test.UWS" UWSC.exe は、場所ははっきりしていますが、test.UWS のスクリプトのファイル自体は、どこにあるのでしょうか？ 以下は、私が使っていたものです。ダブルクォーテーションの付け方が面倒なので、ショートネームにしてあります。 Sub UWSC_clip() '単発 Dim Fname As String Fname = ThisWorkbook.Path & "\regtry2.uws" Shell ("C:\PROGRA~1\UWSC\UWSC.exe /L" & Fname) End Sub 一般的な書き方ですと、たぶん以下のようになるはずです。試してみてはいません。 Shell """C:\Program Files\UWSC\UWSC.exe /L"" """ & ThisWorkbook.Path & "\regtry2.uws""" Lオプションは、「UWSC本体にファイルを読み込ませるのみ」 なお、できれば、uws　のスクリプトは、記録のままにしないで、コードは整えたほうがよいかと思います。VBAを多少書ける人なら、自分で作れます。また、その置き場所は、My　Documents 等の自分の管理の範囲に置いたほうがよいです。
》 オートフィルタの昇順にて並べ替えをしても、同じ 》 （と見えた）データがと前後に並んできません そういう場合を経験したことがありません。 なるほど、そういうデータの場合なのかぁ~、と納得したいので、具体例を幾つか挙げてみてください。
こんばんは。 作業用ファイルのセルを、ActiveSheet の C5だと解釈しましたが、そうでないなら、 Fname = Worksheets("作業").Range("C5").Value のようにシートを特定したほうがよいでしょう。 以下の「開いている模様」という表現は少し変なのですが、ブックが非表示になっていると、開いているか分からなくなるからです。 万が一、呼び出しでエラーが出る時は、オプションの設定に特別な状態になっていることがあります。 '//(一般的に標準モジュール用です) Sub OpenExcelFile() 　Dim Fname As String 　Dim wb As Object 　Fname = Range("C5").Value 　Range("C5").Select '視線をこのセルに向かせるため 　'ファイル名があるかどうか調べる 　If Not Fname Like "*.xls?" Then 　　MsgBox "ファイル名は拡張子を含めて入力してください。", vbExclamation 　　Exit Sub 　End If 　'このブックと同じフォルダに目的のファイルがあるか調べる 　If Dir(Fname) = "" Then 　　MsgBox "このブックと同じフォルダには、'" & Fname & "'はありません。", vbExclamation 　　Exit Sub 　Else 　　'すでに開いているか調べる 　　For Each wb In Workbooks 　　　If wb.Name = Fname Then 　　　　MsgBox "すでに'" & Fname & "'は開いている模様です。", vbExclamation 　　　　wb.Activate 　　　　Exit Sub 　　　End If 　　Next wb 　End If 　Workbooks.Open Fname End Sub '///
Office OnlineのExcelとローカルにインストールされたExcelとの違い https://support.office.com/ja-jp/article/%E3%83% … できないことの例 https://speedland365.wordpress.com/2015/01/13/%E … http://pcclick.seesaa.net/article/398184214.html http://raku2.ucom.ne.jp/topic3/20140320.html >セルの列選択 Ctrl+スペース 行選択の方は日本語入力がオフの状態でShift+スペース。 >セルの全選択 上記の応用で、日本語入力オフの状態でShift+スペースの直後にCtrl+スペース（逆でもOK） >画像の挿入 たぶんできません。
＞社内のファイルサーバーに配置されているExcelファイル（共有）を2,3人で同時に使用しています。 最初に開いた端末に上書き権限が渡されます。使用中のファイルを次の人が開こうとすると「使用中、参照で開く」というメッセージが出たと思います。最初に開いた人が上書きして終了後のファイルを次の人が開かない限り、上書き保存はできないようになっています。 理由は作業後の上書きが別の人の作業上書きで消滅しないようにしているからです。 解決方法は同時に同じファイルを開かないようにするだけです。
こんにちは。 シート名修正マクロって、結構むつかしかったと思います。 以下のようなちょっとひねったマクロでないといけないかもしれませんね。 >シート１のA６からA２０までの各セルに入力した名前 >誤って入力したシート２～２０までのシート名に シートの数が合いませんが、それはいいとします。 '// Sub SheetNaming() Dim c As Range Dim i As Long, j As Long Dim rng As Range 'ここは任意で変更してください。 Set rng = Worksheets("Sheet1").Range("A6:A20") On Error GoTo ErrHandler i = 2 'シート2から 　For Each c In rng 　 If i <= (rng.Rows.Count + 1) And i <= Worksheets.Count Then 　　 Worksheets(i).Name = c.Value 　　 i = i + 1 　 End If 　Next c Exit Sub ErrHandler: 　j = j + 1 　Worksheets(i).Name = "Temp" 　Worksheets(c.Value).Name = "Temp" & CStr(j) 　Resume End Sub
順位をRANK関数で決めて、その順位に相当する名前をINDEX関数とMATCH関数で取り出します。 http://freett.com/comet333/excel-124.html は考え方の一例。質問の例とは行と列が違っていますのでROW関数の代わりにCOLUMN関数を使うことになります。 "Excel 順位 RANK MATCH INDEX" をキーワードにGoogleなどで検索を。
こんばんは！ 必ずA列から範囲指定するとします。 一例です。 Sub Sample1() Selection.Sort key1:=Selection(5), order1:=xlAscending, Header:=xlNo End Sub こんな感じではどうでしょうか？m(_ _)m
Excelのバージョンと入れた式を書いてもらえますか？ 後、何のエラーが出ますか？
申込日に40を足した月の 25日よりも小さい日付ならその月の25日（25日までの日数を加える） 25日よりも大きい日付ならば翌月の25日（40日後の一週間後…翌月…の25日までの日数と７日を加える） のロジックで求められる。 E5には =D5+40 と入力されているようなので F5には ＝IF(DAY(E5)<=25,E5+(25-DAY(E5)),(E5+7)+(25-DAY(E5+7))) で良いと思う。 ただし未検証。
No.1・2です。 ＞頂いた第2弾を試してみましたが、特定の文字に関わらず ＞行全体がオートフィルターにより、非表示となってしまいました。 ん～～～ ①　フィルタを掛けている列番号はBZ列に間違いないのでしょうか？ 他の列だとデータすべてが非表示になってしまいます。 ②　BZ列に「TRUE」と完全一致するデータが全くない！ この場合もすべて非表示になります。 考えられる原因としてはこの程度なのですが・・・ ※　「TRUE」を含む　という条件の場合は全く違ったコードになってしまいます。 実際の表のレイアウトがこちらでは判らないので この程度くらいしか思い浮かびません。m(_ _)m
最初に、 >マクロは殆どわかりませんので 謙遜しておっしゃっているのか、コードがあったら、それをVBEに、標準モジュールに貼り付けられる程度か、それとも、記録マクロを取って、それを再度使えるレベルなのか、とか様々なのです。 最近、ここらの度合いが分からなくて、没になるケースが出ています。 それにも関わらず、分っていて書かれたのかもしれませんが、ご質問のレベルは初級ではないようですね。 私の拙いマクロコード書くと、これじゃいけないと、後に付ける人もいるのかもしれませんが、やってみました。 '// ''Option Explicit Dim col As Long Dim cnt As Long Dim max As Long Sub Main() Dim mPath As String mPath = "C:\Users\[you name]\My Documents\ If Right(mPath, 1) = "\" Then 　mPath = Mid(mPath, 1, Len(mPath) - 1) End If '初期値 　col = 1 　cnt = 0 FolderSearch mPath '最後に列幅を調整 Columns("A").Resize(, max + 1).AutoFit End Sub Sub FolderSearch(ByVal Path As String) Dim flg As Boolean Dim objFS As Object Dim objF As Object Dim fn As String Set objFS = CreateObject("Scripting.FileSystemObject") 　　Dim buf As String, f As Object 　　fn = Dir(Path & "\*.dwf") ' 　　If flg = False Then 　　　'フォルダ名 　　　cnt = cnt + 1 '1行開け 　　　Cells(cnt, col).Value = Mid$(Path, InStrRev(Path, "\", -1) + 1) & "---" 　　　col = col + 1 　　　If col > max Then max = col 　　End If 　　Do While fn <> "" 　　　　Cells(cnt, col).Value = fn 　　　　Set objF = objFS.getfile(Path & "\" & fn) 　　　　'更新日 　　　　Cells(cnt, col + 1).Value = objF.DateLastModified 　　　　cnt = cnt + 1 　　　　fn = Dir() 　　　　flg = True 　　Loop 　　For Each f In objFS.GetFolder(Path).SubFolders 　　　 Call FolderSearch(f.Path) 　　Next f 　　col = col - 1 End Sub '///
こんばんは。 >セル30個って事ですよね？少なすぎませんか？ 無限だとは言いませんが、セル30個でも1つでは？ カンマを区切れば、それで1つ。 たぶん、それらの引数は、パラメーター配列ではないかと思います。 https://msdn.microsoft.com/ja-jp/library/538f81e …
こんばんは！ すでに数式による回答はでていますので、 Excel2007以降をお使いだとしての一例です。 範囲指定　→　条件付き書式　→　セルの強調表示ルール　→　指定の範囲内　→　↓のような画面になりますので、 左側の窓に =1 右側の窓に =today() とし　→　書式から好みの色を選択しOK これでも大丈夫だと思います。 ※　本日のシリアル値以下の数値すべてに色が付きます。 （今日の場合は　42248　以下）m(_ _)m
2行めから130行め、行全体の指定ではないかと。
こんにちは。 すみません、返事が遅くなってしまって。 あれこれと考えている間に日にちが過ぎてしまいました。 >この色を[標準の色]の左から４番目の既定値に変更するには、貴方が仰るように「今の段階では、マクロになってしまいます」ということなのですね？ それは、なんとも言えないのです。私は、VBAマクロ中心でやってきたから、そう思うにすぎないかもしれないからです。海外の英語系の掲示板でも、VBAマクロでの解決をしていますが、それは手っ取り早いからだと思います。 >[クイックアクセスツールバー]に登録できないか？ リボンのカスタマイズの範疇になるのではないかと予測は立てたものの、今の私は、そちらの方面は、ほとんど手を付けなかったので、まったく素人同然です。Web で可能なら、こちらでも可能なような気がするのです。 mikeさん側でも、一度、研究してみるとよいとは思います。いわゆる xml の技術なのですね。掲示板でも時々見られるようになりました。以前は、UI Custom Editor とかいうものを使っていましたが、今は、Office Ribbon Editor というもので、それで、QAT(quick access toolbar)の加工も出来るようなのです。しかし、昨日今日、アプリをインストールして触っているだけでは、見当もつきません。 コマンドコントロールのプロパティの色は、どういうわけか古いカラーインデックスを使っていますから、それが利用できればよいのですが、その色を、転用するということは、今のところ、VBAマクロ以外には考えられません。 ただ、その解説を探している過程で、ちょうど、以下のアドインを見つけました。 Excel 2003 カラーパレット・改 http://www.vector.co.jp/soft/dl/winnt/business/s … 展開した後のアドインファイルは、以下の場所にいれます。 C:\Users\[ユーザーID]\AppData\Roaming\Microsoft\AddIns\ このアドイン自体は、リボンのカスタマイズとマクロを応用したもののようです。イントールして動かしてみましたが、あっというほどのものではありませんでした。
[No.4お礼]へのコメント、 》 グループ分けをしてからピボット化する方法ですね？ いえ、ピボット化してから、グループ分け＆空白外しをしました。
こんにちは。 一般的には、テキストファイルは、Unix系 の　Grepというツールで処理されるものです。それを特化したものが、KWIC と言います。(KWIC Finderは、同種ですが、シェアウェアです) http://www.tanomura.com/research/KWIC/ このKWIC は、大学を中心として、出ているフリーのツールですが、あえて、VBA等で作るまでには及ばないような気がしています。私自身は、特殊なgrep を、Excelに組み合わせて使っていますが、何百というテキストファイルの中から該当行を探すようなことをしています。最後はExcelが立ち上がります。 あえて、マクロということですと、今、ざっと作ってみましたが、このようなものになります。細かい検証をなされていませんが、現在は、 '検索文字　の下の、="this is" の所に文字を入れれば良いようになっています。 試してみた文章は以下の所で、検索文字 ="this" http://learningenglish.voanews.com/content/are-y … 結果は、このようになります。 This is because the word smart has many meanings. This means they have spent many years in school. This definition of smart can also be used as a verb. And this leads to the term “Smart Aleck". フォームボタンなどに、このマクロを設置すると良いと思います。最初に、ファイルオープンダイアログが開きますので、それで、ファイルを選択します。複数ファイルを選ぶことが可能です。出力は、アクティブシートの2行目から、ファイル名が最初に貼り付けられ、その後、検索行が、一行ではなく、ピリオドを単位として出てきます。この点が、KWICやGrepとは違う点です。 なお、本日、集中度0に近く最悪のコンディションで、ほとんど、考えてコードは書かれていません。ミスがあるかもしれません。もし問題がありましたら、明日にでもお返事ください。 '// Sub FindWordinText() 　Dim Fnames As Variant 　Dim fn As Variant 　Dim FNo As Integer 　Dim TextLine As String 　Dim arTxt, n, m, arbuf 　Dim i As Long 　Dim strFND As String 　Dim qt As String 　qt = Chr(34) 　'検索文字 　strFND = "this is" 　strFND = Replace(strFND, Space(1), Space(1), , , vbBinaryCompare) 　'出力の最初の行 　j = 2 　 　Fnames = Application.GetOpenFilename(FileFilter:="テキスト(*.txt),*.txt", MultiSelect:=True) 　If VarType(Fnames) = vbBoolean Then Exit Sub 　For Each fn In Fnames 　　FNo = FreeFile() 　　Open fn For Input As #FNo 　　Do While Not EOF(FNo) 　　　Line Input #FNo, TextLine 　　　If InStr(1, TextLine, strFND, 1) > 0 Then 　　　　buf = buf & vbCrLf & TextLine 　　　End If 　　Loop 　　Close #FNo 　　arTxt = Split(buf, vbCrLf) 　　Cells(j, 1).Value = "*" & Dir(fn) 　　j = j + 1 　　For Each n In arTxt 　　　If Trim(n) <> "" Then 　　　　If InStr(1, n, "." & qt, 1) > 0 Then 　　　　　'dot in quotations 　　　　　n = Replace(n, "." & qt, "#.", , 1, 1) 　　　　End If 　　　　If InStr(1, n, ".") > 0 Then 　　　　　arbuf = Split(n, ".") 　　　　　For Each m In arbuf 　　　　　　If InStr(1, m, strFND, 1) > 0 Then 　　　　　　　'retrieve quotation mark 　　　　　　　m = Replace(m, "#", qt, , 1, 1) 　　　　　　　Cells(j, 1).Value = Trim(m) & "." 　　　　　　　j = j + 1 　　　　　　End If 　　　　　Next m 　　　　　Erase arbuf 　　　　Else 　　　　　Cells(j, 1).Value = Trim(n) 　　　　　j = j + 1 　　　　End If 　　　End If 　　　buf = "" 　　Next n 　　j = j + 1 　Next fn End Sub
ANo.2、もうひとつ手があるのを忘れてました。自分でも使った事がある手なのに… 　補助目盛はなしにする。そして、データ系列(0.01,0), (0.02,0),…,(0.09,0)を同じ散布図に一緒にプロットする。 　そのマーカの形を[ + ]にし、塗りつぶしなし、影なし、色は軸の色と同じにする。サイズをかなり小さくする。 　軸の線の太さをちょっと太めにする必要があるかも。
SUM は、最初、SUMMARY だと私も思っていました。しかし、Summary には、「合計」という意味はなく、要約するという意味です。現在、私自身は、数学用語の、SUMMATION =Σ　(総和、合計)という語の省略形だと思っています。 Summation (サメイション)　[数学用語] the total amount or number when two or more things are added together. [2つまたはそれ以上のものを一緒に加えた時に、その合計値または数値のこと] ただ、この命名は、Microsoft ともロースタ社とも関係がなく、1970年代の後半、ハーバード大学ビジネススクールの学生、ダンブルックリンらによるもので、彼らはパテントなどの主張も出来ずに、大手の会社に取り入れられてしまい、その時のものが現在まで流用されています。したがって、誰も、その語源に対して主張ができません。 1980年代に、IBMから出ていた表計算の本に、SUM関数の出来た秘話も読んだことがあります。学生さんが、教授が、授業中に何度も黒板を書いたり消したりするのをみて、PCで、できたらと考えたそうです。当時、すでに大型コンピュータには表計算は存在していましたが、PCにはありませんでした。計算範囲の中に、文字列を入れても、エラーを出さずに、合計が出せるという所が、この関数の特徴です。
キーボードからCtrl+Xと入力してできないのであればフットペダルに割り当てたキーマクロを使っても無理。
私もひとつ思うのですが、 ダブルクリックして、シートを移動した後、元のシートに戻るマクロも必要になると思いますが ならば、一例ですが F5セル辺りに、入力規則などで、名前を選択 =INDIRECT関数で指定したシートの上表を表示させた方が便利ではないでしょうか。 仮に、F5セルにシート名を選択したとして、F6セルに =INDIRECT(F5&"!B2") とすれば、選択したシートのB2セルが表示されます。 同様の関数をコピーして必要なシートの情報を表示させます。
No.5です。 補足を読ませていただきました。 区分が多く、規則性がない場合はNo.6さんのように VLOOKUP関数のTRUE型が良いと思います。 （対応表の変更だけで、数式に手を加える必要がないため） 回答した手前、数式だけで処理する場合は =A1*INDEX({0.47,0.44,0.28,0.25,0.24,0.22,0.21,0.2},MATCH(A1,{0,15,20,25,30,35,50,60},1)) という数式を入れてみてください。 ※　やはり対応表を作成した方が簡単ですね。m(_ _)m
＞特定の列について、 ・「日付」が記載された場合は黄色 ・「行方不明」と記入した場合は赤、の二つにパターンを設定・・・。 予め特定の列を先に選択しておきます。 ①条件付き書式→「ルールの管理」を選択し、左上の「新規ルール」をクリック。 ②一番下の「数式を使用して、書式設定するセルを決定」を選択。 ③数式入力欄に　=A1>0　の式を入れ、「書式」より「塗りつぶし」タブを選択し黄色を選択後「OK」→「OK」 ④「条件付き書式ルールの管理」画面に戻ったら、再度「新規ルール」をクリック。 ⑤一番下の「数式を使用して、書式設定するセルを決定」を選択。 ⑥数式入力欄に　=A1="行方不明"　の式を入力し「書式」より「塗りつぶし」タブを選択し赤を選択後「OK」→「OK」→「OK」で閉じます。 後は日付か「行方不明」の文字を入力するとセルに設定した色が塗られます。
こんばんは！ 一例です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub 非表示() 'この行から// Dim i As Long, k As Long, myRow As Long Dim myRng As Range, myAry As Variant myAry = Array(19, 22, 25) '←S・V・Y列の列番号を格納// For k = 0 To UBound(myAry) For i = 4 To 29 If Cells(i, myAry(k)) = "" Then Select Case k Case 0 myRow = 1 Case 1 myRow = 3 Case Else myRow = 5 End Select If myRng Is Nothing Then Set myRng = Cells(i * 6 + myAry(k) - myRow, myAry(k)) Else Set myRng = Union(myRng, Cells(i * 6 + myAry(k) - myRow, myAry(k))) End If End If Next i Next k If Not myRng Is Nothing Then myRng.EntireRow.Hidden = True End If End Sub 'この行まで// ※　再表示のコードも必要だと思いますので、 同じVBE画面のコードが記載されている下側に↓のコードを追加し、 行を再表示したい場合は「表示」のマクロを実行してください。 Sub 表示() ActiveSheet.Rows.Hidden = False End Sub ※　Changeイベントではありませんので、データ変更があるたびに 手作業でマクロを実行してください。 こんな感じではどうでしょうか？m(_ _)m
8：10を8：11にしたりしてませんか？ A3とA4は手入力でしょうか？それとも式で出してますか？
ANo3です。 捕捉を3回ほど読み直しましたが、わかりませんでした。 どうやら、同じ言葉であっても、それに対する概念がお互いに違うようです。 もしかすると、横軸は0.1刻みでかつ等間隔でいいってことなのでしょうか？ もしそうなら、ごく普通のXY軸のプロットなので、何の問題もないことになっちゃうけど・・・？
A2セルからA20001セルまでを選択して、 ＝E2="○" で可能だ。 この式を直接入力すると "＝E2="○"" のように文字列として認識されてしまうことがあるので入力後に再確認をして、文字列になっているようなら修正すれば正しく動作する。 ＝IF(E2="○",TRUE,FALSE) でもよい。
歴史的問題からそうなります。 平方メートル記号はJISコードには存在せず、NECが独自でJISコードの空き領域に追加したものが起源で（いわゆる機種依存文字）、これがそのままWindowsに引き継がれました。立方メートル記号はと言えば、これはUnicodeで初めて登場し、オリジナルJISはもちろん機種依存文字の中にもありませんでした。 と言うことで、CODE関数はUnicodeがなかった当時からあるため、戻り値はJISコードで返すようになっていますが、前述のとおりで立方メートル記号はJISコードの中にないから、変換失敗の？（コード番号63）を返します。他にも、Unicodeにあるが、かつてのJISコードにはない文字をCODE関数に通すと、同じ現象になるはずです。記号だとトランプのマーク、丸付き数字の21以上、登録商標RやコピーライトCなんかもそうですね。 実はUnicodeでもASCIIコードと重なる部分は共通になっているので、10進で？のコードを表現すると、どちらも63になります。ただしUnicodeは全ての文字コードが2バイト長なので、コードの戻り値は全角半角を問わず常に2バイトです。処理によっては影響があるかも知れません。
PrintAreaを複数設定し、それぞれに対してZoom倍率を変更すれば可能です。 一度1ページ目でも2ページ目でも倍率を変更して印刷する行程をマクロ記録などで記録を取れば、記述の内容もわかるでしょう。 あとは1ページ目の印刷のマクロと2ページ目の印刷のマクロをつなぎ合わせるだけです。
＃３です 以下訂正です >　　Application.ScreenUpdating = True >　　Worksheets.Add ↓ 　　Application.ScreenUpdating = False ' ★ 　　Worksheets.Add
If Target.Column = 3 Then を If Target.Column = 3 Or Target.Column = 5 Then にしてみては如何でしょうか。
モニタキーボードが、表示ができるのでしたら可能です。 でなければ、マウスやキーボードを操作です。 また、ソフト自体にも対応していないと、宝の持ち腐れです。
こんにちは。 atom_28さんのコンセプトからすれば、私の書いたものは、意図しているものとは違うかもしれません。そのときは、また別なものを考えましょう。 >PS. 勿論、このままでは、セルA1には、未来永劫、値を入れることはできません。 >　　他のルーチンにて「Application.EnableEvents = False」を設定して >　　入力を可能としております。 数式入力の状態は、マクロは待機状態になります。この時に、変更が出来てしまいます。 以下の話は、もう少し筋道建てれば分かりやすくなるのですが、とりあえず、②のカスタムプロパティ側から読んでみてください。 ①　SheetChangeの場合 >intersectの意味することから考えると、[Enter]が入力された後に起動されているような気がするし。 その通り、[Enter]で起動しています。 SheetSelectionChangeは、本来、移動した時にイベントが発生しています。これも、誤解しやすいのです。 Not Intersect(Target, Range("A1")) Is Nothing この意味は、二重否定ですから、すぐに分からりづらいです。なぜ利用したかというと、ピンポイントで削除は他の方法でも防げることでも、そこを含めた広い面を、消去(delete)などされると、プロテクト(保護)を掛けてない限りは、一般的には防ぐことはできません。 これは、行の削除でも対応します。 話が前後していますが、②のカスタムプロパティを利用したマクロを考えてみました。一例です。 '標準モジュール Sub Auto_Open()　'ファイルを開いた時に設定 Dim Dummy As Variant 　 On Error Resume Next 　With ThisWorkbook　'カスタムプロパティに入っているかチェック 　　Dummy = .CustomDocumentProperties("DataORG").Value 　If Err() = 0 Then　'入っていれば次へ 　　GoTo EndLine 　End If 　End With 　 With ThisWorkbook.CustomDocumentProperties 　　　 .Add Name:="DataORG", _ 　　　　　　LinkToContent:=False, _ 　　　　　　Type:=msoPropertyTypeString, _ 　　　　　　Value:="SettingName"　'設定された文字 　　End With EndLine: 　　Call ThisWorkbook.SetData　'標準モジュールから、Private 変数は設定できません。 　　On Error GoTo 0 End Sub 'ThisWorkbook モジュール 'Private DataORG As String '前回の続きなら、すでに変数はあるはず。 Sub SetData()　'Private 変数に設定 　DataORG = ThisWorkbook.CustomDocumentProperties("DataORG").Value End Sub ②「カスタムプロパティ」とは、「プロパティ」の詳細プロパティの中のユーザー設定 https://support.office.com/ja-jp/article/Office- … プロパティに製作者や会社名を入れますが、自分の作った項目も登録できるようになっています。今回の全体の流れからすると、コンセプトが違いすぎるかもしれません。レジストリを使おうかと思う時に、こんな便利なものがあるということを思い出していただければよいかと思います。 サンプルマクロを紹介します。なお、他にも、隠しデータを入れる場所はいろいろあります。VeryHiddenのシートの中にデータを置いて使っている人もみかけます。 「静的(static)に保管」というのは、当たり前ですが、保管しても定数として消えていないことです。セルですと、消してしまうことがありますが、プロバティは知っていて行わなければ消えません。 サンプルマクロ '// Sub TestForCustomDProperties() '初めての登録 　 On Error Resume Next 　 With ThisWorkbook.CustomDocumentProperties '--アクティブブックに対して 　　　 .Add Name:="テーマ", _ 　　　　　　LinkToContent:=False, _ 　　　　　　Type:=msoPropertyTypeString, _ 　　　　　　Value:="イベント型マクロ"　　　　　 '--文字列型のプロパティ 　　　　.Add Name:="ログ番号", _ 　　　　　　LinkToContent:=False, _ 　　　　　　Type:=msoPropertyTypeNumber, _ 　　　　　　Value:=9050730　　　　　　　　　　　 '--数値型のプロパティ 　　　　.Add Name:="登録日", _ 　　　　　　LinkToContent:=False, _ 　　　　　　Type:=msoPropertyTypeDate, _ 　　　　　　Value:="2015/08/23"　　　　　　　　　　'--日付型のプロパティ 　　End With 　　If Err() <> 0 Then MsgBox Err.Description 　　On Error GoTo 0 End Sub Sub OutputProperties() Dim myTheme As String Dim LogNum As Long Dim tDate As Date '出力 　With ThisWorkbook 　 myTheme = .CustomDocumentProperties("テーマ") 　 LogNum = .CustomDocumentProperties("ログ番号") 　 tDate = .CustomDocumentProperties("登録日") 　End With 　MsgBox myTheme & vbCrLf & LogNum & " :　" & tDate End Sub Sub ChangePropertyies() Dim myTheme As String '修正用 　With ThisWorkbook 　 .CustomDocumentProperties("テーマ").Value = "SheetChange とSelectionSheetChangeについて。" 　End With 　Call OutputProperties End Sub
No.3 です。 > エクセルのファイルを開く都度、タップのツールに成っています。これをホームで開けるように出来ませんか？。 多分、「タッチ」タブを非表示にすると、起動時、「ホーム」タブが表示されると思います。 下記URLのページをご覧になってお試し下さい。 （「タッチ」タブの存在を今日初めて知りました。） 「OFF2013 タッチ タブを非表示にする」 http://office-taku.com/201406/msoffice/7488.html > それと画面が縮小されて開きます、ネット画面でも同じです。 初めは、画面表示の拡大率の問題かと思いましたが、Excelとブラウザの画面が同じだということは、プログラムの実行時のサイズが「通常のサイズ」で開いているのだと思います。 その場合は、下記URLのページをご覧になってお試し下さい。 「Windows 8.1でプログラムを常に最大化して開く方法」 http://121ware.com/qasearch/1007/app/servlet/rel …
1.時間の書式は【時刻　13:30】 (13:30は例なので、値はこだわらない) 2.金額の書式は【数値】　　　　(\記号を付けるなら、【会計】にする) 3.支給額の計算式＝時間×24×時給 　【時間に24を掛けることをわすれないように!】
こんばんは。 1つの数式で表現するには無理がありますね。ご質問者さんは、掲示板で、そうしたテクニックを学んだのでしょうけれども、そういう数式は、掲示板特有の数式のようです。もちろん、私の以下の最初の数式も同様ですが。 Sheet2 A列には、 りんご オレンジ バナナ とし、B1から、数式を貼り付け、右へドラッグコピー。下にドラッグコピー =IF(COUNTIF(Sheet1!$A$1:$A$20,$A1)>=COLUMN(A1),INDEX(Sheet1!$B$1:$B$20,INDEX(SMALL((Sheet1!$A$1:$A$20=$A1)*ROW($A$1:$A$20),COUNTIF(Sheet1!$A$1:$A$20,"<>"&$A1)+COLUMN(A1)),,)),"") なお、Sheet1 のC列は使用していません。 本当は、もう少し簡単な方法があると思います。 例えば、D1 に、「りんご」書いておいて、 =IF($A1=$D$1,ROW(),"")　と入れて、下の適当な位置まで、ドラッグコピーし、全部出てきたら、 Sheet2 で、このようにすれば、出てきます。 =INDEX(Sheet1!$A$1:$B$20,SMALL(Sheet1!$D$2:$D$12,COLUMN(A1)),2) りんごの次は、E1, F1 にオレンジ・バナナと続きます。 実務上は、#3さんがご指摘のように、確かに、フィルターオプションで十分ですね。
No2です、 ごめんなさい、4:30~5:15部分が未検証のまま回答してしまって間違っていました。
下半分（J6,J7,J8）がうまくいかなかった原因は、デフォルト設定の値の範囲のせいです。 デフォルト設定の区分は、100～67%、67～33%、33～0%　であるため、近い値が２つと離れた値が１つの場合、そのようになってしまいます。 対処方法は以下のとおりです。 『条件付き書式』⇒『アイコンセット』⇒『その他のルール』 画面下段の範囲設定で以下のように入力すればOKです。（添付画像参照） 一番上：　">="　　"100" 真ん中：　">"　　　"0" 一番下：　設定項目なし 書式のみ貼りつけを行えば、繰り返しの作業も可能です。
・軽油税の数量セル ＝SUMIF(A:B,"*軽油税*",B:B) 　→多分1個しか当てはまらない 「セルの書式設定」-「表示形式」を「ユーザー定義」「(G/標準)」とする 　↑カッコをつけるため ・軽油の数量セル ＝SUMIF(A:B,"*軽油税*",D1:D10,E1:E10)-SUMIF(A:B,"*軽油税*",B:B) こんな感じでうまくいきませんかね…
こんにちは。 ご質問が分かりにくいのですが、1列の処理ということでしょうか。 本来、列幅は任意で行えばよいと思いますが、それもマクロですか。 列幅の指定方法が書かれていませんね。 そこで、こういうようにしてみました。 セルに　15.20 区切りは1文字なら、何でも構いません。 15a20でも可能です。 その次のセルから、つまり、数字などの情報を入れた次のセルからで、15行先まで、1,2,3,4,...と数字を入れ、幅は、20ということにしました。 >A3には（２）A4はA2と同じ処理が行われるようにしたいです。 理由は、こういう文章からです。 もし、入力したセルを含めるなら、 ActiveCell.Offset(1) とある所を、 ActiveCell に変えてください。 ボタンでも、ショートカットでも良いかと思います。 '// Sub RailingByLines() 　Dim num As Variant 　Dim numL As Long 　Dim numF As Double 　Dim i As Long 　num = ActiveCell.Text 　If num Like "#*" Then 　　For i = 1 To Len(num) 　　　If Not Mid(num, i, 1) Like "#" Then 　　　　numL = Mid(num, 1, i - 1) 　　　　Exit For 　　　End If 　　Next i 　　If i < Len(num) Then 　　　numF = Val(Mid(num, i + 1)) '数値を取り出す 　　End If 　Else 　　MsgBox "数字がありません。", vbExclamation: Exit Sub 　End If 　 　If numF > 0 Then 　　ActiveCell.EntireColumn.ColumnWidth = numF 　End If 　 　If numL > 0 Then 　　With ActiveCell.Offset(1).Resize(numL) 　　　For i = 5 To 12 　　　　With .Columns(1).Borders(i) 　　　　　.LineStyle = xlLineStyleNone 　　　　End With 　　　Next i 　　　For i = 7 To 12 　　　　With .Borders(i) 　　　　　.LineStyle = xlContinuous 　　　　　.ColorIndex = 0 　　　　　.TintAndShade = 0 　　　　　.Weight = xlThin 　　　　End With 　　　Next i 　　　For i = 1 To numL 　　　　ActiveCell.Offset(i).Value = i 　　　Next i 　　End With 　End If End Sub '/// ちなみに、既存の組み込みのショートカットに、Ctrl + Shift -> _ が、罫線を全部削除しますので、それと合わせて使えばよいかと思います。
失礼しました。 Application.OnTime Now + TimeValue("00:00:15"), "Tset" では15秒間隔ですね。 Application.OnTime Now + TimeValue("00:05:00"), "Tset" でお確かめ。
C1の式は単純に =A1-B1 この式では不都合があるのですか。
直接SERIES式を書き換える方法 まずC6:S6の折れ線グラフを作成 プロットされた折れ線をクリックして選択 数式バーのSERIES式を確認（下記式の内容は推測です） =SERIES(グラフ!$C$6,グラフ!$D$3:$S$3,グラフ!$D$6:$S$6,1) これは =SERIES(系列名,項目データ,数値データ,プロット順) といった内容です。 数式バーをクリックして編集モードにする C20:S20行のデータ範囲を下記のように書き換え （項目データと数値データそれぞれの複数のセル範囲を ,（カンマ）で区切り、括弧で括る） =SERIES(グラフ!$C$6,(グラフ!$D$3:$S$3,グラフ!$D$17:$S$17),(グラフ!$D$6:$S$6,グラフ!$D$20:$S$20),1) これで離れた複数のセル範囲データが同じ系列で連続してプロットされます。 離れたセル範囲が多過ぎると 数式の長さ 8,192 文字 という制限項目に引っ掛かることがあると思います。
行番号が知りたいだけならMATCH関数でいいのでは？
＃１です まだ閉じられていなかったので･･･ 結果は変わりませんが、チョット記述の修正を >　　　　　　If (i = 0) Then Exit Do １回だけのための判別を毎回やりたくない とか、もうチョットすっきりさせたい >　　　　　　　　　　　　j = j + 1 >　　　　　　　　　　　　n = n - 1 >　　　　　　　　　　　　If ((CNUM - j + 1) >= (i - n)) Then Exit Do >　　　　　　　　　　　　j = j - 1 >　　　　　　　　　　End If >　　　　　　　　　　j = j - 1 で、参考にするのなら以下の方を･･･ Public Sub Samp2() 　　Const CNUM As Long = 9 　　Dim sA(1 To CNUM) As String 　　Dim sDef As String, sChg As String 　　Dim i As Long, j As Long, k As Long, n As Long 　　sDef = Range("A2").Value 　　sChg = Range("A3").Value 　　Application.ScreenUpdating = False 　　With Range("D1").Resize(, CNUM) 　　　　.EntireColumn.Clear 　　　　For j = 1 To CNUM 　　　　　　sA(j) = sDef 　　　　　　.Cells(1, j) = j 　　　　　　.Cells(2, j) = sA(j) 　　　　Next 　　　　k = 2 　　　　For i = 1 To CNUM 　　　　　　j = 1 　　　　　　n = 0 　　　　　　Do While (1) 　　　　　　　　While (n < i) 　　　　　　　　　　sA(j) = sChg 　　　　　　　　　　j = j + 1 　　　　　　　　　　n = n + 1 　　　　　　　　Wend 　　　　　　　　k = k + 1 　　　　　　　　.Rows(k).Value = sA 　　　　　　　　sA(j - 1) = sDef 　　　　　　　　n = n - 1 　　　　　　　　If (j > CNUM) Then 　　　　　　　　　　j = j - 1 　　　　　　　　　　Do While (j > 1) 　　　　　　　　　　　　If (sA(j - 1) = sChg) Then 　　　　　　　　　　　　　　sA(j - 1) = sDef 　　　　　　　　　　　　　　n = n - 1 　　　　　　　　　　　　　　If ((CNUM - j + 1) >= (i - n)) Then Exit Do 　　　　　　　　　　　　End If 　　　　　　　　　　　　j = j - 1 　　　　　　　　　　Loop 　　　　　　　　　　If (j = 1) Then Exit Do 　　　　　　　　End If 　　　　　　Loop 　　　　Next 　　　　With .Resize(k) 　　　　　　.HorizontalAlignment = xlCenter 　　　　　　.Borders.LineStyle = xlContinuous 　　　　　　.Columns.AutoFit 　　　　End With 　　End With 　　Application.ScreenUpdating = True End Sub
こんばんは。 そろそろ、質問を公開してから1週間が経つわけで、気にはしていたので、良く読ませていただきました。 そうすると、いくつかの問題点が見え隠れするのです。 もう少し、自分はここまで作ったけれども、ここが分からないとか、もう少し具体的な形で聞いたほうがよいですね。掲示板は、マクロの作成を依頼するところではありませんから。 1. >A2をクリックしたらA3以降が通し番号で昇順に並び変え。 項目行がないのでしょうか。 あれば、 >B列が”T”以外の行でAJ～AQ列に10000以下 こちらも使えます。 2. >B列が”T”以外の行でAJ～AQ列が10000以上の場合は表示形式を【[$-411]ge.m.d;@】にしたいのです。 10000というのは、どうやら日付らしいと分かりましたが、昭和2年で区分けするというのは、かなり変則的です。できれば、数字よりも日付で探したほうが自然のような気がします。今は、純粋に数字を探しています。 A2 の所は、T を入れれば、起動するように変えました。 '// Private Sub Worksheet_Change(ByVal Target As Range) 　Dim col As Long 　Dim c As Range 　Dim r As Range 　If Target.Count > 1 Then Exit Sub 　If Target.Value = "" Then Exit Sub 　If Target.Address = "$A$1" Then 　　If Target.Value = "個人データ" Then 　　　Columns("L:AQ").EntireColumn.Hidden = False 　　　Columns("L:AI").EntireColumn.Hidden = True 　　ElseIf Target.Value = "会費" Then 　　　Columns("L:AQ").EntireColumn.Hidden = False 　　　Columns("AG:AQ").EntireColumn.Hidden = True 　　ElseIf Target.Value = "OPENSESAME" Then '魔法のことば"(全部オープンにします) 　　　Columns("L:AQ").EntireColumn.Hidden = False 　　End If 　ElseIf Target.Address = "$A$2" Then 　　Application.ScreenUpdating = False 　　If StrConv(Target.Value, vbUpperCase) = "T" Then 'Tが入力されていたら 　　　col = Cells(3, Columns.Count).End(xlToLeft).Column 　　　Range("A3", Cells(Rows.Count, 1).End(xlUp)).Resize(, col).Sort _ 　　　Key1:=Range("A3"), Order1:=xlAscending 　　　For Each c In Range("B1", Cells(Rows.Count, 2).End(xlUp)) 　　　　If StrConv(c.Value, vbUpperCase) <> "T" Then 　　　　　c.EntireRow.Interior.ColorIndex = xlColorIndexNone 　　　　　Set r = Intersect(c.EntireRow, Columns("AJ:AQ")) 　　　　　Call FindNumbertoYear(r) 　　　　ElseIf StrConv(c.Value, vbUpperCase) = "T" Then 　　　　　c.EntireRow.Interior.ColorIndex = xlColorIndexNone 　　　　　c.EntireRow.Interior.ColorIndex = 15 　　　　End If 　　　Next 　　End If 　　　　Application.ScreenUpdating = True 　End If End Sub Sub FindNumbertoYear(ByVal rng As Range) 'サブルーチンマクロ Dim r As Variant Dim c As Range 　On Error Resume Next 　Set r = rng.SpecialCells(xlCellTypeConstants, xlNumbers) 　On Error GoTo 0 　If IsObject(r) Then 　For Each c In r.Cells 　　If c.Value2 >= 10000 Then 　　　c.NumberFormatLocal = "[$-411]ge.m.d;@" 　　ElseIf c.Value2 < 10000 Then 　　　c.Interior.ColorIndex = 6 　　End If 　Next c 　End If End Sub '/// 今回、急遽作りましたので、決定的なミスが残っているかもしれません。
以下でどうなりますか ★ 部分を有効にすると、左詰め表示します Public Sub Samp1() 　　Dim vA As Variant, vB As Variant 　　Dim i As Long, j As Long, k As Long, n As Long 　　 　　vA = WorksheetFunction.Transpose( _ 　　　　Range("A1", Cells(Rows.Count, "A").End(xlUp))) 　　Application.ScreenUpdating = False 　　With Range("C1").Resize(, UBound(vA)) 　　　　.EntireColumn.Clear 　　　　k = 1 　　　　For i = 1 To UBound(vA) 　　　　　　ReDim vB(1 To UBound(vA)) 　　　　　　j = 1 　　　　　　n = 0 　　　　　　Do While (1) 　　　　　　　　While (n < i) 　　　　　　　　　　vB(j) = vA(j) 　　　　　　　　　　j = j + 1 　　　　　　　　　　n = n + 1 　　　　　　　　Wend 　　　　　　　　k = k + 1 　　　　　　　　.Rows(k).Value = vB 　　　　　　　　vB(j - 1) = Empty 　　　　　　　　n = n - 1 　　　　　　　　If ((UBound(vA) - j + 1) < (i - n)) Then 　　　　　　　　　　j = j - 2 　　　　　　　　　　Do While (j > 0) 　　　　　　　　　　　　If (vB(j) <> "") Then 　　　　　　　　　　　　　　vB(j) = Empty 　　　　　　　　　　　　　　j = j + 1 　　　　　　　　　　　　　　n = n - 1 　　　　　　　　　　　　　　If ((UBound(vA) - j + 1) >= (i - n)) Then Exit Do 　　　　　　　　　　　　　　j = j - 1 　　　　　　　　　　　　End If 　　　　　　　　　　　　j = j - 1 　　　　　　　　　　Loop 　　　　　　　　　　If (j < 1) Then Exit Do 　　　　　　　　End If 　　　　　　Loop 　　　　Next 　　　　With .Resize(k) 　　　　　　.HorizontalAlignment = xlCenter 　　　　　　.Borders.LineStyle = xlContinuous 　　　　　　On Error Resume Next '　　　　　　.SpecialCells(xlCellTypeBlanks).Delete xlShiftToLeft ' ★ 　　　　　　.Columns.AutoFit 　　　　End With 　　End With 　　Application.ScreenUpdating = True End Sub
>１は含まなくても大丈夫です。 うん…つまりね。 1以上という表現は1を含むんです。重箱の隅をつつくようでアレなんですが、こういった掲示板は言葉で情報を伝えるのでなるべく表現は正しくあった方がいいと思います。 それに、おそらく表の作業列には1がまず存在しないでしょうから（1行目はタイトル行？）あえて1を外す必要もないと思います。 以上・以下、未満（より小さい）・超（より大きい）の使い分けに注意をお願いします。 記号一つで結果が大違いということもありますので。すみません本筋と外れちゃいましたが。 というかよく見たら1より大きいじゃなくて1より小さいになってるし。 まぁ、集計できたんだったらいいですが。
はは、そうでしたか・ 「教えてgoo!」は、OKwebなどからは独立したので、システムが異なります。 画像の縮小--imageMagickを使われているのだと思われますが、拡大されると劣化してしまいますので、ローカルでそのサイズに切り抜いたり縮小したりコントラストや明度、ガンマ補正などをして確認してから送る方が良いですね。
貼り付け先にも非表示行(列？)があるとかはないですか？ エクセルは見えている範囲だけコピーはできても、見えている範囲にだけ貼り付けは一般機能ではできませんので。
ファイルすばやく開けるようにするにはデスクトップかどこかにショートカットを作成するのが一般的な方法だと思います。 しかしここは質問者さんのご希望に沿いまして、 特定のファイルを開けるようにタスクバーにアイコンを追加する方法を示します。 ①空のテキストファイル、例えば"abc.txt"を作成して 拡張子をexeに変えて"abc.exe"とし、タスクバーにつかみ入れます。 ②それをタスクバー上で右クリックすると「abc」という項目が出るのでそれをさらに右クリック→「プロパティ」を選択。 ③プロパティ画面で「ショートカット」タブで「リンク先」にさっき作ったファイルのパス(ディスク上の場所)が入っています。それを、希望のファイルのパスに置き換えます。 そして「OK」を押します。 ファイルのパスは、ファイルを右クリック→プロパティで確認できます。 ファイル名を末尾に追加するのを忘れないように。 例えばデスクトップにある"ex.xlsx"というファイルのパスは "C:\Users\<ユーザー名>\Desktop\ex.xlsx"となります。 ④①で作ったabc.exeを削除。 以上で完了です。
こんにちは。 UTC の時間値だけの計算ですよね。 「=IF(A1-(9/24)<0,A1+(7/24),A1-(9/24))」 これって計算おかしくありませんか。 >jst日本時間で記載されているものを　マイナス9時間計算 だから、9:00(JST) ->0:00(UTC) になりますね。 8:00(JST) -> 23:00(UCT) になるはずです。 その計算式ですと、 8:00(JST) -> 15:00(UTC) になってしまいます。 マイナスになったら、(24-9)時間を足すならよいのですが、7時間を足すことになっています。 　　　↓ =IF(A1-"9:00"<0,A1+"15:00",A1-"9:00") そこで、私は、 =MOD(A1-"9:00",1) で、良いと思いました。 もし、空白を除くなら、 =IF(A1<>"",MOD(A1-"9:00",1),"") とします。 私は、関数はあまり得意ではありませんので、間違っていたらすみません。
[No.2お礼]へのコメント、 》 ピボットの存在は知っていたのですが印刷をする時に見た目が 》 分かりやすい方が良いので中々気がすすみませんでした 印刷プレビューを添付図にしてみました。 やはり「見た目が分かり」にくいですかネ。
紙の上でやる手順をそのまま再現すれば良い。 値を条件に基づき判別、計算。 これだけだ。 条件はIF関数で行える。
こんばんは。 少し、おじゃまさせていただきます。この件について考えてみました。 表計算周りで解決するなら、私も、#1さんの均等割り付けしか思いつきません。 すでに、#4,#5 でご説明がありますが、セルの書式のユーザー定義からの方法は、私のほうでも、書式を制御する文字を、ひとつずつ調べてみましたが、数値は別として、文字は文字列として、ひとまとめになってしまい、いずれのバージョンでも、個々の文字の間にはスペースは入れられません。 お勧めとしては、均等割り付けを良くお使いになるのでしたら、「クイックアクセスツールバー」をカスタマイズして、一覧の中から、均等割り付けをピッアップして、表示させればよいのではないかと思います。 >「田中一郎」と入力すると「田　中　一　郎」 >希望どおりに動作しました。(#2欄) 物理的に空白値を、文字列に入れることをお望みで、マクロ/VBA以外ですと、解決の目処は立たないのではないかと思います。関数は、文字のあるセルを加工できるわけではないので別です。 また、マクロもいろんな種類、いろんな方法がありますから、必ずしも、拡張子を変えなくてはならないわけではありません。もう一度、再考することを願います。
グラフの項目に色を付けたいということだろうか。 それとも表のセルに色を付けたいということだろうか。 グラフの項目には条件付き書式のようなものはない。
i = 1 For Each ws In Worksheets for j = 1 to 5 Cells(i, 1) = ws.Name i = i + 1 next j ・・・ とでも、、、
#4の回答者です。 >ImageListというものを知らなかったので再度どういった形がいいのか検討してみます！ 昨日、画像は取っておいたけれども、アップロードしてありませんでしたので、本日上げておきます。とりあえず、今のものを完成させていくのが一番だと思います。 UserForm も作り方によっては、思った以上になります。
こんばんは。 ＞同行に記された△数を欠席欄に、＼数を遅刻欄に、／数を早退欄に示すようにする。 No.2の方の回答で良いと思います。 ＞上記の記号がついた氏名をあるセル（欠席や遅刻、早退をした氏名を示すセル）に示すようにする。 上記の記号がついた各氏名の行（△、＼、／）の合計数をそれぞれ出したい。 こんな感じで宜しいでしょうか？ でしたら、ワイルドカードを使えば良いと思います。 http://www.excel-img.com/database07.html [△] [＼]　[／] の数を一括で出したい場合。 * は、空白を除く文字が入力されているセル数を合計します。 =COUNTIF(B2:AF2,"*") URLにあるような応用としての数式、? は、? の数だけ抽出します。 [△◎] [＼]　[／] とした場合、 "??" と一致した [△◎] だけの合計数が返ります。 =COUNTIF(B2:AF2,"??") ご参考になれば幸いです。
貴女がアップされているピボットテーブルの場合ですと、GETPIVOTDATA関数を使用することは出来ませんので、この場合は普通にSUMIF関数を使い以下の式で対処します。 セルC22に　=SUMIF($A$4:$A$17,$B22,B$4:B$17)　と入力し下方向と右方向へ式をオートフィルコピーします。 合計の所はセルC22～E25までを範囲選択しオートSUMのボタンを押して一気に合計を出すことが出来ます。 また、セルB22～B25のような感じでそれぞれの集計を取りたいのでしたら、「出荷先国」フィールドはピボットフィールドの「行」に配置し、「列」には「支店」「出荷予定」「カウント」を配置し、「値」のフィールドの場所には「出荷高」「出荷予定」「カウント」を交互に出し入れする事で望みに近い集計をGETPIVOTDATA関数で集計することは可能です、が、３種類同時に集計する事は出来ません。 ＜例＞ セルB22～B25までのセルには、上から「アメリカ」「中国「タイ」「合計」と入力しておきます。 セルC21は、例えばピボットフィールドの「値」の場所に「カウント」フィールドが入っていればセルA3は「合計／カウント」と表示されていますのでセルC21には　=A14　の式を入れておきます。 後はGETPIVOTDATA関数でセルC25に　=GETPIVOTDATA($A$3,B22)　の式を入れ、セルC24まで式をオートフィルコピーします。 後はセルC25にSUM関数かオートSUMで合計を出します。
こんにちは。 コード全部をいじらなくて済むように、設定部分を設けました。 　Const uCOL As Long = 4　'列を増やす場合はここで調整 3列なら、3、4列なら、4と入れれば済みます。 なお、行に関しては、添付画像をみてください。 列の開始場所に関しては、現在は、コード全部を直さないとできません。 '// Sub SeparateAndCopyMacro2() 　' 'No. 9045516+reviced1 　Dim rw As Long 　Dim i As Long, j As Long 　Dim locateCode As String 　Dim arLine As Variant 　Const uCOL As Long = 4　'列を増やす場合はここで調整 　 　rw = Cells(Rows.Count, "B").End(xlUp).Row 　If rw = 1 Then MsgBox "データがありません。", vbExclamation: Exit Sub 　Application.ScreenUpdating = False 　For i = rw To 3 Step -1 　　If Len(Cells(i, 2).Value) > 2 Then 　　　arLine = Cells(i, 2).Resize(, uCOL).Value 　　　locateCode = Cells(i, 2).Value 　　　　For j = Len(locateCode) - 1 To 2 Step -2 　　　　With Cells(i + 1, 2) 　　　　　.Resize(, uCOL).Insert 　　　　　.Offset(-1, 0).Resize(, uCOL).Value = arLine 　　　　　.Offset(-1, 0).Value = Mid(arLine(1, 1), j, 2) 　　　　　.Offset(-1, 1).Value = Mid(arLine(1, 1), j, 2) & CStr(.Offset(-1, 1).Value) 　　　　　End With 　　　　Next j 　　　　Cells(i, 2).Value = Mid(arLine(1, 1), 1, 2) 　　　　Cells(i, 3).Value = Mid(arLine(1, 1), j, 2) & CStr(Cells(i, 3).Value) 　　Else 　　　　Cells(i, 3).Value = Cells(i, 2).Value & CStr(Cells(i, 3).Value) 　　End If 　Next i 　Application.ScreenUpdating = True End Sub '///
こんばんは！ ＞1列目に曜日を固定して・・・ とありますので、日曜日始まりにしてみました。 ↓の画像で、B4セル（セルの表示形式はユーザー定義から　d　とだけしておきます）に =IF(MONTH(DATE($A$1,COLUMN(A1),1)-WEEKDAY(DATE($A$1,COLUMN(A1),1))+ROW(A1))=COLUMN(A1),DATE($A$1,COLUMN(A1),1)-WEEKDAY(DATE($A$1,COLUMN(A1),1))+ROW(A1),"") という数式を入れ列・行方向にフィル＆コピーしています。 これでA1セルに西暦年を入力すれば1月～12月までの日付が表示されます。m(_ _)m
＃３です 以下部分、変更すると気持ち速くなるかも >　　　　　　ReDim vB(1 To k - 1, 1 To UBound(vA, 2)) >　　　　　　For j = 1 To UBound(vB) >　　　　　　　　For k = 1 To 4 >　　　　　　　　　　vB(j, k) = vA(i, k) >　　　　　　　　Next >　　　　　　　　For Each v In dic.Keys >　　　　　　　　　　If (vA(i, v) >= j + 1) Then vB(j, v) = 1 >　　　　　　　　Next >　　　　　　Next >　　　　　　For Each v In dic.Keys >　　　　　　　　vA(i, v) = 1 >　　　　　　Next ↓ 　　　　　　ReDim vB(1 To k - 1, 1 To UBound(vA, 2)) 　　　　　　For j = 1 To UBound(vB) 　　　　　　　　For k = 1 To 4 　　　　　　　　　　vB(j, k) = vA(i, k) 　　　　　　　　Next 　　　　　　Next 　　　　　　For Each v In dic.Keys 　　　　　　　　For j = 1 To vA(i, v) - 1 　　　　　　　　　　vB(j, v) = 1 　　　　　　　　Next 　　　　　　　　vA(i, v) = 1 　　　　　　Next
さすが、上級テクニックをお持ちの回答者さんがこぞって回答されてますね。 では私はフィルタオプションで。 まず、Ａ1はＡＢＣＤのみでリストを作成し表示形式で「@”グループ”」などとしておきます。 （リストがＡとかＢなので整合させるため。他の方が書かれているのと同じです） G1に№、H1に種類と入力し、I1に「=A1」とします。そしてI2にも「=A1」と入力します。 G5～I5にも上記と同じように入力します。 表内にカーソルを置き、データタブ→フィルタの横の「詳細設定」を押します。 抽出先 ●指定した範囲　　を選択 リスト範囲 $A$6:$F$16 検索条件範囲 $G$1:$I$2 抽出範囲 $G$5:$I$5 と範囲を入力し（ドラッグすれば入ります）、OKを押すとG7セルから条件に合うデータが抽出されます。 A1のリストを変えた場合は再度詳細設定ボタンを押し、「指定した範囲」のラジオボタンを選択しOKと押すと新たに抽出されます。 ちなみにあくまでも提示のデータでやってますので実際のデータと違うところはご自分で修正してください。
ちょっと失礼します。 おそらく、質問者さんの書き間違いだと思います。 ×「スペースのみの場合、空セルでないと判定させる」 ○「スペースのみの場合、空セルと判定させる」 という筋立てで、一つ書かせていただきました。 こんな文面から、その趣旨に導き出されます。 「該当セルにスペースのみが打ちこんであると、表示はされなくても、ISBLANK あるいは <>"" の条件に当てはまらなくなります。」 という所から、当然質問主さんは、ISLANK(セル), <>"" はご存知ということです。 「文字の空白が入っても、セルは空だと判定させる」 と解釈の元で、再度、回答を試みました。 また、ここの質問と2009年の質問が同じ種類だと考えました。 「EXCELの条件付き書式で数式を空白と認識してくれる方法」 http://oshiete.goo.ne.jp/qa/4905400.html 「EXCELの条件付き書式で例えばA1のセルに何か文字が入っていれば色を付けるというようにする場合は=A1<>""でOKだと思いますが、A1には既に数式が入力されている状態で、でも表示はされていない見かけは空白に見えるセルを空白と認識してくれる方法、数式はないでしょうか？」 という内容で、この質問の正解は出ませんでした。 「中身の見えないセルは、何もない」とすることは出来ないか、と言われたら、簡単ではありませんね。 中身が見えなくても、何か入っいると判定するには、ISBLANK()関数で良いはずです。それなら、Excelをひと通りやった人なら分かります。 =IF(A1="", "空", "在") のはずが、 A1セルに半角のスペース (&#x20) が混入していたら、計算が間違えてしまいますし、全角空白　(&#x8140)もあります。 最近では、セルに、「&#160」(no-break space)の見えないスペースも入っていることもありますが、さすがに、ここまで来ると、難しいことになりますね。 =IF(LEN(TRIM(A1))=0,TRUE,FALSE) は、 =IF(TRIM(A1)="",TRUE,FALSE)　　こちらでも良い。 以下なら「&#160」も判定が可能です。 =ISERROR(MATCH(FALSE,(ASC(MID(A1,ROW(INDIRECT("A1:A"&LEN(A1))),1))<"!"),0)) Shift+Ctrl - Enterで、配列の確定をしてください。しかし、数式としては、少し無理があるかもしれません。 #4さんの画像とは趣旨が逆ですが、一覧を作ってみました。
行の削除などで見えないくらいに狭くなったオブジェクトが多数あるときにそんな動作を経験しました。 まあとりあえず http://matome.naver.jp/odai/2134672226548347701 https://oshiete.goo.ne.jp/qa/8282741.html でしょうか。 行や列全体が数式に書かれている配列数式などが原因かも知れませんが、HDDやSSDの空き容量が足りないとかディスクのフラグメントとか、メモリ不足とか全然関係無いでしょうね。
＞時間帯（朝昼夜）にはどのようなＣ（性別）、Ｄ（交通手段）が来店しているのか。 ＞住所別にはにはどのようなＣ（性別）、Ｄ（交通手段）が来店しているのか。 ピボットテーブルのフィールドの部分 「列」に「時間帯」と「住所」をドロップ 「行」に「交通手段」と「性別」をドロップ 「値」」に「交通手段」をドロップ これでお望みの集計が取れると思いますがどうでしょう？
単純にユーザー定義でｍとすると月になったちゃうので [m]”分単位” で如何でしょうか？
こんにちは。 おそらくは、マクロでよろしいかとは思いますが、「自動で修正される」というように設定してしまうと、私なら、うっとうしく感じますが、こういう感覚は、人それぞれですから言明はしません。 実際に、私が使う目的でマクロを考えてみました。 「個人用マクロブック（PERSONAL.XLSB)」 「標準モジュール」にマクロを置き、 「クイックアクセスツールバー」に登録。 （私は、ショートカットにはしません。たぶん、忘れてしまうからです) なぜ、「個人用マクロブック」に登録するかというと、2点の利点があります。 ひとつは、保存する拡張子の影響がない(xlsx/xlsm)。もう一つは、クイックアクセスツールとして、いつでも使える。 なお、十分に納得のいかない内容でしたら、以下のマクロは個人用マクロブックにはいれるべきではありません。 今回は、特別に、マクロに内容説明を入れましたので、それを読めば、何をしようとしているか分かるはずです。 ふつうは、このような解説を入れませんから、納得がいけば解説部分は消してよいです。 '// Sub Lines_CellHeight()　　'この名前は、臨時ですから、適当に変えてください。(日本語名可) 'No. 9043589 　Dim c As Range 　Dim i As Long 　Dim h As Double 　Dim stdHt As Double 　Dim ht As Double 　If TypeName(Selection) <> "Range" Then　　'マウスで選択した場所が、セルの範囲でないなら、 　　MsgBox "該当範囲を選択してください。", vbExclamation　　'メッセージを出して、 　　Exit Sub　　'マクロは終わる 　End If 　stdHt = ActiveSheet.StandardHeight　　'標準のセルの高さ 　For Each c In Selection　　'選択範囲からひとつのセルを検討する 　　If c.HasFormula = False And Not IsEmpty(c) Then　　'セルは数式がないことと、空ではないなら、 　　　i = Len(c.Value) - Len(Replace(c.Value, vbLf, ""))　　'セル内の改行コードの数 　　　If i > 0 Then　　'一つでもあれば、 　　　　ht = c.Rows.RowHeight　　'セルの行の高さ 　　　　If stdHt * (i + 1) > ht Then　　'セルの高さよりも、標準のセルの高さ✕(改行コード数+1)が高ければ、 　　　　　c.FormatConditions.WrapText = False　　'書式の折り返して全体を表示する、Offにし 　　　　　c.EntireRow.RowHeight = ht * (i + 1)　　'セルの高さ✕(改行コード数+1) の高さにする 　　　　End If 　　　End If 　　End If 　Next c End Sub
> 隙間なく埋まる名簿データから > 指定する姓名一つを発見可能な関数なんてありましたでしょうか？ 関数ではなく、その姓名が入力されているセルを探すことが目的なら、「検索」機能をお勧めします。次のように操作してみてください。 1. [Ctrl]キーを押しながら、[F]キーを押します。 2. 表示されるダイアログボックスに、探したい姓名を入力し、[Enter]キーを押します。 3. 入力した姓名が入力されているセルがアクティブになります。 以上で、探しているセルが選択(アクティブ)されますので、色を付ける必要はないと思います。 お探しの姓名が入力されたセルに色を付けるのが目的なら、「条件付き書式」という機能を使います。 「条件付き書式を使って、特定の文字列を含むセルに色を付ける」 http://www.ne.jp/asahi/juku/excel/Jouken12.htm なお、Excelには文字列が含まれるセルの位置を検索する関数など多数あります。（下記URLのページをご参照ください。） 「Excel 検索/行列関数一覧」 http://www.excel-list.com/lookup_and_reference.h …
こんにちは 別シートに単価を入れて表を作るといいのですが 品名から引っ張ってくる感じです http://detail.chiebukuro.yahoo.co.jp/qa/question … こういうのではだめですか？ http://www.excel.studio-kazu.jp/kw/2005112314351 …
私も考えてみました。こんな方法もあると思います。 D2から、フィルハンドルで範囲内をコピーします。 =IF(COUNTIF($A$2:$A$19,$C2)>=COLUMN(A1),OFFSET($B$1,MATCH($C2,$A$1:$A$19,0)+COLUMN(A1)-2,0),"") これは、A列の数値を数えて、その同じ数をテーブルの横に出すものです。
・B8セルを右クリック。 ・「セルの書式設定」 ・「表示形式」タブの「ユーザー定義」を選択。 ・「種類」に「[mm]」と入力してOK。 で、分表示になるはずです。
こんな感じ？
解答は既に出ていますが、Excelではなくて、正規表現付きテキストエディターで可能だと思います。 フリーでよいので、ひとつ持っていると重宝します。名前から、notepad ++ を手に入れる人もいますが、有名な割には、なかなか使いこなせません。個人的には、サクラエディタは重宝していました。 検索値は、_[A-Z\d\.]+ 置換値は、(なし) Excelというのでしたら、同じ検索値で可能です。 ご興味があれば試してみてください。 '// Sub ReplacePostwords() 'No. 9041696 　Dim n As Variant 　Dim buf As String 　Dim Matches As Object 　Dim Match As Object 　With CreateObject("VBScript.RegExp") 　　.Pattern = "_[A-Z\d\.]+" 　　.Global = True 　　.IgnoreCase = True 　　 　　For Each n In Selection 　　　If n <> "" Then 　　　　Set Matches = .Execute(n) 　　　　buf = n 　　　　For Each Match In Matches 　　　　　buf = Replace(buf, Match.Value, "", , 1) 　　　　Next Match 　　　　n.Value = buf 　　　End If 　　Next n 　End With End Sub '/// これでやってみると、文末の　._. は、スペースが空くようです。 直すことは可能ですが、今はそのままにします。
Excelのバージョンの記載がありませんが。 [Excelのオプション]で[小数点位置を自動的に挿入する]のチェックが ついているのでは？ http://www.relief.jp/itnote/archives/003735.php 既定で[入力単位]が[ 2 ]になっているので100分の1になります。 Excel2003以前も[オプション]の[編集]タブに同じ項目があります。
四則演算などを含む一般の数式ではなく、セル参照を表す文字列であれば、INDIRECT 関数によりセル参照に変換できます。つまり D 列各セルの 1 本の数式中に書かれている 3 つのセル参照を 3 列に分けて書き、3 つの INDIRECT を使えば、お望みの計算はできます。 C3　 =(indirect(vlookup(c2,b11:f17,3,1))-indirect(vlookup(c2,b11:f17,4,1)))/indirect(vlookup(c2,b11:f17,5,1)) B11　16　など D11　C2　など E11　$S$153　など F11　$S$152　など お示しの数式の文字列を 3 列に分けることは、「区切り位置」機能や置換の機能を使えば、すぐにできます。必要な場合は、追加で説明します。
あなたは しょうがくせい ですか？ いままで「普通の計算式」を 目標値－実績 としていたのなら、 ひきざんをぎゃくにして、実績－目標値 としてごらんなさい。
本当だ！ KINGSOFTのSpreadsheetsのようですね(^_^;)
Vlookup関数を沢山配置したからと云って10分もかかるのはおかしいと思います。 ファイルを開いた後に、関数のリボン、右端にある　再計算　をクリックしてみてください。 それでも10分かかるのであれば、関数に問題あるかもしれませんが そうでなければ他の問題ではないでしょうか。
>ExcelでResultというFunctionをつくり、 できれば、中身も書いてほしかったですね。 それと、Result という名称は、予約語のひとつではなかったでしょうか。 私のExcel(2010)では、その関数名では作れません。だから、Results にしました。 それはともかく、ご質問では、何が問題なのか、こちらの推測の範囲でしかありません。 >現状A2の結果を更新する為にはA1もしくはA2を入力しなおさないと実行されません。 ユーザー定義関数に問題があるのは分かるのですが、ご質問の内容だけでは、分からないのです。 つまり、A2にユーザー定義関数を置き、引数をA1 としているのですから、 A1が変化しない限りは、A2のユーザー定義関数の戻り値は変わりません。 この種の問題では、ユーザー定義関数の中でRnd()関数を利用した時ぐらい発生しないのではないかと思われます。 >Excelを開いたときに、自動で再計算される様にすることは可能でしょうか？ '特定のシート（数式が置いてあるシート) Private Sub Worksheet_Activate() 　ActiveSheet.Calculate End Sub
mike_gさん、こんにちは。 設定の時に、あまり深く考えてもしょうがないので、私は、探し方のコツを書いたつもりだったのですが、本来、それは、JIS並びになっていますね。全部を見通しているわけではないので、おそらく全部がそうだという推測の上なのですが。 一応、添付画像では、JIS(10進)と、UNICODE(10進)を並列してみました。
No.1です。 ＞E列に1を代入しない方法があればより良いです。 ということですので、No.5さんと同じようなやり方になりますが・・・ （今回はフィルタではありません） Sub 非表示() Dim c As Range, myRng As Range, myArea As Range Dim myFirst As Range, myFound As Range With ActiveSheet Set myFound = .Range("C:C").Find(what:=0, LookIn:=xlValues, lookat:=xlWhole) If Not myFound Is Nothing Then Set myFirst = myFound Set myRng = myFound Do Set myFound = .Range("C:C").FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do Set myRng = Union(myRng, myFound) Loop For Each c In myRng If c.Offset(, 1) = 0 Then If myArea Is Nothing Then Set myArea = c.Offset(, 1) Else Set myArea = Union(myArea, c.Offset(, 1)) End If End If Next c If Not myArea Is Nothing Then myArea.EntireRow.Hidden = True End If End If End With End Sub ※　非表示を解除するコードも必要かと思います。 ↓のコードを追加しておいてください。 （再表示のコードです） Sub 再表示() ActiveSheet.Rows.Hidden = False End Sub こんな感じではどうでしょうか？m(_ _)m
No.2の回答は間違いがありました。m(_ _)mすみません。 もう一度書き直します。 >上のように、空白を除いて連番をふる方法をしています。 矛盾しているので、両パターン >空白を除いて連番をふる方法をしています。 なら、D2セルに =IF(E2="","",IF(ISNA(LOOKUP(21,D$1:D1)),1,MOD(LOOKUP(21,D$1:D1),20)+1)) 下へオートフィル >上のように、 なら、F2セルに =IF(E2="","",IF(F1="",1,MOD(SUM(F1),20)+1)) 下へオートフィル 関連性と意味が分からないので >他に、日付けを 以下の質問は、受け付けません
>Case "2015/2/1" To "2015/2/29"←ココのコードがわかりません。 一応、カレンダーで確認してみてほしいのですが、2015/2/29 はありませんね。 あえて、コードを書くとすれば、その部分は、以下のようになります。 Case DateValue("2015/2/1") To DateValue("2015/2/28") 細かいことですが、「Sheets("ブランク ")」に、ブランクの後に半角のスペースが入っていますが、こういうのはエラーの元になります。もちろん、実際もそうなっているのかもしれませんが。 また、本来は、If 構文で書いたほうが一般的かもしれません。 ※なお、リクエストされている対象とはまったく違います。
現在の所、ご質問のマクロからエラー 400 が出るというのは、見当たらないのです。 また、 >（マクロコードを)コピーして別シートで使うと という必要性はないはずです。別のブックというなら、あるかもしれません。標準モジュールに置く限りは、どのシートでも構いません。 あえて、いくつか想定するエラーに対処すれば、このようにはなりますが、不明です。別の原因があるか、ステップモードにして、どこでエラーが出るか特定していただいたほうがよいです。 Sub Sample1R() Dim rw As Long 　With ActiveSheet 　　rw = .Cells(Rows.Count, "A").End(xlUp).Offset(1).Row 　　'エラー処理をする 　　If rw < 3 Then Exit Sub　'空のA列 　　.Range("H16:H19").Copy 　　.Cells(rw, 1).PasteSpecial Paste:=xlPasteAll, Transpose:=True 　　.Range("H16:H19").ClearContents 　　.Range("H16").Select　'これはなくてもよい 　End With End Sub
C4のセルに入れる関数を下記のものにします =COUNTIF($B$4:B$18,B4) これをC列，E列，G列に居れればカウントした数が求まります．
>上記の式の("_"&シート!$AN$2:$AN$4&"_",の結果が"_い_"となるんですがなぜかわかりません 「数式の検証」を使っての結果でしょうか？ 対象の部分の数式を選択(反転)させ[F9]キーで配列定数が返ります >ただAN2〜AN4まではい以外の文字が並んでました… う～ん、上記の式を2行目に書いていれば、シート!$AN$2セルの値が返り 3行目に書いていれば、シート!$AN$3セルの値が返り・・・という風に値が返るので どうしてなのかはわかりません。シートを間違っていることはありませんか？
とりあえず >まず、Text4 = Range("I2").Valueの部分を >I列の2行目から最終行までと書き換えたいです。 の部分だけですが For i = 2 To Range("A" & Rows.Count).End(xlUp).Row Subj = Range("C" & i) EmailAddr = Range("A" & i) CCAddr = Range("B" & i) ・・・・ Next と云った具合に、For ～Next　で繰り返させます。 Range("A" & Rows.Count).End(xlUp).Row がA列にデータが入っている最終行番号を取得する構文と思ってください。 Range("A" & Rows.Count). 一旦、A列の一番下（２００７以降であれば、1048576）へ移動して、 End(xlup)で空白でない最後の行へ移動して .Row　でその行番号 となります。
こんばんは！ C1セルに =COUNTIF(1:1,"A") という数式を入れているのですよね？ これでは循環参照になってしまいます。 数式を入れた時点で「循環参照」の注意画面が表示されなかったでしょうか？ それを無視して確定すると、「0」という表示になってしまいます。 本来であれば循環参照は避けるべきなのですが、 どうしても！というコトであれば メニュー　→　ファイル　→　オプション　→　数式　→　「反復計算を行う」にチェックを入れ OK　としてみてください。 ※　別案として・・・ Excel2007以降のバージョンをお使いであれば =COUNTIF(D1:XFD1,"A") としておくのが無難だと思います。 （最終列がXFD列になるため）m(_ _)m
特定の誰か宛の内容ではありませんが、#2の書き込みについて、ちょっと誤解されそうなので、補足しておきます。 「最近、こうしたマクロが、Webスクレイピングかどうかという議論で、強行な意見の持ち主もいるようですが、お互いが権利保持者ではありませんから、お互いに主張したところで無意味です。」 というのは、禁止を求めるのは、その権利を保持した人で、もし嫌うなら、Webサイトに仕掛けをするはずなのです。むろん、そのサイトの規約などに書かれていたら、仕掛けが施されていなくても、そうした行為は避けるべきだと思います。 http://www.f3.dion.ne.jp/~element/msaccess/AcTip … >調査する >まず対象サイトがスクレイピングを明示的に禁止していないかどうか確認する必要があります。 >スクレイピングは人間による Web サーフィンと違って、寄り道せずに必要な情報だけ持っていきます。 －中略－ >もっともスクレイピングの認知度は一般的にはまだまだ低いですから、 この頃は、まだ、それほどWebスクレイピングをする人は多くなかったのです。 http://qiita.com/nezuq/items/c5e827e1827e7cb29011 Webスクレイピングで誰も嫌な思いをしなくて済むように、…… こうしたデータの取り扱いは、慎重にしたほうが良いようです。
こんにちは。 >サブフォルダ内のファイル名取得(拡張子を指定)のコードをどのように記述するのか 雑な書き方で、質問者さんのコードを汚してしまいましたが、こんな感じでループすればどうでしょうか。 たぶん、時間をかければ、私の書いた程度なら書けたはずだと思います。 ファイル名取得なら、 Dir(myPath & "*.xlsx", vbNormal)　　か、ただの　Dir(myPath & "*.xlsx")で良いはずです。 ひとつだけ気になるのは、 　ActiveWindow.Visible = False 　の部分ですが、後、どうやって収拾するのでしょうか？ '// Sub SameFolderBook_OpenN() 'No. 9037311 　Dim FileName As String 　Dim wb As Workbook 　Dim IsBookOpen As Boolean 　Dim myPath As String 　Dim FolderLists As Variant 　Dim FSO As Object 　Dim objFolder As Object 　Dim i As Long 　Dim obj As Object 　Dim pt As Variant 　Dim buf As String 　myPath = ThisWorkbook.Path & "\"　　　'今開いているブックのパスを取得 　ReDim FolderLists(0) 　FolderLists(0) = myPath 　i = i + 1 　Set FSO = CreateObject("Scripting.FileSystemObject") 　Set objFolder = FSO.GetFolder(myPath) 　For Each obj In objFolder.SubFolders 　　ReDim Preserve FolderLists(i) 　　If Right$(myPath & obj.Name, 1) <> "\" Then 　　　 FolderLists(i) = myPath & obj.Name & "\" 　　Else 　　　 FolderLists(i) = myPath & obj.Name 　　End If 　　i = i + 1 　Next 　 　For Each pt In FolderLists 　FileName = Dir(pt & "*.xlsx",vbNormal)　 'myPathの*.xlsxのファイル名を取得 　　Do While FileName <> "" 　　　For Each wb In Workbooks 　　　　If wb.Name = FileName Then '既にブックが開いているときの処理 　　　　　IsBookOpen = True 　　　　　Exit For 　　　　End If 　　　Next wb 　　　If IsBookOpen = False Then 'ブックを開く処理 　　　　Application.StatusBar = "データを読込中..." 　　　　Application.ScreenUpdating = False 　　　　Workbooks.Open pt & FileName, ReadOnly:=True 　　　　ActiveWindow.Visible = False 　　　End If 　　　IsBookOpen = False 　　　FileName = Dir() 　　Loop 　Next pt 　Application.StatusBar = False 　Application.ScreenUpdating = True 　ThisWorkbook.Activate End Sub '///
ステータスバーのユーザー設定を表示した状態で、Ctrlを押さずそのままアルファベットを押してみてください。
こんにちは。 フォームコントロールで、起動を止める方法は、今のところ2つ浮かびます。 1．一般的な方法 CheckBox に取り付けているマクロはどのようなものにしても、以下のように、フラグを付けて、離脱するか決めさせます。 Private Const flg As Boolean = True　'←このようにして、マクロの実行を止めます Sub チェック1_Click() If flg Then Exit Sub　　'Trueの場合はマクロを実行しない Range("A1").Value = Range("A1").Value + 1 End Sub 2. このようにして、マクロの登録を回避させ空白にして、「代替えテキスト」に移してしまいます。 タブルクリックしても、メッセージなども出てきません。戻す時は、逆の方法を取ります。 Sub Macro1() Dim bln As Boolean Dim chkb As Object For Each chkb In ActiveSheet.CheckBoxes 　chkb.ShapeRange.AlternativeText = chkb.OnAction　　'マクロの命令を退避させる 　chkb.OnAction = "" Next End Sub chb.OnAction の部分にダミーマクロを入れてあげても可能ですが、元のマクロコードに戻すためには、どこかにコードは置いておかなくてはなりません。また、chb.OnAction = "+"　&　chb.OnAction でもよいのですが、ダブルクリツクすると、「マクロが見つからない」というエラー表示をします。
こんばんは！ お望みの関数でなく、VBAでの一例です。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long, cnt As Long, c As Range, wS As Worksheet Set wS = Worksheets("作業中シート") With Worksheets("顧客リスト") For i = 1 To wS.Cells(Rows.Count, "A").End(xlUp).Row Set c = .Range("B:B,F:F,J:J").Find(what:=wS.Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then cnt = cnt + 1 End If Next i .Range("M3") = cnt End With End Sub 'この行まで// ※　関数でないのでデータ変更があるたびに マクロを実行する必要があります。m(_ _)m
エクセルのカテゴリーですので、エクセルを使ってと云う事ですよね。 Ｎｏ１の方がおっしゃる通り、名前を付けて保存で ファイル形式で　ＰＤＦ　が選択できます。 また、ＯＳがＷｉｎ７以上であれば プリンターに　ＸＰＳ　がありますので、このプリンターを選択して 印刷してみてください。 ファイル名などウイザードが表示されます。 但し、このファイルをメールなどで配布した際に、相手もＷｉｎ７以上で ある事が必須です。開けませんので。 まあ、今更、アドベのソフト購入する必要はないと思います。
添付図参照 Sheet2!B2: =VLOOKUP(A2,Sheet1!A:D,4)
いくつか検討してみました。 大きく分けると二種類のコードになりますが、 標準Module に書かれたものを、再利用するものです。ThisWorkbook内のコードは、エクスポート／インポートすると、クラスモジュールになってしまいますので、そのコードを、活用するためには、もうひとつ別の起動用マクロが必要になってしまいます。それで、一般的には、標準Module　一本にするのが楽かと思います。 二番目は、趣向の強いもので、回答者としてのマナー違反だと言われかねないものです。（マナー違反を自覚しないで書いているわけではありません。しかし、これを他人の環境で人知れず実行するためには、もう一つ非公開の技術が必要です。) 私は、最初のほうのものをお勧めします。 どちらも、直接、マクロコードを触りますから、 　セキュリティセンターのマクロの設定で、 　開発者向けのマクロの設定 　レ　VBAプロジェクトオブジェクトモデルへのアクセスを信頼する 　にはチェックが必要です。 （セキュリティのためには、会社などではここはオフにしておくのが一般的です) '以下のコードは標準モジュールで、Module1 以外にしてください。 '// Private Const myPATH As String = "C:\Users\[YourNamer]\My Documents\" '末尾には￥を入れてください。 Sub TestMacro1() 'ここでは、Module1 を使います。 Call ExportModule Sheets("sheetA").Copy Call ImportModule '面倒でも、パスとファイル名は分かち書きしてください。 ActiveWorkbook.SaveAs Filename:=myPATH & "sheetA.xlsm", _ 　　　FileFormat:=xlOpenXMLWorkbookMacroEnabled '保存したので、Falseを入れてください。 ActiveWindow.Close SaveChanges:=False End Sub Sub ExportModule() 'エクスポート 　ThisWorkbook.VBProject.VBComponents.Item("Module1").Export _ 　Filename:=myPATH & "tmp1.bas" End Sub Sub ImportModule() 'インポート 　With ActiveWorkbook 　.VBProject.VBComponents.Import _ 　Filename:=myPATH & "tmp1.bas" 　End With 　Kill myPATH & "tmp1.bas" End Sub '------ Module1 は、以下のようになっているものとします。 '--------- Sub Auto_Close() 　MsgBox "Good-Bye!" End Sub '-------------- '// Sub TestMacro2() Const myPATH As String = "C:\Users\[YourName]\My Documents\" '末尾には￥を入れてください。 Sheets("sheetA").Copy '直接マクロコードを書き込みます。 Call WritingMacroCodes ActiveWorkbook.SaveAs Filename:=myPATH & "sheetA.xlsm", _ 　　　FileFormat:=xlOpenXMLWorkbookMacroEnabled ActiveWindow.Close SaveChanges:=False End Sub Sub WritingMacroCodes() With ActiveWorkbook.VBProject.VBComponents.Item("ThisWorkbook").CodeModule 'マクロの 1 行目から 3 行目まで書き込みます。 　.InsertLines 1, "Private Sub Workbook_BeforeClose(Cancel As Boolean)" 　.InsertLines 2, " MsgBox ""Good-Bye!""" 　.InsertLines 3, "End Sub" End With End Sub '///
>ブックの１枚目のシートのみをコピーすることはできますか？ For i = 1 To Worksheets.Count Sheets(i).Activate ・・・ ・・・ Next で全てのシートを繰り返していますので Sheets(1).Activate For k = 1 To Range("A" & Rows.Count).End(xlUp).Row .Range("A" & j).Value = buf .Range("B" & j).Value = Sheets(i).Name .Range("C" & j & ":E" & j).Value = Range("A" & k & ":C" & k).Value j = j + 1 Next で十分ではないでしょうか。
マクロ（アドイン）を使うことで利用できるようです。 http://www.ka-net.org/office/of31.html http://snow-white.cocolog-nifty.com/first/2010/0 …
こんにちは。 >２．別BOOKとして保存したファイルを、同一フォルダ内にZipファイルとして圧縮 というのは、2007以降のOffice ファイルは、拡張子が変わっただけで、本来は、Zipファイルなのです。あえて、Zipで圧縮する必要があるか分かりませんが、アーカイブに格納ということで、やってみました。 #2さんのリンク先とは、仕組み自体は同じですが、 Set Shell = CreateObject("Shell.Application") zFolder.CopyHere sFolderItem で、ZIPフォルダが認識しないことでした。そこで、何度もやった結果、事前に参照設定することで解決しました。 '// Sub Files2Zip() 　　Dim myPath As String 　　Dim ZipFName As String 　　Dim ZipFNameB As String 　　Dim FName As Variant 　　'要参照設定 　　'Microsoft Shell Controls and Automation 　　Dim objShell As Shell32.Shell　'レイトバインディングだと抜けがあります。 　　Dim ar As Variant, fn As String 　　Dim i As Long, j As Long, k As Long 　　myPath = ThisWorkbook.Path & "\" '任意の場合は、必ず末尾に￥を入れること 　　 　　ZipFNameB = myPath & "MyFilesABC" ' & ".zip" "圧縮名 　　ZipFName = ZipFNameB & ".zip" 　　 　　'一意の出力ファル名の決定 　　fn = Dir(ZipFName & ".zip") 　　Do Until fn = "" 　　　k = k + 1 　　　ZipFName = ZipFNameB & CStr(k) & ".zip" 　　　fn = Dir() 　　Loop 　　 　　FName = Application.GetOpenFilename(FileFilter:="Excel Files (*.xl*), *.xl*", _ 　　　　　　　　　　MultiSelect:=True, Title:="圧縮ファイル選択") 　　If IsArray(FName) = False Then 　　　　Exit Sub 　　Else 　　　 Open ZipFName For Output As #1 　　　 Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0) 　　　 Close #1 　　　 　　　 Set objShell = New Shell32.Shell 　　　　For i = LBound(FName) To UBound(FName) 　　　　　　If IsBookOpen(FName(i)) = False Then 　　　　　　　'ファイルは必ず閉じた状態で使ってください 'ここで問題が発生することがある 　　　　　　　　objShell.Namespace(ZipFName).CopyHere FName(i) 　　　　　　　　Sleep 500 　　　　　　End If 　　　　Next i 　　End If End Sub Function IsBookOpen(ByVal FName As Variant) Dim myFno As Integer If Dir(FName) <> "" Then 　myFno = FreeFile 　On Error Resume Next 　Open FName For Binary Lock Read Write As #myFno 　Close #myFno End If 　If Err.Number = 70 Then 　　IsBookOpen = True 　End If End Function '//
失礼しました URL　を　関数でつなげると　全て文字列になってしまいますね。 K2セルは、 URLの前までの文章 L2セルに、　URL M2セルに　URLの後の文書に分けて VBAの方で objMAIL.Body = Range("K2").Value & Range("L2").Value & Range("M2").Value とすれば大丈夫の様です。 ＞URLはメール内に見せずに12桁の数字のみをメール内に表記させて ＞且つ数字にハイパーリンクを張らせたいのですが は、残念がら私も知りません。 ＞年月日がメールになると数値で表示されてしまいます。 は、関数を ・・・& Text(G2,"yyyy/mm/dd(aaaa)") &・・・ といてみては如何でしょうか。 ＞メール送信が終わったら2行目以下は消去して構いません。 ならば、VBAの最後に Range("A2:J1000")..ClearContents で全てクリアしては如何でしょうか。
ご質問を読んで、チョッと試してみたのですが、… コピーしたピボテ上の任意の場所を選択したら、タブメニュー上に[ピボットテーブル ツール]なんてなタブが忽然と現れます。そこの[分析]をクリックして現れるリボンの中の[データソースの変更]を辿ると[ピボットテーブルのデータソースの変更]というタイトルは長ったらしいけど[テーブル/範囲]ボックスを書き替えればOKなのではないかと。 編集していた列幅等は既定値に戻るけど、ピボテの基本レイアウトは維持されるようです。 ただし、つぶさに検討したわけではないので、ご自分で試してみてください。
こんばんは！ 色々回答が出ていますので、参考程度で・・・ やり方だけです。 ↓の画像では元データは左側のSheet1にあり、別Sheetに表示するようにしています。 （他のSheetもやり方は同じですので、A1セルのデータだけ変更してみてください） 画像ではSheet2のA4セルに =IFERROR(INDEX(Sheet1!A$1:A$1000,SMALL(IF(Sheet1!$A$1:$A$1000=$A$1,ROW($A$1:$A$1000)),ROW(A1))),"") 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　Sheet2のA4セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 最後にA4セルのフィルハンドルで列・行方向にコピー！ これで画像のような感じになります。m(_ _)m
追伸： 一応、ファイルサンプルをアップロードして置きました。 本日、2015/8/16 20pmより、1週間で、最長で1週間、置いておきます。 実際のピボットテーブルではありませんが、ピボットテーブル等のテーブルを探すように作られていますが、実際に試したことはありません。 ダウンロードにつきましては、ファイルのプロパティで、ブロック解除を行ってください。そうしないと、開くことができません。 http://fast-uploader.com/file/6995278289730/ パスワードは、ここの7桁のログ番号にしています。
たぶん、フォームコントロールのボタンでしょうから、私の知っている範囲なら、このようにします。名称があるなら、Buttonsの中に名前を入れてください。Shapesでも可。コードが別に書かれているかどうかではなく、そのオブジェクトにマクロ登録しているという前提です。 Sub Test1() 　'フォームボタン 　Run Worksheets("Sheet9").Buttons(1).OnAction End Sub 'ちなみに、ActiveX 側はこちら Sub Test2() 　'ActiveX コントロール・ボタン 　Worksheets("Sheet9").CommandButton1.Value = True End Sub
通りすがりですが。質問です。 １　有給該当者は、画像にあるように13人限定ですか？増減の有無は？ ２　各日の有給該当者数は、３人までですか？４人以上になることはありませんか？ １、２　によって考え方が全く違ってくるように思います。
タブとして表示されていないのは、そのものの機能を使っていない場合 などが主な理由です。[ツールのタブ]などが、その一例です。 ・[アドイン]タブについて アドインとして、ユーザーフォームやツールバーなどを設定していない 場合や、アドインツールをインストールしていない場合などでは、この タブはチェックが付いていても非表示になります。 http://www.atmarkit.co.jp/ait/articles/1405/19/n … http://hamay.blogspot.jp/2011/09/blog-post_06.html 外部アドインをインストールすると、この[アドイン]タブに表示される こともあります。 ・[背景の削除]タブについて 画像を挿入して、[図ツール]の[書式]タブを開きます。 そこにある[背景の削除]をクリックすると、削除する範囲を指定でき、 この操作をするときに表示されるのが[背景の削除]タブになります。 http://hamachan.info/win7/Office/haikeid.html https://support.office.com/ja-jp/article/%e5%9b% … 上記の作業において、[リボンのユーザー設定]で[背景の削除]タブへの チェックを入れていないと、[背景の削除]タブが表示されずに、細かい 修正がし難くなります。
こんばんは！ 「発芽」セルだけを見つけ出し、そのセルだけループさせてみました。 一例です。 Sub Sample1() Dim c As Range, myRng As Range, myArea As Range Dim myFirst As Range, myFound As Range Set myArea = ActiveSheet.Range("B350:I450") Set myFound = myArea.Find(what:="発芽", LookIn:=xlValues, lookat:=xlWhole) If Not myFound Is Nothing Then Set myFirst = myFound Set myRng = myFound Do Set myFound = myArea.FindNext(after:=myFound) If myFound.Address = myFirst.Address Then Exit Do Set myRng = Union(myRng, myFound) Loop For Each c In myRng With c.Offset(1) .Value = .Value + 1 End With Next c End If End Sub ※　別案　※ 範囲内のすべてのセルをループさせます。 Sub Sample2() Dim c As Range For Each c In Range("B350:I450") If c = "発芽" Then With c.Offset(1) .Value = .Value + 1 End With End If Next c End Sub 今回は範囲セル数が多くないので こちらの方が簡単だと思います。m(_ _)m
1月でその２シートを作っていて、1日が1行なら 予定 =INDEX(シート1!C:C,$C$1+1)&"" 出張 =INDEX(シート1!D:D,$C$1+1)&"" でもいいのかも
もし、マクロでしたら、ダメ元なのですが、 Application.ScreenUpdating = True の一行か、 Application.ScreenUpdating = Flase Application.ScreenUpdating = True のセットを試してみてください。 個別にボタンのオブジェクトのプロパティのVisible =True, False を繰り返す以外は、今のところ、思い出せません。
ピボットテーブルを作成した時にデータベースが消える…というか、テーブルに置き返されてしまいます。 使える機能としては、シート内を上下に分割するという方法（機能）があります。 例えばデータベースをA100行目から○○○行目まで配置しておき、ピボットテーブルの開始位置をセルA1からとして作成します。 次に作成したデータベースの位置（例えばセルA100行目から作ったとして）セルA100をクリックして「表示」タブ→「ウィンドウ」グループ内の「分割」をクリックすると縦と横の分割ラインが表示され4つに分割されますので、縦の分割ラインを左右どちらかに移動して（縦の分割ライン上でマウスの左ボタンを押したまま左右どちらかへ移動）シート外へ格納します。（左側の行番号方へ移動して行った方が分かり易いかと・・・。） あとはスクロールで上下に移動したい方のシートを一回クリックしマウスのスクロールホイールでクリックした方の分割シートが上下に移動します。 ※失敗してやり直す場合、もう一度「分割」ボタンをクリックすると元の一枚のシートに戻ります。 （その状態を画像で添付しておきます。） 追加で・・・。 分割ラインを設定する場合は、予め作成したデータベースがPCの画面上の中央か中央より少し上あたりに来るようにしておいてから「分割」ボタンを押すといいです。 以上、excel Ver'2010 より。　（ピボットテーブルは2003のものと変換した状態のものを添付しております。）
>合わせて32t ？　33じゃなくて？ で、結果はシート2に出すんですか？するとシート2には東芝倉庫のデータと今日の日付の結果が両方出るんですか？ とりあえず、SUMIFSを足してみました。シート2枚分ならそんなに手間じゃないかと。 シート2のE1から倉庫1が入っているとして E2=SUMIFS(Sheet1!$B:$B,Sheet1!$C:$C,E$1,Sheet1!$A:$A,TODAY())+SUMIFS(Sheet2!$B:$B,Sheet2!$C:$C,E$1,Sheet2!$A:$A,TODAY()) 右にコピー。 ※Excelカテゴリで放置している質問をきちんと対応してください。
こんにちは！ 一例です。 シートモジュールにしてください。 Private Sub Worksheet_Change(ByVal Target As Range) 'この行から// Dim str As String If Intersect(Target, Range("A1:A3,B1:B3")) Is Nothing Or Target.Count > 1 Then Exit Sub With Target If .Value <> "" Then str = .Value .Value = StrConv(str, vbWide) End If End With End Sub 'この行まで// こんな感じではどうでしょうか？m(_ _)m
D列を選択し、条件付き書式の新しいルールで =AND($A1="仕入",$D1<=0.06) 塗りつぶし赤 =AND($A1="自社",$D1<=0.3) 塗りつぶし青 で如何でしょうか？
No.3 さんの MATCH 関数で十分と思います。ベストアンサーは辞退します。 INT なら、 =(a1<41)+int((a1-11)/30) とすれば 41 未満も 1 にはなりますね、一応。
＞フィルタオプションを使えばできますが、 マクロに登録しては如何でしょうか。 とりあえずの作業 開発のリボン、マクロの記録の開始 フィルターオプションの操作を実行 記録の終了 これで、必要な作業の操作がマクロ化されます。 開発のリボンで　VBエディターを起動すると 記録されたコードがあります。 そのコードを シートモジュールにコピーすれば 会社名を変更した時点で、希望のデータが表示される 勝手に、フィルタオプションが実行されます。 詳しくは、マクロの記録で記録されたコードを提示てみて下さい。
ハイパーリンク関数ではできません。 リンク貼り付けで似たようなことはできます。 (2台目のPCを開く時点で更新される) 状況が不明なので、リンク貼り付けで良いかどうかはわかりかねます。 2台目がバックアップということなら、そのようなソフトを使うとよいと思います。
コードと云う事なのでVBAですよね。 ＞1万行とかあるので、出来るだけ早い方法が理想です。 データ数が多いので、ここは発想を変えます。 別シートに、【クリアと言う文字を含まない】行のデータを抽出する。 もちろん、1行目に、きちんと項目名があってデータが下にあるとしてです。 フィルターオプションの機能を使います。 http://www.eurus.dti.ne.jp/yoneyama/Excel/filter … などを参考にしてください。 Sheet1が元データ 　A　　　B　　　　C 項目１　項目２　項目３ NG クリア ・・・・ Sheet2 　A　　　B　　　　C　　　　　J 項目１　項目２　項目３　　　項目１ 　　　　　　　　　　　　　　="<>クリア" マクロの記録で得られたコードですが Sub Macro1() Sheets("Sheet1").Columns("A:C").AdvancedFilter Action:=xlFilterCopy, _ CriteriaRange:=Range("I1:I2"), CopyToRange:=Range("A1:C1"), Unique:=False End Sub となりました。 また、NGを抽出したければ Sheet2 　A　　　B　　　　C　　　　　J 項目１　項目２　項目３　　　項目１ 　　　　　　　　　　　　　　NG とします。 コードを編集せずに、色々と応用もできますし 何といっても早いです。
( ‥)ﾝ?　日曜日のセルの下、４～５行目の部分の左側にタテの罫線ですか？ 取り敢えず、セルC4～AG5を選択しておきます。 途中まではいいですが、「次の値に等しい」の右側の枠には　=C$3<>"日"　の式を入力します。 または、「次の値に等しくない」とした場合は、　=C$3="日" となります。 数式を使用して・・・の場合も同じく、数式入力欄には　=C$3="日"　の式になります。 で、後は書式を設定「書式」→「罫線」でプレビューの左側をクリックすると縦に罫線が入ります。 「＄」マークの位置に注意が必要です（絶対参照と複合参照と相対参照の違い）
こんばんは！ 横からお邪魔します。 色々な方法での回答が出ていますので、敢えて関数でやってみました。 画像の配置だとB1セルに =INDEX({100,200,250},MATCH(A1,{"○○","△△","××"},0)) としてフィルハンドルでダブルクリック！ これで大丈夫だと思います。 （エラー処理はしていません） ※　敢えてVBAでやるとなると、No.1さん後者の方法が良いように思います。 理由としてはデータ変更する場合インデックスのデータ変更だけで コードに手を加える手間が省けると思います。m(_ _)m
個数の計算はCOUNTIF関数を使うといいです。 画像を添付しますので、ご参照ください。 セルE2には次の式を入力します。　=COUNTIF(A:A,$D2) 後はオートフィル機能を使い、右方向と下方向へ式をコピーして下さい。
こんにちは！ ＞にその値に対応した数値を・・・ の部分は、質問文を素直にそのままコードにしてみました。 Sub Sample1() Dim c As Range, k As Long, myAry As Variant myAry = Array("○○", "××", "△△") For k = 0 To UBound(myAry) Set c = Range("A:A").Find(what:=myAry(k), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then c.Offset(, 1) = 100 * (k + 1) End If Next k End Sub こんな感じではどうでしょうか？m(_ _)m
条件付き側の内容が分かりませんから、ご質問の回答としては曖昧になりますが、リンク元が空白(Empty)なら、リンク先は0と表示するはずです。 #1さんに倣って、Sheet1に対して =IF(Sheet2!A1="","",Sheet2!A1) もし、リンク元が空白なら、リンク先では、このような数式では、長さ0の文字列("")として返るはずです。 そのまま、=Sheet2!A1 なら、「0」が出てきますから、それを書式で、0を非表示にしても可能です。 最初の場合の条件で、 条件付き書式の一つの条件に 　A1<>"" を、AND(条件1,条件2,・・・) の一つの条件として加えれば良いのではありませんか？ 0なら、 A1<>0 です。
１．F1セルに　=SUM(B1:E1)　　と入れてEnter. ２．F1セルを選択 ３．F1セルの右下にある小さい黒い四角　■　をダブルクリック
http://www.becoolusers.com/office/transparent-co … 白なら別に印刷されないから、この作業はしなくてもいいんですけどね(^_^;
No3です １２５≒１２０ １２６≒１３０ の式を答えましたが こちらかな? １０００÷８＝１２５≒１２０ １００８÷８＝１２６≒１３０ この式なら =INT((A1/B1+4)/10)*10
同じ日がいくつかあるなら、SUMIFとかでもいいですね。 =SUMIF(Sheet1!A:A,A1,Sheet1!B:B) >Ｔoday表示 の意味がちょっとわかりませんが。
=OR((A$2:A$100=A2)*(C$2:C$100="完全終了")) 　　　　　　　　　　　　　　　↓ =OR(($A$2:$A$100=$A2)*($C$2:$C$100="完全終了")) 【余計なお世話】 》 それを参考に適用先を変えたりしましたが… そのことが本当なら、その内容を示すべき！ 「A2」「$A2」「A$2」「$A$2」の違いを熟考すべし！
mike_gさんご指摘ありがとうございますm(_ _)m 列での指定はできないよなぁ(XL2003) 　↓ あぁ やっぱり 　↓ 範囲に戻しておこう 　↓ 手入力で数字を入力 　↓ 行の絶対参照を忘れる。。。。(-_-)/~~~ピシー!ピシー! お粗末様でした m(_ _)m 感謝
添付図参照 C6セルに =IF(B6="","",VLOOKUP(B6,$A$1:$B$3,2,FALSE)) フィルハンドルダブルクリック
gekikaraouさん、こんにちは。 前回は、マクロを提示した後で、そこにはデータがまばらで全部入っていないということでしたが、前回と同じく、後出しで出てくる条件を恐れてしまい、私は、レスをつけるのをためらいがちになってしまうのです。 もし、本当に、ご質問だけの問題ならば、マクロは、半年以下の経験者でも可能なはずです。 「マクロで解らない事がある」とは、どういうことでしょうか。まったくマクロを知らない方ではありませんから、うかつな回答は、墓穴を掘るようなものです。 例えば、End プロパティが使えないぐらいは想定しています。できれば、ご自身で、ある程度、データを入れるなど生データに近いものや、ぼかしを入れるなどしても、回答側に想定できるものを示してくれたら、回答側のミスリードは避けられるのではないでしょうか。 >その表のCの最上段（画像ではC1）に東京の文字が入っていたらSheet２の上段に貼り付けたいと思います。 「A1~BL41　がひとくくりの表」は、ただ、広さだけが存在して、それが、規則的に並んではないとか、C列の任意の場所に「東京」という文字があるとか、十分に想定できます。そうしたら、For i = 1 To 1000 Step 41　は使えませんね。 つい、C1, C42,C83 のどれかにあると期待をさせてしまいます。画像だけでは分かりませんからね。 '// Sub CheckArea() 　'コピー 　Dim i As Long 　Dim j As Long 　Dim k As Long 　Dim rng As Range 　Dim sh1 As Worksheet 　Dim sh2 As Worksheet 　Set sh1 = Worksheets("Sheet1") 　Set sh2 = Worksheets("Sheet2") 　Set rng = sh2.Columns(3) 　Const FWD As String = "東京" 　k = FindWord(FWD & "*", rng) 　If k = 0 Then 　　j = 1 　Else 　　j = k + 41 　End If 　Application.ScreenUpdating = False 　For i = 1 To 1000 　　If sh1.Cells(i, 3).Value Like FWD & "*" Then 　　　sh1.Cells(i, 1).Resize(41, 64).Copy 　　　With sh2.Cells(j, 1) 　　　　.PasteSpecial Paste:=xlPasteAllUsingSourceTheme 　　　　.PasteSpecial Paste:=xlPasteValues 　　　End With 　　　Application.CutCopyMode = False 　　　j = FindWord(FWD & "*", rng) + 41 　　End If 　Next i 　Set sh1 = Nothing 　Set sh2 = Nothing 　Application.ScreenUpdating = True End Sub Function FindWord(ByVal sTxt As String, rng As Range) 　'東京という単語を探し、最大値の行数を返す 　Dim c As Range 　Dim k As Long 　Dim Max As Long 　Dim FirstAddress As String 　With rng 　　Set c = .Find( _ 　　What:=sTxt, LookIn:=xlValues, SearchOrder:=xlByColumns) 　　If Not c Is Nothing Then 　　　FirstAddress = c.Address 　　　Do 　　　　Set c = .FindNext(c) 　　　　If c.Row >= Max Then 　　　　　Max = c.Row 　　　　End If 　　　　If c.Address = FirstAddress Then Exit Do 　　　Loop Until c Is Nothing 　　End If 　End With 　If c Is Nothing Then 　　k = 0 　Else 　　k = Max 　End If 　FindWord = k End Function '///
こんにちは。 VBAプログラミングがある程度使えるのでしたら、 >とりあえずxlsx形式で作成していたファイルに、後から必要を感じてマクロを追加することがよく有ります。そうすると、ファイル形式を、マクロ有効形式xlsmにいちいち変更しなければならないですよね。 それをマクロで自動化させればよいと思います。 私は、特定のブックを閲覧している時だけ、保存する際に、自動的に拡張子を変える設定だったので、今、人にも使えるように、変更を考えています。 ただ、保存する時に、前に保存したファイル形式の選択は残りますから、一旦、xlsmで保存したら、次の新規ファイルもxlsmが、最初に出てくるようですね。私の場合は、保存ファイルの99%は、xlsm (マクロ付き)ファイルです。 なお、余談ですが、xlsx でも、アドイン型にしてVBAコードと分離すれば、マクロは使えますね。
バージョンは2013ですか？ 原因：（1）Excel のオプション設定（2）互換モードの設定が有効になっている（3）Office 2013 のインストール情報破損 対処： （1）既存ファイルをダブルクリックで開けないがExcel 起動が可能な場合、Excel 起動し「ファイル」「オプション」「詳細設定」「Dynamic Data Exchange (DDE) を使用する他のアプリケーションを無視する」のチェックを外す。 （2）ExcelショートカットやEXE実行ファイルを右クリック「プロパティ」「互換性」各項目にチェックがついているものを外す。（「特権レベル」の項目についてもチェックを外す） （3）インストール情報が破損している可能性の場合Office 2013のアンインストール、再起動、再インストール。
こんばんは。 A154　を、A1 に直しまして =MID(A1,1,FIND("^",SUBSTITUTE(A1,"/","^",5))) エラー処理するなら、 =IF(COUNTIF(A1,"*//*/*/*/*"),MID(A1,1,FIND("^",SUBSTITUTE(A1,"/","^",5))),"") 結果： 　http://aaa.com/BBB/CCC/ なお、残りは =SUBSTITUTE(A1,B1,"") 結果： 　DDD/EEE/index.html ちなみに、これは、Trim を入れたほうがよいです。 =IF(LEN(A1)-LEN(SUBSTITUTE(A1,"/",))<5,"",TRIM((MID(SUBSTITUTE(A1,"/",REPT(" ",100)),100*5-99,100))))
・J列に入力すると、入力した行を灰色 ・I列に入力すると、入力した行を黄色 条件が二つになりますので、まとめてという訳にはいきませんので、二つ条件を入れる必要があります。 ＞A～Lまでの範囲 ではなく、添付されている画像からするとセルA6～？？？からと正確に条件を入れる範囲を選択する必要があります。 例えば、データがA6～L30までだとした場合（添付画像参照して下さい）予めA6～L30までを選択しておきます。 条件を付ける範囲を選択したのち、「条件付き書式」→「ルールの管理」を選択→左上の「新規ルール」を選択→「数式を使用して、書式設定するセルを決定」を選択 数式を入れる枠内に　=$J6<>""　の式を入れ、「書式」からグレーを選択し「OK」→「OK」でまた「ルールの管理」画面に戻ります。 同じく左上の「新規ルール」を選択→「数式を使用して、書式設定するセルを決定」を選択 数式入力欄に　=$I6<>""　の式を入れ、「書式」から黄色を選択し「OK」→「OK」→「OK」で条件付き書式が設定されます。（添付したサンプル画像を参照して下さい） ※　例えば行単位ではなく、列単位で色を設定したい場合は次の式になります。 ＜例＞　=$J6<>""　→　=J$6<>""　となります。（＄マークの場所に注意）
そのファイルのバックアップコピーを取ってから、 壊れて開けなくなったファイルを修復する方法 http://www.microsoft.com/ja-jp/atlife/tips/archi … をお試しください。
その、マウスの反応に引っかかり感があると言うのがExcel以外の作業でも出るのなら、マウスそのものの問題です。無線マウスだったら電池交換だけで治っちゃうかも知れませんし、透明シートや平滑性の高いテーブル上で操作している場合は、適当な紙でも置いてその上で操作してみれば、操作面の影響かどうかもはっきりするでしょう。 が、Excel限定での話だとしたら、それはPC性能が足りていないことになるため、簡単には行かなくなります。 > 尚、PCは、WIN８で、能力は、充分に対応していると思っています。 失礼ながら、見ず知らずの第三者からでは本当に十分かどうかは判断できませんので、こうした質問時にはメーカーと機種名を具体的に記すか、PCメーカーが出している、その機種のカタログページへのリンクを貼るなどすることをお勧めします。
私のやっている方法でよければですが…… ふつうのマクロですと、セキュリティが掛かりますが、これは掛かりません。 まず、個人用マクロブックを用います。既にありましたら、そこは割愛してかまいせん。 開発やExcelの左隅の下の記録用マクロボタンで、「マクロの記録」を取ります。 保存先は、「個人用マクロブック」です。 マウスを一度、セルをクリックした程度で十分です。 （これが一番楽な個人用マクロブックの作り方です。手動でやろうとしても、設定が多すぎて、とても面倒です。) 「マクロの記録を終了させてください」 次に、VBEditor 画面を開いてください。開発の所から、[Visual Basic ]または、[Alt + F11]で開きます。 すると、 添付画像のような部分がありませんでしょうか？ そのModule1 を開きます。 以下を貼り付けてしまいます。 ただし、 　 Application.OnKey "^+g", "Module1.Style_Good" 　 Application.OnKey "^+b", "Module1.Style_Bad" は、 　　現在、Ctrl + Shift + g ->スタイル "良い"　| "^+g" 　　　　　Ctrl + Shift + b ->スタイル "悪い"　| "^+b", にしています。 Key はこのようにして表します。(onkey メソッド) コントロールキーだけの組合せですと、既存のものがありますので、なるべく避けてください。 Shift　 + Ctrl　　 ^ Alt　　 % Application.OnKey [シーョトキー], [(モジュール名.)マクロ名] (カッコ内は省略してもよいです) キーの詳細は以下のようになっています。 https://msdn.microsoft.com/ja-jp/library/office/ … すべてが終わったら、一旦　Excelを終了して、再起動して、ショートカットを試してみてください。 なお、このショートカットは、最初にマウスでセルの範囲、またはセルを選択してから、ショートカットをかけます。既にスタイルがついた所は、元の標準に戻るようにしています。 '----------------------- Sub Auto_Open() 　 Application.OnKey "^+g", "Module1.Style_Good" 　 Application.OnKey "^+b", "Module1.Style_Bad" End Sub Sub Style_Good() Dim Rng As Range Dim c As Range 　If TypeName(Selection) = "Range" Then 　　Set Rng = Selection 　Else 　　Exit Sub 　End If 　For Each c In Rng 　If c.Style.Name = "Normal" Then 　　 c.Style = "良い" 　Else 　　 c.Style = "Normal" 　End If 　Next c End Sub Sub Style_Bad() Dim Rng As Range Dim c As Range 　If TypeName(Selection) = "Range" Then 　　Set Rng = Selection 　Else 　　Exit Sub 　End If 　For Each c In Rng 　If c.Style.Name = "Normal" Then 　　 c.Style = "悪い" 　Else 　　 c.Style = "Normal" 　End If 　Next c End Sub '----------------------
こんにちは。 >貴兄の「JRAのサイトは、オッズには直接飛べなかったですが」と言う事は通常はマクロが組めると言うことなのですね、目標は高いですがそれを目指していく所存です。 つまり、逆にいうと、直接飛ぶノウハウがあるということです。（^^; マクロというか、その技術は存在します。昨日、この話をしたかったものの、多くの人は、欲得づくでは、この技術は習得できないからなのです。VBAの基礎からでは、天才的な人なら数ヶ月でマスターできますが、ふつうの人は、3年近くかかる人もいます。 これは、ネットの世界では「スクレイピング」と呼ばれています。VBAの集大成のひとつかもしれません。 VBAプログラマとしては、多くの人は素人同然だったのに、ある人のお陰で、JRA（他は知られていません)のデータ取得マクロを組めるようになったことは革命的なのです。しかし、その弊害は、あちこちで、自動的にサイト情報を取ろうとした人間が増えてしまって、例えば、ハローワークの求人検索などは禁止になってしまいました。 「スクレイピング　JRA」 このキーワードを忘れなければ、そのサイトは見つかります。 http://www.f3.dion.ne.jp/~element/msaccess/AcTip … 内容は古いけども、半年ぐらいで、出来るようになります。 ですが、残念なことに、教えて！gooで何度も、Excel VBAを使ってデータを取得する方法を、あちこちで聞いている人がいますが、その人の技術では残念ながら、無理だったようです。私自身、積極的に教えようとは思いません。私でも、独学なのですが、単なる「スクレイピング」ではなく、今は、HTMLやJavaScriptの知識を必要とされます。 そのサイトを書いた人は、YU-TANGさんという方で、かつて、ここの掲示板にも出ていたことがあります。 私は、そのサイトで学びました。今や、VBA界の伝説的な人（レジェンド)の一人となってしまいました。それに、この方よりも前にJRAデータを取得する方法を発表したプロのプログラマの人がいますが、あまりに、難しすぎました。 JRAサイトの取得で、「スクレイピング」は、未だに許可しているようです。この技術の応用は、もっと難しくなりますが、ロト6などにも応用できるようです。
開きたいファイルをダブルクリック、または、右クリックから「開く」を選択すれば、ファイルは開くはずです。 「互換性機能パック」は、OfficeのSPによっても作動しないことがあったような気がします。 互換機能パックで「.docx」「.xlsx」を旧Officeで開く方法 http://hpc.blog0.jp/archives/2669
色そのものを識別できるワークシート関数は、今のところ Excel には、ありません。（VBA によるユーザー定義関数や、エクセル4.0マクロと呼ばれる古い数式を使う方法もなくはないですが） 一般的には、何らかの条件を満たすセルに対して色を付けているのであれば（＊）、それと同じ条件を数式中に記述することにより、結果的に、色が付いているセルを対象としたカウントなどの計算を実現できます。 例えば、B 列にある「200 以下の」値に色が付いているとき、そのうち 100 を超えるセルの個数は、次式で算出できます。 =countifs(b:b,">100",b:b,"<=200") ＊この色付けの作業は、条件付き書式という機能により自動化できます。 また、「100 を超え、かつ 200 以下の」値に色が付いている場合は、オートフィルタにある「色フィルタ」機能と SUBTOTAL 関数を併用することにより、色の付いたセル数を数えることができます。 B15　=subtotal(2,b2:b14)　……第 1 引数（集計方法）において、合計ではなくカウントを指定 添付図は、黄色のセルの行のみに色フィルタで絞り込んだものです。その結果として表示されている行数が B15 セルに算出されています。
>大至急よろしくお願いいたします という所からは、こちらの回答は大ハズレもいいところですが、少し気になりました。 #2さんの回答が、大正解だと思います。 ただ、添付画像のように、項目名などがない表、画像のままのデータを使うことにしました。大量のデータは、多少、出てくるまで時間が掛かります。 ''// Sub FilterNumberPickUp() 'No. 9025727 Dim Rng As Range Dim r As Range Dim uRng As Variant Dim lstRw As Long, cl As Long Dim i As Long With ActiveSheet 　''ここが重要:CurrentRegion は、A1から地続きの範囲を取得するものです。斜めでも地続きです。 　Set Rng = Range("A1").CurrentRegion 　If Range("G1").Value = "" Then 　　 MsgBox "G1 に検索値がありません。", vbExclamation: Exit Sub 　End If 　Application.ScreenUpdating = False 　For Each r In Rng.Rows 　　If WorksheetFunction.CountIf(r, Range("G1").Value) > 0 And _ 　　　Not IsObject(uRng) Then 　　　Set uRng = r 　　ElseIf WorksheetFunction.CountIf(r, Range("G1").Value) > 0 Then 　　　 Set uRng = Union(uRng, r) 　　End If 　Next 　lstRw = Rng.Cells(Rng.Cells.Count).Row 　 　cl = Rng.Columns.Count　''これは使っていない変数（値貼り付けに利用するため) 　i = lstRw + 3 　For Each r In uRng.Rows 　　r.Copy .Cells(i, 1) 　　i = i + 1 　Next 　Application.ScreenUpdating = True End With End Sub ''///
No,1です。 ＞Excel2003とか2010とか言われてもさっぱり分からん、詰まらんこと言ってないで日常業務 これは、２０１０のメリットとかを説明する前に Excel2003は、セキィリティ上、法人ではどこも使わないことにしています Excel2003のファイル形式で配布すると、Excel2003でも使用できると云う事になります。 Excel2003の絶滅の為にも、全てのファイルを２０１０の形式にするのが通常です。 と説明しましょう。 その時に、先に紹介したようなシートの構成を勝手に導入しましょう。 10人中1名くらいでも賛同者が得られれば十分です。 面白いコラムありますので紹介しておきます。 http://vbae.odyssey-com.co.jp/column/no11_3.html
初歩の初歩！簡単！ A表のセル A1 に入力してある数値を変更すると、B表のセル AA1 にも反映されるようにしたいなら、セル AA1 に式 =A1 を入力すれば済むこと！
＞「Ａ」を選んだ時だけ、希望のセルに文字が入るようにできる関数・・・？ 　「A」を選んだ時だけ同じ「A」が返ってくるという意味でしょうか？ 取り敢えず以下の方法で・・・。 ドロップダウンを作成したセルが例えばセルC3だと仮定して・・・ 文字を返したい希望のセルに次の式を入れます。 =IF(C3="A",C3,"")
>ページ設定情報とかいろいろ機能を入れてるシートなので、そのままコピーして使いたいのですがね。 そうですね。それなら、 >　 origSheet.UsedRange.Copy ' UsedRangeをコピー 　　origSheet.Activate 　　Cells.Copy 　　newSheet.Activate 　　newSheet.Paste で、機能的にもコピーされるはずです。これ自体は問題ないと思います。 >CodeNameをマクロから直接書き換えようとしたこともありますが、やはり危険なようです。 別に、危険ということではなく、知っている人には、そういうコードは、疎ましいだけです。まして、97のVBAは、今というよりも、Excel2000以降とはちょっと違う部分があるし、いまさら、Excel 97の脆弱性について、考えなくてはならないのは頭の痛いことだと思います。
No.1 です。 > 範囲以外はデータがないものとして印刷できるのですが、総ページをヘッダー等に表示させると、範囲指定しているところは1ページなのに総ページ2ページとなります。 総ページ２の２ページ目はどのようなデータが表示されますか？ もしかして、左右の余白との関係で、２ページ目の空白ページがカウントされているようなことはないでしょうか？ 総ページ３のデータで、確かめてみました所、印刷範囲を指定したページのみが印刷され、1 / 1の表示で印刷が可能でした。
No.2・3です。 何度もごめんなさい。 前回のコードでは入力セルが離れている場合、半角スペースが余分に入ってしまいますので、 ↓のコードにしてください。 Function Mystr(myRng As Range) 'この行から// Dim c As Range, str As String, buf As String For Each c In myRng If c <> "" Then If c.NumberFormatLocal = "mm/dd" Then str = Format(c, "mm/dd") Else str = c End If buf = buf & str & " " End If Next c Mystr = Left(buf, Len(buf) - 1) End Function 'この行まで// ※　検証せずに投稿してごめんなさい。m(_ _)m
こんにちは！ 画像の配置だと B8セルに =IFERROR(INDEX($A4:$Z4,,SMALL(IF($A1:$Z1="●",COLUMN($A1:$Z1)),COLUMN(A1))),"") 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は 上記数式をドラッグ＆コピー　→　B8セルを選択　→　数式バー内に貼り付け　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定！ 数式の前後に{ }マークが入り配列数式になります。 B8セルのフィルハンドルで右へコピーしてみてください。m(_ _)m
>不等号No.1～47ではない あくまでも、Excelの数式とするなら、 A1に対して、 =OR(A1<1,A1>47) その否定形(意味は上記と同じだけれども、反転します) =NOT(AND(A1>=1,A1<=47))
>このような事ができるのでしょうか？ できます。 入力規則をセルによって自動的に変わるようにするちょいわざ http://edutainment-fun.com/excel/waza/inputcondy … ただし、商品番号を後から選ぶと存在しない色とサイズが出るので、条件付き書式で注意を促したり、 商品番号を編集するときに色やサイズも消すような仕組み(VBA)が必要になります
えーっと、Sheet1とSheet2をどちらも選択した状態で移動させるとか？
[No.2お礼]へのコメント、 現在ではブックを閉じるときに必ず「空のウインドウ」が出ます。 先ほどは初めてエラーメッセージが出たけど、ウッカリして読まずに閉じてしまいました。日本文だけどその中にSolver という文字が垣間見れました。
こんにちは。 変数はダブルクォーテーション("")で括ってはいけません。 ThisWorkbook.Path & "\fname"　'←ここが間違いです。 例 '// Sub Macro1() 'No. 9022934 Dim ws1 As Worksheet Dim R As Integer Dim fName As String Set ws1 = Worksheets("電気料明細") ws1.Select R = ws1.Cells(5, 4).Value fName = ThisWorkbook.Path & "\" & Range("D5").Value & "D.jpg" Range("D35").Select With ws1.Pictures.Insert(Filename:=fName) 　　　　.Top = ActiveCell.Top 　　　　.Left = ActiveCell.Left 　　　　.Width = 184.2 End With End Sub '/// 私も「電気料明細」を毎月作っています。月ごとで、係数が変わりますので、結構、最初、面倒だと思いました。
意気込みだけでやったので、手順が多いのが難点ですが、参考になれば幸いです。 １．Fig-1 に示すワークシートを作成 ＿＿E2: =COUNTIF(C:C,A2) ＿＿F2: =H2<>I2 ＿＿セルI2 に式 =IF(H2="","",VLOOKUP(G2,C:D,2,FALSE)) ＿＿を入力して、此れを下方にズズーッとドラッグ＆ペースト ＿＿ちなみに、範囲 E1:F1 は空白のままで放置(←必須！) ２．次の設定で[フィルタオプションの設定]を実行 ＿＿[抽出先] “指定した範囲” ＿＿[リスト範囲] $A:$B ＿＿[検索条件範囲] $E$1:$E$2 ＿＿[抽出範囲] $G$1:$H$1 ＿＿その結果を Fig-2 に示した。 ３．次の設定で[フィルタオプションの設定]を実行 ＿＿[抽出先] “指定した範囲” ＿＿[リスト範囲] $G:$I ＿＿[検索条件範囲] $F$1:$F$2 ＿＿[抽出範囲] $J:$L ＿＿その結果を Fig-3 に示した。
こんにちは。 sakuma8755様 返事を書いている内に躊躇してしまいました。私は、もう現役でもないし、私のような人間の話は、あまり役に立たないかもしれない、と思い始めたからです。PCについては、インストラクターの資格もありますが、そんなことは、あまり大したものではありません。 >小さい商店でも、エクセルだけで、在庫数、販売数、仕入数、その日時を管理するのは難しいでしょうか？ 笹原清明という税理士の人が、Excelや弥生を元に、PC管理のコツを書いています。 http://www.maps-keiri.gr.jp/index.html この著者は、おそらく多くの会社を指導してきた経験からでしょうけれども、紙に書いたものをインプットするのではなく、ダイレクトにPCに入力をすることだと書いています。 しかし、実際、現場とデスクを行き来する私などには、そういうことは出来ませんでした。 ・パソコン会計の導入成功のためのポイント なお、Excelのフォーマットが公開されていますので、それを使えばよいと思います。私がやっていた方法に最も近いものを探してみました。しばらくは、試行錯誤のはずです。 在庫管理表 http://ameblo.jp/nezi-biz/entry-11504399333.html 以下は、在庫管理表の問題点を指摘しています。 エクセル（EXCEL）による在庫管理の限界 http://www.zaikokanri.com/column/2013/11_13_01.h … 1)～5)までの問題は、Excelのままでも、ある程度解消できます。このサイトのように、基幹システムとして導入するのは、足の早い商品に限ります。 品名　前月在庫　仕入　出庫　7月度・在庫　（金額が必要な場合は、単価*在庫) A1 A2 A3 B1 B2 B3 このような表を月単位につけていけばよいわけです。 決算とか、締めとかを、商品管理にも是非取り入れて、年度のまとめをつくってください。だいたい、3年ぐらいのまとめを作るうちに、スタイルが固まります。 >「在庫管理がしたいから販売した又は工事で使用した分の商品を記入してくれ」 それは、お父様でなくても、嫌がりますでしょうね。むろん、大きな会社の経営者ですと、真っ先にPC管理に飛びついて、それで夢をみてしまうものですが、会社では、現場にいる人たちは、トップダウンで渋々従うだけのことです。そうではなくて、まず自分の出来るところから始めるというのが、小規模な経営の鉄則です。できれば、販売実績の明細が、自分の元に自然に入るような仕組みを作ったほうがよいでしょうね。 ところで、『パレートの法則』というのをご存知ですか？(Wikipediaより) ・ビジネスにおいて、売上の8割は全顧客の2割が生み出している。よって売上を伸ばすには顧客全員を対象としたサービスを行うよりも、2割の顧客に的を絞ったサービスを行う方が効率的である。 ・商品の売上の8割は、全商品銘柄のうちの2割で生み出している。 私が仕事をしている時代には、7・3の法則と呼ばれていました。8割2割の配分が、7割3割に変わるだけです。 つまり、3000点の商品があっても、600点～900点ぐらいしか、商品的には流通していない、ということで、商品群からすれば、もっと少ないことが分かるはずです。在庫管理にしても、当面、2～3ヶ月の1度のわりでもよいので、動く商品群だけの棚卸しをすることをお勧めします。 私は、あまりPC管理を強調したりしません。現場に立つ人のことを考えると、そんなに言えないのです。 なお、初歩的な経営分析などは、日本法令の適当な一冊を買えば、十分だと思います。例えば、商品回転率などは、頭に入れておく必要があるかと思います。 さて、ここから、PCとは関係のない話です。過去の私自身の問題点を投影して述べさせていただきます。 >個人商店なので色々と一人でやらなくてはならないことはありますが、商品管理もしっかりしていきたいと感じました。 もちろん、現場に立つ人の仕事というのは、本当にいろいろあります。私のことを買いかぶっていますが、かつての私の問題点は、それは、sakuma8755様も同じかもしれないので、真摯に申し上げます。 世の中には、日々の雑務に忙殺されて、経営が疎かになる人たちは大勢います。また、そういう雑務に忙殺されていること自体に快感を覚える人もいます。 親子であれ、中小企業の社員であれ、本人がある程度仕事に熟達しますと代わりなどはいません。お互いがお互いの立場を尊重する代わりに、お互いがその仕事を続けてもらいたいと思いますから、縛りあってしまいます。失礼ながら、近い将来、お店を背負っていかなくてはならない身では、商品管理だけでなく、幅広い知識や人脈が必要ではないかと思います。 例えば、商工会や組合などの寄り合いはありませんか？同じ年代の同じ業種との人とはお話になりますか？それに、取引先など幅広い人との交流が重要ではないか、と思うのです。私は、一時期、営業部に配属されかけた時には、部長について、外回りもし期待しましたが、結局は、発注を含めた商品管理であり、会計経理に戻ってしまい、ほとんど、それらに忙殺されていたというのも過言ではありません。 こうした付き合いの中では、いろんなノウハウも聞けることがあります。だんだん、年齢が高くなるにつれて、当たり障りのない話だけで、お互いの情報交換が難しくなります。もし経営を担っていくなら、商店の中だけではなく、いろいろと外を回ってみるのが、ずっと有効だと思います。こんなことは、余計なお世話の話かもしれませんが……。 私の自戒を込めて。
セルD1に　=MAX(B1:C1) の式を入れて、下方向へ式をオートフィルコピー 添付されている画像の5行目以降までず～っと式をコピーしていくとD6以降に「０」が返って来ますので、「０」が目障りのようでしたら、D列を右クリックして「セルの書式設定」から「ユーザー設定」を選択し「種類」の枠内に表示されている「G/標準」を「＃」に直してEnterキーを押すと「０」が消えます。
提案としては、今のところ、このようなものが考えられます。 ・Excelの"QueryTable" を使う ・Open infile For Input As #fileNo のスタイルをやめて、FileSystemObject のOpenTextFile で読む。(ReadLine か、ReadAllを使う) ・Open infile For Input As #fileNoではなく、以下の様なバイナリで読んでいく。 　Open inFile For Binary Access Read As #fileNo 　bufbyte = InputB(LOF(fileNo), #fileNo) ''bufbyte は、byte 配列変数 実際は、試してないので、はっきりしたことは言えません。
> EXCELで、行の幅を全部同じではなく、 > 例えば、３行、６行、９行目だけみたいに > ３つ飛ばしだけを、幅を同じに設定したいのですが Excelでは、Wordの表のように、同じ列の一部のセルの幅を変えることはできません。 どうしても変更が必要な場合は、もう1列追加して、変更したい行のセルを結合する必要があります。
こんにちは。 　Workbooks.Open (filename) これは、あやふやなコードですね。これで、開ける確率は、半々というところでしょうか？ ステップモードとローカルウィンドウで追いかけてみれば、一目瞭然のはずです。 もちろん、 >集約用のExcel名に?＄とついたものがフォルダ内に自動生成され、こちらが使用中なのでエラーとなったようです。 #1様の言うとおりで、それは、ありえませんね。 >一つのもの以外は共通フォームです。 意味は分かります。同じ表の形式で作られたファイルという意味ですね。 ところで、私がマクロを書く時、Dir 関数って、意外にデリケートな部分があって、あまりお膳立てが過ぎると、おかしくなってしまうような気がします。それで、マクロにする時は、最初に、Dir 関数で全部ファイル名を取っておいて、配列変数に格納してから処理するという方法を取ることが多いです。今回は問題なかったようですが。 少し、洒落た書き方をさせてもらいます。 '// Sub OpenOrNotFiles() 　Dim FName As String 　Dim myPath As String 　Dim myFno As Integer 　Dim iflg As Integer 　myPath = ThisWorkbook.Path & "\" 　 　FName = Dir(ThisWorkbook.Path & "\*.xls*", vbNormal) '←一応念のため 　Do While FName <> "" 　　If Dir(myPath & FName) <> "" Then 　　　myFno = FreeFile() 　　　On Error Resume Next 　　　Open myPath & FName For Binary Lock Read Write As #myFno 　　　iflg = Err() 　　　Close #myFno 　　End If 　　　If iflg = 0 Then 　　　 Workbooks.Open (myPath & FName)　'←こうなります。 　　　 ''Debug.Print myPath & FName 　　　End If 　　　　FName = Dir 　　Loop End Sub '///
コードをそのまま活かすことにしました。 Const cnsSOUR = "E:\DATA\*.csv" ' 元ファイル(拡張子CSV全て) これを、やめて、 '// Dim mySOURCE　As String　　'モジュールレベルの変数にします。 Sub USB_drive() 　' 　' USB_drive Macro 　' 　Dim objFSO As FileSystemObject　'参照設定 　Dim dvs As Object, dv As Object 　Set objFSO = New FileSystemObject 　Set dvs = objFSO.drives 　For Each dv In dvs 　　With dv 　　　If .IsReady And .DriveType = 1 Then 　　　　'If .VolumeName = "日報DATA" Then 　　　　　MsgBox "USBドライブは " & .DriveLetter & " です。" 　　　　　mySOURCE = .DriveLetter　　'←これを加えます。 　　　　'End If 　　　End If 　　End With 　Next 　Set objFSO = Nothing 　Set dvs = Nothing 　Call USB取り込み End Sub Sub USB取り込み()　' 　Dim rc As Integer '生きていない変数 　Dim intMsgBox As VbMsgBoxResult 　Dim objFSO As FileSystemObject ' FSO　Windows Script Host Object Model (参照設定なら、上記のコードもそのまま使いましょう) 　 　Const cnsDEST = "D:\DATA2\" ' 先フォルダ　(これはそのまま) 　 　intMsgBox = MsgBox("USBからの取り込みをを実行しますか？", vbOKCancel) 　If intMsgBox = vbCancel Then 　　MsgBox "取り込みをキャンセルしました" 　　Exit Sub 　End If 　 　'このように、取得したドライブ名を以下に当てます。 　mySOURCE = mySOURCE & ":\DATA\*.csv"　' 元ファイル(拡張子CSV全て) 　 　Set objFSO = New FileSystemObject 　' ファイルコピー 　 objFSO.CopyFile mySOURCE, cnsDEST, True 　Application.ScreenUpdating = True '画面更新 　If rc = 0 Then 　　MsgBox "ＵＳＢからの取り込みは正常に終了しました" 　End If 　 　 Sheets("操作").Select 　Range("A1").Select 　Set objFSO = Nothing End Sub '///
こんばんは！ 「A」Sheetのシートモジュールにしてみてください。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Intersect(Target, Range("A3:R102")) Is Nothing Then Exit Sub Cancel = True Worksheets("B").Range("I7") = Cells(Target.Row, "A") End Sub こんな感じではどうでしょうか？m(_ _)m
申し訳ありません。 セルBの編集時に、セルCとBを取り込む様な記述になっていましたので、発音記号は、セルAの後半部分と、セルBの改行後部分になっていて、かつ、例文がない状態だったのではないでしょうか？ 修正しましたので、試してみてください。 ※修正箇所は「セルBの編集」の一行です。 Sub Cell_Edit() 　　'変数定義 　　'行番号 　　Dim i as Long 　　'画面更新OFF 　　Application.ScreenUpdating = False 　　'変数（行数）の初期化 　　i = 1 　　Do 　　　　'処理終了判定（セルAが空なら処理終了） 　　　　If Trim(cells(i, 1).value) = "" Then 　　　　　　Exit Do 　　　　End If 　　　　'セルAの編集 　　　　Cells(i, 1).Value = Cells(i, 1).Value & " " & Cells(i, 2).Value 　　　　'セルBの編集 　　　　Cells(i, 2).Value = Cells(i, 3).Value & vbLf & Cells(i, 4).Value 　　　　'セルCとDの編集（クリア） 　　　　Cells(i, 3).Value = "" 　　　　Cells(i, 4).Value = "" 　　　　'変数（行数）のカウントアップ 　　　　i = i + 1 　　Loop 　　'画面更新ON 　　Application.ScreenUpdating = True End Sub
配列数式は関係ないです。単純にリストをセルに表示するために示しただけです 要は、説明不足。原因となる心当たりがないため、基本的な2段階の入力規則の方法を簡易的に示してみました。 BQ10セルにはどのような文字列を入れ、どのような名前を定義し、定義した範囲はどのようになっているのでしょう？ 最終的には「BQ10セルを入力規則のリストによって選択後、BL10セルに対象となるリストを選択させたい。」 と言うことだとは読み取りましたが、エラーが出るからエラーの原因を知りたい といっても、過程が不明だから原因が探れません。
＞第5～第7回のところに、条件書式を入れて色をつけたいです。 画像を添付しますので、この添付画像をもとに説明します。 ☆まず先にセルF2～H10を選択しておきます。☆ 「ホーム」たぶから「条件付き書式」をクリックし「ルールの管理」をクリック。 左上の「新規ルール」をクリックし「数式を使用して書式設定～～」をクリック。 条件と書式を設定していきます。 １）前回（第4回）に〇がついていれば、色なし　←この条件を設定 　　数式入力欄に　=$E2="○"　の式を入力し、「書式」→「塗りつぶし」で「白」を選択 　　式と書式の設定が出来たら「OK」→「OK」を押し、 　　同じようにまた「新規ルール」をクリックし「数式を使用して書式設定～～」をクリック。 ２）第４回空欄、第３回〇　色薄め　←この条件を設定 　　数式入力欄に　=AND(E2="",D2="○")　の式を入力し、「書式」→「塗りつぶし」で色を設定 　　設定後「OK」→「OK」で同じくまた「新規ルール」をクリックし「数式を使用して書式設定～～」をクリック。 ３）第４回空欄、第３回空欄　（２）より色濃く　←この条件を設定 　　数式入力欄に　=AND(E2="",D2="")　の式を入力し、「書式」→「塗りつぶし」で色を設定 　　設定後「OK」→「OK」で同じくまた「新規ルール」をクリックし「数式を使用して書式設定～～」をクリック。 ４）第４回空欄、第３回空欄、第２回空欄　（３）より色濃く　←この条件を設定　 　数式入力欄に　=AND(E2="",D2="",C2="")　の式を入力し「書式」と「塗りつぶし」で色を設定 　設定後「OK」→「OK」で「条件付き書式のルール」画面に戻り条件の順番を変更していきます。 =$E2="○"　　　　　　　　　←この式を1番上に上げます。 =AND(E2="",D2="○")　　　←この式を2番目にします。 =AND(E2="",D2="",C2="")　←この式を3番目にします。 =AND(E2="",D2="")　　　　←この式を4番目にします。 ※条件付きの式を上下に上げ下げする場合 「新規ルール」「ルールの編集」「ルールの削除」の右隣にある▲と▼で、移動するルールを選択した状態で▼▲で上下させt下移動させます。 以上、上の順序でルールを設定すると添付画像の様になります。
通常はエンターを押したら下へ移動するので B14→I12　だけ指定すれば良いですよね シート名のタブを右クリック コードの表示をクリック VBエディターが起動したら Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address = "$B$14" Then Range("I12").Activate End Sub を張り付けて閉じる では如何でしょうか。
こんにちは。 レスがつきませんね。 この質問には、かなり難しい部分があります。 (1)　表2の流れが、右から左になっているからです。 表1では、上から下に時系列になっているのに、表2は、日付が逆です。 そうすると、その都度、挿入か、移動ということになりますね。マクロしか可能としません。 (2)この表の致命的なのは、セルの位置情報がありません。 この2点に加えて、 (3)　個々の名称がかろうじてしか読み取れません。 一度、ここを締めきって、思い切って、この表自体を、どこかの匿名オンライン・ストレージやアップロード・サイトに、公開させてしまうことをお勧めします。それで、レスが着かなければ残念ながら諦めるしかありません。 そうでなければ、これほど細かいものは、全体像は分かっても、仮に、マクロなどをさし上げても、それを組み込めないのではないかと思います。なお、マクロ以外には、この表2の時系列が逆なものは処理しきれないと思います。
＞一か月いくらか？　その中でいつが多いのか？　どこが多いのか？ 全てヤマトビジネスメンバーズの機能にありますよ。 日別集計と県別集計の表が自動で出来ます。 もし、客先別（取引先別）とかで集計したければ 全ての送り状を　B2Webで印刷してしまえば、出荷データから 集計が可能です。
こんにちは！ 画像の配置通りだとすると F2セルに =SUMIFS($C:$C,$A:$A,F$1,$B:$B,$E2) という数式を入れ、列・行方向にフィルハンドルでコピーしてみてください。 ※　余計なお世話かもしれませんが、 消費税は一般的に8%と決まっていますので、A～C列から除外し 後から計算する方が簡単だと思います。m(_ _)m
数値が1桁か2桁なら、 B2に =MID(A$1,FIND(A2,A$1)+LEN(A2),IF(ISERROR(VALUE(MID(A$1,FIND(A2,A$1)+LEN(A2),2))), 1,2)) と入れて、B3,B4にコピー
こんにちは。 最終的には、IFERROR関数が、問題を引き起こしているようです。Excel 2007以降、同じ問題がずっと続いているようで、バグの類であると私は考えています。この関数を使った[名前の登録]にエラーが発生すると、見えないオブジェクトの_xlfn.IFERROR が発生し、表面化するということで、関数を使う限りは、#3のマクロで、一応は消えている状態になっているということです。エラー値が生じていなければ、問題はありません。 互換性チェックをして、バージョンダウンした数式を使うなら、せっかくの上位バージョンを使う意味もなくなってしまいます。 もし、このエラーが、どんどん増えたとしたら、メモリ枠を使いきってしまいます。Excelのメモリというのは、それぞれの機能で割り振りされていますから、全体のメモリがあっても、個々の書式にしても、マクロにしても、それほど大きくはありません。したがって、トラブルの発生の元にはなりますでしょう。 あまり、スッキリとした解決方法ではなかったのですが、私自身、いずれ、再び、この問題に直面する時が来るかもしれません。
>このような場合の関数をご存知でしたらご教授下さい いや、だからそうなったら二つ目以降のデータをどこに表示するのか…と思ったんですが。
「Sheet2」のマクロに以下のコードを入れて下さい。 すると、Sheet2を選択することでメッセージボックスが出ます。 [はい]ボタンを押すとSheet2がアクティブになり、 [いいえ]ボタンを押すとSheet1がアクティブになります。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Private Sub Worksheet_Activate() Dim rc As Integer rc = MsgBox("このシートでは〇〇をします。よろしいですか？" & _ vbCrLf & "よろしければ[はい]ボタンを押して下さい。", vbYesNo + vbQuestion, "確認") If rc <> vbYes Then Sheets("Sheet1").Select End If End Sub ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ※このマクロはモジュールではなくワークシートのイベントへ書いてください。
こんばんは！ ＞印刷マクロボタンを作りたいです。 というコトですので、「A」Sheetにコマンドボタンを挿入した場合の一例です。 ごくごく簡単に・・・ Private Sub CommandButton1_Click() Worksheets("B").PrintOut copies:=2 With Worksheets("C") If Worksheets("A").Range("B35") = "" Then .PrintOut copies:=2, from:=1, to:=1 Else .PrintOut copies:=2, from:=1, to:=2 End If End With End Sub こんな感じではどうでしょうか？m(_ _)m
""は、未入力の状態を表しています。 「W3=""」は、セルW3に何も入力されていないと言う意味です。
まず最初の=は数式を始まりを意味しています． 数式の中には関数以外の文字を入れるとエラーが発生します． 数式の中に文字を入れたい場合には""を利用します． 例えばA列に数値（A1は3，A2は2とすると）が入っていて， B1のセルに="合計は"&SUM(A1:A2)"です" とすれば，B1のセルには「合計は5です」と表示されます． 質問文に書かれている""の場合には「"」と「"」の間に文字が入っていないので空白を示しています． 例えば=IF(A1="",TRUE,FALSE)という数式をA2に入れたとしましょう． A1が空白の場合にはA2はTRUE A1が空白ではないの場合にはA2はFALSE と表示されます．
>値の貼り付けの際に、テキストを 選ぶ画面が出たり はわかりませんが、 >置き換えの際に、一致するデータが見つかりませんのエラーがでたりします。 は環境が一致していないからだと思われます。 ="='"&LEFT(CELL("filename",Sheet1!$A$1),FIND("[",CELL("filename",Sheet1!$A$1))-1)&"B\["&$A2&".xls] 条件を書き忘れてました N1.xlsを想定。 上記、拡張子は適宜変えてください Sheet1であることを想定 シート名は適宜変えてください。また、同一のシート名としています 単純にN1.xlsファイルのSheet1!B2セルをコピーし、fileAにリンク貼り付けします。 N1.xlsファイルを閉じれば、上記式からの値を貼り付けたものと合致していればOK 違うなら、数式を修正します。 若干余分なものもあったので ="='"&LEFT(CELL("filename",$A$1),FIND("[",CELL("filename",$A$1))-1)&"B\["&$A2&".xls]sheet1'!"&B$1
① 可能です。Office2013ですけど、実際に使っています。 OSは Windows 8.1 Pro Update になってますけど。 ② 製品としては32bit/64bitの区別はありません。 インストール時に選択することになりますが、OSが64bitでも通常は32bitを使います。Microsoft自身が64bit版は奨めていません。 特別に必要がある場合だけ64bitを選択してください。 https://technet.microsoft.com/ja-jp/library/ee68 … ③ まず適切な製品ではありません。 違法かどうかは判断が難しいですが、少なくともMicrosoftとの契約にはそぐわない形で販売されています。 # 中国国内向けとか、PC同梱専用品とか 販売者でなく利用者が違法となる製品もありますので注意ください。 ④ おそらくは問題ありません。 Bluetoothなどほかのアダプタがネットワーク1になっているとかではないですか。あるいは一度作り直したとか。
>4～49行がデータ >50～95行がデータ この行数、つまり45行入るかどうかは、このマクロは考慮されておりません。最初、プレビューから、マージンなどで、調整して納まるようにしてください。 また、一応、垂直改行は考慮はしていますが、1ページに収まらない右にはみ出た分に関しては、処理できません。 もし、とのようなスタイルでも、希望の行数にするなら、手動改ページを入れるなど、別のマクロが必要です。 '// Sub PrintOutMacro() 　Dim i As Long 　Dim sPrintArea As String 　Dim HPage As Long 　Dim VPage As Long 　Dim PageTotal As Long 　Dim FirstPage As Integer 　Dim LastRow As Long 　Dim RightCol As Long 　With ActiveSheet 　　'------------------------------- 　　'印刷範囲再設定 　　LastRow = Cells(Rows.Count, 1).End(xlUp).Row 　　RightCol = Cells(4, Columns.Count).End(xlToLeft).Column 　　sPrintArea = Range("A4", .Cells(LastRow, RightCol)).Address 　　.PageSetup.PrintArea = sPrintArea 　　'------------------------------- 　　FirstPage = 1 '最初のページ 　　On Error Resume Next 　　'ページ数の算出 　　HPage = ExecuteExcel4Macro("COLUMNS(GET.DOCUMENT(64))") - 1 　　VPage = ExecuteExcel4Macro("COLUMNS(GET.DOCUMENT(65))") 　　On Error GoTo 0 　　PageTotal = Int(HPage * VPage)　'ページ総数 　　'誤動作のための保守 　　If PageTotal <= 2 Then 　　If MsgBox("ページが、" & PageTotal & "枚しかありませんがよろしいですか？", _ 　　　vbQuestion + vbOKCancel) = vbCancel Then Exit Sub 　　End If 　　For i = FirstPage To PageTotal 　　　If i = 1 Then 　　　　.PageSetup.PrintTitleRows = "$1:$3" 　　　Else 　　　　.PageSetup.PrintTitleRows = "$3:$3" 　　　End If 　　　.PrintOut From:=i, To:=i ', Preview:=True ''外すとプレビューになる 　　Next i 　End With End Sub '///
ホームタブ→右端の「検索と選択」ボタンを押す→オブジェクトの選択 で、如何でしょうか？ http://www.becoolusers.com/office/object-select- … 質問の際はバージョンを記載するようにお願いします。
No1・No2のesupuresso です。 ピボットテーブル全体に罫線を設定する方法を・・・。 ①　ピボットテーブルツールの「デザイン」タブの「ピボットテーブルスタイル」グループのより、▼のボタンのもう一つ下のボタン（その他）ボタンをクリック ②　色々なテーブルスタイルの下の「新しいピボットテーブルスタイル」をクリックします。 ③　テーブル要素の一番上の「テーブル全体」を選択（クリック）して「書式」をクリックします。 ④　線のスタイルからお望みの線を選択し「外枠」「内枠」をそれぞれ設定します。 例えば、外枠に太めの罫線を入れたい場合は、太めの罫線を選択し「外枠」をクリック 内枠の罫線を細めの罫線にしたければ、細めの線を選択し「内枠」をクリックします。 これで外枠と内枠の両方が設定されます。 ⑤　罫線の設定が完了したら「OK」→「OK」で設定を終わらせます。 ⑥　最後に「テーブルスタイル」グループの「その他」のボタンを押してユーザー設定の欄に先程設定したテーブルスタイルが表示されていますので、それをクリックするとピボット全体に設定したスタイルが反映されます。 以上、添付画像を参照して下さい。
こんにちは。 >１シートに１日分の予約があり、プログラムの中にシート名の記載があります。 私も、昔は、1シートにひとつの処理するマクロを置いていたのですが、ファイルとして大きくなるだけでなく、マクロの修正の時に、本当に大変になってしまいます。ボタンが、ActiveX コントロールというのもいけなかったでした。それで作りなおしました。 マクロのコードのシート名は、ActiveSheet で良いです。 また、データの多い少ないは、大きさを自動で換えられます。 左端の一番上だけは決めてください。以下の場合は、E17 になっています。 ただし、ひとつのブックの中に、シートの365枚は作らないほうがよいです。管理が面倒になってしまいます。 次に、マクロの置く場所は標準モジュールです。 それに、「フォームのボタン」を[SortMacro]で、登録します。 今回は、カスタムオーダーリストを登録するマクロを作りました。以下では、Sheet3のA2から、下に向かって、リストが書かれています。しかし、ソートマクロといっしょに行ったら、ブックがハングしましたので、分離しました。そして、ユーザー登録したリストの削除するマクロも作りました。 実際は、リストは、同じブック内のどこでもよいし、一旦、リストを登録したら、シートに書き込みしたものは、削除しても残ります。 num = Application.CustomListCount　 CustomOrder:=num　コードの中で、num というのは、最後にカスタムリストを登録した番号のことです。 さて、同じブック内なら、シート全体をコピーして使っても構いません。ボタンの機能も一緒に着いていきます。 なお、マクロを移す時は、シートのコピー－>新規ブックでよいのですが、マクロのコード自体は、新しいブックの標準モジュールに貼り付けるか、エクスポート・インポートしてあげればよいです。その時に、フォーム・ボタンの中身のマクロの登録も、新しいブックに登録しなおしてください。マクロで、そういうことも可能ですが、ちょっと大げさですね。 '// 'Option Explicit Sub SortMacro() 　Dim OrderList As Variant 　Dim LastCell As Range 　Dim Rng As Range 　Dim num As Integer 　num = Application.CustomListCount 　On Error GoTo ErrHandler 　With ActiveSheet 　　With .Range("E17").CurrentRegion 　　　Set LastCell = .Cells(.Cells.Count) 　　End With 　　Set Rng = .Range("E17", LastCell) 　　 .Sort.SortFields.Clear 　　.Sort.SortFields.Add _ 　　Key:=Rng.Columns(12), _ 　　SortOn:=xlSortOnValues, _ 　　Order:=xlAscending, _ 　　CustomOrder:=num, _ 　　DataOption:=xlSortNormal 　　 　　.Sort.SortFields.Add Key:=Rng.Columns(13), _ 　　SortOn:=xlSortOnValues, _ 　　Order:=xlDescending, _ 　　DataOption:=xlSortTextAsNumbers 　　 　　End With 　　With ActiveSheet.Sort 　　.SetRange Rng 　　.Header = xlYes 　　.MatchCase = False 　　.Orientation = xlTopToBottom 　　.SortMethod = xlPinYin 　　.Apply 　End With ErrHandler: 　 If Err.Number <> 0 Then 　　 MsgBox Err.Number & ": " & Err.Description 　 End If End Sub Sub ResisterOrderList() 'カスタムリストの登録 　Dim num As Integer 　Dim myList As Variant 　Dim buf As String 　On Error Resume Next 　With Worksheets("Sheet3") 　　'（場所は任意)ここでは、Sheet3のA2から一列 　　Application.AddCustomList .Range("A2", .Cells(Rows.Count, 1).End(xlUp)) 　End With 　If Err() <> 0 Then 　　num = Application.CustomListCount 　　myList = Application.GetCustomListContents(num) 　　buf = Mid(Join(myList, ","), 1, 15) 　　MsgBox buf & "...." & vbCrLf & _ 　　"すでに登録している可能性があります。", vbExclamation 　End If 　On Error GoTo 0 End Sub Sub DeleteCustomOrderList() 'カスタムリストの削除 Dim num As Integer Dim myList As Variant Dim buf As String 　 With Application 　 On Error Resume Next 　　num = .CustomListCount 　　myList = .GetCustomListContents(num) 　　buf = Mid(Join(myList, ","), 1, 15) 　　If MsgBox(buf & "...." & vbCrLf & _ 　　"このリストを削除してよろしいですか？", vbOKCancel) = vbOK Then 　　　.DeleteCustomList num 　　End If 　 On Error GoTo 0 　 End With End Sub '///
[Windows]キーって書けばよかったですねm(_ _)m エクセルをセーフモードで起動したことになります OfficeXPの記事ですが https://support.microsoft.com/en-us/kb/881075/ja アドインや個人用マクロブック、起動時にすべてのファイルを開くフォルダ、などを読み込まずに起動するのでそのあたりに問題のファイルがないかなって思ったです。 https://support.office.com/ja-jp/article/Excel-% …
こんばんは！ VBAになりますが、一例です。 ↓の画像のように元データはSheet1にあり、Sheet2に表示するようにしてみました。 （質問の配置とは異なると思いますが、「同一判定キー」の列は不要です。 尚、Sheet3を作業用のSheetとして使用していますので、 Sheet3はまっさらな状態にしておいてください。 Alt＋F11キー　→　メニュー　→　挿入　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim i As Long, lastRow1 As Long, lastRow3 As Long Dim wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") Application.ScreenUpdating = False With Worksheets("Sheet1") lastRow1 = .Cells(Rows.Count, "A").End(xlUp).Row .Range("A:A").AdvancedFilter Action:=xlFilterCopy, copytorange:=wS2.Range("A1"), unique:=True For i = 2 To wS2.Cells(Rows.Count, "A").End(xlUp).Row wS3.Cells.ClearContents .Range("A1").AutoFilter field:=1, Criteria1:=wS2.Cells(i, "A") Range(.Cells(2, "A"), .Cells(lastRow1, "E")).SpecialCells(xlCellTypeVisible).Copy wS3.Range("A1") lastRow3 = wS3.Cells(Rows.Count, "A").End(xlUp).Row Range(wS3.Cells(1, "A"), wS3.Cells(lastRow3, "E")).SpecialCells(xlCellTypeBlanks).Delete shift:=xlUp Range(wS3.Cells(1, "B"), wS3.Cells(1, "E")).Copy wS2.Cells(i, "B") Next i .AutoFilterMode = False wS3.Cells.Clear wS2.Columns.AutoFit End With Application.ScreenUpdating = True wS2.Activate End Sub 'この行まで// こんな感じではどうでしょうか？m(_ _)m
Excel 2013 の場合なら、[オプション]→[詳細設定]内の[編集設定]で“データ範囲の形式および数式を拡張する”にチェックを入れておいたら如何でしょうか？ Excel 2002 の場合なら、[オプション]→[編集]で“リスト形式および数式を拡張する”かな？
> エクセルの表をコピーして貼り付けたいのですが、貼り付け先がとびとびです。 > 例えば、3.7.8.12.14行目には貼り付けず、もとの数値を残す場合はどうすればよいのでしょうか？ > まとめて貼り付けたいのですが、何か良い方法はありませんか。 貼り付け元のデータに空白があり、空白の部分を除いて、入力されているデータだけを貼り付ける「空白セルを無視する」という機能があります。 この機能を利用するには、貼り付け元の『3.7.8.12.14行目』のセルが空白であることが条件です。 【Excel】貼り付け時に空白セルを無視する方法 http://saku-saku-pc.com/excel/%E8%B2%BC%E3%82%8A … 具体的には、 ご質問の貼り付け元のセル範囲に、上書きされては困るデータがある場合は、一時的に、邪魔にならない場所に「貼り付け」て、そのデータを削除した後、改めて、 1. 加工したセル範囲を「コピー」し、 2. 貼り付け先の先頭のセルをアクティブにし、右クリックから「形式を選択して貼り付け」をクリックして、 3. 表示されるダイアログボックスで、「空白のセルを無視する」にチェックを入れて「OK」ボタンを押しますと、 4. 貼り付けしたいデータだけが貼り付けされます。
実際は3行は入力されてからそうなっていると思いますが、エクセルには同様の式や書式が続いた場合に新しいセルに式や書式が自動でつく設定があります。 http://dekiru.net/article/12211/ (リンクはそれを解除する方法ですが、確認方法は同じです。)
一例です。 シート全体を選択して、条件付き書式で =COUNTIFS($B$1:$Z$1,"結果",$B1:$Z1,"×") と入れてみては如何でしょうか。
何度か、検討して、掲示することにしました。 >原因は環境の違いとしか言いようがないのでしょうか。 その通りだと思います。 学内で使われているコンピュータは、サーバーに繋がれているのではありませんか？そうしたら、全体のMicrosoft Office を含むファイルは、セキュリティ・ソフトで管理されているはずです。そのセキュリテイが、Cancel = True のシグナルを遅らせてしまうように考えました。 その現象は、PCが起動してから、ずっと何度も続くようなら、私の考えは間違っているかもしれません。 >記述に誤りが認められる場合、どの部分であるのかご指摘いただけると幸いです。 掲示されている記述自体に問題はありません。 プロシージャ内に、Wait やSleep(Win32 API)から、一旦、テンポを遅らせる方法を検討してみたらいかがでしょうか。
Sub ボタン1_Click() Dim Rng As Range With Worksheets("A") Set Rng = .Range(.Rows(20), .Rows(21)) End With If Rng.Hidden Then Rng.Hidden = False ElseIf Rng.Hidden = False Then Rng.Hidden = True End If Set Rng = Nothing End Sub イメージにそぐってますでしょうか。
数式　　　　　　セルの書式記号 A6　　　太郎　など F4　　　2015/5/16　　　　　　　　　　d G4　　　=f4+1　　　　　　　　　　　　d F5　　　=f4　　　　　　　　　　　　 aaa B21　　 =f4　　　　　　　　　ggg e "年" m "月" AC27　　=ah27-1　　　　　　　　　　　d AH27　　=f4+7-weekday(f4)　　　　　　d D31　　 =ah27+1　　　　　　　　　　　d I31　　 =d31+1　　　　　　　 　　　　d F27　=iferror(index($A:$A,5+match("①",offset($A$6:$A$20,0,match(d27,$4:$4,)-1),)),"") 当月 15 日以前、翌月 16 日以後の日の欄を空欄のような見かけにするには、条件付き書式「数式を使用して、…」を設定。例えば添付図で、4/10 の隣の「早」というセルを非表示にするには、条件式「=countif($4:$4,d27)=0」において、書式記号「;;;」を入力。あるいは同じ条件で、文字の色を白に指定。
AVERAGEIFSでもよいと思うが、範囲を指定するならやはりOFFSET関数などを使った関数に慣れるべきだろう。 考え方をひとつずつまとめながら柔軟な対応ができる。 ＞時間の条件式（">=10","<=20"）のような方法はあるんでしょうか... MATCH関数でよいのではないか。 ">=10" 平均する最初のデータの文字や数値が一致するセルの位置をMATCH関数で返して、その値をOFFSET関数の”基準セルからの行数”に反映させればよい。 前の回答で示した ＞例１：C1セルに基準セルからの行数を示す値を入力。C2セルに平均値を表示。データはB列、基準セルはB1。 ＞C2＝AVERAGE(OFFSET(B1,C1,0,10,1)) に対して C2＝AVERAGE(OFFSET(B1,MATCH(C1,A:A,1)-1,0,10,1)) とMATCH関数を入れるだけだ。 もちろんC1セルには行数ではなく先頭データを示すラベル（秒数）を入力する。 ">=20" 10秒に相当するデータ数をOFFSET関数の”範囲の高さ”に入れるんだ。前の回答ではそういう意味で注釈を付けたのだが読み取れなかったか。申し訳ない。 10秒に相当するデータ数が不定ならば、最初のデータを示す文字や数値に10秒を加えた文字や数値でMATCH関数を使い、返ってきた数値から先頭のデータがある位置の値を引き算し、それを”範囲の高さ”に反映させればよい。（引き算した値に+1することを忘れないように！） 今回は固定ということらしいので、ここまで考える必要は無いかもしれん。 先頭データのラベルを10秒刻みの値で入力したり、引き算の結果を”範囲の高さ”に繁栄させる数式の作成くらいはできるだろう。 ちなみにこれだけの関数ならば、Excelのバージョンは問わない。 もちろんOutlook.comから使えるExcel Onlineでも問題ない。ひょっとすると互換ソフトでもそのまま使えるかもしれない。 （これらは重要になることがある。） ひとつずつの関数がどのような働きをして何をしているのかをよく考え理解してほしい。 よく分からないときは関数ごとにセルに分けて関数が返す値を確認しながら進めるとよいだろう。
Excelの質問は回答者に腕利きが多いので、回答が付きやすいはずですが、今の質問からだと条件と結果がさっぱり見えてきません。もっと整理して具体的に、また貴方しか知らない条件や、わかりきっていて省略しているものも明示しないと、第三者には意味不明になってしまいます。 一度やりたいことを箇条書きにして、自分の中で整理してみてください。そうすれば、実は自分自身でもわかっていないことや、明確化できていないことが出てくる可能性があります。それをやってから質問した方が良いでしょう。
これは、自分のマクロが錆びていないか、点検のつもりで書いてみました。（^^;いまさらなんですが、xlByColumnsとxlByRows とどっちがよいのかとか、Macro3 のイレギュラーな書き方とか、書いてみないと分からないものがあります。とても小さなことですが。 '// Sub TestMacro1() '9014980 　Dim c As Range 　'マウスで範囲を決めてから実行 　If TypeName(Selection) = "Range" Then 　　Application.ScreenUpdating = False 　　For Each c In Selection 　　　c.Value = Replace(c.Text, "あ", "=", 1, 1) 　　Next c 　　Application.ScreenUpdating = True 　End If End Sub Sub TestMacro2() '9014980 　ActiveSheet.Columns("A:B").Replace _ 　 What:="あ", Replacement:="=", _ 　 LookAt:=xlPart, SearchOrder:=xlByColumns End Sub Sub TestMacro3() 　'9014980 　Dim c As Range 　Dim FirstAddress As String 　With Columns("A:B") 　　Set c = .Find( _ 　　What:="あ*", _ 　　LookIn:=xlValues, _ 　　LookAt:=xlWhole, _ 　　SearchOrder:=xlByColumns) 　　If Not c Is Nothing Then 　　　FirstAddress = c.Address 　　　Do 　　　　c.Value = Replace(c.Value, "あ", "=", 1, 1) 　　　　Set c = .FindNext(c) 　　　　If c Is Nothing Then Exit Do 　　　Loop While c.Address <> FirstAddress 　　End If 　End With End Sub '///
次のように操作してみてください。 1. B列のデータ範囲を選択して、「Ctrl＋C」キーのショートカットキーなどで「コピー」操作します。 2. A1セルを選択して、右クリックから「形式を選択して貼り付け」をクリックします。 3. 表示されるダイアログボックスの「空白セルを無視する」にチェックして、「OK」ボタンを押します。 4. B列のデータが不要なら削除します。
こんにちは。 >うまくいきました。ありがとうございます。 それは良かったでした。OkWaveと分離後でも、ここの「教えて！goo」には、長年の関数の達人さんたちのハンドルをお見かけしているので、私のように関数が不得意な者が、お役立てるだけで十分です。 >式の意味がよくわからず、別シートで作ろうとするとうまくいくか不安です。 まず実務的な面からですが、一旦出来上がった表3は、その表全体ごと、移動すればよいし、なおかつ別シートには、Altキーを押しながらすれば、移動が可能です。 >=IF(AND($C2<>"",D2<>""),D2,OFFSET(D$2,INT((ROW(A1)-1)/3)*3,)) IF(AND($C2<>"",D2<>""),D2　→「もし、C2とD2が空白でない場合は、D2を返す。」 そうでない場合は、…… D2が、結合セルというのは、D3,D4 というセルのアドレスは存在していますが、その中身は空になっているからです。それを逆に利用して、 OFFSET(D$2,INT((ROW(A1)-1)/3)*3,)というのは、 その結合セルが、D2,D3,D4 →D2を中心としたら、 D2 は、行に対して0番目,　D3は1番目,　D4は、2番目で、Offsetで、0番目のセルを参照しなさい という意味なのです。 結合セルではない場合は、そのセルは、文字か数字かが入っているという前提の元に、そのセルの値を表示しなさい、という仕組みです。だから、結合を解いた場合は、空白では、0番目を参照してしまうので、何かを入れてください、ということです。 >ROW以下の1を足して（→引いて)3で割って、そこに3をかけるという発想はどこから来たのでしょう。 難しい質問なのですが、もともと私は、VBAが専門の回答者ですから、VBAプログラミングの考え方からです。それがたまたま、関数に応用できたにすぎません。関数のほうが遥かに難しいと思います。
合計を出すセルに、次のような数式を入力します。 =SUMIF(A3:A12,"ばなな",B3:B12)+SUMIF(A3:A12,"バナナ",B3:B12) 「条件に合うデータを合計 SUMIF関数」 http://www.becoolusers.com/excel/sumif.html 「複数条件の合計 SUMIFS関数」 http://www.becoolusers.com/excel/sumifs.html
このようになります。 '// Sub ReplacementMacro1() '前方一致、全取替 Dim i As Long With Worksheets("文字列リスト") For i = 2 To .Cells(Rows.Count, 1).End(xlUp).Row 　Worksheets("作業").Cells.Replace _ 　What:=.Cells(i, 1).Value & "*", Replacement:=.Cells(i, 2).Value, _ 　LookAt:=xlWhole, MatchCase:=False, Matchbyte:=False Next i End With End Sub '/// 結果 エディターの編集　　　　→　　　エディタ　 プリンターの故障　　　　　 →　　 プリンタ サーバーのメインテナンス　→　　 サーバ '// Sub ReplacementMacro2() '部分置換 Dim i As Long With Worksheets("文字列リスト") For i = 2 To .Cells(Rows.Count, 1).End(xlUp).Row 　Worksheets("作業").Cells.Replace _ 　What:=.Cells(i, 1).Value, Replacement:=.Cells(i, 2).Value, _ 　LookAt:=xlPart, MatchCase:=False, Matchbyte:=False Next i End With End Sub '/// 結果 エディターの編集　　　　　→　エディタの編集　 プリンターの故障　　　　　→　プリンタの故障 サーバーのメインテナンス　→　サーバのメインテナンス しかし、 Sakuraエディター　　→　　Sakuraエディタ　 イプソンプリンター　　→　 イプソンプリンタ Unixサーバー　　　　　　→　Unixサーバ というようにもなります。
=IF(対象セル="○",A+B,A) ってこと？ それとも、Ａという項目でいくつか金額があるとかだとSUMIFを入れることになりますが…
「実行時エラー:438」は”そんなプロパティやメソッドは無いよ”という意味なので、 誤： Workbooks("excel_er.xlsm").Active 正： Workbooks("excel_er.xlsm").Activate
添付画像はexcel2010Ver'ですが、方法は同じです。 「名前」フィールドを「行」と『値」の両方へそれぞれドラッグします。
ここが、前回の質問と回答ですね。 http://oshiete.goo.ne.jp/qa/9008013.html ご自身で開発されていない時は、なるべくリンク先などを明示して、作った人を尊重してください。 私は、基本的に、ここでの書き込みでは、丸投げの質問で、お仕事へのお手伝いはしないという方針ですが、あまりレスが付かないので、少し考えてみました。 それから、昨日から、前のログや添付画像と照らしあわせて、やっとなんとなく分かってきましたが、かなり理解に苦しみました。分かっている前回の人が書いてくれるのが一番ベストでしょうけれども。 >チェック時のWEB頁の状態を任意フォルダ内へ保存 とは、ログを保管する部分のVBAコードが必要ということでしょうか？ それと、この説明は、結構重要だったかもしれません。 keronjinさんsaid： 「ＨＴＭＬソースを取得して該当文字列を検索するので、プルダウンの選択項目や説明文なども全て数えてしまいます。Webページを表示した状態で数えるのとはちょっと違うのでもう一工夫必要かもしれません」 　VBAのコードで、肝心の検索元になるデータの取り方ですが、なぜ、body.innerHTMLなのか、という所で、前のログを読み直しました。もちろん、ログとして残すなら、innerHTMLで良いと思いますが、キーワード検索は、innerText ではないかと思います。実際は、ほとんどあまり大きく変わるわけではありませんが、この点が気になりました。　 まあ、これ以上、能書きを言っても不愉快にさせるだけでしょうから、わたし流のコードを書いてみました。本来は、これに、アクセス状態を測るステータスコードの取得がほしいところです。iacc というカウンターで、エラーを検出していますが、確実ではありません。Sleep は、現在使っていませんが、必要に応じて、コメントブロックを外して、利用してください。 ユーザーフォルダは、定数のmyFOLDER です。 それからExcelファイルのある下にフォルダを作るというのが、原則です。ファイルを渡す時に、下位フォルダを付けますと、ハイパーリンクは崩れません。 なお、試したのは、msn サイトです。 '// ''これは、必ず、IEの参照設定をしなくてはなりません。* Option Explicit 'Private Declare Sub Sleep Lib "kernel32.dll" (ByVal dwMilliseconds As Long) Private objIE As InternetExplorer '参照設定　Microsoft Internet Control　＊ Private i As Long Private subName As String Private TargetWord As String Private BaseFolder As String Private Const myFOLDER As String = "GETLOG" 'ユーザーフォルダ Private inFileName As String '出力用のファイル名 Sub SearchWordinSites() 　Dim strURL As String 　Dim l As Long, m As Long 　'初期設定 　'フォルダーをこのブックの下位に作る 　If Dir(ThisWorkbook.Path & "\" & myFOLDER, vbDirectory) = "" Then 　　MkDir ThisWorkbook.Path & "\" & myFOLDER 　End If 　　'ベースフォルダー 　　BaseFolder = ThisWorkbook.Path & "\" & myFOLDER & "\" 　 　'消去 　l = Cells(1, Columns.Count).End(xlToLeft).Column '右 　m = Cells(Rows.Count, "E").End(xlUp).Row '下 　Range("E2", Cells(m, l)).Clear 　 　' 　For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row 　　'URL形式になっているかチェック 　　If StrConv(Cells(i, 1).Value, vbLowerCase) Like "http://*" And _ 　　Cells(i, 3).Value <> "" Then 　　　strURL = Cells(i, 1).Value & Cells(i, 3).Value 　　　subName = Cells(i, 3).Value 　　　DoEvents 　　　'アクセスの確認（ステータスバーに表示) 　　　Application.StatusBar = strURL 　　　Call WebAccess(strURL) 　　End If 　Next i 　objIE.Quit 　Set objIE = Nothing 　Application.StatusBar = "" End Sub Sub WebAccess(ByVal strURL As String) 　Dim HttpLog As String 　Dim iacc As Long 　Dim flg As Boolean 　iacc = 0: flg = False 　If objIE Is Nothing Then 　　Set objIE = New InternetExplorer 　End If 　With objIE 　　.Navigate2 strURL 　　Do While .Busy = True Or .ReadyState <> 4 　　　DoEvents 　　　iacc = iacc + 1 　　　If iacc > 5000 Then flg = True: Exit Do　'アクセス・エラーの判断 　　Loop 　　If flg = False Then 　　　HttpLog = .Document.body.innerText '現行では、Text にしているinnerHTML 　　　 　　　'保存用ファイル名の生成 　　　inFileName = subName & Format$(Now(), "yyyymmddhhMM") & ".txt" 　　　Application.StatusBar = "エクスポート" 　　　Call ExportLog(HttpLog) 　　　Application.StatusBar = "単語検索中" 　　　Call SearchWords(HttpLog) 　　End If 　End With End Sub Sub SearchWords(ByVal strLog As String) 　Dim k As Long 　Dim sTxt As String 　Dim orgLng As Long 　Dim nLOG As String 　Dim cnt As Long 　orgLng = Len(strLog) 　For k = 2 To Cells(Rows.Count, 4).End(xlUp).Row 　　sTxt = Trim(Cells(k, 4).Value) 　　If sTxt <> "" Then 　　　nLOG = Replace(strLog, sTxt, "", , , vbTextCompare) 　　　cnt = (orgLng - Len(nLOG)) / Len(sTxt) 　　End If 　　Cells(k, i + 4).Value = cnt 'カウントの数 　　If cnt > 0 Then 　　　'色付け 　　　Cells(k, i + 4).Font.ColorIndex = 3 　　　'ハイパーリンク 　　　ActiveSheet.Hyperlinks.Add Anchor:=Cells(k, i + 4), _ 　　　Address:=BaseFolder & "\" & inFileName 　　End If 　　cnt = 0 　Next k End Sub Sub ExportLog(ByVal HttpLog As String) Dim fNo As Integer Dim tFolder As String 　 'ファイルの出力 　 tFolder = BaseFolder & subName & "\" 　 If Dir(tFolder, vbDirectory) = "" Then 　　 MkDir tFolder 　　 fNo = FreeFile() 　　 Open tFolder & inFileName For Output As #fNo 　　 Print #fNo, HttpLog 　　 Close #fNo 　　 Beep 　 End If End Sub '///
No.2 です。ちょっと舌足らずな部分があったので、追加で説明します。すみません。 I2 セルの値が B 列で見付からなかった場合、マクロがエラーになってしまいます。それを防止するため、次のとおり書いてください。 on error resume next i = worksheetfunction.match(Sh1.range("i2").value, Sh1.columns("b"), 0) on error goto 0
No.3です。 ＞右端から数えて２個めのコロン以降を抜き出すのは・・・ というコトですので、↓の数式にしてみてください。 =IFERROR(MID(A1,FIND("#",SUBSTITUTE(ASC(A1),":","#",LEN(A1)-LEN(SUBSTITUTE(ASC(A1),":",""))-1))+1,LEN(A1)),"") ※　注意点　※ 1セル内にコロンが二つ以上ない場合はエラーとなり、 セルは空白になります。m(_ _)m
No.1です。 たびたびごめんなさい。 投稿後気づきました。 前回のコードは無駄がありました。 後半部分、SelectionChangeイベントの ＞With myArea ＞.Interior.ColorIndex = xlNone ＞.Interior.ColorIndex = 23 ＞End With の4行を ＞myArea.Interior.ColorIndex = 23 の1行だけにしてください。 どうも失礼しました。m(_ _)m
>もっとも列数の多い行に合わせ、列数の少ないレコードの後ろに勝手にカンマが複数個足されてしまいます。 そういう解釈もあるのでしょうが、四角形に範囲を取っているからだと思います。 >CSVファイルにて出力する作業をExcelマクロ Excel VBAでするなら、 >それをTXTファイルとして開き直し内部データの置換（カンマ個数の調整）をしたいと思っています。 これは不要でしょう。最初から、そう出力すれば済む話ですから。 それとも、既存のCSVを直す方法もありますが、それは、また補足にでも加えてください。 マウスで範囲を選択します。だから、画像には出てきませんが、空行を選択範囲に入れると、それも入ってしまいます。 なお、このマクロは、Excel 97～2000 によく見かけられた、懐かしい古典的なものです。 '// 'Option Explicit Sub CSVExportMacro() Dim Rng As Range Dim Fname As String Dim i As Long, j As Long Dim buf As String Dim FNo As Integer Dim mPath As String mPath = ThisWorkbook.Path & "\" If TypeName(Selection) <> "Range" Then 　Exit Sub End If Set Rng = Selection If WorksheetFunction.CountA(Rng) < 2 Then 　 MsgBox "データが不足しています。", vbExclamation 　 Exit Sub End If Fname = Format$(Now(), "yyyymmddHHMMSS") Fname = mPath & Fname & ".csv" FNo = FreeFile Open Fname For Output As #FNo With Rng For i = 1 To .Rows.Count 　For j = 1 To .Columns.Count 　　If Trim(.Cells(i, j).Value) <> "" Then 　　　buf = buf & "," & Trim(.Cells(i, j).Value) 　　End If 　Next j 　Print #FNo, Mid$(buf, 2) 　buf = "" Next i Close #FNo Beep End With End Sub '///
＞仕事で必要になりマクロを組んでほしいです。 ご自分で仕事をしてください。まずは努力をしてください。質問であれば、こちらで分かることについてお答えします。ここは質問・回答の場であり、あなたの仕事を肩代わりするのが役目ではありません。 また、あなたの業務の緊急度と質疑応答の内容は、無関係です。たとえ「急いでます」マークを付けたとしても、質問あるいは回答の本質には関係ありません。 全くちんぷんかんぷんで手も足も出そうにないスキルだとすれば、それを業務に生かせなくても致し方ありません。ご自分ではメンテもできないソースコードをもらっても、背伸びし過ぎということになります。何が書いてあるのかサッパリ分からないから、また教えて教えて、となります。 もっとも、ご質問の内容は、マクロの初歩の中の初歩、です。したがって質問者さんが勉強すれば、完成まで時間や労力や人からの手助けが必要になるとしても、何もできないということはないはずです。書きかけのコードでも載っていれば、努力の跡が分かります。
ちょっと失礼します。 >ちゃんとした知識と能力が必要な事を改めて痛感しました そういうことはなく、経験的なものだと思います。実務として何度か失敗したら、何が問題なのか嫌というほど身にしみます。 私自身、こうしたシフト表の作成の依頼を受けた経験はあります。しかし、丁重におことわりするししかありませんでした。理由は簡単なことです。最初に人員表ぐらいのリストは作っておいても、後は実際のアナログで、碁盤の目に駒を埋める方法しかないと思います。 もちろん、データの[入力規則]のリストを埋め込んでもよいと思います。重複すれば、[エラー表示]は出来ます。そうしたら、人為的な配置のミスぐらいは避けられますが、手動には変わりありません。 残念ながら、Excelでは、それを清書するぐらいしか出来ません。 1日 (昼) 佐藤 鈴木 渡辺 (夜) 渡辺 佐藤 湯本 >となる事も多いのです。 >この場合に、清掃表で佐藤と渡辺が重複してしまいますので両名を昼営業の部分のみを残し >夜営業の部分は削除したいのです。 これ自体は、マクロの処理では、重複の削除などは簡単なことですが、基本的なオーダーリスト（人の手配の順番－例で言えば、1日の昼の人員)ができません。確かに、重複表示は簡単な[条件付き書式]で可能です。最初の元をどうやって決めるということです。 それ以上は、どうあがいても、複数のオーダーリストなどは、マクロでも不可能なはずです。その都度、マクロに掛けるなんてしても、手動でやったところでこの規模では大差ありません。それと、通常のマクロでは、[元に戻す]ができなくなり、この手の試行錯誤が多いものでは、元に戻せないのは不便だと思います。
こんにちは！ 横からお邪魔します。 今回はセル移動も含めた操作にしたい！というコトですので・・・ 一案です。 あらかじめ色付きセル範囲を指定してみてはどうでしょうか？ ↓のコードはB2～B100.E2～E100セルの範囲を限定としてみました。 シートモジュールです。 Dim myArea As Range 'この行から// Private Sub Worksheet_Change(ByVal Target As Range) Set myArea = Range("B2:B100,E2:E100") '←ここで範囲を設定// If Intersect(Target, myArea) Is Nothing Then Exit Sub With Target If .Column = 2 Then .Offset(, 3).Select Else .Offset(1, -3).Select End If End With End Sub Private Sub Worksheet_SelectionChange(ByVal Target As Range) Set myArea = Range("B2:B100,E2:E100") Cells.Interior.ColorIndex = xlNone myArea.Interior.ColorIndex = 8 '←水色// If Not Intersect(Target, myArea) Is Nothing Then Selection.Interior.ColorIndex = 6 '←黄色// End If End Sub 'この行まで// ※　文字が見えにくいので「水色」にしています。 ※　指定範囲以外のセルに色がついている場合、 その色は消えてしまいます。m(_ _)m
新たに見つけた話をここに書いておきます。 >何が違うんだろう。 ここを、もう少し、早く追求すべきでしたね。 たぶん、個々にみると、環境的な違いよりも、ファイルのタイプの違いがありそうな気がします。場合によっては、ExcelとWordをセットにして、ファイルをお渡ししなくてはならないと思います。 だんだん、時間が経つにつれ、逆に、わからなくなってしまいました。 このマクロの前提として、大きな違いが生じる部分が2点あります。 1．Wordは、docx でなくて、doc であることです。この情報は、技術評論社のサイトから見つけたものです。docx(2007以降のものでは動かないそうです。) 2. 埋め込みされたオブジェクトのスタイル(ClassType)によって、挙動が違う可能性があること。（試してみたけれども、自動的に元に戻って、12型=2007になってしまっていましたが、違いは確認されませんでした。) なお、私の使っているExcelは、2010です。 OLE1.ConvertTo ClassType:=cType 今回試してみたことは、コンバートすることです。 '// Sub MacroLinkedWord3() 　Dim OLE1 As Word.OLEFormat 　Dim Wb As Excel.Workbook 　Dim xlApp As Excel.Application 　Dim Ws2 As Excel.Worksheet 　Dim MsWord As Word.Application 　Dim objDoc As Word.Document 　Dim cType As String 　 　Const FNAME As String = "C:\Users\[UserName]\My Documents\bb9011694.doc"　'* 　 　On Error Resume Next 　Set MsWord = GetObject(, "Word.Application") 　Set objDoc = MsWord.ActiveDocument 　On Error GoTo 0 　If MsWord Is Nothing Then 　　Set MsWord = CreateObject("Word.Application") 　　Set objDoc = MsWord.Documents.Open(Filename:=FNAME) 'WordojbDocを開く 　End If 　'-------------------------- 　MsWord.Visible = True 　Set OLE1 = objDoc.InlineShapes(1).OLEFormat 　'** 　If Not OLE1.ClassType Like "Excel.Sheet.*" Then Exit Sub 　cType = OLE1.ClassType 　OLE1.DoVerb VerbIndex:=wdOLEVerbShow '*NG:wdOLEVerbOpen 　 　'----------------------------------------- 　Set xlApp = OLE1.Object.Parent.Application 　Set Wb = OLE1.Object 　MsWord.Activate 　Set Ws2 = Wb.Worksheets(2) 　xlApp.Goto Wb.Worksheets(2).Cells(13, 1), True 　Wb.Activate '　Wb.Close True 　OLE1.ConvertTo ClassType:=cType 　'------------------------------------------- 　Set Ws2 = Nothing 　Set Wb = Nothing 　Set xlApp = Nothing 　Set OLE1 = Nothing 　Set MsWord = Nothing End Sub '///
No.2です。 たびたびごめんなさい。 前回の②はNo.1さんと被りました。 マイナスの場合もあるかもしれませんので、マイナスは表示させたい場合 #;-#;"";@ としてください。m(_ _)m
こんばんは！ 横からお邪魔します。 No.1さんの回答で解決済みだったようなのですが、 新たな表を拝見すると、表の配置は微妙に変わっていますが 前回（↓のサイト）と全く同じコトですね？ https://oshiete.goo.ne.jp/qa/9009550.html 画像の配置だとH3セルに =SUMIF($C:$C,H2,$E:$E)-SUMPRODUCT(($A1:$A1000=$L2)*($C1:$C1000=H2),$E1:$E1000) という数式を入れK3セルまでフィル＆コピー！ L3セルには =SUMIF(A:A,L2,E:E) としてみてください。m(_ _)m
={"あ";"い";"う";"え";"お"} などは、ワークシート上に置いておいてもいいし、名前のダイアログの中だけで定義する形でもいいです。どちらでも構いません。後者の場合、「名前の管理」ダイアログの「参照範囲」を配列定数で指定すると、「値」欄には {...} と表示されると思いますが、気にしません。 ワークシート上のどこかに、表そのものではなく、「α」などの名前であれば表示してもいいという場合は、例えば D1　=index(indirect(a1),3) といった数式で「切替えが可能な名前を付けた参照」をすることができます。ワークシート上のどこにもαと表示してはならないのであれば、INDIRECT 関数を使わず D2　=index(α,3) 　　あるいは 　　=index({"あ";"い";"う";"え";"お"},3) といった記述でオッケーです。数式中での指定なので、これを切替え可能と呼ぶのがふさわしいかは分かりませんが。B1 セルに 0、1、2 といった番号を記入しても構わない場合は、 D3　=index(if(b1,α,β),3)　　　　…… B1 には数値を記入 　　あるいは 　　=index(choose(b1,α,β),3)　　…… B1 には 1 以上の整数を記入 で「切替えが可能な名前を付けた参照」になりますね。
>書き出すファイルが一つ不足してしまいます。 Range(Sheet1.Range("A1"), Sheet1.Range("A" & UBound(Files))).Value 　　　↓ Range(Sheet1.Range("A1"), Sheet1.Range("A" & UBound(Files) + 1)).Value 配列は0スタートですから、一つ足りません。 ただ、書法そのものから言うと、私なら、以下のように書きます。 書き換えた理由はありますが、人の感性の問題で、レベルの低い議論に発展することがありますから、あえて説明は省いておきます。基本的なコンセプトは、コードの各行は短くするということです。 '// Sub SampleR() 　'No. 9010573 　Dim buf As String, n As Long 　Dim Files() As Variant 　Const myPATH As String = "C:\test\*.xls" 　buf = Dir(myPATH, vbNormal) 　 　Do While buf <> "" 　　ReDim Preserve Files(n) 　　Files(n) = buf ''ファイル名を格納します 　　n = n + 1 　　buf = Dir() 　Loop 　With Worksheets("Sheet1") 　　'1度でもループを通れば、n のカウントは上がりますから、チェックに使えます。 　　If n > 0 Then 　　　.Range("A1", .Cells(UBound(Files()) + 1, 1)).Value = Application.Transpose(Files()) 　　End If 　End With End Sub '///
No.3です。 ＞Sheet2「ケース」売上の欄にB社やC社の ケースの売上 を入れることはできますでしょうか？ すなわちSheet2のE1セル（取引先）以外の集計を出したい！というコトですよね？ 前回の画像の配置通りだとします。 Excel2003をお使いだというコトですので、 Sheet2のA2セルに =SUMIF(Sheet1!$C:$C,B1,Sheet1!$E:$E)-SUMPRODUCT((Sheet1!$A$1:$A$1000=$E1)*(Sheet1!$C$1:$C$1000=B1),Sheet1!$E$1:$E$1000) という数式を入れD2セルまでフィル＆コピー！ E2セルは前回のままで =SUMIF(Sheet1!A:A,E1,Sheet1!E:E) としてみてください。 ※　Sheet2のE1セルデータ変更のたびに結果が表示されます。 こんなんではどうでしょうか？m(_ _)m
こんばんは！ ＞＝A1+(0，30，0)で求まったのですが ん～～～ その数式で求まったのでしょうか？ それはさておいて・・・ A1セルに「10：30」のような感じで入力されているとすると 表示したいセルに =A1-TIME(0,30,0) としてみてはどうでしょうか？m(_ _)m
こんばんは！ https://oshiete.goo.ne.jp/qa/9008238.html と全く同じ質問ですね？ あちらの方法で解決済みだと思ったのですが・・・ 関数でやるにしても、VBAでやるにしても行・列の配置が重要です。 1行・1列でも違えば全く意味のないコード（数式）になってしまいますので、 せっかく画像をアップされているのであれば、行番号・列番号も判るような画像でないと意味がないと思います。 ところで、どうしてもチェックボックスを使用しなくてはならない理由があるのでしょうか？ ＞※フォーマット上無理がある場合などは変更考えます。 とありますので、別案です。 ↓の画像ではSheet1のB列は入力規則の「リスト」にしています。 B列を範囲指定　→　メニューの「データ」　→　データの入力規則　→　リスト　→　元の値の欄に 　,✓ 全角スペース＋カンマ＋✔　と入力しOK これでスペースもしくは✔のどちらかが選択できます。 そうした上での標準モジュールです。 Sub Sample1() Dim i As Long, lastRow As Long, cnt As Long, wS As Worksheet Set wS = Worksheets("Sheet1") With Worksheets("Sheet2") Application.ScreenUpdating = False lastRow = .Cells(Rows.Count, "B").End(xlUp).Row If lastRow > 6 Then Range(.Cells(7, "B"), .Cells(lastRow, "K")).ClearContents End If For i = 34 To wS.Cells(Rows.Count, "D").End(xlUp).Row If Trim(wS.Cells(i, "C")) <> "" Then cnt = cnt + 1 With .Cells(Rows.Count, "B").End(xlUp).Offset(1) .Value = cnt Range(wS.Cells(i, "D"), wS.Cells(i, "L")).Copy .Offset(, 1).PasteSpecial Paste:=xlPasteAll End With End If Next i Application.CutCopyMode = False Application.ScreenUpdating = True End With End Sub ※　どうしてもチェックボックスを使わなければならない場合は 無視してください。m(_ _)m
こんにちは！ 2×2　といったセルは文字列になりますので、四則計算はできません。 ただ、これでは何もお役に立てないので、VBAであれば可能な場合があります。 一案ですが、この質問だけの関数（ユーザー定義関数）を作ってみました。 範囲指定したセルの足し算としています。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻る（VBE画面を閉じる） Function Goukei(範囲 As Range) 'この行から// Dim c As Range, myStr As String, mySum As Variant For Each c In 範囲 If c <> "" Then myStr = StrConv(c, vbNarrow) If InStr(myStr, "×") > 0 Then myStr = Replace(myStr, "×", "*") End If If InStr(myStr, "÷") > 0 Then myStr = Replace(myStr, "÷", "/") End If mySum = mySum + Evaluate(myStr) End If Next c Goukei = mySum End Function 'この行まで// そして以下の順に操作してみてください。 ①　結果（各セルの合計）を表示したいセルを選択 ②　アドレスバーの左側の「fx」のアイコンをクリック ③　「関数の分類」の右側▼で「ユーザー定義」を選択しOK ④　「範囲」の右側窓で合計したいセル範囲を選択しOK これで計算結果が表示されると思います。 ※　セル内に四則計算記号（＋　－　×　÷）と数値が存在するセルだけが対象となります。 （「^」のように他の計算演算子でも計算できる場合もあります） ※　極端に広い範囲（列全体とか行全体）は範囲指定しないでください。 すべての範囲内をループさせますので、計算速度が極端に落ちます。m(_ _)m
№1さんの書かれているようにHLOOKUPでもできますし、INDEXとMATCHを使う関数なら =INDEX(Sheet1!$A$3:$C$3,MATCH(A1,Sheet1!$A$2:$C$2,0)) などでは如何でしょうか？
こんにちは。 http://oshiete.goo.ne.jp/qa/9008800.html こちらを読んでみて、まだ、ご理解されていないようです。 >sheet1.RANGE(i34:k34)=sheet2.RANGE(C7:E7) 失礼ですが、これでは、入門レベルにも達していません。せめて、3日間でも、マクロの基礎中の基礎を我慢して学べば、このようなことにはなりません。 それはとかもく、私の書いたマクロの元になる画像を貼り付けておきます。逆に言えば、そういう画像があって、コントロールはフォームだと言えば、概ね、マクロのコードは書けるということです。 何が足りないかわかるはずです。
こんにちは。 返事をつけるのが遅くなってしまいました。 リンク先の「インストラクターのネタ帳」のサイトが、本日、ずっと開かなかったので、しばらく確認できませんでした。 こんな感じでしょうか？ ただ、 >表題の通り、EXCELの１列目に自作の問題、２列目にその答えがあります。（６００行くらい） って、パワーポイントにそんなにページを作るのでしょうか？ 大丈夫か分かりません。 '// Sub PPTgetXlData() 　Dim objPPT As Object 　Dim objPrsn As Object 　Dim shp As Object 　Dim i As Long 　Dim p As Long 　With ActiveSheet 　　p = .Cells(Rows.Count, 1).End(xlUp).Row 　　If p > 700 Then 　　　If MsgBox("Too Many Data", vbExclamation + vbOKCancel) = vbCancel Then 　　　　Exit Sub 　　　End If 　　End If 　End With 　On Error Resume Next 　'パワーポイント起動 　Set objPPT = GetObject(, "PowerPoint.Application") 　On Error GoTo 0 　If objPPT Is Nothing Then 　　Set objPPT = CreateObject("PowerPoint.Application") 　End If 　If objPPT Is Nothing Then MsgBox "NOT Exist PPT": Exit Sub 　With objPPT 　　.Visible = True 　　Set objPrsn = .Presentations.Add 　End With 　For i = 1 To p 　　With objPrsn.Slides 　　　.Add Index:=i, Layout:=4 　　　With .Item(i) 　　　　Set shp = .Shapes.AddTable(NumRows:=2, NumColumns:=1, _ 　　　　Left:=130, Top:=100, Width:=500, Height:=300) 　　　End With 　　　'With shp ～　End with ここにテーブルの書式設定を入れる 　　　With shp.Table 　　　　.Cell(1, 1).Shape.TextFrame.TextRange = Cells(i, 1).Value 　　　　.Cell(2, 1).Shape.TextFrame.TextRange = Cells(i, 2).Value 　　　End With 　　End With 　Next i 　Set objPrsn = Nothing 　Set objPPT = Nothing End Sub '///
20140501は　Ｈ２６.5.1であるので 元データーの日付+365の必要がある　 表示させるためには別のセルに　＝元データー+365　を書き込めば そこには　H27.5.1　が表示される。 ただ何故そんなことをする必要があるのか？？？
ＩＦ関数使え
＞「A.xlsx」の「sheet1」は「America」に変換 「B.xlsx」の「sheet1」は「England」に変換 「B.xlsx」の「sheet1」は「Germany」に変換・・・これは「C.xlsx」ですよね。 単にファイルを開いて「sheet1」を右グリック　「移動またはコピー」を選択して 移動先ブック名（T)　の「新しいブック」を選んでOKを押す、新しいシートが単独でできるので、 あとは「America」であろうが何であろうが任意の名前をつければいいのでは？ １００くらいだったら・・・手作業で・・・ 勘違いだったらごめんなさい
Ｈ列、Ｉ列、Ｊ列のセルに数値が入力されているか確認すればよいだろう。 分からないのであれば、77行目をコピーして78行目に貼り付ければよい。 そうすれば問答無用で77行目と同じセル形式になる。
#2の回答者です。 >=int(rand()*43)+1 このような洒落た数式は教えていませんね（^^; それに、その使い方は、エクセル関数の使い方ではありません。 重複を許すなら、RANDBETWEEN()関数があります。 今回は、重複を許さないのですから、 A1:A43 まで、 =RAND() と関数を置いて、同じ数式をコピー B1には、以下の数式を置き、 =RANK(A1,$A$1:$A$43) B43まで、コピー、フィルハンドルでドラッグコピーでも良いです。 B列に、重複を許さない数値が出てきます。 つまり、A列の乱数43個に対して、順位をつけるのですから、重複はでないわけです。 念の為に、C1から、C48に以下のように、 =COUNTIF($B$1:$B$43,B1) 数式を置いてみましたが、重複はありません。 図をみてください。
要するに、25 行ごとに抜き出した形に並べ替える方法が分かればいいわけですね。マクロを使わなくても、Excel の基本的な操作だけでできますよ。 添付図のように、「通しナンバー」の昇順で並んでいるときに、「グループナンバー」として、C 列の最初の 25 行に 1, 2, ..., 25 と記入。C2:C26 のセル範囲をコピーして、その下の行に貼り付け。最後に、「グループナンバー」の昇順で表全体を並べ替えれば、お望みの順番になります。「通しナンバー」で並べ替えれば、元の順序に戻ります。
No.1・7です。 ＞その方が見やすいのですが・・・ 実は当方も投稿後そう思っていました。 余計なお世話ですべてのセルに格子罫線にしていたので確かに、下太罫線が判りにくかったですね。 実は前回のコードをほんの少しだけ変えるだけです。 ＞Range("A1").CurrentRegion.Borders.LineStyle = xlContinuous の行を ＞Range("A1").CurrentRegion.Borders.LineStyle = xlNone に変更してみてください。 ※　範囲内の罫線は下太罫線だけとします。m(_ _)m
こんにちは！ 最大値が複数存在しないという前提であれば =HLOOKUP(B1,E1:J2,2,0) とか =INDEX(E2:J2,,MATCH(B1,E1:J1,0)) という数式を入れてみてください。m(_ _)m
ご質問の現象は「ワークシート上で現に選択されている範囲の外に数式が記入される」というもので、普通はそうならないという意味では、人によってはバグとも感じられる仕様というところでしょうね。 Microsoft が説明するオート SUM の使用法は、Excel のヘルプなどに書いてあります。そこでは「（既存データの存在する範囲ではなく）数式を記入する空白セルを選択した状態で、ボタンを押す」となっています。したがって、それ以外の方法でボタンを使おうとした場合の挙動に関しては、知る限り、詳しい説明はされていないのではないかと思います。（探しまくれば何か情報が出てくる可能性もありますが…） 範囲外に記入するというのは、既存データを誤って上書きしないための措置だと考えられますが、実際に数式が記入される位置は、既存データの種類、配置、選択している範囲などの要素によって、変化するようです。 ＞ですから、対処方法が知りたいわけではなく、今まで知らなかったことがショックで、…… 機械任せにすると危ないですので、やはり、数式を記入したいセルを選択した状態で記入する方法のほうをお勧めします。ボタンを押す代わりに、Alt+Shift+= をタイプするとか、「=sum(…」と記入していってもいいですね。 その後の、参照する範囲の指定では、正しいセル範囲をこの段階でドラッグするほか、カラーリファレンスの位置をドラッグ・アンド・ドロップあるいはドラッグのみで修正する方法でもいいですね。
こんにちは！ 範囲を最初から多目にしておいてはダメですか？ SUMPRODUCT関数はどこかの列が空白の場合は「0」とみなされ合計しても結果に変化はないはずですので・・・ どうしても作業列を使用したくない場合の一例です。 表示したいセルに =SUMPRODUCT(IF(A1:A1000<=B1:B1000,A1:A1000,B1:B1000),C1:C1000) 配列数式になりますので、Ctrl＋Shift＋Enterで確定！ この画面からコピー＆ペーストする場合は上記数式をドラッグ＆コピー！　→　表示したいセルを選択　→　数式バー内に貼り付け　　→　そのまま（編集可能なまま） Ctrl＋Shiftキーを押しながらEnterキーで確定します。 数式の前後に{ }マークが入り配列数式になります。 ※　SUMPRODUCT関数自体が配列数式になりますが、 配列数式内に配列数式を入れた感じになります。m(_ _)m
> プレビュー画面から余白を表示させると、余白線？が用紙の中に、外側と内側に２本の枠線が表示されます。 No.1の方のご回答の通り、 上下に表示される2本の線の内側の線は、余白位置を表示し、外側の線は、「ヘッダー」と「フッター」の位置を表しています。 > この外側の余白線？はそもそも何を表わしているもので、どのような意味があるのでしょうか。 下記URLのMicrosoftのページでは、「ヘッダー」と「フッター」について、次のように説明されています。 *******ｺｺｶﾗ***** ヘッダーとフッターとは、文書の各ページにある、上部と下部の余白部分に印刷される文字列や図のことです。よく使用されるヘッダーとフッターとしては、ページ番号、日付、会社のロゴ、文書のタイトルやファイル名、作成者などがあり、偶数ページと奇数ページで異なるヘッダーやフッターを作成することなどができます。ヘッダーとフッターには、本文と同じように文字の入力や書式設定、および図の挿入を行うことができます。ヘッダーとフッターが表示されるのは、印刷レイアウト モードのみです。 *******ｺｺﾏﾃﾞ***** 「ヘッダー/フッターの機能について」 https://support.microsoft.com/ja-jp/kb/881320/ja 簡単には、 「ヘッダー」・・・ページの上部に表示される文字や図です。 「フッター」・・・ページの下部に表示される文字や図です。 > どのような場合に（マウスで）設定してやるのでしょうか。 ページ全体のレイアウトをバランスを見ながら、アナログ的に設定する場合に使います。
=SUMIF(A:A,D1,B:B)/COUNTIF(A:A,D1)
印刷倍率が変わってしまうのに伴い、自動改ページになっている部分は倍率によって範囲が変更されてしまうようです。 ということで、全部の自動改ページ設定を手動で位置設定しないと、お望みのことは難しいようです。
> Excelで間違って上書き保存してしまい、前までのデータがなくなってしまいました。 > 復元方法はありますか？ 「上書き保存」した直後であれば、「クイックアクセスツールバー」の「元に戻す」ボタンを押すか、[Ctrl＋Z]のショートカットキーで戻すことができます。 そのほか、設定を変更していなければ、自動保存されたバックアップが保存されている可能性があります。 詳細は、下記URLのページをご参照ください。 「上書き保存したOfficeファイルを元に戻したい」 http://enjoy.sso.biglobe.ne.jp/archives/office_s …
> 見えてるセルを選択しリターン押すと「エラー解消」することもあれば、反対にエラーになることもある。大抵は左詰めが右詰めに変わる これはNo.1さんの回答の通り、 「数値が文字列となっているセルが編集→確定することによって数値になっている」ということだと思いますが、 セルの書式を「文字列」から「数値」に変更しても「文字列」として表示されることがあるようです。 そのセルはいったん編集モードにしてから確定すると「数値」として表示されるようです。 参考ページ 「数値を文字列として書式設定した場合の予期しない動作」 https://support.microsoft.com/ja-jp/kb/141765/ja > 数値に文字列の書式を設定するには、以下の手順を実行します。 > > 1. セルまたはセルの範囲を選択します。 > 2. [書式] メニューの [セル] をクリックします。 > 3. [表示形式] タブの [分類] で [文字列] をクリックし、[OK] をクリックします。 > 4. 選択したセルまたはセルの範囲に数値を入力します。 > > 上記の手順を実行した後、書式を数値に戻した場合は、数値を再入力する必要があります。 > > 注 : 数値の入力後にセルの書式を文字列数値形式に変更した場合、数値は残りますが、セル内で左揃えされて文字列として表示されます。 また、次のサイトも参考になるかもしれません。 「VLOOKUPは数値か文字列かでErrorになる」 http://excel-magic.com/post-1107/ > VLOOKUP関数使っている時に、検索値が範囲の中に絶対あるはずなのに#N/Aになる！っていうことありませんか？ No1の回答へのお礼を読んで、 セルの書式設定を全て「文字列」にしても#N/Aになっていると思ったのでノーブレークスペースを疑ったのですが、 スペースがノーブレークスペースでない場合は、 上記のページに書いてあることも確認したら良いかもしれません。 また、文字列表示になっている数字が数値表示に変わるとき、 文字列表示の時の末尾にあった通常のスペースは削除されるようです。 セルの書式設定を全て「文字列」にしても 「文字の配置」を設定してない状態で右詰めになっているとしたら、 再現方法が分かりませんので何とも言えませんが、 セルの書式設定を全て「文字列」にして 「文字の配置」を設定してない状態でセルの文字が全て左詰めになっていることを確認してから、 LENによる文字列の長さ（同じか否か）、=vlookupセルの状態（#N/Aか否か）を確認しないと混乱しそうです。 セルの書式を全て「数値」にして右詰めになっていることを確認してからの方が問題の原因を見つけやすい気もしますが…。
＃４です では、端折らない以下記述でどうなりますか （ Samp2 のままでは NG だったのでしょうか？ ） Public Sub Samp3() 　　Dim vR As Variant 　　Dim vA As Variant 　　Dim iRow As Long, iCol As Long 　　Dim i As Long, j As Long 　　Const CROW As Long = 11 　　Const CFIGW As Long = 6 　　Const CFIGNEXT As Long = CFIGW + 1 　　iCol = 1 　　While (iCol <= Range("AX1").Column) 　　　　If (Cells(CROW, iCol + 2) <> "") Then 　　　　　　With Cells(CROW, iCol + 2) 　　　　　　　　vR = .Offset(-2).Resize(2).Value 　　　　　　　　i = Cells(Rows.Count, .Column).End(xlUp).Row - CROW + 1 　　　　　　　　With .Offset(, -2).Resize(i, CFIGW) 　　　　　　　　　　vA = .Value 　　　　　　　　　　iRow = 0 　　　　　　　　　　For i = 1 To UBound(vA) 　　　　　　　　　　　　If ((vA(i, 3) >= vR(1, 1)) And _ 　　　　　　　　　　　　　　(vA(i, 3) <= vR(2, 1))) Then 　　　　　　　　　　　　　　iRow = iRow + 1 　　　　　　　　　　　　　　For j = 1 To CFIGW 　　　　　　　　　　　　　　　　vA(iRow, j) = vA(i, j) 　　　　　　　　　　　　　　Next 　　　　　　　　　　　　End If 　　　　　　　　　　Next 　　　　　　　　　　For i = iRow + 1 To UBound(vA) 　　　　　　　　　　　　For j = 1 To CFIGW 　　　　　　　　　　　　　　vA(i, j) = Empty 　　　　　　　　　　　　Next 　　　　　　　　　　Next 　　　　　　　　　　.Value = vA 　　　　　　　　End With 　　　　　　End With 　　　　End If 　　　　iCol = iCol + CFIGNEXT 　　Wend End Sub
こんにちは！ お望みでないVBAになってしまいますが、一例です。 画面左下の操作したいSheet見出し上で右クリック　→　コードの表示　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt+F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から// Dim myFirst As Range, myFound As Range Set myFound = ActiveSheet.Cells.Find(what:="Countif", LookIn:=xlFormulas, lookat:=xlPart) '★// If Not myFound Is Nothing Then Set myFirst = myFound Do Set myFound = ActiveSheet.Cells.FindNext(after:=myFound) myFound.Value = myFound.Value If myFound.Address = myFirst.Address Then Exit Do Loop End If End Sub 'この行まで// ※　上記コードは「COUNTIF」関数だけのセルを「値」にするようにしています。 AVERAGEIF関数のセルを同じように操作したい場合は ★の行で変更してください。 ※　注意点　※ COUNTIFS関数などにも反応してしまいますので、 もしCOUNTIFS関数のように「COUNTIF」が含まれる関数を使っている場合は 別の方法を考える必要があります。m(_ _)m
>Excel2007で開いて保存ボタンで保存した後、2010で開くと保存ボタンが動作しなくなります。 一回きりでしょうか。もしそうなら、セキュリティはセキュリティでも、セキュリティ情報が、Version違いのたびに書き換えが行われています。セキュリティが掛からないようにするには、デジタル署名か、オプションのセキュリティセンターの「信頼できる場所」に登録をするという方法をアドバイスする人もいます。私個人は、どちらもしていません。 それとも、ロックされたままになっているのでしょうか？ロックされたままなら、#1さんのご指摘の通りだと思います。昨年の12/11だったと思いますが、その後も、下位バージョンでトラブルが起きた覚えがあります。 ただ、「（xlsx ファイルの）日付を名前にして保存する」というマクロならば、私も使っていますが、そのマクロを搭載しているブックは別にしても、保存される側は、マクロがなければ関係ありませんね。
No.1です。 たびたびごめんなさい。 投稿後に気づきました。 Sheet1とSheet2の列の並び（北海道～沖縄）が同じであればE2セルの数式はもっと簡単にできました。 E2セルを =IF($B2="","",SUMIF(Sheet1!$V:$V,$B2,Sheet1!Z:Z)) にして、前回と同じ操作を行ってください。m(_ _)m
>セル（J1）に数値を入れ縦方向に変化する事ができました。 >そこで、あつかましお願いですが、横方向にズラス方法を教えてください。 それで、たぶんお気づきかと思いますが、.Cells(4+j, "E").Value と書いたけれども、5　と書かずに、"E"と書いてあります。 .Cells(4+j, 5 + k ).Value と書けば、良いわけですね。つまり、Range("E4") は、Cells(4,"E")　→Cells(4,5) Range("E7") →Cells(7, "E") → Cells(7,5) Range("I7") →Cells(7, "I") → Cells(7,9) と書き換えができます。これで、もう応用は出来るはずです。 '// Sub マックスタイムカード既存Try2() 　'#9003897 　Dim ws1 As Worksheet, ws2 As Worksheet 　Dim i As Long　'ループカウンター 　Dim j As Long　'代入数値（行方向） 　Dim k As Long　'代入数値（列方向） 　Dim Lr As Long　'メンバーシートの最後の行 　Set ws1 = Worksheets("マックスタイムカード") 　Set ws2 = Worksheets("メンバー") 　Lr = ws2.Cells(Rows.Count, 1).End(xlUp).Row 　With ws1 　　.Select 　　j = .Range("J1").Value 'マックスタイムカードのJ1 に数値を入れる 　　k = .Range("J2").Value 'マックスタイムカードのJ2 に数値を入れる 　　For i = 2 To Lr 'iはメンバーシートのデータを読み込む。 　　　.Cells(4 + j, 5 + k).Value = ws2.Cells(i, 1).Value '★セルE4に氏名を入力 　　　.Cells(7, "E").Value = ws2.Cells(i, 2).Value 'セルE7に係を入力 　　　.Cells(7, "I").Value = ws2.Cells(i, 3).Value 'セルI7に班を入力 　　　.PrintOut 'Preview:=True 'プレビューコマンド 　　Next i 　End With End Sub '///
データー一覧 C4　=index(indirect(offset($C$2,0,6*int((columns($C4:c4)-1)/6))&"!c:h"),12+rows(C$4:c4),1+mod(columns($C4:c4)-1,6)) C4 セルをコピーして C4:N8 のセル範囲に貼り付け。空白セルから参照することにより表示される「0」を非表示するには、ゼロのみを非表示にする書式として「0;;」などをセル範囲に設定。

これでよいのかな？ Excel 2007以降の関数を使用しました。IFERROR >建物名の中に・（ミドットのみ） =IFERROR(VLOOKUP(SUBSTITUTE(JIS($C2),"・",""),Sheet1!$A$2:$C$178,3,FALSE),"") >建物名の中に・. (ミドットとピリオド） =IFERROR(VLOOKUP(SUBSTITUTE(SUBSTITUTE(JIS($C2),"・",""),"．",""),Sheet1!$A$2:$C$178,3,FALSE),"") 今は規模が小さいようですから、関数でもよいのですが、もっと大規模で複雑になったら、マクロ形式に書き換えたほうがいいかもしれません。 なお、JIS(Sheet1!$A$2:$C$178)の場合、JIS関数の引数をそのまま範囲として指定しても、エラーになるはずです。データ元の方を全角にするしかないと思います。
並べ替えをする場合、基準となる順序があります。 ☆並び替えの順序 ☆並べ替えで注意すべきデータ http://allabout.co.jp/gm/gc/297700/2/　　←　読んで理解してください。
すぐに継続して、即席で考えました。（罪滅ぼしのつもりはありませんが、（^^;） これは、オートフィルタを使うので、そのタイトル行があれば、そんなに面倒なことをしなくて済むけれど、と思いました。BC行まで続きます。該当するものがない時は、そのままになります。 '// Sub OutDataClear() 　Dim cr1, cr2, cr3 　Dim cL As Long 　Dim i As Long 　Dim Rng As Range 　cL = 1 　With ActiveSheet 　　For i = 1 To 7 　　　cL = 1 + (i - 1) * 7 　　　Application.ScreenUpdating = False 　　　.AutoFilterMode = False 　　　.Cells(9, cL + 2).Resize(2, 2).Copy .Cells(8, cL + 2) 　　　'検索値の確保 　　　cr1 = .Cells(9, cL + 2).Value 　　　cr2 = .Cells(8, cL + 3).Value 　　　cr3 = .Cells(9, cL + 3).Value 　　　If cr1 = "" Or cr2 = "" Or cr3 = "" Then MsgBox "検索値が揃っていません", vbExclamation: Exit For 　　　 　　　'ダミーのタイトル 　　　.Cells(10, cL).Resize(1, 6).Value = Split("aa,bb,cc,dd,ee,ff", ",") 　　　 　　　Set Rng = .Range(.Cells(10, cL), .Cells(Rows.Count, cL).End(xlUp)).Resize(, 6) 　　　With Rng 　　　　'フィルター 　　　　.AutoFilter 　　　　.AutoFilter Field:=3, Criteria1:="=" & cr1 　　　　.AutoFilter Field:=4, Criteria1:=">=" & cr2, _ 　　　　Operator:=xlAnd, Criteria2:="<=" & cr3 　　　　If Application.Subtotal(2, .Columns(1)) = 0 Then 　　　　'　MsgBox "該当セルがありません。", vbExclamation 　　　　　ActiveSheet.AutoFilterMode = False 　　　　　GoTo Recover 　　　　Else 　　　　　'被検索値の退避 　　　　　.Offset(1).Copy Cells(1, 200) 　　　　End If 　　　End With 　　　.AutoFilterMode = False 　　　'元のデータの削除 　　　Rng.Offset(-1).Resize(Rng.Rows.Count + 1).ClearContents 　　　'被検索値のコピー 　　　.Cells(1, 200).CurrentRegion.Copy .Cells(11, cL) 　　　.Cells(1, 200).CurrentRegion.Clear Recover: 　　　'データの場所を元に戻す 　　　.Cells(10, cL).Resize(, 6).ClearContents 　　　.Cells(10, cL + 2).Value = cr1 　　　.Cells(9, cL + 3).Value = cr2 　　　.Cells(10, cL + 3).Value = cr3 　　　.Cells(9, cL + 2).ClearContents 　　　.Cells(8, cL + 3).ClearContents 　　　Set Rng = Nothing 　　　Application.ScreenUpdating = True 　　Next i 　End With End Sub '///
gekikaraou　さん、こんにちは。 最初に#8979529（アラーム） の時は、話が途中で大変失礼しました。機器の故障で、回線がまったくつながらくなって、元に戻るまでに2週間以上も掛かってしまいました。あれから、ずっと気にしていまして、質問で現れるまで、お待ちしていました。 今回の場合、 >Range(Cells(9, 13), Cells(9, Cells(9, Rows.Count).End(xlToup).Rows)).Select Cells(9, 13)　は、M9 ですし、 Cells(9, Cells(9, Rows.Count).End(xlToup).Rows) 　End(xlToup)　←これは、XlUp ですが、 　そもそも、Cells(行,列) ですね。 A1方式とは逆になります。 　列側に、Rows.Count を持ってくると、エラーになるはずです。 　Rows ではなくて、Row です。 　 ＊＊ ここの常連の人は、以下のような書き方の人が多いように思います。 私自身は、少し違う書き方をすることもあります。 正しくは、Rangeと、その中で使われるCells とは、つながりがないので、正しくは、上位オブジェクトのWith で、つながりを作ってやらなくてはなりません。Range の前、Cellの前に、ピリオドが入ります。 Dim EndRow As Long With ActiveSheet EndRow = .Cells(Rows.Count, 9).End(xlUp).Row　'必要な時は、エラー処理をします。 .Range("I11", .Cells(EndRow, 9)).Resize(, 7).Select End With
＃７です 　　　　vA(i, 1) = Mid(vB, 2) '☆ OK ↓ 　　　　vA(i, 1) = mySort2(Mid(vB, 2)) '☆ OK Samp2 の上記を変更の上、以下を追加してみてください Private Function mySort2(sSrc As String) As String 　　Dim dic As Object 　　Dim vA As Variant, v As Variant 　　Dim i As Long, j As Long 　　mySort2 = sSrc 　　If (InStr(1, sSrc, ",") = 0) Then Exit Function ' ★～ 　　Set dic = CreateObject("Scripting.Dictionary") 　　dic.CompareMode = vbTextCompare 　　For Each v In Split(sSrc, ",") 　　　　dic(v) = Empty 　　Next 　　vA = dic.Keys 　　Set dic = Nothing ' ～★ 　　For i = 0 To UBound(vA) - 1 　　　　For j = i + 1 To UBound(vA) 　　　　　　If (StrComp(vA(i), vA(j), vbTextCompare) > 0) Then 　　　　　　　　v = vA(i) 　　　　　　　　vA(i) = vA(j) 　　　　　　　　vA(j) = v 　　　　　　End If 　　　　Next 　　Next 　　mySort2 = Join(vA, ",") End Function ※ ' ★～　～★ 間は、「リンゴ　大　ﾐｶﾝ」時の 「くだもの,サイズ,くだもの」を「くだもの,サイズ」にまとめるものです。 まとめたくない場合は、★～　～★ 間を以下１行に。 　　vA = Split(sSrc, ",") ※ 上記並べ替えは、くだもの、サイズ、の比較になります。 もし、「キーワード一覧」に記述した分類順なら全面的に以下に変更。 なお、文字比較する InStr / Split / Replace 等で vbTextCompare 指定しなくても良いように Option Compare Text を宣言しておく例になるかも Option Explicit Option Compare Text Public Sub Samp3() 　　Dim dic As Object, dicW As Object, dicS As Object 　　Dim vA As Variant, v As Variant 　　Dim vB As Variant, vC As Variant 　　Dim vElm As Variant 　　Dim sS As String 　　Dim i As Long, j As Long 　　Const CNONE As Long = 1 　　With Worksheets("集計") 　　　　i = .Cells(Rows.Count, "A").End(xlUp).Row 　　　　If (i = 1) Then Exit Sub 　　　　Set dic = CreateObject("Scripting.Dictionary") 　　　　Set dicW = CreateObject("Scripting.Dictionary") 　　　　Set dicS = CreateObject("Scripting.Dictionary") 　　　　Call MakeDic3(dic, dicW, dicS) 　　　　With .Cells(2, "A").Resize(i - 1) 　　　　　　vA = .Resize(, 2).Value 　　　　　　For i = 1 To UBound(vA) 　　　　　　　　vB = "" 　　　　　　　　vC = Empty 　　　　　　　　sS = vA(i, 1) 　　　　　　　　If (InStr(1, sS, " ") > 0) Then 　　　　　　　　　　sS = " " & sS & " " 　　　　　　　　　　For Each v In dicW.Keys 　　　　　　　　　　　　If (InStr(1, sS, " " & v & " ") > 0) Then 　　　　　　　　　　　　　　sS = Replace(sS, v, "") 　　　　　　　　　　　　　　vB = vB & dicW(v) 　　　　　　　　　　　　End If 　　　　　　　　　　Next 　　　　　　　　　　sS = Trim(sS) 　　　　　　　　End If 　　　　　　　　For Each vElm In Split(sS, " ") 　　　　　　　　　　If (Len(vElm) > 0) Then 　　　　　　　　　　　　If (dic.Exists(vElm)) Then 　　　　　　　　　　　　　　vB = vB & dic(vElm) 　　　　　　　　　　　　Else 　　　　　　　　　　　　　　vC = CNONE 　　　　　　　　　　　　End If 　　　　　　　　　　End If 　　　　　　　　Next '　　　　　　　　vA(i, 1) = Mid(vB, 2) '★ 　　　　　　　　vA(i, 1) = mySort3(Mid(vB, 2), dicS) '★ 　　　　　　　　vA(i, 2) = vC 　　　　　　Next 　　　　　　.Offset(, 5).Resize(, 2).Value = vA 　　　　End With 　　　　Set dic = Nothing 　　　　Set dicW = Nothing 　　　　Set dicS = Nothing 　　End With End Sub Private Function mySort3(sSrc As String, dicS As Object) As String 　　Dim dic As Object 　　Dim vA As Variant, v As Variant 　　Dim i As Long, j As Long 　　mySort3 = sSrc 　　If (InStr(1, sSrc, ",") = 0) Then Exit Function ' ★～ 　　Set dic = CreateObject("Scripting.Dictionary") 　　dic.CompareMode = vbTextCompare 　　For Each v In Split(sSrc, ",") 　　　　dic(v) = Empty 　　Next 　　vA = dic.Keys 　　Set dic = Nothing ' ～★ 　　For i = 0 To UBound(vA) - 1 　　　　For j = i + 1 To UBound(vA) 　　　　　　If (dicS(vA(i)) > dicS(vA(j))) Then 　　　　　　　　v = vA(i) 　　　　　　　　vA(i) = vA(j) 　　　　　　　　vA(j) = v 　　　　　　End If 　　　　Next 　　Next 　　mySort3 = Join(vA, ",") End Function Private Sub MakeDic3(dic As Object, dicW As Object, dicS As Object) 　　Dim vA As Variant 　　Dim i As Long, j As Long 　　dic.CompareMode = vbTextCompare 　　dicW.CompareMode = vbTextCompare 　　dicS.CompareMode = vbTextCompare 　　With Worksheets("キーワード表") 　　　　i = .Cells(Rows.Count, "A").End(xlUp).Row 　　　　j = .Cells(1, Columns.Count).End(xlToLeft).Column 　　　　vA = .Range("A1").Resize(i, j).Value 　　　　For i = 2 To UBound(vA) 　　　　　　If (Not dicS.Exists(vA(i, 1))) Then 　　　　　　　　dicS(vA(i, 1)) = dicS.Count 　　　　　　End If 　　　　　　For j = 2 To UBound(vA, 2) 　　　　　　　　If (vA(i, j) = "") Then Exit For 　　　　　　　　If (InStr(1, vA(i, j), " ") > 0) Then 　　　　　　　　　　dicW(vA(i, j)) = dicW(vA(i, j)) & "," & vA(i, 1) 　　　　　　　　Else 　　　　　　　　　　dic(vA(i, j)) = dic(vA(i, j)) & "," & vA(i, 1) 　　　　　　　　End If 　　　　　　Next 　　　　Next 　　End With End Sub
No.5です。 プロシージャ①の.Selectの部分を置き換えてみてください。 エクセル設定で、エンターキーでカーソルが下に動く場合は、 SendKeys "{UP}" 右に動く場合は、 SendKeys "{LEFT}" これで試してみてくださいｍ(_　_)ｍ Private Sub Workbook_Open()でエラーが出るようでしたら On Error Resume Nextを先頭にいれるなど対策してください。 ActiveCell.Value = ActiveCell.Valueまま使用されるとセルに数式が入ってる場合は消えます。 If Range(ActiveCell.Address).Interior.Color = 13434828 And ActiveCell.Value > 0 Then ActiveCell.Value = ActiveCell.Value End If
>■制御タイミング >リスト選択時 画像のどこにリストがあるのでしょうか？ それが書かれていない限りは、これをどうやって答えてよいのか分かりません。 一応、オプションボタンは、ActiveX コントロールなので、リスト側も同じActiveX コントロールだと思うのですが、添付画像には、それが見当たりません。
10 分未満の切捨てが許される労働契約が交わされているという前提でお答えします。また、ひとまず、8:00 以前や 12:00 - 13:00 の時間外は考慮しないものとします。 退勤が翌日になるケースがある場合は、例えば 25:00 というふうに時刻を記録してください。セルの書式は「[hh]:mm」などを設定します。 F2　=max(0,e2-max(d2,"17:00")) G2　="00:15"*(int(f2/"00:15")+(round("00:10",6)<=round(mod(f2,"00:15"),6))) なお ROUND 関数は、小数点第 15 位付近に発生する計算誤差に対応するための処理です。
名前の計算ってどうやるの？
解答は既に出ていますが、この件は、かなり前から知っている割には、そういう現象だというしか認識ありませんでした。だから、Close と　Quit　の順番を逆にするということだけで、終わらせていました。 Excel2003ぐらいまでは、こんな問題は、クローズアップされることがありませんでしたから。 今まで、2003のコードでは順調に終了できていたものが、2007以降ではできないので、気がついたからです。何か違いがあるのかもしれません。 #2さんのモーグのサンプルコードのように、あくまでも、Closeメソッドを発生させないで、Saveでつないでいき、最後に、Application.Quit と入れる方法は、Microsoft 推奨のようです。 '// Sub myQuit_TEST() Dim wb As Workbook 　For Each wb In Workbooks 　　If Not (wb Is ThisWorkbook) Then 　　　If wb.Saved = False Then wb.Save　'保存 　　　 wb.Close False 　　End If 　Next 　　'自ブックの保存します 　　If ThisWorkbook.Saved = False Then ThisWorkbook.Save 　　Application.Quit End Sub '/// Closeメソッドで、その後のコードがすべてが破棄されるわけではなく、ThisWorkbook モジュール側のBeforeCloseイベントはExcel側で受け取っていますね。 だから、 'ThisWorkbook モジュール Private Sub Workbook_BeforeClose(Cancel As Boolean) 　Application.Quit End Sub このように、最後にQuit を入れてあげても終わることが出来るはずです。 参考にした所は、[Application.Quitの誤解] http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub0 …
Excel では、一行一行、異なる数式を書くのではなくて、「『限定という文字が使われている』といった条件に応じて、各行の数式そのものではなく『計算結果が』変化する、ただ一種類の数式」を考えるようにしましょう。 B1　=c1*(1.1+0.1*countif(a1,"*限定*")) 　　あるいは 　　=c1*(1.1+0.1*countif(a1,"*"&E$1&"*")) E1　限定
リストの元の値は 1 列または 1 行である必要があるので、作業列を用意して、そこから参照するほかないかと思います。添付図は、作業列にデータを写し取っている例です。 I2　=index(A$2:F$6,mod(h2,5)+1,(int(h2/5)+1)*2-1)
>検索キーワード 数式名を書いているのでそれで検索すれば腐るほど出ると思いますが… その補足書いている間に検索できますよね… =VLOOKUP(A1,Sheet2!$A:$B,2,0) =SUMIF(Sheet2!$A:$A,A1,Sheet2!$B:$B)
では、すでに試されたことかもしれませんが、 コントロールパネル→プログラムと機能から Excel（Office）をクリックし、上部に現れる『変更』をクリックし 現れるインストールオプションから『修復（R)』を行ってみては？ これでも改善しない場合は根本原因は別の所にある可能性も考えられます。 容疑者として濃厚なのは6/10に公開されたWindows Updateです。 Excelを立ち上げていなくても不都合が発生するのなら犯人？ （不都合がいつから起こるようになったか正確な日付が鍵になるかも） 6/9以前に『システムの復元』で巻き戻します。 Excelもインストール日によっては一緒に消えるかもしれませんので その場合は再インストール。 Windows Updateは『設定の変更』で 自動アップデートから個々に選択できるように変更します。 この状態で不都合が無ければ解決に向けて一歩前進かと思います。 以上ご参考までという事で。 PS. ディスククリーンアップで『Windows Updateのクリーンアップ』を行うと 全てのPCで起こるわけではありませんが、不都合が発生する場合があります。 http://freesoft.tvbok.com/tips/optimise_vista/di … 6/10のアップデートで修正されたのか未確認です。
こんばんは！ データは必ず　「数値＋半角スペース＋円」　のようになっているとします。 色々やり方はありますが、一例です。 A1セル以降にデータがありB列に表示するとします。 B1セルに =SUBSTITUTE(SUBSTITUTE(A1," 円",","),",","") という数式を入れフィルハンドルで下へコピーしてみてください。 ※　数式内の「円」の前には半角スペースがあります。m(_ _)m
こんにちは！ 条件付き書式で対応できます。 画像通りの配置でA1セルに数値を入力するとします。 A2～K5セルを範囲指定　→　条件付き書式　→　セルの強調表示ルール　→　指定の値より大きい　を選択し 左側の入力窓の右にある四角をクリック　→　A1セルを選択　→　入力窓の四角をもう一度クリック これで =$A$1 と表示されます。　→　右側「書式」の▼をクリックし好みの色で塗りつぶしてみてください。 これではどうでしょうか？m(_ _)m
H2　=if(i2,"チェック","") I2　=max(0,g2-sumifs(G$12:G$17,E$12:E$17,e2,F$12:F$17,f2)) I 列に算出されている「0」円を非表示にしたい場合は、I 列のセル範囲に対して「#,##0;;」などの書式を設定します（※）。 ※右クリック「セルの書式設定 > 表示形式タブ > ユーザー定義 > 種類ボックス」に上の書式記号を入力
