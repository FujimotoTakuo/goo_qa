うまくいかない原因はほかの方が回答されていますが、 それ以前の問題として、IPアドレスのチェックの要件が不足しています。 ソースから読み取れる、チェック内容は以下の内容です。 1.数字は0～255の数値であること 2.数字（0～9）、ドット(.)以外の文字は使用しないこと しかしながら、更に以下のチェックも必要なはずです。 3.ドットの数は3個であること 4.ドットの両端に数字があること 従って、 1)ドットで始まるアドレスはエラー 2)ドットで終わるアドレスはエラー 3)ドットが連続するアドレスはエラー となります。 5.数字の先頭が0の場合は、次に数字が来ないこと 例えば、00、012、のような数字はエラーとすること （これについては異論があるかも知れないが、ここではこのケースはエラーということにする） 尚、IP[i,j]のように2次元の配列を操作していますが、今回のようなケースでは 1次元の処理（１つの文字列の処理）を複数回繰り返すようにしたほうが、簡単ですっきりします。 又、atoi関数に渡す文字列をchar suchi[5]で定義し、そこに数字を格納していますが、 数字の開始位置を記憶し、その位置のアドレスをatoiに渡すようにしています。 （12.34 の場合、1のアドレス、3のアドレスをatoiに渡します。） 上記を踏まえて、作り直したものが、以下のプログラムです。 関数、check_addrに１つの文字列（IPアドレス）を渡し、チェックOKなら1を返します。 チェックNGの場合は、-1でなく、エラーの理由も判別できるように-1から-9の値を返します。 -------------------------------------------------------------------------------------- #include <stdio.h> #include <ctype.h> #include <stdlib.h> #define ORIGINAL (1) //アドレスチェック //戻り値=1:正常終了 //戻り値<0:異常終了 int check_addr(char ip[]){ int i = 0; int dot_ctr = 0; //ドット(.)のカウンター int bx = -1; //数字列の開始位置の添え字 while(ip[i] != '\0'){ //文字列の最後の\nはscanfは取り込まないので\0で判定する if (isdigit((unsigned char)(ip[i]))){ if (bx == -1){ bx = i; //数字列の先頭の位置を記憶する }else{ if (ip[bx] == '0') return -1; //先頭の数字が0なら以降に数字があるのはエラー } if (i-bx > 2) return -2; //数字列が3桁を超過ならエラー }else if (ip[i] == '.'){ dot_ctr++; if (dot_ctr > 3) return -3; //.の数が3個を超過ならエラー if (bx == -1) return -4; //.がいきなり出現場合はエラー if (atoi(&ip[bx]) > 255) return -5; //数字列の値が255を超過（マイナスにはならないので上限のみのチェックで良い） bx = -1; //開始位置の添え字を初期化 }else{ return -6; //数字、ドット(.)以外はエラー } i++; //次の文字を処理 } if (dot_ctr != 3) return -7; //.の数が3個でないのはエラー if (bx == -1) return -8; //.で終了しているのはエラー if (atoi(&ip[bx]) > 255) return -9; //数字列の値が255を超過ならエラー return 1; //正常終了 } #if ORIGINAL int main(void){ int M = 0;//アドレスの数 scanf("%d",&M); char IP[M][101];//M個のアドレス int i = 0; for(i = 0;i < M;i++){ scanf("%s",IP[i]); } for(i = 0;i < M;i++){ int hantei;//文字列が書式に会ったものかを判定した結果を格納 hantei = check_addr(IP[i]); if(hantei==1)printf("Yes\n"); else printf("No:%d\n",hantei); //hanteiが1以外ならエラー } return 0; } #else int main(void){ int M = 0;//アドレスの数 char *IP[] = { "1.2.3.4", "255.255.255.255", "0.0.0.0", "01.2.3.4", "1.00.3.4", "1111.2.3.4", "1.2.3.4.5", ".2.3.4", "1.2..4", "256.2.3.4", "a.2.3.4", "1.2.3", "1.2.3.", "1.2.3.256", }; M = sizeof(IP)/sizeof(char*); int i = 0; for(i = 0;i < M;i++){ int hantei = -1;//文字列が書式に会ったものかを判定した結果を格納 printf("<%s>",IP[i]); hantei = check_addr(IP[i]); if(hantei==1)printf("Yes\n"); else printf("No:%d\n",hantei); //hanteiが1以外ならエラー（エラーコードも印字） } return 0; } #endif -------------------------------------------------------------------------------------- 尚、プログラムは、IPアドレスを画面から入力する方法（従来の方法）とIP用の文字列を予め作成しておき それを渡す方法（第二の方法）のどちらかを選択できるようにしてあります。 #define ORIGINAL (1)　とすると従来の方法　になります。 #define ORIGINAL (0)　とすると第二の方法　になります。 第二の方法の実行結果は、以下の通りです。 <1.2.3.4>Yes <255.255.255.255>Yes <0.0.0.0>Yes <01.2.3.4>No:-1 <1.00.3.4>No:-1 <1111.2.3.4>No:-2 <1.2.3.4.5>No:-3 <.2.3.4>No:-4 <1.2..4>No:-4 <256.2.3.4>No:-5 <a.2.3.4>No:-6 <1.2.3>No:-7 <1.2.3.>No:-8 <1.2.3.256>No:-9
文法的には char (*ARRAY_SIZE_(T(*)[N]))[N]; は ARRAY_SIZE_ という関数の宣言で ・引数は T(*)[N] つまり「T 型の要素を N個持つ配列」へのポインタ ・返り値は char (*)[N] で「char 型の要素を N個持つ配列」へのポインタ です. C の文法を受け継いでいるので非常に読みにくくなっていますが, 「ARRAY_SIZE_」の直後に「(」があることから「ARRAY_SIZE_ が関数名である」とわかりますし, 対応する「)」までが引数リストになります. そして, 引数リストまでの部分, つまり「ARRAY_SIZE_(T(*)[N])」の部分を「X」と置きなおすと char (*X)[N]; となることから「関数を呼び出すと char (*)[N] が返ってくる」ことがわかります. これも C++11 以降だと auto を使って template <typename T,size_t N> auto ARRAY_SIZE_(T(*)[N]) -> char (*)[N]; と書くことができるので, ちょっとは見やすいかと. マクロ ARRAY_SIZE では返り値を * で逆参照して「char 型の要素を N個持つ配列」をつくり, それに対して sizeof を適用することで配列の要素数である N を求めています. でもこれ, ポインタの代わりに参照を使って #define ARRAY_SIZE(array) (sizeof ARRAY_SIZE_(array)) template <typename T,size_t N> char (&ARRAY_SIZE_(T(&)[N]))[N]; としても同じなんじゃないかなぁ. あとついでですが, ARRAY_SIZE_ を関数にしているのは「テンプレート引数を自動的に推定する」ためです. 関数テンプレートでは (可能なら) テンプレート引数を関数の実引数から推定します. つまり, 挙がっている例では ARRAY_SIZE(n) から (紆余曲折を経て) T = int, N = 40 となります. しかし, この自動推定はクラステンプレートには働かないので, template <typename T, size_t N, T (&)[N]> struct ArraySize { enum { size = N }; }; としても意味がありません. 逆に言うと「自動推定するためには関数テンプレートでなければならない」ので, 例えば make_pair のような補助関数があったりします.
たぶん, キャストで分かりにくいと思ったら キャストの代わりに新しい変数を導入する のが簡単だと思います. 例えば, 今の例 static_cast<Base&>(*this) = rhs; はキャストの部分「static_cast<Base&>(*this)」に新しい変数 t を導入すると { Base &t = *this; t = rhs; } のように書き直すことができます. これならわかるのではないでしょうか. 同様のことを static_cast<Base>(*this) = rhs; に対して実行すると { Base t = *this; // ここでコピーコンストラクタが呼び出される t = rhs; } になります. そして, 期待通りの動作にならないことも理解できるでしょう.
それはC++ではなく、マイクロソフトが.Net Frameworkの共通言語基盤（CLI）用に拡張したC++/CLIでしょう。たぶん。 　C++/CLIだとそういう書式です。 参考まで。
40年近くも前ですが、大学の計算機センターの汎用機での実習の際はグラフは全部自分で計算してプログラム化していました。縦軸は何行分、横軸は何文字（何カラム）分と決め、最大値と最小値がこの範囲の時は目盛りのキザミはこうで、、、、決め、プロラム内でそれを判断して書くようにしていましたね。 参考まで。
ここから、この方のページに飛んで行けば全部視聴できますよ
ＤＸライブラリが複数キーの押下を正常に認識できるのか、とか キーボードがその組み合わせの複数キーの入力がかのうなのか、とかはクリアしているものとします。 > if (CheckHitKey(KEY_INPUT_LEFT) == 1) x -= 4; > if (CheckHitKey(KEY_INPUT_S) == 1) x += 2; > if (CheckHitKey(KEY_INPUT_RIGHT) == 1) x += 4; > if (CheckHitKey(KEY_INPUT_S) == 1) x -= 2; > if (CheckHitKey(KEY_INPUT_UP) == 1) y -= 4; > if (CheckHitKey(KEY_INPUT_S) == 1) y += 2; > if (CheckHitKey(KEY_INPUT_DOWN) == 1) y += 4; > if (CheckHitKey(KEY_INPUT_S) == 1) y -= 2; 無駄なブロックはカットしました。 Ｓキー押下が検出されると… xに2を加算してxから2を減算して、yに2を加算してyから2を減算します。 結果として無事増減なしになります。 ブロックで囲っていようが、インデントしていようが、 > if (CheckHitKey(KEY_INPUT_LEFT) == 1) x -= 4; の条件式の結果は「x -= 4;」で完結しています。 if (CheckHitKey(KEY_INPUT_LEFT) == 1) 　　　{ 　　　　　 x -= 4; if (CheckHitKey(KEY_INPUT_S) == 1) x += 2; 　　　} としたかったのではありませんか？
>クライアント側はTcpClientでないと通信できないのでしょうか。 telnetでクライアント側は代用できます。 telnet 接続先アドレス ポート番号　 で接続が可能です。
手元には C99 の規格しかないのでそこから (うぅん, そろそろ C11 の規格も入手しとこうかなぁ). 一般論として「大きさ 0 の配列」を作ることはできません＞#1. 規格上規定している場所は違いますが, 大きさを整定数で指定する場合でも (定数でない) 整数式で指定する場合でも, いずれにおいても「値は 0 より大きくなければならない」 (shall have a value greater than 0) とされています. そして, 今の場合その規定に反しているので (「shall」に反していることから) プログラムは ill-formed であり, 従って undefined behavior となります. ちなみに #1 のリンクに書いてあることは (規格上は) 大間違いです. ひょっとすると GCC の拡張機能を「C99 の機能」と勘違いしているのかもしれません. あとついでに書いておくと, stdin に対して fflush を呼び出すのは一般にはアウトです. これも「できる処理系もある」というのは知ってるけど, 規格上はやってはいけません.
axWindowsMediaPlayer1.URL = @"C:\Users\ユーザー名\場所\ファイル名"; 　これでは、与えているパラメータが固定なので再生するファイルが違うだけでその都度コンパイルでしょうね。 　こんなときはパラメータを変数にしておきます。 　キーボードなどからフォルダの位置を記入することによって指定します。 ＞【C#】基本の入出力をメモ http://appakumaturi.hatenablog.com/entry/2011061 … 　リソースを埋め込みたいのであれば以下の方法があるようです。 ＞Visual Studioでリソースを管理する ＞http://dobon.net/vb/dotnet/programing/vsresource …
printfの方の%lfだけを%fにしてみては？
ITU(高機能16ビットインテグレーテッドタイマユニット)を使いHighの計測をすればいいと思います。 http://tokyo-ct.net/usr/kosaka/for_students/H8/D …
統合環境ではなく、コマンドプロンプト上での学習という条件になりますが 「独習C 第4版」 https://www.amazon.co.jp/%E7%8B%AC%E7%BF%92C-%E7 … 約10年前に出版された書籍ですが、未だに絶版になっていないところから人気の度合いをお測り下さい。 本来、windows XP/Vista 用ですが、windows 10(64bit)環境でも動作しております。（起動はwindows vista用のバッチファイルを使用して下さい） インストールは添付CDからフォルダを1個コピーするだけですので、1分で完了します。 初心者武向け定番のお勧めだと、visual studioを使用したものになると思います。 でも、巨大なファイル群のインストールが必要なことや、ソリューション・プロジェクト作成といったC言語本来の学習と関係ない部分で混乱する可能性がありますので個人的にはお勧めしません。 ただし、この手の書籍には記載内容・手法で、個人個人に向き不向きがありますので実際に書籍の内容を確認された上で購入されることをお勧めします。（もしかしたら本当の初心者の方には少々辛い内容なのかもしれせん、そのようなレビューが上記リンク先にも見受けられます。）
No.3のそれっぽい修正してみた https://ideone.com/cB8BQq
ここを起点に調べるのが良いと思います。 基本、専用のコマンドプロンプトから使います。 >https://msdn.microsoft.com/ja-jp/library/z7kx322 … nmakeを使うときはコマンドラインが便利なので 結構使います。
しかるべきライブラリをリンクするように指定していますか?
まずはコンパイラの準備ができているのでしょうか？ 　簡単な説明は以下のサイトにあります。 MacでC言語 - コンパイラ（gcc）のインストール - Xcode - Command Line Tools http://webkaru.net/clang/mac-compiler-gcc-install/ 　開発環境の構築ができたならば、その説明の下にＣ言語について触れているようです。 ＞C言語をはじめよう ＞http://webkaru.net/clang/ 　夢中になりすぎてネットに没頭しないでくださいね？
double x[6]と要素数は６つと定義しているわけですから、 n = sizeof(x) / sizeof(x[0]); と、書かなくても n = 6 と書けばすむことです。 ただ、保守性の問題から、定数を直接至る所へ記述するのは良くないことです。 (要素数を変更する必要ができたときに修正箇所が少ない方がいいですよね) #define ですますこともできますが、#define をかかなければなりません。 その点、定数(この場合６)を書いておくのではなく、sizeof(x) / sizeof(x[0]) にしておけば、要素数の定義(この場合 double x[6])を変更するのみでよくなります。
以下のようにしてください。 変更前の行は//でコメントアウトしています。 次の行に、変更した行が書かれています。 -------------------------------------------------- #include <stdio.h> struct data{ int sno; int a; int p; }; //void test_ave(struct test st1, struct test st2,struct test st3, double *avg, double *avg2) void test_ave(struct data st1, struct data st2,struct data st3, double *avg, double *avg2) { //*avg=(st1.a + st2.a + st3.a)/3; *avg=(st1.a + st2.a + st3.a)/3.0; //*avg2=(st1.p + st2.p + st3.p)/3; *avg2=(st1.p + st2.p + st3.p)/3.0; } int main(void) { //struct data st1 = {91,81},st2={72,92,},st3={53,63}; struct data st1 = {0,91,81},st2={0,72,92,},st3={0,53,63}; double ave_am,ave_pm; //ave(st1,st2,st3,&ave_am,&ave_pm); test_ave(st1,st2,st3,&ave_am,&ave_pm); //ave->test_ave //printf("午前の平均売り上げ=%d万円\n",ave_am); printf("午前の平均売り上げ=%lf万円\n",ave_am); //printf("午後の平均売り上げ=%d万円\n",ave_pm); printf("午後の平均売り上げ=%lf万円\n",ave_pm); return 0; } ---------------------------------------------------- 以下、実行結果です。 午前の平均売り上げ=72.000000万円 午後の平均売り上げ=78.666667万円
Windows版intel fortranの標準のコマンドライン環境はどのようになっていますか。 普通にコマンドプロンプトを開けば使えるならグローバルに設定しているのでcygwinなどの環境でもそのまま使えるかもしれません。 専用のコマンドラインを開くなら、起動スクリプトで環境変数など設定しているでしょうから、その起動スクリプトと同じ設定をすれば使えるでしょう。intel fortranはしりませんが、Visual C++のコマンドラインがそんな感じでした。 大体はインクルード用の環境変数とリンク用の環境変数、そしてコンパイラのパスと動的ライブラリのパスを追加するくらいで動くと思います。 ただWindows10なら今日にも配布されるUpdateでは標準でbashが使えるようになるので、cygwinよりそちらを使った方が素直な環境になるのではないかと思います。なお、bashを使う場合でも環境設定は上と同様です。
うん, それはとても残念だ. erf が使えるのは, VS だと 2013 以降なのだよ. https://msdn.microsoft.com/ja-jp/library/dn32904 … は 2015 だけど, 「その他のバージョン」で 2013 も選べることから (正確には「2013 しか選べない」ことから) わかる. で「今まで作ってきたVS2012でのプログラム」が「VS2015でも使用できるのか」は私も知らん. とりあえず「VS2012 では erf は使えない」とだけ書いておこう.
>プログラムを実行してから数秒後に止まってしまいます。 「止まってしまう」というのがどういう状態なのか不明ですが……。 とりあえず気になるところを。 >wiringPiISR(23,INT_EDGE_BOTH,&encoder23); 「ループの中で」毎回設定する必要がありますか？ >count=0; １ループの間に０に戻されますが、encoder23()の中での増減はどうなりますか？ あと、最適化で殺されませんか？ # 「ループの中では」常に０ですが、ループの外に追い出されていたりしませんか？ >dt = ( startTime-endTime) * 0.000001; // μsec→sec 無いとは思いますが、dtが０になったりしていませんか？ # ０になっていると、vel= (double)(N/dt);で死ぬかも知れません。 >en23 = digitalRead(23); >if(digitalRead(23)== digitalRead(24)) count++; 同じく無いとは思いますが、２つのdigitalRead(23)の間で状態が変わることはありませんか？ # 回転方向の検出はこれでいいんでしょうか？ # http://startelc.com/H8/H8_51Encder1.html な情報もありますけど。
mshtml　じゃあなくて、cshtml　では？
conio.h (および、それに関連した関数等) はMS-DOS用のもので、Macを始めとするUnixやLinuxでは利用できません。 ncursesライブラリを使うとかで、同等のことはできますが、単純な置き換えではないので、よく調べて使ってください。
#7です。 パラメータを右回転数を与えるようにしました。 右回転数＝０　そのまま 右回転数＝１　右へ90度 右回転数＝２　右へ１８０度 右回転数＝３　右へ２７０度 --------------------------------------------- #include<stdio.h> int GetConst(int X,int Y) { if (X == -1 || Y== -1) return 4; return 0; } int GetIndex(int base,int rot) { if (rot < 0) rot = 3; if ((base+rot%2)%2 == 0){ return 0; }else{ if ((base+rot/2)%2 == 0){ return -1; }else{ return 1; } } } void FunctionROT(int rot) { int x = 0; int y = 0; int X1,X2,C1,Y1,Y2,C2; int dt[5][5]={ {88,11,11,11,88}, {88,11,88,88,88}, {88,11,11,11,88}, {88,11,88,88,88}, {88,11,88,88,88} }; X1 = GetIndex(1,rot); Y1 = GetIndex(0,rot); C1 = GetConst(X1,Y1); X2 = GetIndex(1,rot-1); Y2 = GetIndex(0,rot-1); C2 = GetConst(X2,Y2); //printf("\nX1=%d Y1=%d C1=%d X2=%d Y2=%d C2=%d\n",X1,Y1,C1,X2,Y2,C2); for( x=0; x<=4; x++){ printf("\n"); for( y=0; y<=4; y++){ printf("%-d", dt[X1*x+Y1*y+C1][X2*x+Y2*y+C2]); } } } int main(void) { FunctionROT( 0 ); FunctionROT( 1 ); FunctionROT( 2 ); FunctionROT( 3 ); return 0; } --------------------------------------------- 以下、実行結果です。 8811111188 8811888888 8811111188 8811888888 8811888888 8888888888 1111111111 8888118811 8888118811 8888888888 8888881188 8888881188 8811111188 8888881188 8811111188 8888888888 1188118888 1188118888 1111111111 8888888888 ｰｰｰｰｰｰｰｰｰｰｰｰｰｰ
GC mc[N] = { //モンスター用 　{ "m0", 0, 0, 0, 0 }, 　{ "m1", 0, 0, 0, 0 }, 　{ "m2", 0, 0, 0, 0 }, 　{ "m3", 0, 0, 0, 0 }, 　{ "m4", 0, 0, 0, 0 } }; GC mc_copy[N] = { //モンスターを複数作成する時用 　{ "mc0", 0, 0, 0, 0 }, 　{ "mc1", 0, 0, 0, 0 }, 　{ "mc2", 0, 0, 0, 0 }, 　{ "mc3", 0, 0, 0, 0 }, 　{ "mc4", 0, 0, 0, 0 } }; こんな感じにしておくと…少なくとも「未初期化のローカル変数」参照で文字化け(ゴミ)が表示されることはなくなるかと思いますよ。 memset()で構造体配列を0x00埋めしてしまう。というのも有りかもしれませんが。 ただし、その場合は >printf(" %-37s%-1d\n", mc_copy[*num].name, i); などで表示される文字列はなにもなし…になりますけどね。
gcc使っているなら、 -Wall オプション付けることをお勧めします。 そうすれば taa065.c:9:15: warning: implicit declaration of function 'atof' 等と「関数の暗黙の定義」と警告してきます。 警告は、エラーではないので、コンパイル自体は「正常」に完了します。 ですが、多くの場合は、期待しない動作の原因となります。 C言語では、定義されていない関数が出てきたら、 任意引数、戻り値intの関数だと勝手に解釈します。 おそらく、 atofがdoubleの5.0を返す →「doubleの5.0と同じビットパターンのint」が帰ってきたと判断される →変数inに、「doubleの5.0と同じビットパターンのint」と同じ値を持つdoubleに変換されて格納される ということが起っているのでしょう。
Javaには標準のAPIってのがありますが、C言語でそれに相当するものと言えば「標準ライブラリ」になるでしょう。 > 付録 A　主要な標準ライブラリ関数 ってところに載っているのでほぼ全部と思ってよいでしょう。 ウィンドウ表示とかDBアクセスとかが無いのは、C言語としての「標準」を用意していないからです。 OSや別のライブラリで用意されたものを使います。 その使い方は、それぞれのマニュアルを参照してください。
なにも考えずただ「丸写し」するだけだったら時間の無駄だと思う. 「どうしてそのような書き方をするのか」「そのように書くとどのように動作するのか」を意識しながらなら「丸写し」でもいける... かもしれない.
scanfで変数に入れる方法はわかりますね? scanfで2つの変数に2つの数値を入れる →それらの変数を引数にして関数を呼ぶ だけです。 しっかし、随分と古い書き方のプログラムになってますね。
質問文には「コンパイルが通らない」とは書いてないんだけどね＞#3. まあ, 「うまく機能しません」は典型的な「ダメな質問」だけど. 最低限 ・何を期待したのか ・実際にはどうなったのか くらいは書かないと, 質問として成り立たないと思ってほしいな. あ, 1点「どう見てもおかしい」ところがあるわ. printf("0～9の中の3つの異なる数字を当てるゲームです。\n同じ数字が複数含まれることはありません。\n「123」のように連続して入力してください。\nスペース文字などを入力してはいけません。\n1～9の中から3つの異なる値を入力してください。\n\n"); って, C を知らない人が見ても「おかしい」ってわかるよねぇ.
http://opencv.jp/opencv-2svn/cpp/user_interface. … マニュアルに書いてあります。 なお、現状のプログラムでは、qを押しても else if (waitKey(1) == '1') { ←この待ち時間でqの入力を検出 } else if (waitKey(1) == 'q') break;← この待ち時間では、もうqは検出されない ということが発生する可能性があります。 int keycode ; keycode=waitkey(1) ; ←ループ毎に、ここで1回だけキー入力を待つ if (keycode== ... ) ←以下、上で読み込んだkeycodeで判定する という形にするのがよいでしょう。
「外部仕様」を具体的に決め、それを漏れなく示した外部仕様書に「これでＯＫです」という検印をいただくことです。これにつきます。 　何を入れたら何が出て来るシステムを欲しているのかを文書化することです。 　具体的な部分では画面の操作仕様、ユーザがその内容構造を意識する入出力ファイル仕様などです。 　データベースのテーブル構成や各テーブルの構造は正規化の結果なので詳しくは不要でしょうが、俗に「○○マスター」と称するような各種管理テーブルはエンドユーザが「何をキーに何を一元管理しているのか」に関わるので十分な理解と確認が必要です。 　ここまでは「あたりまえ品質」を確実に提供するためですね。 　で、システムがシステムとして動作するためという側面で特に注意すべきはエラー仕様です。画面操作や入力ファイルで指定できる値の範囲。それを超えて指定した場合のエラー時の動作。 　何らかのソフトウェア障害やハードウェア障害が有った場合の動作仕様。リカバリー方法。この辺はトランザクション単位（←データベースのトランザクションと言う意味だけではなく、エンドユーザの操作仕様や業務仕様という視点でのより広義な意味で）。etc.etc. 　人間系を含めたシステムの動作全体が異常時もきちんと完結し、業務再開後に処理中だったものの再実行が容易に出来るか、、、つまりデータの取りこぼしが無いかといったところを中心に詰めることです。 　システム開発の組織構成で、発注元からプログラム開発者の間にエンドユーザの言葉と開発者の言葉の両方を理解する者、つまり必要なスキルを持ったSEが居ない場合、エンドユーザが開発者に短時間で近づくのは無理ですから逆をやるしかありません。 　開発者のこれまで経験（力のあるSEの下でどういう経験をして来たか）が問われる力の出し所です。システム開発の上流工程を奪い取るまたは、その分野に食い込むチャンスと考えしっかり進めて下さい。 参考まで。
>char fmt10]; これはなんでしょうか？
Ｃ言語以外だとＲｕｂｙ言語くらいか。 　絶版なので入手が困難。 　Ｃ言語で開発するのは難しいかな？ 恋するプログラム―Rubyでつくる人工無脳 https://www.amazon.co.jp/%E6%81%8B%E3%81%99%E3%8 … 　環境が違いすぎるので参考にもならないかもしれないけど、昔はこういう書籍もあった。 Cでつくる続 脳の情報システム https://www.amazon.co.jp/C%E3%81%A7%E3%81%A4%E3% …
見た感じ Additional Dependencies で Data.obj まで指定すればいいように思うんだけど.... 違うかなぁ?
素で字が小さくて見えない。写真も横向きだし…読んでもらおうという気はあるのだろうか。
エラーの内容が書かれていないのでなんとも言えませんが、ちょっと調べた限りでは以下のように書くようです。 --- std::wstring s1 = std::to_wstring(a); std::wstring s2 = std::to_wstring(b); std::wstring s3 = std::to_wstring(c); Platform::String^ str1 = ref new String(s1.c_str()); Platform::String^ str2 = ref new String(s2.c_str()); Platform::String^ str3 = ref new String(s3.c_str()); ---
> 引数だけでどこでどう判断しているのですか？ 申し訳ありません、意味がわからないので、このご質問には回答できかねます。 > 関数形式マクロ dtaは戻り値が書いてないのに戻ります 関数形式マクロはあくまでもマクロであって関数ではありません。 プリプロセッサによって定義された通りに変換されるだけです。 この場合は、 > #define dta(a,b) ((a)+(b)) によって > cc=dta(50,50); は、 cc=((50)+(50)); へ変換されるだけです。 > priは戻り値が書いてないので何も起こりません これが関数だと仮定しても、「戻り値が書いてない」としても「何も起こりません」というのは理解できません。これはまるで戻り値がない、もしくは戻り値を使用しない関数は意味がない、もしくは何もしないように聞こえますが、そういうことが言いたいのでしょうか。もしそうなら、そのお考えはまったく間違っています。 件の、 > pri(cc); は、 > #define pri(dt) printf("%d\n",dt) の定義に従いプリプロセッサによって、 printf("%d\n",cc) へ変換されます。 「戻り値が書いてない」、この文の意味がわかりませんが、返還後の printf 関数には戻り値があります。この関数の戻り値を使うことは稀ですが。
「オブジェクト指向」における「メッセージパッシング」だと, ふつうは #1 にあるように「オブジェクトにメッセージを送る」というイメージだろうなぁ. #2 の後ろにある「これがメッセージパッシングです」はなんかずれてる感じがする. もっと単純にいえば「オブジェクトに対して命令する」というのが「メッセージパッシング」だ, といってもだいたいあってる. あとついでにいうと #1 の「多態性」というのは「同じメッセージでもレシーバー (受け取るオブジェクト) によって異なる動作をする」というやつだ. 英語でいうと polymorphism.
仕事量の見積もりは人それぞれ。妥当な理由があれば、スケジュールは承認されるし、そうでなければ承認されない。 質問者の方から見て、妥当でない判断であっても、細かく条件を見ていけば必要な工数なのかもしれません。 ＞自分が理解できない難しい専門用語を交えて説明していました あなたが理解できない何かがわかっているのかもしれません。 ＞ところが、自分が影響調査をしてみると、開発工数は1日くらいで(ただコピーすればいいだけ)、テストもすぐ出来るのではないか あなたには見えていない何かがその人に見えているかもしれません。 色々と色眼鏡で見るのをやめてみてはいかがでしょうか。 その人にはその人のタスクがあり、ペースがある。 あなたにはあなたのタスクがあり、ペースがある。 適材適所だと思います。 客観的に評価をするのは、人事。要領の良し悪しは、ITに限らず、どこの業種でもある話だと思いますが。
> char ** > read (void) > { > 　char buf0[BUF_SIZE]; > 　char buf1[BUF_SIZE]; > 　static char * string_pair[2]; > > 　fputs ("比較元:", stdout); > 　fgets (buf0, BUF_SIZE, stdin); > 　fputs ("比較対象:", stdout); > 　fgets (buf1, BUF_SIZE, stdin); > 　string_pair[0] = buf0; > 　string_pair[1] = buf1; > > return string_pair; > } この関数には１つ推奨できない点と１つの間違いがあります。 read はある処理系において予約関数です、この名前は使用すべきでなないです。(←余談です) 問題は、変数 buf0 と buf1 です。この変数は、ローカル変数でスタック上に記憶領域がとられます。よって、この変数はこの関数から戻ったら無効になります。 最適化した場合にうまく動作するのは、恐らくインライン展開のような最適化が行われ、結果的に変数の記憶領域がスタック上に置かれない、もしくはmain () と同一のスタック上に置かれるためと思われます。 確認するには、最適化した時のアセンブラーコードを確認する必要がありますが。
使ったことはありませんが… http://dev.mysql.com/doc/connector-cpp/en/ にいろいろ書かれています。 chapter3とchapter5辺りは必読…でしょうかね。 mysql_connection.h覗いたら…boostライブラリ必要っぱいかんじが……。
「math.h 抜き」, ねぇ.... 例えば #include <stdio.h> double sin(double); double cos(double); int main() { double hypotenuse = 37; double angle = 0.1; double height = hypotenuse * sin(angle); double base = hypotenuse * cos(angle); printf("height = %f, base = %f\n", height, base); return 0; } で求まるね.
https://msdn.microsoft.com/ja-jp/library/ktss1a9 … > stdin、stdoutと stderr のストリームは、テキスト モードで既定で開きます (_setmode等で変更していない限りでは)stdinからの読み込みは、(ファイルやプロセスにリダイレクトされていても)入力の \r\n は \n に変換されます。
>alignmentや呼び出し規約ってなんですか？ alignment 構造体のメンバ配置の制限具合かな。詳細は コンパイラのマニュアルを見て下さい。 呼び出し規約 関数呼び出しでのスタックやレジスタの使い方。__fastcall とかいろいろ有りますが、64bitでは絶滅危惧種です。 >共通ライブラリ(SO)に修正が入ると、 >フルコンした方がよい 通常はincludeに修正が入らなければ不要。
スレッドと同じなんだけど、AppDomain だったか、別のドメインで動かしてみると多少改善するかも。 或いは優先度を下げて動かすとか…
C でやるのと同じようにしたらできませんかね.
プロトタイプ宣言じゃないですかね？ >①が無くても動作するようなのですが、 引数はint型、戻り値もint型というデフォルトが適用される…かと。
c->ushiro != NULLが終了条件なので、最後の要素(c->ushiro == NULL)の時、forの中に入ってないんじゃない？
No.10ですが、最適でないルートを示す場合があったのでパラメータ調整をしました。 その他 ・文字をキーから入力するようにした ・ノード情報を構造体にした -------------------------------- // // http://web.tuat.ac.jp/~tuatmcc/contents/monthly/ … // #include <stdio.h> #include <string.h> #define MAX 32 typedef enum Dir_t {Left = 1, LeftLow, Low} Dir; typedef struct Node_t { 　　Dir minDir; // 積算値が最小となる方向 　　int minVal; // 最小積算値 　　int leftVal; // 左から来た場合の積算値 　　int leftLowVal; // 左下から来た場合の積算値 　　int lowVal; // 下から来た場合の積算値 } Node;; void input(char buf[], int size); int equalChar(char *src, char *dst, int s, int d); void setMinDir(Node *node, int y, int x); int main(void){ 　　char src[MAX + 1], dst[MAX + 1]; 　　Dir path[2 * MAX + 2]; 　　Node map[MAX + 1][MAX + 1]; 　　 　　int srcSize, dstSize; 　　int x, y, i, val, min, distance; 　　// 比較元、対象文字列の先頭にダミーを追加 　　src[0] = '.'; 　　dst[0] = '.'; 　　// 文字入力 　　printf("　比較元："); 　　input(&src[1], MAX); 　　printf("比較対象："); 　　input(&dst[1], MAX); 　　srcSize = strlen(src) - 1; 　　dstSize = strlen(dst) - 1; 　　// mapの初期化 　　map[0][0].minDir = LeftLow; 　　map[0][0].leftLowVal = 0; 　　map[0][0].minVal = 0; 　　// mapの各ノードについて経路の積算値の計算 　　for(y = 0; y <= srcSize; y++){ 　　　　for(x = 0; x <= dstSize; x++){ 　　　　　　// 積算値が最小となる、このノードへの方向を設定 　　　　　　setMinDir(&map[y][x], y, x); 　　　　　　// このノードの最小積算値 　　　　　　min = map[y][x].minVal; 　　　　　　 　　　　　　// 上ノードへの積算 　　　　　　val = 2; 　　　　　　if( y < srcSize){ 　　　　　　　　if( !equalChar(src, dst, y+1, x) ) val *= 5; // ペナルティ 　　　　　　　　map[y+1][x].lowVal = min + val; 　　　　　　} 　　　　　　// 右上ノードへの積算 　　　　　　val = 1; 　　　　　　if( y < srcSize && x < dstSize ){ 　　　　　　　　if( !equalChar(src, dst, y+1, x+1) ) val *= 10; // ペナルティ 　　　　　　　　map[y+1][x+1].leftLowVal = min + val; 　　　　　　} 　　　　　　// 右ノードへの積算 　　　　　　val = 2; 　　　　　　if( x < dstSize){ 　　　　　　　　if( !equalChar(src, dst, y, x+1) ) val *= 5; // ペナルティ 　　　　　　　　map[y][x+1].leftVal = min + val; 　　　　　　} 　　　　} 　　} 　　// 終了地点（map右上）からスタート地点へ最小ルートを辿る 　　x = dstSize; 　　y = srcSize; 　　i = 0; 　　while(x > 0 || y > 0){ 　　　　path[i] = map[y][x].minDir; 　　　　switch( path[i] ){ 　　　　case Left : x--; break; 　　　　case LeftLow : x--; y--; break; 　　　　case Low : y--; break; 　　　　} 　　　　i++; 　　} 　　// 結果表示 　　distance = 0; 　　for(i--, x = 0, y = 0; i >=0; i--){ 　　　　switch( path[i] ){ 　　　　case Left: 　　　　　　printf("%c(挿入)", dst[x+1]); 　　　　　　distance++; 　　　　　　x++; 　　　　　　break; 　　　　case LeftLow: 　　　　　　if(equalChar(src, dst, y+1, x+1)) 　　　　　　　　printf("%c(一致)", src[y+1]); 　　　　　　else{ 　　　　　　　　printf("%c(置換,%c→%c)", dst[x+1], src[y+1], dst[x+1]); 　　　　　　　　distance++; 　　　　　　} 　　　　　　x++; 　　　　　　y++; 　　　　　　break; 　　　　case Low: 　　　　　　printf("%c(脱落)",src[y+1]); 　　　　　　distance++; 　　　　　　y++; 　　　　　　break; 　　　　} 　　} 　　printf("\n"); //　　printf("編集回数：%d\n", distance); 　　printf("編集距離：%.3f\n", distance/(double)(srcSize>dstSize?srcSize:dstSize) ); 　　return 0; } // 比較元と比較対象の指定位置の文字が一致するか否か int equalChar(char *src, char *dst, int s, int d){ 　　if(src[s] == dst[d]) return -1; 　　return 0; } // 左、左下、下の3方向の最小値を示す方向と積算値を // 保存する。 void setMinDir(Node *node, int y, int x){ 　　int i; 　　Dir d; 　　if( y == 0 || x == 0){ 　　　　// mapの左辺および底辺のノードは規定値を設定する 　　　　if(x == 0 && y == 0){ 　　　　　　node->minDir = LeftLow; 　　　　　　node->minVal = node->leftLowVal; 　　　　} else if(x == 0){ 　　　　　　node->minDir = Low; 　　　　　　node->minVal = node->lowVal; 　　　　} else if(y == 0){ 　　　　　　node->minDir = Left; 　　　　　　node->minVal = node->leftVal; 　　　　} 　　} else { 　　　　// その他のノードは最小積算値の方向を設定する 　　　　if(node->leftVal < node->leftLowVal){ 　　　　　　i = node->leftVal; 　　　　　　d = Left; 　　　　} else { 　　　　　　i = node->leftLowVal; 　　　　　　d = LeftLow; 　　　　} 　　　　if( node->lowVal < i){ 　　　　　　i = node->lowVal; 　　　　　　d = Low; 　　　　} 　　　　node->minDir = d; 　　　　node->minVal = i; 　　} } // 文字列入力 void input(char buf[], int size){ 　　char *p; 　　fgets(buf, size, stdin); 　　// 改行コード削除 　　for(p = buf; *p != '\n'; p++) ; 　　*p = '\0'; }
https://oshiete.goo.ne.jp/qa/9343118.html で言われたことについて, どのように考えているのでしょうか? 「そんなことは関係ない, 自分で解く気など毛頭ない」ということでしょうか? そして #1 のような使い方をするくらいなら素直に scanf にすべし.
しかも、まだPCの使い方分かってないし・・・・・。 何で横向けでの写真投稿なんですか。 「相手が見づらい」って思わないんですか。 少なくとも「モノを教わろう」って人間の態度じゃないんですよ。 確かにプログラム書くのはメンド臭いし、やりたくないのも分かる。 しかし「貴方が面倒くさい」って思うモノは他人も(たとえプロのプログラマでも)「面倒くさい」んですよ。 その「面倒くさい」事を他人に頼むのなら、少なくとも「写真は縦でそのまま見れる」ようにすべきです。 こんな横向きで見づらい写真を投稿する、とか、フツーに考えると「ふざけるな」ですね。 相手の面倒をなるべく減らすように出来るだけの事をしなさい。 常識です。 今のトコ、あなたの考え方の基本は間違っています。 ＊写真の方向の直し方 1. PCにスマホから写真を転送する(USBで接続するもよし、メールで転送するもよし) 2. PC上に保存した写真をダブルクリックで立ち上げる 3. 回転ボタンがあるからそれで角度を変える 4. 保存する 5. それで投稿 ・・・・・っつーかね、これも基本で、こないだ書いた通り「PCの使い方がそもそも分からない」・・・「分からない」っつーか「分からなさ過ぎてる」んで、まずはPCの使い方から学びなさい。 プログラミングどころじゃない、それ以前の話です。 取り敢えずPCのマニュアル読むなり、この辺 https://www.amazon.co.jp/gp/bestsellers/books/52 … の本を本屋で買いなさい。 /// ここから #include <stdio.h> #include <stdlib.h> #define BUF_SIZE 2048 int read(void); int get_absolute_value(int number); int main(void) { 　printf("絶対値 : %d\n", get_absolute_value(read())); 　return 0; } int read(void) { 　char buffer[BUF_SIZE]; 　fputs("整数入力 --> ", stdout); 　fgets(buffer, BUF_SIZE, stdin); 　return atoi(buffer); } int get_absolute_value(int number) { 　return abs(number); } /// ここまで あとね、また「stdio.hだけで」とか言うのもナシね。 (写真には)問題にそんな要求は書いてないし、ハッキリ言って、 「Cの標準ライブラリに添付されてある」 関数(stdlib内abs関数)使えば済むモノを、わざわざ「再実装してぇ!」、とか言う人もいませんよ。 あ、あと。 出来れば中学校の数学の本も買った方が良いですね。 この辺から買って読むべきでしょう。 https://www.amazon.co.jp/s/ref=nb_sb_noss_1?__mk …カタカナ&url=search-alias%3Dstripbooks&field-keywords=中学校+数学&rh=n%3A465392%2Ck%3A中学校+数学 こんなのプログラミングの問題でもなくって、中学校1年生の数学の話ですよ。
1. 「環境変数を設定する」だけのファイルを作り, それで環境変数を設定してからおもむろに gdb を実行するというのは不可能なんでしょうか? 2. 「飛ばす」とはどういうことでしょうか? 簡単な例を示してもらえますでしょうか?
#1氏の言う通り、ですね。 基本的にプログラマってのは「キチンと仕様が確定しないと」書きたがらないんです。あるいは、書いたままその通りに実装しちゃう。 最近の質問だとこんなのありましたね。 7と入力したら画像のような図形が出力されるプログラムをループで組みたいです。 : https://oshiete.goo.ne.jp/qa/9332485.html これは恐らく、質問した人はこういうプログラムは欲しく無かったんじゃないでしょうか。 しかし、別にプログラマの人たちが意地悪してるわけじゃなくって、「書いたまま」、つまり仕様(と思わしきモノ)を見て実装するとこうならざるを得ないんです(実はコード見て爆笑してたんですが・笑)。 この問題の場合も、 ・経路が分からない。 ・東京、あるいは大阪にいる場合、どういう質問が出てくるか分からない。 等、不明な点が多いんですよね。 間違っちゃいけないんですが、「例を挙げる事」自体は良い事なんです。絶対動作例は挙げた方が良い。 かと言って、動作例「だけ」でもどーしよーも無いモノなんですね。 キチンと要求仕様を明確にしましょう。 明確じゃない仕様でプログラマにプログラミングさせようとすると、最近のみずほ銀行のニュースみたいな事になってしまいます。 【悲報】みずほ銀行の次期システム、デスマプロジェクトが破綻か。完成のメドなく4000億円がパー: http://blog.livedoor.jp/itsoku/archives/49014907 … みずほ銀行みたいにならないようにしましょう。 取り敢えず考えられる限りの条件付加で、やっつけでプログラミングしてみました。 ・経路は東京->名古屋->大阪とする(逆はない)。 ・東京、名古屋に於いては「次の駅に行くか」訊く。 ・従って、必然的に大阪が終着駅となる。 /// ここから #include <stdio.h> #include <stdlib.h> #include <string.h> #include <stddef.h> #define BUF_SIZE 128 #define LEAVE 4 #define GO 5 typedef struct station_tag { 　char* name; 　char* next; } station; int read(size_t n); char* eval(int arg, int* f, station s[], size_t m, char** msg, size_t n); int main(void) { 　station stations[] = { { "東京", "名古屋"}, 　　　　　　　　　　　{ "大阪", "None" }, 　　　　　　　　　　　{ "名古屋", "大阪" } }; 　char* messages[] = { "どこに行きますか?\n", 　　　　　　　　　　　"%sなら%d", 　　　　　　　　　　　"%sに到着しました\n", 　　　　　　　　　　　"%sで降りる場合は%d%sに行くなら%d", 　　　　　　　　　　　"お疲れ様" }; 　int i = 0; 　int flag = 1; 　puts(messages[0]); 　while (flag) { 　　printf(messages[1], stations[i].name, i+1); 　　if (i == sizeof(stations)/sizeof(stations[0]) - 1) { 　　　printf("\n"); 　　　break; 　　} 　　printf("、"); 　　i++; 　} 　while (flag) 　　puts(eval(read(sizeof(stations)/sizeof(stations[0])), &flag, stations, sizeof(stations)/sizeof(stations[0]), messages, sizeof(messages)/sizeof(messages[0]))); 　return 0; } int read(size_t n) { 　static int mode; 　int i; 　static char buffer[BUF_SIZE]; 　fgets(buffer, BUF_SIZE, stdin); 　i = atoi(buffer); 　switch (mode) { 　case 0: 　　if (i > 0 && i <= n) { 　　　mode++; 　　　return i; 　　} else 　　　break; 　case 1: 　　if (i == LEAVE || i == GO) 　　　return i; 　　else 　　　break; 　} 　return read(n); } char* eval(int arg, int* f, station s[], size_t m, char** msg, size_t n) { 　static char str[BUF_SIZE] = {'\0'}; 　char str0[BUF_SIZE], str1[BUF_SIZE]; 　static int mode; 　static char* next_station; 　int i, k; 　switch (mode) { 　case 0: 　　mode++; 　　next_station = s[arg-1].next; 　　sprintf(str0, msg[2], s[arg-1].name); 　　if (strcmp(next_station, "None") == 0) { 　　　*f = 0; 　　　sprintf(str, "%s%s", str0, msg[n-1]); 　　　break; 　　} 　　sprintf(str1, msg[3], s[arg-1].name, LEAVE, next_station, GO); 　　sprintf(str, "%s%s", str0, str1); 　　break; 　case 1: 　　for (i = 0; i < m; i++) { 　　　if (strcmp(next_station, s[i].name) == 0) { 　　　　next_station = s[i].next; 　　　　k = i; 　　　} 　　} 　　sprintf(str0, msg[2], s[k].name); 　　if (arg == LEAVE) { 　　　*f = 0; 　　　sprintf(str, "%s", msg[n-1]); 　　} else if (strcmp(next_station, "None") == 0) { 　　　*f = 0; 　　　sprintf(str, "%s%s", str0, msg[n-1]); 　　　break; 　　} else { 　　　sprintf(str1, msg[3], s[k].name, LEAVE, next_station, GO); 　　　sprintf(str, "%s%s", str0, str1); 　　　break; 　　} 　} 　return str; }
35行目 digitalWrite(10, HIGH); <- セミコロンを付け忘れてる 38行目 digitalWrite(A0, HIGH); <- セミコロンを付け忘れてる 二箇所もセミコロンつけ忘れてる為、コンパイラが 「}を忘れてませんか?」 とちょっとトンマな警告を発しています。 ちょっと落ち着きましょう(笑)。
コンパイラは、 file.ino: In function`void setup()`; file.ino:2:28: error: lvalue required as increment operand 関数 setup() のどこかに問題があり 2行目にエラーがあり、それはインクリメント・オペランド(C言語の++に該当)は lvalue (変数)が要求されると言っています。 よって、2行目の式を見ると、 void setup() { 　for (int i = 1; i <= 8; 1++) { ← 1++ は i++ ですね。 　pinMode(i, OUTPUT); }
#include <stdio.h> #include <stdlib.h> #include <string.h> int main(void) { int city=99; char str0[64]="\0"; char str1[]="日本"; char str2[]="アメリカ"; char str3[]="イギリス"; char str4[]="フランス"; char str5[]="中国"; printf(" 国名を入力してください : "); scanf("%s",str0); if(strcmp(str0, str1)==0){ city=0; }else if(strcmp(str0, str2)==0){ city=1; }else if(strcmp(str0, str3)==0){ city=2; }else if(strcmp(str0, str4)==0){ city=3; }else if(strcmp(str0, str5)==0){ city=4; }else{ printf("一致する国がありません\n"); } switch(city) { case 0:printf(" 東京\n 大阪\n");break; case 1:printf(" ニューヨーク\n ロサンゼルス\n");break; case 2:printf(" ロンドン\n マンチェスター\n");break; case 3:printf(" パリ\n マルセイユ\n");break; case 4:printf(" 北京\n 香港\n");break; default:break; } return 0; }
指定したindexが範囲外の場合や、指定した文字数が範囲外に及ぶ場合はどうするの? って聞かれてますけど？ http://detail.chiebukuro.yahoo.co.jp/qa/question … ID非公開も活用して頑張りましょう。 http://detail.chiebukuro.yahoo.co.jp/qa/question …
>このような短いプログラムでできますか？ 出来ると思いますよ、ワンライナーといって、1行でかなりの処理をするプログラムを書く人もいます。 まあ、こんな質問がポコポコ投稿されるのも、コンパイル可能な全ソースコードを提供するからだとも思いますがねぇ。
穴埋めじゃなくて、自分で作るのはできますか? int 「　」,i,j ; 変数の宣言です。プログラム中で、宣言せずに使っている変数があるので、その宣言をしましょう 「　」=0 /* 〜 丁寧にコメントがあるので、それに合うような内容にしましょう
c++である必然性が見えないので、敢えて「使っている言語はc++です。」に真っ向対立しますが 以下のコードをメモ帳に張って保存し、拡張子をvbsに変更してダブルクリックすれば さわりの部分は動きます。 ただ、完成させようとすると、全ルートを網羅すべく大変なコード量になるので No.2さんのおっしゃる様に2次元配列を用いる事になるでしょう。 尚、「NO」ルートが2つある事に関しては感知しない事にします。 （実はこれが質問の核心などと仰るのはご勘弁下さい） If MsgBox("興味や嗜好品など特定分野の知識には結構自信自身がある",vbYesNo)=vbYes Then If MsgBox("飲み会に誘われると断れない方だ",vbYesNo)=vbYes Then 'どんどん書いていく Else 'どんどん書いていく End If Else If MsgBox("もっともっと稼ぎたい！",vbYesNo)=vbYes Then 'どんどん書いていく Else 'どんどん書いていく End If End If
処理系の使う文字コードも処理系依存なので char b[] = {'A','B','C','\0'}; と char c[] = {0x41,0x42,0x43,0}; が同じとも限らんのだけどね＞#2. ちなみに C の場合困ったことに char *s; s = 'A'; がエラーにならない (ポインタに int 型の値を入れることができてしまう).
スペースコードの一部を漢字のスペースにしてあります。 コピペするときは気を付けてください。 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <ctype.h> #define LENGTH 150 static void read_file (FILE * fp, char * str, int size); static void replace_str (char * str, char target); int main (int argc, char * argv[]) { 　FILE * fp; 　char buff[4]; 　char str[LENGTH]; 　if ((fp = fopen ("She.txt", "rb")) == NULL) 　{ 　　printf ("ファイルがオープンできません\n"); 　　exit (1); 　} 　read_file (fp, str, sizeof (str)); 　printf ("変換対象文字 --> "); 　if (fgets (buff, sizeof (buff), stdin) == NULL) 　{ 　　printf ("入力エラーです\n"); 　　exit (1); 　} 　if (! isalpha(buff[0])) 　{ 　　printf ("アルファベットを入力してください\n"); 　　exit (1); 　} 　replace_str (str, buff[0]); 　printf ("%s\n", str); 　exit (0); } static void read_file (FILE * fp, char * str, int size) { 　int i; 　int c; 　for (i = 0; i < (size - 1) && (c = fgetc (fp)) != EOF; i++) 　　*(str + i) = c; 　*(str + i) = '\0'; 　return; } static void replace_str (char * str, char target) { 　char c; 　int i; 　for (i = 0; (c = *(str + i)) != '\0'; i++) 　{ 　　if (c == target) 　　　*(str + i) = '*'; 　} 　return; }
>Excelを起動しているときに起こりやすいとかで そういう都市伝説は信じないように。 APIの中にはカレントワーキングディレクトリを変更するものも あるので、相対ではなく絶対パスを使うべき。 実行ファイルのパス(Application.ExecutablePath)とかから生成するのが良いです。
(1) と (2) がまったく正反対であることに気づけば簡単.
あ, kLow って一番上にあったんだ. ということは「どこが間違えているのでしょうか？」の答えは kLow を使っているのが間違い だな.
null pointer と「アドレス0x00000000」とは区別しましょうよぉ＞#1. もちろん「"jobnum==1||jobnum==2||jobnum==3" という文字列リテラル」が null pointer になることはありえないんだけど....
ん? 「出発駅を最も遅く出発して，目的駅に到着時刻までに到着する行き方を求めるプログラム」が作れるんだったら 「出発駅を最も遅く出発して，目的駅に到着時刻までに到着する行き方を求めるプログラム」も作れますよねぇ.... 同じものなんだし.
以下のようにしてください。 ------------------------------------ #include <stdio.h> main () { int i,var; char *data[]={ "□□○○○□□", "□○○○○○□", "○○○○○○○", "○○○○○○○", "○○○○○○○", "□○○○○○□", "□□○○○□□",}; printf("7を入力してください。=>"); scanf("%d",&var); if (var != 7) return 0; for (i = 0;i < 7; i++){ printf("%s\n",data[i]); } } -------------------------------------------------- 以下、実行結果です。 7を入力してください。=>7 □□○○○□□ □○○○○○□ ○○○○○○○ ○○○○○○○ ○○○○○○○ □○○○○○□ □□○○○□□ ----------------------------------- □は判りやすくするために、表示しています。 □は全角の空白に置き換えてください。 又、No2のかたが指摘された、 __○○○○○ _○○○○○○○ _○○○○○○○ _○○○○○○○ _○○○○○○○ _○○○○○○○ __○○○○○ のケースを実現する場合は、data[]の中の文字列の定義部分を そのように置き換えてください。
これは多分、実行環境やCPUのビット数で変わるかもしれませんねぇ。 各型の「最大値」を調べて、適切な型を選んでみて下さい。 #include <stdio.h> #include <float.h> int main(void) { 　printf("float の最大値 : %f\n", FLT_MAX); 　printf("double の最大値 : %f\n", DBL_MAX); 　printf("long double の最大値 : %Lf\n", LDBL_MAX); 　return 0; }
こんなカンジになるかしら。 まあ予測精度は知りませんが(笑)。 // ここから #include <stdio.h> #include <stdlib.h> #include <stddef.h> #include <time.h> #define LEN 30000 /* 取り敢えず乱数列は長さ30000とする */ #define SPOTS 7 /* サイコロの面の数(実際は1引いて6) */ int* sequence_gen(void); /* ダミー関数 */ void make_table(int data[], int table[][SPOTS][SPOTS]); void read(int arg[], size_t n); int eval(int data[][SPOTS][SPOTS], int arg[]); int main(void) { 　int table[SPOTS][SPOTS][SPOTS] = { { { 0 } } }; /* サイコロの出目を記録する三次元配列 */ 　int* seq; 　int input[2]; 　srand((unsigned) time(NULL)); /* 乱数の初期化 */ 　seq = sequence_gen(); /* ダミー関数。ここを置き換える。 */ 　make_table(seq, table); /* 結果のデータテーブル */ 　read(input, sizeof(input)/sizeof(input[0])); 　printf("次の値の予想値は %d です。\n", eval(table, input)); 　return 0; } /* ダミー関数 sequence_gen */ /* 「ランダムな数字の配列と書きましたが厳密にはランダムに見える不順な数列です。」 */ /* との事なんで、この関数を置き換えて下さい */ int* sequence_gen(void) { 　static int seq[LEN]; 　int i; 　for (i = 0; i < LEN; i++) 　　seq[i] = rand() % 6 + 1; 　return seq; } /* 三次元配列にデータを記録します */ void make_table(int data[], int table[][SPOTS][SPOTS]) { 　int i; 　for (i = 2; i < LEN; i++) 　　table[data[i-2]][data[i-1]][data[i]] += 1; } void read(int arg[], size_t n) { 　int i; 　for (i = 0; i < n; i++) { 　　printf("1から6までのどれかの値を入力してください : "); 　　scanf("%d", &arg[i]); 　} } /* 過去の二回の入力より、結果予測を過去のデータから最大値として探し、出目を返します */ int eval(int data[][SPOTS][SPOTS], int arg[]) { 　int* array = data[arg[0]][arg[1]]; 　int index_max = 0; 　int i; 　for (i = 1; i < SPOTS; i++) { 　　if (array[index_max] < array[i]) 　　　index_max = i; 　} 　return index_max; } // ここまで まず、上のコードは、取り敢えず 「ランダムな数字の配列と書きましたが厳密にはランダムに見える不順な数列です。」 との事だったんですが、そのコード自体は知らないんで、取り敢えず、暫定的にC言語の乱数列を使ってコーディングしています。 stdlib.hとtime.hは乱数と乱数の初期化の為に導入してるんですが、その「ランダムに見える」数列の作成方法があるのなら、それらは要らないです。 データ自体が手元にあるのなら、まるっと全部そのへんは置き換えて下さい。 基本的な「確率過程」としての考え方としては、先ほど書いた通り、元々、3つの確率変数A、B、Cがある場合、 P(A, B, C) = P(A)*P(B|A)*P(C|A, B) って計算を施して、「最大の確率を返せ」と言う問題になります。 ただ、データベースにカウントしてる場合、わざわざ「確率計算」をしなくて良い。 単純に、最大値としてのデータが入ってる場所の「インデックス」を返せば良い、って事ですよね。 また、フツーはマルコフ連鎖で考えて(その方が問題を単純化出来るので) P(A)*P(B|A)*P(C|A, B) => P(A) * P(B|A) * P(C|B) として「前項だけが影響を持つ」と言う仮定を施すんですが、さっきの話を聞く限り、「前二項」両者とも影響があり、なおかつ順序が重要なカンジなんで、その考え方にしています。 ※ つまり、通常・・・それが「現実に対応するかどうか」はさておき、あくまで計算が単純になる、と言う理由で、例えばさっきの例だと2 -> 5と言う「流れ」と5 -> 2と言う「流れ」は全く同じだ、と考えるのを「好み」ます。 統計は実は「現実をキチンと反映してる」のではなくって、割に、計算単純化の為の「仮定」をポンポン入れて計算する傾向がある、ってのを「押さえておいて」下さい。 「何が仮定なのか」と言うのを忘れると、実は相当マズい分野なのです。 さて、そうすると、コーディングのポイントは何と言っても「配列の扱い」になりますね。 例えば、「乱数列に見える」数列、があるとします。初項から次のような配列があるとしましょう。 3、1、4、1、5、9、2、6、5、3、5、8、9、7、9、3...... さっきの話から言うと、スタートは3番目(Cでのコーディング上は二番目)である4からループをスタートさせるわけです。 3->1->4 当然前二項は3と1です。そしてこの3つの数字の出現をデータに記録しないといけません。 そこで「3次元配列」を用います。 int table[i][j][k]; /* 各要素は0で初期化されてる前提 */ つまり、3次元配列のi行j列のk番目にデータを格納していく、って考え方ですよね。データを格納する、っつーかカウントしていく、って事ですか。 上の例だと3行目1列の4番目に+1する。 次に取り出すデータは 1->4->1 になるんで、1行目4列の1番目のカウンターを1増やす・・・以降与えられた乱数(に見える)列の最後まで延々とこの作業を繰り返します。 こうやってデータテーブルを作成しておいて、あとは入力で、 2->7 とやってきたら、まずは 2行7列目 の配列を取り出します。 コードで言うとeval関数の int* array = data[arg[0]][arg[1]]; って部分がそれですね。 仮にその配列が { 0 : 無視, 1 : 150, 2 : 129, 3 : 128, 4 : 149, 5 : 136, 6 : 138 } と言う状態だったら、1番目(つまりサイコロで言うと1の目)が最頻出の出目(この例だと150回出てて最多)なんで、1番目、と言う配列のインデックスを返せば題意を満たす、って事になります。
echoコマンドではなく、普通にfopen()/fprintf()/fclose()でもいいような気もしますが…。 まぁ、ソレはソレとして…… >　sprintf(buff1,"echo set smtp=smtps://%s:%s > /home/.mailrc",server,port); >system(buff1); >を実行すると上書きされます。 「リダイレクト 追記」辺りで検索してみるといいでしょう。
無名クラスならそうなります。 クラス名が付いているなら直後である必要は有りません。
ポインタ変数 - その変数の値は、その名の通りポインタ(=アドレス)を示しています。 示していると書きましたが、変数そのものは単に値を格納する器なので、アドレスを代入すればポインタ変数として機能するとも言えます。逆に、普通の変数としても使えます。(普通しませんが) C言語の仕様で変数に * を付けると「その変数が示すアドレスの内容」という意味です。 よって、一般的に、 ポインタ変数に * を付けないと、その変数の値(=アドレス)、 ポインタ変数に * を付ける　と、その変数(の値)が示すアドレスのメモリから値を取得するという意味になります。
ODEってやつのことを良く知らないのですが、やってることは、 ・各関節に「目標画時系列」とかいうパラメータがある ・全ての関節についてそれを並べる（これをGAの世界ではコーディングといいます） ・コーディングされた遺伝子を使ってGAによる世代交代をする ・各遺伝子をデコードしてODEのパラメータを作り、ODEを利用して評価を行う ・評価関数は「単位時間当たりの移動距離」 じゃないかと思います。 1関節の情報をどのように遺伝子として表現しているかわかりませんが、 単純に多値のパラメータを羅列しているだけ（下手に値を二進数化したりしていない）だと思います。 突然変異は、えらばれた座のパラメータの値域の中からランダムに変化するだけだと思います。 きっとODEを使って評価するには、なんかAPIみたいなのがあって、それを利用できるんだと思います。 動画のような問題ですと、遺伝子長が10とかそれぐらいの非常に簡単な問題だと思います。 この問題は、きっと腕や足に当たる部分を近い座に配置してコーディングしていると思うので、 例えばいい動きをする右足といい動きをする左足のパラメータを持った遺伝子を掛け合わせることで、 劇的によく歩ける遺伝子が作られやすいんだと思います。 ある意味、GAのデモにうってつけの問題ですね。 なので、評価部分にODEを使う、突然変異のやり方を工夫する、 遺伝子のデータ構造をODEに合わせたものにする、 だけで、基本的には古典的なGAのプログラミングで簡単にできそうな気がします。
C系の言語だと、配列の要素の範囲をインデックスで 表すのに mからnまで(m≦n)は、mとn+1で表わすことが多い。 例 0から9→0と10 これはインデックスの指す要素と、そのひとつ前の要素 の間に仕切り(壁)があると考えて、2個の仕切りで範囲を 表わすというやり方。C言語では言語仕様の中にこの考え方を サポートする部分があります。 アイビームカーソルの位置などもこの考え方を使ってます。 Javaで文字の選択範囲を表わす方法もこれです。 この考え方でループ回すとき k=n+1 とすると for(i=m; i < k; i++) { } とするのがCの伝統ですね。 別の考え方で範囲を示しても良いですが 出来ればこれに従った方が無難。 でないと読む方が少し苦労します。
別にstddef.hは付けなくて構いませんよ。 ただ、C99以降だとstddef.hを入れた方が「望ましい」だろう、ってんで書いただけです。 (多分stdio.hを呼んだだけで通常はstddef.hがリンクされる「可能性が高い」でしょう)
#include <stdio.h> #include <stddef.h> void calc_average(int class[][2], size_t n); int main(void) { 　int class[4][2] = {{0, 0}}; 　calc_average(class, sizeof(class)/sizeof(class[0])); 　return 0; } void calc_average(int class[][2], size_t n) { 　int i, j, k; 　printf("クラス(1〜3) --> "); 　scanf("%d", &i); 　if (i <= 0) { 　　for (j = 1; j < n; j++) 　　　printf("クラス %d の平均点 : %f\n", j, ((double)class[j][1])/class[j][0]); 　} else if (i > 0 && i < 4) { 　　printf("点数 --> "); 　　scanf("%d", &k); 　　class[i][0] += 1; 　　class[i][1] += k; 　　return calc_average(class, n); 　} else 　　return calc_average(class, n); }
FontFamily.GetCellAscent で検索してみて下さい。
昔からの日本の銀行システムはFortranだったはず。 不正な書き換えも毎日メンテナンスしているわけじゃないので解らなかったのでしょう。
No1の補足(お礼？)で意味が分かりました。 backtickが影響してたんですねー 一番手っ取り早いのはUnicodeでソース保存してビルドしてみてください。 たぶんソース中に¥とか入れて保存しようとすると言われるはず・・ http://www.unicode.org/charts/PDF/U0000.pdf このユニコード表の2ページ目頭くらいに書いてます。0x0060ですね Unicodeとマルチバイト共存さすなら詳しい説明は http://vllv.us/Junk/_T/ ここに結構書かれてるのでそちらを参照してください。
風呂丸 for Windows: C/C++言語のソースからフローチャート自動作成: http://www.vector.co.jp/soft/dl/win95/prog/se326 …
いくつか方法はありますが、独自クラスと各比較メソッドを作るのが分かりやすいかと思います。 独自クラス public class Person { public int Id; public string Name; public int Tel; public int Age; //ID比較 public static int CompareByID(Person p1, Person p2) { return p1.Id.CompareTo(p2.Id); } //名前比較 public static int CompareByName(Person p1, Person p2) { return p1.Name.CompareTo(p2.Name); } //電話番号比較 public static int CompareByTel(Person p1, Person p2) { return p1.Tel.CompareTo(p2.Tel); } //年齢比較 public static int CompareByAge(Person p1, Person p2) { return p1.Age.CompareTo(p2.Age); } } 使い方 //リストを作る List<Person> personList = new List<Person>(); ~~~~ 4人分のデータを入力 ~~~~ //Sortメソッドに比較メソッドを渡すとpersonListがソートされる personList.Sort(Person.CompareByAge);
>なぜかこうなるんです ブラウザがIE8で古くそれが原因では？
スマホとかなら次のサイトとか出来るかもしれませんがね。 https://repl.it/languages/c まあ、でもプログラミングやるならPCでやった方が良いでしょ。
いちおうかくにん. 「Vectorを使うと」ということは, 逆に言うと「使わない場合にはエラーは出ない」んですね? あと, これも念のためですが完全なエラーメッセージを書いてください.
あと、なるたけ多くのパターンを練習しましょう。 別にプログラミングで間違ったから、と言ってコンピュータは爆発しません(しない筈です・笑)。 簡単な問題をやる範疇で、思いつく限りの「ヘンな」事を試してみるんです。 別に誰に怒られるわけでもないんで、趣味に走ってオッケーです。 例えば、この問題で、僕が「趣味全開で」書いたら次のようになりますね。 // ここから #include <stdio.h> #include <stddef.h> void for_each(double (*proc)(double), double *list, size_t len); double fold(double (*kons)(double, double), double knil, const double *clist, size_t len); double input(double); double add_double(double x, double y); #define LEN 10 int main(void) { 　double array[LEN]; 　size_t len = sizeof(array)/sizeof(array[0]); 　for_each((double (*)(double))input, array, len); 　printf("入力値の平均は%.2f\n", fold((double (*)(double, double))add_double, 0.0, array, len)/len); 　return 0; } void for_each(double (*proc)(double), double *list, size_t len) { 　unsigned int count; 　for (count = 0; count < len; count++) 　　list[count] = proc(list[count]); } double fold(double (*kons)(double, double), double knil, const double *clist, size_t len) { 　unsigned int count; 　for (count = 0; count < len; count++) 　　knil = kons(knil, clist[count]); 　return knil; } double input(double arg) { 　scanf("%lf", &arg); 　return arg; } double add_double(double x, double y) { 　return x + y; } // ここまで このコードの解説は特にしませんが、動かしてみれば同じ動作になる、って事に気づくんじゃないでしょうか。 C言語が得意な人は 「なんて無駄な事を」 とか思うでしょうが、まあそれでイイんです(笑)。 思った通り動作した時、 俺SUGEEEEEEEwwwwww とかなれば、自信に繋がるでしょう。 とにかく「同じ問題」に付いて色々試してみて下さい。
ソースは無理なので、流れだけです。 > パラメータ数2.探索範囲マイナス2から2です 探索範囲を0.001刻みで探索すると仮定します。 範囲を2のn乗で収まりが良いように-2.048≦x<2.047とするとちょうど4096分割できて12bitの2進数で表すことができます。パラメータが2個なので全部で24bitになります。このパラメータの2進表現を1個体の遺伝子表現にします。 int gene[24]; 　　　gene[0]～cur_gene[n][11]が個体のパラメータ1の遺伝子 　　　gene[12]～cur_gene[n][23]が個体のパラメータ2の遺伝子 パラメータxから遺伝子表現への変換： 　　xb = (x*1000)+2048として、xbの各bitの0/1情報を取得していく。 パラメータxから遺伝子表現への変換： 　　上記変換の逆を行う。 各個体は2個のパラメータを持っているので以下の様な構造体定義になります。 struct Life { 　　double x1; 　　double x2 }; 全個体数をMとすると上記構造体の配列を要素数Mで、現世代curと次世代nextを宣言する。 　　struct Life cur[M]; 　　struct Life next[M]; あとは上記のデータでGAの手順に従って計算していきます。 1. 現世代cur[M]の全個体Mの初期パラメータを乱数で決定する。 2. Rosen Brock関数で各個体の適応値を計算する。 　 このとき適応値の高い順にソートする。 3. 次世代の個体の作成 　 以下の方法を適当な割合で適用して、M個の個体を作成する 3-1. 淘汰 　　　2.で適応値の高いものを次世代にコピーする。 3-2. 交差（2点交差） 　　　現世代から2個体を乱数選択する。 　　　0≦i<j≦23の範囲でi,jを乱数選択 　　　個体1のgene[i]～gene[j]を個体2の同じ位置に上書きしたものを次世代新個体とする。 3-3. 突然変異 　　　現世代から1個体を乱数選択する。 　　　0≦i≦23の範囲でiを乱数選択 　　　gene[i]のbit反転を行ったものを次世代新個体とする。 4. 3.で作成した新世代next[M]を現世代cur[M]にコピーする。 5. 2.に戻る。 上記を適当な回数（世代）計算を行います。
サイト? いや、サイトじゃなくってEmacsってテキストエディタです。 Emacs: https://www.gnu.org/software/emacs/ UNIX/Linuxだと有名なテキストエディタですね。 Windowsじゃあんま有名じゃないですが、一応Windows版もあります。 NTEmacs: http://cha.la.coocan.jp/doc/NTEmacs.html 画面上部がCのプログラムを編集する部分(バッファとか呼びますが)、下がWindowsで言うDOS窓(コマンドプロンプト)で、eshellと言う端末プログラム(ターミナル等と言いますが)を走らせて、上で書かれたソースコードをコンパイル->実行->入力->結果表示、とやってます。
やり方はコンパイラ次第。ドキュメントを読みましょう。 インクルードディレクトリはまだ序の口です。
#1さんに加えて。 ぶっちゃけ「約数を表示しろ」ってだけならハナクソ以下の問題で、こんなの小学生でも出来ます。 いや、「小学生でも出来る」ってのは「プログラミングが出来る」って言ってるんじゃなくって、アルゴリズムと言うより、この内容は「単なる算数だ」って事です。 これが「約数を手渡せ」なら途端に難易度が上がりますけどね(笑)。 つまり、プログラムの仕様としても、この問題は2個ばかし不明な点があります。 1. int yakusuu(int n)の挙動がハッキリと分からない。 これは2〜ｎの数それぞれに付いて約数を全部表示しろ、って言ってるんですかね? 例えば n = 4を入力したとして、 結果が２の約数　２ 　　　３の約数　３ 　　　４の約数　２　４ と2〜4までのそれぞれに付いて(1以外の)約数を表示しろ、って言ってるのか、あるいは 　　　４の約数　２　４ だけ表示すれば良いのか、が不明です。 2. int yakusuu(int n)は一体何を返すのか?がハッキリと分からない。 この関数は整数型intを返してくれ、って要求してるんですが、一方、 「と表示されるようなプログラム」 と書いてるんで、表示なんかの副作用を求めてるように思えます。 だとしたら、返り値は一体何にして欲しいんでしょうか。そのへんが良く分かりません。 単純に0を返すのか、1を返すのか、あるいは入力されたnを返すべきなのか・・・。 とまぁ、「要求仕様が良く分からない」ですねぇ。
dsってなにものです？ Tables[0]ってなに？？ https://msdn.microsoft.com/ja-jp/library/det4aw50(v=vs.80).aspx 戻り値はDataRow[]です。 DataRowがソートされて配列として返されます。 # なので、元のDataTableは変化しません。 DataTable.Rows[0]、DataTable.Rows[1]…だとソートされていませんが、 戻り値の[0]、[1]…だとソートされた状態になっています。
>しかし、保存することはできませんでした。 関数仕様はちゃんし確認しないとダメですな……。 http://opencv.jp/opencv-1.0.0/document/opencvref … http://bicycle.life.coocan.jp/takamints/index.ph … というわけで、タイムアウト(キー未入力)はkey == -1で判定する必要があります。 >aを押しながらcを押すと撮影開始となるように変更するには >どのようにしたらよいのでしょうか？ 複数のキー押下を検出できない…んじゃないですかね。 SHIFTキーやCtrlキー、Altキーとの複合の場合に検出できるのかは…どうなんだろう？ 「cvWaitKey Ctrl」とかで検索するとなにか見つかりますかねぇ。
https://blogs.msdn.microsoft.com/shintak/2015/02 … によると…… > XAML + C# / VB / C++ > HTML5 + JavaScript / WinJS > Direct X + C++ MFC の組み合わせのどれか…なんでしょうかね。 >右クリックでアイテムの2～3個追加 ということはMFCまんでしょうか。 # SDKだと自前でコンボボックスのアイテムを追加しないとダメだったかと。 # WindowsPhoneでSDKでやれるのかは不明ですが。 ひな形とか作られているならそっちからなんとかできませんかねぇ…。
関数を使わないと何もできない.
> #include <stdlib.h> > #include <time.h>は 必ず必要ですか？ stdlib.hがないと、組み込みのrand()と言う「乱数」が使えません。 もちろん、自分で乱数のプログラムを書きます、と言うのなら話は別ですが・・・。 time.hは必ず必要ではないけど、ただし、実用的な意味では必要でしょう。 これは上のstdlib.hに含まれる乱数の初期値を初期化する為に使われます。 基本的にコンピュータ上の乱数は「疑似乱数」と言って本物の乱数ではありません。 つまり「数の出方に」実は法則性があって、何度も乱数を使った同じプログラムを呼び出すとそれがバレちまう(笑)。 そこでtime.hは「現在時刻を取得したりする」関数が含まれてるんで、そいつを乱数の初期値にセットすれば、原理的には「二度と同じ乱数列が得られない」と言う特典があるんです。 そのため、stdlib.hのrand()を使う際、良く組み合わされるのがtime.hになるのです。
forを使うのは当然ですね。 まあ、データ列がどういう状況になってるか知らないですが方針は基本的に次の通り。 1. forを回して得点の平均点を得る。 2. もう一丁forを回して(得点-平均点)の絶対値が一番小さいヤツをピックアップする。 forを回すか回さないか以前に、 「アナタが実際にそれを手作業で行う時どうするのか」 と言うのがそのまま答えになります。
C++ 2008 は SP無 SP1 どちらでしょうか？ ☆SP無 https://www.microsoft.com/ja-jp/download/details … ☆SP1 https://www.microsoft.com/ja-jp/download/details … のランタイムをインストールしてみましたか？
じゃあ、僕も練習がてらに(笑)。 特に言語指定も無いみたいなんで、Cello Cello: http://libcello.org/home ってC言語用のライブラリを使ってみます。 WindowsだとVisual C++では使えないんですかね。MinGW上でgcc使ってくれ、みたいな事書いてますが、まあいいでしょう。 参考: Celloのインストール方法 http://libcello.org/learn/installation // ここから #include <Cello.h> #include <time.h> var max(int x, int y, int z); var mid(int x, int y, int z); double a(int n, double a1); int main(int argc, char** argv) { 　int x, y, z, n; 　srand((unsigned)time(NULL)); 　x = rand()%100+1; 　y = rand()%100+1; 　z = rand()%100+1; 　n = rand()%6+1; 　print("x = %$\ny = %$\nz = %$\nn = %$\n", $I(x), $I(y), $I(z), $I(n)); 　print("最大値は %$\n", max(x, y, z)); 　print("2番目に大きい数は %$\n", mid(x, y, z)); 　printf("第%d項の数列a_nの値は%6.0f\n", n, a(n, 1.0)); 　return 0; } /* 実は max と mid の内容は殆ど同じ */ var max(int x, int y, int z) { 　var a = new(Array, Int, $I(x), $I(y), $I(z)); 　sort(a); 　return get(a, $I(2)); } var mid(int x, int y, int z) { 　var a = new(Array, Int, $I(x), $I(y), $I(z)); 　sort(a); 　return get(a, $I(1)); } /* これは n が大きいとバカデカい数を返すから気をつけて */ double a(int n, double a1) { 　if (n == 1) 　　return a1; 　else 　　return a(n-1, pow(a1, 2.0)+1); } // ここまで いやあ、ライブラリが優秀だとCで書いてもラクですね(笑)。 コメントにも書いてますが、実はmax関数もmid関数も中身は殆ど同じです。 引数x, y, zを受け取った時点でCelloのarray型 http://libcello.org/learn/array にツッコんでそしてそのままソート(並べ換え) http://libcello.org/learn/sort しちまいます。 このソートは昇順(小さい順から並べる)なんで、結果としてArrayのケツが最大値、当然3要素のArrayだと真ん中の値が「二番目に大きい」値なんで、これで終了、です(笑)。 いや、これはラクですね(笑)。すげぇ手抜きが出来ます(笑)。 数列の方は、言われたままにプログラムすれば上のコード(a関数)のようになります。こっちはCelloの力は特に借りてません。 ただ、こっちはnがデカくなると計算結果がバカみたいにデカくなるんで、ちとキツいですね。 まあ、そんなわけで、nは最大で6程度にとどめておきましょう。 (Common LispやScheme、あるいはPythonなんかだと結構デカい値は操れますが、Cでそれをやるのは甚だメンド臭そうです・笑)
うーん、多分・・・まあ、ぶっちゃけ、「棒倒し法」とか初めて聞いたんで(笑)、ググりながら組み立ててみたんですが、次のようなロジックになるんじゃないでしょうか。 // ここから #include <stdio.h> #include <stdlib.h> #include <time.h> enum Direction { RIGHT, DOWN, LEFT, UP }; /* 列挙体で方向を定義 */ enum Element { EMPTY, WALL }; /* 列挙体で壁(WALL)と空(EMPTY)を定義 */ #define MAX 13 /* 取り敢えず field の長さを指定する */ /* 関数のプロトタイプ宣言 */ void initialize_field(int array[][MAX]); void print_field(int array[][MAX]); int dice(int n); void make_maze(int array[][MAX]); void selector(int n, int i, int j, int array[][MAX]); int main(void) { 　int field[MAX][MAX]; 　srand((unsigned)time(NULL)); 　/* field の初期化 */ 　initialize_field(field); 　/* maze の作成 */ 　make_maze(field); 　/* field の表示 */ 　print_field(field); 　return 0; } /* field の初期化 */ void initialize_field(int array[][MAX]) { 　int i, j; 　for (i = 0; i < MAX; i++) { 　　for (j = 0; j < MAX; j++) { 　　　/* 最初の行と最後の行は全部 WALL で埋まる */ 　　　if (i == 0 || i == 12) 　　　　array[i][j] = WALL; 　　　/* 行数(i)・列数(j) 共に偶数の場合は WALL になる */ 　　　else if (i % 2 == 0) { 　　　　if (j % 2 == 0) 　　　　　array[i][j] = WALL; 　　　　else 　　　　　array[i][j] = EMPTY; 　　　} 　　　/* それ以外は行の最初と最後は WALL、それ以外は EMPTY で埋める */ 　　　else { 　　　　if (j == 0 || j == MAX-1) 　　　　　array[i][j] = WALL; 　　　　else 　　　　　array[i][j] = EMPTY; 　　　} 　　} 　} } /* field の表示 */ void print_field(int array[][MAX]) { 　int i, j; 　for (i = 0; i < MAX; i++) { 　　for (j = 0; j < MAX; j++) { 　　　switch (array[i][j]) { 　　　case WALL: 　　　　printf("%s", "■"); 　　　　break; 　　　default : 　　　　printf("%s", "□"); 　　　　break; 　　　} 　　} 　　printf("\n"); 　} } /* サイコロの定義 */ int dice(int n) { 　return rand()%n; } /* maze(迷路)作成 */ void make_maze(int array[][MAX]) { 　int i, j; /* 端以外は行・列共に偶数の時壁なので、ループを回す初期値は2、以降カウンタは2づつ増やす */ 　for (i = 2; i < MAX-1; i += 2) { 　　for (j = 2; j < MAX-1; j += 2) { 　　　if (i == 2) 　　　　selector(4, i, j, array); 　　　else { 　　　　if (array[i][j-1] == WALL) 　　　　　selector(2, i, j, array); 　　　　else 　　　　　selector(3, i, j, array); 　　　} 　　} 　} } /* 条件でn面体サイコロを変えて配列のどこを変更するか決める */ void selector(int n, int i, int j, int array[][MAX]) { 　switch(dice(n)) { 　case RIGHT: 　　array[i][j+1] = WALL; 　　break; 　case DOWN: 　　array[i+1][j] = WALL; 　　break; 　case LEFT: 　　array[i][j-1] = WALL; 　　break; 　default : 　　array[i-1][j] = WALL; 　　break; 　} } // ここまで まあ、ググりながら書いてみたんですが、どうもこう・・・ハッキリくっきり解説してるサイトが見つからなかったんですよね(笑)。 でも多分こういう事だと思います。 コメントでも書いてますが、要点は次のようなカンジです。 ★最重要:「棒倒し」のループの中では行数・列数のコンビは偶数でないとならない。 まあ、最初の行と最後の行は「全部壁」なんで除外しますが、基本的にはループは2から初めて偶数飛びにしていかないといけません。 イメージ的には棒の上を飛んでくカンジでしょうか。 だから、forループを回す際に、 for (i = 0, ... for(j = 0, ... だとダメなんです。 for (i = 2, ... for (j = 2, .... じゃないといけない。 かつ、手癖で、カウンタ更新を i++ とやっちゃうのも良くないですね。棒は必ず(偶数, 偶数)に存在するので、i += 2じゃないと「棒から落ちちゃい」ます。 そして「棒の上に立ってる」状態でサイコロを振って、その結果に従って棒を上下左右のどれかに「蹴り倒す」(つまり、多元配列の隣り合った4つの要素の「どれか」を「壁」として書き換える)わけです。 んで、棒倒し法の場合、大まかに言うと次のルールがあります。 1. 多元配列で言う2行目だけは乱数に従って上下左右どこへでも棒を蹴り倒して良い。 2. 2行目以外は棒を上に蹴ってはならない。棒は下と左右だけに蹴る事が出来るが、次の付随ルールがある。 　a. 左に棒が倒れてる場合は下と右にしか蹴れない 　b. 左に棒が倒れてなかったら下と左右どれかに蹴飛ばして構わない。 まあ、壁がどこに作れるのか、って言い換えても良いでしょうが、上のようなルールがあります。上のコードで言うと、make_mazeって関数はこのルールに従って書いています。 さて、上のコードの解説をちょっとだけしますが、ここで気づいたでしょうが、実は「棒を蹴る方向」ってのには優先度があるんですね。 1. 右と下は「いつでも」蹴られる可能性がある。 2. 左は蹴られる可能性があったり無かったりする。 3. 上はループが多元配列の2行目にいない限り蹴られる可能性は全く無い。 つまり、乱数生成でサイコロを作る場合「サイコロの面の数」さえ変えればこの状況は割に簡単に記述出来るんです。 つまり、 ・上下左右どこに蹴っても良い(多元配列二行目)のケース -> rand()%4を適用すれば良い ・下と左右どこに蹴っても良いケース -> rand()%3を適用すれば良い ・下と右どっちに蹴っても良いケース->rand()%2を適用すれば良い rand()%nは0, 1, 2...(n-1)のどれかを返すわけですから、そうなると確実に蹴られる可能性がある右と下には0や1の値を与えて、優先度に従って「適当な数」に「適当な方向」を与えてやれば良い、って事になるわけです。 そこで出てきたのが列挙体でのDirection定義なわけです。 enum Direction { RIGHT, DOWN, LEFT, UP }; これは実は int RIGHT = 0; int DOWN = 1; int LEFT = 2; int UP = 3; って宣言と同じなんですが、まあ、メンド臭いので(笑)、こういうカタチで定義してます。 RIGHTとDOWNに関してはどっちも「必ず蹴られる可能性がある」んで0と1、どっちにしてもいいんですが、LEFTは「やや弱い蹴られる可能性」がある、UPは「殆ど蹴られる可能性が」無い、ってぇんでこういう数値割り振りをしてます(つまり、置いた順序には意味があるのです)。 こうしておけば、例えば多元配列の2行目だった場合 rand()%4 -> 0, 1, 2, 3のどれか -> RIGHT, DOWN, LEFT, UPのどれかが選ばれる わけですし、二行目以外で、特定の(偶数, 偶数)座標の左に「棒が蹴倒されてた場合」(つまり壁があった場合)、 rand()%2 -> 0, 1のどっちか -> RIGHTかDOWNが選ばれる と自動的に決まるわけです。
https://msdn.microsoft.com/ja-jp/library/ms131565 の >uriString に指定されたポート番号が無効であるか、解析できません。 といわれている…みたいですな。 http://o-maguro.hatenablog.com/entry/2015/10/10/ … こんなページも見つけましたが…。 WPF触ったことないので後は不明。 とりあえず、変更前の状態でgazouがnullかどうか位は判定できるんじゃないですかね？
#include <stdio.h> #include <stdlib.h> #include <time.h> #include <windows.h> int main(void) { int dice=0, shake=100; int array[6]={0}; srand((unsigned)time(NULL)); for(int i=1; i<=shake; ++i){ dice=rand()%6+1; switch(dice){ case 1:array[0]+=1;break; case 2:array[1]+=1;break; case 3:array[2]+=1;break; case 4:array[3]+=1;break; case 5:array[4]+=1;break; case 6:array[5]+=1;break; default:break; } } system("cls"); printf("\n サイコロを%d回振った場合の結果\n", shake); for(int j=0; j<6; ++j){ printf(" %dの目 : %2d\n", j+1, array[j]); } return 0; } ※少しだけ修正してます。 実行した結果は、画像のようになりますけど、違いますか？
型安全性のためです。 アドレス情報はポインタ変数で管理しなければいけない → アドレス情報が必要な箇所では、必然的にポインタ変数を使わなければいけない → 間違ってポインタ変数を使った場合、コンパイラーにより構文エラーと報告される(可能性が高くなる) → 実行するまでもなく間違いが見つかるので、ソフトウェアの安全性が高まる(かもしれない) C言語は性能重視のために「弱い型付け」の設計なので、完璧な安全性ではありません。 ですが、機械語のような型付けの無い言語にてアドレスと数値を取り違えて、 よく CPU を暴走させた経験をもつわが身としては、 弱くても型付けがあるのは、プログラムをする上でとてもありがたいことです。 参考 https://ja.wikipedia.org/wiki/%E5%9E%8B%E3%82%B7 …
こんな感じで如何でしょう？ 表示例： 6 4 5 1 3 2 0 0 0 0 root:6 　left:4 　　left:1 　　　left:Null 　　　right:Null 　　right:3 　　　left:Null 　　　right:Null 　right:5 　　left:2 　　　left:Null 　　　right:Null 　　right:Null ※1 未使用のheap[i]には0が入っていると仮定しています。 ------------------------- void PrintSPC(int n){ const char s[] = " "; // ここは半角スペース20個入れて下さい。 char *p; int i = 2*n; p = (char*)s; while(*p!='\0') p++; p -= i; printf("%s", p); } char *name[3] = {"root", "left", "right"}; void PrintHeap(int idx, int indent, int kind){ if(idx >= 11 || heap[idx] == 0){ // ※1 PrintSPC(indent); printf("%s:Null\n", name[kind]); return; } PrintSPC(indent); printf("%s:%d\n",name[kind], heap[idx]); PrintHeap(idx*2, indent+1, 1); PrintHeap(idx*2+1, indent+1, 2); } int main(void) { int i; PushHeap(1); PushHeap(2); PushHeap(3); PushHeap(4); PushHeap(5); PushHeap(6); for(i = 1; i < 11; i++) printf("%d ", heap[i]); printf("\n"); PrintHeap(1,0,0); return 0; }
コード上にあるのは >void main() なのですから、リンカーがWinMainを要求している時点でなにか間違っています。 # たぶん/SUBSYSTEM:CONSOLEでないとダメかと。 で、文字コードセットの影響もあるかと思われますので、「マルチバイト文字セットを使用する」にした方がいいかと。 「unicode文字セットを使用する」の場合はwmain()ですかね。 https://msdn.microsoft.com/ja-jp/library/6wd819wh(v=vs.120).aspx あとは…void main()ではなく上記のURLの通りint main()にする…とか。 # まぁ、現状のWinMain()要求ではダメなんですけど。
>対処方法はありますか そのビェーアでメタファイルの形式を厳密に指定 出来るなら、エンハンストを指定してみる。 クリップボードにエンハンストメタファイルを 登録するとWMFも自動生成されるので注意が 必要ということです。
よくわかりませんが↓のCtrl-Dではないですか？ http://www.ne.jp/asahi/hishidama/home/tech/unix/ …
void print_star(int n){ int i; for(i = 0; i < n; i++) printf("*"); // ここで使用 printf("\n"); } int main(void) { int n, i = 1; printf("整数（1以上）は？"); scanf("%d", &n); do{ print_star(i); i++; }while(i <= n); return 0; }
#include <stdio.h> void print_star(int n){ int i; for(i = 0; i < n; i++) printf("*"); printf("\n"); } int main(void) { int n, i = 1; printf("整数（1以上）は？"); scanf("%d", &n); do{ print_star(i); i++; }while(i <= n); return 0; }
MFCなんでしょうけど…… # って事でC言語ではなくC++言語ということになりますかねぇ…。 で……どう「うまくいかない」んですか？ とりあえず、手元のVS2015 Communityで試したところだと… >pWnd = FindWindow("AcrobatSDIWindow", str + " - Adobe Reader"); が常にNULLになりましたね。 というか…コールされたのがAPIのFindWindow()のような気もしますが。 # MFCアプリケーション、ダイアログベースで作成して適当にボタン配置して掲示されたコードを貼り付け。 # PDFファイルのファイル名をローカルドライブにある適当なPDFファイルをフルパス指定して、 # アクロバットリーダーが微妙にバージョン違いの為、その辺修正。 # 掲示された関数はダイアログクラスのメンバに変更。 pWnd = CWnd::FindWindow("AcrobatSDIWindow", str + " - Adobe Reader"); でpWndは非NULLになって動作しましたけど。
scanf("%d\n",&x);の"%d\n"から \n を取り去ってください。
#include <stdio.h> typedef struct kojin_tag { 　int sincho; 　int taijyu; } KOJIN; KOJIN yuujin[] = {{170, 85}, {165, 65}, {180, 78}}; int main(void) { 　int height, weight; 　int max = sizeof(yuujin)/sizeof(yuujin[0]); 　int i; 　printf("身長? "); 　scanf("%d", &height); 　while (i < max) { 　　if (height == yuujin[i].sincho) { 　　　weight = yuujin[i].taijyu; 　　　break; 　　} 　　i++; 　} 　printf("体重%d\n", weight); 　return 0; }
ちなみに. char *charray[MAX]; のすべての要素を NULL で初期化したいなら char *charray[MAX] = { NULL }; とするのが簡単.
#include <stdio.h> #include <stdlib.h> char array[][8] = { "偶数", "奇数" }; void choose(void); void loopfor(void); void loopwhile(void); void loopdowhile(void); void print(int i); int main(void) { 　choose(); 　return 0; } void choose(void) { 　int i = rand()%3 + 1; 　switch (i) { 　case 0: 　　loopfor(); 　　break; 　case 1: 　　loopwhile(); 　　break; 　default: 　　loopdowhile(); 　　break; 　} } void loopfor(void) { 　for(int i = 0; i < 6; i++) 　　print(i); } void loopwhile(void) { 　int i = 0; 　while (i < 6) { 　　print(i); 　　i++; 　} } void loopdowhile(void) { 　int i = 0; 　do { 　　print(i); 　} while (i++ < 5); } void print(int i) { 　printf("%dは%s\n", i, array[i%2]); }
101個以上のエラーなんぞレポートしてもムダ…かと思いますけど。 http://oshiete.goo.ne.jp/qa/7365880.html VS2010だったら？って質問。 書いてあるコードのエラーになる箇所がいくつあるのか知りたい。 『あんたのコードはこんなに酷いんだよ』と指摘する為にっ！！！！ とかいう目的なんだったら… 静的解析ツールでも使用してみてはどうですかね？ フリーで使えるものがあるかはちょっと疑問ですが。 PGReliefとかなかなか素敵に指摘してくれますよ？　高いけど。 http://yohshiy.blog.fc2.com/blog-entry-306.html
>printf("\n x1 = %.2f + %.2fi", r, i); >printf("\n x2 = %.2f - %.2fi\n\n", r, i); iが負だとおかしな表示になります。
論理座標(GDI関数に与える座標)をX,Y 物理座標(描画面左上が原点のピクセル座標)を x,y とすると x=(X - WindowOrgX)×ViewportExtentX÷WindowExtentX + ViewportOrgX y=(Y - WindowOrgY)×ViewportExtentY÷WindowExtentY + ViewportOrgY マッピングモードを MM_ANISOTROPIC にして上のパラメータを APIで設定すれば、自由自在ですよ。
本の書名も分からないので、一般論として、 1.既にTeXの環境が有れば、混在しているとトラブルのもとなので、削除 2.TeXインストーラ 3 　http://www.math.sci.hokudai.ac.jp/~abenori/soft/ … 　を使って、最新版の W32TeX をインストール 3.祝鳥 　http://www.math.sci.hokudai.ac.jp/~abenori/soft/ … 　等の秀丸マクロをインストール
(略) double sum0000=0.0; double sum0001=0.0; .. double sum1000=0.0; ファイル全部の繰り返し { 数値 x,yを読み込む; if (x<0.1) { sum0000+=y;} else if (x<0.2) { sum0001+=y;} ... else if (x<100.0) { sum0999+=y;} else { sum1000 +=y;} } // ループ終り (以下略) 何かの決まりが無ければ、こんなプログラムでも「正解」です。 で、これだといろいろ面倒なので、規則性を見つけて配列とかstd::vectorとかでまとめると楽になる、ということです。 ※ このベタ書きプログラムを出力するプログラムを作る、というのも手段の一つです。 for(i=1;i<1000;i++){ printf("else if (x < %d.%d) { sum%04d+=y;\n",(i+1) / 10, (i+1)%10,i); }
一番外側のループで回答しましたが、実際はiの値次第で外側のxのループがずっと続くか、外側のループが1回だけになるか…。 いずれにしろ期待動作はしません。 何よりiの値も不定ですし。 >・3、4つめのfor文ではモザイク化する箇所を参照し、8*8の平均輝度値を求めたいです。 外側の2つのループはステップを8に(サイズが256なら32回回ればいい)、 内側の2つのループで8x8の領域の精査を行うようにすればいいでしょう。 当たり前ですがカウントに使う変数は別にして。
#include <stdio.h> int main(void) { int i; char *c; printf("何月ですか? "); scanf("%d", &i); switch(i) { case 1: c = "睦月"; break; case 2: c = "如月"; break; case 3: c = "弥生"; break; case 4: c = "卯月"; break; case 5: c = "皐月"; break; case 6: c = "水無月"; break; case 7: c = "文月"; break; case 8: c = "葉月"; break; case 9: c = "長月"; break; case 10: c = "神無月"; break; case 11: c = "霜月"; break; case 12: c = "師走"; break; default: c = "無い"; break; } printf("%d月は%sです\n", i, c); return 0; }
#include <stdio.h> #include <math.h> typedef struct data_tag{ 　double height; 　double weight; } data; double BMI(data d); double StandardWeight(data d); data input(void); void output(double bmi, double stdweight, data d); int main(void) { 　data d; 　d = input(); 　output(BMI(d), StandardWeight(d), d); 　return 0; } double BMI(data d) { 　return d.weight / pow(d.height/100, 2); } double StandardWeight(data d) { 　return 22 * pow(d.height/100, 2); } data input(void){ 　data d; 　printf("あなたの身長は (cm) ?"); 　scanf("%lf", &d.height); 　printf("あなたの体重は (kg) ?"); 　scanf("%lf", &d.weight); 　return d; } void output(double bmi, double stdweight, data d) { 　char *p; 　if (bmi < 18.5) { 　　p = "やせぎみ"; 　} else if (bmi < 25) { 　　p = "標準"; 　} else if (bmi < 30) { 　　p = "肥満ぎみ"; 　} else { 　　p = "高度肥満"; 　} 　printf("あなたの身長は%5.1fcmです\n", d.height); 　printf("あなたの体重は%5.1fkgです\n", d.weight); 　printf("あなたのBMIは%4.1fです\n", bmi); 　printf("身長%5.1fの方の標準体重は%5.1fkgです\n", d.height, stdweight); 　printf("あなたのBMIの判定は%sです\n", p); }
>この２行で >型 'System.NullReferenceException' のハンドルされていない例外が お絵かきソフト 3.exe で発生しました >というエラーがでできました。 ステップ実行などで確認した…ということでしょうか？ とりあえずnullになりそうなのは…… >int penWidth = Int32.Parse(cmbWidth.SelectedItem.ToString()); cmbWidth.SelectedItemがnullになっているかもしれない。 https://msdn.microsoft.com/ja-jp/library/system. … >Graphics g = Graphics.FromImage(bitmap); bitmapがnullかも知れない。 bitmapはフィールド…ですか？ >フォームロードはこのようなかんじです。 bitmapはnull以外…になっています？(newでちゃんとオブジェクト作成されています？) https://msdn.microsoft.com/ja-jp/library/7we6s1x … 失敗はなさそう…ですな……。
まずは基礎から始めるとしてブロック崩しは作れるでしょうか？ ブロック崩しができたら残すはそのブロックを横へ移動させたりですね。 インベーダーゲームの元ネタはブロック崩しだったりします。 ＞ブロック崩しの作り方　目次 ＞http://akaguro.jp/breakout/breakout_index.shtml 　急がば回れです。
貴方のいくつか前の質問のNo.5で、3桁の場合を回答しました（見られていないようなので） No.1さんの最後のご指摘にも対応しています。 解読して4桁にしてみてください。 頑張って下さい。 ※宣言している変数がu1で、使用しているのがuser1ってどういうことですか？ 　貴方の態度にやる気が見えません。
なんか考え方を間違ってると思われます。そもそも構文エラーになるはず。。 一応、.Containsで変数like がListに含まれているかどうかは分かりますが それがListの何番目なのかは分かりません。 // Listのkudamonoの中からaという範囲変数を宣言、 // ※範囲変数a は変数like と一致すること。 // ※の条件を満たしたaを結果としてvarMatch に格納する var varMatch = from a in kudamono where( a == like ) select a; // varMatch からすべての要素を取り出す。取り出し先はstring型のansに入れる foreach (string ans in varMatch ) { Console.WriteLine(ans); } あとは、ringo以外にaoringo とかも含ませるならLike検索くらいでしょうか。 var varMatch2 = from a in kudamono.Where(item => item.Contains(like)) select a;
入門書は大体同じようなことが書かれているので一冊あれば十分です。 人によって合う合わないがあるので、 その2冊にこだわらず、自分が読みやすい本を探すのも良いでしょう。
まずは、マスターマインドの部分はおいといて int main() { 　do { 　　4つの異なる数字を入力する() ; 　　if (読み込み終了 ) { break ;} 　　読み込んだ4つの数字を出力() ; } while (1) } と、読み込むだけのプログラムを作ってみましょう。 「4つの異なる数字を入力する() ;」 には、ここに直接プログラムを書かずに、自作した関数を入れます。 プロトタイムは int input4Numbers(int *a1,int *a2,int *a3, int *a4) ; 戻り値は 正常時 0、 エラー(EOF等) 時 1 今回読み込むのは「数値」ではなく「4つの文字」でよいはずです。 ならば。エラー処理の面倒なscanfは止めて、fgetsで1行入力→1文字ずつ確認 で十分でしょう。 このように分割すると、他の影響をあまり考えずに、単純な機能(今回なら、4つの文字入力する)に集中できます。
char buff[80]; int user; while (1) { _ /* 一行分を読み取る */ _ printf("数値を入力しましょう:"); _ if (fgets(buff, 80, stdio) == NULL) { _ _ もう読み取れないので処理終了します処理(); _ _ return -1; _ } _ /* 読み取った一行分から数値を摘出 */ _ user = atoi(buff); _ if (user == 0) { _ _ 数字以外が入力されたときの処理(); _ _ continue; _ } _ 結果 = 入力した数値を処理(user); _ if (結果 == ゲームオーバーです) break; } return 0;
>他の回答者様より「fflush(stdin); は一般にはやっていけない操作」との回答をいただきました。 規格にstdinに対して実施した場合の動作が明記されていないから。 だったかと。 実装依存する。ということです。 >推測ですが、windowsで改行コードが2Byteであることから発生しているのではと考えています ライブラリー依存でしょうかね。 ¥rと¥nの両方をfgets()が改行として処理したのかも知れません。 gccだし。 >fflush(stdin)を使用しないで、この問題を回避する適切な方法がありましたらご教示ください。 読み込み用のバッファをもう少し大きく用意する。でしょうか。 1回目、"abc"を読み込みます。 第2引数で指定した3バイトに達したため。 stdinのバッファには¥rと¥nが残ってます。 2回目、¥rを読み込みます。 fgets()の仕様により改行コードに到達したため。 1回目の読み込みで残るのに注意です。 # 2回目で¥rだけなのか¥r¥nなのか、はたまた¥r¥nが¥nに変換されるのか…はfgets()の後で内容確認してください。
No.2です。 > どこにNo.2を加えればよいのでしょうか。 No.2のプログラムは、数字を入力して変数userに代入するものです。 ですから同じ動作をしている部分、すなわちscanf()と置き換えれば良いのです。 以下は、No.2のプログラムを修正して関数化したものです。 #include <ctype.h>と 関数input(){ }をmainの上に追加して、 scanf()を代入文に置き換えてみてください。 ---------- #include <stdio.h> #include <stdlib.h> #include <ctype.h> // 関数 int input(void){ char buf[4]; int i; while(1){ printf("重複しない3つの数字："); // fflush(stdout); for(i = 0; i < sizeof(buf); i++) buf[i] = 0; fgets(buf, sizeof(buf), stdin); if( buf[sizeof(buf)-2] != '\n' && buf[sizeof(buf)-2] != 0) while( getchar() != '\n') ; // 入力バッファクリア（この行、要セミコロン） if( !isdigit(buf[0]) ) continue; // 1文字目が数字かチェック if( !isdigit(buf[1]) ) continue; // 2文字目が数字かチェック if( !isdigit(buf[2]) ) continue; // 3文字目が数字かチェック break; } return atoi(buf); } // メイン int main(void){ int user; user = input(); // scanfの代わり printf("number : %d", user); return 0; } ----------
>メンバーに入っていないのはわかりますがどうして入っていないのかが分かりません。 そういう風に設計しているからでは？ 継承しているわけでもないのですから、入っていないものはどうにもなりません。 貴方自身(class sanmoku)についている筈のロケットエンジン(player1メンバー)で火星まで行ってください。 ロケットエンジンついている筈ですが？ って言われて可能ですか？ >メンバーに入れる方法はどのような方法があるのでしょうか？ クラスに宣言を加えて、実装コードを記述してください。 # bool game::player1(int x, int y)　は記述の通りclass sanmokuのメンバーではありませんのであしからず。
文字列の終わりを示す為に、文字列の最後に'\0'を追加します。 その為に、文字配列を確保する際は、文字数に＋1した物を確保 する必要があります。
こんな感じです。 -------------------------- #include <stdio.h> #include <stdlib.h> int main(void){ char *s = "123e+4abc"; char *p; double d; d = strtod(s, &p); printf("data = %g\n", d); printf("next char = '%c'\n", *p); printf("next index = %d\n", (int)(p - s)); return 0; }
「切り捨て」と断じるのはおかしい＞#2. 少なくとも規格上は「適当な桁数で丸める」としか決まっていない.
No.3です。 ＞ブラウザEXEプロセス(例えばIE)も同じ仕組みで、 ＞通信しているのでしょうか？ ＞どの言語で出来ているか分かりませんが、 ＞bindやlisten, accept, connetと等々しているのでしょうか？ サーバはsocket()→bind()→listen()→accept()です。 ブラウザ等のクライアントは普通、socket()→connect()です。 ただし、場合によっては（発IPやポート番号を固定にする場合など）connectの前にbindすることもあります。 bind, listen, acceptの機能をもう一度確認してみてください。
>この場合290≦x≦298,339≦y≦353の範囲をランダムでクリックしている操作をさせていることになりますか？ なりません。 ---------以下、UWSCのヘルプより抜粋------------- //　マウスボタン BTN( ボタン,　状態,　[x,　y,　ms] ) 引数 　ボタン：LEFT,　RIGHT,　MIDDLE,　WHEEL(ホイール回転) 　状態：CLICK(0),　DOWN(1),　UP(2)　　WHEEL指定時はノッチ数 　x,　y： 位置　（省略時は現在位置にて）　 　ms： 実行までの待ち時間 （ミリセカンド） ---------ここまで抜粋------------ >もし上記の操作ではない場合この文章はどういう操作なのか x=290,y=339,待ち時間=298msの左クリック動作になります。最後の353はおそらく無視されます。 >またどうすれば特定の範囲を指定してその範囲をランダムでクリックさせることができるようになるのか 290≦x≦298,339≦y≦353の範囲をランダムでクリックさせたい場合 DIM x = RANDOM(298-290) + 290 DIM y = RANDOM(353-339) + 339 BTN(LEFT,CLICK, x, y) のように乱数を用います。
> プログラムを終了して２度目を開始するとシリアルポートを開くところで停止してしまいます。 このプログラムを終了ってメインスレッドを終了するのですよね。このときシリアル通信しているスレッドの方は正しく終了処理していないですよね。 シリアル通信が正しくクローズされていないので再オープンの際に待ちに入ってしまっているのではないかと思います。mbedを外すとシリアル回線がリセットされて次のオープンでは上手くいくのでしょう。 プログラム終了時に通信スレッドを停止してシリアル回線をクローズする処理を入れる必要があると思います。
やりたいことは、”1ケタの数字（0~9)を４つ重複しないように乱数生成する”ですかね？ （4ケタの数字1000～9999ではないですよね？プログラムの内容的に。） 実現方法はいくつかあると思います。 案１．配列に生成した乱数を記録しておいて、 　　２回目以降の乱数で抽選された数字が、 　　配列に記録してある数字と一致するかチェックし、 　　一致した場合は、一致しなくなるまで再度乱数生成をし直す。 　　以下のプログラムは一例。（手元がC++の環境なので微妙に違うけど。） 　　これが良い例というわけではないです。何かバグあるかもしれん。 int i, d; srand((unsigned)time(NULL)); int ary[4];//生成した乱数格納用 //配列初期化、乱数で選ばれる事が無い-1を入れておく。 for (i = 0; i < 4; i++){ ary[i] = -1; } for (i = 0; i<4; i++) { while (ary[i] < 0){ d = rand() % 10; if ((d != ary[0]) && (d != ary[1]) && (d != ary[2])){ //要素数が少ないので横着 ary[i] = d; } } printf("%d ", d); } 案２．配列（要素数10）に0～9の数字を入れておいて、 　　ランダムに配列内の並び順をシャッフルして、 　　その後、先頭の4つを出力する。 　　参考：http://mementoo.info/archives/746 案2の方がスマートな気がしますが、せっかく途中までプログラム作ってたようなので、 案1はそれの改造版ですな。
計算機が作りだす乱数は規則性があるんやで。
多分 Matrix a, b, c; で a = b * c; と書くと、 ■b * c が新たな一時的な行列オブジェクトを作る。 ■代入で 一時的オブジェクトを を a へ shallow copy ■a = b * c; の最後で一時的オブジェクトが消えるので、 a にコピーされた領域ポインタがさす配列の中身が消えてしまう。 ということなのでしょう。解決法は簡単で = 演算子を オーバーロードします。 案1: = 演算子 で deep copy を行う。 案2: = 演算子 で shallow copy を行い、 配列要素の確保領域内に設けた参照カウンタ(初期値=1)を カウントアップする。 デストラクタでは参照カウンタをデクリメントし、0になったら 配列要素の確保領域を破棄する。 行列要素を変更した場合は deep copy を行う。 案1は簡単で確実ですが遅い。案2は効率的ですが若干複雑です。
if をきちんと書くと if (式) 文1 あるいは if (式) 文1 else 文2 という形で, 「式」を評価した結果が「0 でない」なら「文1」を実行し, 0 のときには (前者の場合) なにもしないあるいは (後者の場合) 「文2」を実行する というものです.
第１引数のアンパサンド(&)は不要です
>・あらかじめ単語を用意する方法 ファイルに用意し、プログラム初期化時にファイル内容を 配列に格納する。 一度使ったかどうかを知る必要があるので struct word_type{ char* word; char isUsed; }; のような構造体の配列になるかもしれません。 (使ったかどうか情報を単語数分だけ持つ配列を 別に用意してもいけると思います) >・単語の引用方法 配列をfor文で回して、使用可能な単語 (ユーザが入力した単語末尾文字で始まり、かつ まだ使用していない単語)があるか 調べます。該当単語を使ったらisUsedにフラグを 立てます。
No2 です。 ブラウザによって、選択できる画質が異なるとの事だったので 試してみましたが、当方では、その様な事は有りませんでした。 使用したブラウザ FireFox 46.0.1 chrome 50.0.2661.102 m IE 11.0.9600.18321 選択できる画質 144 240 360 480 720 もしかしたら、ブラウザのバージョンに寄る違いかもしれません。 YouTube に限って言えば、高画質に設定すれば音声も良くなる様に なっています。 正し、元の音質を超えることは無いので、コンテンツに寄っては 画質を上げても音質は上がらない というのは、良く有る話です。 YouTube の音質に関しては、有志達がいろいろと検証している様で 中には、少しでも良い音質で聞く為の設定やら機器を紹介しています。 検索すれば、いろいろと出てくると思います。 ちなみに、今まで書いてきたのは、windows環境での話です。
>cl dll.c /LD リンク間違えている…というワケではないみたいですね。 https://msdn.microsoft.com/ja-jp/library/cc42909 … より、 >DllMain は、ライブラリ定義の関数名です。以前のバージョンの SDK のドキュメントは、エントリポイント関数名を DllEntryPoint と記述していました。開発者が独自の DLL を構築する場合は、実際に使う名前を指定しなければなりません。詳細については、開発ツールのドキュメントを参照してください。 ということで、VC系ではDllEntryPoint()ではなくDllMain()である必要があるようです。 リンクされるスタートアップ処理からコールされるのがVCだとDllMain()だけでDllEntryPoint()はコールしてくれないのでしょう。 Borland C++は少々古いはずなので、DllEntryPoint()でコールするようにライブラリが作られている…。ってところでしょうかね。 https://msdn.microsoft.com/ja-jp/library/f9t8842 … でリンカにエントリポイントの関数名を指定するか… DllEntryPoint()をコールするだけのDllMain()を追加するか…でしょうかね。
もっと綺麗に書けそうな気がする。。。 http://www1.axfc.net/u/3663721 スタートボタンの処理が難しいですね。 初期状態の時は状態を「連打」に変えるだけで、連打状態の時は `Count` 取りたいというのがうまく書ければ…
> 実際、cl.exeやbcc32.exeでは発見できないインクルードファイルがありました。 それは、具体的に何ですか? ・実際にはそのファイルが存在するのに、コンパイルオプション(特に、インクルードファイルの検索パスの設定)が不十分で見つけられない ・標準ではないライブラリを使用している。MinGWでコンパイルする場合でも、そのライブラリをインストールする必要がある。 　この場合、Visual Studio用のものも用意されていることもあり、それをインストールして然る可き設定をすればコンパイルできるようになるかもしれない。 ・MinGWやUnix系OSで必要だけど、Windowsでは別の方法で代用できる
using System; class fib { 　　static void Main(){ 　　　　ulong a = 1; 　　　　ulong b = 1; 　　　　ulong x, y; 　　　　int i; 　　　　for (i = 0; i < 50; i++) { 　　　　　　　Console.Write("{0}\n", a); 　　　　　　　x = b; 　　　　　　　y = a + b; 　　　　　　　a = x; 　　　　　　　b = y; 　　　　} 　　} } // あとはこの辺 // http://www.oki-osk.jp/esc/cs/lazylist.html // でも参照の事。
同じく2008は所持していないので2005で。 # 2008EEのISOイメージは保管してあるけど、今の環境には2015Communityが入れてあるので…。 ソリューションエクスプローラを表示して、プロジェクト下の対象ソースファイルを選択します。 右クリックしてプロパティを選択。 そのソースファイル個別の設定が確認できますので「C/C++」を展開して「コマンドライン」をクリックします。 右側に表示されるのがビルド痔のコマンドラインになります。 ＃２さんが指摘している個別に～のヤツですね。 C/C++ツリー上に「詳細」があるのでクリックします。(コマンドラインの1つ上かな) 「コンパイル言語の選択」で"/TP"か"/TC"か選択できます。
CやJAVAを知っているなら、UE4のリファレンスを見ながらでも大丈夫だと思いますよ。 C++を使わなくても、エディタだけでも結構いろいろ出来るので、先ずはそちらを試してみた方が良いかも知れません。
基本構造は、整数を返すものと同じです。 ・戻す値を文字列オブジェクトにする。 ・Python側で受け取った値を文字列として処理する 勉強のためにも、その整数を返す例を改造して御自身で作ることを推奨します。
単純に PostMessage(hWnd, WM_CHAR, 0x01, 0); で良いのではないの? # 0x01は制御文字Ctrl+AのASCII文字コード まあこれで終了するかどうかはアプリ次第でしょうけど。
TryParseを使うなら try catch はいらないです。 TryParseの戻り値が false なら エラーメッセージを出力して 下さい。 >何度目で正解できたかも計算できたらいいのですが 適当にカウントする変数を作って数えましょう。
問題になってるのが sqrt だってのはわかるよね? では, sqrt のオーバーロードはどうなってるか確認したのかな?
単純に配列の中身をゼロ初期化するのであれば、 for (i=0; i<(sizeof(field) / sizeof(int)); i++) *(field + i) = 0; もしくは、 memset(field, 0, sizeof(field); ですね。 ちなみに、RAMが64KBしかなく、CPUのクロック周波数が4MHz程度で、 画面描画は直接VRAMに書くしかなかった時代の人なら、 ブロック周辺の背景に当たるデータをいったんその大きさの領域に退避し、 ブロックの形状と背景を重ね合わせて表示、 ブロックが移動するごとにその領域だけ一旦元へ戻し、 移動先（回転後の形状も同様）ブロックの領域のみまた同じように重ね合わせて表示すると思います。 （これを文字通り『重ね合わせ処理』と呼んでいました） 現代のコンピュータはかなり高性能なので気にならないかもしれませんが、 質問者様が作っているプログラムは画面全体を毎回再描画していると思うので、 スペックのかなり低いマシンでは画面全体がチラついた感じになると思います。
ファイルオープンエラーならば、return -1を入れる等対策は するとして、 >if((file = fopen(filename,"wt"))==NULL) "wt"のtがよくわからなかったので、tを削りました。 ドライブのパスをc直下に変えましたが、同じ？エラーが 出たので、d直下にしたらファイルが作成され、正常終了しました。 指定フォルダには何かアクセス権限的なものがあり、書き込み権限 が必要なのかもしれないですね。 ちなみにforループをdouble型で回していますが、期待通りの ループができないときもあるかもしれないですね。 [参考] https://www.jpcert.or.jp/sc-rules/c-flp30-c.html
「-------------------------データ-------------------------」以降を 切り取ってdata.txtとします。 プログラムをコンパイルします。拡張子は.cppで。 コマンドプロンプトで実行時に、ファイルをリダイレクトで 入力します。 例)aaa.exe < data.txt 上記手順で、何かたくさん出力メッセージが出ました。 何が書いてあるかは全く理解できませんけどもｗ
#include <stdio.h> int main(){ int a = 0; /* 変数aは１０００～１００４番地（４バイト）に確保されているとする */ char *p; p = &a; *p = 2; printf("a:%d\n", a); } [実行結果] a:2 できるっぽいですね。 上記コードだとコンパイル時に、 「warning C4133: '=': 'int *' と 'char *' の間で型に互換性がありません。」 と出るので、ポインタ(char *p)の型はint * にすべきでしょうけど。
言語として簡単なのは、後発のSwiftの方でしょう。 ただ。 プログラミングというのは、日本語(または、あなたが得意とする言語。あるいは、数式、図等)で書かれた「作業手順書」を、「外国人であるコンピュータ」に分かるように「外国語(=プログラミング言語)に翻訳」するものです。 プログラミング言語によるの難易度の違いは、主に後段の「翻訳」の部分です。 ですが、前段の「手順書」は、言語によっての違いはほとんどありません。 熟練者がいろんな言語を扱えるのは、「手順書」を作る技術があるからです。あとは、辞書(マニュアル)でも見ながら翻訳するだけです。 /* この言語には、こういう手順の方が書きやすい/書きづらい といった違いはありますが */ 「for多重ループ」といったものは、主に前段に相当します。 多重ループ等は、ちょっとしたプログラムを書けば、どこかに出てます。 Swiftだから使わずにすむ、というものではありません。 今のまま言語を変えても、結局同じところでわからなくなるのでは? 「手順書」作りの技術を身につけましょう。 プログラミングに「正解」は複数あります。本に載ってる「答え」はその一つでしかありません。 「答え」以外の方法を考える、とか、「答え」を応用して違う動作をするプログラムに作り変えるとか、そういう訓練も必要です。 こういう部分は、「読解力」「文章作成能力」といった「文系」の分野です。 「文系だからできない」というのは通用しません。
Eclipseで十分ではないでしょうか？ Javaと比べれば初期設定など色々不便な点はありますがほぼ同等の事が可能です。 Windows環境向けの開発であればVisual Studioをお勧めします。 Visual StdioはEclipseと比べると動作が軽いですし、またオートコンプリートや仕様一覧の出力機能がEclipseと比べ強力等、IDEとして基礎的な機能が強力です。 また、Visual Studioはテストプロジェクトのようにシステムライフサイクルを考慮した機能がIDEに完全に統合されており、Eclipseに比べて設定といった余計な作業が減らせるという利点もあります。 逆に欠点はWindows以外のOSはAndroidとiOS以外の開発は不可能ではありませんが困難です。
> メニュー２にメニュー１の内容を反映する方法がわかりません。 メニュー1でユーザーに入力してもらった情報を保存する変数を1個用意して、 メニュー1の処理でその変数に代入し、メニュー2でその変数の値を利用すれば良いですね。 流れは以下のような感じです。 -------------------------------------- メニュー1で書いてもらう内容を入れる変数uを宣言する。 ループ脱出用フラグ変数fを宣言する（初期値false) while(true){ // 無限ループ開始 　　メニューを表示する。 　　メニュー項目を入力してもらう。 　　switch(入力したメニュー項目){ 　　case 1: ユーザーに書いてもらい、その情報を変数uにいれる。 　　　　　　break; 　　case 2: 変数uの内容を反映したものを出力する。 　　　　　　break; 　　case 3: f = true; // 無限ループを脱出する条件にする。 　　　　　　break; 　　default: 入力したメニュー項目番号が間違っている表示をする。 　　　　　　break; 　　} 　　if(f) break; // 変数fがtrueなら無限ループ脱出 } // 無限ループはここまで
＞外部装置を15ピンD-sub（アナログVGA）またはBNCより映像信号のフレームをキャプチャー する方法について、できるだけ簡易な方法をご教示ください。 キャプチャーしたい信号に適合した、ビデオキャプチャーカード（たとえばSC-500N1/DVI　？）を使う。２，３万で入手可能と思います。 http://www.4gamer.net/games/017/G001762/20111024 …
こんな感じ void smallnums(int& a, int& b, int& c){ int t; if(a > b){t = a; a = b; b = t;} if(a > c){t = a; a = c; c = t;} if(b > c){t = b; b = c; c = t;} }
>目的はグローバル変数を使用しないで実行したい ならばmain()内のローカル変数にすればよいでしょう。 他に関数コールで渡したりする訳ではないのですから。 関数にわたすなら結果は戻り値で受け取るのが普通かと思いますが。 ちなみにローカル変数の場合、参照する前に初期値いれておかないと内容は不定ですのでご注意を。 >「ここの計算式」だと小数点が出ません何がいけないのでしょうか？ int型に少数が入ると思っているのが悪いと…。 整数しか入りません。小数点以下は切り捨てられます。
VisualStudioにC++がありますのでコンソールアプリケーションとして作成すれば可能です。リンクの方ではVisualStudio2013ですが当方2010Express Edition（無料版）でやったところ動きました。こんな感じ（添付図） >高度な作業ができるのでしょうか? MikuMikuDanceの開発ソフトはVisualC++ 2005 Express Editionだそうです。 http://www.itmedia.co.jp/news/articles/0803/10/n … コンソールアプリケーションでビルド https://www.yc.tcu.ac.jp/~vis/vs/12a1_ide_usage/ …
入門書などを購入して、しっかりと基礎から学習された方が良いと思いますよ。 （文字列、配列、ポインタ……） --------------------- #include<stdio.h> int main(void){ char *x[] = { "___CCCCC", "CCC_____CCC", "CCC", "CCC", "CCC", "CCC_____CCC", "___CCCCC", }; int i; for(i = 0; i < 7; i++) printf("%s\n", x[i]); return 0; } --------------------- ※表示が崩れるのでスペースの代わりに"_"としました。 ※scanf使用の意図が不明なので削除しました。
RS232Cが標準で付いていた時でもそれらの信号が付いていないときも有りました。 ＵＳＢからRS232Cに変換するのであれば、制御信号は使わないようにしたい。 変換装置が、制御信号まで面倒見ているか分からないから。 　 質問の意図が制御信号が付いているから積極的に使おうと言うのであれば、使わないように考えた方が良い。 　 　相手側の都合でその制御が必要と言う事でしょうか。 　ＣＴＳが付いている装置ですと、ＣＴＳをＯＮにしないとハード的に送信出来ないのでＯＮにする処理が必要です。ＣＴＳをＧＮＤに落とせばＯＮになると思います。 　相手から出ている出力制御信号をＣＴＳに繋いでＯＮにする方法も有ります。 　 　通信制御が必要なら、ソフト的に通信をＯＮ／ＯＦＦする方法を検討した方が良い。 　制御するソフト命令が有るのかと言う質問なら、私の範疇外なので２番さんに任せます。
そういう仕様ですね＞#3. 規格にも「いったん立った failbit を落としてから読み込む」コード片が書かれてますし. さておき, ちょっとファイルの仕様がどうなっているのかも気になった. 例えば header が "ABCDEFGH" のとき AAAAAAAsomething wrong (※ここは空行です) ABCDEFGHthis is good (以下省略) みたいなフォーマットになっているのでしょうか? そして, このようなフォーマットで「空行を永遠にリードし続け」るということでしょうか? もしこういうフォーマットだとしたら AAAAAAAAsomething wrong (※ここは空行です) (※ここも空行です) ABCDEFGHthis is good とか AAAAAAAAsomething wrong ABCDEFGHthis is good の場合, あるいは AAAAAAAAここはとっても長い行なんだと思ってください具体的には300バイトくらいの長さになってる行だったりするといろいろプログラムに問題があって困りそうなんだよねそろそろ300バイトは越えてくれるかなもうちょっとあった方がいいかなああもういい加減面倒だからこれで止めることにしておくけどこれで足りなかったらもっと長くしてくれ (※ここは空行です) ABCDEFGHthis is good だったらどうすればいいんだろうか.
> 入力して書き込んだとき（curr_s_wright関数使用時）は正常なのですが それは、どうやって確認したのですか? また、具体的に、どのような文字化けになったのでしょうか? プログラムを見る限り、 　　curr_s_wright( str2 ); 　　printf( "%s" , curr_s_read() ); を 　　printf( "%s" , str2 ); としても同じ結果になるはずです。 　　wsprintf( str2 , "%s（貨幣）" , str1 ); この時点で、あなたの期待とは違う文字コードが使われているのではないか、と思われます。
参考にされているサイト様にも書かれているように >●提供される DLL の情報・仕様の読解力。 こちらが要求されます。 SafeMelt32.DLLと同梱のapi_ref.txtに必要な関数の使い方が書いてありますので、 そちらを読みながら適切な関数を呼び出してください。 シェアウェアなところとか、XPまでにしか対応してないところとか気になりますが。
kbhit()は，getc()などを呼ぶ前にそこにキー入力があるかどうかを確かめることができるものですよね．この例の中のシリアルに対するreadable()も同様の機能を持っています． ここでキー入力を検出した場合にgetc()によってその文字を読みだすのはkbhit()もreadable()も同じです．
>②のポインタ*iの型はint *で良いのでしょうか？ *iの型は int*(int, int) です。ポインタではなく関数型です。 関数型は値として評価される時はポインタに変換されます。 つまり *i の変換後の型と i の型は同じ、意味も同じです。 >sizeof(int *())はsizeofのオペランドは関数で >あってはなりませんと怒られてしまうようなのですが、 >何故、int *(*)()に変換されるのでしょうか？ int *(int, int) が int *(*)(int, int) に変換されるのは 言語仕様通りです。特に不合理な点はないと思います。 また、関数型にはサイズが定義されていませんから、sizeof がエラ－になるのは当然だと思います。
こちらにカウントダウンタイマーについて 詳しく載せてる方がいますので 参考にしてみてくださいね！ http://skylinker.blog.fc2.com/blog-entry-50.html
fはあくまで「関数」で、必要に応じてポインタに変換されます。 >関数全体の先頭アドレス 先頭かどうかはコンパイラの実装次第。 利用者が気にする必要はありません。 関数を起動するためのエントリーポイントです。 >ポインタの指す中身（この場合は、 >関数全体になると思うのですが）の >大きさを見る方法とかはあるのでしょうか？ ありません。そもそも特定の関数に属さない 共通コード等も生成されるので、大きさは定義 不能だと思います。
PHPカテゴリのご質問の続きですよね？ 本題からどんどん脇道に逸れていっていますが、大丈夫ですか？ Microsoft Visual C++ 2008 SP1 Redistributable PackageはUSBに入れて使用するものではありません。また、Xammp portableは、このパッケージを必要としません。 初心者の方にありがちですが、いろいろな環境をごっちゃにしてしまった状態で発生した問題を解決するのは至難の業です。件の質問の回答にあるように、一旦全てをアンインストールしてから、再度、必要な一つの環境のみインストールすることをお勧めします。
>int (*p)[3]のpの型は、 >int (*)[3] >か >int *[3] >のどちらが正しいのでしょうか？ 勿論宣言通りの int (*)[3] です。 ポインタだから、32ビットでコンパイルすれば常に4です。 sizeof(p) を調べるのが簡単です。 >sizeof()で調べると、 >sizeof(int (*)[3]) = 4 >sizeof(int *[3]) = 12 >となり、後の方が合っているように思うのですが？ int *[3] は intを指すポインタの配列(要素数=3) なので sizeof(int *[3]) は sizeof(int *) * 3 という意味になります。
>①の記述は、typedef int(*ap)();でも大丈夫のようですが Cだとプロトタイプ宣言無しになってしまうので、 引数の数や型がノーチェックになって通ってしまいますが 警告を出すコンパイラが多いですね。 c++ならエラーになります。 Cでも近い将来プロトタイプ宣言無しは廃止される そうなので、止めた方がよいでしよう。 エラーチェックが弱まるだけで、良いことはひとつもないです。
ランタイムエラーの修復は厄介ですね。 次回のWindows Update で自動修復されればいいのですが、どうしても急ぐのであればOSの再セットアップをしてしまえばいいです。 プログラムはすべてインストールしなおさねばならなくなりますが、あれこれ悩んでいてもムダに時間が過ぎていくだけです。 私はWindowsを使うようになってから14年ほどですが、これまでシステムの復元とかで不具合が解消したことが一度もありませんので、システムの復元機能は最初から無効化しています。 復元が必要なほど重大な問題が起きたときはためらわずに再セットアップしますよ。
ちょろっと仕様を確認したけど int a[] = { 1,2,3 }; としたときの a が「不完全型」かどうか判断できなかった (苦笑). int a[] までは不完全型だから, それではじかれる可能性がある (static でないデータメンバーは完全型である必要があるので). ちなみに手元の G++ 5.2.0 ではどっちもアウト. jひょっとすると VC++ の拡張機能で「最後のメンバーは『大きさを陽に与えない配列』でもいい」というのがあったりするかもしれん. これが発動するなら class MyClass { public: int a[] = { 1,2,3 }; int b = 1; }; はダメでも class MyClass { public: int b = 1; int a[] = { 1,2,3 }; }; は OK だったりする.
MSのダウンロードセンターからVCのランタイムをDLしてインストールしてください。 https://www.microsoft.com/ja-jp/download/search. … どのバージョンのものが必要とされているかは不明ですので、一通りインストールすることを勧めます。 # SPなんちゃらの場合は新しい方だけでいいが、ほかはバージョン間で互換がありません。 OSが64Bit版の場合は32Bit(x86って表記されてる)と64Bit(x64と表記)の両方を、 32Bit版の場合は32Bit版のランタイムを。 # 2005/2008/2010/2012/2013/2015の一通りを。 インストール終わったらWindowsUpdateしておくといいでしょう。
>それでは、端末を閉じた場合、 >exe内のprintfの標準出力はどこを向くのでしょうか？ 出力先は変わらないです。 HUPでkillされてしまいますね。SIGHUPで死ななければ、 恐らく数分後にSIGPIPEくらうでしょう。
.netでは ADO.NETという仕組みでDBにアクセスするのが一般的です。。 ADO.NETでDBにアクセスするには そのDB用のデータプロバイダ が必要です。MySQLは MySQL Connector/Net ですね。 ADO.NETはOLEDBやODBCをサポートしているDBとも 汎用のデータプロバイダ経由で接続できます。 取りあえずローカルな小型DBとしては H2とかはいかがでしょう? ODBCで繋がると思います。
この＆はif条件のandではなく&演算子です。変数keyとdefine値PAD_INPUT_UPのビット演算をしています。 ちなみにif文の複数条件は&&です。
あまりこの領域に経験がないのであくまで参考程度に読んでください。 手始めとしてはVisual C#で、Windowsアプリケーションを 作るのがよいのではないでしょうか？パソコン雑誌でもそんな 特集が多い気がします。 ・言語：C# 　C++基礎知識があり、習得が容易である。 　一から全部覚えなくても、C++とかぶっていない個所をさらっと 　学習や、必要になったところで必要なだけの情報収集で間に合う 　気もします。 ・開発環境：Visual Studio Community 2015 　無料。高機能なIDE。ある程度大きなプログラムを 　作成するようになった時、IDEは必要になる。 　登録すればずっと使える模様。 　GUIはドラッグ&ドロップで作成可能。 ・ライブラリ：OpenCvSharp 　日本人の作者曰く、ラップしている関数が多い。 　導入が楽。 　詳細な利点・欠点は以下を参照。 　　http://schima.hatenablog.com/entry/20090616/1245 … 　ライブラリの層がそれほど厚くないので、抽象度の高い 　書き方はできないけども、opencvを直接使う感覚に近い 　書き方ができるので、既存のopencv解説サイト・書籍を 　有効活用可能と思います。 Visual Studioインストール済みの自分のPCで、 以下サイトを参考に試しに導入してみましたが、適当な画像を 使って、動作させるところまで楽でした。 (NuGetではOpenCvSharp-AnyCPUを選択した(Opencvも インストールしてくれる模様)。 プラットフォーム設定はAnyCPUしか選択できなかった) http://schima.hatenablog.com/entry/2013/12/15/11 … 参考サイト 　http://schima.hatenablog.com/entry/2014/01/30/10 … -- Javaを選択した場合、opencvとの連携のための環境設定、 IDEであるEclipseの習得に難があるのではと感じます。 Visual Studio習得もある程度は時間がかかるとは思いますが、 基本的なところを抑えれば、挙動に癖がないと個人的に思います。
何度も同じこと言わせないでください。 理解できないのなら、どの箇所が理解できないのか、具体的に書いてください。 > gcc -Wall -O3 -finput-charset=cp932 --exec-charset=cp932 -o 01.o -c 01.c > windres 02.rc 02.o > gcc 01.o 02.o -mwindows -o 01.exe > ① 01.cから01.oを作る > ② 02.rcから02.oを作る > ③ 01.oと02.oから01.exeを作る それは結果でしかありません。 ・01.exe を作るためには、 01.o と 02.o が足りない → 用意しよう 　・ 01.o が存在しないから、作ろう 　　　01.c があるから、 %.o: %.c のルールを使おう 　　　> ① 01.cから01.oを作る 　　　> gcc -Wall -O3 -finput-charset=cp932 --exec-charset=cp932 -o 01.o -c 01.c 　・ 02.o が存在しないから、作ろう 　　　02.rc があるから、 %.o: %.rc のルールを使おう 　　　> ② 02.rcから02.oを作る 　　　> windres 02.rc 02.o 　01.o と 02.o が 用意できたから作ろう 　> ③ 01.oと02.oから01.exeを作る 　> gcc 01.o 02.o -mwindows -o 01.exe という流れの中で、 ①②③が目に見えている、というだけです。 くどいかもしれませんが、エラーの原因は「01.exeを作るのに、02.oが必要だと指定してあるのに、02.oが無い。作り方もわからない」です。 「02.rcが無い」ことに拘っているようですけど、そこは枝葉です。 Makefile は 「if」と書いてないだけで、実質は「条件分岐」の集まりです。 特殊な事情が無ければ、if を使う必要はありません。 %.o: %.rc 　$(MENU) $(RC) $*.o は %=具体的なファイル名の一部 if %.o が必要 && %.rc が存在する && %.oが%.rcより古い then 　$(MENU) $(RC) $*.o end if と書いてあるようなものです。 ---------------- あなたのやりたいことは 02.rcがあるとき RC=02.rc となっている箇所を、02.rcが無い場合には RC= と書き換えるだけ済むことなんです。 そうすると OBJS+=$(RC:.rc=.o) が ・RC=02.rcのとき: RCの.rcを,oに置き換えた「02.o」がOBJSに追加される ・RC=のとき: RCの.rcを,oに置き換えた「」がOBJSに追加される。つまりは OBJS にはなにも追加されない となり、あなたのやりたいことが実現されます。 これを自動にする方法の一つが RC=$(wildcard *.rc) です。 02.rc が存在すれば、ワイルドカードにマッチして RC=02.rc と書いたのと同じことに、存在していなければ RC= と書いたのと同じことになります。 ------------- 例えば、以下のMakefileは作り方としては間違っていますが動作します。 02.rcがある方のディレクトリで、 make cleanのあとで makeしてみてください。 02.cも01.rcも存在しませんが、コンパイル自体はちゃんとできてしまいます。 ーーー SRC=02.c OBJS=$(SRC:.c=.o) RC=01.rc OBJS+=$(RC:.rc=.o) PROG=01.exe CC=gcc CFLAGS=-Wall -O3 #LDFLAGS=-mwindows RM=rm %.o: %.c 　$(CC) $(CFLAGS) -o $@ -c $< %.o: %.rc 　$(MENU) $< $@ .PHONY : all all: $(PROG) $(PROG): $(OBJS) 　$(CC) $(OBJS) $(LDFLAGS) -o $@ .PHONY : clean clean: 　$(RM) $(OBJS)
「highはデータ検索範囲の大きい方の添字」としか書いてませんよね? 1から100までが検索範囲なら low=1,high=100 30から45までが検索範囲なら low=30,high=45 1から10までが検索範囲なら low=1,high=10 どのような範囲でも、このアルゴリズムで探索できます。 「常に全体を検索範囲にしなければならない」等という決まりはありません。 あとは、解説用に狭い範囲で、というのもあります。
>No.4さん >・char は符号付きまたは符号なしのどちらか >・符号付きの整数の表現方法は「2の補数」「1の補数」「符号+絶対値」のいずれか >・char は最低 8ビット >ということが明記されています JIS規格ではそのような定義があるのですね、勉強になりました。 >質問者様 ご質問の内容と直接に関連のない部分で話題を広げてしまいました。 申し訳ありませんでした。
仮引数の型は必要ですが、名前はあっても無くても、関数本体と異なっていてもかまいません。 型が違うと別関数になってしまうので問題があるかもしれません。 ちゃんと意味のある名前で、定義と同じにしておくと ・プロトタイプだけを見て、引数の意味がわかる ・IDEがヒントを表示してくれるかもしれない ・プロトタイプと定義とで同じ意味になっている、ということが確認できる。 というあたりが考えられます。 例) int hoge(int x,int y) ; // xとyを指定する、ということが、プロトタイプでわかる。 ... // 定義 int hoge(int y,int x) { //(警告もエラーも出ないけど)プロトタイプと見比べたら逆になっているから //もしかしたら期待した動作になっていないかも、という予想はできる。 .... }
OSはWindowsを使っているならば、 ・Windowsキー + [R] ・cmdと入力 ・リターン で、コマンドプロンプトが表示されます。 あるプログラムを実行する際は、 >c:\****\sample.exe ※****はご自身の環境に読み替えてください とするとおもいますが、sample.exeの後に半角スペースを 入れてプログラムにデータを渡すことができます。 例) >c:\****\sample.exe aaa bbb この場合、sample.exeのC言語のmain関数を int main(int argc, char *argv[]) などと定義した場合、aaaはargv[1]で、bbbはargv[2]で 参照可能です。(argv[0]にはsample.exeのパスが入っています) プログラムは、ユーザーが起動時に指定するデータを元に いろいろと処理することが可能なります。 (たいていはオプション指定に使われることが多いと思います)
printf("%c", i); をループで回す。というだけのことでしょうかね？
>abc.A(xyz.getX); こう書いたときに >「C2664 'なんちゃら': 引数 1 を 'int (__cdecl *)(void)' から 'int' へ変換できません。」 このエラーが出て(int型の引数に対して'int (__cdecl *)(void)型の関数ポインタを渡しているのだから当たり前) >abc.A((int)xyz.getX); こう書いたら >引数に意味のない数字が渡されてしまいます こうなったのでしょうか。(関数ポインタをintにキャストして渡しているのだから当たり前) それで、xyz.getX()に直したことで解決したのではないですか。
> bbb::ccc[0] = ....; bbb:: が不要です。 というか、aaa.cpp のソースが本当にこれだけなら、#include"DxLib.h" と void bbb::InitCcc(){ の間に #include "aaa.h" int bbb::ccc[8]; が抜けています。
「ネットの記事を見てその通りに書き、間違いはないと思った」って, いったいどこにある「記事」なんだろ. たとえば #include <iostream> int main() { int x[3]; x[3] = { 1, 2, 3 }; for (int i = 0; i < 3; ++i) { std::cout << x[i] << std::endl; } return 0; } ってあったらおかしいと思わない? というわけで, 素直に ccc[0] = ....; ccc[1] = ....; (以下省略) って書けばいい. あるいはファイル名を配列で持っておいて for (なりなんなり) でまわすとか.
bbb::bbb(){ const int ccc[8] = {1,2,3,4,5,6,7,8}; //宣言 } これって、「bbb::bbbメソッド内のローカル変数cccの宣言」です。 bbb::cccの宣言になっていません。 staticなフィールドの定義なら、メソッドと同じレベルに書く必要があります。 bbb::bbb(){ // コンストラクタの内容 } const int bbb::ccc[8] = {1,2,3,4,5,6,7,8}; > ちなみにconst int型ではなくint型で宣言すると問題なくビルドが通りました。 こちらは再現しません。 手許のclang++では、constの有無では変化しません。 もしかして、 static const int → int (staticもはずしている) ではないですか?
No.1の方と結局同じことを言っているのですが・・・ 関数の引数たるポインタの「配列」は、実際はポインタ（アドレスを表現する、呼び出された関数のローカル変数）だからです。 例えば、 void func(char *pp[]) { printf("%s\n", *++pp); return; } なんて関数を作って、御質問文のpを引数に func(p); を呼び出してもちゃんと通ります（Marchが出力されるはずです）。 もちろん2は、pはポインタではなくてただの決まったアドレスだからNGだというのは質問者様が御推察のとおりです。
「プログラミング勉強サイトcodingame」がいかのうようものかわからないので、下記サイトにて、何となく仕様はこうだ！と憶測をはらんだ上で回答させていただきます。 http://jyusensha.wp.xdomain.jp/post-64/ あなたは、printf()/scanf()関数がコンソール画面への出力あるいはキーボード入力を受け取る関数と捕らえているのではないでしょうか？ printf()/scanf()関数はストリームと呼ばれる画面入出力よりも抽象的な概念への入出力として設計されております。ファイル入出力もそのストリームへの出力です。ストリーム？抽象的？っと思われるかもしれません。うまく説明できないので下記を参照してください。 https://ja.wikipedia.org/wiki/%E6%A8%99%E6%BA%96 … さて、「プログラミング勉強サイトcodingame」において、ユーザーであるあなたの入出力を担う方法としてストリームを利用しているのだと思います。 この説明でご納得いただけるでしょうか？
>terapadからtest.cとあらかじめ文字を出力させるだけの簡単なコードを書いて保存 間違っていたらごめんなさい。 よくある話ですが、 　test.exeが暴走プログラム といったことありませんか？
別の関数のラベルを指定して直接飛ぶことは不可能です (そもそも「別の関数のラベル」が指定できない) が, 別の関数のラベルのアドレスがわかっていればそこに飛ぶことはできます. 例えば #include <stdio.h> void *foo(void) { printf("before label\n"); label: printf("after label\n"); return &&label; } void bar(void *ptr) { printf("in bar\n"); goto *ptr; } int main(void) { void *p = foo(); bar(p); return 0; } なんてプログラムを GCC でコンパイル&実行してみると (警告は出るもののいちおうコンパイルできます) わかると思います.
1) ここに書き写したときに間違っているのでなければ、問題が変です。 int x=[空欄] ; だったとして。 21 と出力しているのは printf("%d\n", x); です。 では、ここで 21 と出力されるためにはどうなっていればいいのか? 　具体的には、xがどうなっていればいいのか? その前で x += 5; となっています。 ここでどんな動作になるのか? この行が完了したとき、上の「21と出力させるための x 」になっているはずです。 そこから逆算すれば、この行の実行前の段階での x がどうなってなければならないか、わかります。 以上をふまえて考えれば int x=[空欄] ; で何を初期値にしなければならないかがわかります。 「答えから仕組みを考える」のではなく「仕組みを考えてから、答えを導く」のがいいのではないでしょうか。 余談 int *x でも21と出力させることは不可能ではありませんが、少なくとも初心者向けではない使い方になります。
うぅ～んと.... p = &bese_list[ mode3 ][ mode4 ]; としたとき, p+=1; と bese_list[ mode3 ][ mode4 ]　+=　1; が全く違う意味を持つことは当然理解してますよね?
できません(作成できるアプリはPC用です） 使いたいマイコン用のクロスコンパイラを準備してください 一例） http://monoist.atmarkit.co.jp/mn/articles/0910/2 …
該当プログラムで使っているメモリ(コード及びデータ)が、止めている間に他のプログラムを動かすためにキャッシュから(場合によってはメモリから)消されて、再開時に再読み込みの時間が掛かるようになっている。 メモリからスワップアウトされるのを回避するのはメモリ上にロックするシステムコールがあったと思うけど、キャッシュの方は難しい。というか無理をするとほかのプログラムの実行が大きく阻害される。
>gccは通ったのですが >./a.outができないです… カレントディレクトリがどこになっているのか？ とか、実行しようとしたユーザはなんなのか？ とか、SELinuxの設定はどうなっているのか？ とか、パーミッションはどうなっているのか？ でしょうかね。 それぞれ pwd id getenforce ls -l a.out とかで確認できます。
以下5行のプログラム if (c == '*') if ((c = getch()) == '/') break; else ungetch(c); が1文だからです。 2文以上は大カッコ{}でくくって1文になり（意味が変わる）ますが、 1文は大カッコ{}でくくっても1文のまま（意味は変わりません）です。
イメージとしては #1 の最後にいわれているように ・水平タブを (適切な数の) 空白に変換する ・しかる後に固定桁で切り出す (同時に行うことも可能) くらいかな. 余談. エディタによっては「空白を水平タブに変換する」機能があったりするから, 「人間が手打ちした」データならこういう構造も考えられなくはないかなぁと思ったりする. プログラムでこんな構造にするのは却って面倒くさい気がする.
とりあえず > ヘッダの中に関数を使わないのであれば、どのようにして、関数の呼び出しを行うのですか？ ---main.c--- #include <stdio.h> #include "facter.h" int main(int argc, const char * argv[]){ 　省略 } ---facter.h--- int twobit(int); ---facter.c--- #include "facter.h" int twobit(int a){ 　省略 }
http://stackoverflow.com/questions/11405/gcc-pro … ということで.
No4 です >AD変換器のメーカはCDでサンプルファイルを提供していて、所定のフォルダに何種類もの拡張子のファイル群が含まれています そのファイルを見ないと何とも言えないのですが 　　　・CDの説明などで該当ソースコンパイルできるVCの対応バージョンが書かれている 　　　・makeファイルが付いている といったことはありませんか？ 　　　　　　　　拡張子が　mak　だったかな？ 単純には community起動すると　　プロジェクトを開く　という項目があるはずですので それを押してそのサンプルフォルダを見に行ってみてください それで特定のファイルが見れるようであればそのファイルを開いてみてください 　　バージョンが違っても自動的に変換されて実行モジュール生成に必要な 　　サンプルの環境が読み込まれるはずです makeファイルが付いているならそれは実行モジュールコンパイルするための 必要ファイルなどが書かれたテキストファイルになると思います 　　　今見たらmakeファイルを直接プロジェクトとして開くことはできないみたい 　　　昔出来たような気がするが VC6かな？？？　　－＞　　記憶があいまい そういったファイルが見当たらない（ソースとヘッダしか見当たらない） のであれば多少荒っぽいやり方として コンソールアプリのプロジェクトを作って （そのソースがコンソールアプリのソースならという前提） ファイルを入れ替えて全部のファイルを追加登録する　　　　などすれば ビルドできるはずです 　　　もしかしたらライブラリなどのリンクエラーが出るかもしれませんが 　　　そこら辺はエラーメッセージ見て必要なものを追加していくしかないでしょう 　　　（コンパイルはある程度通ると思います） 環境読み込めればメニューのビルドからコンパイル・リンクの実行ができ エラーが無ければ実行モジュールが生成されるはずです
PyQTはよくわかりませんが 現在選択されているIndexを、どこかに覚えておいて QListViewへのfocusInイベントでそのIndexを選択すれば良いのではないでしょうか？ QListView Class Reference http://pyqt.sourceforge.net/Docs/PyQt4/qlistview … QAbstractItemView.focusInEvent http://pyqt.sourceforge.net/Docs/PyQt4/qabstract …
「連想配列」の本来の英語は associative array です. 連想配列を実装する 1つの方法としてハッシュ表があるだけであって, 連想配列のことをハッシュと呼ぶのは (概念と実装を混同しているという点で) 本当は不適当です. 「1つの方法」と書いているようにほかにも実装方法はあって, 例えば C++98 では (std::map というクラスですが) 平衡 2分木で実装することが想定されています. まあ, 連想配列自体はある意味 FORTRAN の時代からあったといえなくもないんだけどね. なにしろ 識別子は英字 6文字まで だったわけだし. あと, 「何ができるのか」あるいは「何ができないのか」に関しては, それこそ ライブラリがあれば何でもできる としか言えません. やろうと思えば Fortran で GUI のプログラムだって作れるし, 逆に C では (「標準ライブラリ」と呼ばれる) ライブラリがなければ入出力すらまともに動作しません.
> 1次元配列と2次元配列の場合c言語でどう書けばいいですか？ ゲームプログラム経験者です。まず配列はプログラム手段として結果的に使う事はあるけれど、意識しません。 自動車の運転で右折何回してここまで来ました、って質問に似ています。 c原語の知識で作れない事もないですが、directXはWindowプログラムのようなものなので最低限、ポインタ、構造体くらいは普通に使います。 で、パズドラ風との事ですが、ちょっとステップアップし過ぎ感があります。 まずは、2Dロールプレイングゲームで自由にキャラを動かすレベルから始められては？
通常、メインの動作は縦にまっすぐ、分岐を横にする。 特に、ループが縦に並んでないのはよくない。 「<> がTrueだったら下」と単純に考えないこと。 C言語の内容をそのまま書いているけど、それならフローチャートにしなくてもプログラムを見えればすむこと。 特に「for〜」を全部書いてるけど、では、 return i で返すiはどんな値?変数iが変化するのはどこ? あと、C言語そのものに間違いがあります。 C言語では ・関数の定義は上から順番に処理する。 ・それまでに知らない関数が出てきたら、とりあえず int型、引数自由の関数としてコンパイルを進める ということをやります。 他の言語のように、定義順がバラバラでも正しく動く、ということにはなりません。 今回はたまたまsekiがint型なのでコンパイル自体は正常に終了しますが、使い方を間違えているので、実行時に問題が出る可能性があります。 これを期待通りにするためには、「使う前に宣言する」という方法を取ります。 方法1: 定義自体を先にする #include <stdio.h> int seki(float dat[],int n) { (sekiの内容) } int main(void) { (mainの内容) } 方法2: 関数の形だけ先に宣言する(プロトタイプ宣言) #include <stdio.h> /* プロトタイプ宣言 */ /* 詳しい書式は「プロトタイプ宣言」で検索 */ int seki(float dat[],int n) : int main(void) { 以下元と同じ ※ include <stdio.h> には、このプロトタイプ宣言が沢山入っています。 　printf等が正しく使えるのは、ここでプロトタイプ宣言されているからです。
> 見ていただけますか？ 以前のご質問から思っていたのですが、もう少しやる気を感じさせるコメントができないのでしょうか？ 学校の課題か何かわかりませんが、ご自身で解決しないと身につきませんよ。 > 一様プログラムはかけたのですが、コアダンプや無限ループが出てしまいます。 コアダンプは、たぶんメモリアクセスに問題あり。配列変数などで宣言した値を超える番号の要素にアクセスしていないかを確認する。 無限ループは、ループを抜ける条件を満たさない為、その条件が正しいかを確認する。 いずれも、プログラムの要所要所で、その時の関係する変数（配列の要素番号、ループ脱出条件で使用しているもの等）をprintfで表示させて、想定の値を示しているかを確認する。 また、それ以前にそもそもプログラムの考え方が正しいか検証する。 そして、考え方が正しくコードに落ちているかを確認する。
C++98 だとコンストラクタを作るか一旦オブジェクトを作らないとダメ, かな. C++11 なら G[s].push_back({t, c}); でいけそう.
> 描きたい直線の傾きが負の場合、また、傾きが1をこえる場合にうまく描画できず困っております。 傾きが正の1未満になるように変換して計算すれば良いのでは？ 具体的には ・傾きが1より大きいとき 　直線y=xに対象な点に変換、すなわちxとyの入れ替えをして計算し、描画時に戻す。 ・傾きが1未満の負のとき 　直線x=0に対象な点に変換、すなわちy=-yの入れ替えをして計算し、描画時に戻す。 ・傾きが1より大きい負のとき 　上記２つを組み合わせる。
No.3のやり方で数値化できたということは、空白文字など読み込んだセルの値に数字に置き換えることのできない文字が含まれていたと考えられます。 No.1で示した確認方法はこれを行うまえの事前確認です。（No.2で1を乗算するのと同じことをやっています） CLEAN関数は空白文字や制御文字などを削除する関数です。 「置換」で”空白文字”（全角/半角）を空欄に置き換えた後、「区切り位置」で書式を「数値」に指定すると良いかもしれない。
＞ と書いた時の違いってどのようになるのでしょうか？ 後者は、ループの先頭でgetchar()します。 前者は、ループに入る前にgetchar()します。 while((c = getchar()) != EOF && c != 0x1a)と同じ機能を前者の方式でやるためには、 c=getchar(); while (c != EOF && c != 0x1a){ 　printf("'%1c' -- %2x\n", c,c); 　c=getchar(); } と、ループの末尾でもgetchar()する必要があります。
http://physics.cocolog-nifty.com/weblog/2012/01/ … ここの動画のようなことをやりたいのだとおもいますが プログラムから PortAがスイッチの入力用で PortBが出力だと思いますけど http://physics.cocolog-nifty.com/weblog/2012/05/ … を参考に PORTB = PORTB<<1;PORTBの内容を左に１ビットだけシフトのばあい PORTB = PORTB>>1;PORTBの内容を右に１ビットだけシフトのばあい 速度調整はwaitを入れて数字を大きくすればゆっくり、小さくすれば早くなります
Header Winbase.h (include Windows.h) となっていますから、お手持ちの環境のヘッダファイルにCheckTokenMembershipがあるか検索してみてはどうでしょう？ VC6って辺りでサポートはとうに終了していますけどね。 Platform SDKの更新をしていないのなら更新してみるとか。 http://blogs.msdn.com/b/japan_platform_sdkwindow … の下の方にDL用のリンクがあります。 2003 SP1 Platform SDKか2003 R2 Platform SDKですかね。
> x=0.0 > y=0.0 > a=1./x > write(*,*) a,a*y,x > stop; end > を計算すると、Infinity, 0.0, 0.0となりました。 確かにこれは変ですね。コンパイラが変な最適化をして、a*yをゼロにしてしまっているのかも。 x,yをファイルから読み込むようなコードにするとどうなるか気になります。
本題は #1 の通りでしょう. あとついでにいうと mk_tree の中の p->left = &c; などは右辺でアドレスを取っている c が (関数の仮引数なので) 関数にローカルな自動変数の扱いになります. だから, この文で設定しているアドレスは (関数から出てしまうと) 有効なアドレスではありません.
「2次元配列を使用して」という (謎の) 条件を無視している時点でアウトなわけだが, それ以上に 「'z'-'a' が 25 である」という保証は (少なくとも質問文中には) なんじゃないかな＞#5.
opencvについてはまるでわからない門外漢ですが、 http://www.wakayama-u.ac.jp/~chen/opencv/opencv2 … >CV_8UC1 1個のCV_8U,モノクロ画像の画素値 unsigned char [1] ```コード Mat koyuu(64, 64, CV_8UC1);//生成用画像を用意 koyuu.at<float>(i, j) = 0.0; koyuu.at<float>(i, j) = pca.eigenvectors.at<float>(0, d); ``` この辺でエラー文出てたりしますか？ なにをやりたいかわからないので、妥当な回答かはわかりませんが、 ↓に置き換えるととりあえずエラーが出なくなったりしませんか？ Mat koyuu(64, 64, CV_32F); あと、ベストアンサーください。
>C#でstring型のクラスに格納された文字列を、C言語のchar*として http://rokujo.hatenadiary.com/entry/2015/07/21/1 … そのまま渡せばよろしく処理してくれる…ようです。 試したことはありませんが。
>OSはWindows7で、64Bitです。 でしたら…ランタイムのインストールは可能だとは思われますが……。 ログファイルの中からいくつかキーワードで検索してみるとかでしょうかね…。 なお、対象アプリが64Bitでない場合はランタイムも32Bitが必要だったかと。(未確認…ですけどね) >AviUtlという動画編集ソフトを使いたいんですが、 >それを使うにはそれをインストールしてそのあとにMicrosoftVisual C++を >インストールしなくちゃいけないみたいなんです。 http://spring-fragrance.mints.ne.jp/aviutl/ ですかね？ version1.00でも2013/4/1のリリースみたいですから、VC++2015のランタイムが必要。ということはないと思われます。 # ちなみに、それぞれの2015が入っていれば2005のランタイムが不要。なんてことにはならないのでご注意を。 んで…version1.00をDLしてDependency Walkerで依存関係のDLLとか調べてみましたが、特にVC++のランタイムが必要って感じではありませんでしたが？？ # スタティックリンクしているのかねぇ…。 起動時にエラー表示とかがあるんですか？ # 組み込んでいるプラグインがVC++のランタイムを必要としている…のかも知れず。 # その場合は組み込んでいるプラグインの説明を確認して必要とするVC++のランタイムを調べてください。 # まあ、各バージョンのVC++ランタイムはインストールしておいた方がいろいろ手間が掛からなくていいと思いますけどね。 # サイズもたいした事無いし。(インストール後は何度かWindows Update実行しましょう。) >多分・・・実行環境が欲しいんだと思います。 とすると、カテゴリが違うかと思われます。 デジタルライフのソフトウェア辺りになるんじゃないでしょうかね？ 動画編集ソフトってことで…「デジタルライフ > ソフトウェア > 動画・画像処理」辺りかな。 # 事務局側で移動してくれる…かも知れませんけど。(あえてカテ違いで事務局に報告はしませんけども)
概念の違いについてはNo.1の方のとおりですが、学習という意味では、ディープラーニング（ニューラルネットワーク）は数学的である（論理的に説明できる）のに対し、転移学習は発見的（恐らく論理的に説明できない）だと思います。
> なぜ❝void *❞型にして、関数の中で❝int *❞型にキャストするような使い方をするのでしょうか int a[M][N] はint が M * N 個並んだ配列です。 これを int *a0 = (int *)a ; とすると a[j][i] = a0[j*N+i] という関係になっています。 このことを利用して、 int [M][N] でも int [N][P]でも同じプログラムで?x?の行列を出力するようにしているのがprint関数です。 a[M][N] をそのまま受け付けるためには void print(int x[][N], int s, int t) 等と配列の大きさを指定する必要があり、int [M][N] でも int [N][P]とでは別の関数が必要になります。 void print(int * x, int s, int t) 等として、 呼び出し側で print((int *)a,M,N) とする方法もありますが、print全部に(int *)のキャストが必要で、見栄えがよくありません。 C言語の void * なら、任意のポインタを受けることができるので、 print(a,M,N)と、(int *)へのキャストが不要になります。 そのかわりに、print関数内でキャストが必要です。 > かっこでくくらなくても正しく❝VAL❞と等価だと解釈されるのはなぜでしょうか #define 等は、コンパイル前に「プリプロセッサ」で処理されます。 #defineはマクロを定義するものです。 この場合のマクロは「定義に従ってプログラムを書き換える」ものです。 これは丁度、「テキストエディタの置換機能で VAL → rand() % 101 - 50 と置換する」ような感じです。 Cコンパイラは、実際には、マクロが書き変わったものをコンパイルしています。 a[i][j] = VAL; と書いてあったら、マクロ展開されて a[i][j] = rand() % 101 - 50 ; となり、これがコンパイルされます。 上記のように書いてあれば、括弧が無くても問題無い、ということがわかるのではないでしょうか。 今回は括弧は不要でしたが、逆に括弧が無いと期待したプログラムにならない例もあります
面白そうなので作ってみました。 H,Wは奇数限定ですw 大きい値にしたほうが迷路らしくなりますね。 周囲に壁をランダムに選択し、そこからランダム（制限条件あり）な方向へ壁を延ばしていきます。 やっていることは、関数名をみていただければ大体わかるかと思います。 壁を延ばすときの制限条件を関数extend_wall()とfill_space()内で適当に記述していますが、いろいろ調整してみてください。 延ばすスタート位置の壁と、伸ばす方向をランダムにするために配列sp[]とdir[][]をシャッフルするのに乱数を使用しています。シャッフルのアルゴリズムはFisher-Yates shuffleを使用しました。 ------ aa.c--------------- #include<stdio.h> #include<stdlib.h> #include<string.h> #include "aaaa.h" void create_around_wall(int maze[H][W]); void shuffle_direction(int dir[4][3]); void shuffle_start_position(int *); void get_start_position(int *, int *, int); void extend_wall(int maze[H][W], int, int, int dir[4][3]); void fill_space(int maze[H][W], int dir[4][3]); void create_maze(int maze[H][W]){ int sp[2*(H-2)+2*(W-2)]; int dir[4][3] = {{0,1,1},{1,0,2},{-1,0,-1},{0,-1,-2}}; int ch,cw; int i; create_around_wall(maze); for(i = 0; i < ((H-2)+(W-2)); i++) sp[i]=i; shuffle_start_position(sp); for(i = 0; i < ((H-2)+(W-2)); i++){ get_start_position(&ch, &cw, sp[i]); extend_wall(maze, ch, cw, dir); } fill_space(maze, dir); } void create_around_wall(int maze[H][W]){ int h,w; for(w=0;w<W;w++){ maze[0][w] = WALL; maze[H-1][w] = WALL; } for(h=0;h<H;h++){ maze[h][0] = WALL; maze[h][W-1] = WALL; } } void shuffle_direction(int dir[4][3]){ int i,j,k[3]; for(i = 3; i > 0; i--){ j = rand() % i; memcpy(k, dir+i, sizeof(k)); memcpy(dir+i, dir+j, sizeof(k)); memcpy(dir+j, k, sizeof(k)); } } void shuffle_start_position(int *sp){ int i,j,k; for(i = (H-2)+(W-2)-1; i > 0; i--){ j = rand() % i; k = *(sp + i); *(sp + i) = *(sp + j); *(sp + j) = k; } } void get_start_position(int *h, int *w, int no){ no = no * 2 + 1; if(no < H-2){ *h = no + 1; *w = 0; return; } if(no < (H-2)+(W-2)){ *h = H-1; *w = no-(H-2)+2; return; } if(no < 2*(H-2)+(W-2)){ *h = no-((H-2)+(W-2))+1; *w = W-1; return; } *h = 0; *w = no-(2*(H-2)+(W-2))+2; return; } void extend_wall(int maze[H][W], int h, int w, int dir[4][3]){ int i, dh, dw; int extendable = 1; int his[2] = {-99,-99}; int his_p = 0; while( extendable ){ shuffle_direction(dir); extendable = 0; for(i = 0; i < 4; i++){ dh = dir[i][0]; dw = dir[i][1]; if((h+2*dh)<0 || (h+2*dh)>=H || (w+2*dw)<0 || (w+2*dw)>=W) continue; if(maze[h+2*dh][w+2*dw]==WALL) continue; if(maze[h+dh][w+dw]==WALL) continue; if(dh==0){ if((maze[h+dw][w+2*dw]==WALL)||(maze[h-dw][w+2*dw]==WALL)) continue; if((maze[h+dw][w+dw]==WALL)&&(maze[h-dw][w+dw]==WALL)) continue; } if(dw==0){ if((maze[h+2*dh][w+dh]==WALL)||(maze[h+2*dh][w-dh]==WALL)) continue; if((maze[h+dh][w+dh]==WALL)&&(maze[h+dh][w-dh]==WALL)) continue; } // この条件を外すと壁の配置が斜めっぽくなる。 if(his[his_p]==dir[i][2]) continue; maze[h+dh][w+dw] = WALL; h += dh; w += dw; extendable = 1; his[his_p++] = dir[i][2]; if(his_p == 2) his_p = 0; break; } } } void fill_space(int maze[H][W], int dir[4][3]){ int ch, cw, dh, dw; for(ch = 2; ch < H-2; ch++) for(cw = 2; cw < W-2; cw++){ int exist_wall = 0; for(dh = -1; dh <= 1; dh++) for(dw = -1; dw <= 1; dw++) if(maze[ch+dh][cw+dw]==WALL){ exist_wall ++; goto exit_for; } exit_for: if(!exist_wall) { maze[ch-1][cw] = WALL; maze[ch][cw] = WALL; extend_wall(maze, ch, cw, dir); } } }
三角波のグラフをASCII文字で描画するプログラムですね。 #include <stdio.h> #include <math.h> // 三角波の生成関数 double f(double x) { _ return fabs(sin(x) - sin(3*x)/9 + sin(5*x)/25 - sin(7*x)/49 + sin(9*x)/81)*8/M_PI/M_PI; } // f(x) を描画する ASCII 文字列を生成 char *makeBar(char* ptr, double num) { _ char* p = ptr; _ int n = 1 + (int)(0.5 + 4 * num); _ while(n--) *p++ = '*'; _ *p = 0; _ return ptr; } void main() { _ double x; _ char buff[80]; _ for (x = 0.0; x < 2*M_PI; x += M_PI/8) { // 描画範囲は適当に調整してください _ _ puts(makeBar(buff, f(x))); _ } }
＞あと、getchが定義されてない。とでます。 #include <conio.h>
> '(void)'の意味がよくわかりません voidそのものはご存知ですよね？ もしご存知ない様でしたら入門書をお読みください。 > void (* const RESET_Vectors[])(void) = {…} まず、* const RESET_Vectors[]ですが、これは ポインタの配列になります。constがついていますが、よくある 　main(int argc, char* argv[]) の2番目の引数と同じ書き方ですよね。 では、何のポインタの配列かというと、以下の記述にするとわかり易いを思います。 　void func(void) そうです関数ですね。 つまり、void func(void)型の関数へのポインタの配列ということになります。{……}の中で記述しているのは各関数のアドレスになると思います。 下に同じ書き方をした簡単な例を挙げますので、ご参照ください。 ご提示のソースは、組み込み用CPUか何かのプログラムですよね？ そのCPUのリセットベクタ（constがあるのでROM領域）に処理ルーチンの開始アドレスを登録しているのだと思います。 ------------------------------------------------------- #include <stdio.h> int a = 2; int b = 3; void add(void){ printf("a + b = %d\n", a + b); } void sub(void){ printf("a - b = %d\n", a - b); } void mul(void){ printf("a * b = %d\n", a * b); } void div(void){ printf("a / b = %d\n", a / b); } int main(int argc, char *arcv[]){ void(* const vector[])(void) = {&add, &sub, &mul, &div}; (*vector[0])(); // a + b = 5 (*vector[1])(); // a - b = -1 (*vector[2])(); // a + b = 6 (*vector[3])(); // a / b = 0 }
http://marupeke296.com/EL_Ard_No8_SuperSonic.html のコードですよね? そのままコピーしてArduinoのIDEに貼り付けて、そのままビルドできましたけど…。
if( a % 2 == 0 ){ これは int amari = a % 2; if( amari == 0 ){ と同じになります ある数字と２で割った時、割り切れる時（余りが０）は偶数、 割り切れない時（余りが１）は奇数になりますよね。 この算数を利用して偶数か奇数かを判定しています。 aが５の時は int amari = 5 % 2; →　５÷２の余りがamari に代入されるのでamari は１ if( amari == 0 ){ のif分には入らず、elseの処理に入ります。 ＝＝は代入ではなく、比較です。０と同じかどうか判定しています。
unsigned char だろうと char だろうと int だろうとやることは同じです. さて, int の配列だったらどうしますか? ちなみに #2 はいくつか誤解しているところがあるのでその指摘もしておきましょう. ・ただの char が signed であるか unsigned であるかは処理系依存です.つまり char buff[3]; という宣言が unsigned char buff[3]; と同じであるような処理系も存在しえます. ・C において負数の表現方法には「2の補数」, 「1の補数」, 「符号+絶対値」のいずれもがありえます. なので, signed char で表すことのできる最小値である SCHAR_MIN は規格上 (-128 ではなく) -127 以下となっています. ・念の為書いておくと, char のビット数も処理系定義です.
それは、具体的にどのCPU向けのなんというCコンパイラの話でしょうか? また #include <stdio.h> #include <limits.h> int main(){ int s = sizeof(unsigned int); printf("sizeof(unsigned int)=%d\n",s); printf("UINT_MAX=%u\n",UINT_MAX); return 0; } このプログラムを実行したらどんな出力になりますか? (標準ライブラリが使えるコンパイラで、printfでの出力ができたとして) intの大きさは、対象CPUやコンパイラの種類によって違います。 例えば、Windows PC用のVisual C++だと intは32ビットで、次のように出力されるはずです。 sizeof(unsigned int)=4 UINT_MAX=4294967295 > unsigned int は6万しか取れなくて 「6万」という「中途半端」な値ということは、まずありません。 普通は内部では二進数が使われているので、intが16ビットのコンパイラだと 65535が最大になります。 このとき、上記のプログラムでは 「sizeof(unsigned int)=2」「UINT_MAX=65535」 と出力されると思います。 ※ sizeof(unsigned int)= の方は違う値になるケースもありますが。 「6万しか取れなくて」等と言われると、この情報自体が間違っているのでは?と疑ってしまいます。 > unsigned int に0xffffffを代入 まず。 整数型間では、「暗黙の型変換」が行われます。 unsigned int u; とした場合、 u=0xffffff ; は u=(unsigned int)0xffffff ; と同じ意味になります。 大きな型から小さな型(int→char等)の場合、上位ビットの足りない分は無視されて下位だけが残ります。 例えば、char c; の場合 c=0x1234; は、下位の 0x34 だけがcに代入されます。(charが8ビットの場合) intが16ビットというのが正しければ、 「u=0xffffff ;」と書くことは可能ですが、実際には上位ビットが捨てられて「u=0xffff ;」となります。 intが16ビットというのが間違っていて、24ビット以上(UMAX_INTが16777215以上)ならば、0xffffff が正しく代入できます。
浮動小数点数で非数(NaN)を表現する値の1つですね。 C99だと判定関数としてisnanがありますが、VCだと_isnanですかね。
こんなかんじですか。 各インスタンス共通で使用する定数という前提です。 -------------------------------- #include <iostream> #define SIZE 3 using namespace std; class Foo{ private: static const int m[SIZE]; public: Foo(){} void Print(void); }; const int Foo::m[SIZE] = {1,10,100}; // ここが配列のデータ void Foo::Print(void){ //　配列を表示する関数 for(int i = 0; i < SIZE; i++){ cout << m[i] << endl; } } int main(int argc, char *argv[]){ Foo *a = new Foo(); Foo *b = new Foo(); a->Print(); b->Print(); return 0; }
様々な条件で違います。 例えば。 Excelを自分のPCでビルドしている人は、ほとんどいません。 これは後者の「ビルド環境でコンパイルしてしまい、実行ファイルを実行環境に持っていく」です。 例えば。 UNIXとかLinuxとかでは、最近でこそビルド済みのバイナリでの配布も増えましたが、まだまだ「ソースコードで配布して、各自でビルド」というのも「一般的」です。
指数部がゼロというのは、正規化数の範囲では、数値のゼロを表現します。そのため、仮数の整数部もゼロ、小数部もゼロです。 参照されているページの「指数部の符号化方式」の所を見てください。
#include <iostream> #include <vector> using namespace std; struct HISTOGRAMS { int number; double histograms; }; vector<HISTOGRAMS>* read_hist() { FILE *fp; auto *hist = new vector<HISTOGRAMS>(); int number; double histograms; char buf[100]; fopen_s(&fp, "hoge.txt", "r"); fscanf_s(fp, "%s", buf, 100); while (fscanf_s(fp, "%d%*c%lf%*s", &number, &histograms) != EOF) { HISTOGRAMS temp; temp.number = number; temp.histograms = histograms; hist->push_back(temp); } fclose(fp); return hist; } void write_hist(vector<HISTOGRAMS>* hist) { FILE *fp; fopen_s(&fp, "huga.txt", "w"); for (auto it = hist->begin(); it != hist->end(); it++) { fprintf_s(fp, "%d:%f ", (*it).number, (*it).histograms); } fclose(fp); } int sum_hist(vector<HISTOGRAMS>* hist) { int sum = 0; for (auto it = hist->begin(); it != hist->end(); it++) { sum += (int)(*it).histograms; } return sum; } void normalize_hist(vector<HISTOGRAMS>* hist) { int sum = sum_hist(hist); for (auto it = hist->begin(); it != hist->end(); it++) { if (sum != 0) { (*it).histograms /= sum; } } } int main() { vector<HISTOGRAMS>* hist = read_hist(); normalize_hist(hist); write_hist(hist); delete hist; return 0; }
No1で答え出てますが、気づいていなさそうなので #include <studio.h> あなたのスペルミスです。 <stdio.h>
C99は、OSや環境等に依存しない、標準的な言語仕様を 定義したものです。 従って、特定のOSや文字コードを使う様に、限定された 物であれば、定義される場合もあるかもしれませんが、 現在使用しているC言語のヘッダファイルに定義されて いなければ、自分で作る(調達)必要があります。 ※注意点 文字列を単純にByte単位で逆順にしただけでは、漢字等 の2Byteコードも順序を入れ替えてしまう為に、正しい 文字列反転にはなりません。 漢字(2Byteコード)か否かを判定して、漢字の場合には その2Byteの順序を変えない様にします。 漢字か否かの判定条件は、文字コードにより異なります。
No3 補足 型きちんと見てなかったので hist[gray] ++; if (gray < 128)　　辺りがエラー（ワーニング）になるかもしれません とりあえずエラー起こさないようにするだけなら hist[(int)gray] ++; if ((int)gray < 128) とでもしてください(もちろんgintでも構いません）
座標の取得関数（input_point）の「int型に変換」の所を下のように修正してください。 //座標の取得 int input_point(PT * p, char board[H][W]) { //int型に変換 (input[0] == '\0') ? p->x = -1 : (p->x = atoi(input)); ↓に修正 //int型に変換 (input[0] == '\0' || input[0] < '0' || input[0] > '9') ? p->x = -1 : (p->x = atoi(input));
「以下のURLにあるソースコードをeclipseのファイルにコピペしたら」といわれても, 「実際にあなたがなにを実行したのか」がさっぱりわからんのよ. 実際にした操作を「誰にでもその通りに実行できる」ように書いてくれんかな. そもそも「eclipse のファイル」ってなんだよ. あと余談だけど, URI は大文字と小文字の区別をしないから「以下の最初のHをhに変えれば」は全く意味を持たない.
画像を見たところ、データファイルの数値はタブ区切りでしょうか？ タブ区切りだと勝手に想定して、データファイルの名前を data.txt だとします。 だいぶやっつけですが以下のような感じでどうでしょう。 データファイルの上から3行の英語が書かれている行は、atoi関数で0が返りますが、 今回、整数は1～17の範囲ということなので、0は無視しています。 必要なら適当にエラー処理などは入れてください。 #include <stdio.h> #include <stdlib.h> #include <string.h> #define MAX_STR 100 #define MAX_NUM 17+1 int main(void) { FILE *fp; char str[MAX_STR]; char *tp; int a; int freqdis[MAX_NUM] = {0}; int i; fp = fopen("data.txt", "r"); while (fgets(str, MAX_STR, fp) != NULL) { tp = strtok(str, "\t"); a = atoi(tp); if (a == 0) { continue; } freqdis[a]++; } /* 表示 */ for (i = 1 ; i < MAX_NUM ; i++) { printf("%d: %d個\n", i, freqdis[i]); } fclose(fp); return 0; }
プログラムでやらなきゃいけない理由は? プログラム作るのに時間がかかるようなら、Excelのヒストグラム機能使えばいいのでは? それに、こんなコメントも無いプログラムの断片見せられても、どこにどうやっていいものかわかりません。
ハッシュ関数に与える文字コードと、 プログラムに記述する文字コードと、 キーボードやファイルやデータベース等から入力する文字コードと、 画面やファイルやデータベース等に出力する文字コードとを、分けて考えましょう。 UTF-8 対応のCコンパイラ、というと、関係するのは「プログラムに記述する文字コード」だけです。 前回の件で、ソースコードに char seed[] = "It's a show time" ; h = hash(seed); みたいにして使いたいなら ○ソースコードをCP1252 で書いて、 CP1252 に対応したコンパイラを使う ○ seedの文字コードを CP1252 に変換してからハッシュ関数に渡す ○ *seed = "It\102s a show time" ; 等と、コードを直接指定する。 等があります。 ファイルやデータベースから読むなら ○ファイル等をCP1252 で書いて、そのままハッシュ関数へ ○読み取った文字列を CP1252 に変換してからハッシュ関数へ となります。
// SEND それぞれのアルファベットには独立した数字 (0～9) のときその組み合わせは？ // +MORE //-------- // MONEY このコメントが付いて、ようやく何をしようとしているのかが理解できました。 > 1000から9999までを全て計算して25個実行する というのも意味不明だったのですが、「25個解が見つかる(本当はそんなに無いはず)」という意味だとわかりました。 まず、覆面算では、「最高位は0ではない」というルールがあるそうです。 そのルールを採用するなら「NO. 1:2817+ 368=3185」 等はM=0なのでルール違反です。 ただ、現状のプログラムでは、1000〜9998 (9999ではありません) を総当たりしているので、このルールを適用したものになっています。 次に、check 関数で何をやっているか見ていきます。 正解となるのは (1)同じ文字には同じ数字 (2)違う文字には違う数字 を満すときです。 (1)をチェックしているのが if((e1 == e2) && (e2 == e3) && (n1 == n2) && (m1 == m2) && (o1 == o2)) flag =1; です。コメントを付けるなら /* 同じ文字が同じ数字になっていれば、正解の可能性がある(flag=1) */ とでもなるでしょうか。 (2)をやっているのが、その下の部分です。 /* Sと他の文字とで等しいものがあったら不正解(flag=0) */ if((s ==e1) || (s == n1) || (s == d) || (s == m1) || (s == o1) || (s == r) || (s == e2) || (s == m2) || (s == o2) || (s == n2) || (s == e3) || (s == y)) flag = 0; 以下、同様のコメントを付けていくと、チェックしてない文字があることがわかります。 そのチェックを追加しましょう。 で、抜けているの文字のことを考えると、そのままコピペして if((e1 ==s) || (e1 == n1) || (e1 == d) || (e1 == m1) || (e1 == o1) || (e1 == r) || (e1 == e2) || (e1 == m2) || (e1 == o2) || (e1 == n2) || (e1 == e3) || (e1 == y)) flag = 0; とかやって、「答えが一つも見つからない」とでも思ったのでは? 論理和なので、どれか一つでも成立していれば、flag=0になります。 この中には (e1 == e2) があります。 このとき「不正解」とするのが「正しい」動作なのか、考えてみましょう。 少し工夫すると、無駄な判定が無くなってスッキリするのですが、今回は、提示されてプログラムをなるべく変えない方針で答えました。
＞参考になるサイトや書籍がググっても見当たりません。 そんなこと言ってるようじゃ先が思いやられますが ZIPだけでいくつか http://qiita.com/yuba/items/55226c2de81436746a8c https://ja.wikipedia.org/wiki/ZIP_%28%E3%83%95%E … http://www.tnksoft.com/reading/zipfile/cryptzip. …
あなたがヒストグラムを作るとしたら, どう作りますか?
環境を構築するためのリリース物一式をまとめたアーカイブをプロジェクトのサイトからダウンロードし、自分でコンパイルします。 http://www.gtk.org/download/macos.php 上記ページのBuilding、All-in-one bundlesを参照ください。 この辺りを読んで「？？？」の場合は、環境を作ってもその先がちょっと大変かもしれません。 なお、日本語での解説は「mac gtk インストール」といったキーワードで探すと見つかると思います。
「c++ 日本語 文字列」といったキーワードで検索すると詳しく解説しているページが間単にたくさん見つかりますよ。 お試しください。 ちなみに自分が読みやすいC++の入門書を一冊選ばれるのも一つの方法です。
起動時の引数で区別するのがいいと思います。
#include <string.h> #include <ctype.h> typedef struct character { int y; //座標 int x; char name[16]; int room; //dungeon[room][y][x]; int lv; int hp;//ヒットポイント int atk; int lack; int gold;//所持金 } PC; //初期化データ PC pc[2]; pc[0].room = 0; pc[1].room = 0; int main(void) { Init_Room_PC(0); srand((unsigned)time(NULL)); printf("[Esc]=Game End , [Hit Any Key]=Game Start\n"); while ((ch = _getch()) != 27) /* 27 = Esc key で強制終了*/ { if(toupper(ch) != 'C') { Init_Room_PC(pc[0].room); } else { Init_Room_PC(0); } keyinput(); monster();//乱数で、4方向移動 system("cls"); status(); //pc[0]{0,2,"Player",0,0,50,5,3,10},の内容をprintf()で表示するだけです。 dungeon();//10x10でダンジョンとキャラの表示 game_end(pc); } } void dungeon(void) { for(int y=0;y<10;y++){ for(int x=0;x<11;x++){ /*ここら辺が怪しいのかなとは思うのですが、倒した後、姿を消したいのでこうしました。*/ if((y==pc[0].y&&x==pc[0].x)&&(pc[0].hp>0)){//HPが0以下なら表示しない printf("＠"); }else if((y==pc[1].y&&x==pc[1].x)&&(pc[1].hp>0)){//HPが0以下なら表示しない printf("巣"); else if(dungeon[room][y][x]==1){ printf("■");//壁 }else{ printf("　");//移動できる場所(全角スペース) } } } 略 game_end(PC pc[]){ 略 if(pc[0].hp <= 0){ //hpが0以下になったらhpに0を入れる pc[0].hp=0; dungeon(); printf("モンスターに敗れた・・・\nGAME OVER\n"); printf("[Esc]=Game End , [C]=Continue\n"); }else if(pc[1].hp <= 0){//hpが0以下になったらhpに0を入れる pc[1].hp=0; dungeon(); printf("モンスターを倒した！\nGAME CLEAR\n"); pc[0].room += 1; pc[1].room += 1; printf("[Esc]=Game End , [C]=Continue\n"); } } // 部屋番号でPC構造体を初期化する int Init_Room_PC(int aroom) { if(aroom == 1) { ClearPC(&pc[0], 8, 1, "Player", aroom, 0, 50, 5, 3, 10); ClearPC(&pc[1], 1, 8, "Slime", aroom, 0, 7, 3, 1, 30); } else { ClearPC(&pc[0], 1, 2, "Player", aroom, 0, 50, 5, 3, 10); ClearPC(&pc[1], 4, 5, "Slime", aroom, 0, 7, 3, 1, 30); } } // PC構造体の初期化 int ClearPC(PC * apc, int ay, int ax, char *aname, int aroom, int alv, int ahp, int aatk, int alack, int agold) { apc->y = ay; apc->x = ax; strcpy(apc->name, aname); apc->room = aroom; apc->lv = alv; apc->hp = ahp; apc->atk = aatk; apc->lack = alack; apc->gold = agold; }
とりあえずそのメッセージに従ってみてはどうだろうか.
プログラムの実行結果は正しいので、ループ回数を少なくしたいということでしょうか？ 取り敢えず、別の方法でも計算するようにしてみました。 #include <stdio.h> int mmony() { int s, e, n, d, m, o, r, y; int send , more, money, count = 0; for(s = 1; s < 10; s++) { for(e = 0; e < 10; e++) { if(s != e) { for(n = 0; n < 10; n++) { if(n != s && n != e) { for(d = 0; d < 10; d++) { if(d != s && d != e && d != n) { for(m = 1; m < 10; m++) { if(m != s && m != e && m != n && m != d) { for(o = 0; o < 10; o++) { if(o != s && o != e && o != n && o != d && o != m) { for(r = 0; r < 10; r++) { if(r != s && r != e && r != n && r != d && r != m && r != o) { for(y = 0; y < 10; y++) { if(y != s && y != e && y != n && y != d && y != m && y != o && y != r) { send = 1000 * s + 100 * e + 10 * n + d; more = 1000 * m + 100 * o + 10 * r + e; money = 10000 * m + 1000 * o + 100 * n + 10 * e + y; if((send + more) == money) { count++; printf("NO. %d\n", count); printf(" %4d\n", send); printf("+ %4d\n", more); printf("-------\n"); printf(" %5d\n", money); } } } } } } } } } } } } } } } } } int check (int send, int more, int money) { int s, e1, n1, d, m1, o1, r, e2, m2, o2, n2, e3, y, flag; flag = 0; s=send/1000; e1=(send / 100) %10; n1=(send / 10) %10; d= send %10; m1 = more / 1000; o1 = (more / 100) % 10; r =(more / 10) %10; e2 = more %10; m2 = money / 10000; o2 = (money / 1000) % 10; n2 = money / 100 % 10; e3 = money / 10 % 10; y = money % 10; if((e1 == e2) && (e2 == e3) && (n1 == n2) && (m1 == m2) && (o1 == o2)) flag =1; if((s ==e1) || (s == n1) || (s == d) || (s == m1) || (s == o1) || (s == r) || (s == e2) || (s == m2) || (s == o2) || (s == n2) || (s == e3) || (s == y)) flag = 0; if ((d == s) || (d == e1) || (d == n1) || (d == m1) || (d == o1) || (d == r) || (d == e2) || (d == m2) || (d == o2) || (d == n2) || (d == e3) || (d == y)) flag = 0; if ((r == s) || (r == e1) || (r == n1) || (r == d) || (r == m1) || (r == o1) || (r == e2) || (r == m2) || (r == o2) || (r == n2) || (r == e3) || (r == y)) flag = 0; if ((y == s) || (y == e1) || (y == n1) || (y == d) || (y == m1) || (y == o1) || (y == r) || (y == e2) || (y == m2) || (y == o2) || (y == n2) || (y == e3)) flag = 0; return flag; } int main(int argc, char argv[]) { int send , more, money, count; count = 0; for (send =1000; send <9999; send++) { for (more =1000; more <9999; more++) { money = send + more; if(check(send, more, money)==1) { count++; printf("NO. %d\n", count); printf(" %4d\n", send); printf("+ %4d\n", more); printf("-------\n"); printf(" %5d\n", money); } } } printf("=======================\n"); mmony(); }
>Undefined symbols for architecture x86_64: >"Board::putBlack(int, std::__1::vector<int, std::__1::allocator<int> >&)", referenced from: >Board::putBlack(int) in osero2-03dec1.o Board::putBlack(int, std::__1::vector<int, std::__1::allocator<int> >&)をBoard::putBlack(int)からコールしているけど、 指定されたシンボルが見つからないからリンクできね～よ。 と言われています。 掲示されているページのothello.cppのint Board::putBlack(int ix)の実体(189行目)までしか記述していないのならリンクエラーになるでしょうね。 別のオブジェクトファイルにint Board::putBlack(int ix, vector<int> &v)の実体があるワケでもないのですから。 分割コンパイルしたいなら、それなりに書き換える必要(クラス定義のヘッダと実体のcppソースとか)があったりビルド時のオプションでそれなりに指定が必要だったりしますけどそういうことしていないですよね？ xcodeやterminalの問題ではなく、不完全なソースでの途中ビルドはできないよ。というだけのハナシではないですかね？ # コンパイルでオブジェクトファイルの生成まではソース記述の途中でも可能でしょう。(文法エラーとかなければ…　あんまり意味ないですが)
初級のころは説明を簡単にするために、本当のところを少しだけ隠したりしています。 // scanfはキーボードから入力、とか if (条件) のときの「条件」もその一つです。 より正確には if(式) で、「式が真値の場合then句を、偽の場合はelse句を実行する」となります。 C言語では、0で無いものが「真」、0は「偽」となっています。 では if (a == b) とは何か。 これは 「aとbが等しかったら」 ではなく 「a==bの計算結果が真ならば」 です。 そう。 == はただ計算するだけの演算子なのです。 a == b は aとbが等しければ1,等しくなければ0という値になります。 式なので、式が書けるところに使えます。 return m_board[ix] == BLACK; というのは m_board[ix] == BLACK という「計算結果」を返すものです。 余談ですが。 よく見かける if (a) { 〜 といった表現は、「a」が式だからできることで、その真偽によって分岐することができます。 if (a=b) { 〜 と間違えてもコンパイルが通ってしまうのも、 a=b が「式」だからです。( = は代入演算子 ) judge= (a == b) ; 等と変数に結果を保存して、後で if (judge) { 〜 等と分岐させることも可能です。
VBAのコードだけどAPIベースなので、取り敢えずは判るのではと。 http://okwave.jp/qa/q3252966.html
「スタックを一切使ってはいけないみたい」とかいってるけど, それ以前に わざわざ入力を解析して 2分木を作ったにもかかわらずそこから RPN にした上でその RPN をさらに解析し直すのは無駄 ということに気付くべきじゃないかなぁ.
実際に行ったわけではないですが・・・。 以下のマイクロソフトのQAを読む限り、インストールと共存が可能なようです。 https://www.microsoft.com/ja-jp/dev/products/com …
普通に考えてメモリ割り当て処理などを間違っているのではないかと思います 以下のような回答しかできません http://okwave.jp/qa/q8067899.html
アプリケーションが OS を経由していろいろ仕事をするのは, #2 のように「ハードウェアの違いを吸収する」以外にも「無法なことをさせない」という理由もあります. 例えば, バックグラウンドでなにか作業をしているプログラムが勝手に変なものを表示しても困るよね. そういうことをさせないよう全てのリソースを管理するというのも, OS の仕事の 1つです. ちなみに「C言語単体」といってしまうと, 単純な文字の表示すら不可能です (printf などのライブラリ関数は「言語自体」とは一応分離されている). ということで Linux の printf をターゲットにしていろいろ解説している http://www.shuwasystem.co.jp/products/7980html/4 … なんて本もあったりします.
https://ja.wikipedia.org/wiki/%E3%83%84%E3%82%A7 … > ただし、1月と2月は、前年のそれぞれ13月・14月として扱う。 > たとえば、2015年1月1日・2月1日は、2014年13月1日・14月1日とする。 計算は、プログラムの通りの順番に行なわれます。 wdayを 計算したあとで、year,monthを変更しても、プログラムを遡ってwdayを計算しなおしたりはしません。 > if (year <= 2) //曜日の計算をする ○ yearが2以下になることは、ほとんど無いし、上記のツェラーの公式用の計算なら「年」ではありません。 ○ コメントの書き方もプログラミング技術の一つです。 　ここは、「曜日の計算をする」場所ではなく、その「準備をする」場所。 　具体的には 「1月と2月は、前年のそれぞれ13月・14月として扱う」ための場所です。 if (year <= 2) //1月と2月は、前年のそれぞれ13月・14月として扱う だったら、 year がおかしいし、計算順番もおかしいことがわかったのでは。
「Visual C++ 入門」とか「Visual C++ 入門 プログラム」といったキーワードで検索すると様々な解説サイトがヒットします。 その中に結構例題をあげて解説しているものもあります。 書籍だと2008年発行の「ひと目でわかるMS VISUAL C++2008アプリケーション開発入門」（ISBN-10 4891005769）というものがあります。 設計→製造の順に説明していてわかりやすいです。 ちなみにC言語は勉強済みでしょうか？ C++はオブジェクト指向言語のくくりに入れられていますが、C言語にオブジェクト指向“的”な改良を加えた物なので純粋なオブジェクト指向言語ではありません。そのため個人的にはオブジェクト指向をしっかり理解する題材としてはおすすめしません。 C++を学ぶ場合はまずC言語を理解された上で取り掛かられると「こういう部分がオブジェクト指向なのか」というのが分かりやすいかと思います。。。というか、やっぱりオブジェクト指向をちゃんと学ぶのでしたら純粋なオブジェクト指向言語、例えばJavaを題材にされるとよいです。
考え方は、だいたいよいかと思いますが、その考えをうまく「言葉」にできていないようです。 ○ 関数は 型 名前(引数) { 本体 } という形になります。このとき、本体に別の関数の定義が入ったりましません。 main関数も関数です。 このままでは void decrement _date(int *y,int *m,int *d) { に対応した } がありません。 ○ incrementとdecrement が逆になっていませんか? 　decrementなのに、一日増やす(次の日にする)ようなプログラムになっています ○> case 10 : (*d==31);*m=*m+1; *d=1; break; やりたいことは見当付きますが、コンピュータはそう解釈してはくれません。 (*d==31) と書いても「*dが31だったら」という意味にはなりません。 また、31日以外のときに 日付を単純に1日増やす、という処理がありません。 ○ printf("前の日は％ｄ年％ｄ月%d日です。\n"); 各%dに対応する値が指定されていません。 あと、おそらくここに打ちこんだときにそうなってしまったのだとは思いますが、％ｄに「全角文字」が使われているので、期待通りには動いてくれません。
#1 です。 行ヘッダーに表示させている行番号をどのように指定しているのかわからないのですが、その数値を 10 で割った余りの値を指定すれば良いかと。 ex.) 123 → 3 ここを参考にししているのなら http://dobon.net/vb/dotnet/datagridview/drawrown … (e.RowIndex + 1).ToString() を ((e.RowIndex % 10) +1).ToString() に変更 private void dataGridView1_CellPainting(object sender, DataGridViewCellPaintingEventArgs e) { 　　if(e.ColumnIndex < 0 && e.RowIndex >= 0) 　　{ 　　　　e.Paint(e.ClipBounds, DataGridViewPaintParts.All); 　　　　Rectangle indexRect = e.CellBounds; 　　　　indexRect.Inflate(-2, -2); 　　　　TextRenderer.DrawText(e.Graphics, 　　　　　　((e.RowIndex % 10) + 1).ToString(), 　　　　　　e.CellStyle.Font, 　　　　　　indexRect, 　　　　　　e.CellStyle.ForeColor, 　　　　　　TextFormatFlags.Right | TextFormatFlags.VerticalCenter); 　　　　e.Handled = true; 　　} } ここを参考にしているのなら http://dobon.net/vb/dotnet/datagridview/headerte … こんな感じ for (int i = 0; i < dataGridView1.Rows.Count; i++) { 　　dataGridView1.Rows[i].HeaderCell.Value = ((i + 1) % 10).ToString(); } とか
どこがCの質問でしょう？ カテ違い？
少なくとも「収束ってなんですか？」については, この問題を出した人間に聞くのがベストじゃないですかねぇ.
atメソッドを使ったり、ptrメソッドを使ったりします。 http://opencv.jp/opencv2-x-samples/access_pixel_ … の C++版 。これは、各画素の書き込むものですが、= の左右を逆に考えれば、各画素の値を読み出すのに使えます。 追記: 調べたところ、 cv::Mat::copyToで、std::vectorにコピーすること自体はできるようです。 http://book.mynavi.jp/support/pc/opencv2/c3/open … ただ、その場合、Matの型、チェンネルとvectorの型を揃える必要があるように思います。 また、OpenCVのバージョンによっては、 型を指定する必要があります。 それで気になっているんですが、 おそらく、 〜.bmpは、 8bit x 3チャンネル(3色) です。 それに対して、 v1は <float> となっています。 v1には、どんなデータを入れたいとお考えなのでしょうか? 事前に型や色を変換するとか、vectorを適切な型にするとかが必要と思われます。 # 今OpenCVを使える環境が無いので、当方で確認することはできません
> その変換の部分でうまくいきません 「うまくいかない」とは、具体的にどんな現象から判断していますか? もし、実際のプログラムもこのままだとしたら、cv::Mat とか std::vector の問題ではなくて sprintf(name, "分割1-１\0015.bmp",);//画像をnameへ格納 が問題なのでは? CやC++での文字列のこと、よく思い出してください。
Program1.cs 　エントリポイント 　出来上がったプログラムは、ここに記されているコードから実行されます。 　プロジェクトのプロパティにある『スタートアップオブジェクト』を 　設定していない場合、ここの中のstatic void Main()が真っ先に走行します。 　そして、そのメソッド内に、Application.Run(new Form1());と記述 　されていることで、Form1を呼び出しています。 　 　間違っても、初めてプロジェクトを作成したからと言って、Form1が 　呼び出されているわけではありません。 　逆に言うと、初期表示したいフォームを変更したいならば、ここの 　内容を変更しますし、フォームが閉じられた後に何か処理を要する 　時でもこのファイルに追記してコードすることがあります。 Designer.cs 　フォームなどを作成した時に、関連づけられているソースコードです。 　分かりやすいところでいうと、フォームでボタンを貼りつけたり、 　ラベルの文字や背景色を変えたりした情報が、すべてこのファイルで 　設定されます。 Form1.cs 　実際に求める動作を記述するファイルです。 　ボタンを押したらラベルに「Hello World」の文字を表示するとか。
あー、うん、C言語慣れてないとメンドくせぇ問題だな、ってのは分かります(笑)。 僕も 「２つの異なる実数解を持つ場合は整数1を、重解を持つ場合は整数0を、虚数解を持つ場合は整数-1を戻り値とする関数solveQeを定義して利用すること」 って文を読んだ時、 「何でやねん。直接解を返さないで何で1、0、－1を返さなアカンねん?」 って初見でそう思いました(笑)。 基本的にモダンな言語のユーザーだと皆同じように思うでしょうね(笑)。「なんてムダなんだ!」と(笑)。これはある意味、C言語らしい問題ですね(笑)。 さて、ポイントは2つあります。 まず一つ目。 今書いたように、問題文の指定だと関数solveQeは「計算する」けど「計算結果」は返さない、と言う不思議な挙動を仕様とします。 つまり、例えばmain関数内で適当な変数dを用意して d = solveQe(a, b, c, ans); とした場合、dには何が入るでしょうか?ちょっと考えてみてください。 そうですね、1か0か-1のどれか、です。実は全く計算結果は入らないんです。 言い換えると事実上、2次方程式の解、つまり計算結果は「捨てられてる」って事なんですね。非常に不思議なんですが、これが実はこの問題のポイントなんです。 じゃあ、ここでdは一体何に使われるべきなんでしょうか?答えは一種のフラグなんですね。表示を切り替える「サイン」として働きます。 つまり、問題の要求はmain関数上に次のようなコードを書け、って言ってるんです。 d = solveQe(a, b, c, ans); if (d > 0) 　　　{ 　　　　　　printf("係数a, b, c >> %d, %d, %d\n", a, b, c); 　　　　　　printf("2つの異なる実数解: %.2lf, %.2lf", ans[0] + ans[1], ans[0] - ans[1]); 　　　} 　　　else if (d == 0) 　　　{ 　　　　　　printf("係数a, b, c >> %d, %d, %d\n", a, b, c); 　　　　　　printf("重解: %.2lf", ans[0] + ans[1]); 　　　} 　　　else 　　　{ 　　　　　　printf("係数a, b, c >> %d, %d, %d\n", a, b, c); 　　　　　　printf("虚数解: %.2lf ± %.2lfi", ans[0], ans[1]); 　　　} つまり、dの中身によって印字される内容を変えろ、って事です。 「計算上」の話をすると実はsolveQeが行ってる事はこの「切り替え」のサインのみの「返し」で、計算結果自体は全く関係ない、事実上その計算結果「自体」は捨てられてるんです。これが実はこの問題の一つ目のポイントです。 いやちょっと待てよ、と。「計算結果自体が捨てられてるのなら計算結果が見れないじゃん」と思うでしょう。その通りなんですが、もう1つのポイントがC言語特有(でもねぇけどモダンな言語じゃちょっと無い)の性質絡みの事があるんです。 ではその2つ目のポイント。 C言語では別の関数に配列を渡すと基本的に配列の内容を「書き換えてしまう」って特徴があるんですね(正確に言うとC言語だけじゃなくって低レベルの言語だとそう言う事がしばしばある。メモリ効率を優先してるから)。難しい言葉で言うと「副作用」(計算結果が問題にならずに、メモリの状態を書き換えたり、とか印字する「計算自体とは何の関係も無い作用)って言うんですが、このプログラムでは要するにそれが用いられてるわけです。 一般的に昨今のモダンな言語ですと、配列、あるいはリストなんかを別の関数に手渡す場合、大体のケースではそのものを渡さずにコピーを渡すんですね。ところがC言語なんかの低レベル言語だと「データそのものを渡す」ように設計されてて、例えば関数Aから関数Bに配列を渡す、何らかの計算を行って手渡された配列に結果を書き込む(ここが副作用)、そうすると関数Aに戻った時、元あったデータが書き換えられる、って事です(破壊的操作、等と呼んだりします)。 昨今のモダン言語だとこの「破壊的操作」は非常に危険で、データをあっちこっちに手渡した場合、いつ書き換えられるのか、書き換えられた事で元の関数に戻った時にとんでもない挙動が起きたり、とか予測が付かない、ってんで嫌われてるんですが(要するにバグの原因になり得る)、この宿題ではそう言う「破壊的操作」を用いる形式となってるわけです。 solveQe自体は高校数学での「判別式」を知ってればそれほど難しくないです。つまりreturnで「1、0、-1のどれを返すのか」と言うのは判別式に従う、って事ですね。当然if文が活躍します。 int solveQe(int a, int b, int c, double m[2]) { 　　　int determinant = pow(b,2)-4*a*c; 　　　printf("%d\n", determinant); 　　　if (determinant > 0) 　　　{ 　　　　　　m[0] = -(double)b/(2*a); // ここが破壊的変更 　　　　　　m[1] = sqrt(determinant)/(2*a); // ここが破壊的変更 　　　　　　return 1; // 返り値 　　　} 　　　else if (determinant == 0) 　　　{ 　　　　　　m[0] = -(double)b/(2*a); // ここが破壊的変更 　　　　　　m[1] = sqrt(determinant)/(2*a); // どっちにせよ結果は0 　　　　　　return 0; // 返り値 　　　} 　　　else 　　　{ 　　　　　　m[0] = -(double)b/(2*a); // ここが破壊的変更 　　　　　　m[1] = sqrt(-determinant)/(2*a); // ここが破壊的変更 　　　　　　return -1; // 返り値 　　　} } もう一度言うと、deteminant(判別式)に従ってif文で返り値を変えます。判別式は高校数学が教えるところの determinant = b^2 - 4*a*c ですよね。determinantが0より大きければ実数解、0の時は重解、0より小さければ複素数解になります。 そしてこのコードに於いて、引数で与えられた配列mに「計算結果を書き込む」事が配列への「破壊的変更」で、一旦ここで数値が書き込まれたらどの関数から参照されようと「配列の中身は変わってしまってる」って事です。また、この作用自体は「計算結果を返してる」わけじゃないです(この辺ちょっと難しいかもしれませんが、取り敢えず「データ書き換え」は返り値ではない、つまりsolveQe関数が計算結果自体を返してるわけじゃない、って理解してください)。 もう1つの注意は、僕もちとハマってたんですが(笑)、例えば2次方程式の解を計算する際に 解の一部 = -b/(2*a) を計算しなければいけませんが、この時点でaもbも整数型ですが、これキチンとbをキャストして型をdoubleとかに変更しないと計算が上手く出来ないんですね(笑)。キャストしないと結果がヘンになるんで、キャストを忘れないようにしましょう。 さて、ここまで書けば、あとはmain関数の方でsolveQe関数の「返り値」を受け取って(つまり結果の1、0、-1に従って)、printfで表示を変えるだけ、ってのが残りの作業です。 この辺はイイですよね。ハナクソです。 int main(void) { 　　　int a, b, c, d; 　　　double ans[2]; 　　　printf("a を入力して下さい: "); 　　　scanf("%d", &a); 　　　printf("b を入力して下さい: "); 　　　scanf("%d", &b); 　　　printf("c を入力して下さい: "); 　　　scanf("%d", &c); 　　　d = solveQe(a, b, c, ans); 　　　if (d > 0) 　　　{ 　　　　　　printf("係数a, b, c >> %d, %d, %d\n", a, b, c); 　　　　　　printf("2つの異なる実数解: %.2lf, %.2lf", ans[0] + ans[1], ans[0] - ans[1]); 　　　} 　　　else if (d == 0) 　　　{ 　　　　　　printf("係数a, b, c >> %d, %d, %d\n", a, b, c); 　　　　　　printf("重解: %.2lf", ans[0] + ans[1]); 　　　} 　　　else 　　　{ 　　　　　　printf("係数a, b, c >> %d, %d, %d\n", a, b, c); 　　　　　　printf("虚数解: %.2lf ± %.2lfi", ans[0], ans[1]); 　　　} 　　　return 0; } まあ、こんなモンじゃないでしょうか。
printf文で&a、&b、&cとしていますが、こう書くとどういう値を参照すると理解していますか？ 出力を見るとループ回数は求める通り5回となっていますからwhileループは正しく動いています。 意図したとおり動いていないのはprintf文ということがわかりますよね？ 5セット出力されているa、b、cの値が全て同じというのが大きなヒントです。つまりa、b、cに格納されている値を印字していないということがわかります。 だとすると。。。
> struct { > int num; > int mark[12]; > int no[12]; > } pl[4]; あ、やっぱりそうだ。 C言語で意図しない書き換えがあったときに、まっさきに疑うべきなのが 「配列の確保」と「添字」の関係です。 int mark[12]; としたら、どこまでが「正しく使える範囲」か、よく考えてみましょう。
とりあえず21行目で文字列が閉じてないようですが。
>scanf("%f%f%f%f",&n,&x[0],&v[0],&dt); 辺りで妙なことになりそう…ですな。 # &nじゃなくて&xmではないのかね？まぁxm使っていないみたいですけど。
>解凍先は、デスクトップでした。 UNLHA32に渡すオプションで指定するものかと思われますが…。 COMMAND.TXTにオプションについて記述されている筈ですので確認した方がよいでしょう。 未指定の場合はレジストリに記録されていればそちらに、なければカレントディレクトリではないですかね。 Win32APIのGetOpenFileName()使っているなら指定したファイルのある場所にカレントディレクトリが変更されているかも知れません。 >静的リンク版がどこのソースをどうすればいいのか、わかれば、そうしてみたいです。 UNLHA32.TXTには… > UNLHA32.LIB : VC++ でコンパイルするためのインポートライブラリです。 となっていますので、C++builderでは使えない可能性もあるかと思われますが。
ついでに以下も合わせてみると参考になるでしょう http://marupeke296.com/CPP_charUnicodeWideChar.h …
No.4 > 質問者様ご提示の式には i層の発火条件が含まれていないですよね？ 右端の括弧に記載されていましたね。 重ね重ね失礼しました。
C言語自体にそんな機能は無いので、C言語から使えるライブラリを探してくるか、自作するか、になります。 例えば、ImagaMagickには文字列を画像にする方法が用意されています。 http://www.image-magick.com/font/fontimage/ これは、コマンドからの実行ですが、これを、C言語から扱うためのAPIが用意されています。 http://www.imagemagick.org/script/magick-core.php ただ、ちょっと面倒です。
マウスキャプチャーすればいいのでは(SetCapture/ReleaseCapture)。 他はWM_INPUTとか。
No.2です。 答えだけ知っても考え方が分からないのでは目先をちょっと変えた問題を出されると「教えてください」になるだけです。 で。 > 以下のプログラムはaを0から４の範囲で0.001刻みで変化させた際の分岐図を出力するプログラムですが、以下のプログラムの空欄何が入りますか？ > {xt},t=0,...1000を計算 > t=1001から1200まで{xt}を計算し,(a,xt)を出力 これが問題に提示された“機能”に関わる全文なのだとしたら、求められる処理はどういう物になるのかをここに示された範囲で日本語を使って箇条書きにまとめてみましょう。「・」ではなく「(1), (2), (3)...」という書き方が繰り返し処理のところを書きやすいでしょう。フローチャートの書き方をご存知でしたらそれの方がよりよいです。 日本語を常用する人が日本語で処理手順を書けないということはプログラミング言語でも書けません。 書けない理由は「与えられた入力にないし、要求される出力を行うための処理手順を考えることが」からです。つまり処理アルゴリズムを考えることが出来ていないのです。その場合は答えを見ても「なるほど」と思わないか、思っても本質を理解出来たいない場合が多く、ちょっと目先を変えただけでまたわからなくなります。いろんな初級プログラマーを見て来た経験上そう思います。 なお、処理手順の考え方は個人個人で微妙に違います。相当違う場合も少なくない。なので、ご質問にあるような穴埋め問題の場合は出題者が考える処理手順を読み解くことになります。それにはまず自分の考える処理手順が頭にないとより所がなく理解するのに時間を要します。具体的にはプログラミングレベルだと「何でこんな変数が必用なんだ？」とか「何で初期値がこの値なんだ？」ってあたりからはじまって、、、って感じでしょうか。:-)
まず、 _fastcall TForm4::FormActivate(TObject *) _fastcall TForm4::FormDestroy(TObject *) _fastcall TForm4::ExtractBtnClick(TObject *) _fastcall TForm4::ExitBtnClick(TObject *) がどこにも宣言されてないことに気づいてください。 これは、VCL のイベントハンドラです。 C++Builder の「オブジェクトインスペクタ」を表示させて、 そこに、Form(この場合は、TForm4）を選択してください。 「イベント」のタブで、 OnActive OnDestory をそれぞれクリックし、右側に発生する空欄をダブルクリックすると、この名前で自動的に登録されます。 _fastcall TForm4::ExtractBtnClick(TObject *) _fastcall TForm4::ExitBtnClick(TObject *) は、フォームに乗っているボタンのイベントハンドラです。 同じように該当するボタンを選んで、onBtnClick からハンドラを登録してください。 というか、以上の内容は、C++Builder 自体の操作の初歩です。
> for (a = 0; a <=□ ; □)} for (a = amin; a <= amax; a += da)
>メモリリークということはmallocでメモリ確保しなければいけないということでしょうか？ malloc()で確保したメモリ、どこで解放しています？ 特に最初のループで確保した『複数の』メモリブロックを。 ループ2回目以降のmalloc()が失敗したときも盛大にリークしてますけどね。 # まぁ、そのあとプロセス終了するのでまともなOSであれば問題にはなりませんけど…行儀がいいとは言えませんね。
ちなみに、ディープラーニングは、「ものすごく大量の」データを使える場合には、確かにものすごく強力なアルゴリズムですが、 データ数が少ないと、全くといっていいほど、まともに動きませんよ。（少なくとも、現時点で知られている学習の方法では） データ数が少ない場合には、もっと古典的な機械学習アルゴリズムのほうが、良い性能を出すことが多いです。
「C言語の仕様」としてそうである以上, 「C言語の仕様」としてはどうにも動かしようがありません. 既に指摘されているようにコンパイラや OS を含めた「処理系」全体の話になるので, 「gcc」としかわからない状況ではどうにもなりません (しさらに言えば処理系の詳細が分かってもどうにもならないかもしれない). 以下は余談. C の仕様 (9899:1999 なら section 6.7.8, 9899:2011 は未確認だけどドラフトでは section 6.7.9) に If an object that has static storage duration is not initialized explicitly, then: (この質問に直接関係ないところは省略) - if it has arithmetic type, it is initialized to (positive or unsigned) zero; - if it is an aggregate, every member is initialized (recursively) according to these rules; って書いてあるんだけどね＞#3. ついでに指摘しておくと「プログラムの実行前に初期化される」というのも (別のところに) ある.
No.2です。 質問者様は、実際にプログラムを動かして結果を確認していませんよね？ この問題は実際に動かして結果をみないとわかりにくいですよ。 打ち間違いの修正、不足の関数の追加、その他をしています。 ---test.html---------------------------------------------- <!DOCTYPE html> <html> <head> <title>テスト</title> <script type="text/javascript"> function print(){ var s = ""; var i; for(i = 0; i < arguments.length; i++){ s += arguments[i]; } s += "<BR>" document.write(s); } function henkan(p){ var w; p.r = Math.sqrt(p.x * p.x + p.y * p.y); w = Math.acos(p.x / p.r); p.th = w*180/Math.PI; } var p1, p2, p3, p4; p1 = {x:1, y:1}; p2 = {x:-1, y:1}; p3 = {x:-1, y:-1}; p4 = {x:1, y:-1}; henkan(p1); henkan(p2); henkan(p3); henkan(p4); print("P1: r=", p1.r, " th=", p1.th); print("P2: r=", p2.r, " th=", p2.th); print("P3: r=", p3.r, " th=", p3.th); print("P4: r=", p4.r, " th=", p4.th); </script> </head> <body> </body> </html>
sizeof(ENDMARK) とすると１バイト大きい１２が得られます。 １１が望みなので、 if( strncmp(buf, ENDMARK, sizeof(ENDMARK)-1) == 0 ) { とするか #define ENDMARKLEN (sizeof(ENDMARK)-1) として if( strncmp(buf, ENDMARK, ENDMARKLEN) == 0 ) {　とするか のどちらかでよいかと。
No.3です。 > int i,heikin;とfor (i = 0; i < GAKUSEI_NUM; i++)の" i "は別物でしたでしょうか >　私は同じものばかりと思っていたところですが！ いえ、同じものですよ。 int i,heikin; で変数の使用を宣言して、for(i = 0; i < GAKUSEI_NUM; i++){……}で実際に使用していますよね。 No.2さんが書かれている様に、for文の中で変数i は、0,1,2,3と増加して、i が3（=GAKUSEI_NUMで定義している値）になったところでfor文を抜けます。 ですから、for文の中で使用される変数i の値は、0～2になります。
それは、内容次第でしょう。 ○ まとめて処理(例えば親フォームで入力したTextboxのTextを、Form1〜Form20全ての Textプロパティに設定する、とか)なら、配列やDictionary等にまとめておくのが便利です。 逆に、そういう処理が無いのなら、それぞれの変数にしても特に問題ありません。 また、デザイナでフォームにコントロールを配置すると ・コントロール名と同じ名前のメンバ変数 ・フォームのControlsプロパティ(配列状になっている)の要素 という2種類の方法でアクセスできるようになります。 同様に、 それぞれの変数と、配列の両方を同時に使う、ということも可能です。 ○ 「名前」を使いたいのなら、配列ではなく、enumや文字列をキーにしたDictionayを使う、という方法もあります。 https://msdn.microsoft.com/ja-jp/library/xfhwa50 … ○「それぞれ違う機能」というのが、どんな状況を表わしているのかがわかりません。 入門書にありがちな「動物」クラスとその継承クラス「犬」「猫」「鶏」を例にするなら 　・「動物」に「鳴け」と命令したい 　　　「犬」:ワン 「猫」:ニャー 「鶏」:コケコッコー と「違う鳴き方(=違う処理)」 　・「犬」は「走れ」 「猫」は「寝ろ」 「鶏」は「鳴け」 と違う命令をしたい のどちらに近いのでしょうか? 前者なら、まさしく「オブジェクト指向」的な手法が使えますから、まとめるのが効果的です。 後者なら、まとめるメリットはありません。 　ですが、少し変えて 　・「犬」には「合図したら走れ」 「猫」には「合図したら寝ろ」 「鶏」には「合図したら鳴け」 と覚えさせてから、 　　「動物」に「さっき教えたことをやれ」と命令する とするなら、まとめるメリットが出てきます。 ○「FormAの派生クラス」というのが本当に適した実装なのか、考える必要はあると思います。 　FormAから派生した FormA0,FormA1 を作って、 Form1,2,3 はFormA0, From4,5,6はFormA1 等とした方がいいかもしれません。 あるいは、インターフェース IFromA0, IFormA1 を用意して Form1,2,3 はFormA+IFormA0, From4,5,6はFormA+IFormFormA1 とするのが適しているかもしれません。
> class10の処理が「同じ処理」ならClassA型の配列でいけそうなんですが…。 なら、メソッドを呼び出す側から見て同じ処理にしてしまえばいいんです。 そのためのメソッドのオーバーライドです。 public ClassA { 　// ...... 　public virtual void someMethod() 　{ 　　同じ処理 　} } Class10 : ClassA { 　// ...... 　public override void someMethod() 　{ 　　別の処理 　} } という具合にして、ClassA型の配列で回して someMethod() を実行しましょう。 someMethod() の引数・戻り値はやりたい処理に合わせて修正してください。
代入.
1. while ((value = getc(fi)) != EOF) { 　　fiから1文字読んでvalueに代入、もしファイルの最後だったら6.へ 2. putc(value ^ key[i],fo); 　　　　valueとkey[i]のxor（排他的論理和）をfoへ出力 3. i++; 　　　　iに1足す 4. if (key[i] == '\0') i = 0; 　　　　もしkey[i]が0（終端文字）だったら、iに0を代入 5. } 　　1.へ戻る 6. key = "apple"だとすると、以下の動作になります。 入力の最初の文字と'a'をxorしてfoへ出力 2番目の文字と'p'をxorしてfoへ出力 　… 5番目の文字と'e'をxorしてfoへ出力 6番目の文字と'a'をxorしてfoへ出力 7番目の文字と'p'をxorしてfoへ出力 　以下、入力が終わるまで続く。
何がネックになっているのですか? それによって対策も違うと思うのですが。 例えば: ○準拠する規格(C99 等) ○OS由来の関数 ○コンパイラ独自の実装の違い ○ハードウェア、デバイスを直接操作するようなもの 主な対策としては ○ラッパーを作って、引数の差異等を吸収する ○関数マクロをうまく活用する ○MinGWでGCCを使う ○CygwinでGCCを使う ○VisualStudioのバージョンを変える 数値計算が主だったら、それほど変更は無いと思うのですが。
まずは、その作業をあなた自身がやるとしたら、どういう風になるかを考えてみましょう。 「 文章が書かれた紙1,紙2,....紙n が渡されました。この紙に書いてある文字列をソートして、別の紙に書き出しなさい」 そう言われたら、どんなやりかたをすればいいでしょうか? 例えば、次のようになるでしょう。 1) 紙に書いてある文字列を、単語帳みたいな小さいカードに書き写す。 2) 1)を 紙1〜紙n 全てに行う 3) カードをアルファベット順に並べる 4) カードの内容を別の紙に書き出す この「日本語の手順書」を「『C言語』の手順書」に書き直すのが、プログラミングです。 こうすると「全然わからない」状態から、個別の「ここがわからない」に変わります。 ○./a.out ファイル１　ファイル2　・・・　ファイルn としたときに、ファイル1、ファイル2 を受け取る方法がわからない ○ ファイルを読み込む方法がわからない ○ ファイル1、ファイル2と繰り返す方法がわからない ○ 並び換える方法がわからない .... こうしたら、一部は「ここはわかる」となりませんか? > 線形リスト上で単純選択法を使う 文字列は全部でどれくらいあるかわからない → 長さが固定されている配列では実現がむずかしい → 長さが自由な線形リストがいいだろう ということでしょう。他にいい方法があるなら、そちらを使ってもかまいません。 ※ 線形リスト上で単純選択法を使え、という課題でない限り ただ並び換えたいだけなら、C言語など使わなくても、sortコマンドを使うだけのことです。
いくつかある勉強方の内で僕としては実際に動かしながら目で見て確認できる方法が良いのでは無いか？と考えます。 　初期投資がかなり掛かるのが難点ですが、教材を用意する方法などです。 　およその予算が２万円程度必要になります。 http://www.amazon.co.jp/Raspberry-Pi-%E3%83%A9%E … http://www.amazon.co.jp/Physical-Computing-Lab-T … http://www.amazon.co.jp/Physical-Computing-Lab-T … 　話題に乗って４週間前からいじってますが、話題の”Ｌチカ”（発光ダイオードの明滅）から始めて電子回路を楽しんでいます。 　途中から脱線してサーバを構築しておりました。 　サーボモータの制御ができれば楽しみ方の幅が広がって面白いでは無いですかね。 　ガイドブックはどれが良いのか？はやはりここは技術だけに「技術評論社」が堅実な選択と思います。 ☆好みの問題もあるので書店で目を通してみて良さそうなを選んでみてください。 ＞Raspberry Pi［実用］入門 ＞http://gihyo.jp/book/2013/978-4-7741-5855-6
細かく追っていませんが… >while(cur->next != NULL && cur -> next -> moji != del){ >　cur = cur->next; >} >p = cur->next; >cur->next = new->next; リストの繋ぎ換えが正しくないでしょう。 唐突に出てきたnewはなんです？ 処理としては… ・リストの先頭から探索。 ・削除対象の場合はリストの繋ぎ換え(単方向リストの場合は注意が必要) ・削除対象のメモリ解放(このタイミングでないと機会がなくなる) という感じになるかと。 >for(cur = &head;cur->next != NULL;cur = cur->next) { >　if(cur->next->moji == del) { >　　p = cur->next; >　　cur->next = cur->next->next; >　　free(p); >　} >} こんな感じ？
既にNo.1で述べられていますが ご利用の参考書で、メンバとテンプレートという語が、どの様に説明されているかわからないと回答のしようが無いと思います。 （テンプレートについては別のご質問で回答がついていますね） 構造体でいえば、以下の様に構造体を構成する各要素をメンバといいます。 struct タグ名 {　　　　　※ご利用の参考書ではタグ名がテンプレートと呼ばれています 型　メンバ1; 型　メンバ2; 型　メンバn; }構造体変数名; struct TestKekka　　←タグ名（テンプレート） { 　　char shimei[80];　←メンバ 　　int kokugo;　　　←メンバ 　　int sugaku;　　　←メンバ 　　int eigo;　　　　←メンバ };
配列変数を定義する文法は 型名 配列変数名[要素数]; というわけで struct TestKekka : 型名 gakusei : 配列変数名 GAKUSEI_NUM : 要素数 ご提示の例で言うと、#define にて GAKUSEI_NUM が 3 と定義されているので、 変数 gakusei は、 struct TestKekka 型の配列で要素数は 3 と定義されます。 余談ではありますが、 TestKekka は、構造体のタグ名と呼ばれます。 C/C++ 言語の世界でテンプレートというと、 一般的には別の意味になってしまうので、ご注意ください。 https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3 …
dxfってのは図形情報を規定の方法でテキストデータにしたものだから、内容を理解してその形式で書き出しすればいいのでは。 http://www.phe.jp/technic/dxf_practical.html
とりあえず、if(0 < x1 < v) があなたの意図と違う結果を返している可能性があるので、まずこれ読んで下さい。 https://www.jpcert.or.jp/sc-rules/c-exp13-c.html
Vector1 を for 構文で繰り返し { _ Vector2 を for 構文で繰り返し { _ _ if (1 の値 == 2 の値) { _ _ _ 結果 += 1 の位置と値; _ _ _ break; _ _ } _ } } return 結果;
文法的に間違っていますが、ちゃんと書いたとしてもイコールを含んだ文字列を置換することは出来ません。 置換じゃなくて後ろに付けるだけで良さそうなので、これでいいかと。 @echo off set conf="C:\Program Files\test\aaa.conf" set host=%computername% for /f "usebackq delims=" %%A in (%conf%) do ( if "%%~A"=="Hostname=" ( echo %%~A%host% ) else ( echo %%~A ) )
MATLABはないので、その他(プログラミング) になるんじゃないですかね。プログラムを組む前に、関数の仕様を熟読するのが先ではないでしょうか。関数のセレクションまでは、私も知りません。出題者、もしくはクライアントに問題を確認することが最初の仕事、そしてサンプルのプログラムを組み、動けば、その処理の結果を検証し、この関数でよかったのかどうかを確定するのが、その次の仕事ではないかと思います。
ソースコードはどこぞからのコピペですかね？ ありがちなパターンとしてインデントを全角スペースで示している場合があります。 # 私もここの回答でインデントは全角スペースでやっていますし。 コピペで使う場合は全角スペースを削除して半角スペースか水平タブに置き換える必要がありますけど、その辺りどうですか？ # 全角スペースはSHIFT-JISで0x8140になるかと。 エディタの全角スペースや水平タブを可視化する機能がある場合は有効にしておくといいでしょう。
float f( float x, float v);　　← 実体がありません float fd( float x, float v);　　← 実体がありません main() { 　float x0, v, max_calc, accuracy, x, n, error, newton;　← newtonは関数名に使用されています。max_calc, n は int型であるべきです。 これ以上、書くのが面倒なぐらいデタラメなコードです。 よく見直しましょう。
そのエラーメッセージ自体は そんなファイルね～よ っていってるだけだから, 「指定したファイルがあるかどうか確認しろ」としか言いようがない.
無限の猿定理により、そのうちシェークスピアの作品が打ち出されます https://ja.wikipedia.org/wiki/%E7%84%A1%E9%99%90 …
文法がそうなっているらです。 「c言語 文法　セミコロン　意味」で検索して2番目に出たURLです。 http://kmaebashi.com/programmer/c_yota/semicolon … 1.文の後にはセミコロンがつく。 2.ただし複合文{ }の後ろにはつかない。 3.宣言はセミコロンが付く。
#include <stdio.h> #include <math.h> float factorial(int n) { if (n == 0) return 1; else return n * factorial(n - 1); } float MySin(float x, int n) { int sign; if (n == 0) return x; // is eqauly x^1/1! sign = (n % 2) ? -1 : 1; return MySin(x, n - 1) + sign * pow(x, 2 * n + 1) / factorial(2 * n + 1); } int main() { int i; float x; float pi = 3.14159265; for(i=-100;i<=100;i++) { x=pi*i/100.; printf("%f %f %f %f %f\n", x, MySin(x,0), MySin(x,1), MySin(x,2), MySin(x,3), sin(x)); } return 0; }
三角関数 sin のマクローリン展開による近似値計算ですね。 計算式は既に示されている様なので、あとは C 言語でそれを実装するだけでしょう。 基本構造はこの様になると思います #include <stdio.h> #include <math.h> flaot MySin(float x, int m) { _ float sum = 0; _ int n; _ for (n = 0; n < m; n++) { _ _ // 作業値 = 2 * n + 1 の様に、よく使う値を変数にすると便利 _ _ // 累乗 (-1)^n を計算 _ _ // 累乗 x^(2n+1) を計算 _ _ // 階乗 (2n+1)! を計算 _ _ sum += 各結果を掛け合わせた計算値; _ } _ return sum; } main() { _ float x = 3.14159265 / 3; _ printf("%f %f %f\n", x, MySin(x), sin(x)); } 計算式を実装する際は、以下さえ抑えていれば難しいことはないでしょう * 総和 Σ は for 構文を使う * 累乗 a^b は math.h の関数 powf を使う * 階乗 a! は for 構文を使う、桁あふれに注意 これを MySin.c などという名前で保存してコンパイラにかけて実行すれば解決です
プログラムは実行時に引数を指定でき、コマンドライン引数と呼ばれます。 C言語の場合は、一般に変数 argv からコマンドライン引数を参照できます。 コマンドライン引数をどう使うかはプログラムを作る人の自由ではありますが、 慣習的に POSIX 規格または GNU スタイルに従うことが多いです。 POSIX 規格では、プログラム動作を変更するような オプション指定方法は以下の形式になります。 * 先頭は '-' * その次に英数字1文字 (なるべく英小文字) というわけで if (argv[argc][0] == '-') とは、 プログラム実行時に指定されたコマンドライン引数のうち、 argc 番目の値が POSIX 形式のオプション指定だった場合 ついでに if (argv[argc][1] == 'a') とは、 英数字1文字の 'a' に割り振られたオプション機能が指定された場合 ただし、以下の前提付きです argc <= コマンドライン引数の個数 && strlen(argv[argc]) == 2
ブロックと呼ばれる、Appleによるプログラミング言語の拡張構文ですね。 この場合は、completionHandlerとして実行する処理を、ブロックで記述することを意図しているかと。 くわしくは、「Apple ブロック構文」で検索してみてください。
どの程度速くなるかは分かりませんが、同時のFTP転送は可能です。 ウェブブラウザも同時並行でHTTP接続を行いますが、標準だと4並行くらいのはずです。 クライアント側のポート番号は、自動的に別々のものが割り振られますので、気にする必要はありません。
fprintf 関数の仕様は、 int fprintf (FILE * stream, const char * format, ...); ですが、 この第一引数 stream が示すストリーム(ファイル、デバイスなど)へ書き込まれます。 例えば、第一引数に stdout を指定すると標準出力(コンソール、コマンドプロンプトなど)へ出力されます。 (この場合は標準出力へ出力されるので、ファイルへ保存されるわけではありません) 第一引数へ fopen 関数などでオープンしたファイルストリーム (fopen 関数の戻り値)を指定すれば、そのファイルへ書き込まれます。保存ファイルの場所は、fopen 関数などで指定した場所になります。保存したファイルが見当たらない場合は、fopen 関数などで指定したファイルが「相対位置」か「絶対位置=フルパス」かによって、探す場所が異なります。「絶対位置=フルパス」の場合には、指定したその場所にファイルが生成されますが、「相対位置」を指定した場合には、そのプログラムの「カレントワーキングディレクトリ」からの相対位置(ディレクトリ)へファイルが生成されます。
あれ? クラスB を前方宣言するだけではだめじゃないかな? A::func1 を定義する時点でクラスB を完全型にしておかないと, 結局その中でエラーになる (ならないとおかしい) はず....
> cur→オブジェクト→オブジェクトhead 違います。 最初は cur = &head; により cur は head (オブジェクト)へのポインターを示しています。 つまり、head のアドレスと cur へ代入された値は同じものです。 よって、この時点では cur->next と head.next は同じものをさしていることを意味します。 実行途中で cur = new によって別のオブジェクトへのポインターへ置き換わります。 見難いかもしれませんが、概念図を添付します。
エラーからすると、 ・y1の中に0があって、log(0)=infになっている ・y2の中の0があって、?/0 = inf になっている ・y1,y2共に0になっている要素があって、 0/0=NaNになっている ではないでしょうか。 どんな方法がベストかは、何を求めたいかによりますが、 0 をなんとかする方法を考えましょう。
ディープラーニングではないのですが、人工知能について広く浅くまとめた入門者向けの書籍があります。 　一度は絶版になったあと執筆者の厚意でＷＥＢ公開されました。（無償） 　その後、好評に応えてアマゾンで電子書籍としてダウンロード購入ができるようになっています。 ＞森川くん、人工知能の本をここで再編集。 ＞http://www.1101.com/morikawa/index_AI.html 　もしもゲームソフトで使うとしたら・・・の実例を交えて紹介をしています。
提示の方針で、問題ないと思います。仰るとおり、例外（std::regex_error)のcatchをis_matchの中でする必要があります。 ＞その他何か考慮した方がよいことがあればおしえてください。 単純に、マッチしたかどうかではなくて、マッチした文字列とか部分文字列とかを返したい場合には、文字列のメモリ管理を少しだけ気をつける必要がありますかね。 （たいした話ではないですけど） あとは、細かいですが、 int is_match(char *target, char *pattern) は、 int is_match(const char *target, const char *pattern) にしたほうがよいか。 この場合、is_match関数内で、string strという変数を作る必要がないです。
↓参考までにどうぞ。 http://www.atmarkit.co.jp/fdotnet/dotnettips/490 …
ご要望に応えるために意地になってネット検索を繰り返していましたが、該当する記事を見失ってしまって見つけられそうにありません。 　代わりにＹｏｕＴｕｂｅで投稿されている動画を紹介します。 　要望通りかと思います。 ＞商品をかざすだけで認識、バーコード不要の新開発スキャナ #DigInfo ＞ 　展示会に参加される意思があれば以下の情報を参考にどうぞ。 ＞http://www.nikkan.co.jp/eve/irex/
> if(p -> head == NULL)　　もしｐがなにもなかったら ↑struct node に head というメンバーはありませんよ。 > ノードpの後にノードｑ以降のリストを連結する関数 ↑不明確です。 変数 head と tail がそれぞれ構造体 node の先頭と末尾を示しいるとして、ノードp は head が示すリストへ連結されている一つのノードであり、ノードq はまだ head が示すリストへ連結されていないノードリストであると仮定した場合、 struct node * n; for (n = q; n != NULL; n = n->next) { 　if (n->next == NULL) 　　break; } if (p->next == NULL)　　 /* ノードp は末尾である p == head もしくは p == tail でも確認可 */ 　tail = n;　　　　　　　　/* tail へノードリストq の末尾ノードを代入 */ else　　　　　　　　　　　/* 中間ノード */ 　n->next = p->next;　　/* ノードリストq の末尾ノードの next へノードp の次のノードを代入 */ p->next = q;　　　　　　 /* ノードp の next へ q を代入 */
sum関数の戻り値はvoid型(戻り値は返さない)であるが、計算結果は引数ans(int型へのポインタ)で指定される領域へ格納されるから。
>一行一行ステップオーバーでどこでプログラムが落ちるのかを探す そんなことやらなくても普通にデバッグしてる限りでは 飛んだ段階のアセンブラコードややソースが表示されるはずです 自作関数内でなかったのであればスタック情報たどれは大体の見当は付けられたはずです （通常そういった方法で確認してるので） 一発で分かる方法ってのは　　知りません
数学の用語と同じです。 数学で言うと、 2x + y + 3 = 0 のような式で、x や y という文字が変数です。 y = f(x) この f が関数で、x が引数（変数でもある）、y が関数の値（変数でもある）。 Cだと、 ch = getchar(); ch が変数、getchar が関数、この場合は引数は無し。 n = printf("%d",x); printf が関数、"%d" が引数、x も引数、x はまた変数でもある。n も変数です。
うん, 手元の Visual Studio 2012 で適当に進めたらきちんと動いた.
#include <stdio.h> void print(char c) { if (c != 'a') { print(c - 1); } putchar(c); } int main() { print('z'); return 0; }
ちょろっと見た感じではターミナルに依存するっぽぃ.
０＜ｘ＜１　０＜ｙ＜１の乱数を作ります。 ｘ＾２＋ｙ＾２＜１の範囲にあれは、あたりとしてカウントします。 それを１万回繰り返して あたりの数／１万で１辺１の正方形のなかで４分の１の円の中に入ったあたりの確率が分かります。 それを４倍すれば円周率になります。 　ここで円を４つに分けたくないとなれば ０＜ｘ＜２。０＜ｙ＜２にして （ｘ－１）＾２＋（ｙ－１）＾２＜１でカウントすればいいと思います。
こんにちは 趣味でプログラミングをしている者です。 独習C http://www.amazon.co.jp/%E7%8B%AC%E7%BF%92C-%E7% … C言語について網羅的にわかり易く解説されている書籍だと思います。 ただし、Windowsでコマンドプロンプト使用を前提にしている書籍です。一応冒頭にコマンドプロンプトでの使用方法の説明がありますが、もしかしたらプログラミング初心者の方にはわかりにくいかもしれません。 この手のご質問を拝見して常々感じていることですが、他の人の薦める書籍が必ずしも自分にとって良い書籍とは限りません。できる限り書店で実物を確認してから購入することをお勧めします。
> if((strcmp(year_L,year_search)==0)&&(strcmp(year_R,year_search)==0)){ ↑この構文が成立することはありえません。 変数year_Lと変数year_Rには違う値が代入されているのに、一つのyear_searchで比較しているので、この if 文が成立することはありません。 添付のようにしてみては如何ですか。
#1 と同じことですが. システムは書かれてないけど Windows 以外で C# を使うというのはよくわからんので Windows だと仮定する. DirectSound を使えば「一定量の再生を行ったらプログラムに通知させる」ことができます. もちろん厳密には「一定量以上の再生を行った」ですが, 「特定の位置にあるデータを再生した」ことでトリガーされるので誤差がつもることはないはずです. https://msdn.microsoft.com/ja-jp/library/ee41874 …
使う環境や言語によります。 数値計算やりたいならそれ専用の言語を使います。 MATLABが有名ですが、フリーで使える類似の環境がいろいろあります。 http://matome.naver.jp/odai/2136163231573327601 Java,C++Pythonなどフツーのプログラミング言語でやるにしても、行列演算のライブラリを使います。 そういう言語で学生のプログラミング課題なら、単純にfor文でも使うでしょう。
そもそも switch だって「あらかじめ分岐の個数がわかっている場合」なんだけどなぁと思いつつついでに. 「分岐がわからない場合」というのが「どれだけあるのかプログラムを書いている時点ではわからない場合」というのであれば配列を使うのが自然かな. もちろん線形リストとか B木とかをがんばって作っても構わんけど.
目的次第です。 目的は何ですか？
> ならばためしにint main (int akb48, char * nogizaka[]) > しても、コンパイルはできましたので、とくに引数自体を変えてもプログラムには影響はないみていです。 ↑当然です。 argcもargvも単なる変数名です。任意の変数名を使用することができます。(もちろん他の変数と重複しないこと) > このプログラムは構造体とポインタのコラボレーションなので int main (int argc, char * argv[]) がないと、 > このプログラムは成り立たない。 ↑「構造体とポインタのコラボレーション」かどうかは別にして「このプログラムは成り立たない」←そんなことはありません。 main関数がないと「このプログラムは成り立たない」という意味に於いてはその通りですが argc、argv変数が必ずしも必要というわけではありません。(コマンドライン引数を使用する必要がなければ) int main (void) と書くこともできます。 > int main (int argc, char * argv[]) ↑この書き方は、あくまでC言語が開発されて以来の慣習・習慣です。 試されたように、int main (int akb48, char * nogizaka[]) と記述することもできます。(自由です、ただし、おススメはしません)
センサーには誤差が必ずあります。更に、誤差にもさまざまの誤差があります。 （１）オフセット 　現在貴方が経験していますように、設置条件により何もないのにあるかのように０ではない値が検出される。 （２）線形誤差 　加速度が１０の時に、センサー出力値が１００だとして、加速度が２倍の２０になった場合、センサー出力値が２００にはならず、１９９の場合もあれば、２０１かもしれない （３）シンメトリー 　加速度が１０の時に、、センサー出力値が１００だとして、加速度が－１０（減速）になった場合、センサー出力値がー２００にはならず、ー１９９の場合もあれば、ー２０１かもしれない （４)環境によるブレ 　その時の温度により同じ加速度でも検出される値が異なる。あるいは振動によっても値が異なることがある。 （５）量子化誤差 　定期的にセンサー値を取得していますが、取得していない時のセンサー値は無視されています。その影響が反映されていません。 　このように様々な誤差を含んだセンサー値を積算するということは、誤差をどんどんと増やしているということです。 つまり、加速度センサーから速度を求めるのはとても難しいということです。これを経験させるために、課題を与えられたのかと思っていました。
一般的な言い方で「プログラムはmain関数から始まる」と言われますが、実はこのmain関数が実行される前に色々やらなきゃいけないことがあるんです。その一つにご質問のmain関数への引数を用意することがあります。コマンドラインで指定された文字列をmain関数の引数として準備してmain関数を呼び出すことが、色々な言語、OS、などで取り決めされています。(もちろん、これらの処理がない言語やOSも存在します)我々は、あまりこれらのことを気にしてプログラミングする必要はありません。というか、気にしなくていいようにしてくれてるんです。従って、そういう機能が知らない間に提供されているということです。ちなみに、ご質問にはありませんが、ご質問のプログラム中のargv[0]には常にプログラム名称が入ります。よって、指定した引数は常にargv[1]以降へ順番に配置されます。
http://www.glfw.org/download.html ↑ここからコンパイル済みライブラリをダウンロードして解凍し、lib-mingwフォルダにあるglfw3dll.aをlibglfw3.aへリネームして使う必要があります。
＞Office2010にあるような背景除去(静止画)のプログラムをC++で書きたいと思っています。 期待されている回答ではないと思いますが、 あるものは有効利用する、という設計方針で、 「Office2010を呼び出して、背景除去した画像を受け取る」というプログラムをC＋＋で記載するのではダメですか？
Fortran77 に限定. 1 はたとえば整合配列を使えばいい. 2 に対する「どんな処理系でも使える方法」は「あらかじめ余裕をもって配列の大きさを決めておく」だけのはず. もちろん処理系によってはライブラリで動的メモリ確保ができるようになっているかもしれん.
こんにちは 第4版冒頭の「第4版にあたって」によると 明瞭性に主眼を置いた「第3版」の改定新版であり、前回の改定と同様に大幅な改定は行っていない旨の記載があります。 あとは、Windows Vista対応と、GNU CコンパイラのCD収録くらいですね。 なので買いなおす必要はないのではないかと思います。
VS2010だと、EFは別途インストールしないと駄目ですよ http://codezine.jp/article/detail/6470 下の方に「Expressの場合」が書いてあります。
OpenSSLライブラリには、公開鍵暗号（RSAなど）の実装（かなり最適化されています）も何種類か入っているけど。 （SSLプロトコルじゃなくて、OpenSSLライブラリのことですよ。念のため。） ＞AES,Serpent,MARS,Twofish,Misty,RSA,楕円曲線暗号 自分で再実装したんなら、それ使えばいいのでは？ 結局のところ何を探しているのですか？
御意＞#4. 忘れてました. 個人的には [lvalue] としたいところ.
そういう事情があるなら、面倒かもしれませんが、最初から順番にやりましょう。 難易度は決して高くはありませんが、何も基礎が無い状態ではわからないでしょうし、解説を聞いたところで理解できないでしょう。 ここくらいまでなら、独習でなんとかなります。 #2で私が「わからない」と書いたところも、過去の問題で解説したからこの問題では省略する、ということなのでしょう。 /* そんな状況を考えても、いい問題だとは思えないけど。 */
これ。
言葉足らずだったので追記します。 Mono実装のC#も文法は同じです。VC#よりバージョンは古くなります。 C#はISO規格化されているのでVBとVBAの様に差があるわけではありません。 MonoDevelopと言うアプリケーションの統合開発環境とか、Unityと言うゲームエンジンなどで使われています。 これらはLinuxやMacでも利用可能で、Win/Mac/Linuxに同じソースコードでアプリケーションを公開できます。
d（ディー）ｂ（ビー）という文字です。 C言語のソースコードはテキスト形式ですから、そのような文字が含まれます。 文字の羅列に意味を持たせて定義することもできます。 定義元を探してみては？ dbが引用されるよりまえのソースを関数・変数・プリプロセッサ定義までさかのぼってください。
スキャンした書籍の内容を公開していますが、著作権的な問題はクリアされていますか？ > 312ページの”構造体のメンバアクセス”から意味が分からなくなって困っております。 > 皆様！この参考書は確かなことを書いてあると思われますでしょうか？ ここで書籍の記載内容に問題が「ある」「ない」と回答されても、質問者様の理解になんら寄与することは無いと思われます。 「どの部分」が理解できないのか「具体的に」「質問者様ご自身」の言葉で質問された方が良いのでは無いでしょうか？
「イベント」って理解できていますか? 「ラベル がクリックされたら通知」だったら書けますか? 「クリックされたら」は、「Clickイベントが発生したらイベント処理」というプログラムになっているはずです。 同様に 「ラベルの文字が変更されたら」 も「イベント発生 したらイベントの処理」 というプログラムを書きます。
既に書かれてるけど, もともとの質問にあった 言葉\n 言葉，記号\n 空白の行\n 言葉\n 空白、数字、数字、数字\n 数字、数字、数字、数字EOF という形と「csvファイルをメモ帳で開いたときのモノ」である ???, ????,#### , ?, 10,11 21,22 が全く違うって理解できる? それはさておき, 本当はどういう形なんだ? まさかここでまた違う形を出して「本当はこうです」とか言わないだろうな? 以下本題ではないけど誤解するといけないので補足. char buf[100]; scanf("%s", &buf); が「正しく」動くとはいっても, それはあくまで「結果的に」であって, 論理的には間違っています. これが「正しいプログラムである」とは思わないでください.
カンマで区切ります。 Basho(int x,int y):House(x), yy(y){
＞この時、どのように考えればよいのでしょうか？ 始点とすべての点を結んだ新しいグラフG'を作って、「G'での巡回セールスマン問題」として解いたらいかがです？
> もし、上記サイトのe_log.cの内容を、通常のプログラム形式で表示(拝見)する方法はありますか？ ダウンロードして保存して、テキストエディタで開いてください。 その e_log.c はC言語のソースコードそのものです。 実際にコンパイルするには http://www.netlib.org/fdlibm/ にある一式が必要かもしれません(試していません) 中を見ると、 メインの部分は sqrt(2)/2 < 1+f < sqrt(2) のときの log(1+f) を精度よく近似するものです。 この範囲を越えるような x については、 x = 2^k *(1 +f) となる k を探して (1+f) の対数を計算し、その後、元のlog(x)になるように計算しています。 log(1000) なら、 log(1000) → log(2^10 * 0.9765625) → 10 * log(2) + log(0.9765625) と変形してから、 log(0.9765625) を求めます。 学校で習ったかと思いますが、logには「底の変換」等いくつかの公式があります。 log_a(x) を直接計算できなくても、 これらの公式を使って「計算できる底、真数だけの式」( t + s・log_b(y) 等)に変形すれば計算できます。 これはFdLibm というライブラリでの1例であって「一般的にこのアルゴリズムが使われている」というわけではありません。 実際に、glibcでは別のアルゴリズムが使われているようです。 底や真数によってアルゴリズムを使い分ける場合もあるでしょう。 Visual C++での実装や IntelのCPUに組み込まれた実装は、アルゴリズムが公開されているわけではないので、何が使われているかわかりません。 正解が一つではないので、回答も曖昧にせざるをえません。
まず ・なにをどうしたいのか ・何がどうなることを期待して、それがどうなっているのか はっきりさせましょう。 添削希望とありますが、上のようなことがわかならければ、明らかなエラーでもない限り、ベテランでも直しようがありません。 エラーを無くすだけなら簡単です。 「何もしない」プログラムなら、エラーは出ません。 まず、次の箇所は基礎なので、もう一度ちゃんと勉強してください。 Basho(int x,int y){ House(x)=x; } コンストラクタの書き方が、明らかに間違っています。 また、ここでの変数yがどこにも使われていません。 下の方にswitch(y)とありますが、別の関数なので、同じ名前でも違う変数です。 // ついでに、main関数にも int y; y=p; とありますが、これも違う変数です。 変数の有効範囲(スコープ)は重要です。 Basho.ques(); インスタンスのメソッドと クラスの(staticな)メソッドを混同しています。 インスタンスのメソッドを呼び出すには、インスタンスが必要です。 Basho.result(); インスタンスに直しても、エラーになるはずです。 それは resultメソッドが定義されていないからです。 定義されていない理由は ・本当に定義されていない ・このresult という名前が間違っている ・resultのつもりで別の定義をしている のどれかです。 ーーーーー #2でいろいろと添削されていますが。 ・インスタンスメンバ変数 budgetをpublicに移動 ↓ C++やJava等のアクセス制限がある言語で、その制限をむやみに変えるのは御法度です。 privateにしてあるのは、外部からその存在を隠してアクセスさせないため、のはずです。 　本当は公開するはずのものを間違えてprivateになっているなら、 public にしてもいいです。 　ですが、プログラムを見る限り、budgetは Houseの派生クラスであるBashoクラスだけでの使用を想定しているように見えます。 　それならば、派生クラスからアクセスできる protected にするのが妥当です。 ・Basho型変数bsを宣言して使用 ・関数spotをコメントアウト spotは関数ではなくて、Bashクラスの変数では。 spotの行をコメントアウトするのではなく、 順番を入れかえて 「Basho型変数spotを宣言して使用」とするのが期待している動作と思われます。
fp = fopen("filename", "r"); の箇所のfilenameの両端のダブルクオートをはずしてください。 fp = fopen(filename, "r");　・・・のようにしてください。
そのソースコードはShift-JISコードが含まれていますが、ご使用のコンパイラがShift-JISのサポートをしていないか、コンパイラのオプションでソースコードのコード体系(この場合Shift-JIS)を指定する必要があると思います。もしくは、ソースコード中の漢字やカタカナなどを全て削除すれば、とりあえずコンパイルできると思います。
拝見、しました。 scanf("%d %d", &kari_nyuuryoku.tanka,　・・・・の行のtankaが もれています。そこが緑色になっていれば、完璧です。
アンダーフローの例外を起こしていないだろうか？ 例外を起こすと割り込み処理が発生するため大変遅延する。 まぁ、対処方法としてはアンダーフローを起こさないようにするって事ぐらいですね。 コンパイラとOS環境などに依存するので、こちらでは確認が困難。
それって、コピーになってなくて、 他プロジェクトのX.cs 等を、そのまま現プロジェクトから参照するものです。 X.csを現プロジェクト用に修正すると、元のプロジェクトでもX.csが書き変わってしまうでしょう。 > FormXオブジェクトの定義がエラーになってしまう 具体的なエラーメッセージは何でしょうか? エラー番号は? いくつか考えられます。 ○ FormXクラスが本当に定義されていない ○ namespaceや上位クラス等が違っているため、X.cs内のFormXを FormX だけで呼び出すことができない ○ X.csで定義されているのは「FormX」ではない。 ○ FormXの定義に問題があり、利用できる状態になっていない。 ○別プロジェクトにしたことで、X.csをコンパイルするのに必要なもの(元プロジェクトの別ファイルにあるメソッドとか)が使えなくなっている。 ○既に同じ名前のものが定義されている ○private/public等の違いで呼び出すことができない
void * は汎用ポインタといって、特定の型を指さないポインタ。 ポイント先を参照するときは必ずキャストが必要。 任意のポインタは汎用ポインタにキャストなしで代入できる。 void ** は汎用ポインタへのポインタ。
たとえば・・・ですが、以下のような説明サイトがあります。 ＞[C#] 画像の拡大・縮小 (イメージのリサイズ) ＞http://www.ipentec.com/document/document.aspx?pa …
c言語ならswitch文を調べれば出来るでしょう。 それが理解できないなら目的に対して完全なスキル不足です。 LED1個から始めましょう。
>厳密にいえば「ハッシュ」よりも「連想配列」の方が >適当ではないかと思いますが 仰る通りなんですが、最近は連想配列といっても 若い人には通じなくて・・ ハッシュも本当はハッシュテーブルが正しいですが、 perlやJSではハッシュなんで染まってます(^-^;
具体的に、どんな方法を取ったのですか? 状況が再現するような最低限のプログラムにして補足してください。 具体的に、どんなエラーなのですか? 意訳されても判断にできません 単に、呼び出し方法が間違ってるだけな気もします。
位相係数モードじゃなくて位相計数モードですね。 残念ながら、1セット(TCLKA,B)しかありません。 画像は仕様書の抜粋です。
for(i=0;i<36;i++) ・・・ /********************この部分を挿入*****/ for(i=0;i<36;i++){・・・・・・・（１）この箇所で外側のｉの値を破壊する ・・・・ ｝ /************************************/ ・・・ } のようになっています。 （１）の箇所で、外側のiの値を破壊しています。 （１）のｉをｉｘなどの別の変数にして下さい。
#No.1です。 >kosuu[10];をakb[10];変えたところ　以下の　errorでてコンパイルできません！？ > example10.c(15) : error C2065: 'kosuu' : 定義されていない識別子です。 宣言している変数名を変更したら、その変数を利用している場所（エラーメッセージで15行目と書かれています）の変数名も変更する必要があると思いませんか？ 下の例で、1行目も変数をaからbに変えたら、2行目,3行目のaも、bに変える必要があのはご理解いただけますよね？ 01: int a; 02: a = 10; 03: printf("a=%d\n", a);
#1 の最後で指摘してされている点はどちらもエラーですな. ポインタ変数に 0 を代入するのは OK だけど, 関数名から変換されたポインタ値に代入するのはさすがにアウト. あと, 値を返す (つまり返り値の型が void でない) 関数は, main を除いて返り値を伴う return の実行が必須 (main だけは「return を実行しなかったら関数の最後に return 0; という文があるものとみなす」ことになっている). 以下おまけ: まず, 「judgement」は関数名としてどうなんだろうか. 判定して bool値を返すのはいいけど, この名前から「どういうときに true を返してどういうときに false を返すのか」は読み取れないねぇ. この手の「ひどい名前」は有名なソフトウェアでも見かけることがある (そしてときどきバグが混入している) んだけど, やっぱり気を付けた方がいいと思うな. それから return static_cast<int>(((damage_seed)* 3 >> 2) + (1 >> 2)); の部分は ・damage_seed になぜ括弧をつけているのか ・1>>2 の結果は 0 だから加算の意味がない ・右辺はそもそも int なので static_cast が完全に余計 と, 無駄だらけ. ついでにいうとこの計算結果が damage_seed より小さいことに気づいてる?
＞たとえば、同じクラスにの中に”中村君”が３人いた場合先生が「中村君」と読んだら 　例え話として回答をします。 　仮に中村君が３人居たとして区別が付くか？極端な話、「同姓同名しかも誕生日も一緒の中村君が3人居たらどうするか？見分けられるか？」。 　というのは区別が付きます。 　「学生番号が違うので識別は可能」。
以下はg++のMANページの抜粋です。 -fopenmp Enable handling of OpenMP directives "#pragma omp" in C/C++ and "!$omp" in Fortran. When -fopenmp is specified, the compiler generates parallel code according to the OpenMP Application Program Interface v3.0 "<http://www.openmp.org/>". This option implies -pthread, and thus is only supported on targets that have support for -pthread. つまり、OpenMP API3.0に準拠したコードを自動生成するけど、pthread(POSIX Thread)が暗黙の内に使われるからpthreadライブラリをリンクしてね。OpenMP API3.0に準拠した「パラレルコード」が必要なら-fopenmpをつけてさらに-lpthreadも必要ということです。そうでないなら、このオプションは要らないです。
int a[5][8]で下記のような感じで確保されます。 [0][0] [0][1] [0][2] [0][3] [0][4] [0][5] [0][6] [0][7] [1][0] [1][1] [1][2] [1][3] [1][4] [1][5] [1][6] [1][7] [2][0] [2][1] [2][2] [2][3] [2][4] [2][5] [2][6] [2][7] [3][0] [3][1] [3][2] [3][3] [3][4] [3][5] [3][6] [3][7] [4][0] [4][1] [4][2] [4][3] [4][4] [4][5] [4][6] [4][7] >void setw (int *b, int m, int n, int dat) /* 初期化を行う関数 */ >{ >　int k; >　for (k=0;k<n;k++){　 -----------------------　　① >　　*(b[m] + n) = dat;　　-----------------------　 ② >　　b++; >　} >} ループ1回目のそれぞれの変数は…… bがa[0][0]を差しています。 >*(b[m] + n) = dat; により、b[5]でa[0][5]でさらに+8した箇所(a[1][5])を差します。 >　b++; により、bはa[0][1]を差すようになります。 ループ2回目で >*(b[m] + n) = dat; により、b[5]でa[0][6]でさらに+8した箇所(a[1][6])を差します。 >　b++; により、bはa[0][2]を差すようになります。 ループ3回目で >*(b[m] + n) = dat; により、b[5]でa[0][7]でさらに+8した箇所(a[1][7])を差します。 >　b++; により、bはa[0][3]を差すようになります。 ループ4回目で >*(b[m] + n) = dat; により、b[5]でa[1][0]でさらに+8した箇所(a[2][0])を差します。 >　b++; により、bはa[0][4]を差すようになります。 ループ5回目で >*(b[m] + n) = dat; により、b[5]でa[1][1]でさらに+8した箇所(a[2][1])を差します。 >　b++; により、bはa[0][5]を差すようになります。 ループ6回目で >*(b[m] + n) = dat; により、b[5]でa[1][2]でさらに+8した箇所(a[2][2])を差します。 >　b++; により、bはa[0][6]を差すようになります。 ループ7回目で >*(b[m] + n) = dat; により、b[5]でa[1][3]でさらに+8した箇所(a[2][3])を差します。 >　b++; により、bはa[0][7]を差すようになります。 次のループでkがめでたく8になりますのでループ終了です。 a[1][5]からa[2][3]までは値が設定されますが、他の部分は未初期化ですので不定値となります。 　int k; 　for (k=0;k<(m * n);k++){ 　　*b = dat; 　　b++; 　} とか、 　int k,l; 　for (k=0;k<n;k++){ 　　for (l=0;l<m;l++){ 　　　*(b + (k*m) + l) = dat; 　　} 　} とかにするべきなんじゃないですかね？ 「ポインタｂにより直線的（連続的）に」だと前者かと思われますが。
変数を宣言しただけだと、その変数がどの様な値かわからない状態です。 ですから初期化して、この変数の初期値はこの値です、と、明確にする必要があります。 例えば、件のプログラムの数行後の while(kari_nyuuryoku.tanka != 0){ 　省略 } で、whileの条件式で、変数kari_nyuuryoku.tankaがゼロであるか否かを判断しています。 ここで変数kari_nyuuryoku.tankaの値がわからないと、正しい判断ができなくなります。
＞技術評論社に問い合わせて3日が過ぎましたが、まだメールでの回答が来ません 　まあー、仕方が無いですね。 　出版社から執筆者に問い合わせを転送して内容を確認してから回答をして貰い、技術評論社がそれの質問している人へ回答として寄越してくる。 　まあだいたいは30日程度はかかるかもしれない。（必ず回答が寄越されるという意味では無い） 　先日のリンク先の出版情報に依れば2009年の出版物ではね・・・。
ついでにいうと scanf("%d,&x"); もおかしい. 細かく言えば printf("How many number do you want to type?"); も変だな.
Thread.Joinメソッドを使うことで、スレッド終了まで待機することができます。 https://msdn.microsoft.com/ja-jp/library/95hbf2t …
質問者の反応がまったくないので, 生存チェックも兼ねて確認してみよう. #1 にもあるんだけど, 同一の月日が 3年以上あったらどうするの? 例えば, 例の最後の行が 888,2014/09/09,412 じゃなくて 100,2015/04/01,204 だったらどんな結果がほしいの? それとも, そんなことはこの世の終わりまで決してありえないことなの?
「2行目のデータ」って, どこにあると思う?
トラディショナルC言語は、アセンブリ言語（マシン語、ネイティブコード）が 主流であった時代に意識されたものですから、配列の先頭とポインタは同じ扱いになります。 values[10] は、*values の使用を許可しており、 *values の定義は、values[] の記述を許可している意味になります。 アセンブリ言語では、[]のような便利なものが無く、ポインタしか存在しません。 これに対して、 「[]って記述したら、ポインタを上手に使って、プログラマの意図したようにコンパイルします。」 というのが売りです。 当時のプログラマは、これに感心して、 「便利だわ～。俺もCに乗り換えようかな。」 とか思っていたわけです。 当時のユーザーはポインタのほうが考えやすかった。 こういうユーザー配慮がある以上、ポインタのほうが優先されるわけです。 昨今では、この使い方が危険だとし、ワーニングを出したり、禁止するコンパイラもあります。 この禁止の思想はコンパイラや規格により方言として扱うのが宜しいでしょう。 同様にC++も、C言語になれた人に如何にしてアピールするか悩んで作られています。 このために、構造化とオブジェクト化の敷居が曖昧であり、 オブジェクト言語としては使いづらいものになっています。 このように、 言語仕様と言うのは、常に不完全であり、そのたびに新しい言語が登場しています。 初心者ですと、 「この様に書いたら、だめだった。」 と言う部分で悩むでしょうから、 「どの様に書いたらよいでしょうか？」 と考えてしまい、視野が狭くなります。 その前には、 ・この言語は何に適しているのか？ ・パターンと成る記述方法（考え方）はどんなものか？どんな特徴があるのか？ ・何を苦手とするのか？ と捉えないといけません。 プログラミングの本質を大雑把に理解し、 開発直前に言語仕様を調べて開発を行い、終わったらすっかり忘れる。 これが正しいあり方です。 言語を学ぶにあたり、記述方法を覚えていくと限界があります。 何を想定して作られた言語なのかを知ると良いと思います。 そうすると、 ・きっとこうなっているだろう。 ・と思っていたら、そうじゃなかった。 という二つの発想で覚えていくことが出来ます。 例えば、初心者向けの本にはprintfと相対して、scanfが良く記述されています。 しかし、慣れてきますと、 scanfの変換動作がわかりづらく、これをパワーユースすることを嫌うようになります。 C言語を使う人は、文字列をメモリ情報として扱い、これを直接操作して、 文字列操作を行うことを好みます。 printfは、メモリ情報を文字列に変換してそのまま出力デバイスに送信します。 デバイスを直接操作する部分は、OSに任せたいところですので、 最初のほうは好意を持ってしようします。（ファイル操作ぐらいまでは）。 しかし、 C言語が本当に活躍するのは、多様な出力デバイスを扱い、 リッチでスピード感のあるアプリケーションやハードウェア操作をするとき ですから、 printfは、存在そのものとして価値がなくなってしまいます。 （コンソール画面に文字しか出せないものですから） この様に、言語そのものの仕様というのは、個人のスキルの上達には直接関係なく、 言語が何に適しているかが大事に成ります。 C言語の場合は、実際のコンピューター上のメモリを直接読み書きする思想です。 例えば、 あるメモリ領域がVRAM（画面情報をセーブしたメモリ）であると想定した場合、 これを０で埋めてしまえば（大概の仕様では）画面が黒色で埋まります。 このときに、画面上での座標はVRAMの先頭アドレスから計算して何バイト目に 相当するか計算できます。 横が2048ドットであり、1ドットが32ビット＝4バイトであり、 横列終わった後、次の行が続いているとします。（大概はそうなっている。） ｘ＝１５、ｙ＝１０とした場合、（共に０から始まるとする） オフセットアドレス　＝　（（２０４８＊１０）＋　15　）　＊　４； となりますよね。 これにより、ｘ、ｙ座標が何バイトめになるかわかります。 そこに直接カラー情報を書き込めば、描画プログラムを作ることも可能です。 この様に、C言語はメモリを直接操作したり、これを繰り返してループする場合 に優れています。 そして思想と言うのがあります。 例えば文字列操作で、文字列を分割する操作があったとします。 splitなどと良く言われています。 ”abc,def,ghi,jkelm" という文字列から','で区切られた文字列を取り出す場合、 ①元の文字列を配列にコピーする。 ②出力となる文字列アドレスの配列を定義する。 ③①の配列を1文字ずつ調べていき、','を見つけたら０で埋める。 ④③と同時に、０で生めた場所＋１のアドレスを②の配列に記録していく。 　（注：最初の文字が','でなければ、元の文字列の先頭を②にあらかじめ入れておく） ⑤①と②を出力として返却する。 　（注：返却する①②の配列の上限は予め定め、仕様とし、オーバーしないようにする） このとき、 もとの文字列を明示的に*つきのポインタとして受け渡し、 コピーした左記の①は配列としておき、[]で操作する。 ②も[]で操作します。 返却する場合は、[]で返したいところですが、これが（つまり「あれ？できないぞ」） 仕様上無理なので、呼び出し側が[]で確保しておき、ポインタを与えます。 int stringSplit( char **outputStrings , char *outputStringsBody , char *inputString , char splitChar , int maxOutStrings ) outputStrings: 出力文字列の先頭アドレス配列　② outputStringsBody:分割された文字列の格納先　① inputString:分割したい文字列 splirtChar:分割するタグに沿うとする文字 maxOutStrings:分割したとき、バッファが溢れないように制限した、最大文字列数 リターン値として、分割された文字列数を返します。 みたいな関数として作成できます。 こうした関数は、既に質問者さんが知る言語仕様だけで作成できます。 使い勝手もよろしくて、個人で作製されている人も多数いるでしょう。 C#では、string.Split( ',' )のように記述できます。 あらかじめライブラリとして用意されていると言う事です。 もちろん、for文を使用して自分で作成できますが、C＃やJavaなどはC言語と違い、 直接のデータ操作が苦手です。（ループ記述での繰り返しは比較にならないくらい遅い）。 そのため、多くのライブラリを用意し、なるべくループ動作をしないように配慮しています。 C言語を使う人は、これらを嫌い、全部自分で作ります。 これ以外の言語は、ライブラリ仕様をどれだけ良く知っているかという部分が大事になります。 思想と言うのはこの様に言語により違ってきます。 C言語を使う場合は、最初の導入の記述を覚えたら、 ・配列とポインタ操作で、如何にして便利な自分ライブラリが作れるか？ に進み、 多言語にあるライブラリ（もちろんC言語でも）に相当するものを、 自分で作ろうとしてテーマにし続けることが大事です。 つまり、C言語は覚えることが少ないのであっけなく、習得は終わります。 その後が長いわけです。 どこまで、 「他人が作った物と同じモノを自分だけで作れるか？」 だけが上達になります。 もう、大体の記述を覚えているようですから、 文字列操作系のライブラリを全部自分で作ることをお勧めします。 ベンチマークと言うのがありまして、 （数万回実施したときとか）、どのくらいの時間差になるのかを、 自作の場合と比較します。 こうしたものしか利点がありませんので、 既存ライブラリより早いスピードで動くものを作れない場合は、 C言語をつかう意味はあまりないと言って良いでしょう。 上達とは、これを指しますので、文法上での検討は、わからないとき本を読む程度にし、 数日でおわらせて、（繰り返しメモリ操作での）ライブラリ自作を死ぬほどやってください。 文法上では多くのC言語プログラマが知っていることは、もう知っているはずです。 ここから如何にしてLinuxが作れるのか？ 如何にしてSkypeが作れるのか？ はたまた如何にしてオンラインゲームが作れるのか？ そこに秘匿されたノウハウがあり、壁になるのです。 通信を扱うアプリケーションなどでは、TCP／IPそのものが適していない場合があります。 こういうときは、UDPなどからTCPに相当する通信スタックを自作します。 これを数日で出来ないようですと、仕事そのものが納期に間に合わない場合もあります。 例えば、音声のコーダ（圧縮）が高くて、自作したことがあります。 買うと実験用だけで数百万円もしました。 これは半日で作ることが出来ました。 ライブラリ仕様を調べたり、製品の納品を待つ間の時間よりも、 自作でのスピードが速ければいい。 こういう種族がCプログラマです。 以上、ご参考に成れば。
昔、一度C++でプログラムを作ったのですが、全く動かず、あきらめました。 ですから、この書き込みは適当に読み流してください。 'System.AccessViolationException' のハンドルされていない例外が発生しました。 追加情報: 保護されているメモリに読み取りまたは書き込み操作を行おうとしました。他のメモリが壊れていることが考えられます。」 で検索したらいっぱいヒットしたサイトが出てきましたけど。 たとえば、C#のようですが http://bbs.wankuma.com/index.cgi?mode=al2&namber … で、 > AccessViolationException が発生すると言うことは、本来、確保しておくべきメモリを確保していなかったり、足りなかったり、あるいは間違った渡し方をすることでその関数の実行に失敗するか、他のオブジェクトなどが使っているメモリを壊してしまうかという被害が発生します。 > 今回のケースでは StringBuilder にあらかじめ確保しておく文字列バッファ（260 文字ぐらい？）を用意していなかったため、別の場所のメモリが破壊され．．． といった記述があります。 shoboyさんのプログラムは私にはさっぱりわからないので、どこが間違っているかはわかりませんが... もっと詳しいことを求められているのでしたらごめんなさい。
名称は無いと思います。 ツールバーのメニューにあるコマンドで、そのコマンドを押すとすぐに何か影響が出るたぐいのものがあります。 たとえば [表示]-[詳細] とか [表示]-[小アイコン] とか。 コマンドを押しても直接影響がでず、別の画面やウィザード等に続きを引き継ぐようなコマンドの場合は、コマンド名の後ろにドットを3つ付ける慣習があります。 昔はソフトウェアの UI 設計のためのデザインガイドとかに書いてあったのかもしれませんが、最近の状況はまちまちでしょうね。
> tanka_kosuuとtankakosuuが同じ結果になるか？ コンパイラからすると、tanka_kosuu であろうが、tankakosuu であろうが、 A であろうが、foo であろうが、なんでも同じです。 構造体タグ名だからと言うことじゃなくて、変数名でも、関数名でも（mainを除く）、文法的に正しい名前であれば、名前は何でも良いんです。 コンパイルで生成されるコードは同じで、プログラムの動作は同じです。
> make.exe:`01.exe' is up to dateが出てこの方法では実行出来ません。 「コンパイルでエラーになっても」じゃなくて、「ソースを修正しなくても」ということであれば、 all: 　./01.exe ですね。 ソースが更新されていればコンパイルもしてみたいのであれば、 all: 01.exe 　./01.exe 01.exe: 01.c 　gcc -o 01.exe 01.c ; true #コンパイルエラーになっても無視するためにtrueを付ける
intel fortran の、配列はみ出し検出のコンパイラのオプションは /check:bounds です。 コンパイラのオプションは /help で表示されるので、それを見るのが良いと思います。 詳しくはマニュアルを読めば書いてあります。 なお intel visual fortran には ver.2.11 は存在しません。よくご確認ください。 普通Fortranでは、計算スピードが遅くなるので、実行時に配列はみ出しチェックなどはしません。デバッグ時にのみ使用します。また５０年前くらいの整合配列がなかったころの古いプログラムでは、配列はみ出し前提のサブルーチンなどが使用されるので、はみ出しチェックは余計なお世話という場合もあります。
objdump コマンドを使えば、32bit と 64bit の判別は可能です。 $ objdump -a /usr/lib/libpng.so.3 /usr/lib/libpng.so.3: file format elf32-i386 /usr/lib/libpng.so.3 $ objdump -a /usr/lib64/libpng.so.3 /usr/lib64/libpng.so.3: file format elf64-x86-64 /usr/lib64/libpng.so.3 readelf コマンドでも判別できます。 $ readelf -h /usr/lib/libpng.so.3 ELF Header: Class: ELF32 Machine: Intel 80386 $ readelf -h /usr/lib64/libpng.so.3 ELF Header: Class: ELF64 Machine: Advanced Micro Devices X86-64
「scanf_s」の使い方を間違えています。 入門書には、よくscanf が出てきます。 ですが、scanfは注意して使わないと、いろいろと問題が発生します。 そのため、VSでは「よりセキュアなscanf_sを使いましょう」と勧めてきます。 しかし、scanf とscanf_s とは使い方が微妙に違うので、 単純に 置き換えただけでは、期待通りには動作しません。
実体を作る.
先のURLには「フォニーターゲットを使うのには、同名のファイルとの衝突の回避、パフォーマンスの向上という二つの理由があります。 」とあります。 「暗黙のルールでの検索作業でもフォニーターゲットを飛ばします」ともあるので、.PHONYが無いと偶然「$(PROG)→all」の暗黙のルールが存在していた場合、そのルールが適用されることになります。 今回は暗黙のルールが無いと思われるので、.PHONY無しでも動作するでしょう。 無くてもよい。(cleanの方も、「clean」というファイルが無ければ、期待通りに動きます) けど、あると更によい。(期待しないルールが適用される可能性が減る) ということになります。
#1の方が言われている >○ int * にキャストして渡す(または、void * で受けとって int *にキャストする) >　[y][x] は [y * 幅 + x ]のはず の実装例です。 void print(int **x, int s, int t);　を void print(void *x, int s, int t); にします。 次に、printを以下のようにします。 ------------------------------------------ void print(void *x, int s, int t) { int i, j; int *p; for (i = 0; i < s; i++) { for (j = 0; j < t; j++) { p = (int*)x + (t * i) + j; printf("%5d", *p); } printf("\n"); } printf("\n"); } ------------------------------------------ 不明点は補足してください。
これは「staticを外すとsunday monday tuesdayの後にゴミを出力する」のではなく、「staticを付けたらたまたまうまく動いた」のです。 10行目の判定は *p が指している先が NULL の時に偽になります。*p が指している先は 9 行目で wday の先頭に設定され、12 行目でひとつづつ次の要素に移動します。 しかし、"tuesday" を指しているときに次の要素へ移動しようとしたとき、C言語では何も文句を言わずに wday の領域を超えた箇所を指してしまいます。 static を指定した時はたまたまその箇所が NULL だったのでしょう。 一番簡単な対策は、wday の宣言を以下のように変えることです。 static char *wday[4]={ "sunday" ,"monday" ,"tuesday" , NULL }; 上記なら static を外しても意図した通りの動作になります。
>コンパイラーに依っても違って来ると思いますが。 普通にコンパイラ依存…でしょうね。 http://cdecrement.blog.fc2.com/blog-entry-67.html VC++では使えるようです。 分割コンパイルでファイル毎に文字コードが異なった場合にどうなるか…は不明ですが。 # main.cppがShift-JISで、sub.cppがUTF-8だった…とかの場合に正常にリンクできるのか？とか…。 ただ……仕事で使われるコードで変数名などに漢字とかの多バイト文字使われると…やり直しを要求される可能性が高いでしょうね。 # 和英辞書とかのサイトはありがたく利用させていただいてますが。
うーん、それ以前に > int nstudents; > int grades[nstudents][4]; という問題がありそうなコーディングがあるのですが……コンパイル時になにか警告が出ませんでしたか？ また、後のほうや呼び出している関数の引数の型を見ると > string students; という部分は string students[/* 何らかの値 */]; っぽいのですが、その何らかの値を教えてください。
>人の手作業での線を引くのでは無くて、自動的にプログラムで線を引く事を考えています。 だから、そのつもりで回答しています。 C言語で、6×10個の正方形を並べて文字別に色を塗り分けることができないのですか？
Fortran77は構造化プログラミングが導入。 Fortran 90からモジュラープログラミング、配列演算とユーザー定義総称関数、 Fortran 95にはHigh Performance Fortran が、導入されました。 仕様が小さなものへの下位互換は かなり厳しいのではないでしょうか。 何か最小限の手間での方法が見いだせるとよいですね。
データの元が英文だと、これじゃないですか? https://ja.wikipedia.org/wiki/Windows-1252 また、「文字コード 0x92」で検索すると関連する情報がみつかります。 予想ですが、次のようなことが起っているように思います。 「正しい」ハッシュ: 0x92 という1バイトで計算 「間違っている」ハッシュ: 元データはCP1252で 0x92 → 読み出した際に、CP1252→Unicode変換が行われ、 u+2019 (10進で8217) になる → 出力時にUnicode→Shift_JIS変換が行われ、0x81,0x8cという2バイト列に 　 / またはUnicode→UTF-8で0xE2, 0x80, 0x99という3バイト列に →変換されたバイト列でハッシュを計算 そうだとすると ・CP1252のまま読み取る ・CP1252で出力する ・出力されたものをCP1252に変換してハッシュ計算する 等が必要になります。
const char *と char * は互換性が無いので、8行目を const char **p; に変えれば良いかと。
行数を数えるプログラムは、ファイル中に実際にある改行の個数を数えます。 ファイル中の \n は改行ではありませんので、無関係です。 "\n" や '\n' とCプログラムソースの中に書いておくと、コンパイラがそれを改行に変換します。変換前はたんなる \n という2文字です。
たぶんprintfとscanfが逆に動いているわけではなく、全ての処理が完了してからまとめて表示されるのでそのように見えるだけと思います。 NppExecが標準入出力を取得している都合でそうなっているのではないか…と。 ためしに、printf("hello\n"); の次の行に fflush(stdout); といれてみてください。 #include <stdio.h> int main(void) { int a; printf("hello\n"); fflush(stdout); scanf("%d", &a); printf("a = %d\n", a); return 0; } //参考：http://www9.plala.or.jp/sgwr-t/lib/fflush.html
そもそもなんでループを 2つに分けてるのかが分からない.
Visual Windows for BC++　はいかがですか？ http://phys.cool.coocan.jp/physjpn/bccwin.htm http://www.vector.co.jp/soft/winnt/prog/se326602 …
第1回 初めてのVisual Studio 2013 (1/5) http://www.atmarkit.co.jp/ait/articles/1408/27/n … 　今度こそ起動すると良いですね。 　インストール作業はすでに完了したと解釈すればよろしいのでしょうか？ 　（４／５）からの解説にあるとおり、「ファイル」→「新しいプロジェクト」と作業を進めていけばスケルトン（骨格）が作成されていきます。 　健闘を祈る。
以下のようにしてください。 TEST.CSVに負の値は格納されていないことが前提です。 ------------------------------------- include <stdio.h> #include <stdlib.h> int main(void){ FILE *fp; int num[12] ,e[12],p[12]; int i,sum=0; int j; //この行追加 if((fp = fopen("TEST.csv","r"))==NULL){ printf("not open\n"); exit(1); } for(i=0;i<12;i++){ fscanf(fp,"%d,%d,%d",&(num[i]),&(e[i]),&(p[i])); } fclose(fp); //ここから全面的変更開始 for(i=0;i<12;i++){ if (num[i] == -1) continue; //-1の行は1列目の値が他と同じなのでスキップ for(j=i+1;j<12;j++){ if (num[j] == -1) continue; //-1の行は1列目の値が他と同じなのでスキップ if (num[i] == num[j]){ e[i] += e[j]; num[j] = -1; //2度と使わないために-1を設定 } } } for(i=0;i<12;i++){ if (num[i] == -1) continue; //-1の行は1列目の値が他と同じなのでスキップ printf("number「%d」の総和は「%d」\n",num[i],e[i]); } //ここまで全面的変更終了 return 0; } -------------------------------------- 以下、実行結果です。 number「111」の総和は「801」 number「112」の総和は「1446」 number「113」の総和は「528」 number「123」の総和は「1100」 number「133」の総和は「95」 number「122」の総和は「190」
こんな感じじゃないでしょうか。 axWindowsMediaPlayer1->settings.setMode("loop", true); いくらでもサンプルは見つかると思います。よく探してみて下さい。
ソースをしっかり見ていないのですが、動画を再生するスレッドとキャプチャするスレッドを分けていますか？メインスレッドだけしかないのなら、おっしゃるような交互の動作になるのではないかと。 マルチスレッド化して、処理を並列化すれば、お望みの処理が行えると思います。
正確には＃１のかたの回答になりますが、用途で考えた場合は、以下の３通りで十分かと思います。 （但し、特別な要件があれば話は別ですが） １．とにかく、１バイトずつ読み込む場合：fgecを使用（データはバイナリファイルでもテキストファイルでもなんでもよい） ２．データをまとめて、ｎバイト単位で読み込む場合：freadを使用する（データはバイナリファイルの場合が多い。テキストファイルでも出来ないわけではないが、そのような使い方はあまりしない） （ｎは読み込み側で１０００とか１００００とかそのときに最も最適と思われる値を指定する） ３．１行単位で読み込む場合：fgetsを使用（データがテキストファイルの場合のみ使用する。バイナリファイルでfgetsを使用することが出来ないわけではないが、使用する意味がない。） 但し、fgetsを使用する場合は、そのファイルの１行の最大のサイズより大きい読込領域を内部に確保しなければいけません。例えば、そのファイルに長さが１０００バイトのデータが１行あり、ほかの行は全て１００バイトだった場合、内部のデータ領域は１００１バイト以上を確保しなければ、期待した結果は得られません。従って、読み込むファイルの１行の最大の長さが不明な場合は、十分に大きな読込領域を自分で考えて確保しておく必要があります。万が一、確保した読込領域の大きさが、足りなかった場合は、期待した結果が得られません。 以上。
ロベールのC++入門講座かな。ただC++11に対応していないので、そっちはネットで調べて。 >cocos2d-xでゲームを作る為に必要な知識として継承は必要ですか？ はい。 Javaでもまともに作ると必要だと思うけど。
大変失礼ながら、今の貴方に足りないのはC/C++の基礎知識ではなく、論理を学ぼうとする姿勢や意欲ではないでしょうか？できません・わかりませんでは、いつまでたっても進歩がありません。 最初のうちは誰しもわからないものですが、プログラミング学習ではサンプルコードを実行し、どういう動きをするのかを調べることは必須です。なのでVisual Studioがうまく動かないのであれば、どううまく行かないかを質問して解決し、手元に実証可能な環境を整備すべきです。 Visual Studioが動けば、ステップ実行して変数の内容の変化を表示させられたりするので、理論だけの学習よりもはるかに効率が良くなり、また理解も進みます。まずはそこから手を付けるべきではないかと私は思いますね。
どの程度の精度で考えてますか? 完全なものは正規表現では無理です。 下記のようなケースについて 「検出できなくてもいい/絶対検出したい」 「関数名で無いものを誤検出してもいい/誤検出は困る」 「検出できるようにC++のソースを書き換えるからいい/書き換えないで対応したい」 等を考え、それに合せた方法(他のツールを使う、等も含める)を使います。 C++ では、ただの改行と空白は同じ扱いなので int hoge(int hoge1){} と int hoge ( int hoge1 ) { } とは同じです。 前者で統一されていれば、正規表現である程度の精度で検索できますが、後者の場合は(findstrでは)無理です。 ※ たしか、複数行にわたる検索に対応していなかったはず classHoge hoge(Fuga) ; は、文脈によって ・classHoge型変数 hoge の宣言 。コンストラクタの引数に Fuga を指定 ・classHoge型関数 hoge のプロトタイプ宣言 。引数に Fuga型 と違う解釈ができます。単純に文字列だけを見るfindstrでは、分別不可能です。 関数宣言文で検索するなら、名前に :: が含まれるケースを考慮する必要があるでしょう。 namespaceHoge::classHoge namespaceHoge::classHoge::hoge(namespaceFuga::classFuga fuga1){} 厳密にやるなら、 :: と連続していることを調べる必要があります。 文法チェックはコンパイラにまかせるなら、 : を「関数名に使える文字」として扱うという方法があります。 _ (アンダースコア) は関数名に使えます。 先頭にも使えます。 但し、先頭に使うと予約名になってしまう場合があるので、自作部分での使用は避けた方がよいでしょう。 https://msdn.microsoft.com/ja-jp/library/Cc44018 … 「予約名の形式」
acnt, bcnt, cnt の初期化 (float)sum / cnt 誤字だと思いますが、 平均 "の合計" 余談ではありますが、 配列の個数 = sizeof(配列) / sizeof(配列[0])
手元のVC6が正常に動かなくなっている為正確に確認できまませんが メモリた変数のウインドウの(多分）左上に各ウインドウを閉じるための　×　アイコン表示があると思います でもってその下に縦棒みたいな表示があっるかと思います(Windos枠がそこだけ太くなってる） そこをクリック(正確にはクリックではなくてマウスダウン）すると各Windowそのものが選択されます 後は自分の好みで動かせばいいかと思います
>int変数で入力した後で型変換をするやり方も試しましたが、これも同じでした。 ちゃんと、1,2,3「リターン」のように、数をカンマで区切って入力しましたか？ scanf("%d,%d,%d",&ia,&ib,&ic); であれば、「カンマで区切って数値を入力する」という意味になっています。 書式とおり1,2,3「リターン」と入力すれば、ia,ib,icにそれぞれ　１，２，３が代入されるはずですが・・ ＜おまけ＞ scanf("%d %d %d",&ia,&ib,&ic); であれば、カンマではなく「スペースで区切って数値を入力する」という意味になりますので、1 2 3「リターン」と入力することになります。
関係ありません。 タブレット、スマートフォンなどにも対応したアプリケーションを作りたいとか、後々そういうところにも手を広げたいというならば最初から2015を利用しましょう。 2010ではPCLもShared Libraryもないでしょうし。 また、今ではExpressのような制限付きエディションではなく、CommunityというProfessionalと同等の機能を有するエディションがありますので、2015を利用した方が何かと便利かと思います。 https://www.microsoft.com/ja-jp/dev/products/com …
ああ、ちなみにPCのキーボードで発生するかは不明ですが、 チャタリングという現象もある機能性がありますので、適度なSleep()は必要かと思われます。 私がゲームのスクリプトで作っていた時には 「キーを押して、離した時に反応」するようにしていましたけどね。 (key[KEY_INPUT_Z]==0 && oldkey[KEY_INPUT_Z]==1) のような条件式に。 マウスのボタンだと「押して離した時に反応」でいいのですが、キーボードだと「押された時(キーリピートの為？)」というのが、Windowsで一般的なインターフェースっつぽいですけどね。 (ダイアログのボタンなどにフォーカスがあった時の動作…とかね。)
絵本シリーズ、独習シリーズは、中級者向けの本です。 「やさしいC++」などの入門書をしっかり読み直しましょう。 単にコードの意味が分からないのなら、インターネットで検索しましょう。 アマゾンには読者の書評も載っているので読んでみましょう。
……ごめん、 > Vector3d、Matrix3d がeigenの行列クラス。 > Sophus::SE3がSophusのクラスです。 といきなり言われても、eigen や Sophus が何を意味するのか解らないからどうしたらいいか答えられないや。 再度のお願いですみませんが、ソフトが完成した暁にそれを使ってあなたがやろうとしていることの簡単な説明と、Vector3d, Matrix3d , Sophus::SE3 が何のライブラリに所属しているクラスなのかを補足願います。
まず、「エラーの意味がわからないので、それらしくソースを直してみる」ということは、絶対にやってはならないことです。 こういう癖をつけたプログラマは、「なんかわからないけど動く」という、本質的な部分にバグを含んだプログラムを作って、周りの皆さんに迷惑をかけます。 あと、提示されたソースからは、 「strcpyの宣言云々」というエラーは出ないはずです。 既に、「いろいろなエラー」がでて、あちこち適当に直した後なのだろうと思います。 そもそも char :::name() には元々引数がない（関数に渡す情報がない）のに、char *name(char *nam[]); と引数をつけてみるというのも、やってはいけないことです。 さて、 return nam というのが、「本当に意図するところ」なら、nam の型（または、それを変換可能な型）が関数の型になります。 nam を返すのですね？ nam は、char ではなくて、char の配列です。 で、これまでの練習問題を見直して、char の配列（それこそ、名前とか）を返す関数が、どういう型になっているのかを確認してみてください。
> なぜ（）をつけたら0になったのでしょうか？ 1回のループで、{}で囲まれた { num/=16; return n; ｝ を繰り返そうとするからです。 実際には繰り返す前にreturn で戻ってしまうのですが
まずLEDを1つだけ点灯させるところからやってみてください。
クライアント側で、Xサーバーを動かします。サーバー側でプログラム起動時にDISPLAY環境変数で、192.168.0.1:0.0 のようにディスプレイ名を指定します。 「Windows Xサーバー」で検索してみてください。フリーの物、有償の物があります。
以下のようにしてください。 ---------------------------- #include <stdio.h> void move(int n, char a, char b, char c); int tesuu=0; /*これを追加*/ main() { int n; printf("円盤の枚数？"); scanf("%d", &n); move(n, 'A', 'B', 'C'); printf("%d手かかりました\n",tesuu); /*これを追加*/ } void move(int n, char a, char b, char c) { if(n > 1) move(n - 1, a, c, b); printf("円盤%2dを円盤%cから%cへ移動\n", n, a, c); tesuu++; /*これを追加*/ if(n > 1) move(n - 1, b, a, c); } ---------------------------- ついかした行は、右側に/*これを追加*/ と記入してあります。 以下、実行結果です。 円盤の枚数？3 円盤 1を円盤AからCへ移動 円盤 2を円盤AからBへ移動 円盤 1を円盤CからBへ移動 円盤 3を円盤AからCへ移動 円盤 1を円盤BからAへ移動 円盤 2を円盤BからCへ移動 円盤 1を円盤AからCへ移動 7手かかりました
意味があるかどうかわからんけど, 例えば質問中にあるプログラムで何が「出力」 (「表示」ではなく) されるんでしょうか? あと, 念の為だけどプログラムを書くために使った文字コードはどうなっている?
/* このほうが修正が楽 */ int main() { pthread_t thread1,thread2; void *print_val(1,void *args); void *print_val(7,void *args); /* 中略*/ } void *print_val(ｊ, void *args) { int i; for (i=0; i<strlen(word); i++) { sem_post(&sem2); // sem2 increment sem_wait(&sem1); // sem1 decrement printf("%c",word[i]); fflush(stdout); sleep(ｊ); } return NULL; }
一番の問題は 「モンテカルロシュミレーション」とはなにか のような気がしますが＞#1. わざわざ「シュミレーション」と書いてあるということは「シミュレーション」とは違う何かのように読めるんだけど, それがなにかさっぱりわからない. ちなみにいうと「最適解を探せ」といわれても「期待値として最良」しか求められないし, それでいいならわざわざシミュレーションなどしない.
object senderにイベントの発生したオブジェクトが入っています。 今回の場合はドロップしたコントロールが。 TextBox Target = (TextBox)sender; として、 Target.AppendText(file_name + "\r\n"); と記述し、textBox1とtextBox2のハンドラを同じものを指定すればよいかと。
プログラムから呼び出されるサブルーチン printf に必要な、レジスタの初期化処理が不足しているからです。 特殊呼び出しとなる printf は、一般にC言語コンパイルラではうまく検証できないので、この様な泥臭い問題が発生します。 ---- printf("%dです。", 123) をコンパイルした機械語イメージ mov レジスタ2, 前の処理に使った値 ... mov レジスタ2, 123 ← レジスタの値を初期化 mov レジスタ1, 書式文字列のアドレス call printf ← レジスタ1 の書式に%dがあるので、レジスタ2 から「123」を読み取って、整数として表示 ---- printf("%dです。") をコンパイルした機械語イメージ mov レジスタ2, 前の処理に使った値 ... mov レジスタ1, 書式文字列のアドレス call printf ← レジスタ1 の書式に%dがあるので、レジスタ2 にたまたま設定してあった「前の処理に使った値」を読み取って、整数として表示
遙か昔に買ってきただけで挫折した書籍として。 ・・・と思って書籍検索をしてみた物の該当なし。 別の書籍を紹介します。 ＞やさしいインタープリタの作り方入門―オリジナルなインタープリタを作成する 単行本 – 2009/2 ＞http://www.amazon.co.jp/%E3%82%84%E3%81%95%E3%81 … 　性能や実用性はとりあえず無視して開発するのもおもしろそうですね。 　蛇足ついでに書いておくと、最近になって情報を知って吹いた言語としては「ニャル子さん言語」。 ＞「(」・ω・)」うー(/・ω・)/にゃー」でプログラムが書ける言語「Nyaruko」登場 ＞http://nlab.itmedia.co.jp/nl/articles/1204/19/ne …
大抵の場合、「やりたい事」がそのまま見つかることはありません。 ですから、やりたい事が「自分が知っている方法で」どうやったらできるか、を考えます。 そうして、どうしてもそれだけではできない部分を調べます。 このためには「問題を分析する」ことが大切です。 今回ので言えば、 XMLとかを考えなければ @SystemTime&gt;='XXXX' and @SystemTime&lt;='ZZZZ' のXXXXとZZZZを日付の文字列に置き換える だけです。「文字列の置き換え」なんていくらでも方法が見つかります。 String.Formatの書式で書いて{0}には開始日時が入ると決めておけば、 String.Format(XMLの内容, 開始日時,...)なんて方法が使えます。 いろんな内容を置き換えるものに「テンプレートエンジン」というのもあります。 ※ ここで、特定のタグの中だけ変更対象にしたい、という場合に、XMLの構造解析や要素の抽出等を行うのが、XDocument等の使い方です。 (2)も同じように、問題を分割することです。 「INI等に除外ワードを書いて、それを読み込む」 というプログラムは簡単ですよね? 「対象文字列に、検索文字列が含まれているかどうかを調べる」 というプログラムも簡単ですよね? これらがわかれば 「対象文字列に、『除外ワード』が含まれているかどうか調べる」を全部の除外ワードについて繰り返して、1つでも含まれていたら除外 というプログラムは、簡単なものをちょっと組合せただけの簡単なプログラムになります。 (3)ですが。 勘と経験もあります。 ですが、(1)(2)を考えると「何を探したらいいのか考えないまま、漠然と探している」のではないでしょうか?
専門学校で学んでも、レベルが高くないよ。ゲームプログラマーになるヤツって、俺も含めてそうだけど、独学ですごく時間を費やしてスキルアップしてる。専門学校に行こうと思って話を聞いたら「あなたはもうレベルが高くて専門学校のレベルを超えている」と言われた。 大学卒業した方がいいよ。在学中でも専門学校に通うこともできるし。公認会計士を目指す人って、大学行きながら専門学校みたいなとこへ通うだろ（ダブルスクールってやつ）。 大学に通いながらプログラミングは勉強できる。両方やった方がいい。
>SIGTERMは指定できるのですが、プロセスIDを指定できない様です。 >何か他に方法はありますでしょうか。 これは失礼しました。 シグナルの代わりになる正当な方法が無いのかも？ 自分ならばオリジナル修正を少なくするよう、 ・適当なスレッドを起こし、 ・そこで適当な待機オブジェクトを待ったり、メッセージ受信する（適当なプロセス間通信） 等を考えます。 後は、そのスレッドから raise 関数が正しく動くかどうか…
C には「多次元配列」というものは本来存在しない (2次元配列は「配列の配列」として処理する) わけですがそこは目をつむることにして. C で int a[2][3]; とあると, これは「int [3] の配列」となるのでメモリ上 a[0][0], a[0][1], a[0][2], a[1][0], a[1][1], a[1][2] と並びます (「a[0][0]～a[0][2]」の部分が a[0] ). 一方 Fortran で integer :: a(2, 3) とすると, メモリ上の並びは a(1, 1), a(2, 1), a(1, 2), a(2, 2), a(1, 3), a(2, 3) となります. ここでは 2次元配列で書きましたが, 任意の次元の配列でも同様に ・C では右の添字から先に変化する ・Fortran では左の添字から先に変化する ので, 添字の動く順序がまったく反対になります. 単純な処理だとこれで速度が実際に変わる (数字もどこかで見た記憶はあるけど忘れた) のですが右辺が複雑だとそっちのせいであまり変わらないかも.
返答が遅れました。 私の方こそよく見ていませんでしたね。すみません。 Leapd.libは旧バージョンの１．ｘ系には含まれていたデバッグ用モジュールですね。 https://developer.leapmotion.com/documentation/c … このリンク先のVisual studioのプロジェクト設定方法を見ると、 デバッグ用設定でも、Leap.libをリンクするようにと指示がありますので、そのようにして下さい。
出力については、既に出ていますので。 ループ回数や範囲が違ってます。 > int readfile(double aryofdata[],FILE *fp) >while( (fscanf(fp,"%lf",&inputdata)!= EOF) のループでi を使って入力したデータ数を記録して > return i; で返す、ということをしているように思いますが、その間に > for(i=0;i<DATASIZE;i++){ が入っているため、iには、ループ終了時の値(=DATASIZE)が常に返ります。 おそらく、今回は4000個のデータなので、DATASIZEが返っても気付かなかったのでしょう。 > void printrtau(double aryofdata[],int n,int tau) この各引数はどんな意味で使っていますか? プログラムの動作を追っていくと printtau(aryofdata,2000,1) が実行されます。このときの > for(t=0;t<n;++t){ のループでどういう計算になるか、よく考えましょう。 また https://ja.wikipedia.org/wiki/%E8%87%AA%E5%B7%B1 … のR^(k)式と比べると、 μ=0,σ=1 となっていますが、入力するデータは既にそのようになっているのでしょうか?
No.4です。 記述間違いがありました。 テキスト→メモ帳　の間違いです
この場合には FORTRAN77 の時代から SAVE を使っておくのが安全だったらしい. で Fortran90 以降は SAVE文とは別に SAVE属性が設定できるから, そっちを使う方が現代的といえるかもしれない.
単純にタイトルだけ取得するならこれでどうですか？・・・。（.NET） Dim Tt As System.Diagnostics.Process Console.WriteLine("タイトル＝　" & Tt.MainWindowTitle)
例えばなんらかの事情で「NULL の値を表示したい」ということがあったとしましょうか. この場合単純に考えると #include <stdio.h> int main() { printf("Null pointer = %p\n", NULL); return 0; } でよさそうですが, 実際にはこれではダメなことがありえます.
あなたがわからないのは、次のどれなのでしょうか? (1) 流れ図 そのもの (2) プログラムので何をすればよいか (流れ図はわかる) (1)なら、まずは教科書や参考書、ネット等で調べて、流れ図の書き方を覚えましょう。 (2)の場合。 プログラミングで大切なことは、「どうやったら問題を解決できるかを考える」ことです。 プログラミング言語の命令とかを覚えるよりも大切です。 命令がわからなくても、マニュアルとかを見ればわかりますが、考えがわからない時に本を見てもそのものずばりで書いてあることはそうそうありません。 やりかたを考える方法の一つが「自分がコンピュータだったら、どんな手順でやるだろうか」を考えるというものです。 ※ #1にある「自力でやる」とは、この意味だと思います。 「これから数値を読み上げます。 　あなたは、Tの升目に昇順となるように書いてください。 　-1 と言われたら、その内容を『画面』の紙に書き出してください」 と言われて、紙と鉛筆と消しゴムを渡されました。 ・比較したり判断したり書き込んだりできるのは、升目に書いてある数字だけ。 　　例外として、読み上げた値は1回だけ升目に書き込める。 ・升目は自由に読み書きできる。 ・升目以外に書いてはいけない。 ・同時に複数の作業をしてはいけない。 　等のルールがあります。 0番目に「34」と言われました。 　ここでどうしますか? 1番目に「28」と言われました。 　ここでどうしますか? .... I番目に「???」と言われました。 　ここでどうしますか?
bmp をフィールドにする https://msdn.microsoft.com/ja-jp/library/ms17311 … g を使う前に、bmp から g を取得する Graphics g = Graphics.FromImage(bmp);
>if ( fp == 0){ >　fopen dekina　と表示してくれるのでしょうか？ はい、表示してくれます。 NULLは、通常、(void*)0 の値が定義されていますので、実体は0と同じです。 しかし、NULLはポインターに対して定義されているのなので、 if ( fp == NULL) と書いたほうがよいでしょう。 一方、0は数値を表すので、 if (fp == 0)とは、書かないほうがよいでしょう。 int a; が定義されていたとき、 if (a ==0) は、a（という数値を表す変数）の値が0か否かを判断するので、これでよいですが if ( a== NULL) は、a（という数値を表す変数）の値がNULLか否かを判断するので、 違和感がありますから、使用しないほうが良いでしょう。
WIndowsの環境もいろいろあるので、貴方のお使いのコンパイル環境（ライブラリ・API等含む）に合った関数をお使いください。 わからないんだったら、Cygwinにしておくといいでしょう。
VisualStudio2010 は使用した事ありませんが、 どこかリンカの設定に詳細メッセージを吐く項目が有るはずなので、そこを活かしてみると、閲覧者にも状況が判ると思います。 一応、私が見て前提にしている事は、 ・アプリ（MFCのダイアログベース）では libMPSSE_spi.h をインクルードしている。 ・また、libMPSSE.lib はアプリから参照出来る位置に配置・定義されている。 です。 なお、○.dll、○.lib、○.h はおそらく雛形ですからプロジェクトから外した方が良くないですか？　回答側から見て混乱するだけなので…
お書きのとおりで合ってますよ。大丈夫です。
＞リアルタイム入力機能とはなんですか？ 普通のコンソールアプリのキーボード入力は、Enterキーを押して初めてプログラムにデータが渡ります。 キーを押した瞬間にそのキーデータがプログラムに渡ることをリアルタイム入力と書きました。
Java や C# のように現代的な言語なら、 args にはプログラム引数のみが入るので if ( args.length < 1 ) で問題ありません。 C 言語の場合は、args に「プログラム名」も含む仕様となっていますので、 argc は通常 1 以上の値になります。(用途によって例外あり) 参考) JISX3010 プログラム言語 C 5.1.2.2.1 プログラム開始処理 argv[0] が指す文字列は、プログラム名を表す。 argv[1] から argv[argc-1] までが指す文字列は、プログラム仮引数を表す。 なので、"file mei ga nai" というよりも「プログラム引数が一個も無い」を表す条件は if ( argc < 2 ) または if ( argc == 1 ) でなければなりません
// 変数を追加 int line_idx = 0; // item へのコピー時に line_idx を指定 strcpy(&item[item_idx][line_idx], item_p); // 一行を読み終わったら、line_idx を +1 item[item_idx][line_idx] = '\0'; line_idx++; // 出力は、第3列のみを line_idx 行分 for(i=0; i<line_idx; i++) fprintf(fl,"%s\n", &item[2][i]); // 全体の処理順序は以下がオススメ fp = fopen() while ( 読み込み(fp) ) { 処理 } fclose(fp) fl=fopen() 書き込み(fl) fclose(fl)
プログラマでない素人意見で想像による回答も含みます。あらかじめご了承ください。 例えばコンパイラーがデバッグ情報を提供してくれそれによりソース上でトレースできるようなものならそれを使ってソースをチェックしたほうがいいのではないでしょうか？　ただ、こういう専門的な仕事では、基本的に論理的な確証を持たずにあてずっぽうデバッグは意味がないことくらいは理解できます。そして、派遣とは経験を積めないシステム雇用され、終身雇用制には適さす、当然、経験時間が少なく実務レベルが下がると考えることは正しいとおもいます。 つまり、派遣社員に一から教えても契約切れで入なくなるだろうなとか、派遣だから正社員のようには必死に取り組んでもなあ。。のようなあきらめ気分。 したがって、派遣をやめるには正社員の既得権を削り給与をさげてでも正社員確保を目指す考え方が必要です。しかし、現在の、大手企業の組合はどのように考えるでしょうか？ ここらあたりを解決できなければ改善は無理でしょう。ワークシェアリングの理念を取り入れながら正社員確保をやろうというのは北欧の考え方ですが、日本では難しいようです。 日本全体で考えると、今後、企業が移民を低賃金で雇うようになってしまうとその業界でも、そういった間に合う人材の確保はいっそうに難しくなると思われ、経営者の都合により、日本人労働者が苦労することになるかもしれませんし、派遣切りとなりはしないでしょうか？ 経済連の考えることは目先の欲のようです。先の北朝鮮拉致被害者の帰還のときも密約があったとか。。まったくわけのわからないことをやります。また、当時のリストラと派遣推奨の小泉改革もけっこう怪しいです。先進技術者の海外雇用にも繋がり日本の技術が流出し打撃を受けました。
構造化するときに関数を使いますね 日常で使う言語でも書き下す時には 章ー節ー段落 等というように 構造化しているはずです。
nodesがNULLじゃね？ とか言われているようですが……。 .NET Frameworkのランゲージパックをインストールするとエラーメッセージが日本語で表示されるかと。 で……「使ったサンプルコード」のままだとすると、指定されたページにid="todayRanking"になっているものがないのでしょう。 # ブラウザで表示し終わった後、ソースを表示してtodayRankingで検索してもヒットしませんし。 元記事が2009年のものですから、ページのデザインなどが変わった影響でタグが見つからないのでしょう。 HtmlAgilityPack.HtmlNode.SelectNodes(System.String)の戻り値が…XMLで記述されているヘルプ(?)によると…… An HtmlAgilityPack.HtmlNodeCollection containing a collection of nodes matching the HtmlAgilityPack.HtmlNode.XPath query, or null if no node matched the XPath expression. 引数で指定したノードが発見できない場合はnullを返却する。と書かれているように読めます。
System.Net.Http、Html Agility Packを利用することで、Webページの取得およびXPathによる部分抽出が可能です。 Html Agility Pack http://htmlagilitypack.codeplex.com/ 参照設定 System.Net.Http HtmlAgilityPack コード private void button1_Click(object sender, EventArgs e) { var htmlTask = new System.Net.Http.HttpClient().GetStringAsync("http://www.google.co.jp"); htmlTask.Wait(); var html = new HtmlAgilityPack.HtmlDocument(); html.LoadHtml(htmlTask.Result); var node = html.DocumentNode.SelectSingleNode("//a[1]/span[2]"); Console.WriteLine(node.InnerText); } 正規表現でも可能でしょう。 いずれにしても、もとのHTMLの階層・構成を把握した上で、望む位置を抽出するよう制御してあげなければ不可能です。
基本構文 if ( 条件式 ) { 処理; 処理; ... } else if ( 条件式 ) { 処理; 処理; ... } else { 処理; 処理; ... } 省略形として if ( 条件式 ) 処理; else if ( 条件式 ) 処理; else 処理; 場合によっては更に省略できる if ( 条件式 || 条件式 ) 処理; else 処理; ちなみに数値同士の比較をする条件式とは、以下のいずれかです A < B A <= B A == B A >= B A > B
既存のプログラムを取り込むのがめんどくせー。ってのは判らんでもないですけどね……。 >SendMessageAPI関数は、コマンドプロンプトウィンドウで実行中のMyPsCON.exeに適用できるんでしょうか。 実行しているアプリに対しては適用できませんが、そのコマンド プロンプトのウィンドウへの適用は可能でしょう。 プログラムを実行しているコマンド プロンプトのウィンドウを検索するのが少々手間かも知れませんけど。 とりあえず、普通に起動しただけのコマンド プロンプトに対して、下記の処理で「a」が入力されたのは確認しました。 # Windows7 64BitにVC++2010Expressにて 　HWND hConsoleWnd = NULL; 　hConsoleWnd = FindWindowEx(NULL, NULL, TEXT("ConsoleWindowClass"), TEXT("管理者: コマンド プロンプト")); 　if(hConsoleWnd) { 　　SendMessage(hConsoleWnd, WM_CHAR, (WPARAM)'a', (LPARAM)0); 　} FindWindowEx()の第4引数が問題になる…かも知れませんな。 # 複数起動していたらどうなる？とか、FindWindowEx()からSendMessage()までの間にウィンドウ閉じられたら(普通は無理ですが)どうする？とか……。 ちなみに、第4引数の文字列はSpy++にて該当ウィンドウのプロパティから取得。 見た目だけだと半角スペースの数とか合わないかも知れないから。
参照かアドレスで渡すのがよいと思います // 参照渡し int func(vector<mm>& m) { cout << m.a; } // 使い方 func(mx); // アドレス渡し int func(vector<mm>* m) { cout << m->a; } // 使い方 func(&mx);
GetAttribute があるんだから SetAttribute もあるだろう、と想像できませんかね。 こういう想像してみる行動ができないとこの先苦労すると思いますよ。 https://msdn.microsoft.com/ja-jp/library/system. …(v=vs.110).aspx
.NET Framework 4.5以上なら、HttpClientクラスを利用する方法が最も簡単です。 http://www.atmarkit.co.jp/ait/articles/1501/06/n … https://msdn.microsoft.com/ja-jp/library/system. …(v=vs.110).aspx 一部の文字を取得したいならば、GetStringAsync()後にRegex.Match()などの正規表現を利用して抜き出せばよいでしょう。 http://dobon.net/vb/dotnet/string/regexmatch.html
ソートのアルゴリズムは「大小関係を比較して、正しくなるように並び換える」の繰り返しです。 このときの「大小関係」な、なにも、「並び換える配列」そのものの値でなくてもかまいません。 今回の場合 index[0]番目のscore (=score[index[0]] ) が最大 index[1]番目のscore (=score[index[1]] ) がその次 index[2]番目のscore (=score[index[2]] ) がその次 ... となるように、 index[] を並び換えます。 if (score[j]<score[i]) { max = score[j]; score[j] = score[i]; score[i] = max; } では、 score[i]とscore[i]を比較して、score[i]とscore[j]を入れかえてました それを 「score[index[i]]とscore[index[i]]を比較して「index[j]をindex[i]を交換」するようにします。
使ってるコンパイラは? 対応していれば、環境変数LANGを適切に設定すれば日本語表示されるはずです。 もっとも、エラーメッセージレベルの英語を読めるようにする方がなにかと便利ではないかと。
長文で色々書いてあるみたいだけど、ただ単にこういうこと？ 1. WIndowsアプリケーション化したので標準ね入力（stdin）がありません。 2. だけどstdinからキーボード入力を受け取りたい。 2の考え方が矛盾してるんじゃないの。 私ならUSB通信プロセスとデータベース（と表示）のプロセスを分けてプロセス間通信する。
C# の仕様 (というか ECMA-344) を読んでみたんだけど.... IEEE 754 を読み誤ったかもしれない.... IEEE 754 的にも a != 0 と ! (a==0) が同じであることを保証してるかもしれない. もしそうなら #3～#5 はただの私の妄想なので捨ててください. なお, C# の仕様としては NaN が出てきても例外などを発生することなく処理は進んでいきます.
教育が充実しているところに入社すれば、言語まーったくできなくてもおｋ 大手ならふつーは教育期間があるので、安心 中小でもあるところ受ければおｋ牧場
ソリューションエクスプローラー　というエリアからFormファイルを開くと表示されます。(名前を変えていなければForm1.csなど) テキストボックスはラベルはツールボックスというエリアからドラッグして追加します。 ソリューションエクスプローラー、テキストボックスが画面に表示されていない場合は画面上部の「表示」から表示させることができます。
少々乱暴な説明ですが new クラスの情報を一つ格納できる広さのメモリを確保する new BBteam() BBteam 一個分のメモリを確保した後に、メソッド public BBteam() を実行する コンストラクターによる初期化処理と呼ばれます BBteam akira = new BBteam() メモリを確保し、BBteam() を実行した後に、メモリの位置を変数 akira に格納する akira.name = "Akira" 変数 akira から、フィールド name が格納されているメモリの位置を計算し、上書きする WriteLine(akira.name) 変数 akira から、フィールド name が格納されているメモリの位置を計算し、値を読み取って、画面表示 メソッド Main の実行が終わった後 使い終わった BBteam 一個分のメモリを開放する デストラクターによる終了処理と呼ばれます 以下参考 new BBteam(1) BBteam 分のメモリを確保した後に、メソッド public BBteam(int) を実行する 同じメソッド名でも、引数があるので () とは別のメソッドです new BBteam("あ") BBteam 分のメモリを確保した後に、メソッド public BBteam(string) を実行する 同じ引数一個でも、引数の型が違うので (int) とは異なるメソッドです new BBteam("あ",1) BBteam 分のメモリを確保した後に、メソッド public BBteam(string,int) を実行する 一個目の引数が同じでも、二個目があるので (string) とは違うメソッドです
#include <stdio.h> int main() { int a; int b = 1; int i; printf("a:"); scanf("%d", &a); for(i = 0; i <= 4; i++) b *= (a + i); printf("答え:%d\n", b); return 0; }
> もちろん、傾向がつかめる分岐ならこの限りではないと思いますけど。 GreenHills社のコンパイラは、実際に実行したプロファイラの結果を最適化に戻して、使い方にあった個別の最適化を行うような機能がありますね。
最初に一文字ずつ０と１に直してから、くっつけていく方法 で良いと思います。 ostringstream o; string::iterator i = dna.begin(); while (i != dna.end()) { _ switch(*i++) { _ _ case 'A': o << "00"; break; _ _ case 'T': o << "01"; break; _ _ case 'G': o << "10"; break; _ _ case 'C': o << "11"; break; _ } } return o.str();
http://ja.wikipedia.org/wiki/Scanf#.E7.95.B0.E5. … この罠に嵌ってます。
もうほとんどカンニング行為かも知れませんが、お手本は次のように説明があります。 ＞クイックソート ＞http://www1.cts.ne.jp/~clab/hsample/Sort/Sort9.h … 　話の流れからここから持ってきたソースコードに手を加えたのだろうか？と思うほどソックリですね。
以下のようにしてください。 --------------------------------------- //ここに４行追加して下さい。 //（１）鍵を作る（mrecv.cと同じファイル名から作る）。 msgkey=ftok("mrecv",'a'); //（２）msggetシステムコールを行い、msgidを得る。 msgid=msgget(msgkey,IPC_CREAT|0666); //（３）msgdataのアドレスをポインタ変数pに入れる。 p = &msgdata; //（４）msgdataのメンバmtypeにプロセスidを入れる。 p->mtype=getpid(); --------------------------------------- 以下、mrecvの実行結果です。 message received from 7077 10 seconds has passed!! message received from 7077 10 seconds has passed!! message received from 7077 10 seconds has passed!! message received from 7077 10 seconds has passed!! 実行環境は以下の通りです CentOS release 6.3 (Final) gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC)
……? 「関数Aを使う処理」というのが漠然としていて具体的に何を意味しているのか理解できていないのですが、ただ単に関数Aを呼び出せばいいんじゃないんですか? すみませんが、関数Bで関数Aを使って何がしたいのかもっと具体的に書いていただけないでしょうか。
fopen_s()ではなくfopen()を使う。というのも有りです。 というか、既にそういう回答もらっていますよね。 SYさん？それともHIRO31さん？はたまたgyukiさん？
http://pokosho.com/t/image/ このページのものですかね。 # 10章に掲示しているソースがある。 ソースコードのリンクでzipファイルがDLできるので、展開して c:\users\ogura\documents\visual studio 2013\projects\consoleapplication19\consoleapplication19\ にParams.hをコピーして下さい。 コメントの日本語部分が文字化けしているっぽいので、もしかしたらコメント部分の日本語は削除した方がいいかも知れません。 # 秀丸の自動判別でも正しいモノにならなかった。Shift-JIS/EUC/JIS/UTF-8/UTF-16LE/UTF-16BEどれも駄目。
unordered_multimap は使わないんでしょうか?
端的に言いますと、「関数は値」ということです。 min_e = min_of(eng, 5); というのは、min_of(...) がただの数値であって、 その数値がmin_eという変数に代入される、という意味です。 で、min_of(...)がどういう数値かというと、 return(min); の「min」という数値になります。 つまり、return()の()の中身が、その関数の数値になるのです。 int func() { return(10); } int main() { int a; a = func(); printf("%d\n", a); exit(0); } なんて書くと、10と表示されます。 これが「代入」に関する疑問への答えです。 あと、min_of()関数の中の処理についてですが、 単純に引き渡された配列要素の中で最小の数値が入っているものを見つけ出しているだけです。 省略形で書かれているのでわかりにくいですが、 制御構造をちゃんとブロック付きで書くとわかりやすいです。 for( i = 1; i < no; i++ ) { if (vc[i] < min) { min = vc[i]; } } return (min); つまり、全要素を順に、今まで見つけた最小と思われる数値（min）と比較し、 もっと小さいやつがあったら最少記録を更新する、 最後にこの関数の数値は、その最少記録にする、 というプログラムです。
アンドが何か解るだけの基礎知識はお持ちなのでしょうか？　No1で答えが示されているのに実装できないようなので、とてもそうは思えません。 高校１年生になったらN進数、論理ともに学校で習いますので、その時に改めて考えてください。 それから、もはやC/C++と関係無いので数学とかVBのとこでやったら。 https://oshiete.goo.ne.jp/articles/qa/257 https://oshiete.goo.ne.jp/articles/qa/392
１６ｂｉｔかどうは知らないが、「レナさん」ですね。 ＞レナ (画像データ) ＞http://ja.wikipedia.org/wiki/%E3%83%AC%E3%83%8A_ … 　いつも画像処理の世界で登場する有名な女性です。
回答がついている通り、基本的には無理です。 デバッグシンボルがあると…もしかしたら可能かも知れませんが。 # とは言え、他アプリとかの場合はいろいろ面倒でしょうねぇ… # ロードされるアドレスとかが…(一応、WindowsのDLL類はロードアドレスが異なるように作られている…らしい)。 # DLLのヘッダにその辺は記載されていたハズ。
以下の部分を追加してください。 ---------------------- time_t result; time(&end); result = end - start; write(write_fd,&result,sizeof(result)); ----------------------- 以下実行結果 ::::::^Zelapsed time = 6 CentOS release 6.3 gcc version 4.4.6 で動作確認しました。 不明点は、補足にて質問してください。
その nonfree.hpp なるファイルはどこにあるのでしょうか?
それだけの情報では、作れる技術のある人でも作れないでしょう。 ○解像度とは、何の解像度ですか?色数ですか?画素数ですか?時間ですか? 　どちらにしろ、増やすということは、今無い情報を補間する必要があります。 ○YUVを使うかどうかは、上記の「補間」方法次第です。 ○1フレームの画像を処理する方法もあれば、前後の複数フレームから計算する方法もあります。 ○普通は、できるはずのものを課題にします。 　プログラミングがまったく無いまま課題にしたりはしないのではないでしょうか?
>これはddが定義されていないという意味でしょうか？ ランタイムがそこまでやってくれるんですかねぇ…。 まぁお節介な環境なんでしょう。 >return yy,mm,dd; コレは何を意図していますか？ 「書式として」はエラーにならないでしょうが、意図と合っているかどうかは別ですから。 >int yy,mm,dd; 宣言しただけで、初期化されていません。 >d1.get(yy,mm,dd); で、初期化していない変数を参照しています。 なので、The variable 'dd' is being used without being initialized. 翻訳サイトなどで翻訳してみましょう。 Dateクラスのメンバ変数は何のために用意されているんでしょう？ next()ヘンバ関数はソレで合っていますか？ get()は参照を使う…んでしょうね。 next()では月またぎ／年またぎとか考慮する必要があるんでしょうね。 # 「次の日は2014年2月30日です」とか言われるのはヘンだろう。
以下のようにしてください。不明点は補足にて質問してください。 乱数は現在時刻を種として設定しています。（でないと毎回同じ乱数が出現するので） 名前は１文字でなく、10文字まで使用できるようにしました。(%10sの書式を尊重しました) --------------------------------------- #include <stdio.h> #include <stdlib.h> #include <string.h> #include <math.h> #include <time.h> main() { unsigned char x; int w,n,i,j; int count[8]; int skipFlag[8]; char name[8][11]={"AAA","BBB","CCC","DDD","EEE","FFF","GGG","HHH"}; int rank[8]; int maxcount; int maxindex; for(n=0;n<8;n++) { count[n]=0; skipFlag[n]=0; } srand(time(NULL)); //乱数の種を与える（種は現在時刻） for(i=1;i<=100;i++) { x=rand()%8; count[x]++; } //countの中から最大の値をもつ位置（添え字）を探す //それを8回繰り返す（1位から8位まで探す） for(i=0;i<8;i++) { maxcount = -1; //最大値に-1を設定（初期値） for(j=0;j<8;j++) { if (skipFlag[j] == 1) continue; //既に最大になった箇所はスキップ if (count[j] > maxcount){ maxcount = count[j]; //最大値を更新 maxindex = j; //最大値の添え字を記憶 } } //最後に最も大きい値の添え字が記憶されているのでそれを格納 rank[i] = maxindex; //最大になった箇所は、次回使用しないようにするため1をセット skipFlag[maxindex] = 1; } printf("----------------------\n"); for(i=0;i<8;i++) { w = rank[i]; printf("第%d位%3d回%10s\n",i+1,count[w],name[w]); } printf("----------------------\n"); } --------------------------------------- 以下、実行結果です。 1回目 ---------------------- 第1位 18回 AAA 第2位 16回 FFF 第3位 13回 BBB 第4位 13回 EEE 第5位 11回 DDD 第6位 10回 CCC 第7位 10回 GGG 第8位 9回 HHH ---------------------- 2回目 ---------------------- 第1位 18回 FFF 第2位 13回 AAA 第3位 13回 BBB 第4位 12回 CCC 第5位 12回 GGG 第6位 11回 EEE 第7位 11回 HHH 第8位 10回 DDD ----------------------
>プログラムを作りたいのですがどうすればいいですか？ 問題点の指摘ではなく、正解のコードが欲しかっただけなんですね。 まぁ、私の指摘もいろいろ足りませんでしたけど、そんな無能の指摘よりコードくれ。
>VisualStudio2013です。 >「「構成プロパティ｜リンカー｜追加のライブラリディレクトリ」で「C:\Program Files (x86)\Leap Motion\LeapSDK\lib」を追加します。」 >はきちんと実施しました。 でしたら、その場所に「leapd.lib」がちゃんとあるか確認…ということになるかと思われます。 # ないとは思いますが、セキュリティ対策ソフトが誤検出して削除された…なんてことも……。 バックグラウンドでセキュリティソフトがスキャン中…ということもあるかも知れませんので、OS起動してしばらく待ってからやった方がいいかも知れません。 掲示されたページは直接リンクで飛べなくなって…いる模様。 カテゴリの「Leap Motion」から2013-07-24のエントリ探して下さい。＞他の回答される方 画像が貼られていたような気がしますが、現状で見えない？？？？
画像キャプチャではなく、記述したコードと実行結果を「テキストで」貼ってください。
なにがわからない?
いろんなところでしょう。 プログラマの負担はむしろ重いです。 ○多くの言語では、サブルーチンや関数は、どんな順番で宣言しても、同じように利用できます。 　C言語は、先に宣言しないと使えません。 　プログラマとしては、場所を考えないといけないので面倒ですが、コンパイラにとっては上から順番に処理すればいいので簡単になります。 ※ 他の言語では、「とりあえず保留しておいて、宣言が見つかったら戻る」とか「最初に宣言の一覧を作るために読み込んで、そのあと頭に戻ってコンパイルしなおす」とかの工夫が必要です。 ○一番はっきりと違いが出るのは配列でしょう。 他の言語では、添字がちゃんと確保した範囲になっているかチェックし、エラーを出したり、自動で範囲を増やしたりします。 C言語では、そのようなチェックはありません。範囲も増えません。 範囲内で使うように、プログラマが注意しないといけません。 そのかわり「チェックする」動作が無い分、プログラムが軽くなります。 範囲のチェックをしないので、範囲外にアクセスしても、律儀に該当するアドレスにアクセスしにいきます。 例えば int a[10] ;としたとき、 a[10000]=0 ; としても、それ自体はエラーではありません。 しかし、実際にはエラーになることも多いです。 それは、a[10000]のアドレスがOSで保護されているとか、プログラムの他の変数の領域を書き換えてしまったからとかいった理由からです。 まったく影響の無い領域になっていて、何事もなく処理が続く場合もあります。 このような配列の仕様は、脆弱性にもつながります。 例えば、文字列は文字の配列です。\0までが区切りです。 この区切りを忘れると、本来の文字列の範囲を越えて、\0が見つかるまで文字列だと認識します。 ユーザー名だけprintfしようとしたのに、\0が入ってなかったため、続けてパスワードまで表示してしまった、等ということが起りかねません。
検索して見つかるps2000con.cはVC++6.0用ってワケではなさそうですが。 ファイルの先頭あたりにあるコメントでは2006年に最初のモノが作られたっぽいですけど。 # あと、VC++6.0はとっくにサポート切れです。 >コマンドラインで、 >DUMPBIN /EXPORTS PS2105AD.DLL >を実行すると、次のように表示されます。 >1 0 00001028 PsOpen そのDLLで外部から利用できるのはPsOpenという名前の関数になると思いますが そのあたりは間違いありませんか? >if (kbhit ()) そのDLLがリンクされるアプリケーションに標準入出力が割り当てられていないと、たぶん動作しませんがそのあたりはちゃんとされていますか？ # Win32コンソールアプリケーションとかですね。まぁ起動した後で再割り当てするというのもありかもしれませんけど。 >購入したオシロスコープ装置に、開発者向けサンプルプログラムが付いてました。 Picoscope2204Aか、その系統…でしょうかね？ PS2105ADって名前つけているところからPicoScope2105？ # http://akizukidenshi.com/catalog/g/gM-01621/ 私自身はソフト屋さんなので、電気の方のオシロスコープ使うことはないのですが……。 https://www.picotech.com/downloads の「PS2000 Software Development Kit 10.5.2」ですかね。 「C gui」ディレクトリの下にVisual C++ Express 2010向けに作成されたサンプルが、 「Wrapper」ディレクトリの下にVisual Studio Express 2012 for Windows Desktop向けに作成されたサンプルがあるようです。 サンプルコードからDLLに用意されているAPIのコール順などを調べ、自前で必要な処理を組み込んでいく…ということになると思いますが。 # 現物ありませんしこれ以上は不明…ですかね。 # 英語が大丈夫でしたらメーカーのフォーラム利用された方がいいかもしれません。 # https://www.picotech.com/support/
……うーんと、自分は OpenCV 全く知らないのですが、関数名で検索した結果以下のページが見つかりました。Java なんですが。 http://blog.goo.ne.jp/nobotta50/e/030481c86ccf27 … このページ最初の画像の直前のコードを見て C++ に置き換えると、どうも vector<Point> が輪郭一つ分のデータでその中にはその輪郭の頂点が入っている、そして画像内に輪郭は複数あるのが普通だからそれを vector にしてまとめている、ということのようです。 Kinect から画像データを持ってくるという事はノイズやらなんやらで自分の欲しい物体以外の輪郭も混ざると思うので、それらのなかから目的の輪郭を見つける必要があると思います。 そのあたりをどうしたらいいか……ごめんなさい、自分の知識ではここまでです。
独学と掲示板で尋ねてプログラムを作っているので、いつまでも初級者ですが 誰も回答がないようなので... 私の場合、メインプログラムで何度も使う処理（メインプログラムとは別にしておく方が使いやすい）、１つのまとまった処理（別にしておくとデバッグがやりやすい）、初期化とか終了時の処理、他のアプリでも使えそうな処理をサブプログラムにしています。
質問とは関係ないところですが、解釈の間違いがあるので指摘します。 > struct tanka_kosuu data [10]; > 構造体宣言 構造体名　 変数名　値・・10を代入 これは全体として変数定義です。 定義している変数名は data、変数の型は struct tanka_kosuu[10]です。 値の代入なんてしていません。 > 　　　　　 struct tanka_kosuu kari_nyuuryoku = {-1, 0, 0}; > 　　　　　　　　　　　　　　 型　構造体メンバ(変数名)の初期化 インデントの付け方を見るに前の行に深く関連した行と見ているようにお見受けしますが、後の変数の使用で生まれてくる関連性はともかくこの行自体は前の行とは関連はありません。現に前の行と位置を入れ替えても問題なく動作します。 これは全体として変数定義です。 定義している変数名は kari_nyuuryoku、変数の型は struct tanka_kosuu です。 また、変数の初期化を行っています。構造体メンバの初期化ではありません。{-1, 0, 0} という struct tanka_kosuu 型の値を用いて初期化を行っているのです。 まあ、ご質問の箇所も #1 の方がされているような後の方の使われ方を見ての説明をすることも可能ですが、この行だけを抜き出せば「int 型で nyuuryoku_kosuu という名前の変数を宣言し、0 という int 型の値で初期化している」という意味しかありません。 ……しかし、どこにあったコードなのか知らないけど、11 個目以降を入力できてしまうのは問題だし、各々の kingaku が 0 になってしまうのは何なんだかなぁ。 それとも、この後の解説で上記の問題があると指摘して「ではこれらを直していきましょう」という流れの解説なのかなぁ……
うん, やっぱり何もわからない. あなたは「消える」とか「なくなる」とか言ってるけど, それがどのような状態であるのか何も書かれていないので, 他人にはまったく通じていないということを理解してほしい. ということで, #4 にも書かれてるけど ・どのようなプログラムで ・どうなった結果として 「メモリが消える」あるいは「確保した領域がなくなっている」と判断したのか, すべてを公開してください.
とりあえず, この質問のいったいどこが C や C++ に関係するのかを明確にした方がいいと思う.
>教えるコツや「ここは重要だよ」というところがよくわかりません。 「自分が理解するのに戸惑った部分」とかは全くないのですか？ 先達のそういうところを伝えるのが効果的かと思われますが。 # 自身の経験なら説明もしやすいでしょう。 といいつつ、改めて説明しようとするとパっとは出てきませんねぇ。 う~~ん… ・ループの終了条件に気をつけろ 　無限ループや1回も実行されないとかいう可能性に。 ・実行される回数などには注意しろ 　バッファオーバーランとか引き起こしやすい。 ・whileループとdo~whileループの違い、forループをwhileループで書き直せるパターンがある 　forループか展開したwhileループにするか、どちらが適当なのか…とか。 ・break文とcontinue文 　continueしてから終了条件で抜ける…なんてこともあったりはしますね。 なんのためにループが必要なのか…ってのも最初にやった方がいいでしょうねぇ。
あなた (ないし誰か) が作ればあります.
＃１です。 >struct tanka_ data {　・・・・（１） >　　int tanka; >　　int kosuu; >　　int kingaku; >}; ・・・途中省略 >}　これでいいでしょうか （１）のところは、変えてはいけません。 struct tanka_kosuu {　 のままにして下さい。 他は、問題ありません。
>元になるファイルができますが、Formを作る方法がわかりません。 リソースエディタはないので、Formではなくダイアログを作りたいのであればフリーのリソースエディタなどでダイアログリソースを作成して下さい。 スケルトンでもウィンドウプロシージャはあるハズですので、 自前でいろいろ追加していけばそれなりのモノは作れるでしょう。 # CreateWindow()で子ウィンドウとしてボタンを作る。とか。 いずれにしろ、GUIでお気楽にForm作成♪はできません。 ダイアログでよければフリーのリソースエディタでダイアログリソースを作成し、 自前でダイアログプロシージャなどを実装して……。 といった具合の作業が必要です。 # 記事内容は古いですが、「猫でもわかるWindowsプログラミング」とか参考に……なるかなぁ。 # 他に「Win32API」とか「Win32SDK」とかのキーワードで検索して下さい。 本題(?)のローカルフックに到達するまでにそれなりに壁がありそうですけど。
> プログラムファイルが*.c(*.cpp)だけの場合は、空のプロジェクトを作って、 >そこに*.cを追加して 普通のサンプルであればプロジェクトファイルもついてると思うのですが なかったんですか？　　という疑問はおいておいて ほかのファイルでも基本的には　*.c と同じです ライブラリファイル(*.lib)をプロジェクトに追加すればリンクエラーがなくなって 実行モジュールができるはずです dllファイルは実行モジュールと同じフォルダに置くか windows\system32フォルダにおいておくだけでいいと思います （存在しない場合実行時に読み込みエラーでメッセージが表示されるはずです）
６，４，０，８，２，６が偶数なので数は６個です。 あなたが正しいです。解答（５個）が間違っています。
できますよ。 struct tanka_kosuu kari_nyuuryoku = {-123, 456, 789}; 　 でも struct tanka_kosuu kari_nyuuryoku = {555,666,777}; 　 でもＯＫです。 ただ、 struct tanka_kosuu kari_nyuuryoku = {0,666,777}; //666,777は任意の数字 とすると、 コンパイルはＯＫですが、実行すると、直ちに終了します。
pWnd->GetWindowText() って GetWindowText API のラッパーだと思うのですが、 プロセス間のやりとりは無理でしょう。 SDKベースで書くなら次のようにすれば取れるはず。 HWND hWnd = .... TCHAR tmp[128]; ::SendMessage(hWnd, WM_GETTEXT, (WPARAM)sizeof tmp, (LPARAM)tmp);
gcc使っていないんで、細かいところはアレですけどねぇ…。 >warning: cast from pointer to integer of different size int型とポインタでサイズが違う。って警告ですかね。 その辺りについてはgccのオプションで32bitか64bitか指定できるかと。 # Win32API使うんなら、int型もポインタも32bitとして指定した方がいいでしょうね。おそらく。 https://oshiete.goo.ne.jp/qa/8601577.html Linuxですが…-m32オプションかな？
FILE *fp = fopen("fileName", "r"); は、 FILE *fp = fopen(fileName, "r"); でしょうね。 他はいいと思いますが。 細かいことを言うと、argv[1] を参照する前に、argcの値をチェックすべき。
本題とは無関係ですが, 「if文の構成より、while文のほうが作りやすい」ってどういうことなんでしょうか. if と switch で悩むことはあるし実際質問の状況だとどっちにしようか考えるけど, 「if にするか while にするかを検討する」って状況が想像できない.
まじめにがんばるなら ICU (not International Christian University nor Intensive Care Unit) とか＞#2.
>sizeof(double)=8ですので、8づつ増えると思っていたのですが、+2、+8、+2という 全く予想していない結果となりました。 +8づつ増えていますよ 書式%pなので、アドレスを<16進数>表記を忘れいません?
このファイルには「条件付コンパイル」という手法が使われています。 その条件は #if defined(_MSC_VER) || (__TURBOC__) || (LSI_C) です。 _MSC_VER 等は「定義済みマクロ」と言われるもので、そのうちのコンパイラの情報を表わすものです。 これによって、「VisualC++,TurboC,LSI-C だったら conio.h をincludeする」「それ以外ならcurses.hを使う」となります。 conio.h はWindows/MS-DOS用のコマンドプロンプト環境での入出力を扱うライブラリ(のヘッダ)です。UNIX/Linuxにはありません。 逆に、cursesはUNIX/Linuxでの端末の入出力を扱うライブラリです。Windowsには通常はありません。 普通にやったら別々にプログラムを用意する必要がありますが、それを一つにするのが「条件付きコンパイル」です。 なのですが。 この判定では、 MinGWやCygwinでGCCを使った場合は、この判定に使われているマクロは定義されていないので、UNIX/Linuxと判定されます。 対処方法は ○Cywin/MinGWでCursesが使えるように設定する ○MinGWだったらConioを使うように設定する のどちらかになります。 Cygwinだったら、セットアップからcurses関連のものをインストールします。 MinGWはほとんど使ってないので、詳細はわかりません。
こういうことですかね…？ なにかそもそもからして間違ってたらごめんなさい。 入力するx,yは正の実数とありますが、特に入力時にチェックなどはしていません。 #include <stdio.h> #include <stdlib.h> #include <string.h> int main(void) { double input_x, input_y; char tmpstr[100]; int sx, sy; double y; int count = 0; printf("x = "); fgets(tmpstr, 100, stdin); input_x = atof(tmpstr); printf("y = "); fgets(tmpstr, 100, stdin); input_y = atof(tmpstr); //printf("x = %f, y = %f\n", input_x, input_y); printf("三角形: (0, 0) (%f, 0) (%f, %f)\n", input_x, input_x, input_y); for (sx = 0; sx <= input_x; sx++) { y = input_y / input_x * sx; for (sy = 0 ; sy <= input_y ; sy++) { printf("sx = %d, sy = %d ", sx, sy); if (sy <= y) { printf("三角形の内部"); count++; } printf("\n"); } } printf("三角形内部の整数点: %d\n", count); return 0; }
https://msdn.microsoft.com/ja-jp/library/hh97346 … 2010では無理そうですが……
「写経」って、何ですか?もしかして、本のプログラムをそのまま打ち込んだ、ってことですか? もしそうなら、まだその本でやるべきことが残っています。 ○打ち込んだプログラムを実行してみましたか? ○エラーになったとき、その原因を理解し、修正できましたか?(元本と見比べてはいけません) ○打ち込んだプログラムを、別なものに変更しましたか? 　例えば、小さい順に並べるプログラムを大きい順にする、とか
普通は画像処理で寸法測定をする場合、対象物を画像化して、測りたい部分が何ピクセル（ドット）で構成されているかを数えます。事前に1ピクセルの大きさを調べておけば、単純な掛け算で寸法が求まるわけです。 （大きさがわかっているものが何ピクセルあるか調べ、ピクセル数で割れば1ピクセルの大きさがわかる） 市販の寸法測定器だと、測りたい場所の指定は人手で行うものと、自動で対象物を連続で流して事前に決まった位置で停止させ、設定された場所を次々に測定するもの等があります。前者は測定器に多く、後者は生産ラインで寸法の合否判定に使われることが多いです。 一度、寸法測定 画像処理 アルゴリズム とかでググってみるのも参考になるでしょう。
一応，System.IO.Packaging https://msdn.microsoft.com/ja-jp/library/system. … 以下のクラス群を使ってOOXMLのXMLをパーツとして保存していけば，.docxを生成することは不可能ではないです。 テンプレートとなる.docxがあって，その一部を書き換えて済むのであれば，この方法が一番簡単だったりします。
puppy linuxは使ったことありませんが……。 >Urxvtという端末でhello worldを出力させるのでしょうが >どのような順序で進めていいのでしょうか？ 作成したソースファイルのあるディレクトリに移動して、ビルドしてください。 cc hello.c または gcc hello.c 辺りでビルドできると思います。 おそらく、a.outという実行ファイルが作成されるでしょう。 ./a.out とすることで実行できます。 「Linux C言語 学習」とか、そういったキーワードで検索するとサイトとか見つかるんじゃないでしょうか。 ドットインストールでもその程度は解説しているんじゃないですか？ http://dotinstall.com/lessons/basic_c/9402 の2:10辺りからやっているように見えますが。 # 作成される実行ファイルのファイル名を指定していますけどね。
レノボの場合、ThinkPadなどのPC製品は国際保証になるが タブレットなどは海外での修理保証などは無いらしい https://support.lenovo.com/jp/ja/documents/srvc- … 元の製品価格から考えれば、日本に送り返して修理出すくらいなら現地で新しいのを買った方が早いんだろうなぁ
JIS X 3010:2003 / 5.1.2.2.1 プログラム開始処理 より抜粋 > argc の値が正の場合，argv[0]が指す文字列は， > プログラム名（program name）を表す。 > argc の値が 1 より大きい場合，argv[1]から argv[argc-1]までが指す文字列は， > プログラム仮引数（program parameter）を表す。 というわけで、 if ( argc < 2 ) でなければ 「argc の値が 1 より大きい」 なので argv[1] は「プログラム仮引数の1番目」です。 具体的な例 (Windows のコマンドプロンプト画面でプログラムを動かす場合) 実行 C:\hoge>行数計算.exe 計算対象.txt 無関係な引数 結果 argc == 3 strcmp(argv[0], "c:\\hoge\\行数計算.exe") == 0 // たぶん strcmp(argv[1], "計算対象.txt") == 0 strcmp(argv[2], "無関係な引数") == 0
> 複数のクラスで共通で使うクラスを作成したいのですが、 > そのようなクラスは、どのような名前にした方が、よいのでしょうか？ 数ある共通クラスに”共通”する名前をつけたいということでしょうか？ であれば、これには、common, utilitity といった単語、あるいはそれをcmn、utilと いうように略して共通クラスの名前の先頭または末尾につけることが多いです。 (こういうのを接頭辞とか接尾辞といいます) 例えば、"CmnDialog "のように。 #老婆心ながら、utilityとかcommonとかいう英単語の意味は調べてから使ったがいいですよ。 #utilityでないものにutilityと名づけてバカにされてるプロジェクトは割りと多かったりしますから。 ただ、C++ならば、接頭辞/接尾辞ではなく、名前空間を使うことをオススメします。 例えば、common::hoge_classといったような感じで。 >　また、そのような関数クラスは、どのクラスを親にしたらよいのでしょうか？ ちなみに、 > ※定義を集めた.hファイルはdefien.hなどのような一般的な名前 ここで挙げられた、"define.h"のような、内容を表さない意味のない名前は、名前の付け方に失敗している、一般的な例です。 また、C/C++では、No.1さんの回答にあったアッパーキャメルケースだけでなくスネークケース (quoted_printable_encodeとか)も一般的です。JavaだとNo.1さんの仰るとおりですけどね。
ガボールフィルタで検索すると見付かるけど... それじゃダメなの?
#1の方の指摘が正しいです。 ・・・ do{ scanf("%d", &no); if(no != store[ans]){ printf("違います。もう一度入力しなおしてください。\n"); } }while(no != store[ans]); } ・・・の if(no != store[ans]){ を if(no != num[ans]){ }while(no != store[ans]); を }while(no != num[ans]); に修正してください。
>バイトオーダーを行っています。htonlやntohlの64bit版はないのでしょうか？ バイトオーダーを行っています。・・この意味が不明です。 バイトオーダーの変換を行っています。と理解します。 linux32bitで動いているC言語のアプリを、linux64bitに移行する場合、 無条件にバイトオーダーの変換を行うなら、htonlやntohlを使うべきではありません。 これは、実行時のマシンがsparc系（ビッグエンディアン）なら、一切データの変換は行われません。 実行時のマシンがINTEL系（リトルエンディアン）の場合に、エンディアン変換を行います。 そもそも、エンディアン変換を行うのは、ネットワーク通信でポート番号及びIPアドレスを変換する場合のみです。IPV6については、判りませんが、少なくともIPV4環境では、htnl,ntohlの64ビット版は必要ありません。（６４ビットアプリでもhtnl,ntohlを使用すればIPアドレスの変換を正しく行えます） 無条件に６４ビットデータ（8バイトデータ）のエンディアン変換をしたい為に、htnl,ntohlの64ビット版がほしいといわれているように見えますが、そうであれば、そもそも、32ビットアプリの時に その機能を実装しているのではないでしょうか？ long型のデータを通信相手に送信する場合、３２ビットアプリでは４バイトのデータを送りますが、 ６４ビットアプリでは８バイトのデータを送ることになりますが、これは、そもそもあってはならないことです。つまり、送信側の都合で（32ビットから64ビットアプリに変わったという理由で）、送るデータのサイズが変化してはいけない筈です。 つまり、32ビットアプリの時点で、４バイトのバイトオーダ変換をしている場合は、 64ビットでも４バイトのバイトオーダー変換をすべきです。 又、つまり、32ビットアプリの時点で、８バイトのバイトオーダ変換をしている場合は、 その時点で8バイトのバイトオーダー変換の機能を実装しているはずなので、新たにその機能を求める必要はないということです。 以上が、htnl,ntohlの64ビット版に対する回答ですが、無条件にバイトオーダーの変換を行う機能が 欲しいいうことであれば、linuxでは16ビット、32ビット、６４ビットようにバイトオーダーのスワップマクロが提供されています。 bswap_16、bswap_32、bswap_64がありますのでそれが、使用可能です。 以下、使用サンプルです。 --------------------------------------- #include <string.h> #include <stdlib.h> #include <stdio.h> #include <byteswap.h> dump(char *name,int len,void *ptr) { int i; unsigned char *p = (unsigned char*)ptr; printf("%s=",name); for(i=0;i < len; i++,p++){ printf("%02X",*p); } printf("\n"); } int main(int argc , char *argv[]) { //64ビット環境あることの確認 long long1; short short1; int int1; long long int longlong1; printf("sizeof long=%d\n",sizeof(long1)); printf("sizeof short=%d\n",sizeof(short1)); printf("sizeof int=%d\n",sizeof(int1)); printf("sizeof long long=%d\n",sizeof(longlong1)); long1 = 0x0123456789ABCDEFLL; short1 = 0xABCD; int1 = 0x1234ABCD; longlong1 = 0x123456789ABCDEF0LL; //スワップ前 dump("long1",8,&long1); dump("short1",2,&short1); dump("int1",4,&int1); dump("longlong1",8,&longlong1); long1 = bswap_64(long1); short1 = bswap_16(short1); int1 = bswap_32(int1); longlong1 = bswap_64(longlong1); //スワップ後 dump("long1",8,&long1); dump("short1",2,&short1); dump("int1",4,&int1); dump("longlong1",8,&longlong1); return 0; } ------------------------------------------------ 以下、実行結果です。 sizeof long=8 sizeof short=2 sizeof int=4 sizeof long long=8 long1=EFCDAB8967452301 short1=CDAB int1=CDAB3412 longlong1=F0DEBC9A78563412 long1=0123456789ABCDEF short1=ABCD int1=1234ABCD longlong1=123456789ABCDEF0 ---------------------------------------------- CentOS release 6.3 (Final) Kernel 2.6.32-279.el6.x86_64 on an x86_64 で実行しました。 gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC) で、-m64 オプションでコンパイル＆リンクした結果です。
>参考書では、サイズ指定のない配列の利点は、「配列の次元を変更せずにテーブルを長くしたり短くしたりできること」とありました。 「コンパイルの時点でコンパイラが自動計算してくれる」というだけです。 決して動的にサイズが変更できるワケではありません。 >int str[][3] = { >{1, 2, 3}, >{4, 5, 6}, >{7, 8, 9} >}; とりあえず、str[3][3]と書いたのと同義になります。 が、str[4][3]とか、str[1][3]とかにしたい場合に、添え字の数字を書き換えるのを忘れると問題が発生する場合があります。 # まあ、添え字より多ければコンパイルエラー、添え字より少なければメモリの無駄遣いになる程度ですが。 機能拡張とかしたりした時に、サイズが増える(減る)場合があります。 が、添え字の値まで修正し忘れる。ということはたまに発生しますので、コンパイラが自動計算してくれているだけです。 # 少なければコンパイルエラーで判明しますが、多かった場合のメモリの無駄はエラーにならないので判りません。 というわけで… >int str[][3] = { >{1, 2, 3}, >{4, 5, 6}, >{7, 8, 9} >}; としておいて、 >str[3][0] = 11; だの実行すれば、バッファオーバーランを引き起こし、どこか破壊して吹っ飛びます。 >どこを変更すべきかどなたか教えていただけないでしょうか？ 動的確保なりに変更しないと無理です。 # C++のvectorだったら…よろしくやってくれるかも知れません。(動的確保をラップしてくれている。とも言えますが)
異常終了の原因を区別するためでしょう 大規模なシステムの場合だと、処理が複数のプログラムに分散されることが多いので、 スクリプトなりジョブ管理システムなりで、プログラムの呼び出しを管理することになります。 この様な場合はプログラム毎に実行結果を判断して、 異常発生ならば原因毎に特有の後始末を行わなければいけません。 この実行結果を判断する目的で、大抵のプログラムには終了ステータスの機能が備わっており、 C言語にも main 関数の return 文として仕様に盛り込まれています。 ご提示の例ですと、 終了ステータスが 0 なら、正常終了 終了ステータスが -1 なら、「引数が足りない」 の後始末をする 終了ステータスが -2 なら、「変なのを指定するな」 の後始末をする というように、呼び出し側にて管理することができます。 単体で動くプログラムなら管理の必要はありませんが、 細かく決めた終了ステータスはデバッグ時に有益な情報源にもなりますので、 習慣として指定することをオススメします。 というわけで 質問1: -2 の理由 特に無いが、管理のために決まったルールがあるなら従うこと 質問2: -2 を他の数字にした場合 何の問題もない
補足を見ました。 ＞　「もしコマンドライン引数がコマンド名を入れても２未満なら、言い換えると、 ＞　引数が無ければ、file mei ga naiと表示してプログラムをリターンコードで終わらせる。」 ＞　　と！もっともらしいことを書いています。 ＞　間違いはないでしょうか！？ 若干誤解を与えそうな表現ですが、気持ち的にはほぼ間違いないでしょう。 行間を読まない人のために次のような補足があるとわかりやすいです。 「～を入れても『argcの値が』２未満なら、～」 「プログラムをリターンコード『-1』で終わらせる。」 ＞　ですが、しかし、argcの値は１以下はOKではないでしょうか！？ OKですよ。 argc < 2 ・・・これはargcが２未満（２は入らず、それより小さい）ならば真 argc <= 1 ・・・これはargcが1以下（１も含めて、それより小さい）ならば真 argcの型はint（整数だけの離散値）なので、実質的に上記どちらでも同じです。
えー？はずかしい フォームを使ってて発生するなら別の問題の気がしますが、フォーム使ってないなら mciSendStringはCOMなので、 [STAThread] static void Main() でいけると思いますがどうでしょう
少しは検索くらいしてほしいです。 http://stackoverflow.com/questions/10989690/cant …
調べても出てこなかったので、 本などで調べてみてはいかがでしょうか。 Amazonにいっぱいあります。 http://www.amazon.co.jp/C-%E6%9C%AC/lm/R3G0D6MOR …
補足を読みました。 次はｍａｋｅですね。 　統合開発環境を起動してツールバーの中の「ウインドウ」→「設定」から「Ｃ／Ｃ＋＋」をクリックし展開する。 　次に下の方の「新規　Ｃ／Ｃ＋＋　プロジェクト・ウィザード」をクリック。 　中央のペインの「プロジェクトタイプ」で「実行可能」をクリックして展開。 　それぞれのプロジェクトが４種類現れるので、これをクリックし、右側のペインで適切なツールチェーンを選びます。 　今回は「ＬＬＶＭ　ｗｉｔｈ　ＧＣＣ（Ｗｉｎｄｏｗｓ）（ＭｉｎＧＷ）を示すようにクリックをしてください。 　この次に「優先ツールにする」を押下し、続けて「適用」ボタンを押下して設定を羽根井させてください。 　これでエラーは出なくなると思います。
もし本当に 「半角１文字は＝１バイト＝0～127ビット」 なんて書いてあるような参考書なら捨ててしまった方がいいです. 本当にそんな風に書いてあるとは思えないけどね. 以下蛇足気味につっこむ. 1バイト = 8ビット は C では通用しないです＞#2. あと, ふつうは -127～128 じゃなくって -128～127 だね. ただし規格で保証するのは (#3 でもいわれているように符号の有無が処理系に依存するため) 0 から 127 までだし, signed char でも保証されるのは -127～127 だ.
https://oshiete.goo.ne.jp/qa/8683035.html ただし BOOST 使用.
この例題、あなたの実力と全然マッチしてないですよ。 もっと初歩的な例題を ・配列の意味 ・文字列と文字配列の関係 を充分理解した上で取り組んで下さい。
c/c++ では文字型というのは整数型の一つで、整数と文字を区別しません。 整数の 65 は文字の A です。32 は空白(スペース)です。 文字型と整数型を明確に区別する言語もあります。 あまり一般的に「コンピュータでは」などと考えないほうがよいですよ。 コンピュータでは文字を文字コードに対応させ、内部的には整数値で 扱っていますが、それはあくまでコンピュータの実装上に話。 Cのような抽象度の低い言語ではそれがあからさまに見えてしまいますが、 それをプログラミング言語でどう扱うかは別に話です。
># 「Visual C++ コマンド ライン ツールでは、PATH、TMP、INCLUDE、LIB、および LIBPATH 環境変数が使用されます。」って書かれてます。今回の場合はLIBでしょうかねぇ。 全然違った。 普通にライブラリのファイル名指定するだけでした。 # LIB、およびLIBPATHからファイル名に該当するもの検索してくれます。 # もちろん、上記の環境変数が未設定ならフルパスで指定することになるでしょうが。 ということで、 cl m1.cpp user32.lib だけでとりあえず実行ファイル作成されました。
具体的にはどんなプログラムがどのくらいの大きさになっているんでしょうか?
参考 ---------------------------------- #include <stdio.h> int main() { char mojiretsu[10]; mojiretsu[0] = 'A'; printf("%s\n", &mojiretsu[0]); mojiretsu[1] = 'B'; printf("%s\n", &mojiretsu[1]); mojiretsu[2] = 'C'; printf("%s\n", &mojiretsu[2]); mojiretsu[3] = '\0'; printf("%s\n", &mojiretsu[3]); } ---------------------------------- #include <stdio.h> int main() { char mojiretsu[10]; mojiretsu[0] = 'A'; mojiretsu[1] = 'B'; mojiretsu[2] = 'C'; mojiretsu[3] = '\0'; printf("%s\n", &mojiretsu[0]); printf("%s\n", &mojiretsu[1]); printf("%s\n", &mojiretsu[2]); printf("%s\n", &mojiretsu[3]); printf("%s\n", mojiretsu); printf("%s\n", (mojiretsu + 1)); printf("%s\n", (mojiretsu + 2)); printf("%s\n", (mojiretsu + 3)); } ---------------------------------- 上記の様な2本のプログラムを実行してみて 結果がどうなるか試してみて下さい。
Excelは日付と見なせる文字列や数値を勝手にシリアル値に変換するという「お節介機能」が標準で搭載されています。 それが働いているのだろうと思います。 で、それが年月に直した文字列を年月＆1日のシリアル値として参照しているのでしょう。
Liveメールのアカウント設定方法が知りたいということですか？ http://windows.microsoft.com/ja-jp/windows-live/ …
IMEは、他のアプリケーションからある程度制御できます。 例えば、電話番号欄を入力するときは「全角文字」を入力させないために自動でOFFにする、とか。 そのあと、住所欄を入力しようとして、直接入力のまま、ということだと、これはアプリケーション側の都合です。 住所なのだから、IMEをONするべきだ、という考え方もあります。 住所でも、日本語とは限らないので、下手な制御はするべきでない、という考え方もあります。 そうではなく、例えば 　きょうはいいてんき と打とう として 　きょうはiitenki となってしまう、とかだと、入力ミスの可能性が大きいと思います。
INDEX関数と MATACH関数を組み合わせて http://www.eurus.dti.ne.jp/~yoneyama/Excel/waza/ … VLOOKUPで年度毎に検索対象を変更させる方法もあります。INDIRECT関数と組み合わせます。 http://office-qa.com/Excel/ex178.htm
バージョンは違いますが、 Microsoft Visual Stadio 8 -- vc -- PlatformSDK -- Include にありました。
①② 基本的にはその方法であっています 最新（SP6なら以下） http://www.microsoft.com/ja-jp/download/details. … ③　いくつかありますが　　とりあえず思いつくところで 　　コピーしたDLLはファイルコピーだけで動くのか 　　実行モジュールはきちんとリリース版として作成されているものなのか 　　すべてのDLLが同じバージョンのものなのか ソースがあって開発環境もあるという事なら 再生成したほうが早いという話も無きにしも非ず
試したことはありませんが…… Read()メソッドの第1引数に指定する型によって挙動が変わる…のかも知れません。 https://msdn.microsoft.com/ja-jp/library/ms14354 … https://msdn.microsoft.com/ja-jp/library/34t733f … 後者は「文字列」を意図しているようですので、NewLineプロパティの影響を受けるのかも知れません。
使ったことはないので本当にできるかはわかりませんが、 inotifyのIN_MODIFYイベントをキャッチすればリアルタイムな変更にも対応できそうです。 といいつつ、こういったイベントキャッチ系のシステムコールといえども、 その裏側は定期的な割り込みのタイミングでしか見ていないので、 程度の差こそあれ、#1の方のご回答のような自前コードでも本質的には変わらないような気がします。 つまり、リアルタイムな変更に対応したような気分に浸るか、 なんちゃってだけど体感的にはリアルタイムに対応するプログラムを自作したという満足感に浸るか、程度の違いでしょう。 ちなみに、0は、多分パイプだから、selectでキャッチできるのでしょう。 fork→execするとき、forkの前にpipe作るでしょ、その原理だと思います。
IT企業で採用関係もしてきたおじさんです。 プログラマーになる目標はいいでしょうね。 「企業でプログラマーとして就職するのに一番有利なものは何なのでしょうか？」 →それはある程度の適性と人間的魅力の二つです。 ある程度の適性というのは、コンピュータやソフトウエアの基礎を理解できる力です。 IT企業のほとんどは、採用に関して学校や学部などを問いません。 その理由は、プログラマーやシステムエンジニアになるための教育は入社後に企業で教えるからです。 それを学んで理解する力があればいいので、新卒の場合は経験は不要です。 また、人間的魅力というのはコミュニケーション能力です。 プログラマーやシステムエンジニアというのは技術者ですが、毎日コンピュータだけを相手に仕事しているわけではありません。 社内での打ち合わせ会議、顧客との打ち合わせなど人との話しがとても重要です。 いくら技術力があっても、人との話が苦手では仕事がうまくいかないのです。 また、資格については入社後に勉強して取得しても大丈夫です。 高校生や大学生のうちは、社会性や社交性を磨くことも大切ですよ。
>w=!(a- ++b); で、 >たとえばa=4,b=3だった場合 だと…… w=!(a- ++b); まず++bが評価されてbが4になる。 次にa-bが評価されて0になる。 !(0)が評価されて…非0がwに代入される…ということになろうかと。 wの型とか不明ですが…。
全く違います. ちゃんとマニュアルで確認してください.
代入演算子の一種で、その左辺にある変数に、右辺にある値を加算します。 とりあえず処理としては 　g = g + a[i]; と同じ結果になります。 https://msdn.microsoft.com/ja-jp/library/5bk6ya5 … なぜ 　g = g + a[i]; でいいのにそんな書き方があるのかいうと、これだと「g の値を g に a[i] を足した値にする」という意味になるのに対して 　g += a[i]; だと「g に a[i] を足す」と意味が簡単になるためです。 ……まあ、それ以外に歴史的・機械語的にこっちの方が速いという意味もあったんですが、最近のコンパイラはそのあたりを最適化するので左記の意味は薄れています。
問題の本質とは関係ないと思いつつ回答します。 Wr5様の指摘する >>char *str; //文字列 >>scanf("%s", str); >で、吹っ飛びそうですけど。 は、「char str[50]; 」などとすれば解決します。 あと、左方向の表示の「while(c>i){」の比較をする前に、iに初期値を入れましょう。 putchar(s[cnt+i-len]);の行は、はじめはcntもiも0のはずなので、「cnt+i-len」はマイナスになるのではないでしょうか。この行の意図は読み解いてませんが、「len-i」など0以上する必要があります。 原因の究明は、ステップ実行して自分の想定外の動作を行う場所を特定するか、適当な箇所にprintfを挿入して内部変数の表示機能を追加してプログラムの動作を追わない難しいでしょう。
そのCOBOLは具体的にどのCOBOLなのでしょう。 DLLを呼び出せる機能があるかどうかは、そのCOBOLの処理系次第です。 また、呼び出せる場合でも、その方法がそれぞれに違います。 DLLも特定のルールに従う必要があるかもしれません。 (dllexportするラベルとか、変数などの相互変換とか) マニュアルを読むなりして、上記の二点を確認しましょう。
つ ブログパーツ - goo ブログの使い方 http://blog.goo.ne.jp/how_to/e/89b470fc570d02bbd …
アニメーションのタブで「効果のオプション」とかいうのはないですかね。 「再生の中止」での項目で「次のスライドの後」にチェックをいれて、数字を5にすれば5枚目のスライドが終われば再生中止、という風に設定されます。
ついでにデバッグ方法 ------------------------------------ 　x0 = 0; 　y0 = 0; printf("sizeof(GRID): %d\n", sizeof(GRID)); printf("lengthX: %lf\n", lengthX); printf("numX: %d\n", numX); printf("lengthY: %lf\n", lengthY); printf("numY: %d\n", numY); printf("StartA\n"); 　/*最内層節点作成*/ 　grid[0].g = (GRID *)calloc(numY, sizeof(GRID)); printf("StartB\n"); 　for(i=0; i<numY; i++){ 　　grid[0].g[i].gid = i+1; 　　grid[0].g[i].x = 0; 　　grid[0].g[i].y = i*lengthY/numY; //　　fprintf(stderr,"%d\n",i); 　　printf("%d\n",i); 　} //　fclose(fileW); 　fclose(fp); 　return(0); } ------------------------------------ 上記の様に随時、変数の内容や実行前・実行後に メッセージを出力させる。 長いプログラムの場合は #define DEBUG #ifdef DEBUG 　　printf("%d\n",i); #endif の様にすると便利です。
>if(date2<0){ 終了条件がdate2が0未満のときになっています。 >printf("%d\n",kekka[i]); 表示するのはkekka[i]だけでよろしいのですか。 10 2と入力した場合、何も表示せずに終了するようになっています。 また、整数部と小数部をどのように分けるつもりですか。
DLLやVBという表記から，Windowsを前提とします。 Windowsには，GetCommandLineというAPIがあります。 ref) https://msdn.microsoft.com/en-us/library/ms68315 … これを単純に呼び出せばコマンドラインがそのまま取得できます。 C/C++のmain関数のようにコマンドラインを分解したい場合は，W版のAPIとCommandLineToArgvW APIを組み合わせます。 ref) https://msdn.microsoft.com/en-us/library/bb77639 …
>環境変数から取得したパスを渡せず どのように取得していますか？ >INIファイルパスを指定する引数の型がLPCTSTRのため 『APIの内部処理で、受け取った文字列は書き換えませんよ。』 という意味でのLPCTSTR指定になっているだけですので、普通にLPTSTR型で渡しても問題ありません。
あれがコンパイルできるってことは, とりあえず 「これはsqrt関数(math.h)に関しても同様のことが起こりました。」 については「コンパイル環境の問題ではない」ことがほぼ確定だな. で, 「最後にこういったエラーもでました」って言われても, それでは問題の解決にはなんら役にたたないことはわかるね? むしろ「関数の参照ができないというエラー」よりも前のメッセージが重要なんだよ.
最初にインストールしてからずいぶん経つので、細かいところは覚えていませんが。 最初で、どのパッケージを選んでますか? SInglarは標準ではインストールされないと記憶しているのですが。 Cygwin Terminal はmintty というパッケージに入っている minttyという端末を使用します。 Baseカテゴリーの中に入っているはずです。 初期状態で一緒にインストールされたと思います。
> １）目的のglut.dll内のglutKeyboardFuncの仕様 >　　 glutKeyboardFunc(void (*func)(unsigned char key, int x, int y)) これはC++ではなくCのやりかたですが、これは関数のポインタをあらわしています。 戻り値の型 (*関数名)(引数リスト) とかいてやると、このような戻り値と引数リストを持つ関数へのポインタをあらわします たとえば、 void aaaa(int i) { .... } void (*func)(int i) = aaaa; func(3); これを実行すると、aaaa(3)と同じことをやったことになります。 glutKeyboardFuncはこの仕組みを使ってコールバック関数の指定を行います。 > ２）インポート文 > ３）メソッド内での GlutKeyboardFunc 呼び出し文 について、C#からdllを参照する場合、関数ポインタにはデリゲートを指定します。 デリゲートという言葉そのものを知らないのであれば、まずはインターネットで意味と使い方を 調べられたほうが良いと思います。 あまりC#を使わないので間違えているかもしれませんが、この例の場合 delegate void KeyboardCallback(unsigned char key, int x, int y); [SuppressUnmanagedCodeSecurity()] [DllImport("glut.dll", EntryPoint = "glutKeyboardFunc", ExactSpelling = true)] internal extern static void GlutKeyboardFunc(KeyboardCallback f); GlutKeyboardFunc(new KeyboardCallback(myKeyboard)); 大体こんな感じになるかと思います。
>ファイル名を既存のファイルにした場合は、実行開始とともに、エラーで強制終了。 とりあえずこっちだけ。 >char tension; >fscanf(fp, "%d %d %d %d %d %d %s",&year, &month, &day, &h, &m, &s, tension); tensionの値が不定ですが…とりあえず入っている値(0x00から0xFFのどれか)をアドレスとして、その場所に気分を書き込みます。 ということで気分でアクセス違反してみたりします。 # char型なのでアドレス0x00000000から0x000000FFのどこかに書き込んでみたいです。 # 普通はそんなところへの書き込みを許可できないので、OSさんがへそ曲げられました。 正しくは… char tension[100]; fscanf(fp, "%d %d %d %d %d %d %s",&year, &month, &day, &h, &m, &s, tension); とかかと思いますけど。
C++/CLIであれば，C++の配列ではなくCLIの配列型(C++/CLIではarray<int>^)を使うようにした方がよいでしょう。 これはmanagedなクラスなので，managedなクラス内に記述することが出来ます。 # C++/CLIはC++とは別の言語だと認識した方がよいです。 ただ，突き詰めるとそもそもC++/CLIを使う必要があるか，という根本的な問題が横たわりますが……。
ご存知のとおり計算機は二進数(バイナリ)で全てのデータを処理します。 その意味で char も int も float も char[] も、ぜんぶ整数と似たようなものです。 違うのはデータを処理するプログラムが、型を元に * char => 8桁の二進数であらわす文字コード * int => 32桁の二進数であらわす整数 * float => 32桁の二進数であらわす実数(符号1,仮数23,指数8) * char[] => 64桁の二進数であらわす、char を羅列しているメモリーの先頭アドレス (たぶん) というお約束を守ってくれるので、 プログラマーからはあたかも char が文字の様に見えたり、 char[] が文字列の様に見えるわけです。 さて printf で書式指定を細かく書く理由ですが C言語は「弱い型付け」の言語でして、以下の二つを両立するための設計です * 低級言語としての効率性 → 型チェックを実行時に行わない → 高速に処理できる * 高級言語としての利便性 → 型チェックをコンパイル時に行う このため * 関数に渡す引数が正しいかは、コンパイル時の型チェックで可能 * コンパイル済関数の内部では型チェックができないので、引数の型が(本当の意味で)わからない printf はコンパイル済関数であり、かつ汎用的な引数指定であるため、 実行時に引数の型がさっぱり分かりません。 なので書式指定子という方法で引数の型を明示して、 上記の char だか int だかのお約束が守っているわけです。 「強い型付け」の言語ならこの様な配慮は必要ないのですが、 実行時の型チェックはかなり重い処理なので、 効率性の点でC言語に及ばない様です。(異論あり)
No.1 で既に回答がありますが。 　Data(100); // （２） と書いた場合、この文が実行されている間、Data class の 100 というパラメータを受け取ることのできるコンストラクタが実行されて、この文を抜けるときに、Data class のデストラクタが実行されます。 言い換えると、この間、有効なインスタンスがひとつできているので、例えば、Data class の、hoge() というメンバ関数が存在すれば、 Data(100).hoge(); と、メンバ関数を実行させることができます。 例えば、日付を扱う Date class があったとして、 int dayOfWeek = Date().deayOfWeek(); のように、「今日の曜日をもらう」という処理が、見かけ上簡単にかけたりします。 ※引数無しの Date class が今日の日付で初期化されるという前提で。
Car mycar = { {0.0, 0.0}, 90.0}; は、厳密には「代入」ではなく「初期化」と言います。 「変数を宣言するときに、同時にその内容を決める」というものです。 見た目はそっくりですが、文法的には別のものと解釈されます。 Car mycar ; mycar = { {0.0, 0.0}, 90.0}; とは書けません。こちらは「代入」です。 「代入」とは「変数等に値を設定する式」です。 mycar.pt.x=0; mycar.pt.y=0; mycar.fuel=90.0; と書く必要があります。 初期化という言葉には、C言語の文法での意味の他に、プログラムでの機能としての意味もあります。 count=0 ; while(XX) { count ++ ; } といったプログラムでは、 count=0 は 　文法的には「変数countに0を代入」 　プログラムの機能としては「変数countを初期化」 となります。
char 入力された文字列[10][80], *並べ替えバッファ[10], *p; for (i=0; i<10; i++) 入力する(入力された文字列[i]); for (i=0; i<10; i++) 並べ替えバッファ[i] = 入力された文字列[i]; /* 文字列[5]と文字列[4]を比較して、文字列[5]の頭文字が若い場合、交換する */ if (strcmp(並べ替えバッファ[4], 並べ替えバッファ[5]) > 0) { p = 並べ替えバッファ[4]; 並べ替えバッファ[4] = 並べ替えバッファ[5]; 並べ替えバッファ[5] = p; } for (i=0; i<10; i++) 出力する(並べ替えバッファ[i]);
Sleepの前にDoEvent差し込むと簡単ですが、予期できない副作用を沢山招くのでお勧めしません。 SendKeysを正しく呼び出しているか表示したいだけであれば、ラベルへの表示ではなく、 Debug.Printを使う方が適切かと思います。 またSendKeysはキーストロークをエミュレーションしているだけなので、確実に、"テスト"とメモ帳に送信されるとは限りません。 なので、もし本当にやりたいことが別にあるのであればSendKeys以外を使うことをお勧めします。
モダンコンバットの5ですか？ であれば4のAndroidとiOSの様にサーバーは違うはずですね。 一緒にプレイできるようになるかどうかは公式に問い合わせてみる方が良いかと… （現状、一部機種が正常にプレイできなかったりするそうなので難しいとは思いますが）
goto NEXT;　の行き先がないですよ。
64 ビット環境向けなら size_t が64 ビット化されているので標準の C ライブラリで大丈夫……なのかなぁ。 https://msdn.microsoft.com/ja-jp/library/3b2e749 … そうでないなら Win32 API の助けを借りることになりそうです。 http://rarara.cafe.coocan.jp/cgi-bin/lng/vc/vcln … https://msdn.microsoft.com/ja-jp/library/cc42912 …
さしあたり思いついたのは、 (上下反転してから)bmp形式で保存して適当なバイナリエディタで開いたものを適当なテキストエディタで整形する方法と、 GIMPでHTML表形式で保存して適当なテキストエディタで整形する方法です。 もしかすると他によい画像形式があるかもしれません。たとえばPPMは10進ですが文字表示になります。
スレッドハンドルが取れるので…GetExitCodeThread()APIで取得できるんじゃないでしょうか？
「char chの部分をintにすると、望んでいない動きをしてしまいました（強制終了）」ということですが, プログラム全体を出したうえで「望んでいる動き」とやらを具体的に説明してもらえませんか? 「int chで書き換えたときは、int ch, scanf("%d", &ch)の変換でいいのですか？」については「あなたがどのような動作を求めているのか」によります. で統一したいだけなら (この場合に関しては) char にしとけばいい.
https://msdn.microsoft.com/ja-jp/library/wweek9s … とあるように、これは、外部のコマンドを実行するためのものです。 コマンドプロンプトでコマンドを実行して、その結果を使う、という感じです。 単純に置き換えるなら https://docs.oracle.com/javase/jp/6/api/java/lan … 等を使って、ということになりますが.... spawnlで実行しているのは、Windows用の実行ファイルです。 Windows上でJavaを実行しているのなら、そのままでも動くかもしれません。 しかし、Androidで実行するなら、実行ファイルの形式が違うので動きません。CPUも違うでしょう。 このコマンドで何をしているかを調べ、同じ処理をするAndroid用のプログラムを探すか用意するかが必要です。
・変数 や関数の役割を考えましょう。 変数maxはなにを表わしていますか? それを踏まえて「bunpu[i]がmax以上の数であれば」でやりたいことは合ってますか? ・プログラムの構造を考えましょう for(i=max; i>0; i--){ 　1行出力する。 } という構造にしたいはずです。そして、「1行出力」とは、例えば for( jを0〜bunpuの最大添字まで ) { 　bunpu[j]の内容に応じて'*'か' 'を出力 } 改行 という構造になると思います。これを組合せれば for(i=max; i>0; i--){ 　for( jを0〜bunpuの最大添字まで ) { 　　bunpu[j]の内容に応じて'*'か' 'を出力 　} 　改行 } という構造になります。
質問者さんの今の状況は、四則演算も理解していないのに「数学に興味を持ったので、テンソル解析の問題を解いてみたいと思っています。xxすれば解けるのではないかと思っていますが、Σという記号の意味が分かりません。なんでもよいからヒントを教えてください」と言っているようなものです。 回答している皆さんはどれだけ的外れな質問をされているかは理解した上でご回答されていると思いますが、まず質問者さんご自身が基礎知識を身につけなければハナシになりません。まずフツーにプログラム言語を「利用」できるレベルになって、それから簡単なインタプリタが実装できる程度の知識は身につけましょう。並列計算の「実験」はその後のハナシです。
ソフトを作成するってかなり難しいと思います。 他の人のソフトを見て参考にしてみたらどうですか？ http://jra-van.jp/dlb/sdv/trial.html ここの競馬ソフト体験教室では、競馬ソフトを作成していく過程を ステップアップ形式で解説してくれるみたいなので、 こちらもおすすめします。
scanfはかなり上級者で無いと使いこなせない関数です。初心者は使ってはいけません。 fgetsを使ってください。 printf("文字列 : "); fgets(str, sizeof str, stdin); printf("文字 : "); ch = getchar(); あと、 ＞printf("%cは%d番目にあります。\n", ch, i+1); は、 printf("%cは%d番目にあります。\n", ch, no+1); の間違いですね。
＞以上間違いございませんか！？ 間違ってます。 printfとは、データをいろいろな形式に変換して表示する関数。1文字とか、文字列とか、10進数とか16進数とか、いろいろ。 putcharとは、1文字を出力する関数。 ＞ネットで検索かけても、機械的な回答ばかりで、生身の人間には伝わってこない説明文ばかり、 入門者はネットで無くまずは入門書を読むべきだと思います。 ＞参考書は形式こだわりすぎじゃん・もっとわかりやすい表現とか解説ができないのかな その参考書の対象層が自分と合っているかを十分立ち読みなどして確認する必要があります。
まずは、main() のなかに書いてある return と、それ以外の関数に書いてある return を分けて考えましょう。 ※本来は、同じものなのですが。 main 以外の関数（例の場合では、int kansuu() の中にある、 return 100;）の場合は、比較的わかりやすいと思います。 この関数は、 modori = kansuu(); という形で、呼ばれて、その「結果」が、modori に代入されています。 どの値が代入されるかといえば、関数で実行された、return の次の数字になります。 int kansuu() では、最後に、return 100; が実行されるので、「呼び出された」kansuu() の値は、この、100 になります。 これが、main() 以外の関数に書かれた return の挙動です。 では、main() のなかにある return は何かといえば、これは、わかりにくいと思います。 なぜなら、「main() はどこからも呼び出されない（見かけ上）」からです。 実は、「main() はどこからも呼び出されない」というのが間違いで、おおざっぱに言えば、OSから呼び出されます。 大抵の参考書では、「Ｃのプログラムは、main() から実行される」と書いてあります。 これは、もう少し詳しくいえば、「OSがmain() という関数を呼び出す（本当は、ちょっと違う）」というわけです。 なので、main() に書かれている return は、（自分を呼び出した）OSに対して、値を返すために使用されます。 OSからの呼び出しなので、明示的には見えませんが、 kekka = main(); のような事になっていると思ってください。 で、OSは、ここで返された値を使うことがあります。（使わないこともあります） 使う場合、「0 なら正常終了、それ以外なら、異常」という判定のために使用する例が多いです。 なので、main() の中にある、return で、0 以外の値を指定すると、（その結果を使うOSなら）「エラーが発生した」という表示をすることが多いです。
「任意の入力」から当該構造体を作って返す関数を書けばいい. そうする意味はたいていの場合に存在しないとは思うが.
1度目と2度目は、違うドメイン（サーバー）上にアップロードしようとしているという認識で宜しいでしょうか？ 【例】 1度目　…　http://○○○.com にアップロード 2度目　…　http://×××.co.jp にアップロード もしそうであれば、通常は1度目と2度目は違うホスト名・ユーザ名・パスワードです。 ホスト名等を決めるのはドメインの会社ではなくサーバーの会社です。 2度目のドメインに紐づけたいサーバーを借りて、そこからホスト名等の設定をもらって下さい。 今回は違うと思いますが、例外として、同じサーバースペースにマルチドメインで2つ以上のドメインを乗せる場合は、ホスト名・ユーザー名・パスワードは同じです。 もちろん、同じ名前のファイルをUPすれば上書きされてしまいますが…。
分布を n[10] に計算できたとします。 /* 横に並べられたのだから、ここまではいいですね? */ ここで、元のグラフの縦軸に値を入れます。 3:* * 2:* * * * 1:* * * * * * 　------------------------------- 　0 1 2 3 4 5 6 7 8 9 こうすると 3: 分布数が3以上のものに * 2: 分布数が2以上のものに * 1: 分布数が1以上のものに * となっていることにお気付きでしょうか? これに気付けば ・最初の行はn[10]の最大値→最大値を求めるプログラムが必要 ・最大値から1まで逆順にループ ・対象行1行分の出力 という構成になることがわかります。 この手の問題では、規則を見付けることがカギです。
なんだ連投か。
https://oshiete.goo.ne.jp/qa/8814060.html まったく同じ質問してますよね? #1にmain関数のreturnについての説明がありますが、読みましたか? 自分の思い通りにならないことを「バグ」の一言で済ませていたら、先には進めません。
もしあなたがWindowsPCをお使いなら http://windows.microsoft.com/ja-jp/windows/show- … を参照して拡張子を見ながらもう一度試してください。 標準の状態では問題を認識する手段が奪われていますので。 拡張子（ファイル名の後ろにあるファイルの種類）これが、キモなんです。 youtubeは全く別です。検索すれば出てくるかと。
「生徒1人1人の平均点と分散」の「分散」って, 何の分散を求めさせているんだろう. 教科ごとの点数の分散でいいんだろうか? ちょっと文章が謎だ. 余談: いまどき (とはいえ 15年も前のなんだが) の C の規格では #1 のように書いてもいいんだけど, ふるくっさい規格に固執している処理系だとだめなんだよね.
>いま入っているプロバイダは、 >SCRAM-SHA-1 >SCRAM-SHA-1-PLUS >に対応していません。 自前で仮想マシン内にメールサーバ立ててみる。というのも有りでしょう。 http://www.mk-mode.com/nanoc/2014/10/30/freebsd- … FreeBSDでの設定サンプル…ですかね。 私自身はFreeBSDはよく判りませんけど。 # Linux＋Postfixでやっている例があるのかは不明。 # 新しめのディストリビューションならできそうな気もしますけどね。
基本的な考え方は、 関数を使う前に、それがどんなものかがわかっていないといけない。 main()の中で、関数kansuu()が使われていますが、 コンパイラにとって見れば、 kannsuu()って何者？？ となります。 もちろん、最後のほうで何者かは、はっきり書いてあるのですが、 もし、最初の int kansuu(); がないと、定義されていない言葉を使うなといって、コンパイラが怒り出します。 そこで、main()の前に、 int kansuu(); と書いておいて、 こんな言葉を使うから、許してね。内容は跡で詳しく書くからね。 と言って、コンパイラに事前通告をしているのです。 したがって、 #include <stdio.h> int kansuu() { printf("kansuu de hyouji\n"); return 100; } int main() { int modori; modori = kansuu(); printf("modori=%d\n", modori); return 0; } の、順番にすれば、一つで済む。 なぜ、この形にしないのかは、そのうち、分かると思います。 最後の部分を削除し忘れました。 ごめんなさい。
まず、「文字を送ることができない」という所から誤解があります。 return 0; は、たしかに、整数値の 0 を返すことができます。 Ｃでは、0 ～ 9 で構成されるものは、「数値」ですから。 return x; は、x という文字ではなくて、「x という変数の中身」を返します。 そして、x という変数はどこにも定義されていないので、 > Line 13: error: 'x' undeclared (first use in this function) というエラーが出ています。 まず、エラーの意味を理解するように努力しましょう。 もしも、x という一文字を返したいのなら、 return 'x'; になります。 で、この場合、'x' は、char 型のデータとなりますが、実は、Ｃでは、char 型は、整数とおおむね同じ扱いを受けるので、関数の型が int でも、エラーにはなりません。（紛らわしいですが） さらにいえば、 return 'x'; と書き換えるとエラーは出なくなりますが、このままでは（多くの場合）、 modori=120 と表示されます。
も 1つ確認. 「c++の言語仕様に不慣れ」ということですが, では C の言語仕様は大丈夫でしょうか?
Cのマクロは非力なので、 #define case2(a,b) case a: case b: #define case3(a,b,c) case a: case b: case c: ・・・・ のように個数ごとにマクロを作る必要があります。
あと細かいけど C の構造体は名前空間にならない って違いもある.
> ●復帰の\rを使う > ●\r出力後、fflush(stdout);を使うこと。 \n で改行するのはよく使っているかと思います printf("aaa\nbbb\n"); ↓ aaa bbb \r は、改行せずに表示位置が行頭へ戻ります。 printf("aaa\rbbb\n"); ↓ aaa(ここで行頭に戻って)bbb ↓ 画面上では 「aaa」が上書きされ「bbb」だけが見える 出力→待ち→出力とすると、画面が変化したように見えます。 printf("123") ; /*ここで\nで改行しない */ 待ち printf("\r23 ") ; /* 最後に消すための空白文字あり */ とすると 「123」が「23」に「動いた」ように見えます。 ファイルや画面の出力は「バッファリング」というものが行なわれていることがあります。 これは、出力内容を一旦バッファに溜めておいて、ある条件になったら(バッファが一杯になった、改行があった等)実際に書きこむというものです。 これにより、まとめて読み書きすることで、処理の効率をよくしています。 ですが、これのために、上記のようなことをしようとすると、実際には 　"123"をバッファへ 　待ち 　"\r23 " をバッファへ 　バッファを出力 と動作し、外から見た目には 　待ち 　"123\r23" を出力→一瞬なので、"23"が出力されたようにしか見えない となります。 対策の一つは「バッファに溜ったものを強制的に出力させる」です。 　"123"をバッファへ 　バッファを出力 　待ち 　"\r23 " をバッファへ 　バッファを出力 これに使うのが fflush関数です。 /* 他に、バッファリング自体を行なわないようにする、という対策もあります */ > ●時間稼ぎ用の処理（計算など）を使う 例えば int i,dummy1,dummy2=1234,dummy3=5678 ; for(i=0;i<10000;i++) { dummy1 = dummy2*dummy3; } とすれば、10000回かけ算(と、i++)をするので、その分の時間がかかります。 ... と単純にいけばいいのですが。 ○昨今のコンピュータでは、10000くらいなら一瞬です。 「動いている」ように見せるには、もっと多く繰り返す必要があるでしょう。 ○C言語には「最適化」という機能があります。 コンパイル時の設定で様々な最適化を行います。 最適化の中には、ループを最適化、というものもあります。 ループ内容を解析して、同じ効果のある別な命令へ変えてしまう、というものです。 例えば 　for(i=0;i<10000;i++) { dummy1 = dummy2*dummy3; } だったら、ループ回数、ループ内の処理が固定なので、 　i=10000; /* ループ終了後の値 */ 　dummy1=7006652; /* 1234*5678 */ でも「結果」は同じだ、と判断して、実行ファイルに上記内容で書き出します。 これでは、いくらループを増やしても実行時間は変わりません。 ・ 待ちの最初に時刻を取得→規定時間過ぎたら待ち終了 ・用意されている「一定時間待つ」関数を使う 　　(sleep関数だと1秒単位だが、環境によってはより細かいものが用意されている) 等が確実な方法です。
インターネットへの接続サービスを提供する会社のことを、「インターネットサービスプロバイダー」と言います。略して「プロバイダー」です。 インターネットへの接続サービスを提供する会社と契約しないとインターネット接続は出来ません。 回線業者がプロバイダーを兼業していることもあるので、そういう場合はその会社と契約すれば良いです。ケーブルテレビ会社とか、携帯電話キャリアとか、YahooBB(SoftBankBB)とか。 プロバイダーを兼業していない回線業者（NTTフレッツとか）と契約する場合は、別途プロバイダー会社との契約が必要です。
> 数が逆しかできないです......。 とわかっているのなら、逆にするだけです。 次の問題を解いてみましょう ○入力した数値まで、昇順と降順を同時に出力するプログラムを作る 例) 5 を入力したら 1 5 2 4 3 3 4 2 5 1 複雑に見えた元の問題ですが、簡単なプログラムを組み合わせだけだとわかるかと思います。 どんな複雑なプログラムも、実際には「簡単なプログラム」を組み合わせたものです。 この「簡単なプログラム」への分解方法と組み合わせ方法を考えるのが、プログラミングです。 問題に行き詰まったら、分解することから考えてみましょう。
C系のコンピュータ言語では 　a^3 = pow(a,3) という風に書くんですよ。 　a^n = pow(a,n) ね。 ただ、文法にうるさいCコンパイラだと、 　pow(a,b) のa、bのデータの型が実数でなければならないので、bに整数型のデータを入れるとエラーにされてしまう。 BorlandのCコンパイラーなどがその代表。 難しく考えないで、 この質問ページにある return 3 + 2*x + (2*x - pow(cos(x),2) - sin(x)) / (pow(x,2) + cos(pow(x,2)) + pow(pow(sin(x), 3),3)); をドラッグ＆ドロップし、コピーして、ソースプログラムの問題箇所に貼り付ければいいんですよ。 ドラッグ＆ドロップ http://www.pc-master.jp/words/drag-drop.html コピー＆ペースト http://siriasu.s10.xrea.com/etc/copipe.htm それで動くと思うんだけれどな。
「あっぱれ懸賞ダイアリー」は、いかがでしょうか！ 項目の自動入力だけでなく、懸賞情報を簡単に取り込めますし、 条件検索などもしやすいです！ 使いやすいのでおすすめです(*^_^*)
フラグ(flag)の略かと思います。 http://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%B3% …
NO6 です。 失礼しました。 原因は、リリースモードでビルドしたものを デバッグしていたからでした。 デバッグモードでビルドしたものを デバッグしたら、きれいに表示されました。 間違った情報で、混乱させました。 ごめんなさい。
導き方は総当りです。 正規表現 (0|10)*2(1|00|010)+ の場合は、以下のパターンを意味します A. "0" または "10" の 0 回以上繰り返し B. "2" の 1 回繰り返し C. "1" または "00" または "010" の 1 回以上繰り返し このパターンで文字列長 3 の文字列を列挙するなら まずは最低限の繰り返し回数でマッチする文字列を検証 A = 0回 / B = 1回 / C = 1回 "2" + "1" ← 目的より少ない文字列 "2" + "00" ← 目的の文字列 "2" + "010" 目的より少ない文字列 "2"+"1" があったので、繰り返しの回数を増やして検証 A を1回増やす "0" + "2" + "1" ← 目的の文字列 "10" + "2" + "1" Bは回数を増やせない C を1回増やす "2" + "1" + "1" ← 目的の文字列 "2" + "1" + "00" "2" + "1" + "010" 目的より短い文字列が見つからなかったので、これ以上の検証は不要 これにより、目的の文字列は以下に確定 "200" "021" "211"
MSさんは、最近きまえがよくなりました。 Visual Studio Community 2013 with Update 4 が、無料で入手できます。 また、日本語化もできます。 これを使って、 MFC　の　ダイアログボックス　の形態のソフトを作るのが 簡単だと思います。（実際にやってみました。） また、回答者も多くなると思います。
いやいや, int が 4バイトかつ 4バイトアラインと仮定すれば foo->data=new int*[2]; で「bytData[8]が破壊される」のは明らかでしょ? むしろ何をどう考えたら「破壊されない」と思えるのかが知りたいよ. 端的にいえば int x = 1; x = 2; とやったときに「x が 1 のままでないのはおかしい」って思うか, ってことなんだけど.... ちなみに「メンバがこの順番に並んでいるか?」だけは (その場合) 規格で保証されているはずです＞#3. 今の規格 (C++11 and/or C++14) を持っていないの「はず」としておくけど, C++98 でそうなってるしここを変える必然性はないと思うので今でも大丈夫じゃないかな. ほぼ「メンバが隙間無く並んでいるか?」も大丈夫だとは思うけどこっちが成り立つ必然性はない.
> 次にコマンドプロント内に > > HelloWorld.c > > と入力しました。この際に、Visual Studio C++が開き、私の書いたコードが反映されます。 > > そして、コマンドプロントの方は何も表示されない状態になりました。おそらく、コンパイラしてエラーがなかったのだと思います。 ここが思い違いのある場所です。 「今まで、visual studio 2010 C++でプログラムの練習をしていた」あなたの環境では、.c という拡張子を持つファイル名だけを入力した時はその .c という拡張子に対応したプログラムである visual studio 2010 でそのファイルを開くという事を行います。その結果が「Visual Studio C++が開き、私の書いたコードが反映されます」ということです。 そして、その時点では Visual Studio はただ単にそのファイルを開いただけでそれ以外のことは何も行っていません。なにも、です。コンパイルなんてしていません。 コンパイルしていないのですから当然 a.exe なんてできていません。したがって、そのあとで > a > > と入力すると > > C:\CLang>'a'はは内部コマンド、外部コマンド > 操作可能プログラムまたはパッチファイルとして認識されていません。 > > と出てしまいます。 というのも当然です。 というか、gcc を使用するまともな初心者向け参考書ならばソースファイルを書いた後の手順としてコンパイルする手順が書いてあると思うのですが……。 　gcc ほにゃらら というように gcc で始まるコマンドプロンプト入力をしろという指示があるはずですよ?
例えばTextBoxのMaxLengthだった時 取得は可能だが、設定は許可しない例です。 【コンポーネントの実装】 class Class1 : TextBox { [Browsable(false)] [EditorBrowsable(EditorBrowsableState.Never)] [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)] public new int MaxLength { get { return 0; } protected set { } } private int _yyy; public int YYY { get { return this._yyy; } set { this._yyy = value; base.MaxLength = this._yyy; } } } 【利用時】 class11.MaxLength = 1; エラーメッセージ set アクセサーにアクセスできないため、プロパティまたはインデクサー 'WindowsFormsApplication1.Class1.MaxLength' はこのコンテキストでは使用できません。 EditorBrowsable(EditorBrowsableState.Never) 外部ソリューションで参照された際に、コード入力中に表示されるインテリセンスの候補として出現しなくなります。 勘違いしてはならないのが、同一ソリューション内の他プロジェクトでは効きません。 [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)] コンポーネントを設置した際、Designerファイルで自動生成されるコードとして除外します。 これを設定することで、Designerファイル上にプロパティの設定コードは自動生成されません。 上記例だと、結果的に以下の動作になります。 　・Designerファイルで制御文が入ってこない。 　・インテリセンスに表示されてこない。 　・直接入力されたとしても、値を設定することはできず、無意味？な値の取得のみ行える。 　　（無意味かどうかは実装に応じて・・・） Obsolete("使用不可", true)は、上記に加えてお好きにどうぞ、という感じです。 Obsolete()はメッセージが適切かどうか微妙では？ 操作不能としたいという要望では、上記の方法論の方が適切かもしれません。
> static void uint2Hex（）によって文字列に置き換えを行っているのですが とのことですが、unit2Hex() は一度も呼ばれていないようです。 つまり、文字列の置き換えなどされてないと言うことです。 また、data1, data2 をそれぞれ、0xfa00, 0xfa10 番地に割り当てているようですが、これも意図が理解できません。 ここには、未定義のレジスタが存在するようですが、定義されないところを何かに使うのは、良くない気がします。 その他にも、rs_puts() が定義してあるのに使っていないとか、ずいぶんと不思議な気がします。 他のところがあっているとすれば、 Getad() { unsigned int data; char buff[16]; initSCI3(); // SCI3初期化 data = AD.ADDRA >> 6; uint2Hex(data, 0,buff); rs_puts(buff); rs_putc(':'); // 区切り記号（適当に） data = AD.ADDRB >> 6; uint2Hex(data, 0, buff); rs_puts(buff); rs_putc('\x0d'); // 区切り記号（適当に） AD.ADCSR.BIT.ADF = 0; AD.ADCSR.BIT.ADST = 0; } こんな感じで、16進の文字列で出てくる気がします。 data も省くなら、 Getad() { char buff[16]; initSCI3(); // SCI3初期化 uint2Hex(AD.ADDRA >> 6, 0, buff); rs_puts(buff); rs_putc(':'); // 区切り記号（適当に） uint2Hex(AD.ADDRB >> 6, 0, buff); rs_puts(buff); rs_putc('\x0d'); // 区切り記号（適当に） AD.ADCSR.BIT.ADF = 0; AD.ADCSR.BIT.ADST = 0; } でも、いけるのではないかと思います。
例えばプログラム名をhogeとした場合 hoge と起動した場合 argc = 1 argv[0] = "hoge" hoge aaa bbb の様に起動した場合 argc = 3 argv[0] = "hoge" argv[1] = "aaa" argv[2] = "bbb" ↑の値が各変数にセットされます。 以後の処理で、それらの値を使用するのが 必須の場合、引数をつけずにプログラムを 起動したか、値が適切な物であるかどうか を「コマンドライン引数チェック」で確認 してチェック結果に応じた処理をします。
あまり自信は無いですが、 tmp[j]^=iv[j] ここで使う　iv[ｊ]; の値は、暗号化のときと復号化のときでは、 違った値になっていませんか？ iv1[]、 iv2[] を用意して 復号化と暗号化で別の領域を使ったらどうでしょうか。 　
ちょっと情報が少なすぎて何とも…。 組み込みだけでは幅が広すぎてどの程度の演算能力が使えるのか分かりません。 情報がどのようなものかも分かりません。(例えばASCII文字列なのか、10進数値なのか) あとはCSVは組み込みプログラム側で読める必要は無いと考えてよいのでしょうか。
imgData の中は、次のようにデータが並んでいます 0 * widthStep から 　X=0,Y=0のデータ 　X=1,Y=0のデータ ... 　X=x,Y=0のデータ ... 　X=width-1,Y=0のデータ 1 * widthStep から 　X=0,Y=1のデータ 　X=1,Y=1のデータ ... 　X=x,Y=1のデータ ... 　X=width-1,Y=1のデータ y * widthStep から ... 　X=x,Y=yのデータ ... y * widthStep から ... 　X=x,Y=yのデータ ... (height-1)*widthStepから ... 　X=width-1,Y=height-1のデータ 各座標データは次のようになっています チャンネル1のデータ チャンネル2のデータ(2チャンネル以上のとき) チャンネル3のデータ(3チャンネル以上のとき) チャンネル4のデータ(4チャンネル以上のとき) 各チャンネルのデータは IPL_DEPTH_* で示されるバイト数だけ使われます。 IPL_DEPTH_8U なら1バイト IPL_DEPTH_32F なら4バイト 以上のことから、座標(x,y)のチャンネルch のデータは imageData[ y * widhtStep + 1データあたりのバイト数 * ( x * 総チャンネル数 + (ch -1)) ] から始まる 「1データあたりのバイト数」のデータ、ということになります で out_img = cvLoadImage("C:...\shiro.jpg", CV_LOAD_IMAGE_COLOR); だと、おそらく IPL_DEPTH_8U(1バイト), チャンネル数3になっているはずです。 これだと out_img->imageData[out_img->widthStep * y + x * 3] = 0; // 3チャンネルのうちのチャンネル1: B out_img->imageData[out_img->widthStep * y + x * 3 + 1] = 0; // 3チャンネルのうちのチャンネル2: G out_img->imageData[out_img->widthStep * y + x * 3 + 2] = 0; // 3チャンネルのうちのチャンネル3: R となります。 /* 元の画像が 6x6 なら、 x=6,y=6という座標は存在しません。 */ /* よって out_img->widthStep * 6 + 6 * 3 は間違いです */ ですが cvCreateImage(cvGetSize(src_img), IPL_DEPTH_8U, 1) だと、IPL_DEPTH_8U(1バイト), チャンネル数1 です。 imageData[ y * widhtStep + 1データあたりのバイト数 * ( x * 総チャンネル数 + (ch -1)) ] にあてはめれば imageData[ y * widhtStep + 1 * ( x * 1 + (1 -1)) ] です。 前にも言ったと思いますが、C言語では、配列の範囲外かどうかのチェックはしません。 例え範囲外でも、とにかくそのアドレスをアクセスしに行きます。 ちゃんと正しい範囲かどうかを管理するのは、プログラム制作者の仕事です。 そこが不完全なら、まずは、チェックしてくれるSet/Getを使って「正しい処理」をするプログラムを作ることから始めてはどうでしょうか。
va_list 等は、可変長引数を扱うためのものです。 va_list 、 可変長引数 等で検索すると、より詳しい解説がみつかります。 例えば、 printf では、引数が1つのときもあれば、3つのときもあります printf("hello world"); /* 引数が一つ */ printf("No.%d is %f\n",i,d[i]) ; /* 引数が3つ */ こういうのが可変長引数です。 後半のループは、 配列 fmt と変数 k の内容を追い掛ければわかるかと思います。 %があったらmessからfmtにコピーを始めて、 s,d,x等があったら、fmt を書式文字列に指定して、fprintf を実行しています。そのとき、呼び出し元で指定された可変長の引数から順番に取り出して、fprintfに指定しています。 例えば error("aa%2c",'b') ; だったら a → fprintf(f2,"%c",'a') ; /* k==0だから */ a → fprintf(f2,"%c",'a') ; /* k==0だから */ % → fmt ="%" ; /*k=1に */ 2 → fmt ="%2" ; /*k=2に */ c → fmt ="%2c" ; fprintf(f2,"%2c",'b') /*k=0に */ つまりは error(msg, a0, a1, ... ) ; が { fprintf(f2, msg, a0, a1, ...) ; exit(1); } と「ほぼ同等」の意味になります。 ただ。 単純に{ fprintf(f2, msg, a0, a1, ...) ; exit(1); } とするなら、va_list をそのままfprintfに渡せる「 vfprintf 」という関数があります。 わざわざmsgを解析する必要はありません。 fprintf(f2,fmt,(char)va_arg(list,int)); の (char)va_arg(list,int) については、意図をわかりかねます。 Cの可変長引数のルールとして「int以下の整数は、intに変換される」というのがあります。 　char c ='a' ; 　printf("%c",c ) ; とした場合、実際には 　printf("%c",(int)c ) ; となります。よって、va_argで取り出す際には va_arg(list,int) なのが正解です。 しかし、それをまたcharに戻す理由はわかりません。 fprintfも可変長引数なので 　fprintf(f2,fmt,(char)va_arg(list,int)); は 　fprintf(f2,fmt,(int)( (char)va_arg(list,int) ) ); と同義です。 "%c"の方はまだ「charとして扱いたい」という(無意味な)理由が考え付きますが、 "%x","%d"の方はわかりません。 「int i ; error("%d",i) と指定なっていたら、iはintではなくcharとして下位8ビットしか見ない、ということなのでしょうか。
ひらがなではなく、英単語だったら作れますか？ まだでしたら、まずは英単語版のしりとりを作ってみるほうがいいと思います。
コンフィグファイルが、BOM（バイト・オーダー・マーク）付きのユニコードで保存されてしまっているようです。 ■■はおそらく、BOMです。 文字コードをASCII（メモ帳だと、ANSI)で保存してください。 プログラムファイルの文字コードも間違っている可能性がありますね。
ケアレスミスですね。 誤： double naiseki(int *vecterA, int *vecterB) { 正： double naiseki(double *vecterA, double *vecterB) {
>すいませんコメントつけたほうがよかったんですね… コメントを書かれいない場合、そこで何をやりたいのか他者には伝わりませんよ。 >そこは渡されたdataを16ワードごとに区切って一度tmpに入れて暗号化、それからもとのdataの位置にそれを戻してやるという動作をさせたくて書きました。 memcpyをちゃんと調べてみましょう。 第2引数にint *を渡してるからといって第3引数のintを指定した個数分(今回でいえばintを16個分)という意味になったりしません。 memcpyをちゃんと調べれば >memcpy(data,init,16); >memcpy(data2,init2,isize); などもおかしいことがわかると思います。
Expression : (str !=NULL) で検索すると http://oshiete.goo.ne.jp/qa/459729.html 等が見つかります。 そう考えてプログラムを見ると if( (fp = fopen( "zahyou1.csv", "r")) == NULL ) { printf( "can not open the file.\n" ); } if( (out = fopen( "out.csv", "w")) == NULL ) { printf( "can not open the file.\n" ); } いずれも、fopenの戻り値がNULLかどうかのチェックはしていますが、NULLであるとき(=fopenに失敗したとき)にはメッセージを出力するだけで、そのまま実行を続けています。 このままでは、実際にfpやoutを使おうとしたときに、問題となります。 エラーの場合は、後の処理をしないような工夫をしましょう。(exitやreturnで終了させるなど) また、Visual Studioを使った場合の、よくある話なのですが。 fopen( "zahyou1.csv", "r") このようにファイル名だけ指定すると、カレントディレクトリにあるディレクトリから探します。 このあたりの詳細は、「作業ディレクトリ」「カレントディレクトリ」等で検索してください。 VisualStudioからデバッグ実行した場合は、プロパティの中にある「デバッグ時の実行ディレクトリ」になっています。 初期では、 bin\Debug やbin\Relase 等の、実行ファイルのあるディレクトリになっています。 ソースコード(～.c)と同じディレクトリに zahyou1.csv があっても、bin\Debug に無ければ fopenは成功しません。 ・ファイルの置き場所を変える ・作業ディレクトリをzahyou1.csvのあるディレクトリに指定する ・ファイル名だけではなく、ディレクトリの場所もフルパスまたは相対パスで指定する といった対策が必要です。
　いつものように単純なタイプミスだとは思うのですが、 ＞参考書　には　 ＞＄　example9.c　-o　example9.exe　として ＞実行結果が 　これでは操作ができない。 $gcc -o example9.exe example9.c 　として、「example9.exe」を生成し、 $./example9.exe example9.c 　として実行するのではないだろうか？ 　「example9.c」の部分を任意のテキストファイルのファイルネームに置き換えて実際に試してみてください。
補足すると sizeof() は関数ではなく演算子で 実行時ではなくコンパイル時に評価されるため 動的に長さは取れないのです。
普通はやらないけど fwrite とか.
[Q1]word3とword４ではなぜ、*word3, *word4とポインタで設定するのでしょうか？ [A1]別にchar word3 [] = "ABD";としても問題はないと思います。気まぐれとしか思えません。 [Q2]「word4 = strchr(word4, *word2)」とポインタ指定するのは何故か？ [A2] ポインタ指定なんかしていない。ポインタが指している実体を引数にしている。 char a = 'A' ; char *pa ; pa = &a ; char c ; のような場合、'A'をアクセスする場合には c = *pa ; と書くでしょ ? それと同じです。 つまり、 word4 = strchr(word4, *word2) は word4 = strchr(word4, 'a') と同じです。
> 思い通りの解答になりません。 具体的に、どのようになっているかわかりますか? ただ「思い通りにならない」と言われても、何の解決策も思い付きません。 具体的にどうなっているかを調べ、 どうしてそうなるのかを調べる というのが、プログラム修正の基本です。 おそらく ○何を入れても「正解」になる。 という現象が起っているのでは。 この現象から、想像力を働かせて、どうしてそうなるかを考えます。 例えば ○合否判定を間違えたら「全部正解」になりそうだ ○結果を保存する箇所を間違えたら「全部正解」になるかもしれない ○保存した結果を出力するときに間違えて「全部正解」と出力してしまっているかもしれない 　合否判定は ans==a+b 　ぉの結果を収納するのが if(ans==a+b) kaitou[i+1]=seikai; else kaitou[i+1]=huseikai; 　出力するのが if(kaitou[i+1]==seikai) printf("○\n",seikai); else printf("×\n",huseikai); ここだけ取り出すと、判定は正しいように見えなくもないですが kaitou[]に代入されている具体的な数値をよく考えると、間違っていることが判明します。 kaitou[i+1]=seikai; kaitou[i+1]=huseikai; それぞれ、kaitou[i+1]にどんな値が入るか、考えてみましょう。 あと。 > int kaitou[10]; と宣言したとき kaitou[?]～kaitou[??] の?～??はいくつになるでしょう? forでi=0～9になっていますが、i=9のとき、 kaitou[i+1]はどうなるでしょうか? > printf("○\n",seikai); > printf("×\n",huseikai); エラーにはなりませんが、seikai,huseikaiが無意味です。
> どうもサーバ(Listenする側)からアクティブクローズすると、TIME_WAITは生じるもののクライアントから接続要求を出すと同じポートからでももう一度接続できてしまうというのは判 ちゃんと双方了解のもとで close() できなかったときのこと言ってるなら int optval = 1; if (setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof optval)) しとけという話ではなくて？
No1です。 このソフトだと、バイナリデータ（0x00～0xff）をそのまま送信するのと、 16bit分データを送信していないのでデータが化けて当然です。 文字を送信しなさいということは、16bitのデータが0x01faなら"01fa"と 文字列に変換して、 sendCharSCI('0'); sendCharSCI('1'); sendCharSCI('f'); sendCharSCI('a'); という風に送信するようにプログラムしてください。
#include <iostream> #include <limits> using namespace std; void print_cm_to_inch(double inch){ cout << inch << "inch=" << inch*2.54 << "cm" << endl; } void print_num_of_real_solution(double a, double b, double c){ double d=b*b-4*a*c; cout << "f(x) = " << a << "x^2 " << showpos << b << "x " << c << endl; cout << "The number of solutions is "; cout << noshowpos << (a?d>0?2:d?0:1:b?1:c?0:numeric_limits<double>::infinity()) << endl; } int main(){ double a, b, c, inch; cout << "Input inch : "; cin >> inch; print_cm_to_inch(inch); cout << "\nInput a, b, c :\n"; cin >> a >> b >> c; print_num_of_real_solution(a, b, c); return 0; } c++です。
>それでは、このソースコードではmyfile内で文字化けが起こるのは仕方がないと思って良いのでしょうか？ そもそも、そのプログラムではmyfileはテキストファイルとして扱ってはいませんから文字化けとか以前の話です。
> 改行（\n）までをファイルに書き込めばいいと思うのですが、プログラムでどう書けばいいかが分かりません その通りに書けばいいだけでは? > /*半角スペース部分をとばし、p1をBの最初の文字にする*/ > *p1++; /* ここでの * p1 ++ の * は不要というか無意味というか */ で、 p1はBの先頭に来ているわけですから p1の指す先が改行になるまで繰り返す { 　p1の指す先を1文字出力 　p1 ++ } でOKです。 ○元プログラムでの注意点 ・wordへ7文字コピーしていますが、終端文字('\0')を入れている様子がありません。 wordの状態によっては、正しく動作するように見えることもありますが、大抵は何かの問題が発生します。 症状が軽ければ文字化けで済みますが、最悪はシステム破壊まで有り得ます。 ・1行が、改行込みで「半角英数」199文字までなら問題ありませんが、それ以上の長い行があるようなら、扱いに注意が必要です。 ○別解1 > 　ここで工程3を行う の時点で、 p1 は、「B\tC\n」という文字列の先頭アドレス、と解釈もできます。 あらかじめbuffの改行コードを'\0'にしておけば、p1 は「B\tC」という文字列の先頭アドレスということになります。 そうすれば fprintf(fout,"%s;;;%s\n",p1,word); で済みます。 ○別解2 C言語での文字列操作は、正直面倒です。 この内容なら ・UNIX系OS標準のsedコマンド (Windows移植版もある) ・Perl,Ruby,Python等のテキスト処理が得意な言語 ・「正規表現による置換」機能を持つ、ある程度高級なテキストエディタ 等で簡単にできます。
何をもって「大丈夫」といえばいいのか、わかりません。 また、そのソースコードは、ヘッダーファイルのインクルードや main関数がないため、そのままでは実行できません。 仮に、コードに修正を施して実行できるようにしたとして、 わざわざ ＞*(x + ( i * 3 + j )) ＞*(x + i) と書かなくても、もっと簡単に x[i * 3 + j] x[i] と書けます。
さらにいえば int x[3][3] = {{1,2,3,4},{5,6,7,8}}; でエラーが出るしね＞#1. まあ, 強いていえば printf("z\n"); で「z」を出力できる, くらい?
stdio.h 系でやるならば FILE* fp = fopen(ログファイル, "r"); ログファイルを末尾まで読み取る処理(fp); long pos = ftell(fp); fclose(fp); 一定間隔にて以下を繰り返し fp = fopen(ログファイル, "r"); fseek(fp, pos, SEEK_SET); ログファイルを末尾まで読み取る処理(fp); pos = ftell(fp); fclose(fp); iostream 系でも同じ考え方で処理できます。
小学生並の感想： 1)インデントを付ける習慣をつけたほうが良いと思います。見にくいです。 2)エディタによっては自動でインデントするので、インデントレベルの不正によりバグに気付く事があります。 3)for (m = 0; m < renzoku + 1; m++); { 　この行がおかしいです。 「;」により for(snip){/*空文*/;} { と同じになっています。 4)ステップ実行していけばすぐ判るので、ステップ実行できるようになりたいねぇ。
No.1 です。 「バイナリデータでは？」と書いたのは間違っていたわけですが、それでも、 printf("%02x\n",pszBuf[i]); で、バイナリデータとして確認してみるのは、無駄ではないと思います。 これで、どういうコードとして渡ってきているかは確認できますので。
私の場合。 int Array[10]; 　配列 int *Array = new int[n]; 　配列 　区別する必要がある場合は「new で確保したintの配列」と「それを覚えるためのポインタ『Array』」 std::vector<int> v; 　std::vector std::array<int,10> v; 　std::array 「配列のような動作をするクラス」は自作もできます。 メッソドやフィールド、機能が一緒とは限りません。 なので、そういう「配列のような動作をするクラス」まで含めて全部「配列」と呼ぶのは、ちょっと無理があると思います。 > 改めてnew[]してmemcpy() reallocでも、同様のことが行われることがあります。 また、C++では、安全だとわかっている場合を除いて、memcpyによるコピーは危険です。
独自のデータで保存しても良いけど、iniファイルを使うのが簡単かも。 http://www.ne.jp/asahi/hishidama/home/tech/vcpp/ … 状態をiniファイルに保存して、次回起動時にiniファイルを読んでコントロールの設定をします。
11x11の画像を二値化しているのに、 なぜ元の画像と同じ大きさのlap_imgwo用意して、x+6,y+6 (ともに11以上になることがある)の値を見るのですか? 他に ・元画像を二値化したtmp_imgを、二値化してbw_imgにして、 それを毎回dst_imgにコピーしてから 11x11の部分を二値化する、 って、なんか、無駄なことしてませんか? 二値化した画像をさらに二値化するのって、なにか意図があるのですか? 毎回bw_imgからdst_imgにコピーするのって、なにか意図があるのですか? ・ > for (x = 0; x < bw_img->width; x++){ // x 座標を 1ピクセルずつ進める > for (y = 0; y < bw_img->height; y++){ // y 座標を 1ピクセルずつ進める だと、11x11の右下の座標(x+10,y+10)が画像からはみ出ることがあります。 そのことを意識してやってますか? はみ出ないようにするには、範囲を調整する必要があります。
>char *return_str; これ、ポインタ宣言しているだけで、領域確保していないので、sprintf()の引数には使用できません。 あと、この手の質問をするときは何がうまくいかないかも書きましょう。 また、fgetc()の戻り値はintです。 char型としても使えますが、 >sprintf(return_str,"%c",c); が、文字列の領域を確保して、うまく動いたとしても追加ではなく上書きなので、最後の文字しか保持しません。 1文字だけ返したいのか、文字列を返したいのかで修正箇所は変わります。
> #2 補足 ふむ、ならばこちらよりも「その他(データベース) 」カテゴリで質問されると適切な回答が得られるのではないかと思います。 自分も SQL のエキスパートというわけではありませんので。 ただ > 一度プログラム側でデータを受け取り、ランダムに並び替えた後で、 > その順に1から番号を振っていく…という感じでしょうか。 については、ランダムの並び替えは SQL の SELECT 時に ORDER BY random() で行えます。 さすがに特定のキャラをラスボスにとかいうように並び順に手を入れたいならば、それはプログラム側でやる方が適切ではないかと思いますが。
GSLしばりの条件でやるのであれば、次のサイトが参考になります。 大浦先生のサイト: http://www.kurims.kyoto-u.ac.jp/~ooura/profile-j … ↓ 数値計算ソフトのリンクをたどっていく ↓ 多次元FFTの計算のしかた: http://www.kurims.kyoto-u.ac.jp/~ooura/fftman/ft …
90度回転した画像なら、画像の一括変換機能なんかのあるソフトでまとめて作成できます。 お勧めはIrfanView。 IrfanView 日本語版のページ http://www8.plala.or.jp/kusutaku/iview/ 上を利用すれば、 ・元の画像 ・15度傾けた画像 ・30度傾けた画像 ・45度傾けた画像 ・60度傾けた画像 ・75度傾けた画像 の５つ作れば、更に90度ずつ回転して15度刻みの画像が360度分の24枚作れるとか。
> SMTP-AUTH の場合は、AUTH-PLAIN　が　must になっていたと思うのです。 mustではないです。 例えば、メールサーバーがPostfixの場合だと、 smtpd_sasl_security_options に　noplaintext　を指定すると、AUTH-PLAINでの認証が出来ません。 つまり、通信する相手（メールサーバー）の設定次第です。 ただし、OutlookやOutlook ExpressがPLAIN認証しか対応していないので 一般的なメールサーバーでは、PLAINに対応するのが普通だと思われます。 （社内・学内などでメールソフトが限定的な運用環境なら外せるでしょうけど） telnet メールサーバー名 ポート番号(25や587) でつないで EHLO local を叩いてみれば、 250-AUTH CRAM-MD5 LOGIN NTLM PLAIN DIGEST-MD5 等が返ってくるので、これでSMTP-AUTHでどんな認証方法が使えるかが分かりますよ。 なので、MUA(メールソフト側）から言えば、これをみて、どんな認証を使うかを 決めればよいことになりますね。
>>SMTP AUTH で、ポート　587　への接続ですが、 AUTH PLAIN 　で接続できるサーバーと、接続できないサーバーがあるようです。 セキュリティアップということでしょうか？特に最近は「野良ＡＰ］というか「野良ＷｉＦｉ」「無償ＷｉＦｉ」への接続等で、ＩＤ，Ｐａｓｓが盗まれることも多いように思えますから、メールサーバ側で「ＰＬＡＩＮ」接続を受けないものが増えているのだと思えます。 私の場合、独自ドメインを取得して、自前のメールサーバを立ち上げたのですが、電信８号といったシンプルなメールソフトでは、問題なく送受信できるけど、thunderbirdでは、メールアドレスの登録で、なんどやっても私のサーバが「見つかりません」と拒否される状態が続きました。 それで、メールサーバのセキュリティ設定のレベルを強化したら、thunderbirdにアドレスが登録可能となりました。 とはいえ、私がメールサーバ設定するとき、thunderbirdが接続できず、いろいろとサーバ側の設定変更を繰り返していたため、同時に変更した他のサーバ設定項目によって、登録可能となったという可能性もあるのですけど・・・・ その後、androidにインストールしたメールソフトにおいて、私のメールサーバに接続して、新しいアドレス登録をするとき「暗号化したパスワード」を選ばないとエラーになりました。ですので、ＡＵＴＨ　ＰＬＡＮかどうか判りませんが、接続のセキュリティを強化したモードでないと受け付けないサーバが増えているのだと思います。
自動変数はスタックから、newした場合はヒープからなんでしょけど、実際は最適化されて全然違う動きしてることもありますよ。 デバッグモードとリリースモードでも、メモリの取り方は変わってきますよ。 参考までに
1000秒からスイッチＯＮ スパコンは使ってませんが……
基本は日本人が英語を話すのと同じです、日本の学校で形だけ覚えた所であまり使えないでしょう、必用だから英語を使う訳で、やりたいことが明確だからその手段などを英語で考える事さえ出来るようになるのです、Ｃ言語もアルファベットを使う一つの言語と考えて下さい、英語圏が人がドイツ語やフランス語で考えるようなもので、スペルも近いですし、意味も近いです、ただ文法的な所での違いはあります、Ｃ言語はそれら英語と近い別の言葉と考えれば良いだけで、プログラミングで問題なのは、スクリプトとは違いハード的な部分を理解していないといけないと言う所です、Ｃはアセンブラに続き色々な事が出来、制約が少ないですが、逆に制約が少ないという事は全部自分でやらないければないらないという事です、 家を建てるので言えば、スクリプトは２Ｘ４の出来上がっている部品を組み立てて家を作るのと、木材を山から切り出し作るのがアセンブラ、Ｃは製材された木材からのこぎりやノミで加工して家を作ると言った感じです。 つまり作る物のイメージや目標があり設計や手順（プロトコル）をあらかじめ準備する、下準備をきちんとしないと、難しいと感じてしまいます、大工だって図面も引かずにいきなり家を作れと言ったって無理ですし、ましてや素人では不可能です、ですから最初は見習いがやるように、やり方を覚える訳ですから、こうやる時はこの手順でこう、と言うのを自分勝手や手抜きをせずに、基礎を覚えれば、良いと思います、独学だとそこの部分で安易な方法を取ってしまいがいちで、ある条件下では使えるが、別の条件だと使えないという事が起き、難しさが倍増してしまうみたいです（反省）。
> この連載では，以下のような開発環境をベースに解説を行っていきます。 > バージョン：OpenCV 1.0 > OS：Winodows XP > IDE：Microsoft Visual C++ 2005 現在、OpenCVは2.xになっています。 ディレクリ構造が1.xのころから少し変っています。 2.x用に書かれた資料を探すか、自分で修正できる程度にC/C++言語の知識を深めるかしましょう。 私としては後者をお勧めしたいところです。
「配列って結局先頭ポインタなので」という表現は乱暴すぎるし余計に誤解させるだけの可能性が高いので賛同できないなぁ＞#3. あと, コンテナに素のポインタを入れるとかえって管理が面倒になるので正直いってお勧めしない.
＞パラメータ 'argc' は一度も使用されない(関数 main )・・・ 2行目で、argcが宣言されていますが、それ以降でどこでも使われていません。 ということで、文字通りの意味のメッセージです。 警告メッセージですが、この場合は使っていないのは意図的なので、特に気にする必要はありません。 で、bcc32 ～～～.c で行うのはコンパイルです。 コンパイルとは ～.c というソースファイルから ～.exe という実行ファイルを作ります。 bcc32 を実行した後、dir とすると、 example9.exe example9.obj example9.tds というファイルが出来ているのがわかると思います。 example9 と打ち込んで実行してください。 ～.obj と ～.tds は、単純なコンパイル＆実行の場合は不要です。
MSのKBに以下のようなものがあります。 How to create a low-integrity process in Visual C++, in Visual C#, and in Visual Basic.NET https://support.microsoft.com/kb/2278183/ ここでは，Low Mandatory Level，つまりIEやChromeなどが動いているレベルへでプロセスを動作させるコードがダウンロードできます。 標準的な権限であるMedium Mandatory Levelで動作させるための手順はこれと同じで， MainForm.csの205行目，SECURITY_MANDATORY_LOW_RIDをSECURITY_MANDATORY_MEDIUM_RIDにすればMeidum Mandatory Levelのプロセスを生成できます。 ちなみに，管理者権限はSECURITY_MANDATORY_HIGH_RIDになります。 # 上位の権限になるための手順は，これとは別の手順になるはず。
旧いコンパイラで作られたライブラリをリンクしていませんか?
あなたが言う「バグ」というのが「この入力に対してこう出力するようにコーディングしなくてはならない、のにそうなっていない」という意味ならばバグです。しかし、「このコードについて出力結果がこうあるべきなのにそうなっていない、これは gcc のバグだ」という意味ならばバグではないです。 説明するとこの欄では足りないので、参考 URL をご覧ください。このページでは .NET 系での話をしていますが、本質的な事情は gcc でも同じです。 参考URL：http://dobon.net/vb/dotnet/beginner/floatingpoin …
メニューバーは複数本配置することができ、それぞれの上にコントロールを置くことはできますよ。
VisualStudio2013は個人使用ならフル機能が使用できるバージョン(Expressではない、Ｃｏｍｍｕｎｉｔｙ)が無償配布されている。 http://www.microsoft.com/ja-jp/dev/products/comm …
> intがなかったらOKですかね Xも小文字のxの誤記ですので、それらを修正すればＯＫですよ。 #include <stdio.h> int main(){ int x = 5; int y = 8; printf("%d * %d = %d\n" , x,y, x * y); x = 3 ; y = 11; printf("%d * %d = %d\n" , x,y, x * y); return 0; }
いまさらながら. 「テスト対象のソースファイル」のなかにテストコードを入れておく手もありますな. #2 はそれを意図してるかもしれん. とりあえず「テストが書かれているソースファイル」とバラバラになりえないというのは利点として考えられる. もちろん「ソースの変更」だけど最後に単純に追加するだけだから問題にはなりにくいと思う.
＞この二つの明確な違いはあるのでしょうか。 ＞大きな違いがあるようでしたら、教えてください。 アプリケーションの操作性を設計する場合に、既に世の中に出回っている製品の操作性を引き継ぐのはよくあることです。 まったく新しい操作方法を提案しても、ユーザから「使いにくい」と言われかねないからです。 マイクロソフトでMCIの仕様を設計した人も、同様に世の中に出回っている製品の操作性を参考にしたと考えられます。 もちろん、実際にどのような設計思想でMCIコマンドを決定したのかは、本人に直接来てみないと判りません。 MSDNのMciSendStringの説明とコマンド一覧 http://msdn.microsoft.com/ja-jp/library/cc410496 … http://msdn.microsoft.com/en-us/library/ms712587 … もちろん、この説明もあくまで初期バージョンの説明であり、バージョンアップの際に密かに機能が追加されている（そしてMSDNは更新されていない）可能性が有ります。
＞ピタゴラスの定理を使おうと考えております 二点がA,Bがあり、 AとBのx軸距離の差と AとBのy軸距離の差から、 A,Bの距離の差が分かる、ということですか。 もう少し具体的な作業内容を教えて下さい
「２次元配列に値を代入するまでちょっと時間差があるので初期化されてた方が安心かな」ということだけど, もし本当にそんなことを言うようなら書き直しをさせそうな気がする. そもそも「時間差」なんて関係ないよね. ちなみに, どのような値で「初期化」されるかわかっていますか? その値は適切ですか? あと, 規格に従う限り sizeof(char) は必ず 1 です＞#5. ただし, ぎりぎりいうと「アライメントをあわせるのにビットアンドを使うのが妥当か」というと困る. アライメントまわりは「一昔前の 32ビットアドレスの RISC」なら (ほぼ) 必ず言及されることだったりするんで, どうしても気になっちゃうんだよね....
すごいコードですね～。 仕事で前任者が書いたコードがこれだったら絶対作りなおすな～。 このコードが正常に動作するかどうかはさておき、虫唾が走る点としては ・配列のサイズを受け渡していない ・自動変数の素の不定値を使っている ・使用しない変数が記述されている ・forループの上限がリテラル値で指定されている ・KeyExpansion()とかCipher()とかいったサブルーチンの戻り値を検査していない といったあたりですね。 参考になりませんですみません。
確保するときと、開放するときとで、iの値がどのように変化するのか考えてみましょう。
> #4 #1です。ご指摘、ごもっとも。自動変数が初期化されるシステムでもダメですね。 > 質問者 warningはコンパイラからのツッコミなので文法的に是正していけばいいですが、segmentation faultや一般保護エラーは実行環境(OSとか)からのツッコミですので、実行環境であなたのプログラムが何か「悪いこと」をやらかしているわけです。 それが何かを理解する必要があるので、C言語の文法的な問題ではないのかもしれないという予想と、実行環境が何を嫌がっている(何をしたらシステムが発狂する)かを知るべきです。 ちなみにOSがないシステム(組み込み機器とか)なら誰からもツッコミが入ることなく、ただ暴走もしくはフリーズするだけですがね。 「int a;」という記述はコンパイラによって、とあるRAM領域のどこかにint型の値を記録できる領域を確保して、そのアドレスに紐付けされたaというラベルを提供するという処理に置き換えると考えることができます。そして「a=1;」は、aというラベルに紐付けされているRAM領域に1が書き込まれます。(感覚的な表現であって、アセンブリ言語レベルでは違う処理かもしれませんが。) それに対し「int *a;」という記述は、とあるRAM領域のどこかに「int型の値を記録できる領域」のアドレスを記録できる領域を確保して、そのアドレスに紐付けされたaというラベルを提供します。そして「a=1;」は冗長に書くと「a=(int*) 1;」であって、つまりint型変数のアドレスとして「1番地」をaに紐付けされたRAM領域に書き込みます。さらに「*a=1;」は、「1番地のRAM領域」にint型の1という値を書き込みます。 WindowsやMacのようなメモリ保護前提のOSでRAMアドレスを直接指定するということはまずないと思いますが、μITRON系OSやOS無しマイコンでは絶対的なアドレスを指定して値を書き込む場面は多々あります。 で、なんで「int *a; a = 1;」がダメなのか。 「int *a;」ではaは、書き込んでも良いアドレスで初期化されないからです。「int型を記録できる領域のアドレス値」の入れ物が定義されただけで、aが持っている値は不定なわけです。それは0番地かもしれないし1番地かもしれないし、100番地かも知れないし、1000番地かもしれません。 その後の「a=1;」はどこだかわからないアドレス番地に1を書き込んでいることになります。 で、ここからが実行環境の話です。 実行環境、特にOSがある場合は、RAM領域の中でシステム専用のアドレス領域やmalloc()で取り出す元になる領域などといったように用途ごとに区画分けがされています。そして1という値は、あなたにとってはint型の1であっても、それぞれの区画では別の意味でしょう。書き込むアドレスによっては、もしかするとパソコンを爆破する命令を指す値かもしれません。 そういった不定な領域に任意の値を書き込む行為は、(あなたにその意志がなくても)実行環境にとってはテロなわけです。テロへの対抗手段として、実行環境があなたの実行したプログラムを(自衛のために)殺すのが不正終了と呼んでいる挙動、その原因である不定な領域に不正な値を書き込む行為を指すエラー名がsegmentation faultや一般保護エラーです。 ちなみに0番地に書き込むのも大多数の実行環境ではテロにあたる事が多いので、「int *a = 0;*a=1;」もsegっちゃうよ、というのが#4の指摘だと思います。(外してたら恥ずかしいな・・・) だったらどうしたらいいのか？ですね。 int *a; としたら、 if ((a = (int*) malloc(sizeof int)) == NULL) exit 1; として、終了(exit)しなかったら、 *a = 1; といった感じで、まずはaに有効なアドレスを与えてあげなければいけません。 他には、 int b; int *a; a = &b; *a = 1; でもいいし、 int c[100]; int *a; a = c; *a = 1; でも(文法的には)いい。 で、ソースコードに立ち戻って、まずは「Node **p;」から「*p = root;」の間で「p=」で始まる処理を探しましょう。 もし無いなら、p(==不定なアドレス)への代入がsegの原因でしょう。 そして、じゃあどこに「p=」で始まる文を入れるべきなのかを検討しましょう。 それがいわゆるデバッグってやつです。 すべてを自分で考えてソースコードを書くならともかく、他人が別の実行環境向けに作ってテスト方法や検証結果も提供していないソースコードをせしめて使いたいなら、デバッグは必須と考えましょう。 特に今回のような、「Node **p;」のような「Node型へのポインタへのポインタ」とかいった多段の参照関係や、あるいは関数ポインタによるコールバックや抽象化は、「C言語で作ったプログラム」としてはごく普通というか、「それがしたくて未だにC言語を使っている」といった類の手法ですが、ポインタの基礎的な知識が不足している状態でそのレベルのソースコードを引っ張って来て流用するというのは、相当の覚悟と努力が必要だと思います。 まさに賞賛に値します。
質問に対する回答ではありませんが・・・ 最終的にVisualStudioを使いこなすのが目的での学習であれば仕方が無いですが、C言語の言語仕様の学習であれば、GCCとかLSI-C86試食版(懐かしい!)といったコマンドラインのコンパイラとメモ帳(notepad.exe)だけのような環境でやる方が、今回の様なトラブルも少なく、またトラブルの原因調査もしやすいのではないでしょうか。
cpplint とかどうかなぁ。実行には Python が必要だけど。 http://www.textdrop.net/google-styleguide-ja/cpp … （上記リンクの「目次」経由でたどれるはず） 英語が読めるならそれ以外は Wikipedeia 英語版の以下のページから C++ のものを探してみてください。 http://en.wikipedia.org/wiki/Category:Static_pro …
因みに、C言語では、配列もポインタも同じ物なので #include<stdio.h> int func(int *pai, int n){ return pai[n]; } int main(){ int ai[] = {0, 1, 2}; int i = func(ai, 1); int *pi = ai; int j = func(pi, 1); printf("Of course %d = %d.\n", i, j); return 0; } で良い。この方がコードが短くなるし速くなる。
　予想で回答します。 　何かのリソースファイルが足りていない気がします。 　インクルードしようとしているファイルネームからしてなにかのＳＤＫが別途必要なのでは無いですか？ 　単純に検索しただけですが。 ＞http://sourceforge.jp/projects/miranda-jp/wiki/M … 参考URL：http://sourceforge.jp/projects/miranda-jp/wiki/M …
コードの掲示もない状態では…なかなか難しいのですが。 >LINUXの設定にある自動起動するアプリケーションにとうろくしました。 >パソコンを立ち上げてみて自動起動することは確認できましたが、CSV作成で失敗してしまう >事象が発生しました. ・権限に問題はありませんか？ ・出力先はどのように指定していますか？ ・カレントディレクトリがどこになっていますか？
>追加した vector<A_t> Mapをコメントアウトするだけで >正常に動作します。　 とりあえず書いておきますが B_t b1; B_t b2; b2 = b1; 上記コード見た目こそ、vector<A_t> B_t::Mapのコピーをしてないように見えますけど実際にはしてるというのはわかりますか？ またコピーコンストラクタが必要な場合は、operator=もふつうは必要です。
もう回答がつてしまってますけど、 >Ｃ言語の「ポインタのポインタ」の学習中なのですが、以下のプラグラムがエラーが出てしまします。 「エラーが出てしまいます。」では他の人にはどういったエラーが出ているのかわかりません。 どういったエラーなのか他の人にわかるように説明しましょう。 また「ポインタのポインタ」の学習中と書かれていますが、まずはポインタをしっかり理解しましょう。 ポインタをしっかり理解してるなら「ポインタのポインタ」の学習なんて不要です。
> [&obj1](int x, int y){ return obj1.add(x,y);}は、 > 新たに、ラムダ式のようなものを作って、 > delgに指定してるようにみえるです "ようなもの"じゃなく、これがC++のラムダ式です。 > obj1のaddを直で、取得し、その上記の型の変数や引数で > 受けることは。 > C++の標準的な構文では、不可能なのでしょうか？ 直接取得するのは無理。あえてやるなら #include <iostream> #include <functional> using namespace std; class foo { int base; public: explicit foo(int b) : base(b) {} int add(int x, int y) const { return base + x + y; } // ↓ラムダ式を返すメソッド function<int(int,int)> add_delg() const { return [this](int x, int y) { return add(x,y); }; } }; int main() { function<int(int,int)> delg; // delegate int delg(int,int) foo obj1(1); foo obj2(2); delg = obj1.add_delg(); cout << delg(2,3) << endl; delg = obj2.add_delg(); cout << delg(2,3) << endl; }
srand の引数にシステム時間を使った場合、同じような時間に 実行すると値の変化が少ないために 1回目の rand の値が似た ような値になります。これは rand の仕様というか癖です。 これを防ぐために、最初に rand を何回か呼び出しておく、 というのは、わりと一般的な対策です。
printfの"%d"と、それに対応する引数をよく考えてください。 質問に書かれてるのは以下のような事です。 int i = 0; printf("%d", &i);
警告を消したいだけなら void func(void *aa, int y, int x) { unsigned char *a=(unsigned char*)aa; 以下変更なし とすればできます。
質問内容をもう少し具体化しませんか？ どのようにノードを追加して そのノードをどんなインデックス指定して操作したいのでしょう？ rootノードが1つ 子ノードが3個 孫ノードが　それぞれ4個 計 16個のノードがあって root - 子ノード1, 子ノード2, 子ノード3 - 子ノード1子 つまり 孫ノード1 ... 孫ノード12 といった順の インデックスですか？ それとも Nodesコレクションが提供する Indexを使うってことなんでしょうか …
＞SetDlgItemIntが整数しか使えないので変換したいです。 SetDlgItemTextとか、SendDlgItemMessageとか使えばいいのでは。
動的に眺める必要がなければ、XPM形式の書き出しならfprintfで用意に達成できるかとおもいます。 形式はリンク先のWikipediaあたりを参考にしてください 参考URL：http://en.wikipedia.org/wiki/X_PixMap
これがリンク時にでているなら、 avl_openを含むコードをコンパイルしていない あるいは ライブラリが足りない
当方の VC2010Expressですと 『+』のクリックだけでBeforeExpandおよびAfterExpandが呼ばれましたよ ハンドラの登録がうまくいっていないだけなのでは … デザイナで登録したのであれば this->treeView1->BeforeExpand += gcnew System::Windows::Forms::TreeViewCancelEventHandler(this, &Form1::treeView1_BeforeExpand); this->treeView1->AfterExpand += gcnew System::Windows::Forms::TreeViewEventHandler(this, &Form1::treeView1_AfterExpand); といった記述があると思います
＞nvcc fatal : Value 'sm_52' is not defined for option 'gpu-architecture' 海外のサイト（機械翻訳）古いバージョンではないか確認して、とあります。（「sm_52」は「sm_30」と違うが）
system
追記します。 まず、やろうとしていることを、日本語(またはあなたが普段使う母国語)で書いてみましょう。 最初はおおざっぱでいいです。 次に「おおざっぱ」の各項目で何をするのか、より細かく書きます。 さらに細かく... と続けて、機械的にC言語の命令に置き換えられる、というくらいまでになったら、C言語に「翻訳」してください。 この設計がちゃんとできていないから、プログラムをどう直していいかもわからないのでは? うまく動作しないときも、設計図通りに動作していてるなら直すべきは設計図、設計図通りに動作していないなら直すべきはプログラム、と修正箇所の切り分けができます。 この設計図が無ければ、「明らかにおかしい」という箇所しか指摘できません。 指摘できても、修正方法まで指摘できないこともあります。 ・j=j++ は「明らかにおかしい」し、意図を推測できたので、修正方法も指摘できました ・+ j * 3 + 3 は範囲外になるという点では「明らかにおかしい」ですが、これが何を意図したものかが理解できないので、修正方法は指摘できません。 ・top変数の扱いは、top変数が何を意図したものかがわからないので、指摘も修正もできません。 画像全体で境界線の最も右の座標、なら、このプログラムの通りになりますが 注目y座標での境界線の座標、なら、jのループの前に初期化する必要があります。 コメントが少ないのも、わかりずらい理由の一つです。 先のtopについても、コメントで説明があれば解決します 例えば、設計図からプログラムへは次のような流れになります 輪郭の座標を抽出する ↓ 左上から走査して、白→黒になった座標を抽出する ↓ 「左上から走査」とは 「左から右へ走査」を上から下まで順番に行う 　↓ 　「上から下まで」とは y座標を0から最大y座標(今回は10)まで繰り返すこと 　↓ 　for( k=0 ; k < 11 ; k ++ ) { 　　「左から右へ走査して変化点を探す」 　}
>考えられる原因は何かありますでしょうか？ ソースコードの掲示なしでは回答の範囲が狭まるだけですよ？ 現状だと…リソースリークでもしているんじゃないですか？としか。 描画処理、どうやってます？ GDIオブジェクト作成して、使用したあと破棄してますか？ # というか、こういうパターンだと最初に作成して使い回すモノかと。 # 描画のたびに生成と破棄を繰り返すのではなく。
今更ですが、、、 >printf内どうやって出力したらいいのか分からなくて空欄です。 googleとかで、 "printf c言語"とすると、色々と参考例があります。 その辺で勉強/調べる事をお奨めします。 ## printf( フォーマット文字列, データ...) ### printf("回数 = %d\n", h); // %d : 整数指定, \n 改行コード >最初から１m以下なら１回と表示出来ればいいのですが。 最初から、1m未満なら、0回と思いますが、、。 その場合、 do {} while() --> while() {} にするだけかと。 >getchは指定です。 c言語なので、 "getch()" と括弧付きにしましょう。 意味は、検索すれば、容易に分かると思いますが、、、 ## エコー無しの文字入力 ... 何かのキー待ちに(昔は)良く使った。 まだ、解決していないようでしたら、検索すれば、参考例は一杯あると思います。 あと、手元のPCでテストしてみる事をお奨めします。
#3のお礼への返信です。 > つまり、例えば、a[3]という配列があったら > ・a = &a[0] ということで、 > 　aを関数に渡すということは先頭配列のアドレスを渡しているということ。 そうです。 > ・関数の仮引数を struct DATA *statusにすることで、関数はアドレスを受け取っている。 > 　さらに、struct DATA *status と struct DATA status[] は意味が同じだから、 > 　hanabutakoさんが書いてくださったコードにはポインタ宣言の*は必要がなかった。 という解釈で合ってますか？ そうです。
ついでに: ・a とか b とかの配列は何を意味する? ・if(((c0x-ax)*(c0x-ax)+(c0y-ay)*(c0y-ay))<R) や if(((c0x-bx)*(c0x-bx)+(c0y-by)*(c0y-by))<R) って条件は間違ってる可能性がある.
Microsoft.Office.Interop.Excelを使われるのでしたら、MSDNを見て調べてコード化するのが良いと思います。 あくまでInteropなので2.0の頃と変わってないはずですが、当時よりは様々なドキュメントが整備されています。 参考URL：http://msdn.microsoft.com/ja-jp/library/microsof …(v=office.11).aspx
No.2の方が回答されているように、そういう決まりです。 Cコンパイラは'\0'の直前の文字までを一連の文字列と見なします。 そして、No.1の方が回答されているように、 while(*to) や while(*from) は while(*to != 0) や while(*from != 0) と書いているのと同じことになります。 そして '\0' は数値としては 0 と同じなので while(*to != '\0') や while(*from !='\0') と書いているのと同じことになります。 そしてmystrcatの第一引数の文字列の空きスペースには 元々どんな値が入っているかわからないので、確実に'\0'を設定して、 意図しない位置まで文字列と見なされないようにする必要があります。
http://www.rfc-editor.org/search/rfc_search_deta …[]=Any&pub_date_type=any によると、 Updated by RFC 4466, RFC 4469, RFC 4551, RFC 5032, RFC 5182, RFC 5738, RFC 6186, RFC 6858 とのことです。全部読む必要があるかどうかわかりませんが。 IMAPプロトコルの勉強をするのが目的で無ければ、何らかの出来合いのIMAPライブラリを使うのがいいと思います。
Ellipseでの描画は 指定された矩形範囲に内接する楕円を描画するのですが 内接するのはペンの中心です // Pen,Brushは選択済みとします Ellipse(hdc, 50, 50, 100, 100); hRgn = CreateEllipseRgn(50,50,100,100); InvalidateRgn(hWnd, hRgn, TRUE); といったコード実行すると Ellipseで描画した縁が消去されないと思います FillRgn/FrameRgnを使えば 生成したリュージョン内での描画になるので上記のような問題は解決されるでしょう 再描画に関してですが WM_PAINTイベントの実装により変わってきますよ BeginPaintを呼び出した際に 返される PAINTSTRUCT構造体psのrcPaintが無効にされた領域です rcPaintだけを BitBltなどで転送する実装だと GetRgnBoxで取得できる領域と等価だとおもいます 無関係にクライアント領域を書き直す実装だと 無駄が多いようにおもいます
windowsストアアプリ開発 開発環境でのテスト visualstudio(以下vs)をインストールした開発用pcでのストアアプリのテストに関して。 win7 + vs2012にてwindowsformアプリを作成する際、コンパイルをしますとDebugフォルダ内にexeファイルが作られ、vs2012を起動しなくても開発中のアプリを直接起動できると思います。 しかしストアアプリの場合、exeから直接起動は出来ないとのことです。 一方で、win8.1 + vs2013でwindowsストアアプリを作る際、コンパイルすると開発用pcにインストールされ、タイルが作られるという書き込みをみました。 これは、vs2013を起動していなくても開発pc上でテストができるということであっていますでしょうか？ よろしくお願いします。 ストア アプリは開発環境 (Visual Studio) がインストールされていない PC でもテストすることが可能です。 ただしテストには開発者ライセンスと呼ばれる、Windows ストア アプリをテスト目的で PC にインストールするためのライセンスが必要です。 （Visual Studio がインストールされている PC でテストする時もこのライセンスが必要だったと思います） テスト用 PC にこのライセンスをインストールし、Visual Studio で作成したインストール パッケージを使ってアプリをインストールします。 開発者ライセンスは不正利用を防ぐために有効期限が ３ヶ月に絞られており、このライセンスを使ってインストールしたアプリは期限が来ると使用できなくなります。 その場合は開発者ライセンスの更新を行ってください。 1. テスト用 PC で新規に開発者ライセンスを取得する # 開発者用ライセンスの取得 (ストア アプリ) # PowerShell で取得する。 http://msdn.microsoft.com/ja-jp/library/windows/ … 2. Visual Studio でインストール用パッケージを作成する。 # Windows ストア アプリをテストインストールする方法 http://blogs.msdn.com/b/osamum/archive/2014/03/1 …
malloc じゃなくって, 単純に配列を使っても同じでしょ?
ああ失礼、修正後の方のコードの変更点を演算子しか見てませんでした。 確かに修正後の方は "CQ DE SHIN" を正しく変換してくれますね。 じゃあ、" SOS" や "SOS "はどう変換されるべきとお考えで、それはその通りになりますか? また、spacesbtwletters　はその名の通り「文字の間の空白」という役目を果たしていますか?
>みなさん、どの様にして三角マークに変えているのでしょうか？ ……オーナードロー、じゃないかなぁ。実際やるとしたらどういう風なのかは知らないけど。 http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.110).aspx http://nekojarasikou.seesaa.net/article/13032909 …
ほかにも正規表現のライブラリはいろいろありますね。 例えば ＢＲＥＧＥＸＰ ＤＬＬ http://www.hi-ho.ne.jp/babaq/bregexp.html とか VC++ 6.0 の .lib も用意されていますし、文字列の置き換えも出来るようです。
2 12 4 9 7 8 5 3 6 11 15 1 2 1 4 9 7 8 5 3 6 11 15 12 2 1 4 3 7 8 5 9 6 11 15 12 2 1 4 3 5 8 7 9 6 11 15 12 2 1 3 4 5 8 7 9 6 11 15 12 1 2 3 4 5 8 7 9 6 11 15 12 1 2 3 4 5 6 7 9 8 11 15 12 1 2 3 4 5 6 7 9 8 11 15 12 1 2 3 4 5 6 7 8 9 11 15 12 1 2 3 4 5 6 7 8 9 11 12 15 だと思うけど、これ見ただけじゃわからないと思うんですが。 http://sorting.at/ こういうの見た方がわかりやすいんじゃないかなぁ
> ……可能でしょうか。 はい。可能です。
そんな不完全な仕様でプログラム作れるのは、大天才か、(理解しないで適当に作る)大馬鹿です。 普通の人なら、もっと詳細まで内容を吟味して、「あとはプログラミング言語で書くだけ」って状態しましょう。 コツは「全部まとめてやろうとしないこと」 メインの流れは、例えば次のようになるでしょう for(最初から終了時間まで) { 　人が移動する(); 　蚊が移動する(); 　感染判定(); 　状態出力(); } 簡単ですよね? 「人の移動」を考えます for(人数) { 　ある人が移動する(); } 簡単ですよね? 「ある人が移動する」を考えます 　　その人の位置 = その人の現在値 + 移動した分 簡単ですよね? こんな風にして、問題を分割していけば、案外「簡単」なことばかりなのが、プログラムです。
このプログラムをそのまま実行させて、データを1行で 20 30 40[Enter] と入力するだけでできます。 scanfの書式指定%dは改行も空白も（Tab文字も）無視してそれ以外の文字だけを取り込みます。したがって、scanfを3回使っていても、データを3行に分ける必要はありません。なお、キーボードからの入力では、[Enter]を入力しないと入力データがプログラムに渡りませんので最後の[Enter]は必要です。
少しは、頭を使って考えたり、身体を使って検索してみよう http://ja.wikipedia.org/wiki/%E3%82%AF%E3%82%A4% … 読んで理解できるかどうかは別として
実際にプログラムを作って確認するのが早いです。 確認は次の方法等でできます。 ・デバッガでステップ実行する ・途中経過を出力するように、プログラムを変更する for(i=～ 　for(j=～ 　　printf("%d番目と%d番目を比較します\n",i,j) ; 　　if ( a[i]>a[j] ) { 　　　printf("%d番目と%d番目を交換します\n",i,j) ; ... 　　　print_array(a,n) ; /* 配列の内容を出力する関数を自作する */ ,,,
C++をマスターしてやる！ という強い意思と目的が無いなら、やめておいた方がいいです。 覚えるべきこと、約束事が多く、肝心の数値演算までたどり着けないかもしれません。(プログラミングが得意でなければなおさら) 数値演算に特化した言語やツールが沢山あります。 そういったものがいいと思います。 R言語、MatLab、Numpy等
分割前 key=_getch(); 分割後 key=_getwch(); 分割の前後でここの関数を変えたのは何故でしょうか。
「解答をなくし」たことで, 何が「わからずじまい」なんですか? C のホスト環境では, main は ・int main(void) ・int main(int, char **) ・その他処理系定義の形 のいずれかである必要があります＞#3. ということで「処理系に無関係に『正しいプログラム』を書く」という観点では間違っていません.
追記の追記。 mallocされたメモリが開放されないまま、次々に新しいメモリが確保されていき、使い終わったメモリが誰にも開放されないままプログラムが終了している（メモリリークしている）が、Nの最大値は1024くらいなので、ほぼ実害は無い。 doubleの値が数千個分メモリリークした所で今のOSは屁でもないので、ユーザーメモリがちょっと減ってオシマイになるだけ。 このプログラムを何千万回も動かすとか、ずっと常駐させて繰り返し動かすとかすれば、実害が出るだろうけど。
>現在、ハッシュ計算のようなそのクラスの中だけで使用する関数がprivateであり >これのアルゴリズムが正しいかテストしたいのです >値の計算にはクラスのメンバも使用するため >そのクラス外部に切り出すことができません なぜ、できないのでしょうか？ 自分で実装を変えられるならば、外部に切り出すことができないということはありえないはずですが。 メンバに依存しないように分離すればよいだけのことです。
>明示的にデストラクタが呼ばれてしまった場合でも >リカバリーできるようにしたいのです そもそも明示的にデストラクタを呼び出した後、デストラクタを含めインスタンスメソッドが正常に呼び出される保証がありませんけど。 #2で既に書いてますけど明示的にデストラクタを呼び出したことによってインスタンスの残骸にしてしまったものに、いったい何を期待してるんですか？ インスタンスの残骸にインスタンスとして動くように期待しても、それは無理です。
3番目： http://www.st.rim.or.jp/~phinloda/cqa/cqa6.html#Q8
ちょっと古い標準を参照しますが，ISO/IEC 9899:1999によると， > A return statement with an expression shall not appear in a function whose return type is void. > A return statement without an expression shall only appear in a function whose return type is void. となっています (6.8.6.4 The return statement ¶1)。 これはConstraintで定義されているため，これに違反しているNo.2に対して処理系は少なくとも一つの診断メッセージを出さないといけません (5.1.1.3 Diagnostics ¶1)。 しかし，制約違反があった場合にコンパイルやリンクを止める必要があるとも書かれておらず，それどころか(標準を構成しないとはいえ)脚注8に > It may also successfully translate an invalid program. とまで書かれているため，今回のように実行までできてしまうことはありえます。 なお，No.2のmainの戻り値は，この場合のみ特別で0となるため (5.1.2.2.3 Program termination)，この点においての未定義の振る舞いはありません。 No.2のプログラムは，制約違反を犯していることは確かなので，(No.1の}がNo.2の後に入っていることを除いて)，「たまたま」動作しているだけ，と言えます。 制約違反のプログラム，つまりは標準Cの仕様外で動いているプログラムであるため，結果が正しいかは「正しい」の基準がないため判別できません。
Profile機能を使います(iniファイル） この様な記述のファイルが出来ます [aaa] bbb=0 ccc=1 [ddd] eee=0 fff=1 記述の意味は↓ [セクション名] キー名=値 http://msdn.microsoft.com/ja-jp/library/cc429763 … 参考 http://park1.wakwak.com/~ima/visualcpp_tips0005. …
呼び出し流れが良くわかりませんが、SetMemString を繰り返すならば 少なくとも UnmapViewOfFile は1度にしておいた方が良いと思いますが...
> char型に変更してみたのですが、何故かエラーが発生してしまいます。 関数StackAllocは、きちんと構造体のメモリを確保していますか。まさかとは思いますが、第一と第二引数を関数calloc（もしくは関数malloc）に渡して呼び出しているだけ、ではありませんよね。 ポップするとき、結果を引数で受け取るならStackPop(s, &x)のようにxのアドレスを渡すべきですが、プッシュするときはStackPush(s, x)のようにxを値渡しするべきです。それとデータ型に気を付けてください。 先輩さんのアドバイスを活かすなら、私は下のようにします。あとは括弧の対応を確認する方法ですが、これはスタックの使い方をよく考えれば分かるでしょう。 #include <stdlib.h> #define StackNo(s) ((s)->num) #define StackSize(s) ((s)->max) Stack *StackAlloc(int max) { Stack *stack = malloc(sizeof(Stack)); if (stack != NULL) { stack->max = max; stack->num = 0; stack->stk.head = stack->stk.crnt = NULL; } return stack; } int StackPush(Stack *stack, char data) { int ng = 0; Node *next = malloc(sizeof(Node)); if ((next != NULL) && (stack->num < stack->max)) { next->data = data; next->next = NULL; if (stack->stk.head == NULL) { stack->stk.head = stack->stk.crnt = next; } else { stack->stk.crnt->next = next; stack->stk.crnt = next; } stack->num++; } else { free(next); ng = -1; } return ng; } int StackPop(Stack *stack, char *data) { int ng = 0; Node *prev = stack->stk.head; Node *crnt = stack->stk.crnt; if (prev != NULL) { *data = crnt->data; if (prev == crnt) { stack->stk.head = stack->stk.crnt = NULL; } else { while (prev->next != crnt) { prev = prev->next; } prev->next = NULL; stack->stk.crnt = prev; } free(crnt); stack->num--; } else { ng = -1; } return ng; } void StackFree(Stack *stack) { char data = '\0'; if (stack != NULL) { while (StackPop(stack, &data) != -1); } free(stack); }
「ポインタ」です
>fgets(str, sizeof str, stdin);　としたほうがバランスがいいのでしょうか。 >ちなみに、変数宣言のところでchar str[256];としているため、 >改めてfgets(str, 256, stdin);　と読み込み文字数を256にする必要はないのでしょうか？ char str[256]; では足りなかったから char str[384]; に拡張しよう！ というのが、この先「絶対に」発生しないならいいんじゃないですか？ # 私はdefine定義で対応することの方が多いですけど。(wcharとか使うコトほとんどないし) 256から384に拡張したからgrepで256探して書き換えればオッケー♪ とか思っていた場合は、今回の254が漏れて不可解な挙動を…ということに。 まぁ、そんなワケで…… いわゆる「マジックナンバー」の使用は控えた方がいい。 ということで。 # プログラミング続けていればマジックナンバーで余計な手間を経験することもあるでしょう。 # そういう、(ある意味)痛い目を見ないと理解できないかも知れませんね。
print()がprint.cに記述してあることは どこの書いているのでしょう？ あなたは作った本人だから知っているけど、 コンピュータにはわかりません。
> １つのＸファイルに１つのＭＥＳＨの場合は、法線情報数が頂点数とも面数とも一致しないということはないですよね 例えば円盤をかんがえてみてください。 中心に1点頂点を置き、そこから放射状に20枚程度のポリゴンを敷き詰めて円盤を作ったとします。 完全な円盤であれば法線はどこを見ても一緒なはずなので、データとして1個だけ法線を持ち、 全ての面と法線がそれを参照する、といった形でデータを作ることもできます。 上記の場合、ファイル内の要素数は 点数→21 面数→20 法線数→1 となります。 法線数を点数、面数と一致するようにデータを作ることは可能です。 ですが、xファイルの仕様としてはそれは保障されていません。
> 当てはまる箇所がありますか？ に対しては「あります」ですが、 その前に 「関数」 「引数」 の意味を理解してますか? 理解できていれば、こんな質問する必要がないはずです。
既に回答があるけど蛇足的に追加. for (あれ; これ; それ) なんか というのは, ＊だいたい＊ { あれ; while (これ) { なんか それ; } } と等価になります. つまり for (int i = 0, rad = 0.0; i <= 6; i++, rad+= drad) なんか は＊だいたい＊ { int i = 0, rad = 0.0; while (i <= 6) { なんか i++, rad+= drad; } } と同じです. ちなみに C でもだいたい同じ.
#1です。 そういうことではなくて double t = 0.05; からはtが時間幅のように見えるが t += 0.05; からはtが時刻のように見える。 通常はx[i+1]=x[i]+x'[i]*dtでdtは時間幅のように計算するものだけれど，本当に式は意図通りなの？ということ。 あとは#2さんの言うようにaやbが意図通りに読まれているかどうかの確認です。
既に回答されているとおり…ですね。 >animal[0] = "dog" なら animal[0]には"dog"の先頭アドレス(00403000)が代入されているのではないのでしょうか。 もちろん代入されています。 「dogなりcatなりの文字列」が表示されるのは＃１さんで指摘されているとおり、%sだから。 >0022FF40 animal[0] : dog, アドレス : 00403000 最初の16進は「char*型の配列変数animalの各要素」のアドレス。 # たぶんスタック上。 ポインタなんで次の要素のアドレスは文字列の長さに関係なく4バイト(32ビット)先ですね。 次の「animal[※]」は配列の添え字。 まぁ、何番目か。というのを判りやすくするため。 その次のdogとかは「ポインタが指している先に格納されている文字列」です。 アドレスのあとの16進数が、その文字列が実際に格納されているアドレスです。 # ポインタが指している先とも言う。 表示されている状況からするとメモリイメージとしては… 00403000 64 6F 67 00 63 61 74 00 68 61 6D 73 74 65 72 00 00403010 6D 6F 75 73 65 00 …… と配置されている。ということでしょう。 # 文字列リラテルなので書き換え不可の領域とされているハズです。
show visible 違い　で検索すれば、いくつもヒットしますけど．．．
以下のようにしてください。 方法1 red_fの戻り値でf_pを返すようにする ---------------------------------- #include <stdio.h> #include <stdlib.h> FILE *read_f(void); void output_f(FILE *f_p); int main(void){ FILE *fp; fp = read_f(); output_f(fp); fclose(fp); return 0; } FILE *read_f(void){ int fn=0; FILE *f_p; char f_name[256]; printf(" text number 1, 2, 3, 4 : "); scanf("%d",&fn); sprintf(f_name,"map%d.txt",fn); if((f_p=fopen(f_name,"r"))==NULL){ /*f_nameを " " で囲まない!*/ printf("You will not be able to open the file\n"); exit(1); } return f_p; } void output_f(FILE *f_p){ int i,j; int array[10][10]; for(j=0;j<10;j++){ for(i=0;i<10;i++){ fscanf(f_p,"%d",&array[i][j]);//画面表示 10*10 printf("%d",array[i][j]); } } printf("\n"); } ----------------------------------------------------- 方法２ read_fの出力パラメータでf_pを返すようにする ---------------------------------------------------- #include <stdio.h> #include <stdlib.h> void read_f(FILE **f_p); void output_f(FILE *f_p); int main(void){ FILE *fp; read_f(&fp); output_f(fp); fclose(fp); return 0; } void read_f(FILE **f_p){ int fn=0; char f_name[256]; printf(" text number 1, 2, 3, 4 : "); scanf("%d",&fn); sprintf(f_name,"map%d.txt",fn); if((*f_p=fopen(f_name,"r"))==NULL){ /*f_nameを " " で囲まない!*/ printf("You will not be able to open the file\n"); exit(1); } } void output_f(FILE *f_p){ int i,j; int array[10][10]; for(j=0;j<10;j++){ for(i=0;i<10;i++){ fscanf(f_p,"%d",&array[i][j]);//画面表示 10*10 printf("%d",array[i][j]); } } printf("\n"); } ------------------------------------------------------ どちらでも問題ありませんが、方法１のほうが理解しやすいので、そちらを推奨します。 なお、printf("%d",array[i][j]);の位置が誤っていますので、正しい位置に修正してあります。
余談ですが「保守」を考えるなら最低限 _SET という名前はやめた方がいい. この手の識別子は処理系予約.
int型だったとして int x[] = {x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25}; などとする方法もあります。参考になれば。
関数内で宣言した関数は、その関数内でのみ有効な変数になります。関数が異なれば、同じ変 数名で宣言することができます。例えば、main関数と(C)kansuu関数で、同じ(A, D)hennsuuという名 前の変数を宣言することができます。 　int main() { int (A)hensuu = 0; (B)kansuuu(1); } int (C)kansuu(int hikusuu) { int (D)hensuu = 10; } 　列のmain関数で宣言されている(A)hensuuと、さ(C)kansuu関数で宣言されている(D)hensuuは 同じ名前ですが、独立した異なるものです。(C)kansuu関数が実行されているときに、(D)hensuuの値 を変更しても、main関数で宣言されている(A)hensuuの値は変更されません。 また、(C)kansuu関数を実行している間だけ、(C)kansuu関数で宣言されている(D)hensuuが有効です。 (C)kansuu関数から呼び出し元でるmain関数に戻った際は、(C) kansuu関数で宣言した (D)hensuuはもう有効ではなくな、値を参照することもなくなります。
何も判りませんが、ShellExecute()関数で成功するならば、違いはウィンドウ絡みを疑います。 自分なら ShellExecute の nShowCmd を変えてみて何が必要か推測します。
http://www.kurims.kyoto-u.ac.jp/~ooura/fftman/in … FFT (高速フーリエ・コサイン・サイン変換) の概略と設計法 上記サイトを参照下さい。 3. 多次元 FFT 等の項目等が処理の参考になると思います。 その他、参考文献　FFT Links から数多くのサイトや参考パッケージ、ソースコード等が辿れます。
正直なところ「それだけ書かれても何もわからん」としかいえん. あとは http://www.equation.com/servlet/equation.cmd?fa= … くらいか?
#3です 私の回答のFormatの書式を間違えてますね … 正しくは質問の通り "{0:#,0}" です
よく見たら、その前に num をインクリメントしてますね。 その必要があるかどうかわかりませんが、そのために p が NULL になってしまいますね。
面倒だからコピペしているんでしょうけど…… http://oshiete.goo.ne.jp/qa/8819889.html で指摘されたところ直っていないよ？ コピペ元が。 >回答を頂いてそこを直すと正しく実行できたと勘違いして ってコトで、先の回答が勘違いだったそうですが… >else if(L=-1&&M==0&&N==-1){ というコードがどういう結果をもたらすか。というのはちゃんと把握した上でのコードってことでいいんですかね？ 今時のコンパイラなら警告なり出ていると思いますけど。 で、大本の質問に関しては…コード読む気にもならないので検証すらしていません。 インデントはともかく、説明のコメントもない２つの質問にまたがるコードを調べよう。という気にはなりませんので。 # 現象が再現できる程度までコード削るとかしてみません？ 結果を格納する変数が異なるだけで、途中の演算が同一。というのであれば…… 演算部分を関数化するか、結果を受け取る変数を配列にして添え字の方を処理するか、ポインタ使うか…そういう対処しますかねぇ。おそらく。 まぁ、回答じゃないんで削除されるかも知れませんけど。 # 回答貰いやすくする為のアドバイス…にもなっていないか。
> 何故どれも最後のelse文が実行されないのか それはそのようにプログラムされているから。 for (L = -A; L <= A; L++){for (M = -B; M <= B; M++){for (N = -C; N <= C; N++){ の3重ループで合計45回回るようだけど，そのうち if (r < R){ を満たすのは L == -1 && M == 0 && N == -1 L == -1 && M == 0 && N == 0 L == -1 && M == 0 && N == 1 L == 0 && M == 0 && N == -1 L == 0 && M == 0 && N == 0 L == 0 && M == 0 && N == 1 の場合しかないのだからelseにはひっかからない。
面倒くさいから見てないけど ×　else if(L=-1&&M==0&&N==-1){ ○　else if(L== -1&&M==0&&N==-1){ じゃないの？
1. まずmain文から処理が始まる（約束事） 2. 「kansuu(2, 3)」で関数kansuuを呼び出す。引数は2、3。 3. 関数kansuuの処理が始まる。hikisuu1の値は2、hikisuu2の値は3。 4. 「hikisuu1 * hikisuu2」を計算する。2×3＝6なので計算結果は6。 5. 上記4より「return hikisuu1 * hikisuu2;」は、関数の呼び出し元に6を返す。 6. 上記5より「modori = kansuu(2, 3);」は、変数modoriに6が代入される。 以上。
>　C言語ののコンパイルは　 Express 2013 for Windows Desktop >　　ではできるのでしょうか？ 左側で、インストール済み → Visual C++ → コードを選択。 右側で、C++ ファイル(.cpp) を選択。 このまま先に進んで大丈夫です。今回の質問のコードだとエラーが2か所ありますので、コンパイル(ソリューションのビルド)で下のペイン(エラー一覧)にエラーが表示されます。前回のコードだとエラーが出なく正常終了するので (16) デバッグ → デバッグなしで開始 を選択する (17) コンソール画面が開き、実行結果が表示されているのを確認する。 まで進んでいけます。 エラーがあっても止まらずに変な結果を出すコンパイラより、エラーだときちんと警告して止まってくれるものを利用されるほうが勉強のためにはいいと思いますので頑張ってください。 また、エラーなどが出た場合、エラー一覧で該当エラーをダブルクリックしたらエラー箇所に飛んでくれますし、デバッグ→オプションと設定→テキストエディター→C/C++全般で「行番号」にチェックを入れて行番号を表示しておくと、エラー一覧で該当エラーがどこなのか右のほうに「行」がでますのでそれを参考に該当箇所を探すこともできます。
AllBooks=全ての本の情報 みたいにして、 http://dobon.net/vb/dotnet/programing/arrayfilte … にあるような方法で、必要に応じて Star5 = Allbooks.フィルタ(Rate-5を検索) のように抽出して foreach(book in Star5 ){ 星5の処理; } と該当したものだけ処理をする。 というのが素直でいいと思います。 別解。 データはデータベースに保存する。 必要なときに、必要なものだけを抽出したり更新したりする。
直接の回答は #1 の通り (ただし右辺の USA にもスコープが必要) なんだけど, もし本当に #include <iostream.h> なんて書いてあるんだとしたらそんな「解説書」は焚書の対象にしてください. いまどきそんな書き方はしません.
ハードがなんなのか、処理系がなんなのかわからないから、 その環境で動かしてみたら？としか言えないよ。
あと、そこが解決すれば終り、では無いと思われます。 期待通りかどうか、ちゃんと確認しましょう。 計算結果が出ていることと、それが正しいかどうかは、無関係です。 Hdx3no2=((-ux2/pow(r,3))+3*X*(ux2*X+uy2*Y+uz2*Z)/pow(r,5)); や、同様の箇所ですが、例えば if(L==0&&M==0&&N==-1||L==0&&M==0&&N==0||L==0&&M==0&&N==1) だと、ループ中 L==0, M==0, N==-1 L==0, M==0, N==0 L==0, M==0, N==1 の3回実行されます。 その最後の結果だけが記録され、他は上書きされています。 よって Hdx3=Hdx3no1+Hdx3no2; で使われるのは、最後の値だけです。 それって、正しいのでしょうか?
> 　以下の使い方がいまいちわかりません？ > printf("kansuu de hyouji\n"); > modori = hikisuu1 * hikisuu2; > printf("modori = %d\n", modori); 使い方というか、元のコードは関数の作成例だと思いますが、関数を利用しないで使ってる変数は利用するとして同じような流れだと以下のような感じでしょうか。 int main() { int modori; int hikisuu1; int hikisuu2; hikisuu1=2; hikisuu2=3; printf("kansuu de hyouji\n"); modori = hikisuu1 * hikisuu2; printf("modori = %d\n", modori); return 0; }
あいかわらず「たまに」だと、なかなか厳しいですね。 # というかC/C++のネタではなくなってきてますが。 同様の現象を経験したことはありませんが… エラーメッセージをそのまま読むと「接続が切れた」って感じですね。 普通にやってて接続が切れることはそうそうないと思いますが…。 とりあえず、サーバ側の設定の確認でしょうかね？ httpsで繋げているようですのでApacheのタイアウトの設定辺りでしょうか？ デフォルトだと300秒かと思われますので…普通ならタイムアウトはしないと思いますけど…。 接続に使用している回線の問題で切断されている。という可能性はありませんか？ # モデムなどでのダイヤルアップとか。 # LANケーブルが断線しかかっている…とか。 サーバ側のログの確認も必要でしょうかねぇ…。
http://www.grapecity.com/tools/support/technical … これ？
なんというか, 「dispose→new」は美しくない気がする. clsa とかに「初期化する」メソッドを追加するのが普通じゃないかな. あと, clsa とかが「ここでしかインスタンス化されない」のであればほかにも方法はあると思う.
というワケで簡単に。 # 手動で閉じた場合だとか、タイマーのキャンセルしてないとか…まあ、いろいろありますけど。 全角スペースでインデントしていますので、コピペする際にはご注意を。 public partial class Form1 : Form { 　private Timer CloseTimer; 　public Form1() 　{ 　　InitializeComponent(); 　　CloseTimer = new Timer(); 　　CloseTimer.Stop(); 　　CloseTimer.Interval = 3000; 　　CloseTimer.Tick += new EventHandler(CloseTimer_Tick); 　} 　void CloseTimer_Tick(object sender, EventArgs e) 　{ 　　this.Close(); 　} 　private void button1_Click(object sender, EventArgs e) 　{ 　　label1.Text = "正解です。"; 　　CloseTimer.Start(); 　} 　private void button2_Click(object sender, EventArgs e) 　{ 　　label1.Text = "間違いです。"; 　} }
>http://codepad.org/ ためしてみましたが、return 1; でも Exited: ExitFailure 1 が出ますね。出なかったというのは、勘違いでは？ 他の方も書いていますが、return の結果をどう使うかは使う側の問題です。
# 書いている間に別の方から似たようなことをすでに回答されていますが、、そのまま投稿しちゃいます。 プロパティもカプセル化手段の一つですので「プロパティをできるだけ使わずにカプセル化して」というのはちょっとよく分かりません。 読み取り専用プロパティを設けたい場合には、以下のような自動実装プロパティを読み書き別のアクセス権にすると楽です。 public string ISBN { get; private set; } リスト状のデータをXML保存するための標準的な考え方は「用途に応じて適切な手法を用いる」です。 たとえば、出力形式は決まっておらずアプリの都合で保存/復元が出来れば良いのであればシリアライザを用いてまとめて保存しても良いでしょうし、出力するXMLのスキーマを特定の構造にしたいとか、きめ細かいエラー処理をしたいという場合には自前の保存処理を作れば良いでしょう。 シリアライザを利用する場合、XmlSerializerでもよいですけれど、個人的には DataContractSerializer をおすすめします。 privateメンバの保存/復元も出来ますし、メンバがリスト状でも大丈夫です。 こんな風にデータクラスに属性のマーキングをして、 // System.Runtime.Serialization への参照設定をしておく。 [DataContract(Namespace = "")] public class Book { public Book(string isbn, string name) { this.ISBN = isbn; this.Name = name; } [DataMember] public string ISBN { get; private set; } [DataMember] public string Name { get; private set; } } こんな風にリストごと保存/復元をすることが出来ます。(エラー処理等は除く) private void xmlSerialize(string filePath, List<Book> bookShelf) { var confDir = Path.GetDirectoryName(filePath); Directory.CreateDirectory(confDir); var xmlSettings = new XmlWriterSettings(); xmlSettings.Indent = true; using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.Read)) using (var xmlWriter = XmlTextWriter.Create(fileStream, xmlSettings)) { var dataContractor = new DataContractSerializer(bookShelf.GetType()); dataContractor.WriteObject(xmlWriter, bookShelf); } } private List<Book> xmlDeserialize(string filePath) { using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read)) { var dataContractor = new DataContractSerializer(typeof(List<Book>)); return (List<Book>)dataContractor.ReadObject(fileStream); } } 注意点としては、デシリアライズ時にはコンストラクタが呼び出されないため、データクラスに以下のようなメソッドを加えてシリアライズ前後に処理を行う必要がある場合も、あるでしょう。 [OnDeserializing] private void onDeserializing(StreamingContext context) { // シリアライズ直前の処理 } [OnDeserialized] private void onDeserialized(StreamingContext context) { // シリアライズ後の処理 } 自前で保存を行うならば、XDocumentを利用したLINQ to XMLによる処理をおすすめします。 以下の例では Select で射影して一括で処理していますが、エラー時に場所や値を詳細に出したい場合などは foreach で回したり要素をもっと細かく見る処理にしても良いかと思います。 private void saveLinqToXml(string filePath, List<Book> bookShelf) { var confDir = Path.GetDirectoryName(filePath); Directory.CreateDirectory(confDir); var shelfXml = new XDocument(); shelfXml.Add( new XElement("BookShelf", bookShelf.Select(book => new XElement("Book", new XElement("ISBN", book.ISBN), new XElement("Name", book.Name) ) ) ) ); shelfXml.Save(filePath); } private List<Book> loadLinqToXml(string filePath) { var shelfXml = XDocument.Load(filePath); return shelfXml.Root .Elements("Book") .Select(bookNode => new Book((string)bookNode.Element("ISBN"), (string)bookNode.Element("Name"))) .ToList(); }
＞ライブラリ使用者がライブラリ内でしか使用しないグローバル関数やグローバル変数と同じ名前を使用しても問題ないレベルを希望しています。 C言語ではそれは不可能。言語の仕様上、そういう事は「出来ない仕様」になっています。 例えば、fopenを使うと、fopen等のファイル入出力関数群がグローバルに扱う「_iobuf」と言う変数がリンクされます。 当然、ユーザーは「_iobuf」と言う名前のグローバル変数を作る事は許されません。「同じ名前は許されない」からです。 そのため、Cの標準ライブラリでは、グローバル変数やシンボリック定数は「アンダースコアから始まる」と決められ「ユーザーはアンダースコアから始まる変数や定数を作ってはならない」と決めました。 とうぜん、そうした理由は「ライブラリ内でしか使用しないグローバル関数やグローバル変数と同じ名前は、ユーザーは使用出来なくなる」からです。 なので、最初から「ユーザーは使うな」と決めたのです。 「使うな」と禁止しておけば、バッティングする事は有り得ません。
作りたいのなら、ここで丸投げせずに少しずつ自分の力で書いていくしかないです。 で、最初にやるには難しすぎるのでもっと簡単なもの「じゃんけん」などにチャレンジしてみてください。
分割したトークンの実体を格納している領域はどこですか？
同じような問題に同じ時期にハマる人がいるんですねぇ。 同じチームの人たちなのかも知れませんが。 とりあえず、データに関しては＃２さんの書かれているようにクラスなりにまとめて、 フォーム間でのやりとりはプロパティ経由なり、受け渡し用のアクセスメソッド入れたり…でよいのではないですか？ 最初に起動するであろうメインフォームのフィールドにデータを保持するクラス/構造体のインスタンスを持って、子フォームには親フォーム経由で受け渡し。 # カレンダーの例では面倒ですが個々のデータを送るしかないでしょう。 あるいは、親フォームの方にデータ受け渡し用のプロパティかアクセス用メソッドを用意して、子フォームからアクセスする。とかでしょうかね。 # カレンダーなら表示更新の際に表示に必要な情報を親フォームに問い合わせればいいし。それなら最大で31日分です。
＞2本のグラフを一つにまとめる 分布図の方がよくないですか。
GetDitailOfの第2引数に 194を指定すればサブタイトルが取得できるみたいですよ 　　Dim sh As New ShellClass 　　Dim f As Folder = sh.NameSpace("ファイルのディレクトリーパス") 　　Dim item As FolderItem = f.ParseName("対象のファイル名") 　　MsgBox(f.GetDetailsOf(item, 194)) といった具合です
「複数の物理量を縦に並べる」の意味が分からん. 複数のグラフを 1つの図にするということなら意味は分かるが, もしそういう意図の質問だとしたら質問する前に gnuplot のマニュアルを読め. そこに関しては「linux」も「gcc」も「TEX」 (が何か知らんが) も完全に無関係だ.
C++の中には包括的にC言語の仕様も含まれてますので同じようなことは学べます。 ただC++は複雑ですし最初に学ぶ言語としては今の時代では適切ではないと思います。よほどC++にこだわる目的があれば別ですけど。
> もし返したい bool 型が関数処理の成否を表すもので、関数を使う側がその戻り値を > 必ず確認しないとまずい場合は、関数の戻り値を string のみにして失敗時に例外を > 投げるようにしたほうがいいです。 あるいはこんな: using System; public class Program { static bool fun(int n, out string result) { result = "???"; if ( n == 0 ) return false; if ( n > 0 ) result = "正"; else result = "負"; return true; } public static void Main() { bool nonzero; string result; nonzero = fun(0,out result); if ( nonzero ) Console.WriteLine(result); nonzero = fun(1,out result); if ( nonzero ) Console.WriteLine(result); nonzero = fun(-1,out result); if ( nonzero ) Console.WriteLine(result); } }
おそらく、無限ループに入っているのだと思います。このページなどは参考にならないでしょうか。 http://stackoverflow.com/questions/8697385/openc … 動作の確認用にソースにログ出力を加える…などの方法も書かれていますが、-minposを明示的に指定すれば解決するのでは？という内容もあったりします。 試したわけでは無いので何とも言えませんが、参考までにご参照ください。
>それを知るために質問しました。 とりあえずいっておくと コンパイラがソースを読む順番と 実際に実行する順番は何の関連もありません。 実行される順番は#2の方が説明されてますので、よく読んで理解しましょう。
>ifstream instream = inStream(argv[1]); >while (instream >> input) >にするとうまくいくようなのですが、この違いがよくわかりません。 >違いを教えてください。 inStream()の中で「毎回、新規にオープンし直す」ので、結果として「毎回先頭から読み込んでいる」んです。 # 正確には…ローカル変数としてifstreamのインスタンス作成して…でしょうかね。 コードに書かれた通り、正常動作していますよ。 # ただし、オープンしたifstreamを閉じていないので、リソースリークしていると思いますが。 ってか… >ifstream inStream(char *str) { >ifstream inStream(str); だと、再帰で永遠に自分呼び出ししません？(吹っ飛ぶまで) # いや、ローカル変数名と関数名が同一だからコンパイルエラー？
MSDN を調べたら以下の記述が見つかりました。 「フィールドを static const として宣言することはできませんが、const フィールドは、その動作において本質的に静的です。 const フィールドは、型のインスタンスではなく型に属します。 そのため、const フィールドにアクセスするには、静的フィールドに対して使用するのと同じ ClassName.MemberName 表記法を使用します。 オブジェクト インスタンスは必要ありません」 http://msdn.microsoft.com/ja-jp/library/79b3xss3 … つまりフィールド変数の場合（ちょっと問題のある記述かもしれませんが）const（C#） == static final（Java）という事になります。 const の使用例の ConstTest でも生成したインスタンスを通して const 変数を使った後にクラス名から直接 const 変数を使っています。 http://msdn.microsoft.com/ja-jp/library/e6w8fe1b … ……というか、C# の話なんだから第三者の比較説明サイトよりもまず総本山の MSDN を調べようよｗ
>コンパイラがそれを変数aが読み取り専用であることを判断するのに使っているのではないか？ コンパイラはそんな事では判断していません。 コンパイラはaが配列として書かれているので書き換えできないようにしてるだけです。 >ちなみに、 >char *p = "fuga"; >とした場合は、pと&pのアドレスは異なって、pの中身は書き換えられます。 pはポインタ変数であって配列じゃないからです。
bmpSource1の読み込みを ファイルネームの指定ではなく FileStreamを使えばいいようです System.IO.FileStream fs = new System.IO.FileStream(sCurDir + "\\AAA.bmp", System.IO.FileMode.Open); bmpSource1 = new Bitmap(fs); fs.Close(); bmpSource2 = new Bitmap(sCurDir+ "\\BBB.bmp"); pictureBOx1.Image = bmpSource1; // ファイルの保存形式を指定しないと png形式になってしまったかも // 2013とかだと 拡張子からの自動判断に直ってるのかなぁ … // 当方 2010Express bmpSource2.Save(sCurDir + "\\AAA.bmp", System.Drawing.Imageing.ImageFormat.Bmp);
＞この環境ではアルゴリズムは変化するのでしょうか？ Nodeとマウスの位置座標とも同じ座標系ならアルゴリズムに変わりはありません。 Edge_eraseでNodeを書き換えていると思いますが、 とりあえずのデバッグ方法としては、Edge_eraseをコメント行にして、代わりに、 i, j, num, Node[i].x, Node[i].y, Node[num].x, Node[num].y, x, y などを画面かファイルに出力して数値を確認してみてはいかがですか？ もしそれに異常がなければEdge_eraseのロジックに問題があるかもしれません。
＞のところで、for文の終了条件がなぜ*p1となるのかが分かりません。（ポインタが苦手なもので・・・） C言語で「条件式において、非0は真、0は偽」です。 本当なら for (p1=buff;*p1 != '\0';p1++) { と書くべきですが、 条件式「*p1 != '\0'」は「0じゃないなら真、０なら偽」なので、条件式を「*p1」と書いても、結果は同じです。 ＞ （結局if文でbreakするから何でもいいような気もしますが・・・） だめですよ。もしタブ文字が来なかったら、forループが終了しません。 文字列を「先頭から末尾までポインタでループする時」は、常套的に for (p1=buff;*p1;p1++) { と言う書き方をします。「決まり文句」みたいなモノです。 ＞また、 *p1++ = '\0';　について ＞>これはタブがあったら、タブの所に「文字列終端」を書き込んで「タブの次の位置をp1に覚える」と言う処理。 ＞と説明してくださっていますが、つまり、タブの部分に文字列終端（\0）を上書き→p1を次の位置（最初の音素）にする　という処理を行っているということでしょうか？ そうです。タブがあった場所に文字列終端を書き込んでから、p1を１つ進めています。 ＞2行目は文字コード分足してるのかな？と思うのですが、 ＞ *(short *)p2 = *(short *)p2 + 41217; カタカナとひらがながの文字コードを「shortの数値」として扱った場合、両者の「数値の差」が「41217」なので、その分を足しています。 ＞3行目のif文と、 ＞ if ((p2[1] < 0) || (p2[1] == 127)) p2[1]++; 差を足してカタカナにしたあと、シフトJISの文字コードの第２バイトが「127」か「負数」になった場合は、文字コードを１文字分「シフト(増加)」させる必要があります。 その「シフト(増加)分」を足しています。 これが「シフトJIS」が「シフトJIS」と呼ばれている所以(ゆえん)です。 ＞for文の繰り返し条件でなぜ+2するのかが分からないです。 ＞for (p2=buff;*p2;p2+=2) { シフトJISの漢字コードは「２バイトで１文字」なので、「１文字づつループする為」に「２バイトづつ進めている」のです。
http://support.microsoft.com/kb/883200/ja http://121ware.com/qasearch/1007/app/servlet/rel … の両方を参照して「ファイル名を指定して実行」でメディアプレーヤーを起動して /play /close が正常に機能しているか確認してみて下さい。 「ファイル名を指定して実行」で、メディアプレーヤーが再生完了後に終了して閉じるのであれば、機能的には問題が無いという事になりますから、あとは「呼び出し方法の問題」だけになります。
元の 　　　「ここでは、関数kansuuの定義とプロトタイプ宣言に 、引数を追加しました。 の意味は、関数　int kansuu( ) に、 引数　int hikisuu　　を 追加しました、　という意味だと思うのですが、単に、関数のプロトタイプを追加したということだと思います。 C言語は、基本的に　前方参照なので、関数、変数などを呼び出す前にそれらの定義文があるのが前提です。 一般的には、main()　は、ソースコードの最後に置かれ、そこで呼び出す関数はmain()よりも前に記述するのが多いです。そうすれば基本的に前方参照になるので、プロトタイプ宣言をいちいち記述する手間が省けます。 何らか都合で、もしくは外部で定義される関数を呼び出す時は、プロトタイプ宣言を参照される前に記述します。 単なる定義文なので、呼び出し元と先で定義が間違っていなければ、コンパイル結果に影響は与えません。 呼び出し元と先の定義がもし間違っていると、コンパイルエラー（ワーニング）になるか、コンパイルが通ったとしても、間違った計算がなされるか、暴走するかいずれかでしょう。C言語の型宣言などの非常に重要なところです。 詳しくは、C言語、前方参照（前方宣言）などを参考書などで良く調べてみてください。
受信する側は受信してるんでしょうか。 受信する側が受信してなくて送信バッファが溢れてる状態なのでは？
ひとつ前の値を保持しておけばいいのなら: #include <stdlib.h> #include <stdio.h> #include <math.h> int main(void){ double dt = 0.001; double t; const double tmax = 1.0; double cur = 0.0; /* 現在値 */ double old; /* ひとつ前 */ for ( t = 0.0; t <= tmax; t += dt ) { old = cur; /* 直前の値をoldに */ cur = 2*cos(2*3.14*60*t); printf("%lf : %lf %lf\n", t, old, cur); } return 0; }
まずは、マニュアルを読みましょう http://msdn.microsoft.com/ja-jp/library/ee404875 … to_stringには、書式設定の指定は無いようです。 > float値を文字列に変換したもの > long doubleを文字列として取得 floatやdoubleを文字列にするとき、決まった形式というのはありません。 ある程度標準のものはありますが。 long doubleも正しく文字列になっています。 ただ、spirntfの%Lf相当、ということで、floatやdoubleの%fと同じ桁だけしか文字列になっていないだけです。
そもそもDirectXを直接扱うこと自体が時代遅れかもしれません。 ゲームエンジンやフレームワークが当たり前になったこの時代でDirectXを扱うのはゲーム開発者の中でもゲームエンジンやフレームワークを作る極一部の技術者だけになってしまいました。そちらを目指されるのであればDirectX11をされたほうが良いと思います。
失礼しました。 先に回答したのは読み込みです。勘違いしておりました。 作成に関しては調べていなかったので作成できるかも覚えていません。。
たとえば、ご質問のコードだと ・プロトタイプを削除して ・関数呼び出しを modori = kansuu(2.0); （引数が、2.0 になっている点に注意） とするだけで、予期しないことが発生します。 （プロトタイプがあれば、とりあえず、思った通りの結果にはなります）
特定のOS、特定の言語に限ったことではないですが、 一般に、closeすると出力バッファにあるものを送ってからプログラム終了となりますが、 closeしないと出力バッファにたまっているデータが送られないまま プログラムが終了してしまうものがあるためです。
一応それっぽく動くだけなら、if(GetTouch(CH_2) == 1){ ... の処理を while(GetSensor(CH_3) > kuro); /* 入力ポート3ライトセンサーが ... のループの中に入れれば動きそうです。 ただし、このやり方ではもう少し複雑な動きをさせようとすると途端に破綻します。 ソースを書く前に、例えば状態遷移図などを使って動作を設計する手法を覚える必要があるでしょう。
write.zip自体に「write」フォルダが作成されているのでは無く、zipの展開に使っているソフトが「write」フォルダを生成しているように思えます。 使用しているソフトによっては「アーカイブ名でフォルダを作成」のようなオプションがある場合があるので、そのチェックを外すとフォルダは作られなくなるはずですよ。 zipファイル自体にフォルダが含まれているかどうかは、zipファイルをエクスプローラーなどで開くと確認できると思います。
. main(){ こんな書き方、最近ではやりません。 ○参考にしたものがとても古い ○主目的が別にあり(ゲームプログラミング入門とか、数値解析とか)C言語はオマケ程度にしか解説していない のどちらかではないかと。 前者なら、それのことは忘れて、新しい本を買ってください。 後者なら、内容だけを参考にして、C言語は別の本を買って勉強してください。 > 変数iの有効範囲 「スコープ」といいます。 とても大事なことです。 ちゃんとした解説書で勉強してください。 このプログラムでは、あまり理解の助けにならないでしょう。
文章を読む限り「ファイルに必ず反映させたいのだったらmsyncを使え。」という事だと思いますが。 頻度や発生条件などカーネルのバージョンやシステムパラメータの設定によって変わるかもしれませんし。
○コメントが少ない 　何が目的で、どんな考えでこう書いてあるのか、よくわかりません。 　よくわからないので、改善点の提案もできません。 　例えば if(GetSensor(CH_3) > kuro){ ですが。 　kuro と判定してるので、黒かどうかを判定していることは予想できます。 　ですが、この判定は 黒のときTrueなのか、黒でないときTrueなのか、どちらの意味かがわかりません。 ○同じ処理を何度も書いている 　「同じことを3度書いたら、マクロか関数にしろ」という格言があります。 　例えば、何度も出てくる GetSensor(CH_3) > kuro)ですが、この判定をマクロや関数にして 　if ( isBlack() ) (もしかしたらはisWhite?) 等と書けば、次のメリットがあります。 　・文字が減らせる。 　・意味がわかる。→コメント代りになる 　　　さらに抽象的にして onLine() (線上にいる) 等とすると、何を意味するかがはっきりする 　・判定方法が変わっても、一箇所直すだけで全体に反映させることができる 　　　例えば、 精度向上のためにセンサーを増やして、複合的に判定させようとします。 　　　「CH_3のセンサーが>kuro かつ CH_4のセンサーが<kuro」になったとして現状どこを変更すればいいか、わかりますか? ○main関数に全部の処理を書く 　mainプログラムには、全体の流れだけを書くようにします。 int main(){ 　while(1) { // メインループ 　　動作スイッチ待ち(); 　　if ( 交差点 ) { 　　　前回曲った方向記録 = 曲がる(前回曲った方向記録) ; 　　} else { 　　　直進する(); 　　} 　} } // さっき曲がった方向を指定→実際に曲った方向を返す関数 左右記録型 曲がる(さっき曲がった方向) { 　　if ( さっき曲がった方向=左 ) { 　　　左に曲がる(); 　　　return 左; 　　} else { 　　　右に曲がる(); 　　　return 左; 　　} } あってるかどうかわかりませんが、例えば、こんな感じになると思います。 これだと、何をしているか、よくわかるのではないでしょうか。
ちらつきが発生する原因は、おそらくですが背景の消去を行っているためではないかと思います。 InvalidateRect() の bErase パラメータに TRUE を指定していませんか？ 蛇足かもしれませんが、ちらつきがなぜ発生するかというと、画面に表示するためのスクリーンのDBに対して、異なる内容の描画が複数回行われるためです。 たとえばなにかグラフのような物を描画するとした場合、「背景消去」→「枠描画」→「グリッド線描画」→「グラフ線描画」などの複数ステップで描画内容を構築すると思いますが、この処理の途中が画面上で目に見えるのがちらつきになります。 毎回、1回のBitBltだけを行って全面を上書き描画だけしていればちらつきは防げます。 ですので、描画画像とサイズが固定だとすれば、背景消去無しでこの例でいうhdc_mem1を直接Bltするだけでも事足ります。 ダブルバッファを利用する目的は、No.1にてmyuki1232 さんがすでに回答されている通りですが、WM_PAINの処理で1度だけBitBltを行うためです。 通常、たとえばユーザ操作などによって描画の内容が変化する場合にメモリDCへの描画を行ってInvalidateRect()を行い、 WM_PAINTでは描画済みのメモリDC内容をスクリーンDC(BeginPaintのDC)への転送のみを行います。 これにより、 ・描画処理は必要な場合にメモリDCへ行うだけとなり、必要最低限の回数で済む。 ・メモリDCからスクリーンDCへ転送するだけで済むので、WM_PAINTが高速になる。 ・複数ステップの描画を画面上に現れないメモリDC上で済ませておくので(スクリーンへは上書き転送だけなので)ちらつきが抑止できる。 ということになるわけです。 さらに蛇足で、この質問の件とはあまり関係しないとは思いますが、ゲームや動画表示と言ったような高速で描画内容が変化する必要のあるアプリの場合には、このままの手法ではうまくいきませんし「ティアリング」といった別の問題も生じてきます。 それらについては、また必要となったときに調べてみてください。
T1/T2 演算を行う際に、T1とT2のどちらかが実数であれば演算は実数で行われる。 T1,T2の両方が整数の場合、演算は整数で行われる。 キャストが付いてるか付いてないか、関数の中か外かの問題ではなく演算自体がどの型で行われるかの違いです。 リテラルで考えると分かりやすくて 1/i は整数で演算が行われ i>1 なら必ず0になる。 1.0/i は実数で演算が行われるので 0 にならない。 実数どうし、整数どうしの場合は演算はより精度の高いほうの型で行われます。 ※実行結果の格納は別の問題です。 この辺りはコンパイラの作りの問題に近いので「コンパイラの作り方」みたいな本を参考にされたほうが理解が早いかもしれません。
「『ループ端によるフローチャート』だぁ? 何寝言言ってんだおまえ」 と言われるのがオチじゃないかなぁ＞#1. フローチャートで書く前に, このアルゴリズムが何をしているのか日本語で手順を書いてみるといいよ.
端子 要素 ループ始端 判断 要素 ループ終端 端子
どこが弱点か分からないなら、コードリーディングもひとつの手です。 難易度高いですがboostのソースコードを読んでみるなど。 あるいは、実装の応用編ですがstd系のライブラリを自分で実装してみるとか。 そうすれば出来無い事や分からないことが見えてくると思います。 ただ、boostやstdは結構難しいことをしているので今の時点で出来なくても徐々に出来るようになれば良い程度ですので焦らないように。
>strftimeで得た時刻をファイル名にする場合はどのように行えばよいのでしょうか？ 普通に文字列に変換できるのですから、そのまま文字列処理すればいいのではないですかね？ char filename[200]; strftime(filename, sizeof(filename), "~/TemperatureSensorLog_%y%%m%d-%H%M%S.txt", tm); みたいな感じで処理できるかと。 # パス名とかは自分で設定して下さいな。
関数プロトタイプに、変数名を伴った引数並びがある場合、それは、「変数の定義」と見なされます。 （関数プロトタイプ自体は、実体を伴わない「宣言」なのですけど） そして、同一スコープ（ある変数が有効な範囲）に、「同じ変数は複数定義できない」と言うことになっています。（文法上、引数の方は、実体があると見なされるため） こんなわけで、関数プロトタイプの、仮引数並びに同じ変数名を指定することはできないことになっています。
sum + a[i]じゃねえの
何を教わりたいの？
間違っちゃいないけど、直に const string でかまわんのでは? #include <iostream> #include <string> const std::string STR1 = "mojiretu"; bool even_length(const std::string& str) { return str.length() % 2 == 0; } int main() { if ( even_length(STR1) ) { std::cout << STR1 << " : even\n"; } else { std::cout << STR1 << " : odd\n"; } }
いま確認できる環境がありませんが。 WNDPROC (*finc[])() だと 『「WNDPROC 名前()というプロトタイプの関数」へのポインタ』の配列 である、配列fincの宣言になります。 よって、fincの各要素(finc[0],finc[1]...)は「引数無し、戻り値WNDPROCの関数へのポインタ」です。 それを、(WNDPROC)WndProcA,等と、WNDPROC型で初期化しようとしています。 「引数無し、戻り値WNDPROCの関数へのポインタ」 と 「WNDPROC型」は別のものでは? まずは、具体的にどんなエラーメッセージになっているか、書いてください。 「WNDPROCはWNDPROC (*)()に変換できない」とかいうものではないですか?
うーん、これだけでは何とも言えません。 shader が 0 になった時の glGetError() の値がわかればいいのですが……。 https://www.khronos.org/opengles/sdk/docs/man31/ …
in を close() するタイミングが遅すぎますし、out を生成するタイミングも早すぎます。 これを変えた後で、in の生成で指定しているファイルと out の生成で指定しているファイルを同一にすればお望みの動作となります。
お作りになっているソフトのプラットフォームは何でしょう？ MFCならば DDX_Radioを使うといった手があります ラジオボタンのGruupプロパティをTrueにしたコントロールに対してメンバー変数を追加します このとき 変数の型を intにして 変数の種類をControlからValueに変更します これで メンバー変数が 0ならば1番目、1ならば2番目 といった具合の対応になります ダイアログの状態を変数に反映するには UpdateData(FALSE); を実行 逆に 変数の状態をダイアログに反映するには UpdateData(TRUE); を実行します 別のプラットホーム(Win32や C++/CLI)ならば その旨の返信をお願いします
>将来の拡張性も考慮すると、これを採用したいと思い(例16F1508:4ch, 18F1230: 6ch等）、お言葉に甘え絞った質問をお許し下さい。 ポイントを絞ったではなく丸投げそのままな気がしますが。 結局の所「どのようにプログラムを書いていいのかわからないので私の代わりに書いてください」でしょ？
普通はシリアルポートの読み書きをする関数なら、データを受信してそれが受信バッファに書き込まれた時にイベントが発生するので、そのイベントの処理の中で受信バッファを読みに行くわけでしょ？バッファサイズが1KBだから、一度に読み込めるデータは最大でも1KBと言うことになり、欲しいデータの190011Byteに対してバッファの方が小さい、すなわち受信イベントの処理は何度も発生することになります。 イベントが発生した時、受信バッファに入っているデータ量は1KB以下の不定な量（受信処理が十分に早ければバッファの半分も行かないはず）であり、読み取り関数で読むと実際に読めた量を教えてくれるか、違う関数でバッファに入ってるデータ量を調べ、その分だけ読み取り関数で引っ張ってくるか、まあその辺でしょう。そうやって必要なデータを複数回に分けて読み込みます。 もし読み取りが間に合わないと受信バッファオーバーフローで例外が発生するから、その場合は相手方に再送要求を送るなり、後続のデータ列を読み捨て続けるなりして、次に備えます。オーバーフローが頻発するんだったら受信バッファを大きくするか、処理を見直すか…
>愚痴ばかりですみませんが何か具体的にこうすればいいというのはありますか？ あなたが「これ(を理解するの)は難しい」と思って避けてる事をする。 とりあえず書いておくと非同期プログラムは職業プログラマ誰でもできるというわけじゃないです。
Eigen は使ったことはありませんが、公式サイトを見ると、 > We use the CMake build system, but only to build the documentation and unit-tests, and to automate installation. If you just want to use Eigen, you can use the header files right away. There is no binary library to link to, and no configured header file. Eigen is a pure template library defined in the headers. （意訳）単に Eigen を使用するだけなら、ヘッダファイルをインクルードするだけでよい。何かをリンクする必要はない。CMake はドキュメント、ユニットテスト、自動インストールのためだけに用意している。 とあります。 Qt のバージョンうんぬんは、おそらく Qt から使用する場合の自動テストをビルドしようとしているのではないかと思います。 参考URL：http://eigen.tuxfamily.org/index.php?title=Main_ …
MSVCはMicrosoft Visual C++の事であってVisual Studioでは有りません。 (VSがVCを含む) MSVCの「バージョン12」が「製品名2013」です。 http://ja.wikipedia.org/wiki/Microsoft_Visual_C% … WindowsだってWindows7のバージョンは6.1です。 製品の名前とバージョンは連動しません。
どうもすみません、回答 #2 の中に恥ずかしいミスがありました。 #ifndef _NEWLIB は #ifdef _NEWLIB の間違いです。 上記間違いのままだと、新しいライブラリ B を使うために _NEWLIB を付けると古いライブラリ A を参照し、前のを使おうと _NEWLIB 無しにすると新しい方を使うという正反対の結果となってしまいました。 お手数をおかけして申し訳ありませんでした。
ご推察の通り，隣接する間接点を選び，3点の座標を用いて角度を求めます。 "余弦定理"を用いれば，角度は求められますね。 そのようなコードを C++ で書けばよいわけです。 OpenGL は分からなくても問題ないですよ。
この問題に対してやらないといけないことは 　1. CSV から座標データを読み込む 　2. 座標データを使って骨格を描画する ことだと思います。 1 は C++ の仕事なので，OpenGL は関係ありません。 適当にコードを書いて読み込んでください。 2 で問題となるのは，どのような骨格を描画するかということになりますが， OpenGL に詳しくないということなので，とりあえず直線を引いてはどうでしょうか？ 座標は読み込みができているので，"座標を使って直線を引く"ということを OpenGL で行うわけです。 これに関しては OpenGL の基本的な機能で実装可能です。 とりあえず，簡単な例で作成してみて， 慣れてきたら骨格の描画などに凝ってみてはいかがですか。
まずは、Releaseモードに切り替えましょう。Debugとか論外でしょ。 あと、 http://kidd0320.hatenablog.com/entry/2014/06/06/ … 上記を参考に、「ランタイムライブラリ」を「DLL」の記載が無いものに切り替えましょう。
そうではありません。 x=x+23 ということは、現在のxに+23したものが、次のxになります。 iの変化が、i=i+1だけだとすると ループ開始 　x=0 終了直前 　i=i+1 /* i=1+1=2 になる */ forの式3の評価 　x=x+11*(i-1)+1 　/* x= 0 + 11*(2-1)+1 =0+12=12になる */ 次のループ開始 　x=12 終了直前 　i=i+1 /* i=2+1=3 になる */ forの式3の評価 　x=x+11*(i-1)+1 　/* x= 12 + 11*(3-1)+1 =12+23=35になる */ ... となっています。 よく見たら、いろいろと間違ってますね。 cvSetImageROI(dst_img, cvRect(y, x, 11, 11)); は、 dst_img の 横y,縦xの位置から11x11のROIを設定して、以降、cvClomeImage(dst_img)等としたときに、dst_imgが、そのROIで指定した範囲だけの画像のように扱われる、というものです。 2回目では、x=12なので「 dst_img = cvCreateImage(cvSize(12, 12), IPL_DEPTH_8U, 1); で確保した 12x12(横0～11,縦0～11)の画像dst_img」の 座標(0,12)から11x11画素を抜き出した画像、という意味になるので、エラーになるのも当り前です。
まず変化前選択状況を格納する vector なり list なり配列なりを用意して、 OnSelChange() で今の選択状況と変化前選択状況を比較して増えた分を変化前選択状況の後方に追加。 選択順の項目番号ががほしい場合は変化前選択状況を見る。 ……という感じでできるんじゃないかなぁ。もちろん逆に選択数が減った場合とか選択のクリア機能を追加する 場合とかはその処理を考えなきゃならないけど。
こんにちは ドキュメントを読みましたか？ flat propertyで表示できるようですね。 http://qt-project.org/doc/qt-5/qgroupbox.html#fl … -上記urlより引用--------------- flat : bool This property holds whether the group box is painted flat or has a frame. A group box usually consists of a surrounding frame with a title at the top. If this property is enabled, only the top part of the frame is drawn in most styles; otherwise, the whole frame is drawn. ---------------------------------------------- Group Box Example http://qt-project.org/doc/qt-5/qtwidgets-widgets …
>もしかして何もしなくていいのかな、、、というところです。 >ホントですかね？？？ Windows の場合は、アプリでは何もしなくてよいことも多いですよ。 ただし、Windows では整数型のサイズが変わらないので、 動きますけど、32ビットの制限がそのまま残ったりします。
input_fileの配列数と文字数はあってますか？
作成中のCSのプロジェクトに MFC/非MFCのDLLとPDBを追加します ファイル > 追加 > 既存の項目 で 追加したファイルのプロパティの 出力ディレクトリーへコピーを常にコピー(または新しい場合はコピー) に設定します これで CSのbin\debug にDLLファイルがコピーされます MFC/非MFCで手順は変わりないと思いますよ …
タイトルが２の倍数となっていたので、１００個の数値（５０ペア）の双方が偶数のケースを拾い出す形で記述してみました。 取りあえず　数値を入力してTRUE, FALSEを返す関数 funcA()　は、２の倍数ならTRUEという形にしてあります。 参考にしてみてください。 #include <stdio.h> typedef enum _boolean { FALSE, TRUE } boolean; #defineRW50 #defineCL2 booleanfuncA( int a ) { if ( (a % 2) == 0 ) return( TRUE); else return( FALSE ); } void main( void ) { inti,j,n; intnm; intdata[RW][CL]; intresult[RW][CL]; for ( i = 0; i < RW ; i++ ) { for( j = 0; j < CL ; j++ ) { printf( "input data[%#d][%d] =?", i,j ); scanf( "%d", &data[i][j]); } } n = 0; for ( i = 0; i < RW; i++ ) { if ( funcA( data[i][0] ) && funcA( data[i][1] ) ) { result[ n ][0] = data[ i ][0]; result[ n ][1] = data[ i ][1]; n++; } } printf( "Number = %d\n",n ); for ( i=0; i < n ; i++ ) { printf( "result[ %#d ] = %d,%d\n", i,result[i][0],result[i][1] ); } }
コピーコンストラクタをConfigに作ればいいかと Copyメソッドを作るのであれば 引数を ref引数にするとか … // コピーコンストラクタ public Config(ref Config src) { 　　this.H = src.H; 　　this.V = src.V; } // ref引数の Copyメソッド … public void Copy(ref src) { 　　src.H = this.H; 　　src.V = this.V; } といった具合で …
たぶん正確な文言は 「キャストしてください」 ではないと思うが.... さておき, よしんばそういうメッセージだったとしてもそれは キャストすればプログラマの思った通りの結果が得られる と言っているわけじゃないだろう. つまり「キャストしてごまかすのではなく『キャストしなくてもいい』ように変更する」のが正解だと思われる.
自分で探させましょう。それが出来ないようではすぐに挫折します。 質問も自分でさせてほうが良いです。 ちなみに、私見ながらC++はVisualBasicの数百倍難易度が高いのでVisualBasicが太刀打ち出来ないなら到底無理です。
例えば、次のような足し算をする簡単な関数があったとします。 int sum(int lhs, int rhs) { 　return lhs + rhs; } ここで、処理の部分に当たるのは、大括弧で囲まれた｛～｝の部分になります。 この関数のプロトタイプ宣言は、次のように書くことになります。 int sum(int lhs, int rhs); ちなみに、プロトタイプ宣言では引数の型が分かれば良く、引き数名を付ける必要はありません。 つまり、次のようなプロトタイプ宣言でもOKになります。 int sum(int, int);
以下の2点の補足をお願いします。 (1) 「最初の#includeのところがペーストしてもエラーが出ます」とのことですがそのエラーメッセージには何と書いてありますか? エラーメッセージをそのままコピー&ペーストしてください。 (2) あなたが参考にしているページは以下の URL だと思うのですが、その 2.3「Windows 系 OS にインストールする」の手順は実行しましたか? http://www.wakayama-u.ac.jp/~tokoi/opengl/libglu …
そもそも、「ある特定の番地」をポインタにセットする、「標準的な」方法はありません。 規格上では、ポインタはポインタであって、必ずしも整数型による、番地表現と互換性があるわけではないので。 で、「規格」と「実装」という区別になるのですが、 ・ぶっちゃけ、普通に使われるマイコンは、ポインタに、整数定数０を代入すると、０番地を意味するようになるケースが、かなり多いです。 ※組み込みの場合、アセンブラレベルで確認するでしょうし。 ・実は、「整数定数0」と回りくどい言い方をしていますが、int 型の 変数に代入された値 0 は、「整数定数」ではありません。 　なので、 int adr = 0; char *p; p = adr; で、p がゼロ番地をポイントする可能性は高いです。 ※ただし、上述したように、整数型をポインタに代入することの結果は、一般的には決定されません。 こんなところでしょうか。
改行コードもそうですが、EUCとShift-JISの対応は大丈夫ですか? こちらも気を付けないと思わぬ不具合に遭遇します(いわゆるダメ文字とか) Cでやらなければいけない積極的な理由が無いのなら、Perlとか使った方が楽だと思います。
WDK使ったことはありませんが……。 Ws2tcpip.hのinet_pton()のプロトタイプ宣言周辺を見ると… >#if (NTDDI_VERSION >= NTDDI_VISTA) >WINSOCK_API_LINKAGE >INT >WSAAPI >inet_pton( となっています。 NTDDI_VERSIONの設定次第で、後のプロトタイプ宣言は無効になるワケで……。 NTDDI_VERSIONはどう設定されています？ http://msdn.microsoft.com/ja-jp/library/windows/ … http://k639.blog121.fc2.com/blog-entry-46.html
改行コードだとBEだと 00 00 00 0a LEだと 0a 00 00 00 だと思うんですが。 質問でいわれている改行コードは復帰も含むんでしょうか。
呼び出す際にはそれほど特別なことは行いません(何を以って「特別」なのかが分かりませんが、通信を行うプログラムとしては普通です)。 前回の参照URLに書いてあるように、 1. カーネルを起動して接続 2. カーネルにデータ(パケット)を送って計算させる 3. 返されたデータ(パケット)を処理する 4. 最後は接続を閉じて終了 という流れです。 呼び出す時よりも、コンパイルやリンクする際にヘッダファイルやライブラリを自分の環境に合わせて準備しておく必要がありますので、ちょっと面倒です。 幸い日本語のドキュメントがありますので、一通りお読みになることをおすすめします。 参考URL：http://reference.wolfram.com/language/tutorial/W …
// 被積分関数(積分したい任意の関数、以下を書き換える) double myFunction( double x , double y ) { double ans=0.0 ; ans = x * x + y * y ; return ans ; } // 積分を処理する関数 double myIntegral( double x_ini , // xの積分区間の最小値 double x_fin , // xの積分区間の最大値 double y_ini , // yの積分区間の最小値 double y_fin , // yの積分区間の最大値 double x_devN , // xの積分の分割数 double y_devN , // yの積分の分割数 double (*fnc)( double x , double y ) // 積分する関数 ) { double ss=0.0 ; // 積分値を保存する変数 double xx=0.0 , yy=0.0 ; // xとyのループ変数 double dx=(x_fin-x_ini)/x_devN ; // 積分の微小区間 double dy=(y_fin-y_ini)/y_devN ; // 積分の微小区間 for( xx=x_ini ; xx<=x_fin ; xx+=dx ) { for( yy=y_ini ; yy<=y_fin ; yy+=dx ) { ss = ss + dx * dy * ( fnc(xx,yy) + fnc(xx+dx,yy) + fnc(xx,yy+dy) + fnc(xx+dx,yy+dy) ) / 4 ; } } return ss ; }
Ｃ＃は、Ｃの流れをくんでいますので、いずれも可能です。
#2 に基づいて実装してみた(string使用) #include <iostream> #include <fstream> #include <map> #include <algorithm> #include <string> /* --- foo.txt apple banana cherry grape orange */ using namespace std; int main() { map<string,string> dic; { string word; string key; ifstream stream("foo.txt"); while ( stream >> word ) { key = word; sort(key.begin(), key.end()); dic[key] = word; } } string inputs[] = { "allep", "nanaba", "rryche", "peach" }; for ( int i = 0; i < 4; ++i ) { string word = inputs[i]; string key = word; sort(key.begin(), key.end()); cout << word << " -> "; auto iter = dic.find(key); if ( iter != dic.end() ) { cout << iter->second << endl; } else { cout << "???" << endl; } } } --- 実行結果(Visual C++ 2013: vc12) --- allep -> ??? nanaba -> banana rryche -> cherry peach -> ???
リソースにVERSIONを追加して その中の ProductVersionを希望の内容に変更してやればいいようです 取得方法 String^ ss = Application::ProductVersion;
>visual stdio 2013では、ファイルが開けませんとなり、途中で、終了してしまうのですが、 >mingwでは、ちゃんとファイルが開けて、プログラムが、最後まで動作するのですが、なぜでしょうか? こういう時の「お約束」ですが… 『カレントディレクトリ』って言葉は知っていますか？ フルパスで指定していないので、カレントディレクトリからの相対パスになります。 その際にカレントディレクトリが何処なのか…と言うことを意識しないと、 「ファイルはあるはずなのにオープンに失敗する」ということになります。 オープンに失敗しているのであると思っているファイルは「カレントディレクトリから見ると」無いんですよ。 Visual Studioなら、プロジェクトの設定でカレントディレクトリ(作業ディレクトリとか書かれているかもしれない)を設定できます。
sizeof演算子は、アライメントが加味された値を返すのではありませんでしたか？＞#7. > 何度もありがとうございます。よろしければ、問題点を具体的に指摘して下さいませんか。 以下のページの説明とかどうでしょう。 C言語-ポインタとメモリと型（構造体）の関係 (2) http://www.mm2d.net/c/c-15.shtml
こんにちは QTを触ったのははるか昔で、かつ、QT Designerも使用したことが無いので外したらゴメンナサイ。 メインフォームの隙間にフォームAとして、QStackedLayoutか、QStackedWidgetを配置。 フォームBやC（と非表示ということで何もないフォームDも必要？）をQWidgetで作成して、 A.addWidget()でB,C,Dをスタックに追加。 A.setCurrentIndexで切り替えを行うと良いのではないでしょか？ 参考URL：http://qt-project.org/doc/qt-5/classes.html
ProgressBarを操作したいとなると Mainクラス側の処理関数に BackgroundWorker型とDoEventArgs型を引き渡してやる必要がありそうです BackgroundWorkerは中断処理と ReportProgressメソッドを使うため DoEventArgsは中断処理のCancelフラグを設定するためです funcを void Main::func(BackgroundWoker^ worker, DoEventArgs^ e) { ... do while( funcの終了条件 ) ... { ... ... if ( worker->CancellationPending ) { ... ... ... e->Cancel = true; ... ... ... break; ... ... } ... ... // 重い処理 ... } } といった具合になりそうです あと BackGroundWorkerのWorkerReportProgressとWorkerSupportCancellationをtrueに設定し ProgressChangedイベントをForm側に設置しましょう また RunWorkComplatedも実装したほうがいいでしょう …
// たびたび王次郎です struct str{ char *name[2] ; } ; static struct str state_ab[4] = { { "いちご" , "" } , { "みかん" , "" } , { "レモン" , "" } , { "ブドウ" , "" } , } ; static struct str state_ab2[8] = { { "きゅうり" , "" } , { "セロリ" , "" } , { "じゃがいも" , "" } , { "にんじん" , "" } , { "たまねぎ" , "" } , { "ニンニク" , "" } , { "レタス" , "" } , { "キャベツ" , "" } , } ; static struct str state_ab3[4] = { { "牛肉" , "" } , { "豚肉" , "" } , { "鶏肉" , "" } , { "魚肉" , "" } , } ; // その１：str配列の先頭アドレスをpに渡す char *state_ab_f_read_1( int mode , int num1 , int num2 ){ struct str *p=NULL ; switch( mode ){ case 0: p = state_ab ; break; case 1: p = state_ab2 ; break; case 2: p = state_ab3 ; break; } return p[num1].name[num2] ; } // その２：strのアドレスをpに渡す char *state_ab_f_read_2( int mode , int num1 , int num2 ){ struct str *p=NULL ; switch( mode ){ case 0: p = &state_ab[num1] ; break; case 1: p = &state_ab2[num1] ; break; case 2: p = &state_ab3[num1] ; break; } return p->name[num2] ; } // もし、num1 と num2 の使い方が逆の場合は入れ替えてください // 以上
＞(1)プロジェクトのプロパティ⇒構成プロパティ⇒C++⇒コマンドライン ここは、他のシートで設定した項目を適用した結果を確認するためのものです。 設定は別のシートで行います。 /FU であれば、下記が該当します。 プロジェクトのプロパティ⇒構成プロパティ⇒C++⇒詳細設定⇒必ず使用する #using 指定ファイル ※各シートの項目をクリックすると下部にスイッチ名と説明が表示されます。 ＞(2)ソリューションエクスフローラ⇒Setup⇒見つかった依存関係 これは、コンパイラがみつけてくれた（自動検出した）依存関係なので、 ソースとかリンクしているライブラリとかから、DLLの依存関係を調べる必要があります。 たとえば、ソースに下記があれば、urlmon.dll とリンクされます。 #pragma comment( lib , "urlmon.lib" ) DLL の依存関係について調べたい場合、 Dependency Waliker などで調べることができます。
Image Mastering API (Windows) http://msdn.microsoft.com/en-us/library/windows/ … とか。
記述するイベント箇所は、Form.Deactivateでしょう。
その「洋書のSTLの本」で generic algorithm をどう使っているかわからないと, なんとも言いようがない. 特定のアルゴリズム (群) をさして「generic algorithm」 と言っているのかもしれんし, 単純に「一般性のあるアルゴリズム」という意味で使っているのかもしれんし.
該当サイトの一番上の注意書きにあるとおり，現在の.NET環境であればBackgroundWorkerを使うように修正してください。 http://dobon.net/vb/dotnet/programing/progressdi … キャンセルを確認するのはワーカー側の責務です。 というのは，安全に処理を中断するタイミングで中断を開始しないと， データが壊れる等の問題が起きる可能性があり， それを判断できるのは処理を実行しているワーカー側だけだからです。 キャンセルの確認の回数を増やせば，処理中断までの時間は短くなります。 どの程度の時間を許容できるかによって，キャンセルの確認回数を増やすことになるかと想います。
http://msdn.microsoft.com/en-us/library/system.t … サンプル: http://ideone.com/3H31Tf #intはSystem.Int32のC#での呼び名。 #stringはSystem.StringのC#での呼び名。
MoveToは画像を動かすためのものではなく、線などを書き出す位置を移動するために使用します。 pDC->MoveTo(0,0); // 書き出し位置を(0,0)に設定 pDC->LineTo(100,100); // 書き出し位置(0,0)から(100,100)に線を引く 書き出し位置も(100,100)に移動する pDC->LineTo(100,0); // 書き出し位置(100,100)から(100,0)に線を引く 書き出し位置も(100,0)に移動する pDC->MoveTo(100,100); // 書き出し位置を(100,100)に設定 pDC->LineTo(0,100); // 書き出し位置(100,100)から(0,100)に線を引く 書き出し位置も(0,100)に移動する といった形で使用します。書き出し位置は基本的に前回の描画が終了した位置なので、それでは困る場合に移動する必要があります。 描画されている内容を移動するものとして、ScrollWindow(Ex)がありますが、Windowsの描画の仕組みをよく知らないとうまく使えないです。 ちらつきは、WM_ERASEBKGNDメッセージで背景を塗りつぶしたあとで、描画の処理に入ってくるからではないでしょうか。そうであれば、WM_ERASEBKGNDのハンドラとしてOnEraseBkgndを作成して、何も処理せずに戻るようにすれば解決すると思います。
下記に具体的な方法が載っています。 http://l.inolv.jp/2013/02/27/disable-and-enable- … ただし、文字列の区切りが違っています(半角のダブルクオートです)。 無効化（disabled） netsh interface set interface "ローカル エリア接続" disabled 有効化（enabled） netsh interface set interface "ローカル エリア接続" enabled 「ローカルエリア接続」の箇所は、「ipconfig /all」で「イーサネット アダプター」の後にかかれています。例えば「イーサネット アダプター イーサネット:」であれば「イーサネット」です。
>putchar('¥n')をなくすと、すべての値が同じ列になってしまいます putchar('\n')が何をしてるのか理解されていますか？
どうも、intellisenseの「仕様」のようです。 ※ intellisenseは、入力時に候補を選ばせたりするやつです。 手許のVS2010で試したところ #if 0 #endif class TestClass {}; int main(void) { return (0); } という意味の無い#if～#endifを入れてもエラーは消えました。 「蛇足」部分について、検索したら同様のことがありました。 http://tanjoin.hatenablog.com/entry/20121213/135 …
>変数iの宣言は >old_val = [i]; >こんな感じでしょうか？ 普通に int i; です。 ChgFlagも同様です。 >>というか…掲示されたコードだとloop()の中身は >>>DateTime now = RTC.now(); >>だけですが、よろしいので？ >File dataFile = SD.open("datalog.txt", FILE_WRITE); >これが、要らないのでしょうか・・・ 「{」と「}」の対応がヘンだから、loop()の内容がそのコード「しか」ないですよ。 という指摘だったんですが…。 >これは、書き込むフォーム（形）と認識していますが、合っていますでしょうか。 一応合っていますが、空白の位置が最初の想定と違います。 まぁ、動かせば判ると思いますが。 # コンパイルエラーを直した上で。 >このスケッチは変化が有った時に状態を書き込むスケッチと認識していますが如何でしょう。 変化を検出して、書き込み用の判定をしています。 とりあえず、別の掲示板に移動したみたいなので私の回答はここまでですかね。 あちらにIDとか持っていませんし。 # あと、あちらの掲示板の書き込みルールには従いましょうね。 # 常連さんから指摘されると思いますが。 参考URL：http://dixq.net/forum/viewtopic.php?f=3&t=15753
4x1 X 4x4 は数学でも計算できませんから。 目的によっては、 ・4x1を転置した1x4 を使う。 ・4x4 X 4x1 で計算する でいいのかもしれませんが、それぞれ違う結果になるので、どちらが求めるものか、あるいは、どちらも違うのか、判断できません。
まぁリリースするときに云々というのはANo1の方が回答されているので、もう少し質問部分を細かく解説していきましょー。 objとbinって何？　どう違うの？　という点について。 objというのはプログラムをビルドする途中の中間ファイルが保存される場所で、binがビルド後の成果が保存される場所だ。 なので、objとbinならどっち？　という事なら、binの中身がリリースすべき（＝Visual Studioが入ってないよそのパソコンに持っていくべき）ものという事になる。 とりあーえず、バッチビルドという機能を使ってデバッグビルドとリリースビルドをどっかんどっかんやってみたらこれまた色んな場所にexeが出来上がるのでそのファイルサイズを見比べてみるといいだろう。
>お薦めの「C++」の入門書をご存じでしたら C++は私もちゃんと習得していませんからねぇ。 なんとなくで読めるけど自分でコード書けるほどじゃないし。 で、書籍に関しては……大きめな本屋に行って数冊の内容を立ち読みで確認し、 自分に合っていそうだな。 と思われる本を2～3冊購入してみる。 としか言えませんね。 なかには今回のような標準関数の扱いについてあやしいものもあるかも知れませんし。 そういう意味でも複数。ある程度身についたら別系統のもの…とか。 # ちなみに私は機能逆引き系とかそういうの好む傾向がありますな。 # C#でこういう機能を実装したいときのコーディング例…とか、こういうコード書くとこんな問題がある…とか。 そこそこ評価のよい著者のものを購入する。ということもありますかね。 # アマゾンとかのユーザレビューも参考になるかも知れません。(ただし、全部が信頼できるレビューというワケでもない場合があるので割り引いて読んだ方がいいかもしれませんが) 安い買い物でもないし。 # 1000円以下だと疑って掛かる。1000円～3000円位だと購入検討する。3000円超えると…結構悩む(買うこともあるが)。 # 入門書代わりにムック本を買うことはありますかねぇ。日経ソフトウェアのとか。 他には…言語だけでなく環境に関する理解なんかも必要かも知れませんね。 「ファイルはあるのにオープンできないのはなんで？」「カレントディレクトリってなんのこと？」「相対パスってなに？」 とか、ツッコミどころあるような理解だとどうにもなりませんし。 あとは、統合開発環境の使い方とか…でしょうかねぇ。 こっちは書籍よりWebで探した方がいいかもしれませんけど。 # Visual StudioならMSのページとかにも載っていたりしますし。 書籍だと突っ込んだ操作方法とか載っていないイメージが。 # 今回のような1ソリューションに複数プロジェクトとか。
EnumWindowsを呼び出す前に BOOL EnumWindows(WNDENUMPROC lpEnumFunc , LPARAM lParam); と言うプロトタイプ宣言が必要です。 このプロトタイプ宣言をし忘れると、EnumWindowsの第一引数の関数の呼び出し規則が__stdcallとなり、宣言と一致しなくなります。 ＞キャストすればよいのかと思い下行のようにしました。 キャストは駄目です。呼び出し規則は変更出来ません。 呼び出し規則を無理矢理にキャストしてしまうと、呼び出し元と呼ばれた関数の整合性が取れなくなり、暴走したり、メモリリークしたり、致命的例外を発生したりしますので、通常はキャストできないようになっています。
＞Windows Formの場合、アプリケーション上に保存といった形を取ることは出来ないのでしょうか？ 出来ません。 ＞もっともexe形式なので、出来ないとは思いますが。 その通り。 やるとすれば、自分で設定用ファイルを用意し、そのファイルに書き込む、などとしなければなりません。 この場合、設定用ファイルをどこに保存するか、が問題になります。 昔は、他のアプリケーションとバッティングしないようにする為、自分自身が居るフォルダに保存していました。 自分自身と同じフォルダに保存する事にすると、実行時に「自分自身が居るフォルダへの、リードライトアクセス権」が必要なので、UACが原因で「exeがある場所でファイルに書き込み出来ない」などの問題を引き起こす可能性があります。 そのため、設定ファイルに保存せず、自分専用のレジストリキーに値を書き込む方法が取られるようになって来ていましたが、実行時にレジストリアクセスの権限を取得する必要が出てきたため、レジストリ保存も既に時代遅れになりつつあります。 最近では、アプリケーションのデータフォルダの位置をシステムに問い合わせして、得たパスに自分専用のファイルをXML型式で作成する、と言うのが主流のようです。 http://element.dip.jp/~hm/memo/windevelop/appdata/ 当然ですが、設定ファイルの読み書き、コントロールのプロパティの読み書きは、自分で実装しないといけません。
ToolStripMenuItemにはClickイベントがありますから，Clickイベントを普通に検出すればよいです。 詳しくはC#の文法書をお読みください。 a) ラムダ式を使ってハンドラを書く openLabel.Click += (_, __) => { MessageBox.Show(this, "Export"); }; deleteLabel.Click += (_, __) => { MessageBox.Show(this, "Import"); }; b) 別途メソッドを用意してハンドラを追加する private openLabel_Click (object sender, EventArgs e) { MessageBox.Show(this, "Export"); } private deleteLabel_Click (object sender, EventArgs e) { MessageBox.Show(this, "Import"); } openLabel.Click += openLabel_Click; deleteLabel.Click += deleteLabel_Click;
こちらで使っている市販コンパイラではベクトル化してもベネフィットはないとメッセージが出てきます。 unrollの最適化はしています。加算していますのでベクトル化は確かにちょっと効果はなさそうに見えます。 関数にして（inlineにはしなくて）遅めのCPUでやってみましたが、1000万回で7秒程度です。 これで遅いのなら、他にも手は有りますが。
手元にある古い規格書 JIS X 3010-1993 には、「配列変数」という単語は出てきません。（最新の規格には出ているかもしれません。） 　「配列変数」という言葉を使って解説しているWebページを見ると、配列名を指しているもの（質問文中のプログラムではsuuretu）と、個々の配列要素（suuretu[0], ..., suuretu[9]、あるいは *suuretu, ..., *(suuretu+9））を指しているものの両方があるようです。 　まともな参考書なら、「配列変数」という用語は使わないでしょうし、もしも使うとしても「ｘｘｘを配列変数いう（ことにする）」という記述があるでしょう。
共有する属性だけをソリューション直下のSharedAssemblyInfo.csに集めて， そのファイルをプロジェクトからリンクする形で取り込む，ということをやったことがあります。 1. [プロジェクト] - [既存項目の追加]と辿り，[既存項目の追加]ダイアログを開く 2. SharedAssemblyInfo.csを選択する 3. [開く]ボタンの右側の三角を押し，[リンクとして追加]を選択する という手順でリンクを追加できます。 SharedAssemblyInfo.csには，AssemblyInfo.csのコードのうち， AssemblyVersionやAssemblyCopyrightなどの属性を移動しておくことになると思います。
private: System::Void button1_Click(System::Object^ sender, System::EventArgs^ e) { int input; if ( Int32::TryParse(textBox1->Text, input) ) { label1->Text = String::Format(L"あなたは {0} を入力しました", input); } else { label1->Text = L"intに変換できませんね..."; } } > 初心者につき、できるだけ噛み砕いて、説明を加えて、回答お願いします。 どこまで砕いていいかわからんので無理。 わからんとこあったら訊けばいいやないの。
math.h のライブラリにある関数を使うには、libm をリンクする必要があるので、gcc のコマンドラインに -lm という指定が必要です。 printf などの関数は、libc に入っており、これは指定しなくても参照されます。 pow(10,-1)で -lm がなくてもエラーにならなかったのは、他の方が書いてますが、コンパイラが結果を計算してしまって実際にpowを呼ぶようなコードを生成しなかったからでしょう。 つまり、printf("%f",pow(10,-1)); が、printf("%f",1e-1); に最適化された。
振幅の最大値を求める計算は、2乗してから1/2乗して正の値で比較するってことは、単純に振幅値がマイナスのときはマイナス1をかけて正の値にして比較すれば良さそうだけど。C言語仕様書なりで数学関数を調べておけば、累乗、平方根を求めるときに使う関数はわかるよね。 まず、振幅の最大値を求める。これは、最大値を代入する変数を用意して、初期値0か負の値で初期化しておいて、一行ずつ読み込んでは比較用の正の値に直した振幅値と比べて読み込んだほうが大きければ最大値用の変数に代入。という繰り返し処理で、ファイルの終わりに到達したら繰り返し処理を終了。 次に、振幅の最大値の２割に達した時間を求める。たぶんぴったり２割という値じゃないときもありそうだから、振幅の最大値の２割以上で最小値になる時間を求めることになるだろう。最小値を求める変数を用意して、振幅の最大値かその変数のデータ型でとりうる最大値で初期化しておいて、ファイルの先頭から一行ずつ読み込んでは、振幅の値が振幅の最大値の２割以上だったら最小値の変数と比較して、最小値の変数の値のほうが大きければ最小値の変数へ代入して更新。並行して、振幅の最大値の２割に達した時間を代入しておく変数の値も更新とともに出力。これをファイルの終わりまで繰り返し。 ひとつの振幅周期しかファイルに記録されていなければ、こんな感じで処理できると思うよ。 構造体、構造体を入れる配列、クイックソートを勉強すると、もっとうまく処理できるプログラムになるだろう。 ほかに細かな注意事項を挙げておくと、変数のデータ型、特に数値データ型は表現できる値の下限値、上限値、オーバーフロー、アンダーフローに注意。また、異なる数値データ型での型変換(cast)で情報落ちしないかに注意。 ファイル操作では、ファイルのオープン、クローズ、読み込み、書き込みのときにエラーが起きたときの処理も追加するのが安全。ファイルを作ったOS 環境とプログラムを動かすOS 環境とで文字コードの違いがないか、改行コードの違いがないか、ファイル先頭のBOM情報に適した処理にしなくてはならないのか注意。エスケープシークエンス文字の使い方にも注意。時間データ値が数値データなのか、文字列データなのか、時間データと振幅データを区切るのはTABコードなのかホワイトスペースなのかなど。 サンプルプログラムはパッと見、arrival 変数が振幅の最大値の２割を超えていればどんどん更新され続けるバグがある。ほかに、sscanf の書式指定で、時間データと振幅データを区切るセパレータ文字列の扱いが抜けているから、正しい振幅データがamp 変数に取り込めていなそう。この辺は、デバッガを使って変数の値をトレースするやり方を身につけるか、デバッグ用のprintfを付け足して確認するのがいいでしょう。
こんな感じ。 確認はしていません。 質問にあるプログラムと、ほとんど同じ（max20 は毎回確認せずに、max * 0.2 で計算していますが）なので、よく確認してください。 おそらく、いくつかの「例題」をそのまま引っ張ってきて、一本にしたのでしょう。 たとえば、 FILE *fp = fopen(fname, "r"); という、「決り文句」が２回（ファイルを２回スキャンする必要があるので）出てきますが、同じ関数の中で、これを二つ書くことはできません。（実は、書く方法もあります） そこで、二番目の FILE *fp = fopen(fname, "r"); のまえに、いつも書いている main() を持ってきたというのは何となくわかります。 エラーが出たときに、「なぜエラーなのか？」を理解せずに「とにかくエラーを消す」という方針で進むと、いずれ困ったことになります。 あと、プログラムの動作を記述する言葉の使い方にも慣れましょう。 > 振幅の２割を超える時間まで読み込み越えた際の時間を 　振幅の最大値の２割を、始めて超えたときの時間　ですね。 -------------- form here ------------------------ #include <stdio.h> int main(void) { const char * fname = "C1rbc1(50,0)sq,almi00001.dat"; char line[BUFSIZ]; double amp, time,arrival, max=0; FILE *fp = fopen(fname, "r"); while (fgets(line, BUFSIZ, fp)) { sscanf(line, "%lf%lf", &time, &amp); if (amp > max) { max = amp; } } fclose(fp); printf("max: %.7lf\n", max); fp=fopen(fname,"r"); while (fgets(line, BUFSIZ, fp)){ sscanf(line,"%lf%lf",&time,&amp); if(amp > max * 0.2){ arrival=time; break; } } fclose(fp); printf("arrival:%.7lf\n",arrival); return 0; }
たとえば、こんなサイトが参考になるかも。 http://www.geocities.co.jp/Playtown-Knight/6845/ … 他にも、似たようなサイトがありますので探してみてください。
ごめんなさい、間違えてますね。 ご指摘の通り、hogehoge.cを実行しようとしています。 hogehoge.exeを実行しにいくために以下のコードで cd $(CURRENT_DIRECTORY) npp_run $(NAME_PART) あとテキストエディタ上では、対話式のプログラムを動作させることができません。ご注意を。 （例）scanf等で文字を入力する等 リダイレクトを使えば入力を扱うことはできますが。
「ラベリング」は画像のサイズを縦横ともに2画素増やして、画像を囲むように外側1画素を「境界」で塗りつぶすと、例外処理が不要になるので、ちょっと幸せになれる（かも）。 ラベリングの具体的な方法は、Webを検索するなり、初級の画像処理の教科書を見れば、たくさん見つかるでしょう。
演算子順位構文解析ですね。演算子の優先順位に基づいた構文解析なので。 なんで順序と書いたんだろう。 >>char str[2][128]={{0}}; >で、全域0x00でクリアされていますので。 たしかにそうですね。 あと、入力でバッファを溢れさせられるというのも気になりますよね。
>>(1)ソートキーはあっています。 ソートキーがあっているなら、DataTableをキー順に読み出せば、思うとおりの順番で読めるはずですけどね。 なお、物理的な順序は、データベースとして扱う場合、どうなるか判らないというか、デタラメになるのが普通です。 >>(2)ユーザー編集可能行とプログラムのみ編集可能行が混合しているので、EditModeを使うかと思います。 「ユーザが保存ファイルを書き換えない保存方法」の意味がちょっと違っていたようですね。 保存したファイルをユーザがダイレクトに書き換えできないようにしたいなら、XMLやCSV形式を使うのは間違いです。 SQLServerやOracle、あるいは、MySQLとかAccessなどのデータベースを使います。
私もエコー系のソフトがオススメ…でしょうかね。 サーバ側は既存のモノ使えると楽なんでしょうけど。 メールチェッカーは私も作りましたが……まともに作ろうと思うと意外に大変だったりします。 まぁ、本文処理しないとか件名やらのデコードはしない。というのであればそれほどハマらないでしょうけど。 # SPAMだとRFC違反なんてふつ～ですわ。 # Content-Type: text/plain; charset="SHIFT_JIS" # Content-Transfer-Encoding: 7bit # ていう、謎のShift-JIS(もちろん本文はそのまま「8」BitのShift-JIS)とか。 # =?ISO-2022-JP?B?なんちゃら?= でデコードすると生Shift-JIS入っててどこがISO-2022-JPなんよ?とか。 # 受け取っている人も多いと思われる、なんちゃら.asiaドメインのSPAMですな。
No.6,12です。 > うっかり if( argv[i][0] = '-' )～ と書いてしまう類のミス > コンパイラはスルーする、ということを肝に銘じて、自己責任で気をつける、というのが正解のようですね。 そういうのは、lintチェック等で誤りやすいパターンを警告する工程を ビルドプロセスの中に組み込んで、毎回自動実施するのが正解だと思います。
聞いたことが無いならまずググるくらいのことはしましょう。 とりあえず入口となるページの URL は載せるけど。 ソフトウェア開発でのかんばん http://ja.wikipedia.org/wiki/%E3%81%8B%E3%82%93% …(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA) リーン開発 http://www.itmedia.co.jp/im/articles/0803/10/new …
ん～と、少なくとも 2 年使う場合はその値段だったらあと 3 万円足してオープンライセンスを買った方がトータルで得だと思いますよ。 http://licenseonline.bbss.co.jp/valumore/?lolcid …
そういう時には、continueです。 #include <stdio.h> #include <stdlib.h> #include <math.h> int main(void){ FILE *fi,*fo; int i; for(i=1;i<=5;i++){ char input_file[32]; sprintf(input_file,"./testin/%d.txt",i); if((fi=fopen(input_file,"r"))==NULL){ puts("Error:Cannot open input file\n"); continue; } printf("input_file=%s\n",input_file); fclose(fi); } return 0; }
MSDN をさらっと眺めただけですが、その TreeView の AfterSelect イベントの中で、SelectedNode.Nodes.Count が 0 か否かで確認できそうに読み取れます。 TreeView.AfterSelect イベント http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.110).aspx TreeView.SelectedNode プロパティ http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.110).aspx TreeNode.Nodes プロパティ http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.110).aspx TreeNodeCollection.Count プロパティ http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.110).aspx
DBを使わないはずなのにDataReaderが出てくる理由がよくわかりません…… http://intd.componentone.com/arJPhelp_Internal_v … ↑のURLあたりのコードをそのまま引っ張ってきたのかもしれませんが、 これはレポートスクリプトに書くコードではなく、本体側(NewActiveReport1側)に書くコードです。 (そもそも、要件的にFetchDataイベントを使うのが適切がどうかも疑問です) このあたりが参考になるかと思います(バージョンは違うので注意)。 http://www.grapecity.com/tools/support/technical …
カーネルのソースがあればいいのかなぁ.
とりあえず、 char fname1[20]; char fname2[20]; にしましょう。 char *fname1; char *fname2; ですと、ポインターが作られるだけで文字列の格納エリアは作られません。
直接の回答とは違うので削除されますかねぇ…。 とりあえず質問者さんからの補足待ちの間ということで。 >なお、メニュー画面にビルドの項目がないんですよね～。 上級者設定になっていないだけと思われます。 [ツール][設定][上級者用の設定]でもろもろ切り替わります。
MultilineをTrueにしてください。
ん～... そこまでできてて, なにで困っているんだろう.... 単純には FILE *gp = popen("gnuplot -persist","w"); fprintf(gp,"set terminal png\n"); fprintf(gp,"set xrange [0:5]\n"); fprintf(gp,"set yrange [0:50]\n"); for (int i = 0; i < てきとうなところ; i++) { char data_file[いくつか]; sprintf(data_file, "out%d.data", i); FILE *data = fopen(data_file, "w"); /* データファイルに出力するところは全部ばっさり省略 */ fclose(data); fprintf(gp, "set output 'out%d.png'\n", i); fprintf(gp,"plot \"%s\"with lines linetype 1 \n", data_file); } pclose(gp); でいいと思うんだが, なにかおかしなところはあるのかな?
終了しますね。＞#12 hogehog12345670000004quit とか入力すると妙な挙動に見えるかも知れませんね。 標準入力に残る関係上しょうもないですかね。 まぁ、エラーケース考えるのは質問者さんに任せるとします。 # 勉強用だとエラー処理とか入っていなかったりとか多いですし。 # fgets()の戻り値もチェックしていなかったなぁ、そういえば…。
補足: #6様。質問が、入力方法に関するものか、その後に整数として入力成功した後の話か分からないので。 '1'があるかどうかだけなら、確かにgetcの方がいいですね。（エラーチェックをする場合でもそうかも。） 入力を信用するならともかく、「もしかしたら、整数以外の入力があるかも」とか「整数入力されてもintの範囲を越えた整数が入力されたら」「複数の入力がある場合」などまで考えるといきなり難しくなりますね（"%d" の書式では対応できなくなる）。まあ、書式指定をマスターすれば、純粋な文字列として入力する分にはscanfの方が柔軟かもしれない。 質問者様がどこで困っているのか、によりますね。 蛇足の部分はこちらも自力で確認しました。
んー、ちょっとわかりません。 ここで聞くより、MSDNフォーラムで聞いた方が、有識者がたくさんいますので、 そちらで質問してみてはいかがでしょうか。 http://social.msdn.microsoft.com/Forums/ja-JP/home カテゴリは Visual Studio Development -> Visual Studio 共通 フォーラム が適切と思います。
最初に断っておきますが組み込み系において、ＧＵＩを作る場合Win32APIもVisualStudioに付属のフレームワークであるＭＦＣも使うことはまずありません。あと.NETのC++/CLIのフォームアプリも使いません。 まぁ、ポスレジとか自販機とかでそのままWindowsPCが入っている例があるので、その場合は使うことが有るかもしれません。それでもC#かも知れませんが。 組み込み系でGUIだと特殊なのも多いので・・・。 そうですね。ラズベリーパイとかマイコンをＣ++でやってみるのも良いかもしれません。 「こじ研（Raspberry Pi）」 http://www.myu.ac.jp/~xkozima/lab/raspTutorial2. … VisualStudioは使いませんけどね。
#3 をちと変更. 本質は何も変わらないけどコードとしては 1 を「x座標が最小の点を見つける」とした方がおそらく簡単.
>例えば、メインのルーチンを実行中に、フォーム上のボタンを押せるようにするにはどうするか等・・・。 その「メインのルーチン」というのをバックグラウンドで動かせばいいです。
http://msdn.microsoft.com/ja-jp/library/4e964t5e … GroupBoxとPanelの組み合わせ…らしいです。
fstreamのほうが便利な機能も多く慣れれば使いやすいので、どちらでも良いのであれば、 fstreamを使ったほうが良いと思います。
「CellPaintingイベント」です。 と指摘されていたハズですが？？？ いくらか前にListViewのカスタムドローで回答したことはありましたな。 DataGridViewでも同じ事ができるかは不明ですが。 # テキストの描画開始位置の算出が…なぁ……。 参考URL：http://qa.atmarkit.co.jp/q/3851
あなたが何を指して「プレースホルダー」と呼んでいるのかさっぱり分からんので全く保証の対象外だが, たぶんないんじゃないかな. たぶん理解したと思うけど「プレースホルダー」は本来「コードの記載において簡略表記する方法」じゃないわけで.
こちらが参考になるかも … 参考URL：http://www.kanazawa-net.ne.jp/~pmansato/net/net_ …
fgetsの仕様は確認されていますか？ fgetsは読み込んだ改行文字'\n'をバッファに格納します。 改行文字'\n'が格納されないのはバッファから溢れた場合とEOFに達した場合です。 また、 >printf("入力した文字列の長さは%dです\n" ,strlen( buf )); strlen()の戻り値の型はsize_tです。 sizeof(int) == sizeof(size_t) とは限りませんから"%d"では環境によって正しく出力されない事もありますし、たまたま正しく出力されてるように見えてるだけの事もあります。
あなたは、「extern “C” int StrCount(const char* str, char ch); で StrCount と言う関数がどこかにあるからコンパイル後にリンクしてね」と宣言しています。 それなのに、 StrCountがどこにもないので、リンカーが「そんな関数ないよ？」とエラーを出しています。 本がないからわかりませんが、StrCountの関数があるヘッダファイルをインクルードするか、StrCountの関数をあなたが定義しなければいけません。
回転値というのはオイラー角のことでしょうか？ その前提の回答になりますが、 やはり#1の方も行列について書かれていますが、行列計算が必要です。 カメラの視線方向をオイラー角で管理するというのであれば、計算にはオイラー角 と行列の相互変換が必要です。 ・オイラー角→回転行列 http://cflat-inc.hatenablog.com/entry/20130430/1 … のページにある R=RX(α)RY(β)RZ(γ) の計算で得られるRがオイラー角に相当する行列です。 ・回転行列→オイラー角 http://spphire9.wordpress.com/2012/07/05/%E5%9B% … で、これを前提として、質問の内容を実現するには、下記の手順を行います 1. カメラの現在のオイラー角に対応する行列を求める（Rとする） 2. カメラに加算する回転に相当する行列を求める（Sとする） 3. 行列の積　R' = S・R　を求める 4. R'をオイラー角に戻す これでカメラを回転できます。
> 悩んでいるのは EndReceive から、 > 二回目のBeginReceiveまでの間に送られたデータを取りこぼしてしまうのではないかということです。 大丈夫よん。 プログラムがBeginReceive～EndReceiveでひとかたまりの受信データブロックを取得するのはあくまで「同じコンピューターのOSから」なので、その時「同じコンピューターのOS」は相手からのデータ送信をどんどこどんどこ受け付けている。 そもそも最初のBeginReceiveをしなくてもコネクションが確立された瞬間からOSは相手からデータを受け取っているのだ。 これは、次のようなイメージだ。 （１）あなたは一階に総合受付がある雑居ビルで仕事をしてる。（あなた＝プログラム、総合受付＝NIC） （２）一階の総合受付の中にあなた宛の郵便受けを置いたとする。(Socket#Listen、Socket#Accept） （３）郵便屋さんはそこにあなた宛の郵便をどんどこどんどこ持ってくる。 （４）あなたは部下に「郵便受けに何かないか見てこい。何もなかったら何か来るまでそこで見張ってろ。郵便が有ったら報告せよ。」という。（BeginReceive） （５）部下は降りていった時に郵便があればそのまま持って上がる。無ければ来るまで待つ。（コールバック） （６）あなたは部下から郵便を受け取って再び（４）を命じる。（EndReceive、AsyncState、BeginReceive） ここで、（３）と（４）～（６）は非同期にかつ独立して行われる。あなたや部下が郵便を取りに行こうが取りにいくまいが郵便屋さんは郵便を持ってきて便受けに入れるだけだ。具体的には（６）でEndReceiveとBegenReceiveの間に郵便屋さんが来たとしてもそれは便受けに郵便を入れるだけだ。 もちろん、あなたのプログラムが終了しようとしている時に郵便受けに溜まってるのにあなたが読まなかった郵便はプログラム終了（というかSocket#Close）とともにロストする。 TCPはこの郵便受けがぱんぱんになってしまったら郵便屋さん（というか郵便を送りつけてくる相手）にちょっと待って貰うとかそういう制御もしている。 イメージ的にはこんなイメージであなたはBeginReceiveとEndReceiveを実行するタイミングによる伝送データロストを気にする必要はない。もし本当にそんなちょっとしたタイミングの差でそんな事が起こるんならMicrosoftさんだってそんなコンポーネント作らんじゃろ。
clは只の例です。 PATHの役目は、「コマンド名だけ入力したときに、実行ファイルを探すディレクトリを指定する」ことです。 Ｃ￥（ユーザー名）￥Documents\ Visual Studio 2010\Projects\study2\Debug\study2.exe などと、ディレクトリまで指定してある場合は、PATHを使って探しません。 ですから、PATHの設定は無関係と思われます。 > study2.exe はＣ:の最下層にあるのはわかっているのですが　ビルドもリビルドも出来ません。 まず、エクスプローラで探すと、本当に上の場所にファイルはあるのですか? 「わかっている」だと、あるのを知っている(つもり)になっているだけで、本当には存在しない、という可能性もあります。 また「ビルドもリビルドも出来ません」とはどういう状況なのでしょう? ビルドできなければ、その成果物であるstudy2.exeも存在しないはずですが? 「ビルドできない」というのにも ・ソースコードが間違えていてエラーになる ・Visual Studioのインストールが不完全で、ビルドが正常に行えない の2通りが考えられます。 前者ならソースコードを修正する、後者ならVisualStudioをインストールする、となります。 復元した、ということから、後者の可能性が高いように思います。
RenderTransformにRotateTransform渡せば回転します。 RenderTransformはUIElementの依存関係プロパティなのでTextBoxに限らないですが……。 http://msdn.microsoft.com/ja-jp/library/system.w … http://msdn.microsoft.com/ja-jp/library/system.w … ただし，RenderTransformOriginを指定しないと，左上隅が回転の中心点になるので，中心を指定するなどした方がよいでしょう。 XAMLで関係する部分はこんな感じです。 <TextBox RenderTransformOrigin="0.5,0.5"> <TextBox.RenderTransform> <RotateTransform Angle="90"/> </TextBox.RenderTransform> </TextBox>
オブジェクト座標系でＺ＋に動かしてから、新しい座標をワールド座標系に変換します。 具体的には、以下の処理をします。 １．オブジェクトを原点に平行移動する ２．オブジェクトから見た時の、移動量ベクトル行列を求める ３．オブジェクトが向いている方向の、方向ベクトルを求める ４．２と３を行列演算する ５．４で求めた行列を、１で平行移動したのと逆に平行移動する 最初の平行移動は、オブジェクトのワールド座標系での位置と同じなので、計算は要りません。 原点にあるオブジェクトがＹ軸に45度回転している時は (x' y' z' 1) = { ( cos45 0 sin45 0 ) ( 0 1 0 0 ) ( -sin45 0 cos45 0 ) ( 0 0 0 1 ) } ( x y z 1 ) となります。 オブジェクトから見ての正面に10進んだ位置は、オブジェクトの現在位置を原点とした時 ( 0 0 10 1 ) ですから、上記の式の「( x y z 1 )」に「( 0 0 10 1 )」を代入して { ( cos45 0 sin45 0 ) ( 0 1 0 0 ) ( -sin45 0 cos45 0 ) ( 0 0 0 1 ) } ( 0 0 10 1 ) を行列計算します。 そして、それをワールド座標系に平行移動します。 平行移動は (x' y' z' 1) = { ( 0 0 0 ｔｘ ) ( 0 0 0 ｔｙ ) ( 0 0 0 ｔｚ ) ( 0 0 0 1 ) } ( x y z 1 ) で行列計算します。 この時のtx ty tzは「移動前のオブジェクトのワールド座標系での座標位置」で、「( x y z 1)」は、その前の行列計算で求めた「( x' y' z' 1)」の事です。 「何を言っているのか判らない」って場合は「行列」と「ベクトル」についての学習が必要です。
下記の下の方の「この記事へのコメント」に幾つか書かれています。 http://dobon.net/vb/dotnet/beginner/exceptionhan … また、ANo.1さんの回答にありますように setLog(ex.Message); setLog(ex.StackTrace); も良いかもしれません。
一般的にはあなたが調べられたようにフォームに受け渡します。 Staticクラスやグローバル変数で調べるといいかと思います。
verではなくvarだと思います。
http://dobon.net/vb/dotnet/system/osversion.html 上記のページの下の方に「サーバーかどうか調べる」という記載がありますね。
失礼、先に回答した内容は事象１についてです。 事象２についてはやはりソース量の問題でしょうね。 VS2010は重いとも言われていますし、 軽く検索したところ低スペックのPCで同様のメッセージが出ている方がいるようです。
遅くなってすみません インストーラの実行時の条件に.NET Frameworkを指定する事で、 インストール時に.NET Frameworkが無ければ、メッセージが表示され、 .NET Frameworkのインストールが先に行われるようになります。 設定方法は↓を参照していただいた方が、私のつたない文章より判りやすいと思います http://dobon.net/vb/dotnet/deployment/dotnetboot … ちなみに、新しいＰＣだと4.0が標準なので、必須コンポーネントも態々2.0にせず、 4.0を指定する事をお勧めします。
/* * Visual C++ 2013 でコンパイル/実行 * cl -EHsc csvsearch.cpp */ #include <iostream> #include <fstream> #include <string> #include <map> #include <array> #include <algorithm> using namespace std; int main() { map<string,string> dictionary; ifstream stream("Book1.csv"); if ( !stream.is_open() ) return -1; string line; while ( getline(stream,line) ) { // "○○○,×××," から "○○○" と "×××" を切り出して key, value とする string::size_type pos; pos = line.find(','); if ( pos == string::npos ) continue; string key = line.substr(0,pos); line = line.substr(pos+1); pos = line.find(','); if ( pos == string::npos ) continue; string value = line.substr(0,pos); // key/valueを辞書に登録 dictionary[key] = value; } // 以下の各keyについて array<string,4> keys = { "りんご", "みかん", "なし", "もも" }; for ( string key : keys ) { // 辞書を検索し、 auto iter = dictionary.find(key); if ( iter != dictionary.end() ) { // あったら出力 cout << "japanese=" << key << ", english=" << iter->second << endl; } else { // なかったら not found cout << "japanese=" << key << " not found" << endl; } } } /* Book1.csv: みかん,orange, りんご,apple, もも,peach, */
僕なら Xerces、　MFC/.NETは一切使わず、C++のみで実装されています。 参考URL：http://xerces.apache.org/xerces-c/
>http://www.curiocube.com/mikata/oop/p1_ch09_nonu … Func(0); これを後で読んだ場合、ポインタのつもりだったのか数値の0のつもりだったのかわからないと思いますが。 C++で Func(NULL) を「Func(int *)が呼び出されることを意図したコード」というのが、そもそもの間違いですし。 NULLを使うにしろ0を使うにしろFunc(int *)が呼び出されることを意図したコードは Func((int *)NULL); Func((int *)0); です。 >http://www.geocities.jp/bleis_tift/cpp/null.html NULLの定義は確かに処理系依存ですがNULLポインタの内部表現自体処理系依存です。 NULLが思った通りの動作をしない事があるというのもNULLの使い方を間違えてるくらいしか私には思いつかないです。 3番目については「NULLは単なるマクロなので本来は0を使わなければだめ」といった内容には思えないですけど。
質問が理解できない
この分野には詳しくはないのですがFortranを使うことが多いです。歴史的な要素も有るのですが、Fortranの方がCより速いプログラムになることが多いのも関係していると思います。 入出力を除いてはCとFortranもそんなにに変わらないので、ある程度自分で作る気があるのでしたらFortranでも簡単にCで書き換えらると思いますがいかがでしょうか？ ただ配列要素が1から始まるのと0から始まる違いがあるので気をつけないと間違いがおきやすいです。 さて、現実的な解決法としては、CからFortranのサブルーチンを呼び出すことができますので、参考書にある部分はFortranでそのまま利用し、自分で一から書く部分はCで書かれてはいかがでしょうか？ Fortran2003らかはC bindingで検索すれば出てきますが、Cのサブルーチンとほとんど変わらない呼び出し方ができますので、簡単に共存ができます。古いポインタ渡しの解説記事が多いと思います、手間さえかければでできるのですが、C binding機能を使うことをお勧めします。
＞C でデータに const 属性をつけて、初期値を設定して定義すると、初期値は ROMにテーブルが作られますがデータ自体は RAM領域に配置されます。 　何か勘違いしている。 　const 属性はコメントのように書き換えないデータに使います。 　だからＲＯＭ領域に配置されます。 　初期値を持ち、後から変更できる変数はＲＯＭに書いた値をＲＡＭにコピーして使います。 　その場合、const　は付けません。 　リンカー・オプションでセクションのアドレスを設定します。constデータのセクション・アドレスをＲＯＭ領域に設定します。 　ＲＡＭ領域に入っているデータを誤って書き込まないために、読み出す側で安全策としてconstを付ける使い方も有ります。誤って書き込もうとすると、コンパイラがエラーを出してくれます。
確かに * なしの void が戻り値となっている場合は、その関数の戻り値が無いことを意味します。 しかし void * というのは、何らかの型のポインタを表します。 ですから、それが戻り値という事は、何の型のポインタかはこれだけではわからないけどとにかくポインタが返ってくることを表します。 何型のポインタかは事情があって決められない場合によく使われます（例：malloc()）。ですのでその型が具体的になんなのかを決める方法は関数の説明文にあると思われます。 これ以上は関数の説明文を読まないと何とも言えません。説明文を提示いただければさらにアドバイスできると思うのですが。
(1) LPTSTR pszFName = new TCHAR[siz]; // ↑ LPCTSTR ではなく LPTSTR です。LPCTSTR は TCHAR const* で LPTSTR が TCHAR* です。つまり、LPCTSTR は "中身を書き換えられない文字列" で、_tcscpy_s の第一引数 TCHAR* (書き換えられる文字列) に渡す事はできません。 (2) しかし、Windows の関数に渡すだけであれば変換する必要はなくて、ただ単に、str.GetBuffer() を Windows の関数の引数に指定するだけで良いと思います(寿命の問題がなければ)。 或いは、単に、 LPCTSTR pszFName = str.GetBuffer(); で、pszFName に str の中身が入ります。 (3) あと、(文字コード) 変換が必要とか必要ないとか言う回答が挙がっていますが、 CString は TCHAR の文字列、 CStringA が char の文字列、 CStringW が wchar_t の文字列 ですので、CString と TCHAR/LPTSTR の間では、文字コード(Unicode <-> MBCS)変換は必要ありません。CString と LPSTR や LPWSTR の間の変換の方が寧ろ必要です。 因みに、Windows の API 関数は、文字列を受け取るどの関数も、TCHAR 版 (例: CreateFile) と char 版 (例: CreateFileA) と wchar_t 版 (例: CreateFileW) の 3 種類が全て定義されています (char/wchar_t 版は A/W を最後につけるだけ)。従って、文字型に応じて対応する版を選んで呼べばいいだけなので、Windows の API 関数を呼び出す為であれば文字コード変換はそもそも必要ないと思います。
>それは理解しています。だから、 > 　ワードのファイルのテキスト部分を >　テキストファイルを扱うように文字列置換を行うだけの、ワードファイル用の関数replace() >がないのか、お聞きしているのです。 少なくともCの標準関数としてはありません。 どこかの誰かが作ってる可能性もありますが少なくとも私は聞いたことありません(.NET使う方が楽だから可能性はかなり低いと思うけど)。
>よくiPhone版アプリで好評なものはAndroid版のリリースとなると結構待たされることがありますが >そういう理由ですね… 違います（笑）。 Androidは、Cではなくて、「Java」という言語で開発されます。また、iOSとはライブラリもまったく違いますから、基本的にはすべて一から作り直しになります。 個人的には、AndroidアプリのほうがiPhoneより簡単だと思いますよ。Androidの場合、Javaだけでなくて、使える開発環境がいろいろとあります。例えば、Googleが開発し、現在、MITで公開されているApp Inventorという開発ツールは、マウスで画面を設計し、アイコンを並べてプログラミングをするというもので、簡単なゲームなら小中学生でも作れるぐらいです。「App Inventor」で検索してみるといろいろ情報が見つかります。 Cを覚えることが目標ならそれでいいのですが、「スマホのアプリを作る」というのが目標ならば、Cにこだわる必要はないように思えますよ。
"invalid language characters in property" で検索すると似たような質問・相談が色々出てきます。 * http://www.tech-archive.net/Archive/DotNet/micro … * http://www.vbforums.com/showthread.php?538029-Re … * 他にも沢山 解決するか分かりませんが、以下の事を確認されてみては: (1) プロジェクト(ソリューション)に含まれるファイル名に日本語(やその他の特別な文字、文字化けした文字)などが含まれていないか。 もし該当したらファイル名を変更して下さい。 (2) プロジェクト(ソリューション)自体が存在しているディレクトリのパスに日本語が含まれていないか (例 C:\日本語\foo\bar\MyProject) もし該当したらプロジェクト(ソリューション)をASCII文字だけで構成されたパスの下に移動して、開き直して下さい。 その際に、もしリンク切れしている項目(ソースファイル、アイコンファイル、リソース、インクルードパス、ライブラリパスなど)が在れば再度設定し直して下さい。
pdb ファイルが有るということは、自分で OpenCV をビルドされたのでしょうか。 ビルド済みパッケージをインストールして、同様にやってみてはどうでしょうか？ それと、既に指摘がありますが、32bit ビルドでは 64bit のライブラリを静的リンクできなかったと思いますので、"...\x86\vc10\staticlib\..." にしてみてください。 参考URL：https://sourceforge.net/projects/opencvlibrary/f …
XC8だと #include "pic.h" であって #include "16f876A.h" じゃないんじゃないかぁ。 詳しくないけど。 参考にしているコードXC8用じゃない場合色々と修正する必要があると思いますので、参考元もXC8にしたほうが良いと思います。
フローチャートの書き方。というのがあります。 世界標準ですので、個人的な書き方をすると 自分にしかわからないものになってしまいます。 後で自分が見てもわからないことになることも多いです。 もう少し勉強して下さい。
＞*p=100　は*p = 100;で終わっていますが！出力結果として文字が出てきたいるのはなぜですか！ つまり、「*p = 100;」のようにセミコロンつきでなぜ出力されないかという質問ですね。 回答：printf("*p=%d\n", *p); の代わりに、printf("*p=%d;\n", *p);というprintfにすれば、セミコロンつきで出力されますよ。
具体的な手順はすでに回答ついているのでいいとして… >リソースにはjpegで書いた画像aを追加しました。 画像ファイルではアイコンやマウスカーソルには使用できないかと。 アイコンエディタとかフリーでありますからそういうのでアイコンファイル(カーソルファイル)を作成してください。
バブルソートではないですね。 http://ja.wikipedia.org/wiki/%E3%83%90%E3%83%96% … 選択ソートではないかと思います。 http://ja.wikipedia.org/wiki/%E9%81%B8%E6%8A%9E% … > また、ほかのソートの仕方も教えてください。 「ソート アルゴリズム」などで検索するといっぱい見つかると思います。 他の回答である通り、C++でプログラムを書くとしたら、std::sortを使うのが普通です。今回は勉強のために自分で書いてみているのでしょうけれど。 quick sortとか? template <typename T> void Swap(T& i0, T& i1) { T tmp = i0; i0 = i1; i1 = tmp; } template <typename BiderectIter> void QuickSort(BiderectIter begin, BiderectIter end) { typedef typename std::iterator_traits<BiderectIter>::value_type value_type; if (begin < end) { BiderectIter pivot_index = end - 1; value_type pivot_value = *(end - 1); BiderectIter store_index = begin; for (BiderectIter it = begin; it != end - 1; it++) { if (*it < pivot_value) { Swap(*it, *store_index); store_index++; } } Swap(*store_index, *pivot_index); QuickSort(begin, store_index); QuickSort(store_index + 1, end); } } merge sortとか? template <typename Iter> void Merge(Iter begin, Iter middle, Iter end) { typedef typename std::iterator_traits<Iter>::value_type type; std::vector<type> tmp; tmp.reserve(end - begin); Iter fhead = begin, lhead = middle; while (fhead != middle && lhead != end) { if (*fhead < *lhead) { tmp.push_back(*fhead); fhead++; } else { tmp.push_back(*lhead); lhead++; } } if (fhead == middle) { for (; lhead != end; lhead++) { tmp.push_back(*lhead); } } if (lhead == end) { for (; fhead != middle; fhead++) { tmp.push_back(*fhead); } } Iter it = begin; for (size_t i = 0; i < tmp.size(); i++) { *it++ = tmp[i]; } } template <typename Iter> void MergeSort(Iter begin, Iter end) { size_t size = end - begin; if (size < 2) return; Iter middle = begin + size / 2; MergeSort(begin, middle); MergeSort(middle, end); Merge(begin, middle, end); } 呼び出し方はこんな感じになりますが。 QuickSort(&c[0], &c[10]); MergeSort(&i[0], &i[10]);
ループ処理に失敗していますね 同様の処理を二箇所に分けているのも感心しません。 あと最近のコンパイラなら自動的に最適化してくれますが、 二進数の処理をするなら、やはりビット演算で書くのが筋でしょう。 // 正解例 ただし入力値が正の整数の場合のみ int s, b; for (s = 0, b = 入力値; b != 0; b >>= 1) { □ if(b & 1 > 0) s++; } printf("%d is %d\n", 入力値, s); -- 出題の例からは外れますが、別解として // K&R に登場する高速化した処理 int s, b; for (s = 0, b = 入力値; b != 0; s++) { □ b &= b - 1; } printf("%d is %d\n", 入力値, s); // 分割統治法を用いた実用的な処理 unsigned int t = 入力値; t -= (t >> 1) & 0x55555555; t = (t & 0x33333333) + ((t >> 2) & 0x33333333); t = (t + (t >> 4)) & 0x0f0f0f0f; t += t >> 8; t += t >> 16; t &= 0x3f; printf("%d is %d\n", 入力値, t);
1行ごとにalt="の位置を検索して次の”の位置までの文字数をカウントする。 検索はstring.IndexOf()でできます。 先頭座標が取得されるのでalt="の文字数分だけずらしてやります。 これで1行の文字数が取得できるので、すべての行の文字数を取得して足しあわせるだけです。 文字数の取得は正規表現を使うと簡潔に記述できるかもしれません。
(1)ソリューションエクスプローラーで対象のプロジェクトを右クリック (2)表示されたプロパティ画面の左側で「ビルド」を選択 (3)(2)で表示されたページの中の「アンセーフコードの許可」にチェックを入れてプロパティ画面を閉じる ……でも、ポインタに挑戦するならポインタが異物な C# よりもポインタの本場の C 言語をやった方がいいと思うのですが。
ANo.1 にあるとおり、C++なら一様分布が簡単に作れます。 #include <iostream> #include <random> int main() { // メルセンヌ・ツイスター std::mt19937 generator; // 0..9 一様分布 std::uniform_int_distribution<int> distribution(0,9); for (int i = 0; i < 20; ++i) { int number = distribution(generator); std::cout << number << ' '; } }
XBee ZigBee 基本編 ワイヤレス通信を始めよう～XBeeの使い方～ http://www.geocities.jp/bokunimowakaru/diy/xbee/ … 　こういった情報で何とか・・・なりませんかね？ 　ペアリング（ネットワークへの参加）さえできればどうにかなりそうな気がしますが。 参考URL：http://www.geocities.jp/bokunimowakaru/diy/xbee/ …
質問者さんの意図に、いちばん近い形にするとなると、こういう書き換えになるでしょうか？ ＞ *(array + 3) = 0; int *ptr = &array[0][0]; *(ptr + 3) = 0;
>２行目の「;」を入れると「emptyステートメントが間違っている >可能性があります」と警告も出ています。 そりゃ、if文で判定した後「なにもしない」という無意味な文になるからでしょう。 # 警告ならそのまま走りそうですけどね。 # ただし、どんなURLだろうがヤフーのトップページに固定されることになるでしょうけど。 >「;」を省くと警告もエラーも出ませんが、処理も上手くいきません。 どう「うまくいかない」んですか？ >strURL == "http://google.com" だと、それ以外の場合には判定成功しませんよ？ "http://google.com/"でもダメ。 今だと…リダイレクトされるのか別のページに遷移したりしますけどね。 # httpsなページに飛ばされる。
> 色々調べましたらＣ＋＋のコンパイラの設定に関連するエラーらしいです 違います。関数の呼び出し方が間違っていることを表すエラーです。 Windows 関連の C/C++ で LP~ で始まる型を見たら ~ 型のポインタを意味するものと考えてまず間違いないです。今回の場合は POINT 型のポインタを要求されているところに POINT 型そのものを渡しているために問題のエラーが発生しています。 したがって、今回の場合は bool rtn = MoveToEx(hdc, 0, 0, &MyPoint); としてやれば OK ……とはなりません。このコード片にはそれ以外の問題があるからです。 (1)なぜ POINT 型を自分で定義しているのでしょうか? この関数が要求しているのは windef.h で定義されている POINT 構造体のはずで、この関数を使用するために windows.h をインクルードしていれば使えるはずです。 http://msdn.microsoft.com/ja-jp/library/8kk2sy33 … (2)この関数の戻り値の型は C++ の bool 型ではなく Windows SDK で定義されている BOOL 型です。実験してみたところ VC++ では問題なく変換できるようですが、型は合わせたほうが安心でしょう。
OutputDebugString()のことですかね？ DLLに限った話ではありませんし、printf()のようにコンソールには出ませんけど。 参考URL：http://www.nitoyon.com/vc/tutorial/debug/win32.htm
＞XXX.configが見当たりません。 無いなら作ってしまう、と言うのは試しましたか？ 単なるテキストファイルなので、メモ帳で新規作成して、保存後にXXX.exe.configにリネームすればよいです。 あと、こういうシステムファイルは、デフォルトで「非表示」になっている場合があるので、エクスプローラーの表示設定を「システムファイルも隠しファイルもすべて表示する状態」にして下さい。 作ってみて駄目であれば「この方法では解決しない」ので、ランタイムライブラリを古い物に戻す、ランタイムライブラリを新しい物に更新する、ランタイムライブラリを使わないでアプリの中に全部のライブラリを抱え込む形式でビルドし直すなど、他の方法での対処が必要になると思います。
訂正: 関数型→関数ポインタ型 メンバ関数型→メンバ関数へのポインタ型
int *x ; で宣言された変数x は 「int *」型 mallocが返すのは 「void * 」型 です。 x=malloc(sizeof(int)); では 「int * 」型 = 「void *」型 なので、型が一致しません。 そこで、 (int *)を使って、 「void *」型を「int *」型に型変換しています。 わざと「ポインタ」という言葉を使わずに説明しました。 混乱の原因は、ポインタを特別なものだと思い過ぎているからではないでしょうか。 ちなみに。 ・C++を使っているのなら、(型)というキャストは使わないようにするのがよいでしょう。 詳しくは「C++ キャスト」で検索すると解説サイトが見つかります ・C++では、領域割り当て用の演算子 new というものがあります。 これは、型を指定するので、キャストの必要はありません。 また、classやstructは、mallocで確保してしまうとコンストラクタが呼ばれません。 なお、mallocに対してfreeがあるように、new には deleteです。
すみません、こういう操作は素人なので、的外れかもしれませんが、ソースを見てみると、Yahoo! JAPAN IDのテキストボックスは、ソースの129行目の <input type="text" maxlength="32" name="yid" id="yid" value="" class="txtbox stop" tabindex="10"> ではないでしょうか？ 「u」ではなく、「yid」でやってみては？
規模の大きなプログラムでは少し修正するたびにソースファイルを 全部コンパイルしていたら非常に時間がかかります。 規模によっては数時間かかったりします。 必要なオブジェクトファイルだけ作り直してリンクするのは、 それよりはるかに短い時間で済みます。 Linux と gcc でプログラミングしているそうですが、 make コマンドは使用していないのでしょうか。 make コマンドを使用して差分ビルドするようになると、 オブジェクトファイルの有用性を感じるようになるのではないかと思います。
(2) はとりあえず条件をはっきりさせるところからスタートだね. 例えば ・「20x」という入力に対してどうする? ・「20 x」という入力に対してはどうする? ・「-3.6」は? とか, 悩みだすと難しい.
> error C3861: 'IntPtr': 識別子が見つかりませんでした using namespace System; していますか。 または， System::IntPtrと書くかです。
TeijigoTeatimeさん、こんにちは。 提示されたコードは受け側のコードですね。 送り側はどうやってますか？ CreateNamedPipeでパイプを生成している思いますが、その第５、第６引数に何を与えていますか？ パイプで送受信するバッファが16バイトしか用意されていないということはないですか。
まぁ、既にツッコミされていますが……。 どういう入力をして、どうなったんでしょうか？ int型とfloat型では格納されるビットパターンが異なるんじゃないですかねぇ…。 # int型の領域にfloat型として書き込もうとするので…バッファオーバーランしているんじゃないですかね…。 # e1かe3の前後どっちか破壊しているかと思われます。 >scanf("%f,%f,%f",&e1,&e2,&e3); >tri(e1,e2,e3); tri()呼び出しの前にそれぞれの変数の内容を表示して、入力した値と合っているか確認してみてはどうでしょう。 scanf("%f,%f,%f",&e1,&e2,&e3); printf("e1=%d,e2=%d,e3=%d\n", e1, e2, e3); tri(e1,e2,e3); みたいな。
>kasoku.c:48:29: error: ‘rtc’ undeclared (first use in this function) エラーメッセージの通り、'rtc'ってのが見つからないからでしょう。 >//デバイスイニシャライズ >L3GD20_init(i2c_fd); >　　(中略) >// デバイスからデータ取得 >L3GD20_readData(gyroData, rtc); ってところからの推測では… // デバイスからデータ取得 L3GD20_readData(gyroData, i2c_fd); なんじゃないですかね？
WPFはやってないので見当違いなら申し訳ないのですが、 ファイルの拡張子がcsってことはC#ですよね？ > String^ Text = gcnew String( "文字列" ); このコードはC++/CLIのコードですのでC#のコンパイラに怒られるのは当然では？ 　String Text = "文字列"; でいいかと思います。
型　　　　大きさ　　　　　記憶出来る範囲 char　　　１バイト　　　１文字-128～127 の意味するところは以下の通りです。 ーーーーーーーー char型は、記憶領域１バイト（８ビット）の大きさで記憶され、２５６通りの値を記憶できます。 ２５６通りの値をどのように使うかは利用者（プログラマ）次第ですが、 アルファベットであれば大文字小文字をあわせても２５６通り以内なので記号を含めて１文字の記憶に使えます。また数値を記憶させるとした場合、０から２５５までの２５６通りとして記憶する場合や、-128から127までの２５６通りとして記憶すると場合が一般的です。
わかる分だけ。 >２．１５行目の変更方法は？ >オリジナル >CFLAGS= $(cflags) $(cdebug) $(cvars) -I. >これにオプションを追加する記載はこの様に２行になると、２行目しか認識されませんよね？ >どの様に記載するのか教えていただけないでしょうか？ 1行目の定義は2行目の定義で置き換えられるのは確かですが、6の文章をよく読みましょう。 6に書いてあるのは、「マルチスレッド」「マルチスレッド デバッグ」「マルチスレッド DLL」「マルチスレッド デバッグ DLL」をそれぞれ作る度にCFLAGSを書き換えてくださいって事です。 >３．「release用の場合は nodebug=1 オプションを末尾に付ける」とは以下の様にするのでしょうか？ あってます。 >※release用を別メイクするのなら、２．のオプションはデバッグとリリースで別々に作成して実行するのでしょうか？ リリース用とデバッグ用はmake時にnodebug=1を指定するかしないかで行われるので別々に作成する必要はありません。
既存のShowDialog()を利用せず、FormBでShowDialog()をオーバーロードすればいいのでは。 【Form1.cs】 Form2 form = new Form2(); int result = form.ShowDialog(); Console.WriteLine(result); 【Form2.cs】 DialogResult result = base.ShowDialog(); if (result == System.Windows.Forms.DialogResult.OK) { return 0; } else { return 1; } みたいな。 また、ShowDialog()で制御がFormAに戻ってくるタイミングは、FormBが閉じられた時です。 つまり、(3)の前半部分はShowDialog()では実現できません。
R8C　HEWではなく　arm IAR workbenchでの経験からなのですが... 書き込みの方法(RS232Cとか)によっては、書き込むためのプログラムが書き込まれているために初期値のままはなくベクタ領域などをずらして設定しなければならないのかもしれません。 vectorでプロジェクトのファイルを検索してみるといいかもしれません。
「ポインタは特に指示しなくても、大きさが確定する」でだいたい当たり. まず, C において配列には「1次元配列」しか存在しません. で, 配列の要素には非常に大雑把にいうと「宣言の時点で大きさが確定しなければならない」という条件が付きます (正確な条件はめんどくさいので省略). ということで ・int p[][]: p の要素は「int []」であるが, この [] の中に大きさが書かれていない→要素の大きさが確定しないのでアウト ・int *p[]: p の要素は「int *」で, 大きさが確定しているのでセーフ ・int p[][4]: p の要素は「int [4]」. これは大きさが確定するのでセーフ ついでに余談: 関数の仮引数に配列を書くと自動的にポインタと解釈される.
/OUT:ファイル名 を使ってください。
とりあえず, アルゴリズムを見せてくれれば考えてもいい.
ビルドするたびに、Visual Studioのプロジェクトに入っているDBファイルがbin/Debugなどに上書きコピーされていませんか？ bin/Debugに入っているプログラムを起動してDBを書き換えても、ビルドし直した際に、bin/DebugなどにDBファイルが上書きコピーされて内容が消えているように見えます。 常に同じDBを参照しておきたい場合、ConnectionStringでDBファイルをフルパスなどで指定するようにすれば解決できると思いますよ。
ラジオボタンにスクリプトでチェックを入れたいと言うことでしょうか。 WebBrowserコントロールを使っていると思いますが、おそらく操作はJavaScriptによるDOM操作と同じだと思われます。 そうすると、次のようにすればチェック制御が行えるはずです。（JavaScriptならこんな感じです） forms[0].checked = true # 少し話はそれますが、本来の目的からそれて、1人で大量のメールアカウントを取得（何が目的か分かりませんが）というのはあまり奨められる事では無いですね。
まだ正規化の式が間違えています いきなり処理全体をつくろうとせずに各処理を確実１つずつ作ってみてください。 -オブジェクト型に直接座標値が入っているならそれはやめてベクトル型をつくってそのオブジェクトをメンバに持つようにしたほうがよいとおもいます -そのうえでベクトルに四則演算を実装する -正規化機能を実装する 上記を行いテストを行い正常に動作する事を確認する、ということをさきにやったほうが良いです。 あと、うまくいかない、とかかれていますがもう少し具体的に説明されたほうが解決に近づきやすうとおもいます。 現状で衝突判定は正常にできていますか? 回避だけがうまくいかないとは具体的にどういう結果になっているでしょうか?
Visual STUDIO 2005くらいから scanf_sになっていると思います。 オーバーロードされた関数が沢山有りますのでscanf_sでググってみて下さい。 頑張ってね。
MicrosoftUpdate(WindowsUpdate)の際に「空き容量の大きいドライブ」にDLされて放置されるファイルですかね？ 削除しちゃって大丈夫だと思いますよ。 Visual Studio ExpressEditionのインストール時に…だったかも知れませんが。
HTMLは使えませんが、NSAttributedStringクラスで、文字列を修飾することができます。下線も引けます。Apple Developに、クラスリファレンスもガイドもありますから、まずはそれらをお調べになってください。
No.1の回答は撤回します。（完全な誤情報というわけではないんですけど……） Storyboardのみで、オブジェクトのレイアウトができないはずはないなあという思いで、いろいろネット検索していたら、下のブログを見つけました。 http://qiita.com/sora0077@github/items/2e513d9fc … このブログの解説どおりにすれば、Storyboardのみでレイアウト可能です。 ただし、Autolayoutの使い方に習熟している必要がありますので、そちらの方面の勉強がまだでしたら、Autolayout入門から始めてください。 Autolayoutを使わない場合、No.1の回答どおり、プログラムでcontentSizeの調節が必要です。
> １． 標準の機能 > (画像データを変形毎に計算して求めるのは非現実的なので適用していません・・変形後も移動が有る為) 既に指摘がありますし、私も既に回答しましたが、その処理は必ずしなければなりません。なので不可能な理由にはなりません。 パフォーマンス的な問題で質問者さんの目的が達せられない事があるかもしれませんが、それはこの検討段階で言えることではありません。 > ２． OpenCV > ・透過処理がアルファブレンドなので、３の処理が遅い > (理想はOpenGLの様にＺバッファを使用して、背景が透過するもの・・・背景を意識しない処理のみで済むもの) アルファブレンド以外にも合成方法はありますが、試しましたか？ > ・透過処理がアルファブレンドなので、同サイズの画像か背景を上面と重なる部分を検出して切り出す必要がある > (上面の画像の変形を考えると、背景を上面に合わせて切り出すのは困難) なぜ困難なのでしょうか？ > ・４が矩形しか対応していないので、ひし形までしか変形できない > (視点の変更で形状こそ求めているものに近くなるが、今回の用途ではユーザーに単純操作で変形させてあげる必要がある) 方法があることは既に回答した通りです。
昨日の質問に回答しましたが、自分でC言語入門のサイト等を参考に基礎から一歩一歩理解を進めていって下さい。 自分で努力しないと実際の力は付きませんよ。 http://oshiete.goo.ne.jp/qa/8699054.html　回答No.3 　 例えば "猫でもわかるプログラミング " のサイトですが、名前に似合わず真面目に基礎から解説されているので調べてみて下さい。
> その方法をC#で記述するには、どのようにすればよいでしょうか 「C# レジストリ」で検索してみてください。 多くの情報が得られます。 例えば下記などが参考になるかと思います。 http://fernweh.jp/b/csharp-regedit/ http://dobon.net/vb/dotnet/system/registrykey.html http://ch.nicovideo.jp/laz/blomaga/ar471835
このような基礎的な問題を質問されても、直接の回答をする気には誰もなりませんよ。 C言語の入門書等を入手して真面目に最初から学んでください。 例えば次等 http://www.kyoritsu-pub.co.jp/bookdetail/9784320 … プログラミング言語C―ANSI規格準拠― 第2版 http://neko.sbcr.jp/neko_c.html 猫でもわかるCプログラミング言語　第３版 或いはネット上にもC言語の初歩から解説されているサイトもありますので、調べてみて下さい。 C言語　入門 OR 初歩 ==> http://www.kumei.ne.jp/c_lang/ 猫でもわかるプログラミング http://www.kumei.ne.jp/c_lang/index_c.html http://www.kumei.ne.jp/c_lang/index_c2.html 同上　Ｃ言語編 http://www9.plala.or.jp/sgwr-t/ 初心者のためのポイント学習C言語 ........
足し算をしているところ、 プラス記号が全角文字です。 半角のプラスにしたらコンパイルできました。
>フォーカスされていない時に変化しない様にするには、 >どの様にすればよいのか教えていただけないでしょうか？ GetFocus だったですかね、それが自分自身でなければメッセージを無視すれば良いのではないでしょうか。 でもフォーカスを持っているからこそメッセージが届いている気がしますが... >起動直後のどのスクロールバーにもフォーカスがされていない状態で、 まさか目視ではないと思いますが、これはどのようにして確認していますか？
http://d.hatena.ne.jp/NeoCat/20121209/1355041863
少なくとも、そのプログラムにASPは関係ありません。 > "プロジェクト→参照の追加"からSystem.Windows.Formsを追加しようとした 具体的にどのように操作したのでしょう? 追加の画面の「.NET」から「System.Windows.Forms」を選んで追加 としましたか?何かのDLLファイルを直接指定するようなことはしていませんか? また、そのプロジェクトはどうやって用意しましたか? Windowsフォームプロジェクトを最初から選べば、参照も元から追加されているはずです。 > どの語を使うときusingを追加するか、とか記述規則など、本当は手順を踏んで学習していきたいのですが、 > そういったことが掲載されていて なおかつ理解できる書籍やサイトがない VSに付属のヘルプや、MSDNのサイトがありますが。 例えば、 Point でエラーになる件ですが、 .NET Frameworksの Point を検索すると http://msdn.microsoft.com/ja-jp/library/system.d … が見付かります。4.5のものは今現在は機械翻訳のもので、ちょっとあやしい日本語になっていますので英語で読むのがよいでしょう。 また、過去のバージョンの資料も読めます。例えば3.5なら http://msdn.microsoft.com/ja-jp/library/system.d … です。 で、マニュアルですが、必ず次のような記述があります > 名前空間 : System.Drawing > アセンブリ : System.Drawing (System.Drawing.dll 内) usingに使うのは「名前空間」です。usingで使わないなら、 System.Drawing.Point のようにして使います。 アセンブリは、参照に追加しなければならないものです。 > 当面の目標は、特定のウェブページからキーワードを拾ってExcelに出力することで、 > そのためにマウスの右クリックなどをプログラムから使いたいと思っています。 どんなことを目指しているのか、ちょっとよくわかりません。 もし、「IEの画面にマウスを移動させて右クリック→コピー」をプログラムから行いたい、ということなら、 UWSCのような自動操作用ツールを使うのが楽です。逆にC#でどこまでできるか不明です。 データが欲しいだけなら、直接ダウンロードしてHTMLを解析して必要な部分を抜き出す、という方法もあります。 これらは「ウェブスクレイピング」(あるいは単にスクレイピング)と呼ばれるものです。 http://ja.wikipedia.org/wiki/%E3%82%A6%E3%82%A7% …
>cvAddWeightedだと、同じサイズ、移動時は再計算、変形後の配列をどうするかなどなど、 >問題があって、cvAddWeightedでは実現できないと考えております。 cvAddWeighted を出したのはただの例です。 合成方法など無数にありますから、ご自分で用途に合う関数をお選びください。 >ROIは矩形しか対応していないと色々なところで記載されていたので、 >考えていなかったのですが、ROIで非対称の台形なども指定できるのでしょうか？ そんなことは自分で組み合わせてするのですよ。 OpenCV 自体は別に 3D に限定するものではない、汎用の画像処理ライブラリですから、台形変換がしたいのであれば、台形変換をすればいいのです。 幸いにも、cvWarpPerspective という関数で透視投影変換ができ、cvGetPerspectiveTransform で変換行列を簡単に求められます。 台形変換は透視投影変換の一種ですから、できますよね。 >移動時は再計算…など、問題があって…実現できないと考えております。 を見て思ったのですが、使い方を根本的に勘違いしていませんか？ OpenGL では GPU に処理ステージというものがあって、モデルビュー変換や投影変換はパラメータを指定すれば勝手にやってくれますが、 OpenCV は汎用の画像処理ライブラリですから、そのようなフレームワークは無く、変換同士の組み合わせや、パラメータが変わった時の再計算などは全部自分でやる必要があります。
無理。　managedクラスはnativeなメンバ変数を持てません。
「大きなデータのやりとりはポインタ(又は参照)でした方が良い」ってのはその通り. ただ, 「配列は膨大な量になるからポインタで渡せ」 だと「配列」に限定しちゃってる. そうすると, 今の例のように「配列がどこにも出てこない」状況で言われても「何を言ってるんだ」ということになる. そもそも C++ において配列をポインタ以外でどう渡すのかってところから疑問だったりするわけだが. あと, #2 は SetListInt のなかで list_int = *temp_list; としているところを「全部の要素がコピー」と言ってるんだと思う. 実際, ここは全部コピーしちゃってるよね. 以下個人的な意見だけど, const でもらうなら nullptr を使いたいとかの特殊な事情がない限りポインタより参照の方が自然じゃないかなぁ.
ちゃんとしたコンパイラと実行環境用意した方がいいと思いますけどね……。 >　実行結果の >　kaisuu >KURIKAESHI 0のKURIKAESHI 0って何でしょうか！？ >printf("kaisuu >"); と >printf("KURIKAESHI %d\n", syori_kaisuu); の出力結果です。 本来なら >scanf("%d", &kaisuu); で入力待ちになるんでしょうが…… http://codepad.org/ では入力待ちになってくれないんでしょうね。 まぁ、ブラウザ経由で動作しているのにどう入力待ちしろと？とは思いますが…。 >何でプログラム上”KURIKAESHI 0”が現るのですか！？ なんでって…… >printf("KURIKAESHI %d\n", syori_kaisuu); の出力結果です。 syori_kaisuuは最初に0で初期化しているじゃないですか。 >いきさつが分かりません！？ scanf()が期待通りに動作しないからそのまま突っ走っているだけです。 kaisuuの初期化が無かったら悲惨なことになっていた可能性もあるでしょう。 # およそ2分の1の確率で"KURIKAESHI 0"の表示すらなかった…かも知れませんけど。 # コンパイラの既定がint=signed intだったら…ですけどね。
コンピュータが、「文字か数値化判断する」ということは、まずありません。 まず、注意しなければならないのは、誰かが書いた、 kakaku=1+2 というプログラム（の一部）は、いかなる場合でも、「文字と判断」されます。 一般的にソースコードといいますが、プログラムを、「文字として入力」しているわけで、ソースコードは、「文字の集まり」と解釈されます。 そして、Ｃなら、 kakaku=1+2 と書いた場合の、 1 や 2 は、「（整数型の）数値定数を表す」ということに、Ｃの規則で決まっています。 ですから、プログラムが「コンパイルされるとき」に、「ここに書いてある 1 や 2 という『文字』は、本来、数値を表現したくて書かれているのだ」と判断されて（上述したように、Ｃの規則では、こう書いたときには数値を表現することになっているので）、文字として書かれているものを、「数値に変換」して、計算します。 一方で、Ｃのソースで、"1 + 2" と書かれていれば、これは、「文字列を表す」と、Ｃの規則で決まっていますから、コンパイラは、「この部分は、文字列として扱って欲しい」と判断して、数値に変換せずに処理をします。 こういうわけで、 ・人間が書いたソースコードは、「文字」として扱われます。 ・それの中で、（たとえば、Ｃの規則で）「数値のつもりで書かれている部分」があれば、コンパイラなどが、「数値に変換」して処理を行います。
#include<stdio.h> int main (void) { int num,i,j,h; int k; printf("ピラミッドの高さを入力してください : "); scanf("%d" ,&num); for(i=1; i<=num; i++){ for(j=num; j>=i+1; j--){ printf("　",j); } for(h=1; h<=2*j-1; h++){ printf("■"); } printf("\n"); } return 0; }
>角度=atan2(目標y-キャラy,目標x-キャラx) この「角度」というのは、どこを中心としたどこの角度ですか？ >キャラx=cos(角度)*移動速度 >キャラy=sin(角度)*移動速度 これは、どこを中心に新キャラx,新キャラyを求めてますか？
＞以前インストールとアンインストールを繰り返したことがバグの原因かもしれません バグの原因って書いてありますがバグとは不具合の事をいい表す物ではありません。 不具合の原因がプログラムミス（設計ミスｏｒプログラム上の不備）の場合に使う言葉です。 大変失礼ですが、文面の書き方からいって初心者レベルと思われます。 もっと勉強しましょう。
＞printf("合計は%5.lfです。\n", (double)(na ＋ nb ＋ nc); をよ～く見てください　)　が足りません
1. TimerはForm2のメンバですか? 2. TimerのIntervalは適切な値が設定されていますか? 2. TimerのEnabledプロパティはtrueになって/していますか?
　今初めて知ったので試したことはありませんが。 ＞3.自己解凍ファイルの作り方　.exe ＞http://mbsupport.dip.jp/watson/lhaz3.htm 　プログラムを組まなくてもツールがすでに提供をされているらしい。 　ＸＰで可能ということは、それ以降でも何か提供をされていそうな？ ＞自己解凍型zipファイルの作り方 ＞http://blogs.wankuma.com/hatsune/archive/2009/12 … 　初めて知った（汗） 参考URL：http://blogs.wankuma.com/hatsune/archive/2009/12 …
> 予約語とキーワードは同義語なのでしょうか？ 厳密な意味では同義ではありません。 キーワードの方が予約語よりも範囲が広いです。 例えばC言語で標準に用意されている関数があります。 これらの関数名とか変数名はキーワードではありますが予約語ではありません。 例えば、freadとかfwrite、これらの関数名は予約語ではありませんから、 プログラマが自分の関数名などに使うことが出来ます。 しかしキーワードとして重要なので、まずどこでも使ってはならない、と コーディング規約などで定められる対象です。 「出来るコト」と「すべきコト」は違う訳です。 またコンパイルやリンクを行う時に、コンパイルオプションやリンクオプションが あります。 これらはコーディングとは関係が無いようですが、経験上それらのキーワードを 使うと妙なエラーが生じるとことがあると思っています。
それで問題ないです。 ですけどエディションはUltimateであってますか？ パッケージ版で約55万円するんですけど・・・
>う～ん、ちょっとその方法ですと、色々問題が発生しそうです。。 軽く試した範囲だと…難しそうでしたかね。 比較用に1行目のものだけオーナードローしています。 1)描画時のY座標位置が標準描画(2行目)と異なる。 　上に寄っています。 2)"INT"の描画時のX座標が異なる。 　なのにMeasureStringメソッドで取得した幅の分ずらすと"EGER"の位置は揃う。 DrawDefaultせずに該当の列(SubItem)を全部自前でDrawStringメソッドで描画すれば…ある程度は揃えられるとは思われますが。
なんか突っ込みたいところはありますが ポインタの互換性があるのは継承されている場合のみです。 ケチらずに最初からenv_02_t型を使うか、 env_02_t型を受け取るコンストラクタを実装してぶち込んでやるとか… バイト単位で完全な互換性がとれてるなら強引にキャストしても問題ない（プログラムの設計的には問題がある）と思います。 env_t *m_pEnv; ... env_02_t *m_p2Env = new env_02_t( m_pEnv ); delete m_pEnv; // 以後m_pEnvは使用禁止 ... // こんすとらくた env_02_t( env_t arg ) { // 対応するメンバ変数を全てコピーする処理 }
どういうコードを書かれているのかわかりませんが gmtime() localtime() 環境変数TZ この辺について調べてください。 >素人ですいません。 「素人」といえば何でも優しく教えてもらえる免罪符と勘違いしないようにしてください。
スレッドには大きく３つの状態があります。 - waiting : 待機中 - ready : 動けるんだけどCPUが空いてないので待機中 - running : 実行中　(最大でもCPUの数だけ) で、yield() は 実行中のスレッド(this_thread)がＣＰＵを明け渡し、 ready なスレッドに実行権を与えます。 これによって忙しいスレッドばかりがCPUを占有するのを回避するです。 yieldとは"譲る" って意味ね。 # yield()したとき、readyなスレッドがなかったときはそのままrunningを維持します。
オブジェクト指向を活用するなら UpdateEnvは、t_env, t_env2のvirtualなメソッドとして定義して m_pEnv->UpdateEnv(); みたいにする。
あぁ, #1 の意味がようやくわかった. 頂点が 3個しかないグラフでも無意味にループまわしてるのか....
alias では上手くいかないようです。 シェル関数を定義して、 gtp(){gcc -o ${1%.c} $1 $(pkg-config --cflags --libs gtk+-3.0);} とすると、 gtp test.c で、test コマンドが出来ました。
1) uSensor.cpp で、uMain.h を include します。 2) uMain.h の中に、extern PACKAGE TuMain *uMain という行があるのを探します。 3) この後ろの方の名前（この場合、uMain) を使って、 　 uMain->rgIfUse->ItemIndex = 1; 　　とすれば、OKのはずです。
他の方のお書きの通り、*NULL へのアクセスは処理系依存です。 また、他の方のお書きの通り、ポインターに0を代入した場合に実際に何が代入されるかも処理系依存です。 処理系依存とは言っても、ちゃんとメモリ管理されいるOSであれば、セグメンテーションフォルト例外やページアクセス例外などのプログラム割り込みが起こって、プロセスが異常終了するのが普通です。 ということで、たまたまお使いの環境がOS無し、もしくは、簡易なOSであり、 ＞参照先が何かしらあったって事なのでしょうか？ ということでしょう。 memcpy(test, "123", 4); printf("%s\n",test); でどうなりますかね。
No.7 です。 確かに間違ってました > #8 しばらく考え込んでしまいましたけど このあたりで、 a && b は、 if (! a) return 0; else return !!b; a || b は、 if (a) return 1; else return !!b; あるいは a && b は、 if (! a) return 0 else if (! b) return 0; else return 1; a || b は、 if (a) return 1; else if (b) return 1; else return 0; です。
>extern宣言ではダメだということでしょうか？ externはグローバル変数やグローバル関数に対して使うものです。 どこかにあるグローバル変数でないものを強制的にグローバル変数として扱うためのものではありません。
ANo.2で， > この場合，どこかにsObjの定義が必要になります。 と書きましたよね。 > エラーをみると外部シンボル ""public: static class TemMem::HOGE TemMem::sObj" (?sObj@TemMem@@2VHOGE@1@A)" は未解決です。 > とでるので定義しないといけないと思います。 ということまでわかっているのですから，ちゃんと定義すればよいです。 どこかの翻訳単位に， TemMem::HOGE TemMem::sObj; の一行を書くだけです。 <無関係な話> staticメンバ変数へのアクセスをインスタンスを使って書くのは混乱の元かと思います。 myClass.sObjではなく，TemMem::sObjと書く方がよいでしょう。 あと，const int &を返すFunc01も，ローカル変数への参照を返すので問題です。 </無関係な話>
〖 〗ってのは単なるカッコでしょうか、それとも何か特別な演算子？ あと、不思議な文字「▒」が表示されるんですが、これ何？ 　ま、こまかいことは無視すれば、不等式の制約条件付きの極値問題。ならば、アルゴリズムとか言う前に「KKT条件」で検索してみなされ。
いろいろ調べてみたところ, 規格上は #include <type_traits> template <typename T> typename std::enable_if<! std::is_base_of<AbstractClass, T>::value>::type CommonFunc(T &target) { /* do something for anything but of derived class of AbstractClass */ } template <typename T> typename std::enable_if<std::is_bsae_of<AbstractClass, T>::value>::type CommonFunc(T &target) { /* do something for anything of derived class of AbstractClass */ } でいけるはず. VC は知らんけどとりあえず手元の GCC ではできた.
後半のif文で判定している箇所がよくないですね。 添字iを０から９まで廻して、c[i]が５で割り切れるかどうか判断しないとだめです。 後半の判定部分は、 for(i=0; i<9; i++ ){ if(c[i]%5 == 0){ break; } if(i==10){ printf("5の倍数が含まれていません\n"); }else{ printf("5の倍数が含まれています\n"); } というような感じだと思います。（一例です）
キーボードからの入力を受け付けるけど、fgets関数を使うなとなるとscanf関数でも使うのかな？ こういう感じで良い？ ※インデントは自分で調節して下さい。 ---- int main( void ) { int iRika= 0; int iShakai= 0; printf( "理科: " ); scanf( "%d", &iRika ); printf( "社会: " ); scanf( "%d", &iShakai ); /* 理科は社会より点数が低い？ */ if( iRika < iShakai ){ /* 社会の点数を出力 */ printf( "社会 %d\n", iShakai ); } else{ /* 理科の点数を出力(同点なら理科を出力) */ printf( "理科 %d\n", iRika ); } return 0; } ---- かなり初歩的な内容なので、このくらいは自分で教本読んで勉強しような。 求めるものが違ってたらすみません。
先に回答した別の質問内容を読む限り、たぶん学校の宿題かなんかかな？ レベル感からして、自作関数なんかは想定しないと予想します。 以下のようなのでどう？ ---- #define HAIRETU_MAX 10/* 配列の要素数 */ int main( void ) { /* 変数宣言 */ int iLoop = 0; int iSeisu[HAIRETU_MAX] = {0}; /* 整数を入力 */ printf( "整数を%d回入力して下さい\n", HAIRETU_MAX ); for( iLoop = 0; iLoop < HAIRETU_MAX; iLoop++ ){ printf( "%2d個目: ", iLoop + 1); scanf( "%d", &iSeisu[iLoop] ); } /* 5の倍数が含まれているか調べるループ */ for( iLoop = 0; iLoop < HAIRETU_MAX; iLoop++ ){ /* 対象の数字は5の倍数か？ (5で割った余りが0の場合を5の倍数とみなしてチェック) ただし0と負の整数は5の倍数に含まないこととする*/ if( 0 < iSeisu[iLoop] && 0 == iSeisu[iLoop] % 5 ){ /* 5の倍数が含まれていたらprintfしてループを抜ける */ printf( "5の倍数が含まれています\n" ); break; } } /* 5の倍数が見つからずにループを回りきった？ */ if( HAIRETU_MAX == iLoop ){ printf( "5の倍数が含まれていません\n" ); } return 0; } ---- コメントいっぱいつけたので、分かりやすいはずです。 整数を10個入力するのが初期化で済ませていいのなら、最初scanf用ループは不要です。 要望にかなうなら丸コピーしてもかまわないけど、ちゃんと意味理解してからにしような。
>上手くいきません。 どういう結果になったか…くらいは掲示しましょう。 >どこがおかしいか、教えていただけないでしょうか。 >char *buff; ポインタ用の領域を用意しただけで、どこを指しているのかは不定です。 というのは理解されてますか？ >sprintf(buff, "mv %s %s",a,b); どっか判らないけど指しているトコに書き込んでちょ。 と指定しています。 プログラム自身をぶっ壊そうとするかも知れませんし、たまたま問題ないように見える部分をぶっ壊すかも知れません。 最近のOSなら、ちょっと待てぃ！！とプロセス停めるなりされるでしょう。 ついでに…… >name.txtというテキストファイルがあり、中身は >123 abc >456 def ならば… >sprintf(buff, "mv %s %s",a,b); で >mv 123/ abc/ にはなりませんよ。 パス区切りのスラッシュはどこから生まれるんでしょう？
失礼しました。 Vistaでは3.0か3.5が入っているから2.0は必要なかったですね。 > ダウンロードし > 開いても、「スクリプトでエラー、プロパティまたはメゾットをサポートしてない」と出てしまいます この「開く」とは実際には何を行ったのでしょうか。
キャストで万事解決. あとでほかの誰かに張り倒されるかもしれんが私の知ったことじゃないし.
例として、sizeof(int)=4 とします。 int ch とすることで、メモリのどこかにsizeof(int)を確保して、そこを使うことにします。 それを100番地とすると 100番地 ここから変数cの領域 101番地 ここは変数cの領域 102番地 ここは変数cの領域 103番地 ここは変数cの領域 例えるなら、 新人chが入ってきた。ロッカーを4つ分使いたいということなので、No.100～103を使うように指示した という感じ。 ここで、他の言語では「ロッカー」が綺麗に掃除されていたりするのですが、C言語では「空きロッカーの割り当て」をするだけです。 そのため、中に前に使った人の「ゴミ」が残っていることがあります。たまたま綺麗に掃除されていることもあります。 ch=0x41とすると、1バイト毎に分割されて 100番地 0x41 101番地 0 102番地 0 103番地 0 となります。 ※ ここでは、一旦そうしておきます。(後述) scanfでは、何を入れるか("%c")、どこに入れるか(&ch)を指示しています。 ここで、&ch でscanfに渡されるのは、100番地という最初のアドレスだけです。「そこから4つを使っている」という情報は渡されていません。 そこで、scanfは「%c」 から判断して「ロッカー一つに入れる」と解釈します。 入力した文字を100番に入れます。101から103は手付かずです。 scanfが文字コード0x41を読み込んだとすると 100番地 0x41 101番地 ごみ 102番地 ごみ 103番地 ごみ となってしまいます。 たまたま ごみが0だったら、 ch==0x41となりますが、そうでなければch!=0x41です。 str_charの中で、 文字と比較しようにも、chが「文字」を示していないので、「見つかりません」となります。 ch=0を入れると「正常」に動作する理由は、ごみを0にする効果があるからです。 printfによる直接的な違いはありません。 ただし、コンパイルによって生成される機械語は、大きく異なっている可能性があります。 その影響で、「ごみ」が0になりやすかったり、 ch に「ごみの無い領域」が割り当てられたりして、「正常」になっている可能性が考えられます。 さて、先程は、 ch=0x41とすると... と書きましたが、ここに「嘘」があります。 分割したときに、下のバイトから順番に並べるのを「リトルエンディアン」と呼びます。 おそらく、あなたが使っているであろう、IntelのCPU(やその互換CPU)を使ったWindowsでは、リトルエンディアンを採用しているので、上記のような動作をします。 しかし、逆に上のバイトから並べる「ビッグエンディアン」を採用している環境があります。 この場合 ch=0x41 は、メモリ上では 100番地 0 101番地 0 102番地 0 103番地 0x41 となります。 一方、scanf("%c",&ch)では、100番地に代入、ということに変化はありません。ch=0の後に実行しても 100番地 0x41 101番地 0 102番地 0 103番地 0 となり、 ch == 0x41000000 であって 0x41ではありません。 上で「正常」と書いてあるのは、このように「たまたま動作する」からであって、正しい手法では無いからです。
　基本的にNo.1の方と同じですが、 　関数に入った時に、 　　if( n<=1 ){ 　　　　　　return( -1 ); 　　} という2番目が存在しない場合に-１か何かを返すのか、 　何を返すのかが明確では有りませんね。（笑）
先の TransparenetPictureBox の回答者の物です。質問者さんがお使いになっているのは、純粋な C++ ではなくて C++/CLI という物なのですが、これは C# と同じ枠組を使ってプログラムを書く環境になっています。特に Web 上では C++/CLI よりも C# による記事の方が充実しているので、何か分からない事があれば C# の記事を探してそれを C++/CLI に翻訳する (或いは C# の .dll にしてそれを C++/CLI から利用する) というのも有効な一つの手です。(既に御存知でしたら済みません。) 英語とか C# とかでも OK ですか? その様な変換は perspective transformation だとか perspective deformation だとかいうのですが、"C# perspective" などで検索してみると幾らか出てきます。 やはり、標準の機能ではその様な変換には対応していない様です。標準では線形変換だとか精々2次元のアフィン変換しかないので、矩形は常に平行四辺形になります。(台形の形にするには perspective 変換 (～3次元アフィン変換+投射) だとかしなければならないんだった様に思います。)すると、自分で書くか、何処か別の所から持ってくるしかありません。 * 例えば以下でサンプルコードをダウンロードできます http://www.codeproject.com/Articles/36145/Free-I … (ダウンロードには会員登録が必要ですが、このサイトは昔からある良いサイトなので登録して損はないです) ↑の簡単な使い方の例は以下にあります http://stackoverflow.com/questions/5730236/persp … * 他にも下の様なページもありましたが、これはサンプルがリンク切れ?になっていますね… http://social.msdn.microsoft.com/Forums/vstudio/ … * Direct 3D が使える環境では以下のような方法もあります http://msdn.microsoft.com/en-us/library/windows/ …(v=vs.85).aspx (しかし C++/CLI の System.Windows.Forms 上で使うのは色々複雑だったような気が…。最近では XNA Framework が推奨されている様で、これを System.Windows.Forms 上で使う方法を調べれば良いのでしょうかね。)
ただ単に結果だけを知りたいなら、codepadというwebサービスを使えばいい。 http://codepad.org/
どこでも構わんです。 特定のディレクトリでしかコンパイルできないとしたら、 コンパイラのinstallに欠陥あり。
念の為に書いておきますが、私は #2の「最小二乗近似が目的なら、このFortranのプログラムを捨てて、最初からC言語で書く。あるいは、数値演算を得意とするツール(R,MATLAB等)を使う」が最適解だと思っています。 紹介だけしておいて、それはまったく動かなかった、というのはあまり好きではないので、動作客員しただけで、f2cを積極的にするめているわけではありません。 f2cは、C言語に変換されるのですから、あとは、C言語で定番の分割コンパイル→リンクでできるような気はします。 VisualCを使うなら、プロジェクトに追加することになるでしょう。 gfortranもGCCの一部なので、-cオプションでオブジェクトファイルにして、最後にリンクすればいいように思います。 または、gfortran a.f b.f c.f 等とソースファイル名を並べるだけでいいような気もします。
一言で言えば Func は &Func に暗黙的に変換されるからです。より詳しく書くと、関数型は function-to-pointer conversion 規則 (C++規格 [conv.func]) によって、暗黙的に関数ポインタ型に変換されるのです。 この変換規則によって、例えば getchar(); を (*****getchar)(); などと書く事すらできてしまいます。 (*&*&*&*&*&getchar)(); に変換される為です。 (寧ろ、どの様な動作の違いを期待されたのでしょうか。)
(1) 1 になる理由 std::ostream の operator<< がメンバ関数ポインタに対する overload を定義していないので、 規格 [conv.bool] の boolean conversion 規則が適用されて &Class1::f は (bool)&Class1::f に変換されます。 &Class1::f は null ではないので bool 的には true になります。 そして、ostream は true に対して 1 を出力するので、上のコードで 1 が表示されるのです。 なので、この出力に関しては処理系依存ではなくて、(規格準拠の処理系なら) 常に 1 が出力されるべきかと思います。 (2) 中身の見方 メンバ関数ポインタの「内容」を知りたければ union などを使って無理矢理 void* に変換するとか。。(規格的にはメンバポインタから通常ポインタへのキャストは定義されていません。) ------------------ union{ void (Class1::*mfp)(); void* ptr; } conv = { &Class1::f }; cout<<"&クラス::メンバ関数"<<conv.ptr<<endl; ------------------ 大体の処理系では、メンバ関数ポインタの「内容」はやはり実体のアドレスの様です。但し、「内容」が実体のアドレスなのか、或いはもっと違う種類のデータなのかは、既に回答された方のいう通り処理系依存なので、常にアドレスが得られるとは限りません。 (3) 実体はある > ２行目は実態が存在しないと思うのですが、あってますでしょうか？ メンバ関数にもちゃんと関数実体があります! なかったら実行できないではありませんか…。 (3) 後、用語が気になるので… * 実態→実体 * グローバルメソッド→グローバル関数 (メソッドは普通メンバ関数の事です) * メンバメソッド→メソッド or メンバ関数 (C++ 的にはメンバ関数です) 参考URL：http://stackoverflow.com/questions/2064692/how-t …
＞「入力されたデータをメモリ容量限界まで ＞保存可能にする。」 ＞なかなかそれという情報にネットで出会え ＞ていない状態です。 それをしてしまうと、プログラムがデータを 処理する為の作業領域用のメモリも無くなる のでプログラムとしては意味の無い物になる だけだからです。
(1) インスタンスメンバ関数は代入できない 既に回答がありますが、インスタンスメンバ関数のポインタは int (MPointerList::*)(int,int) という型であり、静的な関数のポインタ int (*)(int,int) とは異なる型です。そもそも、インスタンスメンバ関数を呼び出す時は引数 a, b だけでなく持ち主のオブジェクトインスタンス mP も必要なのです。その時の呼び出し方が、(mP.*memberFunctionPointer)(a,b) になる訳です。 (2) 静的メンバ関数は代入できる 因みに、インスタンスメンバ関数ではなく、静的メンバ関数のポインタは通常の関数ポインタと同じ型です。 呼出にオブジェクトインスタンスを必要としないためです。 -------------------- class MPointerList{ public: static int f(int a, int b){ return a * b; } }; FUNC_POINTER fp = &MPointerList::f; // OK -------------------- (3) オブジェクトインスタンスと一緒に取り扱う 「メソッド」と書いている辺り、C# のデリゲートや Delphi のメソッドポインタの様な使い方を期待していますか? (C++ ではメンバ関数の事をメソッドとは言わないので…。) 実は、デリゲートやメソッドポインタは、内部的には単なる関数ポインタではなく (オブジェクトインスタンスへの参照) と (メンバ関数へのポインタ) のペアです。C++ でも同様の事をしたければ、同じようにインスタンスへの参照とメンバ関数へのポインタのペアを取り扱う関数オブジェクトのクラスを用意すれば良いのです。 そして、C++11 でその様なクラスが標準ライブラリに追加されました。std::function です。Visual Studio 2010 以降など C++11 に (部分的に) 対応している最近のコンパイラで使えます (もちろん、古いコンパイラではコンパイルできないコードになってしまうという問題はありますが)。更に、C++11 のラムダ式と組み合わせればその様な関数オブジェクトの生成も簡単になります。 -------------------- #include <functional> using namespace std; int globalFunction(int a, int b){ return a * b; } class MPointerList{ public: static int staticMemberFunction(int a, int b){ return a * b; } int instanceMemberFunction(int a, int b){ return a * b; } }; int _tmain(int argc, _TCHAR* argv[]) { std::function<int(int,int)> fp; // もちろん、静的な関数は代入できる fp = globalFunction; // 静的なメンバ関数も代入できる fp = &MPointerList::staticMemberFunction; MPointerList mP; // &MPointerList::f と mP への参照から関数オブジェクトを生成し、fp に代入できる fp = std::bind(std::mem_fn(&MPointerList::instanceMemberFunction), std::ref(mP), std::placeholders::_1, std::placeholders::_2); // ラムダ式を使えば、上と同等の事をより簡単に書ける。 fp = [&mP](int _1,int _2) -> int{return mP.instanceMemberFunction(_1,_2);}; cout << fp(1,2) <<endl; getchar(); return 0; } -------------------- ★注意★ mP の寿命に注意して下さい。変数 mP の寿命が尽きた後も、fp の中に mP への参照が残りますが、この時に fp を呼び出すと異常動作します。変数 mP のスコープの外で fp を使いたい場合には、MPointerList を動的に確保して寿命を管理する必要があります。その為には、C++11 の std::shared_ptr (～寿命自動管理機能付きポインタ) を使うと楽です。 -------------------- #include <memory> 中略 std::shared_ptr<MPointerList> mP2=std::make_shared<MPointerList>(); fp = [mP2](int _1,int _2)->int{return mP2->instanceMemberFunction(_1,_2);}; //※参照キャプチャ [&mP2] ではなく値キャプチャ [mP2] --------------------
(1) C++でベクトル演算する方法はわかる。パターンベクトルに分解する方法がわからない。 (2) (紙とエンピツとで)パターンベクトルに分解する方法はわかる。C++で計算する方法がわからない (3) (1),(2)ともわからない のどれですか? 例えば、「C++ ベクトル演算 ライブラリ」で検索すると、複数のライブラリが見つかります。 中には無料のものがあります。 これらを使うと、机上で数式を書くような感覚でベクトル演算を実行できます。
そんな誤差より、先を予測するあなたのシステムの　不確実性の方が　はるかに大きい。
using System; using System.Threading; using System.Windows.Forms; delegate void EventHandler(); public class Parent:Form{ EventHandler handler; Button btn; public Parent(){ btn=new Button(); btn.Text="Exec"; btn.Click+=this.btn_Click; Controls.Add(btn); } private void btn_Click(object sender, EventArgs e){ btn.Enabled = false; // ★そもそも処理は UI スレッドではなく別スレッドでするのでは?★ // UIスレッドで処理をすると終わるまで Form が固まります。 // Form のメッセージを適宜処理する為に Application.DoEvents を Exec 内で定期的に呼び出す事もできますが、 // 同期的な実行になるので今回の非同期的に実行するという目的に適いません。 new Thread(new ThreadStart(()=>{ handler = new EventHandler(ChildEventReceived); Child child = new Child(); child.SendEvent += handler; child.Exec(); })).Start(); } void ChildEventReceived(){ // ★Form.BeginInvoke を使えば、その Form の UI スレッド上で非同期的に実行される。★ this.BeginInvoke(new Action(()=>{ MessageBox.Show("Child State Received"); btn.Enabled = true; })); } public static void Main(){ Application.Run(new Parent()); } } class Child{ public event EventHandler SendEvent; public void Exec(){ Thread.Sleep(1000); // 重い処理など // ★イベント自体の発火は同期で良いかと思います★ // 同期的に実行するかどうかは handler に任せた方が自然だと思います if(SendEvent!=null)SendEvent(); } }
パッと見、問題なさそうに見える…けど main()が閉じてないですな。 あ、あと戻り値返していないか。 わざとなのか、ただ単にコピペミスなのかは不明ですが。 無料のコンパイル環境を構築する手段はありますので自分で確認した方がよいかと思われます。 # 既にそういう回答は貰っているようですし。別の質問で。
すみません。No.4の訂正です。 > fwriteなどでまとまったサイズを～ 正しくはfreadでした＾＾；
はっきりいってしまうと, 言語の規格上「変数がどのメモリ領域に配置されるのか」というのは瑣末なことでしかありません. 真に大切なのは「オブジェクトが (時間的あるいはソースコード上の) どの範囲で有効なのか」です. 例えば void foo() { int i = 0; for (i = 0; i < 100; ++i) { printf("%d\n", i); } } という関数 (C だけど) では, 変数i が「int i = 0; の行から関数の最後まで有効である」ことさえ知っていれば, どのメモリ領域にあろうと何も問題ありませんよね? その意味で, 規格において「スタック領域」やら「ヒープ領域」やらというものを持ち出す必要はないのです. もちろん「現実の機械」で上のプログラムを使うとすると変数i はスタック領域に置くことになるでしょうが, それはあくまで 「int i = 0; の行から関数の最後まで」という変数i の有効範囲を実現するためにはスタック領域に置いた方が都合がいい だけであって, 規格で強制されているわけではありません.
おはようございます。 想像になりますが、とりあえず、OnPaint内にカウンタを置いて、それをディスプレイさせて他のメッセージハンドラが呼ばれたときにカウンタが上がっているかとか、 そういった感じで、探っていくしかないと思います。 後は、いくつかの関連していると思しきメッセージハンドラのログを出力するとかです。 後、一応、グラフィックスオブジェクトの作成と破棄の回数があっているかを確認してみてください。
>なるほど、ヘッダファイルの中にネストしてnamespaceが有るのではなく、 >namespaceの中にネストしてヘッダが有るということですね。 ヘッダファイルはネームスペースとは無関係ですよ。 単にヘッダファイルで分けて書いてあるだけ。
Javaを本当に理解していて、勉強法も身につけているなら、そんな物は不要であることが分かるはずなんですけどね。 「本、オンラインなどは無理です。」って段階でJavaの理解度も怪しいです。
オンラインで動作するコンパイラを使って確認する という手はいかがでしょうか。 例) http://ideone.com/
「いくらなんでもそれはないだろ」的に巨大な間違いがあるなら, 突っ込んでいいと思いますけどね＞#5. とよそ向けに書いておくけど, 今までの回答で言われたことを理解できてる?
iを使ってる行にbreakpointを置いてcondition 1 i==1とするのはだめですか。
演算子の場合、少々特殊な事情がありますから。 たとえば、演算子 new は、 Foo *aFoo = new foo(); という形の使い方をします。 これを、内部的には、 Foo *aFoo = new(sizeof(Foo)); という形で呼び出します。 というわけで、普通の関数は、定義したそのままの形で使いますが、演算子の場合、ソース上の記述と、それを、オーバーロードされた関数としてみたときの形が異なります。 new の場合、上記のように変形されることを前提として使用しますから、最初の引数は、size_t でないと困るわけです。
for (bango=10;ten>=1;bango=bango-1) を for (bango=10; bango>0;bango=bango-1) にする。
// 画像を保存する変数を作成します。 TPicture* Picture = new TPicture(); // 描画画像を変数に保存します。 Picture->Assign(Image1->Picture); // 画像をクリアーします。 Image1->Picture = NULL; // コピーした画面を複写します。 Image1->Picture->Assign(Picture);
monthCalendar.SelectionEnd.Subtract(monthCalendar.SelectionStart).Days + 1
doubleならdouble型であり，double *ならばdoubleへのポインタ型です。
ついでだけど, 今さら gets もなんだかなぁと思う.
int sum = 0; for (i = 0; i < 5; i＋＋) sum += vc[i];
Dictionary<string, Dictionary<string, string>> value = new Dictionary<string, Dictionary<string, string>>(); value["A"] = new Dictionary<string, string>(); // これと value["B"] = new Dictionary<string, string>(); // これを追加 value["A"]["0"] = "a0"; value["A"]["1"] = "a1"; value["A"]["2"] = "a2"; value["B"]["0"] = "b0"; value["B"]["1"] = "b1";
これはunionが分からないのではないでしょうか？ unionは同じ場所を名前や型を代えて宣言する方法ですよね？ name.firstName.[0]もname.lastName.[0]も全く同じ場所のデータですよ。 一番大きなサイズが取られますが先頭は同じ場所です。 例えば union Person { char cFirstName[10]; char cLastName[10]; char cAddress[255]; } で終端コードまで計算するコンパイラならsizeof(Person)は256です。 通常は255です。 cFirstName[0]を'A'に変えたら、cLastName[0]もcAddress[0]も'A'に変わります。 Unionですから。 structを使えば、期待するサイズが得られるのではないでしょうか？
CSV形式に出力するだけなら、表示をしているprinf関数のところを printf("%2d番目,%d\n", a+1, n[a]); のようにすればいいと思いますが、結果をCSV形式でファイルに出力したいということですと、 こんな感じでしょうか。 fp = fopen("output.csv", "w"); fprintf(fp, "小さい順:\n"); for(a=0; a<N; a++){ 　　fprintf(fp, "%2d番目,%d\n", a+1, n[a]); } fclose(fp); return 0; //注意 fpはmain関数の最初で int i, a, n[N], min, temp; FILE *fp; と宣言してください。 それと字下げに全角スペースを使いました。 コピーする場合には注意して半角スペースかタブに置き換えてください。
>エラーの内容は「初期化されていないローカル変数 'b' が使用されます」となっています。 　b = &a; とか、 　struct XYZ c; 　b = &c; で、ポインタ変数bを初期化（bを　struct XYZ　のデータのどれかを指す）すれば、いいだけではないですか？ 解説 struct XYZ a = {12,999999,1.41421356},*b; は、 　struct XYZのデータ a と 　struct XYZのデータを指すポインタ変数 b を定義しています。 　aの中身は　 {12,999999,1.41421356}　です 　bの中身はゴミ（何を指しているか不明）です 　b = &a; ポインタ変数 b はstruct XYZのデータ a を指します 　struct XYZ c; 　b = &c; struct XYZのデータ c を定義し、 cの中身はゴミですが、 ポインタ変数 b はstruct XYZのデータ c を指します この直後に 　set_xyz(b,a.x,a.y,a.z); を実行すれば、ポインタ変数 b の指すstruct XYZのデータ（今回はaやc) に　a.x,a.y,a.z　の３つのデータが書き込まれます。
組み込み屋としてはレジスタと言いたいところだけど#5に一票。 下手に例えるより実際のモノで把握しとかないと色々とあとが面倒なので。
// No.1 の続きです。長くて申し訳ない Bitmap^ back; Graphics^ backGraphics; void UpdateBuffer(){ if(back==nullptr){ back=gcnew Bitmap(Width,Height); backGraphics=Graphics::FromImage(back); }else if(back->Width!=Width||back->Height!=Height){ delete backGraphics; delete back; back=gcnew Bitmap(Width,Height); backGraphics=Graphics::FromImage(back); } } protected: virtual void OnPaintBackground(PaintEventArgs^ e) override{ ContainerControl^ container=dynamic_cast<ContainerControl^>(Parent); if(container!=nullptr){ this->UpdateBuffer(); backGraphics->Clear(BackColor); Rectangle rect=e->ClipRectangle; rect.Intersect(Rectangle(Point::Empty,this->Size)); if(!rect.IsEmpty){ this->DrawBackgroundControl(backGraphics,rect,container,Point(-Location.X,-Location.Y)); int i0=container->Controls->IndexOf(this); if(i0>=0){ for(int i=container->Controls->Count;--i>i0;){ Control^ ctrl=container->Controls[i]; Point offset=Point( ctrl->Location.X-this->Location.X, ctrl->Location.Y-this->Location.Y); Rectangle rect2=rect; rect2.Intersect(Rectangle(offset,ctrl->Size)); if(!rect2.IsEmpty) this->DrawBackgroundControl(backGraphics,rect2,ctrl,offset); } } } e->Graphics->DrawImageUnscaled(back,0,0); }else{ this->PictureBox::OnPaintBackground(e); } } }; //------------------------------------- // 使用例 public ref class Form1:public Form{ public: Form1(){ SetStyle(ControlStyles::SupportsTransparentBackColor,true); SuspendLayout(); Image^ image=Image::FromFile("test1.png"); // 適当な画像 // ★PictureBox の代わりに上で定義したTransparentPictureBox を使う TransparentPictureBox^ pictureBoxA=gcnew TransparentPictureBox; pictureBoxA->Location=System::Drawing::Point(10,10); pictureBoxA->Size=System::Drawing::Size(100,100); pictureBoxA->SizeMode=PictureBoxSizeMode::StretchImage; pictureBoxA->Image=image; pictureBoxA->Opacity=0.3f; // ★プロパティ Opacity に不透明度 (0.0f = 完全に透明、1.0 = 完全に不透明) を指定。 Controls->Add(pictureBoxA); PictureBox^ pictureBoxB=gcnew PictureBox; pictureBoxB->Location=System::Drawing::Point(60,60); pictureBoxB->Size=System::Drawing::Size(100,100); pictureBoxB->SizeMode=PictureBoxSizeMode::StretchImage; pictureBoxB->Image=(Image^)image->Clone(); Controls->Add(pictureBoxB); this->Size=System::Drawing::Size(200,200); BackColor=Color::FromArgb(0xFF,0xDD,0xDD,0xFF); ResumeLayout(); } public: static void Main(){ Application::Run(gcnew Form1()); } }; int main(){ Form1::Main(); return 0; }
まず <stdio.h> などは言われるように「非推奨」なので「最終的には変更する」ことを前提にした方がいいでしょうね (たぶん C++1y までは大丈夫だと思うけど). とはいえ, 単純に <cstdio> を #include しててきとうに std:: を付ける だけでもだいたいいけますが. あえて <iostream> に直す必要はないです. まあ, ヘッダ以外は「とりあえず拡張子だけ変えてコンパイルエラーが出たら考える」という行きあたりばったりな方法でもなんとかなっちゃいますけどね.
質問が抽象的なので伝わらないのでは。 言えるのはCOMサーバー(3DマイホームデザイナーPRO7)が 起動していないとクライアント側(MFCアプリ)から操作出来ないて事ぐらいかなと。
宿題の丸投げですかね。 C言語には入出力の概念がありませんから１、２，３ともに作成不能ですね。
libcurl の C/C++ バインディングをどうぞ http://curl.haxx.se/libcurl/c/ 参考になるサンプル http://d.hatena.ne.jp/irasya/20090726/1248610519
AAA.c を AAA.cpp にしてしまえばすむことでは？
>TFillTextFlags() << TFillTextFlag::RightToLeft, これって必要ですか？？ C#やWindowsAPIで同様のフラグを使ったことはないのですが… "Are you?"は右から左に書くと"?Are you"になるんですかね？ # C#ならそれほど掛からずに試せそうではありますが…未確認。
gnuplot を呼び出す
C の規格に従っているのであれば, 「なってしまう」ではなく「ならなければならない」のです. もちろん「電源を OFF にするかどうか」などまったく無関係. ああ, あくまで「それらの関数が C の規格に従っていれば」という前提ですよ. その前提を壊していいのであれば, 好き勝手にしてもらって構いません.
form2への参照の仕方が間違っていることが原因ですね。 いくつか方法はありますが、form2をローカル変数にするのが解りやすいのでは？ namespace オブジェクト検索 { private Form2 form2; public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { if(form2 == null){return;} form2.Text += "*"; } private void button2_Click(object sender, EventArgs e) { form2 = new Form2(); form2.Show(); Application.DoEvents(); } } }
追記。 「配列の各要素に先頭から順に１，２，３，４，５を代入して表示」という仕様は満していますが、 こんな、コピー&ペーストでやるなら、配列を使う意味がありません。 課題が求めているのは、添字を変化させて、代入文一つ、printfの文一つになるようなプログラムでしょう。
>今でもまだ、APIを使用しなければ駄目でしょうか。 そもそも、「今でもまだ」とは、どういう意味でしょう Readonly属性は、入力コントロールに対する変更を禁止にするだけの属性です そして、入力コントロールなのですからキャレットが存在して当たり前です キャレットの主な役割は、移動、変更、コピー＆ペーストがあります このうち、変更が禁止になっただけなので、移動とコピーのみが出来ますよ という属性です 「今でもまだ」、まるでこの仕様が不具合で、まだ直っていないとでも 言いたそうですが、もともとがそういう仕様なのですから 今でもまだ、どころか、この先も変わる事は無いです
// resultを動的に確保してない点が気になりますが では std::basic_string で。 #define _UNICODE #define UNICODE #define _AFXDLL #include <afx.h> #include <tchar.h> #include <string> #include <iostream> typedef std::basic_string<TCHAR> tstring; int main() { const wchar_t nc = L'\0'; CString input = L""; input += L"abc"; input += nc; input += L"def"; input += nc; input += L"ghi"; input += nc; input += nc; tstring buffer(static_cast<const _TCHAR*>(input), input.GetLength()); const _TCHAR* result = buffer.data(); for ( int i = 0; i < buffer.size(); ++i ) { if ( result[i] == L'\0' ) std::wcout << "'\\0'" << std::endl; else std::wcout << result[i] << std::endl; } }
□□token1 = strtok(str, ","); □□token2 = strtok(NULL, ","); この働きは、 http://hitorilife.com/strtok.php を読んでください。
同じ人っぽいですね。 http://detail.chiebukuro.yahoo.co.jp/qa/question … http://detail.chiebukuro.yahoo.co.jp/qa/question … 私はもう答える気がありませんので、答えたい方は参考にしてください。
一つ、大きな勘違いをしています。 PATHは「実行ファイルの場所を探すため」のものです コンパイルに使うソースファイルを指定する場所ではありません。 >今日の作業は最後にあったC:\Program Files (x86)\mingw-w64\i686-4.9.0-posix-dwarf-rt_v3-rev2\mingw32\libexec\gcc\i686-w64-mingw32\4.9.0\ >　　　を削除後 ?　新たに一番最後に　gccコンパイルするファイルががある、examplel.cのPathであるC:\msys\1.0\home\Administrator\を >　　を追加しました。 MinGW用のGCC4.9用と思われるものを削って (実行ファイルではない)「gccコンパイルするファイルががある」を加える というのは、逆効果です。 ・そのCD-ROMの説明に、PATHに追加するものとか、説明は無いのですか? ・gcc-core-3.4.2-20040916-2.tar.gz を解凍したファイルはどこの置きましたか? あるいは、どんな方法で解凍しましたか? 検索すると、C:\MinGW\bin にあることが多いようですが、どうなってますか? また、全体的に古いバージョンのようです。 新しい版だと、各種パッケージもまとめてインストールできるので、そちらに切り替えてもよいでしょう。
関数呼び出しっぽく書けば operator>>(cin.operator>>(skipchar), str); または operator>>(skipchar(cin), str); みたいな感じですか。 やってることは ------- cout << "いくつかの文字を入力する:"; char c; for(int i = 0; i < 10; i++) cin >> c; cin >> str; ------- と同じと思います。
#3 への補足にあるリンク先に書いてあることって, 本質的に (1) C++ のソースをそのまま C のソースだと思っちゃダメだよ ってことだよね? でも, 今質問で挙がっているのは (2) C から C++ への変換 であって, それは (1) とは全く違うことです. そこはきちんと理解してください. まじめな話として「C としては正しいけど C++ としては間違い」という例は C++ の規格でもきちんと触れられているんだけど, 根本的に何とかしなきゃならないのは ・構造体 (などの) タグで使う識別子と「普通の識別子」で名前空間を共有する ・void * とのポインタの変換 ・C++ で新しく導入されたキーワード くらいしか思いつかない (その他はほぼ「そんなアホなプログラム書くな」と一蹴すればいい).
ＩＮＤＥＸ順序と言うらしいです。メモリ上の割りつけは左側のＩＮＤＥＸが最初に変化するような割り付けになります。すなわちメモリ上の割り付けは ａ（１，１）、ａ（２．１）・・・ａ（１００，１）、ａ（１，２）、ａ（２，２）・・・ａ（１００，２）というように続きます。 ａ（１００，１００）をｓｕｂ側て　ａ（１００，１）で受けても差し支え訳です。アセンブラに落とされたリストを見れば直ぐ分ります。
同じくこんな風に書いたことないし規格をざっとななめ読みした限りでは「どうなるか」も見付からなかったんだけど, 結局実体としては BaseClass::InnerClass しかないから多重定義, という解釈でいいとは思う＞#2. ぶっちゃけ static なメンバのようなもの, かな. ただ, 個人的にはこんなのコンパイルエラーでいいと思う. しかし, 何をしたいんだろう....
for r=0 to 100 step 10 for t=-90 to 90 step 10 tt=t*pi/180 x=r*cos(tt) y=r*sin(tt) print using"###.#####":r,t,x,y next t next r stop : end
#include <stdio.h> #include <math.h> void main(void) { double x,y; for (x = 0.0; x <= 360.0;x += 10.0) { y = sin(x * 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 / 180.0); printf("%lf\n",y); } }
#include <stdio.h> float heikin(float x, float y) { return (x + y) / 2; } int main(void) { float x, y; printf("x="), scanf("%f", &x); printf("y="), scanf("%f", &y); printf("平均=%f\n", heikin(x, y)); return 0; }
合計の出力は、for文の外。 #include <stdio.h> int main(void) { int sum, num[20], i; for (sum = i = 0; i < 20; i++) { printf("%d個目=", i + 1), scanf("%d", &num[i]); sum += num[i]; } printf("合計=%d\n", sum); return 0; }
フォームのKeyPreviewプロパティで対応できるのでは？ KeyPressなどのキーイベントをすべてフォームが受け取るようにする http://dobon.net/vb/dotnet/form/keypreview.html さらに、キーがEnterだったら、処理をフォームのイベントで終わらせることも出来る Form1_KeyDown()の中で 　　If e.KeyCode <> Keys.Enter Then 　　　　e.Handled = True 　　End If とすれば、コントロール側にEnterキーのイベントが飛ばない。
追記。 SALは、主に、バッファサイズを超えて書き込みされて意図しないコードを実行されてしまうなど、プログラムの脆弱性を発見する為に用いられています。 C言語では「文法上はエラーにならないが、書いても意味の無いコード」を書けてしまいます。 例えば、 void main(void) { bool a; int b,c,d; b=2,c=3,d=4; a=b,c+d; } bをaに代入して、cとdを足し算していますが、足し算の結果を何処にも格納していません。計算するだけで結果を捨てています。 C言語では、文法上、上記のような書き方も許されます。 上記のように「計算だけして結果を使わずに捨てる」って書き方が文法上は可能なので void main(void) { strlen("abcd"); } と言う書き方も、文法上は可能です。 でも、こういうのは、たいていは「そのつもりが無くて、うっかり」が殆どです。 最初の例でも「<」を打つべきなのに、シフトキーを押し忘れて「,」を打っていたのです。 そこで、SALと言うのが開発され、関数の戻り値に「返り値をちゃんと使ってるか呼び出し元でチェックが必要」と言う注釈を付けたり、引数が入力か出力か、入力であればどういう内容なのか、注釈をつけたりして、文法上はエラーにならない「うっかりミス」を検出できるようにしたのです。 それらが、_Check_return_という注釈だったり、_In_z_と言う注釈だったりします。 これらの注釈が付いていれば void main(void) { strlen("abcd"); } と書いた時に「strlen()が返した結果を呼び出し側で使っていません」と言うエラーを発生させる事が可能になります。
MS製品の場合、一般的にタイトルバーの"ヘルプ(H)" メニューを選択して表示されるヘルプ画面の"目次" からプログラミングガイドやリファレンス等のドキ ュメントが参照できます。 関数やコマンドの全てはリファレンスに記述されて います。 ＃ディスク容量の節約の為に、ドキュメントをイン ＃ストールしていない場合は、追加でインストール ＃する必要があります。(残容量に注意) ＞上記の説明からint型と推測して使うしかないのでしょうか？ ちゃんとsize_t型と記述されてますが？ ＃処理系依存の型なので、int型とは決まっていません。 予め、intの範囲である事が分かっていて、コンパイル時 に警告(warning)が出るならキャスト演算(int)を付けて ください。
そもそも、GCCはインストールできているのでしょうか? MSYS/MinGWにしろ、Cygwinにしろ、通常は、GCCをインストールすると、ls等と同じディレクトリに実行ファイルが置かれるので、ls や sh が動作するのなら、gccも同じ場所にあり、Pathも設定されています。
あーと、自分の言いたかったことが伝わってないようですみません。保存時に保存用 BMP を生成するという手順を変えろと言うつもりは全くありません。その手順にひと手間を追加してみたらどうかということです。 たとえば、 > 主にg->FillEllipse等で円を描画しています というのであれば、その FillEllipse で使用したパラメータがあるはずです。 そのパラメータと、FillEllipse で描画したという事実を覚えておくということです。ここで保存用 BMP に描画はしませんし、そもそもこの時点では保存用 BMP は存在しないはずです。 そしていざ保存という時点で保存用 BMP を生成し AA をDrawImage したら、「そのパラメータと、FillEllipse で描画したという事実」を覚えていたので、続けて保存用 BMP に覚えていたパラメータで FillEllipse すれば、画面で見えている図と同じ絵の BMP ができるのではないか、というのが私の提案した代替手段です。 ええ、わかっています、描く円は一つだけじゃないし、そもそも描くのは円だけじゃないという事を。 ですから、複数回複数種類の描画を再現するには、 ・何らかの描画を行ったという事を表す抽象クラスを作って、それを各描画方法ごとに派生させたクラスを作る。 ・画像編集開始時に上記抽象クラスの List を生成する。 ・何らかの画像編集を行うごとにそれに対応する派生クラスを生成し、上記 List に add する。 ・画像保存時、保存用 BMP を生成し AA の画像を DrawImage した後で上記 List の順に行った描画を保存用 BMP に再現する。 ということを行えばできるはずです。 「これだけ変えたら現状の描画が変わるじゃないか」とお思いかもしれませんが、大丈夫です。最初のクラス追加は処理の流れには関係しませんし、2・3 番目は現行の処理を行っているメソッドに簡単な処理を追加するだけで、処理にかかる時間も「BB描画時にちらつき等」が出ることはまずないはずです。 確かに、目の前に描画した結果があるのに回りくどいことをしているように思うかもしれません。 しかし、上記の変更を行えば、現状では無理な画像編集の Undo/Redo もできるようになります。
お約束の「ヘッダに実体を定義してはいけない」ってヤツです。 code.hに記述した内容はall_includes.hに適用されます。 all_includes.h内で#include "code.h"していますからね。 で、all_includes.hの内容はそれぞれ audio.c、comm.c、env.c、event.c、main.c、misc.c、mount.c、net.c、task.cに適用されます。 つまり、code.hに記述した内容も audio.c、comm.c、env.c、event.c、main.c、misc.c、mount.c、net.c、task.cに適用されます。 それぞれのオブジェクトファイルにPVC_TCP_SIG_CODE[100]が存在します。 リンクする段階でどのオブジェクトファイルのPVC_TCP_SIG_CODE[100]を使用したらいいのでしょうか？？？？？ というエラーです。 extern宣言して、実体をどこかのソースファイルのみに記述する。 というのが一般的な対処方法です。 # static宣言にすればとりあえずリンクは通るかもしれませんが…無駄が出ますねぇ。 # 今回はconstなので、メモリに無駄が出るだけ…で済むかと思われますが。 http://d.hatena.ne.jp/saitodevel01/20110321/1300 …
>なぜそれではダメなのか、よくわからないです。 #4,#7の方が説明されていますから、それらをよく読んで考えてみてください。
すみません, 忘れてました. CRC を計算するときには 1. 与えられたデータの下位 (ビット送りの反対側) に「初期値」を付加する 2. 生成多項式で割って余りを求める 3. 「出力XOR」との排他的論理和を計算する という手順をとります. つまり, 「初期値:0x0000、出力XOR:0x0000、左送り:9AA8」 は (以下 16進で表記します) 1. データ列 41 42 43 44 に初期値 0000 を付加して 41 42 43 44 00 00 を得る 2. それを生成多項式で割って余り 9AA8 を得る 3. それと出力XOR 0000 との排他的論理和を計算して 9AA8 を求める として得られた値です. で, 「CRCを含めたデータを再CRCする」というのはこの場合 データ列 41 42 43 44 9A A8 に対して CRC を計算する 言い替えれば「データ列 41 42 43 44 に対し 9A A8 を初期値として CRC を求める」ということです (初期値の設定ができないので, 質問文に挙がっている CRC16.exe ではこのような計算はできません). 最後にある 「尚、上記ソフトで 初期値:0x0000、出力XOR:0x0000、左送り:9AA8 この場合のみCRC追加しての再CRCはゼロになりました」 はおそらく 41 42 43 44 9A A8 というデータを入力した結果だと思いますが, それは実際には 41 42 43 44 9A A8 00 00 に対して CRC を計算しています (41 42 43 44 9A A8 に対して CRC が 0 になるならこれに対しても 0 になるけど, それは「CRC が想定しているチェック方法」ではない). ここまでは初期値 0000, 出力XOR 0000 なので簡単ですが, その他の値を使った場合には得られた CRC を「適切に」変化させた値を初期値にしないと「CRCを含めたデータを再CRCするとゼロになる」などという都合のいいことにはなりません. ところで, 初期値と出力XOR が両方とも 0 なら右送りでも (左送りと同じ事情で) 最終的な CRC を 0 にできるんですけど, どうでしょうか?
C言語には入出力がありません。 従ってキーボードから入力することも、表示することも出来ません。 どうしてもと言うならハードウエアの詳細を記述するかオペレーティングシステム、コンパイラの種類などを記述すべきです。
外していたらスミマセン。（いちおう、私もVS2008使いです） .rcと.apsファイルに相違が発生しているのかもしれません。 プロジェクトを閉じて、.apsファイルを削除してから、再度プロジェクトを開いてみるとどうなりますか？.apsファイルがない場合は、.rcファイルから自動的に再生成されます。 VSは、.rcファイルよりも.apsファイルの方を参照して、リソース編集をしているようです。その編集結果を、.rcに戻すような動作だと理解しています。
この回答はまともな解答になっているかどうか。。。 まず、Computeが何のオブジェクトを返しているか、デバッグして確かめて見る必要があるかと思います。もし、Int32だったら、もうそれまでですし。 あるいは、sの計算式にSQLのdecimalへのキャスト関数のようなものをつけるという方法もあるでしょう。そうすれば、decimalで返ると思います。 最悪、多倍長精度計算のライブラリをどこかから探してくるという方法も考えられます。その場合、自分で式を計算するプログラムを組む必要があるでしょう。でも、decimalでいいんですよね？
No9です。一部訂正です。 エスケープ文字 = 特殊な意味を持つ文字(制御文字等)の直前に記載することによりその意味を無効にする文字、もしくは、直前に記載することによって通常の文字を特殊な用途として利用できるようにする文字。
マイクロソフトのXMLパーサ（MSXML）のXML文書へのインターフェースポインタ（スマートポインタ）です。 まあクラスといっても差し支えありません。 ただし、自分で宣言するものではなく、マイクロソフトのDLLをインポートすることによってインクルードファイルが生成されて、その宣言が使用されるものです。 #import "msxml.dll" named_guids raw_interfaces_only をいれてあげればとりあえずは解決するかも。"msxml.dll"はOSのバージョン、MSXMLのバージョンによって異なる場合があります。 これはCOMの知識がないと難しいかもしれません。 敷居が高いかもしれませんが、頑張ってください。
ちなみにダイクストラ法そのものは「ちょう基本」です. というか, これが分からないようだと他のグラフ理論的なアルゴリズムはきついんじゃないかな.
#3 補足 Visual C++ なら for ( CFooData item : array ) を for each ( CFooData item in array ) と書いてもいいみたい。 for each はあくまで Visual C++ の独自仕様だろうからオススメしません。
最初に _serialPort_DataReceived 関数で 5 Byte 読んで その後 _serialPort_DataReceived 関数で 40 Byte を読んだら、 途中からしか取れなかった。　関数の中には、「通信ポートを オープンしてるなら受信バッファをクリアする」 if (true == serialPort.IsOpen) { serialPort.DiscardInBuffer();//受信バッファをクリアする } という処理が入っているのですから当然そうなるのではないですか？ 読込の関数を読んだ時点からデータの受信を開始するとした為、 それまで受信していたデータを捨ててまっさらな状態にする為 受信バッファをクリアしてるのですから そう考えれば解決方法は簡単で 受信バッファをクリアするの部分を受信バッファにある分、 全て別のバッファに読む様に修正して その別のバッファの中身を捨てるか、この後の本来の受信処理と つなげて処理するかを、通信フロー等を考慮しながら決めて 通信プログラムを作成します
「過去類似の研究を行っていた先輩が残してくれた実行結果と異なっていた」としても, パラメータが違っていたら当然違う形になりえるわけだからそれが直接「実行結果が間違っている」ことにはつながらないのでは? で http://oshiete.goo.ne.jp/qa/8642263.html は放置ですか?
はじめまして、通りすがると申します。私も同じようなものを作ったことあります。 私の場合は、自力でロジックを考えました。ただ、Ｃ＃ではなくVB.NETにて作りました。 考え方は、数字を文字列として受け取り、それを４桁ずつ区切って、区切った文字をintegerにキャストすます。 キャストした数値は、内部的に加減乗算し、その結果を後で結合していく方式です。 結合時といっても、単純に結合するのではなく、４桁で桁あふれ等が起きた場合、左右隣の数値に１加える か、減算するかを判断して結合していきます。加減のロジックができれば、乗算はそれらを利用して算定する 方式です。この方式はノートなどで手動で計算するようなイメージのロジックになると思います。 vb.netだと２００～３００ステップぐらいで作成した記憶があります。Ｃ＃だともう少し多くのソースを必要とする かもしれません。考え方は色々とあるとおもいますがこれも一つの例としてとらえてください。
次のurlはSolaris→AIXでの注意点というわけではありませんが参考にはなるかと思います。 http://otn.oracle.co.jp/technology/global/jp/sdn …
C言語以前に日本語を学ぶべきだと思う. 「という問題だったと思います」「らしい」なんて, 質問する人間が使うような言葉じゃないよ.
>ところでmallocの間違いを指摘されていますが、 >どのように問題となるのでしょうか。 >心当たりがあるといえば、\0がないので、 >ゴミを表示するのではないか、と懸念されますが、 その前にたぶん吹っ飛びます。 確保した領域に'\0'がないと、 while(*s1) s1++; で見つかるまでポインタをインクリメントし続けます。 バッファオーバーランって聞いたことありませんかね？ で、はみ出した場所に書き込もうとして破壊します。 # OSが止めてくれるかそのまま動作してさらに悲惨な状況になるか……。 >memsetでdstを'\0'で埋めれば良いということでしょうか。 それでもいいですし、確保した最初の場所だけに0x00を入れる。でもOKでしょう。 # 私ならmemset()でクリアする。(というかcalloc()使う)
画像認識なんてしようとするから難しくなる。 画面表示しているアプリケーションソフトから、表示テキストの情報を読み出せばいい。 マウスポイント下のコントロールのハンドルを取得してGetTextすればできるのではと思います。 WindowFromPoint 指定された座標を含むウィンドウのハンドルを取得します。 http://msdn.microsoft.com/ja-jp/library/cc364874 … http://naoko.wankuma.com/win32api/win32api_0010_ … ちょうどそういう事をしているソフトを見つけました。 ポイント位置の文字列取得 http://itpro.nikkeibp.co.jp/article/COLUMN/20100 … http://www.forest.impress.co.jp/docs/serial/okin … http://www.vector.co.jp/soft/win95/util/se454390 … このソフトを起動したらマウスポインタ下のコントロールの文字を拾ってくれます。 もちろん画像イメージで描画してある文字の認識は無理ですけど。
せめて ・どのような動作を期待しているのか ・実際にはどのような動作になったのか くらいは書いてほしい.
実行できない? コンパイルできないんじゃないですか? > class OFConsoleApplication; > class OFCommandLine; 本体、つまり class OFConsoleApplication { ..... }; はどこにあるのでしょうか? ofconapp.h の中にありますか?
> Javaでは引数の有るコンストラクタしか宣言しなかった場合はデフォルトコンストラクタは > 作られなかったと思うのですが、c++では引数のないデフォルトコンストラクタができてるのでしょうか？ Java と同じく、何らかのコンストラクタを定義してしまうとデフォルトコンストラクタは作られません。 > また、デフォルトコンストラクタが出来ていなかった場合、 > Hoge hoge; > というようにプリミティブ型のような変数宣言の仕方で引数有りのコンストラクタを呼ぶことは > 出来るのでしょうか？ Hoge hoge(10); という具合に呼べます。 http://msdn.microsoft.com/ja-jp/library/s16xw1a8 … あと、C++ では（引数なし）コンストラクタだけではなく、コピーコンストラクタ、デストラクタ、および代入演算子も定義しなければデフォルトのものが生成されるので注意してください。 http://docs.oracle.com/cd/E19205-01/820-1213/bka … http://tercel-tech.hatenablog.com/entry/2012/11/ …
何だか変数の宣言とインスタンスの生成がごっちゃになられているような。 >しかし、Javaでは型の宣言はあくまで型を宣言しただけだったのに対し、 ここでいわれている「型」というのは「クラス」の事だと思いますが、 Javaでいう「クラスの宣言」は public class AAA { ... } とクラスを書く事ですけど。 ちなみにC++では「宣言」ではなく「定義」になります。 >Hoge hoge;　とするのと Javaではhogeという名前の変数(インスタンスの入れ物)を用意しているだけですが C++ではhogeという名前の変数であり、その変数はインスタンス自身です。 見た目は同じ書き方ですが意味が違うんです。 C++でJavaと同じような事をするなら Hoge *hoge; になります。 >Hoge hoge = new Hoge(); C++だとエラー。
複数の演算子が使われている式を計算する場合、 例1) A # B $ C どの順番で計算を行うかは、演算子の優先順位と結合規則を元に決まります 例2) 優先順位が # < $ なら A # (B $ C) 例3) 優先順位が # > $ なら (A # B) $ C 例4) 優先順位が同じ、結合規則が「右から左」なら A # (B $ C) 例5) 優先順位が同じ、結合規則が「左から右」なら (A # B) $ C 参考) http://msdn.microsoft.com/ja-jp/library/2bxt6kc4 … ご質問のケースですが、 アロー演算子どうし → 優先順位が同じ、結合規則が「左から右」 ついでにアローと代入 → 優先順位が アロー > 代入 なので、 p->next->prev = x; ↓ (p->next) -> prev = x; // アローは「左から右」 ↓ ((p->next)->prev) = x; // アロー > 代入 ↓ struct CELL* q = p->next; (q->prev) = x; 意味合い的には、双方向リストの要素 p の次に x を挿入するため、 1. p の次の要素にて 2. 前への参照を 3. x に書き換る と思われます
> button1をクリックすると、エラーが出て止まってしまいます。 どんなエラー? // 僕ならこうする // ----- Form1 (WebBrowser と Button) public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { Form2 slave = new Form2(this); slave.Show(this); } public void Navigate(string url) { webBrowser1.Navigate(url); } } // ----- Form2 (TextBox とButton) public partial class Form2 : Form { public Form2(Form1 master) { master_ = master; InitializeComponent(); } private Form1 master_; private void button1_Click(object sender, EventArgs e) { master_.Navigate(textBox1.Text); } }
>test.cpp 内には >コモンダイアログ　「新規作成,名前を付けて保存,上書き保存」　とエディットコントロールがあるのですが >それが表示されません。　どうすればいいのですか？ -Wオプション付きでコンパイルすればいいです。 とりあえず…… ・コンソールアプリケーション 　main()から始まる。 ・Windowsアプリケーション 　WinMain()から始まる。 の２種類がある。ということをお勉強した上でコード書いてください。 # ダイナミックリンクライブラリ(DllMain()から始まる)ってのもありますが、まぁ当面は関係ないでしょう。 >※test.ini の読み取りは　メニューバーにある「version更新」を押すと　test.iniをコマンドプロンプトのウィンドウ　で開けばいいと考えているのですが　これはできますか？ コマンドプロンプト開く必要すらありません。 「version更新」のイベントハンドラ内にmain()に書いた内容を記述すればいいでしょう。 >※ファイルを展開すれば　ファイル内容及び　ソースコードが分かるのですが >　確認せずに！？　投稿ということは　大抵ファイルを展開していない　自分の予想として・・・とか >　で投稿をしているのではないかぁと思います。 展開して、中を見た上で呆れて回答しただけですがなにか？ 現状での最新ソースがどうなっているかも不明ですし、今はアップローダから削除されてしまったようですが。 # さしたる重要度も無いのでRAMデイスクにDL＆展開したので、私の手元には残っていませんけどね。 # ついでに、後からこの質問見た人にはどんなコードだったのかさっぱりなんで似たような問題に直面した人には役に立たない質問になってますが。 で…カレントディレクトリについて指摘しましたが理解されていないようなので現状で起こりうる問題も指摘しておきますかね。 # やり方次第で発生しないけど最新ソース確認できないし。 1)メニューバーにある「version更新」押下。 =>iniファイルが無いので新規作成。 2)コモンダイアログ「新規作成,名前を付けて保存,上書き保存,・・」で別フォルダーに移動してファイル名指定して[OK]押下。 =>こっそりカレントディレクトリ変更されました 3)再度、メニューバーにある「version更新」押下。 =>iniファイルが無いので新規作成。 最新ソースは不明ですし、私の回答はお気に召さなかったようなので以後は控えますね。
> だめだめじゃん　> 自分 > 乗除が続いたときうまくいかない。 ということで、修正しました。 int* pLeft = &a[0]; for (int i = 0; i < sizeof(op)/sizeof(op[0]); ++i) { switch (op[i]) { case '*':*pLeft *= a[i+1];break; case '/':*pLeft /= a[i+1];break; default:pLeft = &a[i+1];break; } } int result = a[0]; for (int i = 0; i < sizeof(op)/sizeof(op[0]); ++i) { switch (op[i]) { case '+':result += a[i+1];break; case '-':result -= a[i+1];break; default:break; } } こんなんでいかがでしょう。 最適とは言えないでしょうけど... 優先度グループが二つしかないから２回のループ、グループが3つなら３回のループになるけど、 ３回のループを回すなら、構文解析ツリーにくみなおす方がきれいかな。
> wchar_tの内部表現がunicodeという決まりありましたっけ？ 確かに wchar_t = Unicode(UCS2/4) を期待すると移植性なくなりますね。 厳密にやりたいなら ICU 使うとか、そんな対処になるのかと。 参考URL：http://site.icu-project.org/
AAADataが refクラスなので AAAData = gcnew array<AAADATA^>(10); といった具合に テンプレートの型名の後ろに『^』が必要ですよ AAADataの宣言時も array<AAADATA^>^ AAAData; といった具合で 型名の直後に『^』を付け忘れないように … エラーが出る場合 C3149とかのエラー番号や 出力内容をのまま引用するなどしたほうがいいですよ
＞ちなみに"TEST.TXT"がリテラルってことでしょうか？ そうとも言い切れませんが、一般的には「そう」ですね。 ちょっと乱暴で不正確ですが、簡単に言えば「ROM領域や、リードオンリーでライトプロテクトされたメモリ領域など、書き込みできないメモリに配置された文字列も指定可能」って事です。
ExcelをC#から扱う，つまりExcelをCOMでオートメーションするというのは， 内部のVBAで記述するのとほとんど同じ方法で可能です。 このため，操作をマクロで記録してVBAコードを見るのが， オートメーション方法を知る一番簡単な方法になります。 1. Range.NumberFormatLocalに通貨用の書式を代入します。 ref) http://msdn.microsoft.com/ja-jp/library/office/f …(v=office.15).aspx in VBA Selection.NumberFormatLocal = "\#,##0;\-#,##0" in C# // Range r; r.NumberFormatLocal = "\\#,##0;\\-#,##0"; 2. Range.AutoFilterを呼び出します。 ref) http://msdn.microsoft.com/ja-jp/library/office/f …(v=office.15).aspx in VBA Range("A1").Select Selection.AutoFilter in C# // Range r; r.AutoFilter(); 3-1. 分割および解除：Window.SplitColumnおよびWindow.SplitRowを指定します。 ref) http://msdn.microsoft.com/ja-jp/library/office/f …(v=office.15).aspx ref) http://msdn.microsoft.com/ja-jp/library/office/f …(v=office.15).aspx in VBA With ActiveWindow .SplitColumn = 1 .SplitRow = 3 End With With ActiveWindow .SplitColumn = 0 .SplitRow = 0 End With in C# // Window w; w.SplitColumn = 1; w.SplitRow = 3; // Window w; w.SplitColumn = 0; w.SplitRow = 0; 3-2. ウィンドウ枠の固定：Window.FreezePanesにtrueを指定します (解除はfalse)。 ref) http://msdn.microsoft.com/ja-jp/library/office/f …(v=office.15).aspx in VBA ActiveWindow.FreezePanes = True in C# // Window w; w.FreezePanes = true;
>メモリアロケートエラーが発生する、具体的な例を挙げていただけませんか。 $ uname -a Linux fedora64 3.14.4-200.fc20.x86_64 #1 SMP Tue May 13 13:51:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux $ cat memalloc.c #include <errno.h> #include <stdint.h> #include <stdio.h> #include <stdlib.h> #include <string.h> int main(int argc, char **argv) { void *p = malloc(32L*1024*1024*1024); printf("%s\n", strerror(errno)); printf("%p\n", p); return 0; } $ cc -o memalloc memalloc.c $ ./memalloc Cannot allocate memory (nil) $ ちなみにFreeBSD 10だと同プログラムでも確保できたような結果にはなります(実際にアクセスする際にエラーになるんだろうけど)。 % uname -a FreeBSD * 10.0-STABLE FreeBSD 10.0-STABLE #1: Sun Apr 27 14:03:05 JST 2014 * amd64 % ./memalloc No such file or directory 0x801000000 % アドレス空間が64ビットあったところで物理メモリ+スワップを超える量をどうやって確保します？(「物理メモリ+スワップ」というのは例えです。この辺はシステムによって異なります)
eclipseはC/C++のプログラムの開発はできますけどeclipse自身でC/C++のコンパイラをもっているわけではなくcygwinやVisualStdio(VisualC++)などで提供されているC/C++コンパイラを利用することになります。 ですので利用するC/C++コンパイラ次第です。
プロパティマネージャ を使って、 よく使うプロパティ・セットを作っておき、 プロジェクトに設定することができます。 参考URL：http://msdn.microsoft.com/ja-jp/library/vstudio/ …(v=vs.100).aspx
いや, 「ノッチフィルタというものを知らないで #1 を書いた」わけじゃないんだよ (苦笑). # 確かに「ノッチフィルタ」について調べたのは事実だが, それは「知らなかった」からではなく「確認したかった」から. LPF や HPF をどう「モジュールとして」あるのか知らんけど, LPF と HPF を組合せれば BPF も BRF も作れるでしょ? 足し算してもいいしかけ算してもいい.
>カレントディレクトリが今どこなのかよくわかりません。なにか表示させる方法はないでしょうか？ 少し前にも別の方にカレントディレクトリネタな回答したような気がしますが… 最近はカレントディレクトリなんてかんけ～ねぇよ。ファイル名指定したらOSが自動的に探してくれんだよ。 がトレンドなんでしょうか？？ # 別ディレクトリに格納されている同名のファイルの場合、どっちが読まれるかふぁじぃ～に動作するんですかね？ ということで…… 「カレントディレクトリ 取得」辺りで検索するとそれなりに見つかるかと。 http://msdn.microsoft.com/ja-jp/library/cc429301 … とか。 >戻り値をDrawStringを使って表示 数値=>数字変換は必要でしょうが…… OutputDebugString()とか、TRACE()とかあったりしますよ。 http://oshiete.goo.ne.jp/qa/8612144.html でカレントディレクトリ関係を突っ込み。 # この質問者さんの最終的な問題はカレントディレクトリから離れてしまいましたが。 んで、そっちでも書いていますが… カレントディレクトリはプログラム実行中に変更される可能性があります。 # まぁ、普通は変更されないんですが…。 そもそも、カレントディレクトリにデータファイルがある保証すらありません。 # アプリの起動時の処理によってはまったく無関係な場所がカレントディレクトリになっていたりもします。 # EXEファイルのショートカット作って、「作業フォルダー」に設定すればどこにだって指定できますし。
http://svn.sourceforge.jp/svnroot/cc1101driver/t … リポジトリブラウザで見るとヘッダファイルはあるようですね。 ヘッダファイル更新してもmakeはコンパイル対象とする必要は無いのかと。
そのページのコードが示す通り、C# ではメソッドはオーバーライド不可がデフォルトで、オーバーライドするには親クラスで許可を与える必要があります。 一方、Java ではオーバーライド可能で、オーバーライド不可にするには final でそのように制約をかけることになります。 これはどちらが優れているかという事ではなくその言語の仕様としてどちらを選んだかにすぎません。 もっとも、Java ではあるメソッドがオーバーライドされているかどうかがわかりづらいため、オーバーライドしたメソッドには @Override アノテーションを付加することが推奨されています（うっかり名前・引数型を間違ってオーバーライドになっていない場合にエラーを出してくれますしね）。
> エラーがでてしまいます． 具体的にどんなエラーなのですか? > allocate(x(0:n)) のあとで > n=1000 とするのは変では無いですか?
uniqueを使う場合、対象の要素があらかじめソートされてあることが必須なので、 まずはbでソート→その後uniqueという手順が必要です。 Aの配列が、bがユニーク+aでソートされている、という条件さえクリアできれば良いのであれば void ToUnique_A(std::vector<A>& v) { std::sort(v.begin(), v.end(), [] (A& a, A& b){return a.b < b.b;}); std::vector<A>::iterator it; it = std::unique(v.begin(), v.end(), [] (A& a, A& b){return a.b == b.b;}); v.resize(std::distance(v.begin(), it)); std::sort(v.begin(), v.end(), [] (A& a, A& b){return a.a < b.a;}); } このようにすれば可能です。 もしくは、setを使えば下記のように実装できます。 void ToUnique_B(std::vector<A>& v) { std::set<int> us; for (std::vector<A>::iterator i = v.begin(); i != v.end(); ++i) { std::set<int>::iterator j = us.find(i->b); if (j == us.end()) us.insert(i->b); else v.erase(i--); } }
マニュアル、読んでますか? ○scanfの動作 ○strtokの動作 ○strcpyの動作 の理解が不十分だと思われます。 scanfのマニュアルの1例です。 http://linuxjm.sourceforge.jp/html/LDP_man-pages … > 変換指定には、以下の 「型修飾子」 を入れることができる。 > s > ホワイトスペースではない文字で構成された文字列に対応する > 文字列の入力は、ホワイトスペースが入力されるか、最大フィールド幅に 達するか、のどちらかが起こると停止される。 %s を使って読み込んだ「ホワイトスペースではない文字で構成された文字列」を、どうやって「ホワイトスペース」で分割するというのでしょう? http://linuxjm.sourceforge.jp/html/LDP_man-pages … > 返り値 > strtok() と strtok_r() は次のトークンへのポインタか、 トークンがなければ NULL を返す。 必ず10回実行しているので、トークンの数がそれより少ないとNULLが返ってきます。 ここでNULLが返ると strcpy(animal[i], strtok(NULL, token)); は strcpy(animal[i], NULL); になります。 この結果が、どうなるかわかりますか?
＞この SQL では、結果を項目名で取得しようとすると、 ＞A,B両方のテーブルにある値でないとだめなのでしょうか。 実際にこのSQLコマンドに対してAccessが何を返すのかを、Accessのクエリーを作って試してみてはどうでしょう？ ＞ちなみに、dtRow[0] のように添え字でアクセスすると、取得できるようです。 番号でアクセスした場合はフィールド名に関係なく、Accessが返したフィールドにアクセスできます。
1行読み込みをしたいんだったら、 fgetsでファイルから1行読み込み、 sscanfでデータを変換するしかないね。 まあ、fscanfは便利だけど、ファイルがおかしい場合は正常な読み出しが 出来ないので、あまり使わないほうがいいね。
2013 はインストールしていないのでそちらではどうなっているのか解りませんが、2012 では開発者コマンドプロンプトを開いた直後のディレクトリが C:\Program Files (x86)\Microsoft Visual Studio 11.0 となっていました。この場所は書き込みが非常に激しく制限されます。 cd コマンドでカレントディレクトリを確認してみてください。カレントが C:\Program Files\ または C:\Program Files (x86)\ で始まるディレクトリであるならば同様の問題が発生すると思われます。 解決策としては temp.txt の出力先をカレントから書き込みが可能なディレクトリに変更してください。
Stringと書かれているのが.NETのSystem::Stringの事なら http://support.microsoft.com/kb/311259/ja が参考になるかもしれませんが、 正直それで何をやりたいのかさっぱりわかりません。
1. String 文字列を表現するクラス 　 2. String^ 　1への参照(ポインタみたいなもん
＞リソースは自動的に解放されると思うのですが この文章に引っかかりました。 Cでは確保したメモリーは自動開放はしないと記憶しています。 bmpを開放してみてください。
読み込むファイルの拡張子がxlsということは、Excelのファイルですか？ Excelのファイルはセルに入力した文字列より前に、いろんな文字が入っています。 C言語でファイルを読むとそれらの文字列を最初に読んでしまうので、意味の分からない文字列が取れてしまいます。 メモ帳のファイルを開くからC言語で読み込もうとしているファイルを開いてみると、きっと、C言語で読み込まれた文字列と同じ文字が並んでいますよ。 C言語はOSを作るための言語ですので、何でもできてしまう代わりに、すべてを網羅して、処理をいれないとなりません。 例えば、Excelファイルの意味の分からない文字列は、おそらくですが、同じファイルなら、同じ文字列なはずです。 ですので、その文字数をカウントして、それだけ飛び越えて、文字を読むようにすると意図したことができると思います。
「プログラムのどこがエラーか教えてください」とはどういうことでしょうか? コンパイルエラーがあるならコンパイルすればわかるはずですし, 論理的なエラーがあったとしても実行すれば「期待する結果と違う」ことから自分で調べればいいだけのことです. せめてコメントくらい書こうよ. あと, 例えば「階数」だけ知ることを許さないのはなぜだろう.
ここは、質問者さんは、読まなくても大丈夫ですので。 今回の質問者の場合、 aの代入後に、bの値が出るって言ってたので、 おそらくこのコードではないんじゃないかな？って 感じての話です。。4-5番さん。 言いたいことはわかりますよ。 ようするに、、 char *abcd(void) { char aaa[]="asjdfisajdfiiajfasd"; return(aaa); } xx=abcd();　// で？　xxは？ってこと。（aaaはローカルだがただの値、中身は実体） 話し戻りますと、 pStr="String"; の書式は、NGではないですね。 すいません。言い方が間違ってました。
>ちなみにhtml_nameは改行とnull文字は付いていません。 改行文字はともかくhtml_nameはNUL文字終端になっていないということですか？ >また、ファイル名にutf-8やshift-jisがあるのかも知りません。 「知りません」ではなく「知ろうとしてない」だけですね。 VisualStudioには立派なドキュメントがありますし。 >バレが怖いので下記しか書けません。質問なのに申し訳ございません 「バレ」って何？
http://ja.wikipedia.org/wiki/%E6%8C%BF%E5%85%A5% … http://ja.wikipedia.org/wiki/%E9%81%B8%E6%8A%9E% … 言語は違いますが、構造は同じです。 他にも検索すればいくらでも見つかります。
func1()とfunc2()のプロトタイプ宣言をtestMain.cとtestKioku.cのそれぞれで行っているのもおすすめしません。 プロトタイプ宣言ではないですけどtestKioku.cのextern int cnt;もかな。
自分で読み直していて、またも気になりまして。 >1024×2048の0と1のみ X=1024 Y=2048 ですよね？ for(j=0; j<1024; j++) // y for(i=0; i<2048; i++)　// x もしかして逆ではない？ （これが最終的に解答だったりして？） ということで、前回のソースを修正しておきます。 バッファーが足りなかったもので。 char buffer[2048+2]; // fgetsは改行コードも読むので、少し予備を追加しておく ここだけですが。
難しく考えすぎていたようです。 #include <stdio.h> #include<process.h> int main(void) { FILE *fp; int a[200], i, j, cnt, max, max_i; fp = fopen("data.txt", "r"); if (fp == NULL) { printf("file cannot open.\n"); exit(1); } for(i = 0; i < 200 && fscanf(fp, "%d", &a[i]) == 1; ++ i) ; fclose(fp); for(max = max_i = j = 0; j < i; ++ j){ int k; for(cnt = 0, k = j + 1; k < i; ++ k) cnt += (a[j] == a[k]); if(cnt > max) max = cnt; max_i = j; } //ここから追加 for(j = 0; j < i; ++ j){ int k; for(cnt = 0, k = j + 1; k < i; ++ k) cnt += (a[j] == a[k]); if(cnt == max) printf("%d\n", a[j]); } //ここまで追加 // printf("%d\n", a[max_i]); return 0; } これだけの話でした。
> VCで作成したCのAPIを実装した と書かれていますが、これは本当にC としてビルドされていますか？ ただ普通にプロジェクトを作っただけでは VC++ は C++ としてプロジェクトをビルドします。 VC++ 2010 Express ではプロジェクトまたはソースのプロパティの「構成プロパティ」-「C/C++」-「詳細設定」の中に「コンパイル言語の選択」がありますので、「C コードとしてコンパイル」を設定してください。
テキストモードでオープンしてるからじゃ？ http://msdn.microsoft.com/ja-jp/library/a499td6y …
　検索エンジンで「ツイッター　ボット」（bot）などで調べてみてください。 ＞EasyBotter - プログラミングができなくても作れるTwitter botの作り方 ＞http://pha22.net/twitterbot/ ＞twitterでボットを作る方法をいろいろまとめてみたよ ＞http://bogus.jp/wp/?p=736 　ツイッターボットを実行する前にほかのユーザがこのプログラムにどんなイメージを抱いているか事前に調査をしてから判断してください。 参考URL：http://bogus.jp/wp/?p=736
肝心な事書き忘れてました _stat() を調べて見てください。 あとおそらくですがNUL文字と0x1aを勘違いされているかと思います。 CP/Mでは0x1aがファイル終端のコードとして扱われていたためMSDOSやその後継であるWindowsのCコンパイラでは互換性のためにテキストモードで0x1aを読み込んだ際にはファイル終端とみなすようになっています(Cのライブラリでそういう処理になってるというだけで本当にファイル終端というわけではありません)。
読み出すだけなら，Usersの権限で可能です。 読めなかった，という時のRegQueryValueExなりのAPIの戻り値は，何でしたか。 実は64bit OS上の32bit ProcessでHKLM\SOFTWARE\Wow6432Nodeを見に行っていた，ということはないでしょうか。 http://msdn.microsoft.com/en-us/library/aa384129 … を参考に，KEY_WOW64_64KEYを常時指定してもよいでしょう。 なお，昇格が必要なアプリケーションをUACのダイアログなしで起動する方法は，基本的に昇格済みのプロセスから起動するしかありません。 そもそも昇格が本当に必要かは調べる必要がありますが。
FORTRN、VC++共に今後もサポートされ続けられると思われますし、高速化の点ではFORTRANの方が充実したパッケージ等が揃っておりコンパイラもFORTRANの性能の方が上のようですし、主要部分はこれまで通りFORTRANのままでも良いのではないでしょうか。 入出力連携やディスプレイ表示(グラフ、平面、立体、アニメ、動画...)などの点でVC++が便利なのでしたら、mainはFORTRANのままで入出力部分等をVC++で処理する事も可能だと思われます。 "FORTRAN C++ 連携 OR インターフェイス" "FORTRAN C++ 連携 OR インターフェイス common" 等とサーチされたら色々な例が見つかります。 common blockを宣言し、FORTRAN, VC++の両プログラムから沢山の変数は共通にアクセス出来るのではないでしょうか。 FORTRAN内で使われていた沢山の変数は、宣言部分のみを書換えれば実行部分では殆どそのままでアクセス出来るのではと思われます。 それからご存じとは思いますが、二次元や三次元のデータアクセス等に当ってはFORTRANとVC++ではabc(i,j,k)をどの順番で(i,j,kのどれを一番内側のループにして)早く変化させるか、メモリ上でどの順番にデータが並んでいるか<==>キャッシュラインヒット率を上げるか等で、単純な書換えでは性能が反って悪化する場合もあるのではと思われます。 既に調べられているとは思いますが、次等いろいろと検討が必要のようです。 http://www.moonmile.net/blog/archives/3359 FortranのCOMMONブロックをC++から扱う http://www.xlsoft.com/jp/products/intel/compiler … インテル@Fortran プログラムからの C プロシージャーの呼び出し http://docs.oracle.com/cd/E19957-01/806-4843/Cp1 … C と Fortran のインタフェース システム全体の事が解らずにピント外れの回答でしたら申しわけありません。
># サイズ指定、間違えないようにご注意を。 と、注意を促していたのですが……予定通り間違えていたんですね。 まぁ、既に指摘されて修正されたようですが。
> wl <- 0 　wlという変数に0を代入する。<-は代入を意味する。Rでは 0 -> wl という書き方も可能。 > i <- 1 　iに1を代入。ここでは次の行で上書きしてしまうので無意味。 > for (i in 1:10) { 　iを1,2,...,10と変えながら最後の}行までを繰り返し実行する。 　一般にforはinの後のベクタの各要素をinの前の変数iに入れながら繰り返し実行する。 　1:10は1から10までのベクタ。一般にm:nでmからnまでのベクタになる。 > wl <- wl+100 　wlを100増やす > x <- c(1:1000) 　1から1000までのベクタを変数xに代入する。この行は単に x <- 1:1000 でも可能。 > y <- sin(2*pi*x/wl) 　ベクタ変数xの各値に対してsin(2*pi*x/wl)を対応させたベクタをyに代入する。 　ベクタ変数の要素ごと計算が簡単にできるのがRの特徴です。 > plot(x,y, type=‘l’) 　xを横軸、yを縦軸にとった折れ線グラフを描画する。type='l'で折れ線を指示する。 > } 　forループの範囲を終わる。 こんな感じで。
VS2013は持っていませんが、VS2012ではC++/CLIと互換性のあるC++ランタイムの プラットフォームツールセットはv110_xpのようです。 VS2013の場合はv120_xpでしょうか？ プロジェクトのプロパティ→構成プロパティ→全般→プラットフォームツールセット の値を v120からv120_xpに変更すればビルドできるようにならないでしょうか？
税抜き金額は100/105すればよろしい。四捨五入なら、+0.5で対応できます。 ８％税込みは上記金額×1.08+0.5で計算できます。 ｓｔａｒｔ ↓ scanf ↓ printf ↓ ｅｎｄ
ここは質問するところなんですけど、そこのところはご理解いただいているという認識でよろしいでしょうか？ >要望が３つあります 要望以前にちゃんと動作するコードにする必要がありそうですが。 >int x = 0, a = 11, b = 17, c = 50; >printf("あなたの運勢を二桁以内の半角英数字で入力してください："); >scanf("%d",x); 数字の入力は出来ませんね。 少なくとも入力文字の先頭に数字を入力してはいけないコードです。 「先に進ませる」ためには。 # 理由はご丁寧にコンパイル時の警告メッセージとして出力されています。 数字を入力するとプレイヤーとモンスターの戦闘は神により禁止されます。 # SegmentationFaultかアクセス違反という神罰により平和な世界が訪れる。 で、数字に入力できないので…ここでのxは常に0になり以降の計算式も毎回同じ値を返すことが確定します。 # ゲーム的要素ないですね…。 >printf("（Ctrl＋cで終了します。先頭を続けるにはEnterキーを押してください)\n"); Ctrl+cでやはり神を召喚します。 結果として「先頭は無かった」ことにされ、プレイヤーもモンスターも死なない平和が実現されます。 # プロセスの強制終了。 環境によっては世界の裏側でプレイヤーとモンスターが神からの時間停止呪文の解放を待ち続けます。 # フォアグランドにならないとgetchar()から先進めないでしょうしね。 >・プレイヤーかモンスターのどちらかのHPが０になった時に、このゲームを終了させたい。 >while(1){ のループの継続条件を整理してみてください。 ちなみに、「0」になる確率にも注意が必要です。 # 25-30は0ではありませんから。 まぁ、ループの継続条件だけでなく中断判定も入れないとアンデットになったプレイヤーがモンスターに攻撃可能だったりします。 さすが勇者！死んでもただでは死にません！ # そして、最初のループ継続条件をミスするとアンデットになったプレイヤーとモンスターがえいえんの戦闘を繰り広げます。 えいえんの戦闘の果て、アンデットから体力バカに転生します。 # えいえんはあるよ。ここにあるよ。 とりあえず、疑似乱数ってものがあることは勉強しましょう。 # あと、種が必要であることも。 >・攻撃の選択肢を増やしたい。（魔法や必殺技など） getchar()での入力内容によって分岐する処理でも追加すればよいでしょう。 「想定外の入力」についても考慮は必要でしょうが。 # MPやら必殺技の使用条件とか考える必要もあるでしょうねぇ。 >・「急所に当たった」という表現を追加したい。 乱数で判定でしょうかねぇ。 行動選択できるなら判定処理ちゃんと考えないとアホな結果になるのでご注意を。 プレイヤーは回復の呪文を唱えた! プレイヤーのHPが34回復。 モンスターの急所に当たった!! モンスターに74のダメージ!! みたいな。 # いつ攻撃したよ？ ちなみに何度か指摘しているループ継続条件をミスると、回復呪文でプレイヤーの負けになる場合もあります。 # アンデットから生者になれるわずかな隙間で。 >お時間がよろしければ下記サイトに例としてコードを書いていただけないでしょうか。 謹んでお断りいたします。 「こういうコードにして、こういう結果を望んだけど違う結果になる。どこが悪いの？」みたいな質問でしたら回答してくれる人はそれなりに居るでしょうが。
以前名寄せが必要な際に、以下のサイトを参考にさせていただきました。 秀逸です。 http://d.hatena.ne.jp/siokoshou/20080324 参考URL：http://d.hatena.ne.jp/siokoshou/20070315
どの言語でも同じことですが ・なにをやろうとしたのか?なにを期待しているのか? ・それがどんな風になったのか?どんな風に期待と違う結果になったのか? ・エラーメッセージが出ているのなら、そのエラーメッセージを買く。 メッセージはコピペする。中途半端に要約しない ・これらを修正しようとした場合、あなたがわからないのは、どの部分なのか? ・使っているCコンパイラは何か、OSは何か? ・ソースコードは全部載せるのが理想だが、文字数が足りないし、長いコードを読むのは面倒なので、「現象が再現する程度の短いプログラム」にする。 これらのことは、自分で直すときにも有用です。 まとめたことで、どこに問題があるか、自分で気づいて、質問するまでもなく修正できてしまった、ということもあるでしょう。
なるほど、要求仕様を満たしていませんでした。 こうですか、解りません＞＜ 本来であれば数字の妥当性チェックもやらないといけないのですが、面倒なので省略しています。 結果は何通りでも良いのですよね？ #include <stdio.h> int main(void) { int suuji,seinen; printf("数字ID："); scanf("%d", &suuji); printf("生年月日："); scanf("%d", &seinen); switch(1) { default: printf("\n二人の相性は最悪です\n"); break; } return(0); }
まぁ、何がしたいのかよくわからんけど、 import java.util.*; import java.io.*; class Test31 { public static void main(String[] args) throws IOException { String str; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println("一人目の数字IDを入力してください"); String str11 = br.readLine(); System.out.println("一人目の生年月日を入力してください"); String str12 = br.readLine(); System.out.println("二人目の数字IDを入力してください"); String str21 = br.readLine(); System.out.println("二人目の生年月日を入力してください"); String str22 = br.readLine(); if(str11.compareTo(str21)>0) if(str12.compareTo(str22)>0) System.out.println("二人の相性A"); else System.out.println("二人の相性B"); else if(str12.compareTo(str22)>0) System.out.println("二人の相性C"); else System.out.println("二人の相性D"); } } こんなところでどう？
>としたところ、Segmentation faultが出ました。 正常動作なので問題ありません。 『コードで指定した』想定通りの動作であり、OSが正しく動作していいる証拠でもあります。 head->yearの出力を除けば、環境によってはSegmentation faultにならずに済むかも知れません。 # 学生の名前が「(null)」と表示されれば。 headが「NULLになる」のと、それが「評価される」のと、「参照される」のと……どういう順番で処理されているのかよく見てみましょうね。 判らなければwhileループの中でステップ実行してみたらよいでしょう。 あと…その連結リストの先頭のデータは表示されない。 元々、有効なデータが入っていたのかも疑問ではあるが……。 # HEAD保持用にデータ入れていない構造体を用意する。なんて処理を組んだとはあるな。構造体1個分のメモリが無駄になるのを理解しつつ。 # HEAD保持をポインタにした場合にnullチェックが面倒だった…という回避用にそうしたんだったかなぁ…。リスト辿る時に終端としてのnullチェックは必須だったし。
#pragma managed(push, on) の意味は「今のマネージのオンオフの状態を取っておいて、マネージをオンにする」と言う意味。 #pragma managed(push, off) の意味は「今のマネージのオンオフの状態を取っておいて、マネージをオフにする」と言う意味。 #pragma managed(pop) の意味は「pushで取っておいたマネージの状態に戻す」と言う意味。 どこかのコードの途中で「マネージを一時的にオンしたい」とします。 一時的にオンにした後は「元の状態に戻す必要」があります。 そして、その場所の「元の状態がオンかオフか判らない」としたら、どうしたら良いでしょう？ //サンプルコード１ //この位置はオンかオフか判らない // //マネージをオンにする #pragma managed // ～～～ ～～～ //マネージを元に戻す //#pragma managed/unmanagedのどっちか判らない！元に戻せない。どうしよう？ // これでは、元に戻せませんね。 //サンプルコード２ //この位置はオンかオフか判らない // //今の状態を保存して、マネージをオンにする #pragma managed(push,on) // ～～～ ～～～ //マネージを元に戻す #pragma managed(pop) // どうです？元の状態がどっちか判らなくても「元の状態」に戻せたでしょう？ managedのpushとpopは、通常「インクルードファイルの中で、マネージをオンしたりオフしたりする必要がある時」に使います。 例えば、test.hppのインクルードファイル内で //マネージをオンにする #pragma managed(push,on) // ～～～ ～～～ //マネージを元に戻す #pragma managed(pop) と書きます。 test.hppは「どこで使われるか判らない」ですから、マネージがオンの場所で呼び出されたり、マネージがオフの場所で呼び出されたりします。 インクルードを呼び出す側も //マネージをオンする #pragma managed // //このtest.hppは、中でマネージを一時的にオンにしても元に戻してくれる <#include test.hpp> // //ここは「マネージがオン」のつもりで書く // #pragma unmanaged // //このtest.hppは、中でマネージを一時的にオンにしても元に戻してくれる <#include test.hpp> // //ここは「マネージがオフ」のつもりで書く // みたいになっています。 もし、test.hppの中で「マネージをオンしたまま、元に戻さなかった」としたら、困った事になります。 // #pragma unmanaged // //このtest.hppは、中でマネージをオンにしたまま戻さないという、極悪非道なファイル <#include test.hpp> // //ここのコードを「マネージがオフ」のつもりで書いても、マネージはオンになっている // どうです？「元に戻す」ってのが、如何に重要な事か、理解できましたか？
divisible_counterの初期化は処理系によるけど、所期するのがプログラマーとしての基本スキル で、ここからは、プログラムのテクニック的なおせっかいだけど、このプログラムって、numberとして0とか負の数が来たら誤動作するよね ですから、まず、Numberが負、0、1、正で場合分けする必要がある。 また、上記のように場合分けしてある場合、ループの範囲は2からnumber/2-1。 更に、1回でも割り切れれば素数じゃないこと確定なので、ループは停止していいです。 最初に一度2でわれば偶数確定なので、ループの範囲を3からnumber/3-1にできて、ステップ間隔も2に出来てループの指すとが大幅に下がります。
　　　public class Customer 　　　{ 　　　　static public int no = 0; 　　　　static public string name = ""; 　　　　static public string mailAddr = ""; 　　　} と書いたとき、no 等が定義されるのはそのインスタンス（new 等で生成したモノ）ではなくクラスそのものになります。一方、customers 自体はともかくcustomers[0] に入っているモノはインスタンスです。 したがって、そのインスタンスで定義されていない no へのアクセスはできません。 Customer の定義を 　　　public class Customer 　　　{ 　　　　public int no = 0; 　　　　public string name = ""; 　　　　public string mailAddr = ""; 　　　} と変えましょう。 ……でもこの修正をしてもコンパイル時じゃなくって実行時にエラーが出るんじゃないかなぁ？
Cでは「１回しか定義できないもの」や「１回しか宣言しちゃいけないもの」があります。 そして「あるヘッダーから、別のヘッダーを呼び出している」って事もあります。 例えば、stdio.hの中では、stdio.hで必要な標準の定義を、_stddef.hを呼び出して行っています。 ユーザーが、以下のように書いたら、どうなるでしょう？ #include <_stddef.h> #include <stdio.h> こう書くと、_stddef.hは「１つのソースファイルで、２回呼び出される」ことになります。 ユーザーは「stdio.hの中でも呼んでるとは思ってない」ですから「_stddef.hが２回呼ばれているとは思ってない」です。 もし、_stddef.hの中に「１回しか定義できないもの」や「１回しか宣言しちゃいけないもの」があったら、どうなるでしょう？ 当然「２回呼び出した段階で、コンパイルエラー」です。 ですが、質問文にあるように「条件付き取り込み」をやっておけば「２回呼び出されたら、２回目は何もしない」ので、コンパイルエラーにはなりません。 もし「ヘッダーファイルの中では、入れ子でヘッダーファイルを呼び出さない」って決めれば、こういう事が起きません。ユーザーが「明示的に２回呼び出さない限りは、２回は呼び出されない」ですから。 しかし「ヘッダーの中に、別のヘッダーを呼び出すのように書いてはいけない」とすると、もっと困った事になります。 stdio.hは_stddef.hに依存します。_stddef.hは_defs.hに依存します。 ユーザーが #include <stdio.h> と書くと、事前に_stddef.hを呼び出してないので、コンパイルエラーになります。 未定義エラーが出て、それが何処で定義されているか調べないと「事前に_stddef.hが呼び出されていないといけない」って事が判りません。 じゃあ、って言って #include <_stddef.h> #include <stdio.h> って書くと、今度は、事前に_defs.hを呼び出してないので、コンパイルエラーになります。 そして #include <_defs.h> #include <_stddef.h> #include <stdio.h> って書いて、やっとコンパイルに成功します。 これでは面倒なので「stdio.hの中で、自動的に_stddef.hを呼び出す」、「_stddef.hの中で、自動的に_defs.hを呼び出す」って言うようにしたのです。 そうすれば #include <stdio.h> って書くだけで済みますから。 もちろん、これらは、ユーザーが #include <_defs.h> #include <_stddef.h> #include <stdio.h> と書いても「２重定義エラー」にならないよう、条件付き取り込みで、２回以上取り込んでも問題無いようになっています。 このように「２重取り込みされても問題ないように書く」のです。
>そりゃ、i396はありませんからね。 9ぢゃねぇぇぇぇぇ… i386ね。
＞＞実用的なら「精度が高い方が良い」からね。 ＞Walsh変換は精度が低いんですか？ 「精度が高い方が良い」は語弊がありました。 精度が問題なのではなく「ハードも進化したし、使い勝手が良い、もっと良いアルゴリズムや変換方法が作られてしまったから」ですね。 精度的には、他の変換方法も余り変わらないと思います。
>C言語でこのようなことはできますか？ 「できますか？」って質問なら、「できます。」だけで終わってしまいますが。 どういう処理すればいいのか？とか聞きたいならそれなりの質問にした方がいいかと。 # まぁ、誰かが書いてくれるでしょう。 左右に箱が置いてあって、左の箱には「1、5」「2、2」「5、3」と書かれたカードが入ってる。 右の箱は空っぽ。 そして手元には何も書かれていないカードと筆記用具がある。 という状況で貴方ならどういう手順で処理しますか？ 日本語で納得できる手順が書き出せたらその手順をプログラムコードに翻訳するだけです。
ディレクトリーを読むなら、 http://www.geocities.co.jp/SiliconValley-Cuperti … こういうふうにします。
volatileが無いのなら。原因は多分No.1に書かれている通りのように思います。 参考 http://www.eleki-jack.com/h8/2009/09/h8-21h8cvol …
C++は文法が膨大なので、そういう方向性の本は皆無に近いです。 そもそも、何かを作ろう！的なノリでは扱えないヘビーな言語です。 わかった気分的なもので良ければ「14歳からはじめるC++わくわくゲームプログラミング教室」がありましたが、もう古いんですよね。あとちょっと分かった気になるだけです。 http://www.amazon.co.jp/14%E6%AD%B3%E3%81%8B%E3% …
>データの個数を求めるプログラムはどのように組めばいいのでしょうか？ 固定長ならファイルサイズをデータのサイズで割ればいいでしょう。 データとやらが1バイト固定でファイルサイズが84バイトなら84個ある。 と確定します。 まぁ、＃１で書かれているように仕様不明ですし。 実際に使用するわけではないコメントとかを入れられるというのならばファイルサイズからの算出は不可能ですし、 データのサイズが可変長なら実際に読み込んで個数を数えてください。 配列に読み込むのであれば、添え字を変数にしてカウントアップしているでしょうからそのカウンタが個数になりませんかね。
>sprintf(filename, "Result%d.xml", i); >fp = fopen((const char *)filename, "r"); お約束なアレですが… 実行時の「カレントディレクトリ」にファイルあるんですよね？ 「カレントディレクトリってなぁに？」って言うのなら、まず検索してください。 # お約束ってくらい、よくひっかかる人が多いんですけどね。
C言語のプログラムでXMLを読むなら、expatやlibxmlを使うのが普通だと思います。 http://expat.sourceforge.net/ http://xmlsoft.org/ "サンプル"や"使い方"をつけて検索すると使用例や解説ページが見つかると思います。 C言語でできますが、自分だったら特別な理由がない限りC言語でプログラムを書かないでしょう。
自前のクラスローダーなどで、DLLフォルダ内にあるdllファイルをロードしてるんですか？ exeファイルと同じフォルダ内にdllを置いてもダメですか？
クラス定義中にメンバ関数の定義を書けば, 暗黙に inline 指定されます. inline は処理系に対するヒントなので, 「必ずインラインになる」とは限らないですが.
No4さん、盛大に、吹いたぞ（ｗ） 日本酒呑んでるときこれ見るのは、きつい（ｗ） ナイス回答！
No1が言うとおり、、2個起動した時、 最初に起動したほうをどうやって終わるか？は ありますね。 ps axでプロセス探してkill するとか？ アプリの起動自体は ./recv & < ＆で強制起動 ./send こっちは＆つけずそのまま、クライアントからの入力待ち。。 が、ごっちゃごっちゃ（ｗ） 他のPCから、アクセスしているのであれば、 コンソールを2個まともに開いちゃえば、画面に直接だせてテストしやすいかもですが。 受け側がprintf 出来るので、かなりデバッグが楽です。 ですが、１つのコンソールでやってるんですよね？ ＜過去に似た事やった事があったんですが、忘れました。
http://freestdf.sourceforge.net/ ↑これですか？ INSTALL ファイルを開いてみたところ VCでのコンパイル法がでていますが、必要なファイルが含まれていないですね。 で、一つ前のバージョンをDLしてみたところ、VCで必要なファイルが含まれているみたいです。 最新版は、VCでコンパイル出来るようにはなっていないのでしょう。
Segmantation Fault は領域外へアクセスしたときに発生するもので、プログラム上の原因は次のようなものがほとんどです ・確保させていない領域にアクセスした 　NULL、freeした後の領域等 ・配列の添字が範囲外 ですから、まずは、上記の点問題無いかを調べます。 エラーなくコンパイルできたかどうかは関係ありません。 で、プログラムを全部チェックするのは面倒ですが、それでも、斜め読みでもわかるくらいおかしな点を http://oshiete.goo.ne.jp/qa/8589069.html で指摘させていただきましたが、今回のプログラムでもまったく直ってません。 (rand()/32767); おそらく、[0,1]の乱数を期待しているようですが、2つの理由から、そうはなっていません。 そのことは理解できていますか?
これはコンマ演算子（カンマ演算子とも）の計算結果でこうなっています。 http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3% … コンマ演算子はコンマの右側の値を返します。 たとえば、a, b と書いた場合、全体としての値は b となります。 ただし、a が何らかの関数などの場合はとりあえずその処理を行います。 > (x*=4, x+2) これはまず x*=4 を計算します。これは、x の値を 4 倍し、その結果である 16 という値を返します。 次に、コンマ演算子によってその結果は捨てられ、x+2 の計算結果が全体の答えとなります。 しかし、コンマ演算子が捨てたのは代入演算子が返す値であって、x　の値を変更したという事実は生きています。 したがって、 16+2 の結果である 18 が全体の結果になります。 > (x*=4, x+2, x+4) これは上記の x*=4, x+2 のあとに コンマ演算子でつなげて x+4 があります。 x*=4, x+2 の結果は 18 ですが、その値は捨てられます。x+2 は x 自身の値を変えないため x の値は 16 のままです。 そのあと、x+4 の値である 20 が括弧全体の値になります。 > (x+2, x*=4, x+2, x+4) これはまず x+2 が計算されますが、この値はコンマ演算子によって捨てられます。 次に x*=4 が計算されますが、この値もコンマ演算子によって捨てられます。ただし、x への代入は行われています。 三番目に x+2 が計算されますが、この値もコンマ演算子によって捨てられます。 最後に、x+4 の値がコンマ演算子によって採用され、 20 が括弧全体の値になります。
前提がよく分からないので見当外れを言っているかもしれませんが、もしかするとカメラの回転と平行移動のみから、レンズの焦点距離を求めたいのでしょうか。さすがにそれは無理があると思います。 また焦点距離を長くしても、素子サイズを小さくしても被写体の像はより大きく写ります。これらが区別できないという話は、カメラの平行移動や座標の単位が何であっても変わらないでしょう。
>「Board at COM1 is not available」とエラーがでて何もできません。 改めて確認するのもアレですが、Arduino　Unoは、実際にCOM1に繋がっているんですよね？ デバイスマネージャなりで確認しましたか？ COM3だったりCOM11だったりと、過去に接続したUSB-Serialによっては番号変わりますけど。
No.2です。 >できれば　set cntrlabel と同じように　4.6ぐらいでも使える方法を教えていただければ幸いです。 最近gnuplotを使っていないので詳しくはないのですが、無理そうに思います。 Rという統計計算用ソフトがありますが、グラフも得意なのです。こちらには希望する機能があります。 http://www1.doshisha.ac.jp/~mjin/R/06.html の下の方に等高線の例があります。もし使ってみる気がありましたら書き込んでください。アドバイスはできると思います。 もしUNIX系のOS(Mac, Linux)であれば、gnuplotの様にパイプでつなげるようです。 R自体はちょっと癖がありますので、他言語から利用している方も多いようです。私自身はRubyからRを利用しています。C++やPythonなど多くの言語から利用できるようです。 Rはこちらから http://www.r-project.org/index.html
for(p=0 ; p<Number_of_ch ; p++){ for(q=1 ; q<Number_of_ch-p+1 ; q++){ ここでqの最大値はいくつでしょう? rand()/32767 これ、どんな乱数になることを期待していますか? おそらく期待通りになっていないと思います。 abc = (Number_of_gene-1) * (rand()/32767); これも、期待通りになっていないでしょう。
「? に数字を入れる」だけではだめなはずだけど.... さておき, どのような ABI に従っているのかをまず明確にしてください.
・受注者は成果物の著作権を発注者に譲渡する ・受注者は成果物の著作人格権を行使しない このような点を契約した方がよいでしょう。カスタマイズを禁止できるのは著作人格権で、これは著作権（財産権）と違って譲渡できなかったと思います。 「成果物」はアプリケーションおよびテストプログラムの実行ファイルとソースコード、ドキュメント一式。
以下のようにしてください。 --------------------------------------------- # include <stdio.h> int main(void) { int y,m,d=0; int yy=0,mm=0; int day; int wd; int i; int j; int wm; int low; int col; //12カ月分のカレンダー用日付 //6行7列=42個を確保 //カレンダーに１から末日までの数値を埋め込み、値が０の個所は空白を表示させる intdays[12][42]; printf("年(西暦)＝"); scanf("%d",&yy); //配列全体を０クリアする for (i=0;i<12;i++){ for (j=0;j<42;j++){ days[i][j] = 0; } } //12か月分の日付を格納する for(mm=1;mm<=12;mm++){ //閏年 switch(mm){ case 2: if(((yy%4==0)&&(yy%100!=0)||yy%400==0)) day=29; else day=28; break; //4月6月9月11月30日まで case 4: case 6: case 9: case 11: day=30; break; default: day=31; break; } y=yy; m=mm; if(m==1||m==2){ y--; m+=12; } //ツェラー wd=(y + (y/4) - (y/100) + (y/400) + ((13*m+8)/5) + 1)%7; //その月の日付を設定（１日から末日まで） for(d=1;d<=day;d++){ i = mm -1; j = d -1 + wd; days[i][j] = d; } } //カレンダーを２列で表示する for(wm=0;wm<6;wm++){ m = 2 * wm + 1; printf("%2d月__________________%2d月\n",m,m+1); printf("日_月_火_水_木_金_土__日_月_火_水_木_金_土\n"); for(low=0;low<6;low++){ //左側の月 i = m - 1; for(col=0;col<7;col++){ j = low * 7 + col; d = days[i][j]; if (d == 0){ printf("___"); }else{ printf("%2d_",d); } } printf("_"); //右側の月 i = m + 1 - 1; for(col=0;col<7;col++){ j = low * 7 + col; d = days[i][j]; if (d == 0){ printf("___"); }else{ printf("%2d_",d); } } printf("\n"); } } } --------------------------------------------- 空白が詰められるので、空白を＿で表示してあります。 このプログラムを実行されるときは、＿を空白に変えてからコンパイルしてください。 以下実行結果です。 --------------------------------------------- 年(西暦)＝2014 1月__________________ 2月 日_月_火_水_木_金_土__日_月_火_水_木_金_土 _________ 1_ 2_ 3_ 4____________________ 1_ 5_ 6_ 7_ 8_ 9_10_11__ 2_ 3_ 4_ 5_ 6_ 7_ 8_ 12_13_14_15_16_17_18__ 9_10_11_12_13_14_15_ 19_20_21_22_23_24_25__16_17_18_19_20_21_22_ 26_27_28_29_30_31_____23_24_25_26_27_28____ ___________________________________________ 3月__________________ 4月 日_月_火_水_木_金_土__日_月_火_水_木_金_土 __________________ 1________ 1_ 2_ 3_ 4_ 5_ 2_ 3_ 4_ 5_ 6_ 7_ 8__ 6_ 7_ 8_ 9_10_11_12_ 9_10_11_12_13_14_15__13_14_15_16_17_18_19_ 16_17_18_19_20_21_22__20_21_22_23_24_25_26_ 23_24_25_26_27_28_29__27_28_29_30__________ 30_31______________________________________ 5月__________________ 6月 日_月_火_水_木_金_土__日_月_火_水_木_金_土 ____________ 1_ 2_ 3__ 1_ 2_ 3_ 4_ 5_ 6_ 7_ 4_ 5_ 6_ 7_ 8_ 9_10__ 8_ 9_10_11_12_13_14_ 11_12_13_14_15_16_17__15_16_17_18_19_20_21_ 18_19_20_21_22_23_24__22_23_24_25_26_27_28_ 25_26_27_28_29_30_31__29_30________________ ___________________________________________ 7月__________________ 8月 日_月_火_水_木_金_土__日_月_火_水_木_金_土 ______ 1_ 2_ 3_ 4_ 5_________________ 1_ 2_ 6_ 7_ 8_ 9_10_11_12__ 3_ 4_ 5_ 6_ 7_ 8_ 9_ 13_14_15_16_17_18_19__10_11_12_13_14_15_16_ 20_21_22_23_24_25_26__17_18_19_20_21_22_23_ 27_28_29_30_31________24_25_26_27_28_29_30_ ______________________31___________________ 9月__________________10月 日_月_火_水_木_金_土__日_月_火_水_木_金_土 ___ 1_ 2_ 3_ 4_ 5_ 6___________ 1_ 2_ 3_ 4_ 7_ 8_ 9_10_11_12_13__ 5_ 6_ 7_ 8_ 9_10_11_ 14_15_16_17_18_19_20__12_13_14_15_16_17_18_ 21_22_23_24_25_26_27__19_20_21_22_23_24_25_ 28_29_30______________26_27_28_29_30_31____ ___________________________________________ 11月__________________12月 日_月_火_水_木_金_土__日_月_火_水_木_金_土 __________________ 1_____ 1_ 2_ 3_ 4_ 5_ 6_ 2_ 3_ 4_ 5_ 6_ 7_ 8__ 7_ 8_ 9_10_11_12_13_ 9_10_11_12_13_14_15__14_15_16_17_18_19_20_ 16_17_18_19_20_21_22__21_22_23_24_25_26_27_ 23_24_25_26_27_28_29__28_29_30_31__________ 30_________________________________________ 不明点は、補足にて問い合わせください。
例えばこんな感じ： gnuplot> plot 'a.dat' using 1:2:3:4:(($3-$1)**2+($4-$2)**2)**0.5 with vectors linec olor palette
回答No.3の「ビット配列のエンディアンを変換する用途を想定するならば、」は誤りで 「バイト配列のエンディアンを変換する用途を想定するならば、」だと思います。 バイトオーダーの切り替え処理に関する質問であってビット・ナンバリングの話ではないと思うので。
>webBrowser1.stop(); 本当に「stop()」なんですか？ http://msdn.microsoft.com/ja-jp/library/system.w … 「Stop()」ではなく？ メソッドの大文字小文字は区別されるハズですけど。 故に、エラーメッセージが > 'stop' の定義が含まれておらず なんじゃないですかね？
Form1クラス内にForm1Instanceアクセサがあるのはおかしいでしょう。 情報を送受信するものはForm2なら、Form2InstanceアクセサがForm1クラス内に 存在しないといけません。 エラーになるのは、アクセサとしてForm1クラスを期待しているのに、Form2クラスを 渡されたためでしょう。
　アクセス違反が出てくれて良かったですね。 　典型的なＣにおけるバッファオーバーフローのパターンです。これでも、エラーが出ないことが往々にしてありまして、その時には、セキュリティーホールの非常に良質なネタとなります。 　まず、最初に、一つ、本質とは関係の無いアドバイス。 　　「reinterpret_cast」は、禁句だと思っておいた方が良いです。文法違反だと思っておいてもかまいません。 　何故、こんなことを言われるかが、自分で理解できるまでは、そういうものだと思い込んでおいて良いでしょう。 　之を使わないと解けないと思った時には、きっとあなたの考え方が間違っています。 　このcastを本当に使わなければならない場面になった頃には、何故そうなのかも理解できているはずです。 　さて、本題。 　Ｃにおいては、メモリーの管理は、純粋に自己責任です。どんなポインターでも、型さえそろえたふりをすれば、渡せますし、書き込みだって簡単にできます。 　これが、あだとなって、今回のようなプログラムが登場します。 　strcatは、第一引数の指すアドレスに、第一引数の指す文字列と第２引数の指す文字列を合わせた物を書き込みます。 　当然の前提として、第一引数の指すアドレスは、書き込み可能で、しかも、二つの文字列を合わせた結果の文字列よりも充分大きな領域が確保されていなくてはいけません。 　今回の第一引数は、"Result"という文字列定数です。文字列定数は、文字の配列として解釈され、そのアドレスは、先頭文字を指すchar *として解釈されます。従って、コンパイルは通るのですが・・・ 　当然のことながら、文字列定数の指すアドレスは書き込み「禁止」です。これは、実装次第という側面はありますが、文字列「定数」のあり方として、そうあるべきです。（ちなみに、言語規約では、書き込み禁止のメモリー領域に配置できるとあります。）また、その領域の大きさは、"Result"を書き込める最小の大きさ（末尾の\0を入れて、おそらく７バイト）です。 　二重の意味で、前提条件を満たしていませんよね。 　多分、書き込み禁止領域に書き込みをしようとして、ランタイムエラーではじかれています。とても親切な実装です。もし、書き込み可能な領域に、この定数が配置されていたら、もっと訳のわからないトラブルに巻き込まれたことでしょう。なぜなら、本来確保した領域の外側へ書き込みを始めるからです。もちろん、隣の領域は、他の変数の領域です。他のルーチンの変数領域かもしれません。そこを平然と踏みつぶしているわけですから、もう何が起きても不思議ではありません。（不幸にも、この隣の領域がシステム領域だっり実行コード領域だったりした時に、とてつもないセキュリティーホールが発生することになります。） 　ほかにも、すごく、冗長なアドレスの表記など、まだ、もう少し、ポインターと配列の関係の理解が不足しているなと思われる場所が散見されます。 　ゆっくりと、ポインターの学習を深められることをお勧めします。 　
>では、 >MyAction action = CreateMethod(); >を実行すると、 >actionの中に >{ >Console.WriteLine(message); > }; >が入り、 > >action(); // 出力：Hello! World! >で実行されるということでしょうか？ actionに { Console.WriteLine(message); }; が直接入るわけではなく、呼び出すための情報が入るといった方が近いかと思います。
>XXXXXXSDKというファイルをダウンロードしたので、Visual C++で開こうとしているのですが、 ファイルメニューでは拡張子がないためか表示されません。 >他に開くようなメニューがありません。 >どのメニューを探せばいいのでしょうか？ それだけの情報で何とかできたら超能力者。 そもそもソリューションファイル(sln)が無いのならVC++向けではないのでは？ どっちにしても、そのsdkの名前やURLを教えるのが速道。 十分な情報を出せない初心者のあなたが隠しても何の得にもならない。
>何か対処法はありますか？ 原因が分からない事には対処方法はわかりません。 今の段階でいえることといえば 「作ってるプログラムのどこかがおかしい可能性が高いので、どこがおかしいか調べてください」 くらいかと。
No.4に書いたのは http://www.speex.org/docs/api/speex-api-referenc … に書かれている第一番目の要素　const void * mode　の中身だけです。
> C#のカンマ演算子の代わりと言われているラムダ式 ……えーと? 確かに C 言語ではカンマ演算子で順次実行のみの処理を一文で書くことができて、C# ではラムダ式で複数の処理を外から見て一文にまとめることができますが、全く別物です。 とりあえず、以下のページからの 5 ページの説明がわかりやすいかと思います。 http://www.atmarkit.co.jp/fdotnet/csharp30/cshar … ……あー、4 ページ目の最初の方は「C 言語では C# では使えない様々な構文（カンマ演算子を含む）を使って複雑な処理を一文に押し込めることができる」って意味で「C# における C 言語のカンマ演算子の代替手段がラムダ式である」って意味ではないのであしからず。
source.cpp(9): warning C4018: '<=' : signed と unsigned の数値を比較しようとしました。 ってことで、一応ビルドは通りましたね。 signedの変数iとunsignedのstrlen()の戻り値での比較ってことですかね。 # strlen()の戻り値はsize_tでしたが。 >if (a[i] == 'ワ'&&a[i + 1] == 'ン'){ とかはintへの暗黙の型変換でもされたかと。 まぁ、期待通りに動作しないことに変わりはありませんが。 ＃１にて書かれているので細かいことは書きませんけど。
処理を全部main関数に記述する縛りプレイでもしてるの？ int main() { 　　for(;;) 　　{ 　　　　for(;;) 　　　　{ 　　　　　　if() 　　　　　　{ 　　　　　　} 　　　　} 　　} } こうなる前に int main() { 　　for(;;) 　　{ 　　　　Process(); 　　} } void Process() { 　　for(;;) 　　　　{ 　　　　　　if() 　　　　　　{ 　　　　　　} 　　　　} } こうするとか
- DLLじゃなかったらうまくいきますか? 確認しましたか? - ↓こうしなかったのはなぜですか? private void Form1_Load(object sender, EventArgs e) { 　　GetFormWidth(this); }
質問ヘタクソ。 - こんなことがやりたくて - こんなコードを書いて - こうしたら - ここで - こうなった くらいは書こうや。
＞環境変数の方もシステム環境変数、ユーザ環境変数両方に、 何を狙ってこのような事をしているのでしょうか？ 手当たりしだい訳も分からず設定しているのではありませんか？ 敢えて困難な道を選ぶような事はせず、おとなしくコンパイラ入りの All in One を導入したらどうでしょうか。 http://mergedoc.sourceforge.jp/index.html#/pleia … http://mergedoc.sourceforge.jp/pleiades-redirect … Pleiades All in One C/C++ C/C++ 開発者向けパッケージです。 Eclipse 公式パッケージ C/C++ Developers のプラグインと追加プラグインで構成されています。 mingw ディレクトリは CDT により自動認識されます。Eclipse 上から使用する限り、環境変数 PATH を設定する必要はありません。
# 回答ではありません XNAは今年の4月で開発終了です。 参考URL：http://ggsoku.com/2013/02/microsoft-xna-end/
>...色々調べましたが分かりません ... やってみれば、それが正しい結果だと思いますよ。 前提で質問を続けても誰も答える気になれないと思う。
Channel 9のことでしょうか。 http://channel9.msdn.com/
簡単にはこんな感じで。 #include <stdio.h> main(){ int c; system("stty -icanon -echo"); while(1){ c = getchar(); if(c < ' ') break; /* 制御文字がキーインされたら終了 */ printf("%c key is pushed\r\n",c); } system("stty icanon echo"); }
サイトを検索した結果が「中々分かる様なサイトが見つかりません」ということでしたら、 独学出来るレベルに達していないのではないでしょうか。 まずはセミナーか何かを受けた方が良いと思います。 http://www.microchip.co.jp/training/seminar.html
数字的には9ビットの2進数なので、0～511までの数字となります。 forで0～511までループし、2進数に変換して、0が5個、1が4個の 組み合わせの数字を見つければいいだけです。
>MFCによって生成終了してくれているスレッドでも特定できるのでしょうか？ >ソースコードから追えますか？ まずはMFCのソースコードインストールしてください。 Cランタイムライブラリのソースコードもインストールしておくとさらにいいかもしれません。 で、ソースコードからCreateThread()とか探してみてください。 # grepとかで探すのがイイでしょう。 見つかったコードから、関係する関数やクラスを使っているか調べる。ということになるでしょう。 >終了コードが0以外というのはあまり気にする必要はないということでしょうか？ 気味が悪い。とか落ち着かない。とかなら、それこそDLLの中まで逆アセンブルで探すことになるんじゃないですかね。 少なくとも私は気にしません。自分で生成していないモノに対してまで責任持てませんし。 ライブラリをコールしたときに渡した引数が問題で要らないスレッドまで起動していた。 とかなら調べますけどね。 デバッグで起動しようとすれば、読み込んだDLLとかもある程度判るでしょう。 # 「'C:\Windows\System32\ntdll.dll' を読み込みました。シンボルが読み込まれていません。」とか出力されているでしょう。
MIPSアーキなら、10進で―2 16進への変換は自分でやってください。
各命令の正確な動作が分からないので答えられない. ちなみにカテゴリもおかしい.
プロパティペインからProductCodeを選択すると，右端に...と書かれたボタンが表示されると思います。 これをクリックすると，[プロダクトコード]というダイアログボックスが表示されます。 あとは，そこに存在する[新規コード]ボタンを押せば，新しいProductCodeが設定されます。 # VS 2010で確認。
「rand Ｃ言語」で検索した上で分からないことを聞くなら良いけど、検索していないなら掲示板に頼りすぎ。Ｃ言語勉強したいなら自分で調べないと理解が進まないと思う。 と言うことで、再度検索したページを例にあげてそのページを読んで分からない事を聞いてください。
2次元配列を使うと言ってもあなたがどういうものを想定しているのかよくわからないのだけれども…。 (1) eat1とeat2を一緒にして2次元配列にするならNo.5の方の書き方になるし、 (2) eat1とeat2がそれぞれ別々の2次元配列になるならポインタの書き方を工夫する必要がある。 struct str { char *name; //名前 int num; //数 } ; static struct str eat1[2][3] = { {{ "もも" , 1 },{ "みかん" , 2 },{"ブドウ", 3}}, {{ "キウイ" , 4 },{ "パイン" , 5 },{"カキ", 6}} }; static struct str eat2[2][3] = { {{ "きゅうり" , 1 },{ "ナス" , 2 },{"カボチャ", 3}}, {{ "キャベツ" , 4 },{ "大根" , 5 },{"ネギ", 6}}, }; intmain (void) { struct str (*p) [3] ; int mode = 2; int i,j; switch( mode ){ case 1: p = eat1;break ; case 2: p = eat2;break ; } for( i = 0; i < 2; i++) { for( j = 0; j < 3; j++) { printf( "%d\n" , p[i][j].num ); } } }
TableLayoutPanel側に ColmunSpanやRowSpanはありません Panelに乗せるコントロールに対して設定可能なプロパティですよ 3行3列テーブルの 1行2列目と3列目にまたがるような(ボタンやテキストボックスなどの)コントロールの場合にColumnSpanを2にするといった使い方をします
既に指摘されているsub $v0,$tの部分以外はMIPSプロセッサのアセンブリ言語に見えます。 丸投げするのではなく、何が分からないのかを書きましょう。
サポートも終わっているVC6ってのも厳しいところですが…… >例外処理 (初回) は ABC.exe (TEMP.DLL) にあります: 0xC0000005: Access Violation。 >というよく見かけるエラーが出たので、例外が起きた場所で停止して原因を特定しようとしたのですが、 Access Violationでは、発生したところと原因の位置が違い過ぎます。 ので、その方法ではチェックできません。 # たとえば…ポインタに不正な値を入れていた(原因)としても、それがAccess Violationとして表面化する(エラー発生)のはそのポインタの内容を参照した時です。 >と、ソースコードのないところしか出てきません。 >これはどういった意味なのでしょうか？ API内部だったり、ライブラリの中だったりするとソースは出てこないでしょう。 >ここから先、原因を特定するにはどのようにすればよいでしょうか？ ポインタ関係で変な操作しているところがないか…とか、そういう探し方でしょうかねぇ……。 あちこちにTRACE()入れて、どこまで進んでいるか…って調べるのもありかも知れません。 >デバッグモードでソフト終了時に、 動的確保して、オーバーランやアンダーランしたとか、解放し忘れたとか、そういうところとかありませんか？ プログラム終了時の後始末関係でエラーになったのではないかと推測されます。
どのように進学されたとしても、学業と並行して勉強された方が良いと思います。 書籍であれば、下記あたりから始めると良いと思います。 ゲームプログラマのためのC++ http://www.amazon.co.jp/exec/obidos/ASIN/4797366 … ゲームプログラマになる前に覚えておきたい技術 http://www.amazon.co.jp/exec/obidos/ASIN/4798021 … ゲームのアルゴリズム 改訂版 思考ルーチンと物理シミュレーション http://www.amazon.co.jp/exec/obidos/ASIN/4797359 … ゲーム開発のための数学・物理学入門 改訂版 http://www.amazon.co.jp/exec/obidos/ASIN/4797356 … 上記の後は、「Game Programming Gems シリーズ」を読まれると良いと思います。 Game Programming Gems 8 日本語版 http://www.amazon.co.jp/exec/obidos/ASIN/4862461 … 一度、どれか手にとってご覧になって、現在のご自分のスキルがどの程度か把握されてみてはいかがですか？
System.Xml.XmlNode.SelectNodesで要素をXPathで指定できますから，これを使います。 ref) http://msdn.microsoft.com/ja-jp/library/hcebdtae(v=vs.110).aspx foreach (var element in document.SelectNodes("/A/C/D").OfType<XmlElement>()) { // element.InnerTextを書き換える } とか， foreach (var textNode in document.SelectNodes("/A/C/D/text()").OfType<XmlText>()) { // textNode.Valueを書き換える } とか。
MinGWのインストールとeclipseの選択に問題がないと仮定して、 eclipse で Hello World を動かす手順は次の通りです。 -------------------------------------------------------------- メニューの "File > New > C Project" をクリック。 Project name: に適当なプロジェクト名を入力して Project Type: を "Executable" の "Hello World ANSI C Project" にして Toolchains: を "MinGW GCC" にして "Finish" をクリック。 "Project Explorer" ビュー内の作成したプロジェクトのところで右クリックしたあと "Build Project" をクリック。 "Project Explorer" ビュー内の作成したプロジェクトのところで右クリックしたあと "Run AS > Local C/C++ Application" をクリック。 "Console" ビューに !!!Hello World!!! と表示される。 -------------------------------------------------------------- もっとも、No.1の方が回答されているように、 最初はMinGWだけでコンパイルして実行するほうがラクでしょう。 ソースファイルが１つだけのプログラムであれば、コマンドプロンプトから gcc ソースファイル名 と入力したあと、 a.exe と入力するだけです。 gcc がコマンドとして認識されない場合は、Windowsの環境変数 PATH に MinGW の bin ディレクトリが含まれていないはずなので追加してください。
unsigned でも signed でも、実際のメモリ上の値は 同じなので、目印程度に使ってますね。 (unsigned)a++; < こうすれば、最初にsignedで作ったかはもはや、問わないわけで。 そこは、CでもC++でも同じだと、思ってます。 工業用のSDKでは、基礎ヘッダー内で typedef unsigned long Uint32; typedef signed long Sint32; typedef unsigned short Uint16; typedef signed short Sint16; typedef unsigned char Uint8; typedef signed char Sint8; などと、符号と、メモリ上の長さを型として宣言していることも多いですよ。 （Hitachi系のSDKに多い書き方） その他外国系だと uintなども見ます。 >やたらにunsignedを付けるのは初心者だと言う人もいます。 なぜ付いているかを理解できないのも、初心者ですよ（ｗ） 必要なら使うのですし！ ということで、私の回答ですが、 やってみて、ダメならUnsignedも使うし。 特にこだわらない事。 ではないかと、思います。
申し訳ありません。 #3は間違いです・・・ >ようするに、その場合はもしかすると、このcontrol deactivateの関数を消してしまえばいいのでしょうか。もう少し試行錯誤してみます。もしアドバイスをいただければ、助かります。 参考にしているプログラムはメインスレッドから作業スレッドに終了指示出すことで作業スレッドは終了しようとするんですから、それだといつまでも作業スレッド終了しませんけど。 使われている関数を呼ばなくするとかではできないと思いますよ。
ovbind.exeのソースではないのですが。 私なら、さけて通りたい道ですが、 https://www.xiph.org/downloads/ libogg（と同シリーズ） のソースファイルです。 これをいじくれば、望みの処理にはなると思いますが。 個人的な、意見ですが、 音源系エンコーダーのソースって、 SSL解読するより、わけがわからない（あくまで私の感想ですが） がんばってくださいね！
細かく全体を見てはいません。 //初回だけ乱数初期化 if(num==0){ srand((unsigned int)time(NULL)); shot[i].rad=atan2(py-y,px-x)-(60*PI/180)+((rand()%120)*PI/180); ++num; break; } 提示された部分で、rand が使われているのはここだけです。 これだと、 「num==0 のとき、必ず srand してからrand」となります。 ・numがどうなっているのか、コードからはわかりません。 最初の1回だけ角度がランダムに決定され、それ以降はnum!=0となり、shot[i].radが過去に設定されたもののまま、ということは無いですか? ・乱数の発生原理を理解しましょう。 randは「疑似乱数」と呼ばれるもので、「乱数のように見えるけど、実際には一定の法則に従った数列」です。 srand (seed,種と呼ばれます)は、その初期値を決めるものです。種が同じなら、発生する乱数列も同じになります。 例えば srand(10) 後、 rand()を繰り返したら 5,3,7,2 .... と乱数が求められたとします。 この場合、srand(10)とすれば、その後のrand()は、必ず 5,3,7,2 .... となります。 通常は、最初にsrandして、後はrandを繰り返す、という使い方をします。 srandは、プログラム実行時に初期値が設定されます。そのため、プログラム実行の度に同じ乱数列が発生します。 # いわゆる「電源パターン」です。 それを防ぐテクニックに一つが、「現在時刻を元に種を作る」です。 srand((unsigned int)time(NULL)); はそのためのものです。 ですが、これには「同じ時刻だと同じ乱数になる」という欠点があります。 time()は1秒単位です。よって、現在のプログラムだと、1秒間に撃たれた「乱射弾」は、全部同じ方向へ飛びます。
4個のスレッドを切るか、10個を切るかは自由だと思います。 が、CPUがQuad=4だから４ってのは、違うとは思いますが。 それ以外の処理にも、CPUパワーをまわすために、3個くらいでとめても いいかもしれません。。 MutexとSemaphoneを使い分けですね。 ミューテックスが設定されている部屋で 終わっていないタスクを探して、 その時点で開いているスレッドを検索 どのスレッドがそれを担当したとフラグを書いておき セマフォでそのスレッドをアクティブ化 　＝そのスレッドは、終わっていないタスクを１つ処理開始 ミューテックス開放 スレッドは、最後に、ミューテックスルームで 終わっていないタスクのエントリに「完了」的フラグに書き換えて ミューテックス開放+セマフォウエイトに戻る。 後は、メインタスクで全部の、 「終わっていないタスク」リストを監視するだけ という流れになると思います。 こうしておけばDefineなどで、スレッドを切る量を後からでも変更できるので トータルで、多いときが早いシステムなのか？ 少ないスレッドのほうが早いのか？を簡単に実験できますから。 と言う感じではいかがでしょうか？ が、スタックを結構消費するので、 メモリを使いすぎると、スワップにされると厄介なので、 あまり増やしすぎるのは、私は好きではないですね。 環境にもよるでしょうけど。
吐き出されているhtmlを編集できる立場（管理者）にいるのか、 閲覧者（客）の立場でhtmlを外から操作したいのかによって、 答えるべき内容が全然違ってくるのですが。 前者であるなら、 ほとんど正解に近い回答がなされている質問が既にあるので、参考URLに載せておきます。 また、もう少しシンプルに書かれているサイトもあるので、ここに載せます。 http://d.hatena.ne.jp/wonohe/20090212/1234411746 参考URL：http://oshiete.goo.ne.jp/qa/5234462.html
標準C++ (ISO/IEC 14882) では，少なくとも2011年版までにおいて配列型の宣言はconstant-expressionを伴うか省略する，となっています。 このため，constant-expressionでないnを使って配列の宣言を行うことはできません。 ただし，標準C (ISO/IEC 98989) では，1999年版より実行時にサイズを決めることのできる配列型が許されるようになっています。 VC++でない環境でできるのは，C++環境においても標準Cの機能を使えるように拡張してあるためではないでしょうか。
Cでプログラムを書けるなら、 「そのプログラムを呼び出して、リターンコード0でなければもう一度呼び出す」 というプログラムを書いて、間に挟めば良いのでは？
>そうですね、やはり、読むだけでなく理解しなければいけませんよね。 >恐らく、こういうことかと理解はできてるとおもいます。 そのコピペしたコードの中核を書き換えて応用したコードが出来ているならある程度は理解できていると思います。出来ていないなら分かっているつもりかもしれません。 まんまのコピペで溢れているなら危険な兆候です。 簡単なアルゴリズムのコードなら理解した部分は、次は見ずに同じ動作するものが書けるはずです。 こういう部分を自己チェックポイントにしてみてください。 どうしても自己チェック出来ないなら、ここで実際にコードを見せてネットからの引用に問題が有るレベルなのかみなさんに確認して貰いましょう。 あとWindowsAPIの呼び出し部分とか書き換え様がないコードの部分もありますが、APIや関数リファレンスにも目を通しているなら大丈夫かなと思います。
お好きにどうぞ。 大きなプログラムを書くときは複数のファイルに分割しますから、 mainだけで一本のファイルにすれば前も後もありませんからね。
SmtpClient sm = new SmtpClient("smtp.mail.yahoo.co.jp", 25); YahooのSmtpポートは25番は使えません。587番を使ってみてください。
他の方も言ってるので、はしょりますが＾＾ q->head=0;　 は q[0].head=0; qというポインタに、構造体内での、headの位置を加えた後 その位置ポインタの中身に対して”0”を代入。という意味です。 typedef struct { int a; int b; int c; }WAA; void hoge(void) { WAA abc[50]; WAA *p; p=&abc[20]; p->a=1; // これと、abc[20].a=1 は同じ。 p->b=2; // これと、abc[20].b=2 は同じ。 p->c=3; // これと、abc[20].c=3 は同じ。 // しかし、20番の位置を1度求めれば以後、pはずっと、abc[20]へのポインタなので高速である } ポインタを使った高速化などでは、よくこの書式を使うので、覚えておいて損はないかと。
比べているものが違うとか？ > 最初はPHP側でSUBMITしたら入力内容をファイルに保存して > Ｃ言語側ではそのファイルを監視して処理を行っていました。 の時に測定していたのは、PHPが入力内容をファイルに保存するのにかかる時間で、 > ファイル処理をブロッキングするソケット通信に変更しました。 の時に測定していたのが、入力内容をソケットに書き込み、データベースサーバーで処理をして、処理完了の応答を返すまでの時間 だとすると、後者のほうが明らかに遅そうです。後者だと、データをソケットを通して送るのに加えて、処理を待つ時間も含まれますから。 データベースサーバーが受付だけして、実際の処理をせずに応答するようにしても、データベースサーバーにコンテキストスイッチをして、そこでデータを読まないと処理が進まないので、単純にファイルにデータを書くのより少し遅そうですね。(1バイトずつデータを送るようなよほど馬鹿なコードを書いていない限り、これだけで10倍以上も遅くなるとは思えませんが) また、そのデータベースサーバーが1スレッドで処理をしているとしたら、他のPHPスクリプトが処理を依頼している間ずっと待たされそうで、全然スケールしなそうです。 それぞれが何を測定しているのかをまず明らかにしてみましょう。 そして、可能な限り無駄な待ち合わせを削ったほうがいいですね。
Ary_objをArrayにキャストしてからRankプロパティを調べると配列の次元を確認できます。 public static void Join(object Ary_obj){ 　Array ary = Ary_obj as Array; 　if(ary == null){ //Ary_objがArrayにキャストできない場合はエラーとする 　　throw new ArgumentException(); 　}else{ 　　int rank = ary.Rank; 　} } が、可能ならオーバーロードを使用することを検討すべきです。
>LinuxやUnixの環境でテストしなくては >ダメということですね。 どういう事でしょう？ もしかしてコンパイル時に警告やエラーが起きないことで、自分のコーディングが正しいかの判定をしようとしてますか？ もしそうなのでしたらコンパイル時にエラーや警告もなく、実際に実行して意図した動作をしたとしても、コーディングは間違っている場合もありますのでお気を付けください。 よくあるのはNULLと0の混同。
もちろん void input(property *data); にして int main(void){ 　property data[3]; 　input(data); が最も普通 (まあ大きさも渡すと思うけど) です＞#7. 配列の各要素は連続して配置されますから, &data[0] = data, &data[1] = &data[0]+1 = data+1, &data[2] = &data[0]+2 = data+2 が (意味のある限りにおいて) 常に成り立ちます. つまり「ポインタの配列」を使う必要性はほとんどありません. しいて言えば「複数の配列のデータを扱うとき」には意味はあるけど, そのような状況があまり想像できない. あと void input(property (*data)[3]); とすると「大きさ 3 の配列」は渡せるけどその他の大きさの配列は渡せなくなります. ただ, 例えば property data[4][3]; とかいう 2次元配列を input(data); のように渡す (ここで &data としちゃうとさらに面倒です) と上のような形が発生します. この 2次元配列との絡みで「3」が省略できない.
http://www.rarewares.org/ogg-oggenc.php これですか? ソースコードをダウンロードして中身を読むとGPLv2だとコメントにあります
>プロジェクトの追加からInstallShield Limited Editionを選択できるように書かれているのですが、実際やってみると全くできません。 ExpressEditionじゃ無理でしょうね。 http://social.msdn.microsoft.com/Forums/vstudio/ … VB2010Expressの例ですが。 http://blog.kaburk.com/os/windows/visual-studioc … ClickOnceですかね。 ちなみに、私は後者のURLの人と同じくInno Setupで対応しました。 派遣の身の上で、派遣先が契約先に納品するモノに対して、 VSの製品版(6万前後)、またはInstall Shieldの製品版(50万程度)の稟議を通してもらえるかも不明でしたし。 C# Expressにしても、私個人のMicrosoftアカウントでアクティベートしてますしね。 # まぁ、ちゃんとした稟議出せば通る可能性はあるのでしょうが。 .NET Frameworkが未インストールだったら～とかの対応もInno Setupで処理できましたし。
厳密には EOF を意味する入力 でもループしちゃいますね＞#2. ちなみに EOF が -1 とは限らない.
http://ja.wikipedia.org/wiki/Scanf#.E7.95.B0.E5. … ではないか、と。 scanfは初級者用の参考書に最初から出てくるので、簡単なように思えますが、実際は色々と考えて使わないといけない関数です。
補足 どうやら、scanfを呼ぶと、 sのアドレスがおかしくなってます。
あなたのコードは不完全なため、ビルドできるように以下のように修正しましたが現象が再現しません。 int AAA; class abc { public: static void CCC(); }; void BBB(){ AAA = 1; } void abc::CCC(){ AAA = 2; } int main(int argc, char** argv) { BBB(); abc::CCC(); return 0; // ここにブレークポイントを設定して AAA の値を確認 } 多分あなたが提示されていないコード部分に原因があると思われます。
>スレッドセーフではないLameライブラリを、pthreadを使ってマルチスレッドのツールを作ることは可能ですか？ 複数のスレッドで同時に利用したいというのなら無理かと。 それならそれで複数プロセスで処理させるという手もありますけど。
　通信販売のアマゾンでは以下のように商品説明があります。 ＞Microsoft Visual Studio Professional 2013 バージョンアップグレード DVD ＞http://www.amazon.co.jp/Microsoft-Visual-Studio- … ＞商品紹介 ＞本製品は、Visual Studio Professional 2012の正規ライセンスを持っている方が対象 ＞のアップグレード版。
>無料でWin7でMFCも使えるVisualC++ってないのでしょうか。 ないです。
ツリーコントロールのカスタムドローを利用しましょう。 http://msdn.microsoft.com/en-us/library/windows/ …(v=vs.85).aspx
素朴な疑問なのですが、strftimeを使うのはダメなんでしょうか。 http://msdn.microsoft.com/ja-jp/library/fe06s4ak … 他の回答で指摘されている通り、 ヌル文字を考慮して配列を確保しないとバッファ溢れして他のデータを破壊しますね。 例えば、"abc"はメモリー上ではa b c \0と表現されているので4バイト使うというのは聞いたことありませんか？
確認だけど 「実はシングルクリックで実行するようになっている」 とかいうオチはないよね?
ダウンロードした(はず)の tar,gz ファイルに収められている ファイル README を読みましょう。 > see the file "INSTALL" for installation (compiling) instructions. と書いてあります。指示通り ファイル INSTALL を読みましょう。 あとは、 vc_solution というディレクトリはありませんか? 中を見てみましょう。
サービスパックを当てると直ったという情報がありました。 http://www.microsoft.com/ja-jp/download/details. …
aのソースは { int k[1000]; int i; unsigned char *p=(unsigned char *)&k[0]; for (i=1000*sizeof(int);i;i--) { *p++=0xff; } } 0xff を4回書くと-1です。 bのソースは、このまんまかな。。 ただ、int m[1000]は4000バイトですが、（32ビット時)ですが、 memcpyはバイトなので、1000バイトでは足りないのでは？ 正しくは、memcpy(m,k,sizeof(m)); < コンパイラ任せのほうがいいかも。 または、1000*sizeof(int) ただ、実際は、数千回ベンチ取らないと、わからない程度かもですね＾＾ ではでは
最後の integrate の例はなにをしたいんでしょうか?
No1 です 他の方の回答通知が来て改めて内容見たときに気が付いたのですが 代入するコントロールの方も違ってたのね　　　見落としてました クラスウイザードの標準操作ではメンバ変数に配列を使うことはできないはずなので 自分で手を加えて細工することになります 手っ取り早くやるならそのコントロールを ポインタ等の配列に代入して使うのがいいでしょう 以下 不足してた部分の雑なサンプル Labei *LabekPtr[3]; //変数の型は 実際のコントロールのものに合わせてください LabekPtr[0] = this->labe1; LabekPtr[1] = this->labe2; LabekPtr[2] = this->labe3; for(int i = 0; i < 3 ; i ++) { 　LabekPtr[i]->Name = }
foreach (ListViewItem item in ListView1.SelectedItems) foreach (ListViewItem.ListViewSubItem subItem in item.SubItems) { MessageBox.Show(subItem.Text); } } かな？ .NET はよく知らないけど。
標準だと左側のソリューションエクスプローラから対象のソースファイルを選択して右クリック、プロパティ。 プロパティページの「C/C++」にプリコンパイル済みヘッダーの設定項目があるハズ。
> 私の継承の認識が間違っているのかもしれません。。 > 継承するつもりがなくてもForm2のオブジェクトをつくるためにインスタンスはするのでクラスの定義は必 > 要だと思うのですが、そういうことではないのでしょうか？ あってます。 私も、言葉の認識違いで混乱させてしまったかもと思った次第です・・・。 そういうことで大丈夫です。 リンクにあるコードを参考にすると、継承関係は以下のようになっていて、認識されている通りです。 Form2 <- Form が、Form1の中のロジックで、Form2を利用していて、そこでイベントをプログラムによって 実装させています。(frm2.TextBox1Changed += frm2_TextBox1Changed;) ここで、Form2で定義したイベントハンドラが効果を発揮していますね。 確かにこういうことを必要としないなら、イベントハンドラを定義する必要性はありません。 私が想定していたのはこの流れではなくて、継承関係が以下のようになっている場合です。 ExForm <- Form2 <- Form この時、ExFormのイベントプロパティの一覧に、Form2で定義しているイベントハンドラが出現します。 どちらもやれることは同じです。 例えば私が過去に作ったプログラムの中では、テキストの変更を捕捉するイベントハンドラを用意しました。 TextChangedイベントは、テキスト内容が変更されてから走行します。 私が求めたものは、『テキストが変更される前に、何が入力されたかを検知し、入力値を許可・拒否する』というものです。 その為、TextChangingというイベントハンドラを用意することにより、そのテキストボックスコンポーネントを利用して開発を行う人は、TextChangingイベントを実装して入力値の許可・拒否を自在に拡張できるようにしました。 イベントハンドラは、そういう、コンポーネントの利用者が要件に応じて求めることが異なるはずですから、それを手助けしてあげてくれるものです。 そういった利用者拡張を必要としない場面ならば、イベントハンドラを定義する意味はあまりないのではないでしょうか。 フォームとして何か決まった処理をするけども、その処理の前と後に自由に制御入れてもいいよ、とか。 前処理のイベントでキャンセル制御が行われたら後続処理をしないようにしてあげよう、とか。 (TextBoxでいうValidating、Validatedイベントの関係性のような)
＃８です。 色々な回答を得られて、色々考えさせられているところかもしれません。 > プログラムだけでなく、私はこうできればいいのになと想像するだけで、 > 行動に移さないことがかなりあります。 これをプログラムの世界で考えたら、『自分の脳内で思い描いたものが、勝手にプログラムとして 出来上がって動作すればいいのに』です。 大した考えもないにも関わらず、です。 夜中に小人が勝手にやってくれると幸せなんですけどね・・・。 出来ない人というのは、内容を掘り下げず、抽象的なまま、大枠でこういうことがしたいと考えていることがほとんどです。 コンピュータは人間ではない、全ての定義とルートを明示しなければならないということを理解した上で 考えるならば、自分に甘えるとかそういうことではなく、きっちり考え始めるはずです。 『いい感じに』、『ちゃらっと』、『察する』 なんてことはコンピュータには通用しませんから。 つまり、論理的思考が持てないというよりは、掘り下げる能力に乏しい、もしくは考えることを放棄していると言えます。 （そういう人に限って、あたかも考慮してたかの態度を取った上で後出しじゃんけんが多かったり口達者で逃げが上手かったりします） そういう人は段階も踏まずに最終的に求めることを調べようとするから、調べ方も下手です。 何か1つの方法が浮かぶ度に、なんでそうするのか、どうやってそれを実現可能にするのか、を 常に考えて1本の道を作り上げることが出来れば、構想は出来上がるはずです。 意外と頭では勝手にできると思い込んでいて、実際やってみようとするとそこの実装部分の考慮が漏れているということがあると思いますよ。 自らを向上させる為の手段としてそれを意識することができない、もしくは意識しても行動が伴わないならば、あまり適正とは言えないと思います。 対人間であったとしても、相手の心情や事情を考慮した上で接したりするのですから、相手がコンピュータなだけですね。 人間味のない、無知なバカに、そいつ（コンピュータ）が理解できる言葉で懇切丁寧に1から説明してあげる能力を持つことです。 対人間と手段は違えど、分かってもらうという目的は同じなわけです。 自分を向上させようとすることが出来ない人は、どのような業種・職種でも適正とは思えません。
>ボタン２でも同じように表示されているウェブブラウザにGoogleを表示させたいです。どのような方法があるでしょうか？ 「void Form1::ウェブブラウザ(string URL)」を使ってという事なら public void DLL関数2(Form1 form1) { form1.ウェブブラウザ("http://google.com"); } にして、 item1.DLL関数2(this); と、とすればいいだけだけど(interfaceは適切に変更してるとしてください)
#1の方に同意 Ｃとjavaと両方わかっているのなら、C++を使うのにほとんど問題はないはずです。 なので、ちょっとしたことがひっかかっているだけの可能性が高いので、その今ひとつの部分を質問したほうが理解が早いと思いますよ。 それに、入門書ってのはひとそれぞれに合う合わないが大きいので、万人におすすめってのは難しいです。私にとってよかった本が質問者さんにとってもよい本かどうはわかりません。 あるいは、質問者さんが読んでみて今ひとつだった本を書き上げてみるのもいいかもしれません。
Objective-Cに、「クラス変数」はありません。「インスタンス変数」のことをおっしゃりたいのでは？ インスタンス変数は、決まった場所で宣言します。そこで宣言しなければ、単なるC言語のグローバル変数と扱われます。 ※いうまでもなく、Objective-Cのインスタンス変数と、C言語のグローバル変数は、別物ではありません。前者は後者に包含されると認識してください。 ヘッダファイルの「@interface」のあと、スコープ「{～}」の中に宣言する。 実装ファイルの「@implementation」のあと、スコープ「{～}」の中に宣言する。 例1： #import <UIKit/UIKit.h> @interface MyClass : NSObject { NSString *moji; int kazu; } @end 例2： #import "MyClass.h" @implementation MyClass { NSString *moji; int kazu; } @end ただし、今流のObjective-Cの流儀では、インスタンス変数ではなく、プロパティを多用することが推奨になっています。これは、メモリの確保と解放を自動化する、ARCという機能を有効に利用するために、プロパティの利用が有効だからです。 ※古いObjective-Cに関する文献だけでなく、最新のバージョンの文献をあたることを、強くお勧めします。じつはいま、ひじょうに速いスピードで、Objective-Cの仕様が新しくなっているので、
Loadイベントはロード時というよりは「フォームが表示されるとき」に実行されます。 ちなみにShowDialogだと毎回実行されます。 コンストラクタは「インスタンス生成時」に実行されます。
たんにスタック操作をする関数群というとらえ方でいいんじゃないでしょうか。 データの型をどうするかはわかりませんが仮にintだとして次のような感じかと struct stack { ... }; struct stack * create(void) { ... } void push(struct stack *stk, int n) { ... } int pop(struct stack *stk) { ... } 構造体や関数の中身はお任せします。
半角スペース２個を全角スペース１個に置換しています。 #include <stdio.h> int main(void) { 　int a,b,c,d; 　printf("整数値を入力してください\n"); 　scanf("%d",&a); 　scanf("%d",&b); 　scanf("%d",&c); 　scanf("%d",&d); 　int data[] = {a,b,c,d}; 　int length = 4; 　int i,j,e; 　for (i = 0; i< length - 1 ; i++) { 　　for (j = i + 1; j< length; j++) { 　　　if(data[i] > data[j]) { 　　　　e = data[i]; 　　　　data[i] = data[j]; 　　　　data[j] = e; 　　　} 　　} 　} 　printf("昇順に並べ替えると、"); 　for (i = 0; i< length; i++) { 　　printf("%d ",data[i]); 　} 　printf("です。\n"); } #include <stdio.h> int main(void) { 　int a,b; 　printf("2つの整数値を入力してください\n"); 　printf("整数A : "); 　scanf("%d",&a); 　printf("整数B : "); 　scanf("%d",&b); 　if(a%b == 0){ 　　printf("BはAの約数です\n"); 　} else { 　　printf("BはAの約数ではありません\n"); 　} }
＞■ ビット5～0 - ADC5D～ADC0D : ADC5～0 デジタル入力禁止 (ADC5～0 Digital Input Disable) ＞このビットが論理1を書かれると、対応するADCnピンのデジタル入力緩衝部が禁止されます。 ＞このビットが設定(1)されると、対応するポート入力レジスタのビット(PINx)は常に0として読みます。 ＞アナログ信号がADCnピンに印加され、そのピンからのデジタル入力が必要とされない時に ＞デジタル入力緩衝部での消費電力を削減するため、そのビットは論理1を書かれるべきです。 ＞ADCピンのADC6とADC7はデジタル入力緩衝部を持たず、従ってデジタル入力禁止ビットの必要が ＞ないことに注意してください。 アナログ入力PINはマルチファンクションによりデジタル入力回路へも繋がっていて、 アナログ入力信号を与えたとき、デジタル入力回路側へも電流が流れてしまう。 信号源のインピーダンスが高ければ信号波形にも影響するでしょう。 "1"をセットすると、このデジタル回路への電流を遮断し、消費電力も軽減する。 という事でしょう。
失礼しました 「マイナス」ではなく「チルダ」でしたか。 チルダならビット反転なので正しいです。
> クラス生成時に全てのfloatを0で初期化したいのですが A::A() { std::fill(ary, ary+4, 0.0f); }
まず、C言語か、C++言語か、はっきりさせてください。 次のサンプルプログラムを例にします。 #define M0 (0) #define M1 (1) struct S { static const int S0=0 ; static const int S1=1 ; }; enum A {A0=0, A1=1}; enum B {B0=0,B1=1}; void subA(enum A a ) { } int main(){ enum A a0 = A0 ; enum A a1 = M1 ; enum B b0 = A0 ; enum B b1 = B1 ; subA(A1); subA(a0); subA(a1); subA(B1); subA(b0); subA(b1); subA(M0); return 0 ; } マクロ、列挙型と同列に構造体がきていることから、この struct sA のような使い方が連想されます。 このような使い方は C言語では文法エラーとなり利用できません。 C++では、一連の定数を関連付けたり、namespaceの代用にしたり、といった目的で利用できます。 enumの利点は「型をチェックできる」ことでしょう。 enum B b0 = A0 ; subA(B0); subA(b0); これらは、数値だけを見れば同じことですが、コンパイル時に「型が違う」と警告が出ます。 ところが enum A a1 = M1 ; subA(M0); では何も出ません。これは ・マクロはコンパイル前に置換されて、数値を直書きしたのと同等に扱われる ・enumと整数との間に暗黙の型変換がある ということからです。 C++ではより厳格になり、警告ではなエラーになります。 また、整数との暗黙の型変換も無くなったので、 「subA(M0);」等もエラーになります。 定数としてのenumの欠点は「整数型しか使えない」ことです。 enum F { F0=0.5 } 等とはできません。 #define F0 0.5 は可能です。 定数としてのマクロの利点であり欠点でもあるのが「型が無い」ことです。 C++でsubF(double) と subF(int)があった場合 subF(F0) と記述したとき #define F0 0.0 と #define F0 0 とでは呼び出される関数が別になります。 doubleの方を使いたいのなら subF((double)F0) とか #define F0 (double)0 とか明示する、という方法があります。 他の方法として、マクロではなく const double を使うものがあります。 const double F0=0.0 ; なら、F0は常にdoubleです。=0 と書いても、暗黙の型変換がはたらきます。 これを関連する定数をまとめる方法の一つとして、「structのstaticメンバーにする」というのがあります。 その例が struct S です。 > 構造体と列挙型の違い これは、まったく別のものです。 構造体は、いわば複数の変数をひとまとめにして扱うためのもの 列挙型は、一連の「名前」を扱うためのものです。
作りなおさずに、ということになると以下の手順でできます。 (1) フォーム デザイナ(WebBrowser、ToolStripの配置に使った機能です)を開きます。 (2) WebBrowser 上で右クリックします。 (3) 「最前面へ移動」をクリックします。 これだけです。 (2) ～ (3) は ToolStrip を「最背面へ移動」でも構いません。
WebBrowserコントロールを全面に配置したフォームを作成して、MDI子フォームとして追加する。 ってところでしょうかね。 現状ではwebBrowser1はMDIのコンテナより上(Zオーダーで手前)に表示されているので、 MDIのコンテナ内であれやこれやしても被さったままです。 よって、MDI子フォームがブラウザより手前に表示されることはありません。 # ガラスの手前に張ってあるシール(WebBrowserコントロールに相当)より手前に、ガラスの向こうの景色(MDIコンテナの内容)が見えることがないように。
2 で割るのを忘れてました.
配列へのポインタの配列を使えばいい.
子ウィンドウ自体をWPF Windowにすることができるかは調べていませんが， ElementHostコントロールを使うことで，WinFormsの中にWPFのコントロールを埋め込むことができます。 http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.110).aspx
f=15ですがな。
c/c++側が引数と戻り値を使って値を保持すればいいのではないでしょうか。
ポインターというのは格納された値のアドレスのメモリーを指すための変数です。 一方、配列はデータを格納するためのメモリーを確保して、その先頭のアドレスが入っていますよ。 char *a; scanf("%s", a); と書くと、aを初期化せずにaの指す先にscanfで文字列を入れます。 大抵、プログラムが書き込むことを許されていないメモリーに書き込みを行おうとしたことを検出したOSからそのプログラムは強制終了されます。 char *a = "aaaaa"; scanf("%s", a); となっているとどうなるか。 aは"aaaaa"が格納されているメモリーを指すように初期化されます。 ただ、大抵"aaaaa"は固定値を入れるために書き込みができないメモリーに格納されています。 よって、scanf("%s", a);も書き込みができないところに書こうとしたことをOSに検出され、強制終了となります。 2つ方向があると思います。 1. char a[128];のように宣言し、スタック上にメモリーを確保し、その先頭アドレスが入っているaを渡す方法。 2. mallocなどでヒープにメモリーを確保する方法。 1だと、 char a[128]; scanf("%127s", a); のように書き、scanfで読み込んだ分をaから始まるメモリーに書くことになりますが、char a[128];で配列を確保しているので書き込みを行うことができ、強制終了はされません。 2だと、 char *a = malloc(128); scanf("%127s", a); printf("%s", a); free(a); のように書きます。 配列はスタック上に取られ、スタック上に取った値はプログラムがその関数を抜けるときに自動的に解放されますが、mallocで確保したメモリーは自動で解放されないので自分でfreeを呼んで開放する必要があります。 %127sがそろそろ気になっていると思います。 こうやって127文字までしか受け取らないようにscanfに指示しています。 C言語では文字列の最後は終了を示すNUL文字が入るので、確保したメモリーよりも１少ない値となっています。 というわけで、ちゃんとメモリーを確保してからscanfで書き込みましょう。ポインターはあくまでどこかのメモリーアドレスを指すだけで、指した先がちゃんと確保されているかどうかは知りませんから。
昔に比べてムツカシとのことですが、、、、、 自分もMFCを利用していた時もありましたし、フレームワークを使わずにネイティブなC言語/Win32API環境でコードを書いていた時もありましたが、それらに比べてC#でのマルチスレッドの実現はかなり簡単になっていると思っています。 きっちりしたアプリを作る場合には、だいたいは非同期処理の部分に進捗表示と処理のキャンセルのUIを持たせる必要が出てくると思います。(PostMessageによるメッセージング機構を引き合いに出されていたのもそういう関連からかと思います) No.2の回答でBackgroundWorkerを推したのは、MSDNのリファレンスページでも書かれていますがBackgroundWorkerがUI連携を前提とした設計のクラスですので、そこから入るのが良いかと思ってのことです。 話が広がり過ぎるかと思い書きませんでしたが、C#で非同期処理を実現する方法は多数の選択肢があって、シンプルに作るならばたとえば以下のような形もあります。これは結構書きやすいと思います。 (1つのスレッドだけの例ですが、複数あっても大したことは無いと思います。) PostMessageは通知とUIスレッド側へのコンテキストスイッチの2つの機能を備えたものと言えると思いますが、別に1操作でそれを行えないと実現できないことがあると言うわけでもありませんので、スレッドではイベントを単に通知して、利用側(UI操作が必要な側)が自分の都合でUIにコンテキストを移すという感じです。 こう分離しておくと、非同期処理側がUIを全く意識しなくてよくて、UIフレームワークを別のものに変えたとしても非同期処理に変更の必要がないというような利点もありますね。 class AsyncWorker { public event Action Started; public event Action Finished; public void Start() { ThreadPool.QueueUserWorkItem(_ => run()); } private void run() { this.Started(); // 何かの処理 this.Finished(); } } private void button_click() { // 非同期処理クラスをのイベントをハンドルして非同期処理開始。 // 利用側でUIへ処理委譲 var asyncWork = new AsyncWorker(); asyncWork.Started += () => this.BeginInvoke(new MethodInvoker(beginAsync)); asyncWork.Finished += () => this.BeginInvoke(new MethodInvoker(beginAsync)); asyncWork.Start(); } private void beginAsync() { // 開始時UI変更など } private void endAsync() { // 終了時UI変更など } 非同期処理の終了待機については、(ここでは途中の進捗通知やキャンセルサポートなをとりあえず置いておくとして)以下のようにすることも出来ますね。 private void Start() { ThreadPool.QueueUserWorkItem(_ => { // 複数の非同期処理を開始して全部が終了するのを待つ var exitEvents = Enumerable.Range(0, 3).Select(n => new ManualResetEvent(false)).ToArray(); foreach (var evt in exitEvents) { ThreadPool.QueueUserWorkItem(__ => { // なんらかの非同期処理 // 終了フラグのイベントをシグナル化 evt.Set(); }); } WaitHandle.WaitAll(exitEvents); this.BeginInvoke(new MethodInvoker(onEnd)); }); } private void onEnd() { // 全部終わった後の処理 } もっとも、これはC#としては少々古い書き方で、現在であれば並列処理ライブラリなどが充実しているのでたとえば上記の複数実行＆待機と同じことが以下で出来ますが。 Parallel.For(0, 2, (num) => { // なんらかの非同期処理 }); 他にも一部のデータ処理の一部だけ並列化したい場合はPLINQで以下のような形とか。 // URLのリストがあるとして var urlList = new List<Uri>(); // 同時に最大10個までを非同期ダウンロードして var downloadData = urlList.AsParallel() .WithDegreeOfParallelism(10) .Select(url => { using (var webClient = new WebClient()) { return webClient.DownloadString(url); } }); // ダウンロード出来たものから何らかの処理をする、など。 foreach (var data in downloadData) { // データを処理 } 手段はいろいろありますので順に全てを学んで、C#のガベージコレクションやラムダ式によるクロージャなんかは非同期処理とも相性が良いので、そのあたりも組み合わせて必要な所に必要なものを利用するようにすれば、結構簡単に目的を実現できたりすると思います。 （私のの場合は、簡単なツールを作るぐらいの場合であればNo.2の回答に示したURL先にも書いたように、1メソッド内で開始のUI変更と終了のUI変更を閉じ込めてしまうさらっとした書き方をよくしますね。）
＞「64 だし、文字としてみると '@' 」とは！ ＞　　どういったことなのでしょうか？ @ の文字コードが、"01000000" だということです。ただし、文字コードをビット列で書くとかさばるので、普通は文字コードは16進文字列で表しますが。 ビット列で表現された文字コード表をみると、 http://charset.7jp.net/sjis.html 上位4ビットが"0100"で、下位4ビットが"0000"のところに、@ と書いてあるでしょ。 この表では、シフトJISと書いてありますが、先頭128個の文字(ビット列で"00000000"から"01111111"まで)は、ほとんどの文字コードで共通です。
y += tmp;は y=y+tmp;のことを+=と書いてもいいという決まりです。
>グローバル変数は初期化時に-1を代入しているのですが、子のダイアログをコール時に親の初期化のところがなぜかコールされてしまい、子に渡すときは-1になってしまいます。 「なぜか」ではなく、そのようなコードを書かれていますけど。 また Form1::aaa はグローバル変数ではなくForm1クラスのインスタンス変数です。 インスタンス変数はインスタンスが異なれば異なります。 void Form1::OpenMenuToolStripMenuItem_Click(object sender, EventArgs e)内で >Form2 f2 = new Form2(); を行っているForm1のインスタンスと Form2::Form2()の >Form1 f1 = new Form1(); // 新しくForm1クラスのインスタンスを作ってる >int bbb = f1.aaa; f1は別物です。 Form2のコンストラクタに public Form2(int bbb): this() { // Form1 fr = new Form1();なんてしない } を作っておいて Form2 f2 = new Form2(aaa); ではダメなんでしょうか。
No4です。 16進数はC#他多くの言語で「0x」を頭につけて表記します。 https://ja.wikipedia.org/wiki/%E5%8D%81%E5%85%AD … 256を掛けて足すというのは、 int charCode = 0; foreach (byte item in bytes) { charCode *= 256; charCode += byte; } ということです。(多分動くつもりですが未チェック)
基本的にはThreadクラスでどうとでもなるし、Formのボタンクリックによるイベントハンドラがスレッドを起動するのであればBackgroundWorkerが中間スレッドになるのが良いかも。以下、画面の描画やマウスボタンクリックの処理をしているスレッドをUIスレッド、複数のスレッドを起動して終了を待ち、最後にUIスレッドに報告するスレッドを子スレッド、何かしらの処理をする複数のスレッドを孫スレッドとして説明する。 BackgroundWorkerクラスを使う時の流れ ・BackgroundWorkerのインスタンスを作る ・Startボタンクリックイベント→BackgroundWorker#RunWorkerAsyncを呼び出すのとStartをDisable、EndをEnableにするのをやる(*1)。 ・BackgroundWorker#DoWorkイベント→今ここは子スレッドで動いている。ここで複数の孫スレッドを起動し、全ての孫スレッドの終了を待ってからDoWorkイベントを終了する。孫スレッドから子スレッドへなんらかの通知をしたい時にはdelegateなどを用いてコールバックすれば良い。 ・子スレッドで動作するDoWorkが終了すると自動的にUIスレッドでBackgroundWorker#RunWorkerCompletedイベントが呼ばれる(*3)のでボタンのEnable/Disableを切り替える(*2)。 ・EndボタンクリックイベントではBackgroundWorker#CancelAsyncを呼び出す。子スレッドで動いているDoWorkの中ではBackgroundWorker#CancellationPendingがtrueなら孫スレッドに停止命令を出すなどする。 ・DoWorkを動かしている子スレッドから画面に何か通知したい時はBackgroundWorker#ReportProgressを呼び出し、UIスレッドではBackgroundWorker#ProgressChangedイベントに応答して画面にメッセージ出すなどする。 (*3)があなたのイメージと少し違うかも知れないが、複数のスレッドがメインスレッドに対してそれぞれ起動と終了を通知するのではなく、単純にががっとスレッドたちを起動して全部が終わるのをざざっと待って全部が終わったら自動的に親が終了を判断できるという方がシンプルになるんじゃないかな。
デバグモードとリリースモードで違いが出る、という場合、真っ先に疑う点は「変数の初期化」です。 例えば int flag; if(! flag) { 初期化(); } とある場合、デバグモードでは常にflag=0となり、初期化が実行されますが、リリースモードでは、flagの値は不定で、0のときもあればそうでないときもあります。 そのSetViewportOrgに値を設定している箇所を探し、それが実行される条件を調べ、その中に初期化しないで使っている変数が無いか、調べまてみましょう。 コンパイル時に、警告レベルを高く設定するのもよいです。
count を使用している個所では値を更新していないことが保障されます。 ……と言いたいところですが、そんな保障はキャストによって簡単に破ることができます。 とはいえ、キャストしなければ参照のみの箇所と更新を行っている個所とを明確に分けることができるため、コーディング規約を遵守している開発現場では一理あるコードではあります。 まあ、C++ ならばこんな共用体を使うよりクラスで変数を囲ってゲッターとセッターを用意するのが筋なのですが。
...というわけで、5つのグループから一度使ったカードは使わずに引けなくなるまで引いてくるコードも書いてみました。 #include <stdbool.h> #include <stdint.h> #include <stdio.h> #include <stdlib.h> #define NUM_GROUPS 10 #define NUM_MEMBERS 5 #define NUM_PICKUPS 5 #define USED -1 struct card_group { size_t next; int cards[NUM_MEMBERS]; }; struct available_groups { size_t size; int group_ids[NUM_GROUPS]; }; void shuffle(int *elms, size_t size) { for (int i = 0; i < size; i++) { uint32_t pos = arc4random_uniform(i); int tmp = elms[pos]; elms[pos] = elms[i]; elms[i] = tmp; } } /* * Draw cards from "cards" to "drawn_cards". Caution: a value of used card * will be overwritten with "USED". */ bool draw(struct card_group groups[NUM_GROUPS], int drawn_cards[NUM_GROUPS], struct available_groups *available) { if (available->size < NUM_PICKUPS) { // cannot continue the game. return false; } shuffle(available->group_ids, available->size); for (size_t i = 0; i < NUM_PICKUPS; i++) { int gid = available->group_ids[i]; struct card_group* cg = &groups[gid]; drawn_cards[i] = cg->cards[cg->next++]; if (cg->next >= NUM_MEMBERS) { // means used up this group. available->group_ids[i] = available->group_ids[available->size - 1]; available->size--; } } return true; } void print_all_cards(struct card_group groups[NUM_GROUPS]) { printf("CARDS:\n"); for (int i = 0; i < NUM_GROUPS; i++) { printf("group %d: ", i); for (int j = 0; j < NUM_MEMBERS; j++) { printf("%02d ", groups[i].cards[j]); } printf("\n"); } printf("----------\n"); } int int_cmp(const void *i1, const void *i2) { return *((int*)(i1)) - *((int*)(i2)); } int main(void) { struct card_group groups[NUM_GROUPS]; struct available_groups available; // initialize. for (int i = 0; i < NUM_GROUPS; i++) { for (int j = 0; j < NUM_MEMBERS; j++) { groups[i].cards[j] = i * NUM_MEMBERS + j + 1; } groups[i].next = 0; available.group_ids[i] = i; } available.size = NUM_GROUPS; print_all_cards(groups); // shuffle. for (int i = 0; i < NUM_GROUPS; i++) { shuffle(groups[i].cards, NUM_MEMBERS); } print_all_cards(groups); // draw. for (;;) { int drawn_cards[NUM_GROUPS]; if (!draw(groups, drawn_cards, &available)) { break; } qsort(drawn_cards, NUM_PICKUPS, sizeof(int), int_cmp); for (int i = 0; i < NUM_PICKUPS; i++) { printf("%02d ", drawn_cards[i]); } printf("\n"); } return 0; } 途中、10回表示が出ないことに頭をかしげましたが、大抵グループは多少偏って選ばれるので、一部のグループだけ多めに残るのは不思議ではないですね。 実行例) CARDS: group 0: 01 02 03 04 05 group 1: 06 07 08 09 10 group 2: 11 12 13 14 15 group 3: 16 17 18 19 20 group 4: 21 22 23 24 25 group 5: 26 27 28 29 30 group 6: 31 32 33 34 35 group 7: 36 37 38 39 40 group 8: 41 42 43 44 45 group 9: 46 47 48 49 50 ---------- CARDS: group 0: 04 03 05 02 01 group 1: 10 06 07 08 09 group 2: 12 13 14 15 11 group 3: 19 16 17 20 18 group 4: 22 25 24 21 23 group 5: 29 30 27 28 26 group 6: 34 33 35 32 31 group 7: 40 39 36 38 37 group 8: 43 45 42 41 44 group 9: 48 50 47 46 49 ---------- 10 22 29 34 43 04 19 25 33 48 03 06 12 16 24 05 07 35 40 45 08 13 17 30 39 14 20 21 27 36 02 32 38 42 50 23 28 31 41 47 01 09 15 18 44
「他のアプリケーション」が何で記述されているのか 関数はdllで提供されているのか などによって、できるのかできないのか、どうやればできるのかなど変わりますけど。
定型処理をUACダイアログを表示させずに行うことは可能です。 １．タスクスケジューラーに、その定型作業を登録します。 ２．このとき、「最上位の特権で実行する」をチェックします。これでUACを回避できます。 ３．実行したいときは、「schtasks /run /tn タスク名」を実行します。 タスク登録の詳細手順： １．コントロールパネル→システムとセキュリティ→管理ツール→タスクスケジューラ ２．右側ペインで、「タスクの作成」をクリック ３．全般タブで、名前を適当に付け、「最上位の特権で実行する」をチェック ４．操作タブで、「新規」をクリック ５．操作を「プログラムの開始」のままで、プログラム欄と、必要があれば引数欄を入力。開始欄には必要があれば、プログラム起動時のカレントフォルダを指定。引数が複雑だったり、複数ステップだったりならバッチファイルにしておくのがいいでしょう。 ６．あとはOK
関数名を書くと, 一部の例外を除き自動的に「当該関数へのポインタ」に変換されます. 配列名を書いたときに (これも一部の例外を除き) 自動的に「先頭要素へのポインタ」に変換されるのと同じ. だから, ただ単に int_cmp と書けば (「例外」でなければ) その関数へのポインタとなりますが, この「関数へのポインタ」は #1 にもあるように &int_cmp と書いても同じように得ることができます.
その「思ったこと」を, 実際に試さないんですか?
文字コードによっては「漢字なら2バイト」とは限らんよ＞#3.
No1 です 状態はわかりましたが確認として　 SendMessage(hTree,TVM_SETITEM,0,VarPtr(tvi)); こっちの戻り値確認する方が先ではないかと http://chokuto.ifdef.jp/urawaza/message/TVM_SETI … 後　TVITEM tvi;　の使ってないメンバはクリアしておいたほうが良いかもしれません http://chokuto.ifdef.jp/urawaza/struct/TVITEM.html 実際使ったことがないので具体的なことは言えませんが 参考として以下あたりが参考になるのではないかと思います SendMessage使うならMSDN探せとか書いてあるけど http://www.nitoyon.com/vc/reference/gui/treeview …
// 実際に書いた方が分かりやすいと思って適当に // 記述が多いとか分かりづらいみたいなのを気にする以前なので気にしなくていい // ほとんどコピペ // コンパイルすら通してないので変な書き間違えがあるかも #include <stdio.h> #define HOWMANY 10// いくつ数値を入力させるか;複数の箇所で使われる同じ意味の定数は定義しておくべき int getmin(int * pvalue); int getmax(int * pvalue); int main(void) { 　　　　int i, value[HOWMANY]; 　　　　int minimum, maximum; 　　　　printf("0~100の範囲で%d個の数値を入力してください：\n", HOWMANY); // 0～100でなかったら何度でも駄目だしを食らうようにした 　　　　for(i=0;i<HOWMANY; ) { 　　　　　　　　scanf("%d",&value[i]); 　　　　　　　　if( value[i] < 0 || value[i] > 100 ) 　　　　　　　　{ 　　　　　　　　　　　printf("0~100の範囲です：\n"); continue; 　　　　　　　　} ++i; 　　　　} 　　　　minimum = getmin(value); 　　　　maximum = getmax(value); 　　　　printf("最小値は%d\n", minimum); 　　　　printf("最大値は%d\n", maximum); 　　　　return 0; } // なんかよく分かんなかったので分かりやすくした int getmin(int * pvalue) { 　　　　int j = 0; int min = pvalue[j]; 　　　　for(j=1;j<HOWMANY;j++) 　　　　{ if(pvalue[j] < min) min = pvalue[j]; 　　　　} 　　　　return min; } int getmax(int * pvalue) { 　　　　int j = 0; int max = pvalue[j]; 　　　　for(j=1;j<HOWMANY;j++) 　　　　{ if(pvalue[j] > max) max = pvalue[j]; } 　　　　return max; }
C言語では data[0] と *data は同じ意味です。同様に data[1] *(data + 1) data[3] *(data + 3) data[i] *(data + i) も、すべて「同じ意味」です。 なので average += *(data + i); は average += data[i]; と書く事が出来ます。
Visual Studioのバージョンを明記していただけると助かります。 以下のページの「XMLファイルに出力する」という項目を参考に、 ビルド時にドキュメントコメントをXMLファイルに出力するよう設定し、ビルドしてください。 http://dobon.net/vb/dotnet/programing/xmldocumen … 別プロジェクトで参照設定したDLLファイルと同じフォルダにXMLファイルを置き、 そのプロジェクトを開くとIntelliSenseやオブジェクトブラウザで説明文が出るようになります。
>あまり多く文字列比較系のアルゴリズムは、実際にOSのソースを見ても >あんまり変わってないな・・という気もしますが >どうでしょうか？ どのOSのソースを見られてるのかわかりませんが文字列比較のアルゴリズは変わりようがありません。 ですが特定のファイルやディレクトリにたどり着く分には、その文字列比較そのものの回数を減らすような仕組みになっています(先にも書きましたがstrstrなんかではありません)。
質問者のために補足しておくと, #9 にある 「(型の内容)引数名」というキャスト というのは一般的な表現ではありません. 少なくとも, こんなところで「引数」という表現を使うのは一般的ではない.
回答No.2です。 > つまり、極端にいうと材料があり、C言語で書いて作れないことはないのでしょうか？ そうですね、可能です。と言うより、No.1回答者さんのアプローチはまさにその部類になるし、そうする方が実装が楽なので、取っ掛かりとしては最適だと思います。 > あと、ハードウェアで性能がよく、windowsで性能があまり良くないのかが理解できません。 Windowsで性能が出ないのは先の回答でも触れたとおり、基準となるタイマーが1msの分解能しかないからです。Windowsはリアルタイム性を追求したOSではないので、あまり高速な応答性を求められる分野には向いていません。そうした処理に強いOS（ROS:Realtime OS）だったら、より高い分解能で処理が可能です。国産OSのTRONなどはその用途に特化してますね。 ただし今回のように周波数カウントさえできれば、別にマルチタスクなんて高級な物は不要だというアプリケーションだと、OSなんてもの自体必要なくて、専用プログラムだけを入れて動かせばそれで済むわけです。これならCPUパワーをその処理だけに全て投入できるから、非常に高速に応答する物が作れます。例示されているキットが、PCよりもはるかに貧弱な処理能力しかないにもかかわらず、MHz単位の計測にも耐えられるのは、そう言う理由からです。
　いろいろと見ているうちに取り違えたようです。 ＞俺的まとめ ＞http://mariarom.blog76.fc2.com/blog-entry-12.html ＞ディスプレイ（モニタ）の電源をオン・オフする 　ここをどうぞ。 参考URL：http://mariarom.blog76.fc2.com/blog-entry-12.html
全部印刷したら百科事典なみの恐ろしいページ量になると思います。目的のものを探す事さえ困難なので検索性の高いWEBで見たほうが良いと思います。
> structobj&型と、structobj型の違いとは何でしょうか。 参照型か否か、です。両者は別物。 int i = 0; int& ref = i; // ref は i の参照 ++ref; // ここで i == 1 となる
たぶんだけど、 片方はマルチバイト文字を既定に指定していて、 もう片方はUNICODEを既定にしているせいだと思うよ tchar.hをインクルードして、文字列は全て_Tマクロでくくれば問題は解決すると思われます const char CLASS_NAME[] = "WinMain"; から LPCTSTR CLASS_NAME = _T("WinMain"); こんなかんじに全て書き直す
大雑把に言えばGDIはCPUで画面描画するもの、DirectXはGPUで画面描画するものと言った感じでしょうか。
既に回答があるから蛇足なんだけど, 「そうすると、(int&)*iPVector.begin()について、」 の「そうすると」の意味が全くわからない. なにがどう「そうすると」なんだろう? そんな書き方, どこで見たんでしょうか?
うーん、具体的なロジックが不明なので何とも言えませんが、 DirectoryCatalog()で指定してたディレクトリに入っているDLLが古かったりしませんか？ DLLをコンパイルしているだけで、DirectoryCatalog()のディレクトリ内にコピーし忘れてるとか。 関数();は、PictureBox1がクリックされた際に実行されるものであると思われますが、 そのDLL内部の関数()内で、『クリックしたときのイベント』というのがあるのも不可解ですが、 前回の流れ的に、ボタンをクリックした時のイベントでしょうかね？？ テキトーに作成したところ、問題なく動きますので、コピー忘れなどの安直なミスだと 思うんですが・・・。 【I/F】 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace MefIf { public interface MefIf { string picturebox1url(); void viewControls(Control c); } } 【AddIn1】 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.ComponentModel.Composition; using MefIf; namespace Mef1 { [Export(typeof(MefIf.MefIf))] public class Mef1 : MefIf.MefIf { public string picturebox1url() { return @"C:\1.png"; } TextBox t = null; Button b = null; public void viewControls(Control c) { if (t != null) { c.Controls.Remove(t); } if (b != null) { c.Controls.Remove(b); } t = new TextBox(); t.Left = 100; t.Width = 100; t.Top = 100; t.Height = 20; c.Controls.Add(t); b = new Button(); b.Left = 100; b.Width = 100; b.Top = 130; b.Height = 20; b.Text = "Click!"; c.Controls.Add(b); b.Click += (s, e) => { t.Text = "DLL1"; }; } } } 【AddIn2】 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.ComponentModel.Composition; using MefIf; namespace Mef2 { [Export(typeof(MefIf.MefIf))] public class Mef2 : MefIf.MefIf { public string picturebox1url() { return @"C:\2.png"; } TextBox t = null; Button b = null; public void viewControls(Control c) { if (t != null) { c.Controls.Remove(t); } if (b != null) { c.Controls.Remove(b); } t = new TextBox(); t.Left = 200; t.Width = 100; t.Top = 100; t.Height = 20; c.Controls.Add(t); b = new Button(); b.Left = 200; b.Width = 100; b.Top = 130; b.Height = 20; b.Text = "Click!"; c.Controls.Add(b); b.Click += (s, e) => { t.Text = "DLL2"; }; } } } 【Form】 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.ComponentModel.Composition; using System.ComponentModel.Composition.Hosting; using MefIf; namespace WindowsFormsApplication2 { public partial class Form1 : Form { private DirectoryCatalog catalog; private CompositionContainer container; [ImportMany] private List<MefIf.MefIf> addins; public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { catalog = new DirectoryCatalog("plugins"); container = new CompositionContainer(catalog); container.ComposeParts(this); } private void button1_Click(object sender, EventArgs e) { foreach (var addin in addins) { var PictureBox1 = new PictureBox(); if (addin.ToString() == "Mef1.Mef1") { PictureBox1.Left = 10; PictureBox1.Width = 100; PictureBox1.Top = 10; PictureBox1.Height = 80; } else { PictureBox1.Left = 200; PictureBox1.Width = 100; PictureBox1.Top = 10; PictureBox1.Height = 80; } PictureBox1.ImageLocation = addin.picturebox1url(); PictureBox1.Click += (s, ex) => { addin.viewControls(this); }; this.Controls.Add(PictureBox1); } } } }
CentOS 6.5にPoderosa 4.3.8bで接続して試しました。 [user@localhost ~]$ ./a.out type your message >>>> 1234 typed : 1234 [user@localhost ~]$ ってコトで正常に動作していますが……。 それなら…と、送信改行コードをCR+LFにしてみました。 [user@localhost ~]$ ./a.out type your message >>>> test typed : [user@localhost ~]$ fgets()の直後に printf("len=%d\n", strlen(msg)); を入れてコンパイル。送信改行コードをCR+LFにして実行してみました。 [user@localhost ~]$ ./a.out type your message >>>> test len=1 typed : [user@localhost ~]$ 送信改行コードをLFに設定し、入力待ちになってから送信改行コードをCR+LFに換えてみました。 [user@localhost ~]$ ./a.out type your message >>>> test len=5 typed : test [user@localhost ~]$ とりあえずの実験結果です。
計測か何かでしょうか？ 計測の場合精度の問題がでるので時間精度に関わる所は外部の計測機器・マイコンなどで処理した上で、ＰＣではロギングに徹するなどの対策が必要になります。 あるいは既に書かれているリアルタイムＯＳに切り替えるかです。その場合C#が使えない可能性が高いです。
>たとえばの数字は思いつきで書いたものであって根拠はないです。データ入力は超えないすうじがはいります。 例えば、以下のような質問があったとします。 >複数の数字を入力してその合計を出力するには、どのようなコードを書けばいいですか。 >例) 1 2 3 を入力したら合計として 456 が出力される。 これ作れますか？ こういう場合大抵、問題が間違ってるのか例が間違ってるのか悩むことになります。 なので例をあげるならあげるで適切な例をあげないと意味ないですよ。
> public void DLL関数(Control.ControlCollection Controls) > { > var textbox1 = new TextBox(); > textbox1.Location = new System.Drawing.Point(10, 260);// > textbox1.Size = new System.Drawing.Size(180, 20); > textbox1.Name = "textbox1"; > Controls.Add(textbox1); > } DLL側がまさにこうだとすると、ちょっとあまりよろしくないのではないでしょうか。 TextBoxのNameプロパティも被るし、作成したコントロールを戻しているわけでもないし。 実際、その生成されたコントロールを操作したい場合はどのようにしているのでしょうか？ 生成されたコントロールが判断つくなら、フォーム内で Control control = 対象コントロール; this.Controls.Remove(control); control.Dispose(); で消せます。 以下、実際の動きとは異なるでしょうが、機能1ボタン、機能2ボタンでコントロールを切り替える例になります。 Findメソッドは全プロパティからその文字列を検索するので、都合が悪いようなら、やはり 生成したコントロールを呼び元で認識できる方が良いと思います。 Nameプロパティだけを調べて見つけ出すには、下記ページのように作りこまなければならないので、 そもそも複雑な制御でない場面で、それが必要になる方が問題のような気がします。 http://jeanne.wankuma.com/tips/csharp/form/findc … public void DLL関数(Control.ControlCollection Controls) { var textbox1 = new TextBox(); textbox1.Location = new System.Drawing.Point(10, 260);// textbox1.Size = new System.Drawing.Size(180, 20); textbox1.Name = "textbox1"; Controls.Add(textbox1); } private void 機能1_Click(object sender, EventArgs e) { this.removeDynamicControls(); this.DLL関数(this.Controls); } private void 機能2_Click(object sender, EventArgs e) { this.removeDynamicControls(); this.DLL関数(this.Controls); } private void removeDynamicControls() { Control[] controls = Controls.Find("textbox1", true); foreach (Control control in controls) { this.Controls.Remove(control); control.Dispose(); } }
>発生順に実行されないようです。 これは当然の話です。CreateThreadの実行順と、実際に 制御が渡る順番は一致しません。どうしても一致さたい というなら、イベントハンドラはスレッドが処理を開始 したことを認識するまで待機しなければなりません。 EventProc(){ 　HANDLE　開始イベント = createEvent(…);//★1 　HANDLE　スレッド = createThread(,,,Thread_Proc,&開始イベント,…); 　closeHandle(スレッド);//★2 　waitForSingleObject(開始イベント,…);//★3 　closeHandle(開始イベント);//★4 } Thread_Proc(HANDLE *開始イベント){ EnterCriticalSection(&m_cs); g_Value += Now(); setEvent(*開始イベント);//★5 LeaveCriticalSection(&m_cs); } 1.サブスレッドが実行されたことを通知するイベントを作る。 　これはスレッド起動時にパラメータで渡す。 2.スレッドハンドルは不要なら閉じる。 3.サブスレッドが処理を始めるまで待機する。 4.不要になったイベントを閉じる。 5.サブスレッドが処理したことをメインスレッドに知らせる。 　この操作で、★3の待機が解除される。
＞分割統治については、以下の説明があります。 ＞http://e-words.jp/w/E58886E589B2E7B5B1E6B2BBE6B3 … あちゃ～、何処の誰だよ、こんな「直訳」を正式な用語に採用したアホタレは。 用語として「分割統治」が採用されちゃってるなら、それが「正解」なんだろうけど、もっと気の利いた「意訳」は出来なかったんかねぇ？ 例えば「分割攻略」とかさ。 ＞ただ、よくわからないのは、その「シリアル（順序立てて）」は何を順序立ててデバッグすることなのか？ ＞ 3つの手法を順序立てて行うという意味なのか、分かりませんでした。 デバッグは状況に応じて、トップダウンで行う場合とボトムアップで行う場合がありますが、どちらの場合も「順番に潰していく」必要があります。 下から順番であれば、最下位のルーチンを潰して、それを呼んでいるルーチンを潰して、などです（この場合の「潰して」は「バグが無い事を確認する」と言う意味です。 この本の場合は「以下の３つの各項を順序立てて行う」で良いと思います。
>その他にもおススメのサイトを知りたいです。 今、どのサイトで勉強しているかわかりません。 新・C言語 ～ゲームプログラミングの館～ [DXライブラリ] ゲーム作りで学ぶ!実践的C言語プログラミング ゲームプログラミング入門 C/C++言語とDXライブラリでゲーム作成入門 0からのゲームプログラミング　さん等のサイトがあります。 また、言語に関係なく基本的な考え方は同じだと思うので、言語の縛りを付けず他の言語のサイトでも 見てみたらどうでしょう？
>こういうことってなかなか入門書なんかには書いてないので非常にありがたいです！ 入門書レベルではそこまで深い(環境依存度の高い)ネタはやらないんでしょう。 # たとえば質問でも書かれているCtrl+DでEOFはUNIX系の場合(というかシェル？)依存ですし。 >本にはこうなりますってものと同じもの書いてもならないと、本が間違ってるのか何のか分からなくなりますからね。 著者が前提としている(あるいは動作確認した)環境が明示されていないモノは…避けた方がいいかもしれませんね。 たいていはOSやコンパイラ、バージョンなんかが明記されているかと。 最初の方に書かれているか、後ろの方の索引近くに書かれているかという違いはありますが。 # 入門書なり購入するときは明記されているか確認・納得の上で購入した方がよいでしょう。
結論を先にいうと「言語仕様がそうなっているから」なんだけど.... エラーメッセージは正確に書いてください. 特に, メッセージを理解もできずに無理に (そして間違って) 訳すくらいなら英文の方がはるかに有用です.
eclipse vim & ctag emacs & etags あたりでできるかと。
あなたの期待する入力、期待する出力をもっと具体的に説明してはいかがでしょうか。 あなたが何を期待しているのか誰にもわからないので、このままではまず的を射た回答は得られないと思います。 一応これまでの質問を読ませてもらいました。 http://oshiete.goo.ne.jp/qa/8503397.html http://oshiete.goo.ne.jp/qa/8503486.html これらから予想すると、いくつかの数字を入力させて、それを表示させたいのではないかと思ったのですがどうでしょうか。 まあ、人が書いたプログラムというのも何かの勉強の足しになると思うので一応書いてみます。 プログラムの説明) ユーザーからn (n <= 4) 個の自然数を受け取り、それをスペースで区切って表示する。 ユーザーが0以下の値を入力すると受け取りが終了する。なお、表示にその0以下の数値は含まれない。 また、数値が4つ入力されると自動的に受け取りを終了し、表示を行う。 動作例) input? (ユーザーからの入力)10(改行) (ユーザーからの入力)25(改行) (ユーザーからの入力)-1(改行) 10 25 コード) #include <stdio.h> #define INPUT_SIZE 4 int main(void) { int input[INPUT_SIZE]; int input_size; printf("input?\n"); for (input_size = 0; input_size < INPUT_SIZE; input_size++) { scanf("%d", &input[input_size]); if (input[input_size] <= 0) break; } for (int i = 0; i < input_size; i++) { printf("%d ", input[i]); } printf("\n"); return 0; } あと、http://oshiete.goo.ne.jp/qa/8503486.htmlを見ていて、数値をシャッフルして出力するということもやりたいのかと思ったので、0から9までの数値をシャッフルして表示するプログラムも参考までに乗せておきます。 #include <time.h> #include <stdio.h> #include <stdlib.h> #define NUMELMS(X) (sizeof(X) / sizeof(X[0])) int random_int(int upper_bound) { if (upper_bound < 2) return 0; int min = ((RAND_MAX % upper_bound) + 1) % upper_bound; for (;;) { int r = rand(); if (r >= min) return r % upper_bound; } } void shuffle(int x[], size_t s) { for (size_t i = 0; i < s; i++) { int r = random_int(i + 1); int t = x[i]; x[i] = x[r]; x[r] = t; } } void print_all(int x[], size_t s) { for (size_t i = 0; i < s; i++) { printf("%d ", x[i]); } printf("\n"); } int main(void) { srand(time(NULL)); int x[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; shuffle(x, NUMELMS(x)); print_all(x, NUMELMS(x)); return 0; } 一応、すべてFreeBSD 10.0Rのclangでコンパイルして、動作確認はしていますが、C99を理解しないコンパイラーを使っているとコンパイルが出来ないかもしれません。 余談ですが、 okikayo さんのコードでいつも気になるのは配列のサイズ以上に値が入力される可能性を考慮していないことです。これはセキュリティー上の欠陥やプログラムのクラッシュを引き起こす欠陥になりえるので注意したほうがよいです。 あと、好みの問題も多々あると思いますが、関数を使うことや制御構造を変えることを考慮して、それでもどうしてもこの構造がよい時にのみdo-while文を使ったほうがよいと思います。条件の確認があとに来るという構造上、本来実行すべきでないコードを実行してしまったり、配列の添字の取り扱いを間違ったりとミスを起こしやすいですので。
Ｃ言語でもＣ++でも作れます。 ＤＸライブラリを使います。 「新・C言語 ～ゲームプログラミングの館～ [DXライブラリ]」 http://dixq.net/g/
既に、同じような質問の回答で指摘されていますが、 「うまくいきません」という質問は、プログラム関係ではしてはいけないものだと考えた方が良いです。 １）何をするプログラムか（普通の言葉で説明） ２）入力例 「"指定する数値を入力して下さい」（１回目）で、 1 2 3 4 5 -1 を入力 「"指定する数値を入力して下さい」（２回目）で、 9 8 7 6 5 -1 を入力 ３）想定される出力 5 2 1 3 4 5 ４）実際の出力 または コンパイルで出たエラーをリストアップ 最低限必要です。 「〇　　●●●●」が想定される出力ですか？
> どこか　おかしいですか？ コンパイラがエラーメッセージを出して教えてくれます。 エラーメッセージは横着せずにちゃんと読みましょう。 > [sa] 何がしたいのかさっぱりわかりません。 なので、どうしたら直せるかも答えられません。
＞茶筌のインストール ＞http://sils.shoin.ac.jp/~gunji/AI/logs/chasen-in … ＞茶筅（ChaSen）Windows版を試すAdd Star ＞http://d.hatena.ne.jp/january/20081226/1230260677 　こういった方法でしょうか。 参考URL：http://d.hatena.ne.jp/january/20081226/1230260677
質問の意図が分からんのだけど, strlen じゃだめ?
SQL Server compact editionはMSとして非推奨になっているからでしょう。 ref) Port SQL Compact to Windows RT | Microsoft Connect https://connect.microsoft.com/SQLServer/feedback … > 投稿者: Microsoft 、投稿日時: 2013/02/18 11:52 > SQL Server compact edition is in deprecation mode with no new releases planned near future. デスクトップアプリを前提にするなら， ・SQL Server LocalDBを使う ・SQLite等，別のServerless RDBを使う といった解決策を採ることになると思います。
No.4 ですがちょっと間違いました。 見つけた件数の判断方法は修正です。 for (int no = 0, out = 0; no < 総数 && out < パターン出力最大件数; no++){ _ 配列abcからno番目の組み合わせを探して第一引数に格納(組み合わせ例, abc, no); _ if (組み合わせが条件を満たしているか確認(組み合わせ例)) { _ _ 表示(組み合わせ例); _ _ out++; _ } }
ふむふむ。 で、閉じたダイアログウィンドウはどこで破棄しているの？ DestroyWindowはどこでやってるの？ まさか「関数を抜けたら勝手に破棄される」とか思ってないよね？
＞つまりこの画像http://imgur.com/gsPTatj.jpgであってるということですか？　実行の順番のことです。 惜しいけど、間違っている。 実行の順番は、以下の通り。 x：int tasizan(int a,int b){ x： 5：int c;　　⇐ 最初に変数ｃの領域を確保して 6：　　a+b;　⇐ 足し算を行ってから 7：c=　　　　⇐ 結果をｃに代入 8：　　　　 c;⇐ 最後にｃを取り出してから 9：return　　⇐ ｃを破棄してから、ｃの値を持って呼び出し元に戻る x：} ｘ：int main(void){ ｘ： 1：int a,b,c; 2：a=1; 3：b=1; 4：　　tasizan(a,b); ⇐ tasizannの呼び出し 10：c=　　　　　　　　⇐ 呼び出し結果をｃに代入 11：printf("%d+%d=%d",a,b,c); 12：return 0; ｘ：} 4番と10番のように「１つの行」の途中で、間に5～9番が入り込む。 また、6番と7番のように「行の左右で順番が入れ替わる」こともある。 更に、8番と9番のように、１つのステートメントで色々な事をする。 なので、行単位では「実行順」は議論できない。 あと「x：」になっている行は「特に実行する事がない」ので「x：」としてある。
> :make run これだと errorfille に出力させた後で vim が読み直すか tee 絡ませて表示してるはずなので、普通のコマンド実行の方がいいと思います :!./a.out みたいに
　最近のゲームソフトの中身というのは海外製ゲームエンジンをライセンス購入で使っていたような。 　技術力はあると思うけど、予算を出そうとしない、スポンサーを探さない、ベンチャー企業を育てないとかあるかな。 　新しい物があるとすぐ叩くところ。 　特にマスコミ。 　朝日新聞を購読しているけど、電子書籍端末を批判してみたり、ビットコインの不安を煽ってたり。 　既得権益にしがみつくばかりで、新しいビジネスモデルを作ろうとしない。 　改正著作権法でも、不正コピーはいけませんが、音楽業界の既得権益を死守するつもりらしいけど、時代に追いついていない。
strcat については前の http://oshiete.goo.ne.jp/qa/8460028.html で指摘したんだけどねぇ＞#3&#4. memset 自体は, 既に回答があるようにループのどこかに入れれば 1個で済むはず. しかし... 前のときにはあえて書かなかったんだけど, ENEMY のコンストラクタがすっごくバカに見える.
最初の方は、main関数だけで完結しています。 次に挙げられたプログラムは、 tasizan()関数を宣言し、 main関数の中でtasizan()関数を呼び出しています。 最終的に、やっていることは同じですが、 後者の方が関数の役割ごとに分割されていて 後々のコードメンテナンスがしやすいと思います。
>Fortranと比べてCは組み込み関数が少ないという印象を持ったのですが実際そうなのでしょうか？ 組み込み関数が少ないどころではなく、ありません(コンパイラ独自拡張によるものは除く)。
因みに、式の中の「カンマ」を「カンマ演算子」って呼ぶ。 カンマ演算子は、例えば int i,j,k; for (i = 0 , j = 10 , k = 100;i < 10;i++ , j--, k += 10) { 何かの処理 } みたいに使う。 こういう書き方を許しているので one = price * 9,0; もエラーにならないのだ。
「取り出す」って言うのがどういう用途を希望しているのか見えないんですが……。 >//データ取得 >da.Fill(dt); で、データベースから取得したデータがdtに設定されているでしょうから、 DataTableならその後で個別にアクセス可能かと思われますが。 dt.Rows[0][1] かな？
＞変化があったのでしょうか？ 質問文で掲示されているページの記事と、質問者さんの例（ほげ１ほげ２）は、表記は違えど「同じ事を言っている」ように見えるんですが。 「何も変わってない」と思いますが、どうでしょう？
こんにちは。 No thanks, just start my download. というリンクがあるとおもいますが、そちらを選択すれば登録はいりません。
No3のかたと大体同じような内容ですが、このようなパターンはObserverパターンと 言われている有名な構造で、複雑になりがちな構造ですが間違いというほどではないかと 思います。 http://ja.wikipedia.org/wiki/Observer_%E3%83%91% … class TimerObserver { public: 　virtual void onTimer() = 0; }; class Timer { public: 　void addObserver(TimerObserver* observer) 　{ 　　observers.push_back(observer); 　} 　// タイマーから一定時間ごとに呼び出されるイベント 　void timerEvent() 　{ 　　for(TimerObserver* o : observers) 　　{ 　　　o->onTimer(); 　　} 　} private: 　vector<TimerObserver*> observers; }; 複数のオブジェクトに対応する、ということなのでこんな感じでしょうか。
確認ですが, 「ポインタを使わない」とするとどんなプログラムを想定すればいいんでしょうか?
＞ご回答頂いた内容で、「書き込み」と「更新」の違いが良く解りませんでした。 「読み出してその値を加工して書き込む」 つまり、「 a=a+b 」のような操作を「更新」と書きました。 この場合は実際には読み出し、演算、書き込みの３つの命令が実行されます。 読み出しと書き込みの間で、他のプロセスが書けないようにロックします。 No1の参考に書いたURLのページを見てください。 a=100 のようにaの値を読み出さずに、値と無関係に書き込むだけなら、ロックの必要は無いです。 同時に動く別プロセスが読み出す値は、100かもしれないし、100を書き込む前の値が50だったとすると50かもしれない。ただ、かならずどちらかで、それ以外の変な値になることはありません。
こういう感じでしょうか。 http://pastebin.com/tpQnvyt9 暗号の例があれば、デバグできますが、 例がないので、試していません。
> ありがとうございます。実行してみたのですが > エラーで動きませんでした（汗） > lines.Remove(1);に対してのエラーなのですが 大変申し訳ございません、間違ったやつで投稿してし まいました。正しくはこうです。 List<string> lines = new List<string>(textBox1.Lines); lines.RemoveAt(1); // 2行目削除 textBox1.Text = String.Join("\r\n", lines);
ファイルの掲載を別に規制する法律はないので...
ただの文字定数の8進表記と16進表記です。 http://msdn.microsoft.com/ja-jp/library/edsza5ck …
> 消滅してるからどこにあるかわからないため、 > atoiを使うと0が帰ってくるのですね 不正解。 参照先のメモリーがすでに解放済みの場合の動作は、不定です。 あなたの使っているコンパイラ/実行環境では、たまたま 0 とか 1 を返してくれた、というだけのこと。 コンパイラ/実行環境が変われば、実行結果は変わってきます。 （プログラムミスだから、実行時エラーとかいうことも考えられる） この辺のことを追及する暇があったらさっさとプログラムを直せっちゅうことかな。
正直な話, 現状で何に不満なのかが分からない. 何がどう「あまりいい方法ではない」のでしょうか? なぜ 4分割するのかはよくわからんが.
>最低サポートバージョンのWindowsでアプリケーションを実行した場合、対象のAPIが実行される処理を通った時だけ、独自のエラー処理を実行したいのですが、このようなことは不可能なのでしょうか？ LoadLibrary()でdllを読み込ませて、GetProcAddress()でAPIのアドレスを取得できます。 それぞれでエラー処理できるはずです。 XPで実行したときにVista以降にしかないdllならLoadLibrary()でエラーになりますし、APIが無ければGetProcAddress()でエラーになります。 検索してみるとそういう処理の仕方を解説しているページは見つかるかと。 APIの中身が無い(何もせずに戻ってくるだけ)という場合もありますが。
>WSAData wsaData; WSADATA wsaData; ですね。 構造体のタグ名と型名の違いってとこですか。
コンピュータビジョン 最先端ガイド6（ CVIMチュートリアルシリーズ ）はもう読まれました？ 参考URL：http://opluse.shop-pro.jp/?pid=66985382
プリコンパイル済みヘッダを使っている(≒プロジェクト内にstdafx.hがある)なら #includeの部分を多少直す必要はあるかもしれませんが、 こちらではコンパイルできていますね。
TreeViewコントロールへの機能の付与は、TreeNodeオブジェクト（＝Nodesコレクションの要素）に対してではなく、TreeViewインスタンス自身に対して行います。 TreeViewクラスのリファレンスを見てもらえばわかる通り、大量のイベントと、定義ずみイベントハンドラメソッドがありますので、こちらでうんちゃらして下さい。 ttp://msdn.microsoft.com/ja-jp/library/system.windows.forms.treeview(v=vs.110).aspx C#のイベントドリブン・プログラミングは泣くほど簡単ですよｗｗｗ
No.1,3,4です。 > リモートのLEDをPCからGUIで制御したいのですが、実現が容易になるライブラリやフレームワークというものはありますでしょうか？ ・そのLEDを制御するのにUDPパケットを送るだけでよい ・GUIプログラムを実行する環境が.NET Frameworkを使える ということであれば、.NET FrameworkとC#だけで簡単に作れます。 Windows FormでGUIを作る方法を以下のようなサイトで勉強し、 http://home.a00.itscom.net/hatada/visual-studio/ … UDPパケットを送信する方法を以下のようなサイトで勉強すれば、 http://msdn.microsoft.com/ja-jp/library/tst0kwb1(v=vs.80).aspx あとはそれを組み合わせるだけで簡単に実現できると思います。
試してないですが コンソールでしたらTurbo-Cのコンパイラで行けるんじゃないでしょうか？ borlandのTurbo Cは昔は超早で重宝されましたよ。 あとはcygwinでも行けるんじゃないでしょうか？
ついでだけど, 「Macでの2GB」ってなんのことですか? 実際に「確保しようとしたサイズ」はいくつですか?
二つ方法があるようです 一つはソースとして追加するのではなく、リンクする方法 http://social.msdn.microsoft.com/Forums/ja-JP/fc … もう一つは共有指定する方法 http://www.atmarkit.co.jp/fdotnet/dotnettips/596 …
あなたの言う「満足いく結果」とはどんな結果なのでしょうか? Gnuplotでは、どういう点が「満足いく結果」では無かったのでしょうか? そういう点を示さないと、同じようなツールを紹介することになってしまうでしょう。 Gnuplotでも,set terminalで幅を設定することができます それだけの数があると、他のツールでも処理に係る時間、使用するメモリ等は大して変わらないと思います。
サイズについては (既に指摘があるので) おいておくとしても, その 2つを ・char *p; → ポインタとして4バイトの領域をひとつ確保 ・char (*p)[10]; → char型の領域を10個確保し、それを1つのポインタ*pointerで管理する と並べてみると, 一貫性がないことに気付くんじゃないかなぁ. 下の「char型の領域を10個確保し」に相当する部分は, 上ではどこに消えたの? ちなみに char 1個は 1バイト.
if (test == ”test.bin”) return TRUE; http://docs.embarcadero.com/products/rad_studio/ …
100倍の下駄履かせる。とかでしょうかねぇ……。 WM_HSCROLLやTRBN_THUMBPOSCHANGINGで受け取れるPOSを100で割って使用する。 ということになるかと。 # 故に…TBM_SETBUDDYでの設定は厳しいので、対応するEDITBOXのテキスト変更通知に反応してスライダーの位置を設定する。などの処理が必要かと。 http://social.msdn.microsoft.com/Forums/vstudio/ … C#ですが、似たような対応…となっているようで。
どこが間違っているかといえば、微分方程式の係数でしょうね。 double m = 50.0; 質量 double k = 0.01; 空気抵抗の定数係数 50Kgの質量に対して空気抵抗係数が0.01では終端速度が49Km/s（a = g - kv/m で a = 0となる v が終端速度）。 曲線になるには、かなりの時間がかかります。 係数をいろいろ変えてみれば、それなりのカーブになります。 > #4 > 空気抵抗力は，速度に比例するの？それとも速度の2乗に比例するの？それともそれ以外？ わかっていると思いますが「速度に比例する」モデルで計算しているようですね。 > #3 > double yd()の式は位置と加速度の関係を求めているようですが意味不明です。 違いますよね。速度と加速度でしょ。 まあ、仮引数名を y にしているのがなんだかなぁ。って感じですけど。 微分方程式を　y' = f(t, y); としているからかなぁ？ ところで、プログラムが「ルンゲクッタ法（RK4）で斜方投射の問題を解く」と全く同じで係数だけが異なっているように見えるのだが、質問者は同じ人？
環境くらいは書いた方がいいかと。 # 過去の質問から探してきやがれ。とかいうならまぁ、かまいませんが。 ボーランドらしいので… http://docs.embarcadero.com/products/rad_studio/ … とかで、フルパス名からファイル名(と拡張子)がとれませんかね？
Visual Studio 2008にて同じ現象が出ました。 私は以下のURLの方法で修復出来ました。 (修正プログラムをアンインストールする方法で修復しました。) http://visualstudioextensions.vlasovstudio.com/2 … 参考になればいいのですが。
>cout<<"break"<<endl; ここらへんに cin.clear(); を入れたら解決しませんか。 勘違いだったら申し訳ないですが、while(cin>>p)を抜けるときにeofフラグが立ってそれ以降のcinがスルーされてるんじゃないかと。
「プログラムを作成したい」ということだから, どのような式をたてればよいか自分で調べてみてはどうでしょうか. ちなみに式そのものは C や C++ とは無関係だね.
入力をキーボードのみに固定しているとか、GUIのアプリだったとかなら難しいですが…… CUIのアプリだったらリダイレクトで処理できるんじゃないですかね。 「CUI リダイレクト 入力」辺りで検索してください。
もうちょい詰めるなら…… 　Uri uri = null; 　if (Uri.TryCreate(Url, UriKind.Absolute, out uri) == false) 　　uri = new UriBuilder("http", Url).Uri; ってところでしょうか。 # Urlがstring型。 「http://」を付与してもURLにならない文字列を渡した場合にどうなるかは不明です。 https://とかftp://とか…URIとして正当だとプロトコルの変更はされませんけどね。 TryCreate()が成功した後のuri.Schemeプロパティで判定してよろしく処理してくださいな。
>型または名前空間名 'webBrowser' が見つかりませんでした。 webBrowserではなくWebBrowserでしたかね。 大文字小文字は区別したかと。 http://msdn.microsoft.com/ja-jp/library/system.w …
回答No.1です。 mshtml は webbrowser コントロールで取得した HTML (DOM)にアクセスするためのライブラリです。 わかり易いサンプルがあったので、以下を見てみてください。 http://support.microsoft.com/kb/312777/ja この掲示板の記事も参考になるかと思います。 http://www.atmarkit.co.jp/bbs/phpBB/viewtopic.ph …
「対立としてはわかりやすい」ってのは, 単に どっちも「クラスをどう設計/実装するか」という視点だから比較することも理解できる ってだけです. 「一方ではクラスを作っているのに他方では作っていない」というのに比べれば, ね. ただ, 「メンバ変数が入る余地がないように、static宣言をつけたい」というのはちょっと違和感があります. クラスに対して static なメンバ関数を作るということだから, そのメンバ関数はそのクラスと「なんらかの関係がある」ということですよね. 「メンバ変数には一切アクセスしない, だけどそのクラスとは関係がある」って状況がどのくらい適切なのかというと.... すぐには想像できないなぁ. もちろん「static なメンバ変数にはアクセスする」ということなら「static なメンバ関数」であることもわかるんだけど.
　突如として割り込んでしまいすみません。 　疑問点があるのであれば書籍を参考にするのはいかがでしょう？ ＞リバーシのアルゴリズム C++&Java対応―「探索アルゴリズム」「評価関数」の設計と実装 (I・O BOOKS) [単行本] ＞http://www.amazon.co.jp/%E3%83%AA%E3%83%90%E3%83 … 　第３章に探索アルゴリズムとして、ここの部分でＭｉｎｉｍａｘアルゴリズムをはじめとして複数が紹介がされています。 　第４章が評価関数を扱っています。 　リバーシの開発を行うのであれば必読と思います。 　立ち読みで内容を確認してみてください。
ＧＰＵによるシェーダ処理とＧＰＵ汎用計算処理を混同している様です。 どちらもＧＰＵを使いますが、使い方が違います。 まぁ、その前にDirectXかOpenGLを使える必要ありですね。これはシェーダ処理の使い方です。２Ｄ・３Ｄ描画に絡む処理で利用します。 それとは別にCUDAやOpenCLを勉強して下さい。これはＧＰＵ汎用計算処理です。物理シミュレーションの高速化はこちらの担当です。 と言うことで覚えることの幅が広いので、いろんな書籍を読んでください。それ以前の知識としてC/C++でマルチスレッドぐらいは楽々扱えないと話にならないです。 i7(Intel HD Graphics)に関しては色々バージョンがあったのでよく分かりませんがシェーダはある程度使えたはず。 CUDAはNvidiaのビデオカード専用です。ですから、INTELなので使えません。 OpenCLならIntel HD Graphics次第では使えるはず。
unsigned char*ではヘッダファイルと型が合わないとコンパイラが文句を言っているわけだから、関数を呼び出す実引数のところで(char*)とキャストすれば…。
オセロなんだよね? だったら, とりあえず「全部のマス目を調べる」のが手っ取り早いんじゃないかな. もちろん「ルール上おいてはいけないマス目」もあるけど, それはルールで排除すればいいだけ. 実際問題としてゲームで探索するときに「子節点がいくつあるのか」を調べるのは無駄だと思う. そもそも「子節点がいくつあるのか」を数えようとしたら, 結局「まだ見ていない子節点があるかないか」を判断しなきゃならないんだし.
MouseEnterイベント、MouseMoveイベント、MouseHoverイベント等をお使いください。 http://msdn.microsoft.com/ja-jp/library/system.w … http://msdn.microsoft.com/ja-jp/library/system.w … http://msdn.microsoft.com/ja-jp/library/system.w …
使ったことはないけど言語依存の話ではないと思うので以下参照 http://www.usefullcode.net/2006/12/post_43.html
No.1さんが指摘されている通り、scanf_s()の使い方が誤っています。 No.1さんが示されたMSDNライブラリのscanf_sの説明の中に ----------------------------------------------------- scanf および wscanf とは異なり、scanf_s および wscanf_s では、 c、C、s、S の各型、または [] で囲まれた文字列コントロール セットのすべての入力パラメーターに対してバッファー サイズを 指定する必要があります。 バッファー サイズ (文字単位) は、 バッファーまたは変数のポインターの直後に追加パラメーター として渡されます。 ----------------------------------------------------- と明確に書かれています。 この説明に従って、 scanf_s("%c", &a , 1); と書かなければなりません。 複数個のパラメータを受け取るなら、 scanf_s( "%d %f %c %C %s %S", &i, &fp, &c, 1, &wc, 1, s, _countof(s), ws, _countof(ws) ); のように書かなければなりません。 つまり、%c,%sそれぞれ1個に対して2個のパラメータが必要です。
ソースプログラムというのはアルゴリズムを言語で実現するためのアイデアが詰まったものです。つまりソースプログラムには著作権があります。 今回あなたは先生が作成したソースプログラムをネットで公開したわけですが、それは先生が望んだことなのでしょうか？ もしあなたが作成した大事なプログラムを友人のAさんに見せたら、わからないところがあるといってAさんが勝手にほかの人に渡しまくったらあなたはどう思いますか？ 先生の著作権が侵害されていなければいいのですが…。
メンバにアクセスできない関数なら、クラス外の関数にするのが手っ取り早いですけど、 ソースコードにアクセスできるなら何とでもできてしまうので無理でしょう。 # 例えば関数をクラスのfriendにするとか 設計思想からいえば、クラスのメンバ内でアクセス範囲を制限しなければいけないならクラスが大きすぎると言えるでしょう。クラスの分割を考えるべきです。
>>２つのファイルをドラッグすると >>argcに2が入り、argv[0]に1つ目のファイル、argv[1]に2つ目のファイル名が入ります。 >argv[0]はプログラムファイル自身のファイル名だったハズですが…。 見落としました。おっしゃるようにargv[0]はプログラムファイル自身のファイル名でした。 なので、argv[1]に1つ目のファイル、argv[2]に2つ目のファイル名が入ります。 ということで for (i = 0; i < argc; i++)　のループは０からでなく、１から回してください。
pls read http://stackoverflow.com/questions/1669645/how-t …
#1の回答で既に答えが出ていますが、補足します。 for(int i=0; i<(signed)strlen(s); i++){ ... } というコードなのに、ループ内でs++;しているのが問題です。ループを回るたびにstrlen(s)が評価され、s++されているので当然ループを回るたびに値がstrlenの結果が1ずつ減り、全部の文字列を探索しません。 s++というコードを書きたいなら、 while (*s != '\0') { ... s++; } というコードにしてはいかがでしょうか。 あるいは、sを変更しないようにします。 ...毎回、strlenを呼んでいるのが無駄だと思いますが。 for(size_t i=0; i<strlen(s); i++){ if (s[i] == c) { ... } ... } しかしながら、文字の検索をするとしたら、プログラミングの勉強でもない限り、#2の回答のようにするか、strchrを使うかだと思います。 #include <string.h> int strch_idx(const char* s, char c) { char* p = strchr(s, c); return p == NULL ? -1 : p - s; } あと、これも何を言っているのかわかりませんが。 // 配列のインデックスは０オリジンだが、インデックスは1からだから１+する このルール通りにやるとしたら、#2の回答も自分のstrchrのプログラムも文字を発見した時の返り値を+1したほうがよいでしょうね。インデックスを1始まりとしてC言語/C++のプログラムを書くのはやめたほうがよいと思いますが。
1チャンネル分しかなければ、24bitカラーにはなりません。 その画像を3つ合成して3チャンネル画像にすれば、24bitカラーになります。 http://opencv.jp/opencv-2svn/c/core_operations_o … http://opencv.jp/opencv-2svn/cpp/core_operations …
>label1.Bold こんなプロパティありましたかね？？ >でできません。 新しくFontを作成して、 this.label1.Font = BoldFont; みたいに設定し直してください。 http://msdn.microsoft.com/ja-jp/library/system.w … より… > Font は変更不可で、プロパティをまったく調整できないため、Font プロパティには新しい Font を割り当てることしかできません。 ただし、既存のフォントをベースにして新しいフォントを設定できます。 「既存のフォントをベースにして新しいフォントを～」についてはFontのコンストラクタを確認してください。 http://msdn.microsoft.com/ja-jp/library/system.d … ボールドにしたいだけなら http://msdn.microsoft.com/ja-jp/library/bdte89fc … ですかね。 BoldFont = new Font(this.label1.Font, System.Drawing.FontStyle.Bold); みたいな。 触ろうとすると読み取り専用だ。といわれるプロパティについてはそのように入れ替えできるものがあるかと。 # できないプロパティもあるかもしれませんけどね。
再帰の探索アルゴリズムで重要なのは、しっかりとした「枝切り」です。 それさえ出来ていれば、この条件とデータ量ならあっという間でしょう。 差し支えない範囲でプログラム内容を補足投稿いただければ、 なにかしら助言出来ると思います。
>#3さん プリプロセッサ処理は、私も一瞬思いついたのですが、 ・マクロが全て展開される → defineで名前を付けた定数も、全てマジックナンバー直書き状態になる ・#includeしたファイルも展開される → プロトタイプや構造体等の宣言がずらーっと並ぶことになる と、今回の目的からは逆効果になると思います。 既存の静的解析ツールを使うとか、Perl等で自作するか、になると思います。 また、Syntax Color に対応したエディタで、色を工夫する、というのもいいかと。 > //　必要なコメント（説明文）のため削除したくない > /*　*/　ばっさり削除 この使い分け規則は徹底できているのでしょうか。 /* */ に説明があったら、手動でやる必要があります。
＞再生は何時間でもずれることはないでしょうか？ プログラムコード次第ですがずれるというのが大前提になるかと思います ＞同期を取る方法を教えてください ＞現在、録音再生の両方のバッファーが終わるのを待ってデーターを移して 実装方法はいろいろあるかと思いますが これも同期をとっていることになると思います この同期方法を取らなければいけない　といったものはないのではないかと おもいます（そこがプログラム作成者次第）
何れの問題も基本中の基本なので、自分で復習をして解いて下さい。 二次方程式の解法、　行列とベクトルの積などです。 自分で解説を読み、例題を辿って理解を深め、演習問題を自分で解いていく事を繰り返したりする事により理解して身に付けていって下さい。 それから　"D=a2-4b" は数式の書き方が間違っています。 これでは　本来の　D=a*a-4*b ではなく、　(a2 という単独の変数　-4*b) としてしか解釈されません。 例えば次等を参考に正しい書き方をして下さい。 http://www.su-gaku.jp/suken_bbs/form.html 数式の書き方 その他、αβγ等は　あるふぁ　べーた　がんま　等と入力して変換操作する事で入力出来ます。 それから数学やC言語に関しては次等が参考になると思われます。 http://okwave.jp/qa/q8043298.html 数学(中学、高校、大学)　の参考サイト等 C言語　入門 OR 初歩　　　　　　　等でサーチ ==> http://www5c.biglobe.ne.jp/~ecb/c/c00.html C言語入門 (左側のcontents ....) プログラミング言語C (カーニハン & リッチー) 等
こういう質問は、どこか、画像表示サイトなどを使って、図示して、質問したほうがいいと思う。 誰も、行間まで読み取って、正確さを期して、回答しようなどとは、思わないんだから。
「任意の1ビットを8ビット集め、バイトにてアクセス」っていうのは、例の中のb7は0x1000番地の3ビット目に対応、b6は0x1020番地の5ビット目、…みたいに指定して、one_byteに値を代入すると指定した各番地のビットが書き換わるみたいな仕組みが欲しいということでしょうか。 C言語の標準にはそういうものはないので、安心してこれまで通りのやり方を続けてください。
OpenGLの拡張機能は直接関数をさしているのではなく、関数ポインタ経由になっており、 初期化するまで各関数ポインタにはNULLが入っています。 一番簡単な初期化は、glewというライブラリを導入して、 glewInitという初期化関数を呼び出すと、glDrawElements等の関数が使えるようになります。
現状の理解状態から推察するに…先は長そうですねぇ……。 >あとゴミが残っているとはどういう内容か知りたいです。 未初期化のローカル変数がどうなっているのか？ ということを勉強してくださいな。 >データーはエクセルの一つのセルに1個ずつ CSV出力した時にどういう形式になっているのか理解しています？ というか、出力したCSVをテキストエディタで眺めたことはありますか？？ 読み込み処理の部分、デバッガのステップ実行で１つずつ追いかけて、 ・期待する動作はどんなものだったのか ・実際の動作はどうなのか を確認した方がいいでしょう。 http://marupeke296.com/DBG_No1_Step.html http://www.atmarkit.co.jp/fdotnet/chushin/vsdebu … http://www.a.math.ryukoku.ac.jp/~hig/guide/vs200 … http://visualstudiostudy.blog.fc2.com/blog-entry … http://news.mynavi.jp/articles/2008/08/18/debug/ などなど……
> 何を排他制御するのでしょうか。オブジェクト？　関数？ スレッドです。 （クリティカルセクションに）同時に入って来られては困るもの、なので。 排他制御についての勉強なら、私はオペレーティング・システムの仕組みについて解説した書籍を読むことをおすすめします。
#2 >そもそも2次元配列をソートしたいというのはどのような仕様でしょうか？ 質問に > dbVec[val][0].x 　のxを昇順にval列をソートしたいです。 とあるので、各ベクタの先頭要素のxをキーにするということだと思います。 で、#1の >「そ～いう比較関数」を作ってやってください. の指示に従って比較関数を作成すると、下に示すコードのようになります。 > 現実的な問題として, 本当に std::vector 同士を入れ替えたときにどのくらい時間がかかるかは知らんけど. ソートが必要なら、配列の配列にするより配列のポインタ配列にしたほうがいいでしょうね。 #include <iostream> #include <vector> #include <algorithm> using namespace std; struct coordinate { int x; int y; }; // 比較関数 int compare(vector<coordinate>& a, vector<coordinate>& b) { return a[0].x < b[0].x; } // データの初期設定 void setup(vector< vector<coordinate> >& vec) { vector<coordinate> elements; coordinateelement = { 0, 0 }; //[6, 5, 2] element.x = 6;elements.push_back(element); element.x = 5;elements.push_back(element); element.x = 2;elements.push_back(element); vec.push_back(elements); //[4, 1, 9, 7], elements.clear(); element.x = 4;elements.push_back(element); element.x = 1;elements.push_back(element); element.x = 9;elements.push_back(element); element.x = 7;elements.push_back(element); vec.push_back(elements); //[8, 3] elements.clear(); element.x = 8;elements.push_back(element); element.x = 3;elements.push_back(element); vec.push_back(elements); } // データの出力 void print(vector< vector<coordinate> >& vec) { for (vector< vector<coordinate> >::const_iterator i = vec.begin(); i != vec.end(); ++i) for (vector<coordinate>::const_iterator j = i->begin(); j != i->end(); ++j) cout << j->x << " "; cout << endl; } int _tmain(int argc, _TCHAR* argv[]) { vector< vector<coordinate> > dbVec; setup(dbVec); cout << "Before:" << endl; print(dbVec); sort(dbVec.begin(), dbVec.end(), compare); cout << "After:" << endl; print(dbVec); }
もともとのmakefileが間違ってる。2行目の$^ が間違い。だいちあ、このmakefileの意図がいまいち不明確ですが。 size情報をだしたいなら、prog.oの生成手段のところに、sizeコマンドをいれておけば、いいだけの話だし。
> 利点がいまいちわからないです・・・ 利点は、まさに"Debug assertaion Failed! vector iterator not dereferencable"が発生することではないですかね。 生ポインタは初期化せずに使用することができてしまい、不正なアドレスなら例外が発生してすぐにバグと気付くけど、不正でないアドレスになっていた場合、そのポインタを使用したところは正常に動作したように見えて、プログラムのほかの場所で使用している変数を壊してしまう。 それに対してイテレータは初期化せずに使用したらランタイムでチェックすることが可能です。
/w 警告をすべて無効にする /wd<n> 警告 n を無効にする /we<n> 警告 n をエラーとして扱う /wo<n> 警告 n を 1 度だけ表示する /w<l><n> n の警告レベル 1-4 を設定する /W<n> 警告レベルを設定する (既定 n=1) /Wall 警告をすべて有効にする /WL 1 行診断を有効にする /WX 警告をエラーとして扱う このあたりが、警告関係。 詳細はマニュアルを参考に。 http://msdn.microsoft.com/ja-jp/library/thxezb7y … Visual Studio のプロジェクトで設定するなら「コンパイル」に「警告レベル」という項目があって、それが上記の/W<n>に相当します。 警告毎に個別に制御できますが、最初のうちは、まとめて制御する /W4 や /Wall 等で、高めに設定するとよいでしょう。
意味論的には「このクラスは使用を終えたときに開放すべき（メモリ以外の）リソースを保持している」という事を明示するという意味があります。 http://msdn.microsoft.com/ja-jp/library/vstudio/ …(v=vs.100).aspx また、このインターフェースを実装しているクラスに対して using ステートメントが使えるという実利的な意味があります。 http://msdn.microsoft.com/ja-jp/library/vstudio/ …(v=vs.100).aspx
直接の回答ではありませんが、こういうロジックが必要な場合、処理Ａ、処理Ｂ、処理Ｃが実は数字が少し違うだけで、実質的に同じ処理をしているというケースがよくあります。 その場合、各処理のほうを見直すと、実は、前段の分岐処理は不要になるというケースもそこそこあります。
『瞬間移動』でいいなら、テキストボックスなどのLeftプロパティの値を変更すればいいだけです。 徐々に移動させたいなら、Timerなどを利用して、徐々にLeftプロパティの値を 変更させていけばいいです。
後者は条件付きディスパッチャでしょうか。 戻り値についてはvoid*等で任意型を返したりはできるのではないでしょうか。
main の引数を使わないなら int main(void) でいい.
>最初に入力した整数の５倍になるまで何度も入力を促す とりあえず、変数1個じゃ実現は難しいんじゃないですかね。 「最初に入力した整数」を記憶しておく変数が別に必要です。 >while( )　　　　　← >printf( ) ←この二つの（）内の文字をどうすればよいのか分かりません 先の方はdo～whileループでのループ条件でしょう。 http://www9.plala.or.jp/sgwr-t/c/sec06-4.html ってことで継続条件ですね。 # 赤字で書かれていますがセミコロン必要です。 例も書かれていますし「最初に入力した整数の５倍になっていない」がループ継続条件となるでしょう。 # 掲示されたパターンでは「最初に入力した整数」の処理も、その変数もありませんのでどういう式になるのかはかけませんが。 printf()の方はなんらかの表示を行いたいのでょうからその表示内容じゃないですかねぇ。 # 掲示されたパターンだとせいぜい改行の出力くらいしか浮かびませんけどねぇ…足りないモノがありすぎて。
推測でものをかいてますが、この処理は、NavController下での戻る、の処理をすれば、スライド操作は、UISplitViewController がやってくれるのではないかと、思います。 　ですので、あなたの定義したアクションの抜ける手前の所で、 a)exit segue をつけて、抜ける処理 b)コードで、今の画面を抜けて、一段戻す 　のどちらかの処理をすれば、detail 側のNavControllerの管理するスタックは、既に、底をつくので、UISplitViewControllerが、Master側のスライド動作をしてくれるのでは、ないでしょうか。
余談だけど, このプログラムの makeArray にバグがいることは分かってますよね? そもそも makeArray で sinMakeArray とか定義したら外にあるやつにアクセスできないんだけど, それをおいたとしても.
Keisanクラス private TextBox _target; public Keisan(TextBox target) { 　this._target = target; } public void Hoge() { 　this._target.Text = @"テスト"; } Form1クラス private Keisan _keisan = null; private Form1_Load(object sender, EventArgs e) { 　this._keisan = new Keisan(this.TextBox1); } private Button1_Click(object sender, EventArgs e) { 　this._keisan.Hoge(); } やりたいのは、こんな感じのことでしょうか？ 必要なタイミングで、KeisanクラスにTextBoxを認識させればいいだけのことのはずです。
処理系によってはアラインメント制約に引っかかって X = *(uint32_t*)Z; が動作しないことも考えられます. その場合の動作は未定義ですから, 突然鼻歌を歌いだしたとしても文句は言えません. #4 の最後にあるように適切な式を使う以外は可搬性がありません.
こういう感じでしょうか。 http://pastebin.com/aLY8rqU5
既に指摘がありますが、まずは、動作の仕様を決めることです。 プログラムはその後です。 必要なのは、「その図の動作の説明」ではありません。 どの図でも、説明通りにやったら答えが求められる(あるいは、条件を満す解が無い、ということが判かる)、そういう一般化された説明です。 今の説明では、単純に「送信回数」=「矢印の本数」*「情報数」」です。 プログラム書くほどのものではありません。 ・「情報が10個」というのは意味があるのか? 現行では、単に定数倍するだけです。 1個として考えても同じことです。 ・経路が重複したときの扱いは? 今回の 例では 0-1-4 0-2-4 と重複して届いた、のべ20個の情報を、4からは10個だけ送信してます。 このルールが曖昧です。「同時に受け取った」から1回分なのか、「同じデータを受け取った」から1回分なのか。 例えば 0-A-B 0-C-D-B とあったら、Bが送信するのは10個ですか20個ですか? あと、ここでは「同様の質問をするなら、古い質問は一旦締め切る」のがルールです。
>>そもそも他サーバーのEXEを起動する事は出来ないのでしょうか？？？ 他サーバーのＥＸＥを起動する仕組みを、それぞれのサーバーに正しく作り込んでおけば、出来ると思います。
プログラムの問題ではありません。 アルゴリズムの問題です。 その前に要件を理解すること。
>したがって、好きなボタンをクリックした時に選んだ種類によりマウスポインタを変更し >マウスポインタを自由に動かし、好きな位置で再度クリックした時に、その場所に >その種類を表示させ、マウスポインタを通常に戻す必要があります。 >イメージファイルは、curファイルにすることはできます。 >ボタンクリックで変更したりが可能な方法が知りたいのです。 コントロールの上にカーソル乗っかったらどうなるのか？ とか、まぁいろいろ考慮する必要はあるかと思いますが……。 VS2010EEでWin32プロジェクトのスケルトンをいぢってみました。 カーソルファイルは適当に。 # 当たり前ですがちゃんとファイルアクセスできるように。 WndProc()にstatic変数を用意。 # 他の方法でもかまいません。任意の期間寿命が保証される変数であればよい。 　static HCURSOR hCursor[2]; WM_CREATEでカーソル読み込み。 　case WM_CREATE: 　　hCursor[0] = LoadCursor(NULL, IDC_ARROW); 　　hCursor[1] = LoadCursorFromFile(_T("ドラゴンの手.Cur")); 　　break; ボタン押下の代わりのイベントとしてメニュー操作を書き換え。 # ここでウィンドウクラスに登録されたカーソルを変更。 　　case IDM_EXIT: 　　　//DestroyWindow(hWnd); 　　　SetClassLong(hWnd, GCL_HCURSOR, (LONG)hCursor[1]); 　　　break; 左クリック時にカーソルを戻すように追加。 　case WM_LBUTTONDOWN: 　　SetClassLong(hWnd, GCL_HCURSOR, (LONG)hCursor[0]); 　　break; ウィンドウクラスを変更しているので、「クライアント領域内」でしか有効ではありません。 他のコントロールや子ウィンドウの上に移動するとそのウィンドウクラスに設定されたカーソルに戻るでしょう。 また、戻すための契機として左クリックを設定していますが、これも「クライアント領域で」左クリックした場合のみになります。 他の子ウィンドウなどの場合は通知が来ないでしょうからよろしく処理してください。 想定しているボタンをクリックした後にマウスキャプチャーを設定したり移動可能な範囲を制限した上でシステムカーソルを変更する。という方法もあるでしょう。 大本の質問の 「curファイルにしなくてはいけないことは、わかりましたがそのファイルをどのように」については、APIで読み込むのもヨシ、実行ファイルのリソースとして登録してLoadCursor()で読み込むもヨシ、自由に使ってください。 # リソースから読み込む方法はキーワード検索すれば出てくるでしょう。 # もっともExpressEditionにはリソースエディタがありませんから実行ファイルのリソースにするにはちょっと面倒かも知れませんが。
ネットで検索するとdllからlibを生成する方法が見つかりますよ。
必然性が無い場合でも相互参照にしたほうが便利になる、ということがよくあります。 たとえば先ほどの大学と学生の話で、 大学の所属学生一覧は必要なのでとりあえず次のように大学を作ったとします。 class College { public: 　vector<Student*> students; }; それで、各学生の所属大学内での何かの順位を取得する機能が必要だったとして、たとえば Ａ：student->GetRankInCollege(); のような設計にするにはstudentの所属大学の情報を得るために Student内にCollegeクラスへの参照が必要です。 ですが、相互参照が嫌という判断で、これを Ｂ：college->GetRank(student); のように実装したり、 Ｃ：GetRankOfStudent(college, student); のように実装したりすることもできます。 ですが、B,Cの場合、これらの機能を利用するプログラマからすれば、 たとえば、「現在のユーザのランクをログインページに表示する」 といったことをしたい場合にいちいち ・現在ログインしている学生 ・その学生が所属している大学 の2つを管理しなければならないという手間が発生します。 上記例の場合、単純にあらゆる箇所でcollege, studentのペアをちゃんと管理する、という労力が あまり大きくないと判断すれば無駄に相互参照にする必要はありません。 ですが、そのあたりの管理を単純にしたいと思った場合に、「相互参照になるからこのような設計にはしない」 のように考えるほどのリスクは無いと思います。
Cドライブ直下でもできませんか? Compiler5.5はとにかく古いので、これあかん、あれだめと言うトラブルが多いのです。 苦Cというサイトの「学習用Ｃ言語開発環境 Ver 0.0.9.0」がおすすめです。 私はCompiler5.5からこれに移行して、色々やっていましたが、トラブルはありませんでした。 ご参考に
ビルドの出力先ディレクトリに，%ProgramFiles%のような， ・書き込み権限を持たないディレクトリ かつ ・ファイルの仮想化対象のディレクトリ ではないですか。 # %ProgramFiles%以下であれば，%LocalAppData%\VirtualStore\Program Files以下に転送される 基本的に，ユーザーは，%ProgramFiles%以下を直接触ってはいけません。 直接触れるのは，インストーラーのみです。 MEFのDirectoryCatalogの検索先として，%ProgramFiles%以下のみでなく，%ProgramData%や%AppData%以下を追加するのがよいでしょう。 # AggregateCatalogを使うことになるかと。
乱数発生方法については http://www.sat.t.u-tokyo.ac.jp/~omi/random_varia … が参考になるでしょう。 また、統計用ライブラリを探せば、関数として用意されているかもしれません。 > 標本数は１０万で、各乱数はテキストファイルに読み込み、テキストファイルに出力します この部分は、何がしたいのかよくわかりません。 ・標準正規乱数を10万個テキストファイルに書き出すプログラム ・自由度３のカイ２乗分布乱数をを10万個テキストファイルに書き出すプログラム ・テキストファイルから数値を読み込み、t検定を行うプログラム を作る、ということなのでしょうか?
> Fontは確かエイリアスだったような 何を言っているのかよくわかりませんが……。 以下のような、与えられた数値の2乗を返すメソッドがあったとします。 double Pow(double d){ 　return d*d; } これを呼び出すときはどう書きますか？ Pow(double d)と書きますか？
#1さんの回答通り、それはLinuxでのパケットキャプチャーの方法だと思います。こういうOSに近いところについて調べるときはOSの名前も一緒に入れて検索したほうがよいです。 *BSDではBerkeley Packet Filter (BPF)を使います。 ざっと検索したら、こんな例を見つけました。 https://gist.github.com/msantos/939154 あと、パケットを書き換えたいとしたら、natdの真似事をするというのもあるかもしれないですね。 パケットキャプチャーでOS関係なく実装する場合はpcapを使ったほうがよいでしょうね。 pcapがその違いを吸収してくれると思うので。
失礼しました。No.3はNo.2のものの間違えです。
質問者さんの言っている方式は、.NETアーキテクチャに近い思想でしょうか。 機能から、どこの階層であるかを判別するのこと自体が間違っています。 階層とは、簡単に言えば、どこの業界の責任であるかを問うための区分けです。 問題が起きた時、アプリケーション作成者が責任を取るという場合は、 よりローカルな表現である、ブロック、インタフェースと呼ぶのが良いでしょう。 またインタフェース群を取りまとめ、自分たちでメンテナンスしやすく設計する 場合は、設計上で名称以外にもIDをふり、独自のブロック化が必要になります。 この時の用語は、そのチーム内でしか通用しないもとなるでしょう。 なので、この機能は何のブロックに該当するのか、それは自明のはずです。 ソフトウェアの業界では、動作や機能に着目しますが、 大変狭義な分類学であり、 それより大きな分類学に当てはめることはできません。 システム全体の中では、常に、アプリケーション層であり、 ローカルな仕事をする、”その他大勢の人”と言うニュアンスで階層自体が扱われます。 例えば、 クライアントと言うのはクライアント・サーバ方式をさす、システムを分類する ための用語であり、ソフトウェアとは関係ない別の業界の用語です。 また、 通信だけに特化する場合は、ノードと呼ぶのが正しく、 この世界では、コンピュータもルータも同じものとして扱います。 ソフトウェアは、 こうした別の業界のユーザーであり、実際に”それ”を作った人ではありません。 そうした意味で、インタフェースと呼ぶが正しいでしょう。 また、そのインタフェースを提供しているミドルウェア製品や言語を使用した場合、 それらのユーザーであるプログラマは、 独自のファンクションを作っただけですから、全てがファンクションとなります。 ここからは言外に含むニュアンスです。 三層を定義しているジャンルは、それぞれのデファクトメーカーが違い、 言語や思想も異なるため、連携しやすいように、定義したものであり、 製品を作る他の業界やユーザであるプログラマを識別し、 連携できるようにしたものです。 コンピュータですから、やろうと思えば、質問者さんのいうように (1)～(3)のどの様な配置も実装も可能です。 しかし、問題が起きた時、通例の使用方法として違うとなれば、 これらのバグ情報は、他の業界で製品を作っているメーカーにとっては、 責任外と成ります。 これが嫌で、層が定義された場合、慣例としての使用の仕方を調査し、 それ以外の使用方法を行わないようにするのが常識とされています。 しかし、単なる分類学と勝手に誤解している人が多くあり、 勝手にプログラム上での機能を配置することは良くあります。 これをさせない管理体制を開発体制と言います。 どこのブロックからどのインタフェースを使用すべきかを検討できると、 上位工程に習熟しているとされます。 これは、問題が起きた時どこのメーカに話すことになり、 解決が早いか？　と言う内容で選択されますので、 技術とは全く関係ない次元になります。 多くのプログラマが上位工程に進めない理由は、 技術的な観点でインタフェースが選択されていると誤解しているからです。 三層構造を採用すると、フリーを基本とした製品群が多くなり、 多様な専門技術者をバックヤードに抱えることになります。 ただし、技術者の数は多いです。メーカも多いですね。 それが故に、体制と言うのが大事になり、担当わけをすることになります。 このときは、コーダーと言う概念があり、この人はフローチャートや 関数仕様の様なものにしたがって、プログラム構造や使用する関数を指定 された上でコーディングします。 関数名や、ライン数も含めて指定されますので、誰が書いても同じです。 インタフェースにSQLを使用するか、どこで発行するかは、 外部設計や内部設計に関わりますが、実際のところは恒久メンテナンス、 顧客事情、セキュリティなど、あらゆる考慮が必要となり、 本来は要件定義やそれ以前の段階でSEとPMが判断します。 しかし、細かい設計上でのインタフェース指定や配置を設定するとコストが あがりますし、さきほど言ったようにトリッキーすぎると、メーカーが保障 しませんから、 「何々と言ったら、普通はこうする」 と言う一般概念を作ります。 けっして、キーワードからデータをアクセするのでデータアクセス層では ありません。またSQLを使うからとか、この関数を使うからではないです。 これでは連想ゲームです。 一般通念としての工法をさすので、逸脱した時は、 何物でもないとするのが正しいでしょう。 三層構造と言ったら、トリッキーなことをしないで、なるべく製品を買って 作るやり方と言うニュアンスです。 より、固い人達が使うという印象です。加えて先進的でない。 UNIX系のシステム管理者出身が好みます。 MVCと言ったら、開発環境の構築が面倒だけど、 顧客受けがよい見栄えや、少しくらい複雑な処理ができる安価なシステムを 場合のニュアンスです。 システム系の処理が地味であり、昨今の華やかなITとかけ離れているため、 ギャップを埋めたいと言う、古い業界の中での革新派と言う印象。 それ以外は、顧客ごとにシステム名が定義され、 中身が前述の三層構造であったり、MVCであったり、レガシーであったり、 問わず複合であると言う（大規模な）ニュアンスです。 なのでプログラマが勝手に関数発行場所やインタフェースを考えられる システム開発は存在しません。 概念としては自由に名前をつけてもいいのですが、 現実的にはそうした仕事が無いので、趣味としての範囲を超えません。 こうしたものをフレームワークと呼び、独自に作って、使ってもらって良いと しています。しかし、誰も使わないと思いますよ。 保守的な人が支配的です。 層と言う表現は、業界全体や学術ジャンルを指し、 「私たち、彼ら、それ以外の人」と言うときに使うニュアンスでしょう。 ちなみに、あまりにも強大な組織になると、多数の業界に進出しており、 垂直型に一社で全てをまかなえるようになります。 この場合は、業界として連携する必要が無く、独自に階層を定義できます。 Webアーキテクチャでは、三層構造とマイクロソフト構造の二種類に分類され、 マイクロソフトは一社で全ての階層をオールインワンで提供し、 クライアントやサーバ、データベースや言語と言う概念を消し去ろうとして います。ですので、彼らのアーキテクチャでは三層から派生した用語は使えません。 更に、さきほどの開発体制も、複数の業界が階層を無し、仕事やノウハウを分担して 連携を想定する（つまり多数のメーカーが責任を押し付けあう）ものを意識して 作り上げる体制ですから、一般的なIT業界の体制はマイクロソフトのアーキテクチャ を使用する場合は必要ありません。 よくご存知の.Netです。 .Netでは設計や思想のようなものを排除し、プログラマが全てを自由に、個人で出来る ようにする目的が強く、これらをサポートするための技術を集めているようです。 当然ながらSI業界との対立関係にあり、SI業界ではLinux文化の普及により、 抵抗しています。 コードをかけないおっさんは食べていけなくなるじゃないですか・・・。 つまり、”層”には、「慣例にあわせ、独自性をだしてはいけない」と言う思想を持つ場合 に使うと良いとおもいます。 発想の自由による、技術の良さを取りたい場合は、少なくても「.Net的ではあるが」 と前置きすると良いと思いますよ。 つまり、本来自由である社会の中で、仕事を済み分けるためにある言葉が多く、 そこからアカデミックな内容を想像すると、合理性がたもてず、 疑問に思うことが多いはずです。 ITやコンピュータの業界は、学術世界のように精錬されておらず、 デファクト（強い奴が）が正しい。 こうした力関係で言葉が使われているので、 これらの派閥と生い立ち、現状での勢い等を良く考えないと、正しくなくなるわけです。 としたばあい、無理に何かの概念にあわせず、 ローカルな設計書やブロック名、インタフェースのみを語るのが健全。 苦労して覚えた技術用語が単なる政治用語であるというのが多く、 IM●が、仕事をとれたようなので、いまはその概念用語は使わないことになった。 と言うこともあります。 覚えても覚えても、知識が増えないのが、IT用語でしょう。 以上、ご参考になれば
使ったことないけど http://sourceforge.jp/projects/sfnet_cproto/ みたいなこと?
前の質問らしきものを貼っておきますー。(なぜか別IDですが) http://oshiete.goo.ne.jp/qa/8436433.html 前回のご質問でも指摘しましたし、他の方も指摘してくださっていますが、 stype!=0のときのtempの値が不定です。 なので、 if(stype==0){ 　temp=LoadGraph("enemyshot1.png"); //←stype==0のときしかtempが初期化されない }else{ 　//TODO: stype!=0のときの処理を書く 　//この中で、tempには必ず何かを入れること } という感じに直してみましょう。
リンク先はVBの話のような気がしますけど。
operator ()の引数の方が違うように見えます。 >result( y, x ) = grayImg2( y, x ); これですかね？ 調べて見たところ、 Mat Mat::operator()( Range rowRange, Range colRange) const Mat Mat::operator()( const Rect& roi ) const Mat Mat::operator()( const Ranges* ranges) const この二つは矩形部分行列の抽出であってコピーではないようです。 yとxを入れて何をコピーしたいのか良く分かりませんが、行列のコピーであればそのまま代入するかclone()やcopyToを使うようです。
ギャラのでない、ここで、ながながした説明する気にはなりませんが、まじめに、Objective-Cのテキスト読んだことあるんでしょうか。よくあるのは、ネットにころがってある、いいかげんな説明をよんでわからん、とか言っていることですが。 　Appleのドキュメントは、基本、英語ですが、Objective-Cについての説明は、日本語でありますけど、これ、読みました？
以下のものを少し変更して、LL（１）文法のコンパイラコンパイラにかける。 -- Attribute grammar of s -- ==================================================== GRAMMAR s SEMANTIC DECLARATIONS --===================== TERMINALS --=========== NUM --1 CELL --2 FUNC --3 "+" --4 "-" --5 "*" --6 "/" --7 "^" --8 "(" --9 ")" --10 ":" --11 nococosy --12 NONTERMINALS --============= s e t f x u o --=========== Scanner rules ================= RULES s = e sem if(isformula) {*att = FORMULA;} else {*att = VALUE;} push(&curtoken); break; endsem. e = t {"+" sem push(&curtoken); break; endsem t sem token1 = pop(); curtoken.x.value += token1.x.value; break; endsem |"-" sem push(&curtoken); break; endsem t sem token1 = pop(); curtoken.x.value = token1.x.value - curtoken.x.value ; break; endsem}. t = f {"*" sem push(&curtoken); break; endsem f sem token1 = pop(); curtoken.x.value *= token1.x.value; break; endsem |"/" sem push(&curtoken); break; endsem f sem token1 = pop(); if (curtoken.x.value == 0) curtoken.x.value = HUGE_VAL; else curtoken.x.value = token1.x.value/curtoken.x.value;; break; endsem}. f = x ["^" sem push(&curtoken); break; endsem f sem token1 = pop(); curtoken.x.value = pow( token1.x.value, curtoken.x.value,); break; endsem ]. x = u | "-"u sem curtoken.x.value = -curtoken.x.value; break; endsem. u = CELL sem curtoken.x.value = cellvalue(curtoken.x.c.col, curtoken.x.c.row); break; endsem [ ":" sem push(&curtoken); break; endsem CELL sem push(&curtoken); token1 = pop(); token2 = pop(); curtoken.x.value = 0; if (token1.x.c.row == token2.x.c.row) { if (token1.x.c.col < token2.x.c.col) error = TRUE; else { for (counter = token2.x.c.col; counter <= token1.x.c.col; counter++) curtoken.x.value += cellvalue(counter, token1.x.c.row); } } else if (token1.x.c.col == token2.x.c.col) { if (token1.x.c.row < token2.x.c.row) error = TRUE; else { for (counter = token2.x.c.row; counter <= token1.x.c.row; counter++) curtoken.x.value += cellvalue(token1.x.c.col, counter); } } else error = TRUE; break; endsem] | o. o = "("e")" | NUM | FUNC"(" sem push(&curtoken); break; endsem e sem token1 = pop(); if (strcmp(token1.x.funcname, "ABS") == 0) curtoken.x.value = fabs(curtoken.x.value); else if (strcmp(token1.x.funcname, "ACOS") == 0) curtoken.x.value = acos(curtoken.x.value); else if (strcmp(token1.x.funcname, "ASIN") == 0) curtoken.x.value = asin(curtoken.x.value); else if (strcmp(token1.x.funcname, "ATAN") == 0) curtoken.x.value = atan(curtoken.x.value); else if (strcmp(token1.x.funcname, "COSH") == 0) curtoken.x.value = cosh(curtoken.x.value); else if (strcmp(token1.x.funcname, "COS") == 0) curtoken.x.value = cos(curtoken.x.value); else if (strcmp(token1.x.funcname, "EXP") == 0) curtoken.x.value = exp(curtoken.x.value); else if (strcmp(token1.x.funcname, "LOG10") == 0) curtoken.x.value = log10(curtoken.x.value); else if (strcmp(token1.x.funcname, "LOG") == 0) curtoken.x.value = log(curtoken.x.value); else if (strcmp(token1.x.funcname, "ROUND") == 0) curtoken.x.value = (int)(curtoken.x.value + 0.5); else if (strcmp(token1.x.funcname, "POW10") == 0) curtoken.x.value = pow10(curtoken.x.value); else if (strcmp(token1.x.funcname, "SINH") == 0) curtoken.x.value = sinh(curtoken.x.value); else if (strcmp(token1.x.funcname, "SIN") == 0) curtoken.x.value = sin(curtoken.x.value); else if (strcmp(token1.x.funcname, "SQRT") == 0) curtoken.x.value = sqrt(curtoken.x.value); else if (strcmp(token1.x.funcname, "SQR") == 0) curtoken.x.value *= curtoken.x.value; else if (strcmp(token1.x.funcname, "TANH") == 0) curtoken.x.value = tanh(curtoken.x.value); else if (strcmp(token1.x.funcname, "TAN") == 0) curtoken.x.value = tan(curtoken.x.value); else if (strcmp(token1.x.funcname, "TRUNC") == 0) curtoken.x.value = (int)curtoken.x.value; break; endsem ")". ENDGRAM
いくつか方法はあるでしょうが…… 　public Form1() 　{ 　　InitializeComponent(); 　　this.radioButton1.CheckedChanged += new EventHandler(radioButton_CheckedChanged); 　　this.radioButton2.CheckedChanged += new EventHandler(radioButton_CheckedChanged); 　　this.radioButton3.CheckedChanged += new EventHandler(radioButton_CheckedChanged); 　　this.radioButton4.CheckedChanged += new EventHandler(radioButton_CheckedChanged); 　} 　private void radioButton_CheckedChanged(object sender, EventArgs e) 　{ 　　RadioButton Target = (RadioButton)sender; 　　if (Target.Checked == true) 　　{ 　　　string[] Items = null; 　　　if (Target == this.radioButton1) 　　　　Items = new string[] { "1", "2", "3"}; 　　　else if(Target == this.radioButton2) 　　　　Items = new string[] { "10", "20", "30" }; 　　　else if (Target == this.radioButton3) 　　　　Items = new string[] { "100", "200", "300" }; 　　　else if (Target == this.radioButton4) 　　　　Items = new string[] { "1000", "2000", "3000" }; 　　　this.comboBox1.Items.Clear(); 　　　if (Items != null) 　　　　foreach (string Item in Items) 　　　　this.comboBox1.Items.Add(Item); 　　} 　} こんな感じですかね？ コンストラクタで設定しているイベントハンドラの登録はデザイナ側でやっても問題ないと思います。 まぁ、コンストラクタで明示的にやっているかInitializeComponent()内部に隠蔽されるかの違いしかありませんが。 # 全角空白でインデントしているのでソースに適用するならその辺りはよろしく処理して下さいな。
元問題は解決しているようですのでANo.2補足への回答です。 オーバーロードは、同名の関数から引数の型によりコンパイラが正しい関数を選択する機能です。 引数と完全に一致する型の関数がない場合は暗黙の型変換が行われますが、それによって選べる関数が複数になると、正しい関数を特定できないためコンパイラがエラーを出します。今回の質問の問題はこのケースです。 ポリモフィズムは実行時のオブジェクトの型によって実行する関数が変わる機能です。実行時のオブジェクトの型が特定できないということはないので実行時エラーはないですね。多重継承で実行できる関数が複数になる場合はコンパイルエラーでしょう。
>>作っていくにしたがってツールが重くなってきたのですが、オブジェクト指向を使ってい書いたほうがアプリケーションは軽くなりますか？ オブジェクト指向は、大規模・複雑なシステムで実力を発揮します。 プログラムが大きくなると、「起動が遅い＝重い」になりがちですが、オブジェクト指向の考え方でプログラム設計をやり直し、スクラッチ＆ビルドをすれば、モジュールがいくらか小さくなり、軽くなる可能性があると思います。もちろん無駄の削除で効率もアップする可能性もありますね。 また、初期処理が完全に終わらない段階で画面表示をすれば、見掛け上、起動が軽くなったように見えますよ。 ただし、もし現在でも無駄が無いコードであって「軽さ＝処理の速さ」を求めているなら、アルゴリズムの見直しなども同時に考えたほうがいいと思います。 それから、Ｃ＃の３．０以降は、ジェネリックなどに加えて、ラムダ式やＬＩＮＱが使えるようになっていますので、それらを使いこなせば、さらに軽くなる可能性があると思います。 なお、ラムダ式が導入された３．０以降は、オブジェクト指向の基本ルールを破ることが可能になり、それを利用したコーディングはメリット大のようです。また、書籍を読むと、マイクロソフトでは、メタ・プログラミングが流行っているようにみえます。 こういった手法を使うことで、実行速度が速くなる保証はありませんが、コードの柔軟性が増大し、コーディング量は減ると思います。
できるわけじゃないですけど、C++ではないような。
これのことかな？ http://msdn.microsoft.com/ja-jp/library/y47ychfe …
.*?　により最短マッチになっています。 @"<[0-9A-F]*?>|\(.*\)" でどうでしょう。 >また、括弧内に含まれる改行を除き（置き換え）たいのですが、どのように記述すればよいでしょうか？ Replaceではできませんか？ "(\n1\n)".Replcace("\n", ""); 参考URL：http://dobon.net/vb/dotnet/string/regex.html
Picosoftさんが解答されているように使えません。 代案として。 ・コメントを書かずとも意味が分かる変数名にする ・コメントが必要なローカル変数をプライベート変数(そのクラス内でしか使えない変数)にする。 /// <summary> /// これはintです。 /// </summary> private int i = 0; public void GetDlgData() { 　　　　　　MessageBox.Show(i + 1); }
そのサイトには trackback も comment も twitter-ID も明記されているのに、 なぜわざわざこんなとこで訊くのか理解できません。
int temp; //弾画像読み込み if(stype==0){ 　temp=LoadGraph("enemyshot1.png"); //←stype==0のときしかtempが初期化されない } //サイズ取得 int w,h; GetGraphSize(temp,&w,&h); //←stype!=0のときのtempはどうなる？ //弾の初期化 for(int i=0;i<ENEMY_SNUM;++i){ 　shot[i].flag=false; 　shot[i].gh=temp; //←stype!=0のときのtempはどうなる？ 　shot[i].width=w; 　shot[i].height=h; 　shot[i].pattern=s_pattern; 　shot[i].speed=speed; 　shot[i].x=x; 　shot[i].y=y; } stype!=0のときもtempが初期化されるように直してみましょう。
思うに、リンク先の方はArduino IDEを使われてるんじゃないでしょうか？ Arduino独特のtypedefや定数が見つからないのでエラーになっているようです。 arduino.hとか引っ張ってきたらビルドは通るかもしれませんが、ちゃんと動作するか？？？ 私もAtmel StudioとATmega単体しか使ったことないので、「こうすればよい」みたいなものは 示せませんが、ArduinoをAtmel Studioで動作させている例を探すと、何か参考になるかも。 http://junkroom2cyberrobotics.blogspot.jp/2012/0 …
HP-UX の make には -p ってオプションはないんでしょうか?
最近の、C++Builder XE http://www.embarcadero.com/jp/products/cbuilder は、マルチプラットフォーム対応のC++開発環境です。 C++の場合、言語自体のコンパイルと、ライブラリの対応があります。 そして、案外、ライブラリ対応の占める割合が高いのが（言い換えれば、そのOSに対応するライブラリを準備するという方法で、「移植性」を高めようとしたのが）CやC++の特徴でもあります。 そういうことで、C++Builder の場合は、目に見える部分は、ほとんど、FierMonkey や、VLC というライブラリ群が担っていますから（しかも、もともと、VCL は Delphiで開発されていたものだったりするし）この部分を、対応させることで、マルチプラットフォーム対応をしています。 （もちろん、ターゲットのCPUに対するコンパイラは作る必要がありますが、ある意味、「コンパイラ部分」だけなら、どこにでもありますから） Java が仮想マシンを使ってOSの違いを吸収したように、Otでは、GUI部分を、独自の（マルチプラットフォームの）GUIライブラリにして、OSの違いを吸収しています。（最近のものでは、そもそも、マルチプラットフォームである、OpenGLのうえい、ライブラリを作ったのではなかったかなとか） C++Builder は、もともと、「Windows の知識がなくても、ビジュアル的に開発できる」ようにしていたので、ライブラリ群が、見かけ上Windows とはあまり関連のない形になっていました。 言い換えれば、同じ考え方で、他のどのOSとも見た目直接の関係はないので、展開はある程度容易だったのでしょう。
計算速度がかなり必要で、自分でプログラムを作るのでしたら、No.1に書かれているFFTWが定番ですが、 ＞とりあえず、ベクターには無かったのですが 計算をしたいということでしたら、 ScilabやRなどでFFTがお手軽です。 http://www.scilab.org http://www.r-project.org 使い方は検索すればいっぱいでてきます。日本語での情報もかなりあります。
多分 abcde0 のabcdeは最初からファイルにあった部分ですよね。 問題はオープンモードの"a+"だと思います。オープンモードによってはfseekで位置を動かしても思ったようにならないと思います。色々と試してオープンモードとfseekの関係を調査してみてください。
> この文の「グラフィックス」というのはペンだのフォントだのブラシだの、といった画材、と考えてよいでしょうか。 いや、むしろ「キャンバス」ですね。
system関数を使って、端末にANSIエスケープ・シーケンスのベル(\a)をエコーして、警告音を鳴らしたいということですか？ 質問の背景や実行する環境などもう少し情報がないと、答えようがない気がしますね。
#1の方が指摘されているように、同じ質問を何度も立てるのはマナー違反です。 テーブルの中身はSQLで取得したと思いますが、マクロやモジュールはSQLでは取得できません。 Microsoft.Office.Interop.Access名前空間のクラスを使うことになります。 .NETでMicrosoft.Office.Interop名前空間のクラスを使う方法のサンプル等(英語) http://msdn.microsoft.com/en-us/library/dd264733 … Accessオブジェクトリファレンス http://msdn.microsoft.com/ja-jp/library/ff192120 … /*マクロの取得サンプル*/ //参照設定にMicrosoft.Office.Interop.Accessを追加すること using Access = Microsoft.Office.Interop.Access; void PrintModule(string filepath){ 　var application = new Access.Application(); 　application.OpenCurrentDatabase(filepath); 　var modules = application.Modules; 　int lineCount = modules[0].CountOfLines; 　Console.WriteLine(modules[0].Lines[1,lineCount]); 　application.CloseCurrentDatabase(); 　application.Quit(); }
> の部分なのですが、なぜprotected overrinde修飾子なのでしょう > 何をオーバーライドしてるのですか？他のサンプルにも構文のように出てくるのですが。 System.Windows.Forms.Control.OnPaintをoverrideしています。 元のメソッドがprotectedなので，可視性はprotectedのままになります。 overrideなので，継承元を辿っていけば元になるメソッドがあります。 http://msdn.microsoft.com/ja-jp/library/system.w … > あとOnPaintはメソッドのようですがイベントを発生させるにはデリゲートではないのでしょうか イベントを発生させることができるのは，イベントを定義したクラスのみです。 Paintイベントは，System.Windows.Forms.Controlのメンバなので，System.Windows.Forms.Control.OnPaintメソッドがイベントを発生させます。 また，イベントの前にOnが付いたprotected virtualなメソッドでイベントを発生させるのは，MSのガイドラインに沿った作りです。 http://msdn.microsoft.com/ja-jp/library/ms229011 … > あとPaintEventArgsはクラスということですがnewはいらないのでしょうか。staticがどこかにあるのでしょうか クラスのインスタンスが引数eに渡されてくるのです。 なので，なぜ「newはいらないのか」という発想になるのかが不思議です。 C#の文法をちゃんと勉強しましょう。 http://msdn.microsoft.com/ja-jp/library/ms173114 … http://msdn.microsoft.com/ja-jp/library/51y09td4 … http://msdn.microsoft.com/ja-jp/library/8f1hz171 …
>ちゃんと初期化しなかったのが原因であってますか？ 原因の一つではありますが、それが全てではありません。 大本の原因は不適切な関数の使用でしょう。 >strcat(send.Name, "ABC"); strcat()ではなくstrcpy()を使うべきではありませんか？ 上から順にコードを読んだ人は、ここでstrcat()を使用することに違和感を覚えるでしょう。 連結ってことはここより前になにか文字列を設定しているハズ。 ということはコードの見落としがあったのか？確かめないと。 見落としはなかった、文字列の設定もされていないのになんで連結なんだろう？ define定義で関数コールが隠蔽されていたのかも知れない。そっちも確認しないと。 などなど。
秀丸がお勧めです。 http://okwave.jp/qa/q8392197.html プロジェクト機能は知りませんでしたが、次が相当するのでしょうか。 http://hide.maruo.co.jp/software/hidemaru8/new1. … その他の要望は殆ど実現されていると思われます。
実行ファイル(EXE)ならパッカーと言われる圧縮ソフトで変換すると簡単には見れ難くできます。 UPXというソフトが有名ですね。 http://sourceforge.net/projects/upx/ http://ja.wikipedia.org/wiki/UPX DLLにする方法もあるみたいですね。 http://ruffnex.oc.to/kenji/text/load_dll/ http://d.hatena.ne.jp/akiramei/20060514/p2 パスワードとかアドレスなどがバイナリーエディタで丸見えなのが嫌なら、文字列を特定のパターンでビット反転したり、ビットシフトするだけで、判別を難しくできますけど結局はデバッガで実行コードを追えば分りますね。 なおパッカーはウィルスなど悪質なソフト類がスキャンを逃れる手段として悪用されるケースもありますので、ベクターデザインなどのサイトでは掲載ソフトへの使用を禁止している所もあります。
本題じゃないけど, ある意味重要な話: 「構造体を送信する際、送信側で定義した構造体を 受信側でも定義する必要ありますか？ 」 ということですが, 「ネットワークを流れるデータ」というのは本質的にただの「ビット列」でしかなく, それをどう解釈するかについては送受信するプログラムの都合で決まります. つまり, 上の質問に対する答えは 「受信側で構造体として扱わなければならないなら必要」 となります.
素直に、ACCESSでAlt＋F11押してExportしたほうが良いのでは？
学校のパソコンでの話なら 先生が生徒のパソコンの画面を見れる仕組みとか普通にありますし そこに生徒しか居なくても遠隔で離れた職員室からでも監視できたり ログを取れたり、さらには操作できたり出来ますから そういう事でないですか？
まあ、既に回答出ていますが……。 検索でうまく見つからない場合はキーワードを「三項演算子」にして検索してみてください。
USB接続タイプのCOMポートの場合、USBを抜けば COMは当然認識しなくなり、 さすと、”しばらくして”ドライバが認識してCOMポートが使えるようになりますよね その、しばらくして の部分はどのように処理されているのですか？
No.2 です。 おそらく RBT-001 の初期化ができていないです。 まず、初期化の際、RBT-001 に渡している（暗号のような）データの意味を確認してください。 その中で、シリアル側の通信条件を決めているはずです。 また、（初期化の際に、通信条件を決める以前の）RBT-001の、デフォルトの通信条件があるはずです。 ・RBT-001 の正しい（デフォルトの）通信条件で H8の通信条件を設定して ・正しく、（アプリケーションで使いたい）通信条件を設定して、初期化し ・その後で、H8の通信条件をアプリケーションで使う条件に再設定する という手順で良いのではないかなと主ます。
>大きさ100の配列に1から10の一様乱数を格納し とありますから、まず乱数を配列に格納してから、集計は別途行うんでしょう。 なので、配列は２つ必要になりますね。
プラットフォームがx86のDLLが含まれている関係でx86コンパイルをしなければ 実行できない環境にあるのではないでしょうか。 Step 9. ライブラリアプリケーションにおけるコンパイルスイッチの意味 http://blogs.msdn.com/b/nakama/archive/2008/11/0 … x86環境での実行のみに限定するなら、プラットフォームをx86でコンパイルして あげれば動作します。 いずれの環境でも動作させたい場合、以下のいずれかを対応する必要があります。 　・AnyCPUでコンパイルされたDLLのみを利用するように変更する。 　・x86コンパイル、x64コンパイルの2種類を用意する。 余計なトラブルを避けたいなら、後者を選択するのが最も単純かつ効率的です。
VisualStudioを使用しているのであれば、プログラムからではなくダイアログエディタのテキストボックスのイベントからKeyPressのイベントを追加するのが良いのでは。 あと、参考にしているページはVB、C#なので、C++とは記述方法などが異なります。 C++/CLIならFormが使用できるけれども、普通のC++だと.NetFrameworkのFormは使えないんじゃなかったっけか。
検索キーが社員ID"だけ"なら、GDBMあたりがお手軽でしょうか。 参考URL：http://codezine.jp/article/detail/7216
私もC言語の勉強と、マイコンキットは分けて学習した方が良いと思います。 後者の方は紹介済みなので、前者の方でWindows上で簡単に学習できる無料ソフトをご紹介します。 http://9cguide.appspot.com/ コンパイラではないので実際の実行形式のファイルを作ることは出来ませんが、構文の確認や、構造体の確認など、テキストに書いてあるサンプルをすぐに確認したり出来ます。 とても軽いソフトです。 ご参考に。
>つまりobjsender　はどんなものにもキャスト可能、と思って良いですか？ いいえ。 キャスト可能なのは、そのインスタンスのクラスやその親クラス、実装インターフェイスなどだけです。 なので厳密には if (objsender is Form) { Form form = (Form)objsender; } のようにobjsenderがFormかどうか確認した上でキャストします。 もしくは // objsenderがFormにキャスト不可能なときにはformにはnullが設定される Form form = objsender as Form;
#4です。 それでしたら、ファイルサイズが0かどうかで判断するのも一つの方法かと。
.ldb ファイルは、Microsoft Jet データベース エンジン 4.0 のマルチユーザー環境で重要な役割を果たします。.ldb ファイルは、共有で使用されているデータベースにおいて、どのレコードがだれによってロックされているかを判断するために使用されます。 参考URL：http://support.microsoft.com/kb/208778/ja
既に回答がついていますが >・しかしnewでの配列確保では正常に動作しているためメモリ不足とは考えにくい newとgcnewはヒープが異なりますから(newはネイティブヒープ, gcnewはマネージヒープ)、newで確保できたのだからgcnewでも確保できるはずというのは成り立ちません。
ストアアプリは開発したことがないのですが下記サイトが役に立つでしょうか。 http://www.atmarkit.co.jp/ait/articles/1210/11/n … Windows.UI.Xaml.Media.Imaging.BitmapImageを使用するようです。
元のデータがsin関数なら、虚部だけしか出ないので正常では? fopen()に対応したfclose()が必要なのはその通りなので直すべきですが。
＞この入れ子の違いはソースによっては混ざってますでしょうか？ ＞自分は混ざってます。 ＞文言の形によってコロコロ変わります。 ＞これって良くないんでしょか？ 良い悪いはともかく、首尾一貫していない書き方はあまり好まれないと思います。 コードを読んでいるときに一瞬違和感を感じて、本筋から集中力が逸れますから。
__autoreleasing NSError **errorPointer;
「ファイル」がソースファイルの意味だとして、 ・構造体の宣言をヘッダファイルに書く。 ・そのヘッダを構造体を読み書きするソースにインクルードする。 ・ソースファイルA,Bのどれかに構造体を定義、初期化する。 例えば下のような3つのファイルに分割してコンパイルすればよいでしょう。 （それと char *name[2]; では2つの文字列ではなく、ポインタの配列になってしまいますよ） /* --- ヘッダファイル (KyaData.h) --- */ struct KyaData { /* KyaData構造体の宣言 */ 　char name[2][16]; 　double d_data[2]; 　int i_data[4]; 　double s_data[2]; 　int state[2][3]; 　int regi[5]; }; /* kya_data配列のextern宣言 */ extern struct KyaData kya_data[2]; /* 関数overwriteのextern宣言 */ extern void overwrite(void); /* --- ソースファイルA --- */ #include <stdio.h> #include "KyaData.h" /* ヘッダファイルのインクルード */ struct KyaData kya_data[2] = { /* kya_data配列の定義 */ 　{ 　　{ "奈美", "爆弾" }, 　　{ 43.0000, 54.0000 }, 　　{ 50, 50, 50, 50 }, 　　{ 0.100,　0.100　}, 　　{ { 0, 0, 0 } , { 0, 0, 0 } }, 　　{ 100, 0, 0, 0, 0 } 　}, 　{ 　　{ "由美", "湖" }, 　　{ 23.0000, 76.0000 }, 　　{ 50, 50, 50, 50 }, 　　{ 0.100, 0.100 }, 　　{ { 0, 0, 0 }, { 0, 0, 0 } }, 　　{ 0, 0, 0, 0, 100 } 　} }; int main(void) { 　printf("%s, %f\n", kya_data[0].name[0], kya_data[0].d_data[0]); 　overwrite(); /* kya_data配列の中身を変更 */ 　printf("%s, %f\n", kya_data[0].name[0], kya_data[0].d_data[0]); 　return 0; } /* --- ソースファイルB --- */ #include "KyaData.h" /* ヘッダファイルのインクルード */ void overwrite(void) /* 関数overwriteの定義 */ { 　kya_data[0].d_data[0] = 11.5; }
こんにちは!(^^)! 自分もプログラミングで本を買いましたが、、 ちょっと後悔しています。 理由は本を買わなくても インターネットで検索すればいろいろと教えてくれるところが あるからです。 ネットの場合質問等もできるので本より数段お勧めです
「コピー代入演算子」とか「copy substitution operator」, あるいは「substitution operator」という「用語」は一般的なものではありません. つまり, 使う人によって同じ意味で使っているかもしれないし違う意味で使っているかもしれません. こんな表現, どこで見たんでしょうか?
db2ライブラリは適切に配置されてますか？
　もう既に解消されているかもしれませんが回答します。 　C:/Windows/SysWOW64/cl.exe 　というのが存在していた場合、それを消さないと上記出たエラーが出され、コンパイルが出来なくなってしまいます。 何かの拍子に入れられているもの、他に影響もないので安心して削除してください。 　これで解消されないかもしれないので、可能性の一つとしてお考えください。 参考URLも添付しておきます http://social.msdn.microsoft.com/Forums/en-US/78 … http://dixq.net/forum/viewtopic.php?f=3&t=8567
＞他のアプリと同様にスタートメニューから起動できるように設定したいなーと思って質問しました。 それはWindows上からの設定でどうなるという話では無いです。 アプリ作成時点でスタートメニューに登録されるようにプログラムを作っていないと出来ません。 出来たアプリのショートカットをスタートメニュー部分にドラッグ＆ドロップが一番簡単ですが これは貴殿の意図と違いますよね？
プロジェクトのプロパティを開いて、「コンパイル」タブの左下にある「詳細コンパイルオプション」を開いてください。 そして、表示されたウィンドウの「ターゲットCPU」という項目がどうなっているのか確認しましょう。 Any CPU：32/64bitの両方に対応。ただし、場合によっては正常に動作しない場合もある。 x64：64bit専用 x86：32bit用。64bit環境でも動作する。 各項目の意味は上記のような感じです。 もし、x64になっていた場合は、x86やAny CPUなどに変更して試してみましょう。 Any CPUになっていた場合は、x86にして試してみましょう。
もしかするとOSによるかもしれませんが、 たしか、単にその記載ではCOM9までしか対応しておらず COM10以上を指定する場合は「\\.\」というプレフィックスを 付ける必要があったように思います。 C言語のリテラルで書くと "\\\\.\\COM10" のような形ですね。 ■おまけ 仮想COMポートソフトウェアを利用すれば、 実際にいろいろなポート名で試してみることが出来ます。 私はよく「com0com」というソフトを利用しています。 これは内部で接続された仮想COMポートのペアを作成するもので、 1台のPC内で送受信のテストをする際にも便利です。 http://sourceforge.net/projects/com0com/files/co … 64bitのOSで利用する場合はデジタル署名されていないドライバは 特別なことをしないとインストールできませんので、 デジタル署名された v2.2.2.0 の signed 版が簡単に利用できるかと思います。 GUIによる設定ダイアログがありCOMポート名称を指定できますが、 そこで「enable buffer overrun」と「enable exclusive」の設定をONにすると 実際のCOMポート動作に近くなるかと思います。
>No.6 >連続したメモリ領域を構造体オブジェクトとして使いたいのなら、こういうこともできます。 >... offsetofを使ったほうがいいのでは？
もう判ってると思いますが、_LATB4じゃなくて_RB4かPORTBbits.RB4(c30)（経験者） それで駄目だったらSOSCI/RP4(1)/PMBEに余計な設定をしてる？
お客様の手に渡る前ならいっくらバグ出てもいいと思っているので、気にしてません。 怖いのは潜在バグなので、見つけやすいように書く/バグったらすぐさま倒れるように書く よう気を使います。
本家sprintfはＣ言語で書かれているわけですから、当然自分で作ることが出来ます。 「Programming Place Plus　Ｃ言語編　第５２章　可変個引数」 http://www.geocities.jp/ky_webid/ProgrammingPlac …
asanonagiさん、簡単なコーディングで上手にやりましたな。
「どういう順番でプログラムを書けばよいか」は簡単なんだけど.... 「プログラム実行者が定めるある値」を知る方法がないんだから, こんなプログラムが作れるわけがない.
>以下の結果が得られるようなプログラムを書いてください。 「以下の結果」というのは >期末試験では必ずフローチャートを書いてください。また、フローチャートが >書けない場合は、どういう順番でプログラムを書けば >よいかを書いてください。 > >年月日を数字８個で入力させ、「今日は○年○月○日です」と >表示させてください。 の事でしょうから #include <stdio.h> int main(int argc, char **argv) { puts("期末試験では必ずフローチャートを書いてください。また、フローチャートが"); puts("書けない場合は、どういう順番でプログラムを書けば"); puts("よいかを書いてください。"); puts(""); puts("年月日を数字８個で入力させ、「今日は○年○月○日です」と"); puts("表示させてください。"); return 0; } かな。 標準出力に出力されたものを結果とした場合ですが。
質問されている問題のレベルがいまいちわかりませんが、データを入力させる部分のプログラムも必要なのでしょうか？ 必要ないのでしたら、次のような流れでいいのではないかと思います。 　1．1秒あたりに得られる5個の実験データを配列に格納する。 　2．1で取得したデータを足し合わせて5で割る。 　3．2で得られた平均値を出力する。 　4．1～3を10回繰り返す。 求めるプログラムのレベルが不明なのですが、期末試験という単語からこの程度いいのではないかと思います。 上にも書きましたが、入力部分のプログラムや本当に時間を計測するような場合はこれではぜんぜんだめなのでご注意ください。
2次元配列を1次元配列に変える方法を理解すれば、4次元を2次元に変えるのは何ら難しくありません。 サイズM*Nの2次元配列 a[x][y] (0≦x<M, 0≦y<N) 　↓ サイズM*Nの1次元配列 a'[x*N+y] サイズK*L*M*Nの4次元配列 b[w][x][y][z] (0≦w<K, 以下略) 　↓ サイズ(K*L)*(M*N)の2次元配列 b'[w*L+x][y*N+z] ここでは4次元を2+2次元に分けましたが、1+3次元とか別の分け方も可能です。 > 4次元配列で表したものを連立一次方程式で解きたいので2次元配列に置き換えなければなりません。 元の4次元配列に入っているデータがどういう構造をしているものなのかが分からないと、どのように2次元配列に置き換えるのが適切かは決められません。 質問文にある情報だけでは、2次元配列に置き換えれば連立一次方程式として解けるような種類のデータなのかどうかも不明です。
大量のクラスがMyIntを有するインターフェースを実装しているならば、 そのインターフェースを型としてインスタンス化すればできるでしょう。 List<IMyIf> myIf = new List<IMyIf>(); myIf.Add(new MyClass()); myIf.Add(new MyClass2()); foreach (IMyIf value in myIf) { value.MyInt = 0; } みたいな。 そうではなくて、アクセサを直接操作したい場合は、PropertyInfoでどうでしょうか。 List<object> cls = new List<object>(); cls.Add(new MyClass()); cls.Add(new MyClass2()); foreach (object value in cls) { Type type = value.GetType(); System.Reflection.PropertyInfo pi = type.GetProperty("MyInt"); if (pi != null) { pi.SetValue(value, 0, null); } } みたいな。
スタートメニューなどから起動する「コマンド プロンプト」も同様なのでしょうか？ コマンドプロンプトを起動して、CHCPと入力してEnterキーを押すとどう表示されますか？ http://kuroeveryday.blogspot.jp/2013/09/sjijutf- … http://propg.ee-mall.info/it/%E3%82%B3%E3%83%9E% … 手元のXPだと HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe というキーは存在しませんでしたね…。
「おそらく」なのですが、過去形でないイベント名は Win32 API のメッセージが由来なのではないでしょうか。 たとえば、キー入力関連のメッセージは http://msdn.microsoft.com/en-us/library/ff468861(v=vs.85).aspx という感じであり、マウス入力関連のそれは http://msdn.microsoft.com/en-us/library/ff468877(v=vs.85).aspx となっており、動詞の原型が名前に使用されています。
デバッグ情報を付与したら落ちる場所が変わった…なんてこともあるかも知れませんが……。 とりあえず、私ならmapファイルを出力してドコの関数で落ちているのか特定しようとします…かね。 「mapファイル デバッグ」辺りで検索すると情報は見つかるでしょう。 DLLの場合、ベースアドレス(ロードされるアドレス)が変動する場合もありますので、その辺りは注意が必要かも知れません。 # DLL内の関数のエクスポートにDEFファイルを使用しているのであれば、ロードされるデフォルトのベースアドレスは指定できますが…。 # ただし、そのアドレスにロードされるという保証は無い。他のDLLなどがそのアドレスを使用している場合は他の場所にロードされますし。 # DEFファイルでなくても、リンカの/BASEオプションで指定できますけどね。 # http://msdn.microsoft.com/ja-jp/library/f7f5138s … デバッグ情報付きなら…落ちた時にJust-In-Time デバッグでアタッチできませんかね？ http://msdn.microsoft.com/ja-jp/library/5hs4b7a6 …
テキストフィールドやボタンなどを生成しviewに追加する為に必要なUIViewのクラスメソッドがaddSubViewです。 selfは自クラスのインスタンスにあたります。 javaで言う Button button= new Button("ボタン"); add(button); などにあたります
#include <stdio.h> void zero(int* n) { *n = 0; } int main() { int n = 123; zero(&n); printf("n = %d\n", n); /* n = 0 */ return 0; } ポインタ無しにコレは書けない。
回答２；続きです。 これは、画像ファイルに下に、 新しく勝手に作成したデータを追加して全体を一つの画像ファイルにしています。 勝手に追加しているデータ部分をカメラからの画像データにしてテストすれば 見えるようになると思います。 参考になれば幸いです。VC++2005を使っています。 if((dstfile = fopen(ct, "wb")) == NULL){ printf("Can not open crypted file. \n"); return; } srand( (unsigned)time(NULL) ); //in constracter strcpy(FName, pt);// = srcfile.GetFileName(); nsize = strlen(FName); //.GetLength();// length of file name. // 平文 fseek(srcfile, 0, SEEK_END); long filelen = ftell(srcfile); fseek(srcfile,0,0); fsize = filelen;//fsize = srcfile.GetLength();// as char 8 bit sidesize = int((4+1+(fsize/2)+1+(nsize/2))/nhsize) + 1; //sidesize = 1 + (int)sqrt((double)(4+1+(fsize/2)+1+(nsize/2)));// as short int 16 bit // Write the header of bitmap file. *((DWORD*)(&(bmpHeader[2]))) = 54+4*sidesize*(sidesize + nvsize); *((DWORD*)(&(bmpHeader[18]))) = nhsize; *((DWORD*)(&(bmpHeader[22]))) = sidesize + nvsize; *((DWORD*)(&(bmpHeader[34]))) = sidesize*(sidesize + nvsize); fwrite( bmpHeader,sizeof(char),54, dstfile); //dstfile.Write(bmpHeader, 54); j = rand(); // 16 bits k = nsize & 0x0000ffff; jj = (j<<16) + (j^k); *((unsigned int*)&tmpch) = jj;//32 bit fwrite( tmpch,sizeof(char),4, dstfile); //dstfile.Write(tmpch, 4);//32 bit j = rand(); // 16 bits k = nsize & 0xffff0000; jj = (j<<16) + (j^(k>>16)); *((unsigned int*)&tmpch) = jj;//32 bit fwrite( tmpch,sizeof(char),4, dstfile); //dstfile.Write(tmpch, 4);//32 bit j = rand(); // 16 bits k = fsize & 0x0000ffff; jj = (j<<16) + (j^k); *((unsigned int*)&tmpch) = jj;//32 bit fwrite( tmpch,sizeof(char),4, dstfile); //dstfile.Write(tmpch, 4);//32 bit j = rand(); // 16 bits k = fsize & 0xffff0000; jj = (j<<16) + (j^(k>>16)); *((unsigned int*)&tmpch) = jj;//32 bit fwrite( tmpch,sizeof(char),4, dstfile); //dstfile.Write(tmpch, 4);//32 bit for(i=0; i<nsize/2 ; i++){ j = rand(); // 16 bits k = (unsigned char)FName[2*i]; l = (unsigned char)FName[2*i+1]; jj = (j<<16) + (j^((k<<8)+ l)); *((unsigned int*)&tmpch) = jj;//32 bit fwrite( tmpch,sizeof(char),4, dstfile); //dstfile.Write(tmpch, 4);//32 bit } if(nsize%2 == 1){ j = rand(); // 16 bits k = (unsigned char)FName[nsize-1]; jj = (j<<16) + (j^((k<<8)+ 0)); *((unsigned int*)&tmpch) = jj;//32 bit fwrite( tmpch,sizeof(char),4, dstfile); //dstfile.Write(tmpch, 4);//32 bit } if(nsize%2 == 0){ j = rand(); // 16 bits k = 0; jj = (j<<16) + (j^((k<<8)+ 0)); *((unsigned int*)&tmpch) = jj;//32 bit fwrite( tmpch,sizeof(char),4, dstfile); //dstfile.Write(tmpch, 4);//32 bit } for(i=4+1+nsize/2; i<sidesize*nhsize ; i++){ j = rand(); // 16 bits if(1 == fread(tmprbuf, sizeof(char), 1, srcfile)){//1 == srcfile.Read(tmprbuf,1)){ k = (unsigned char)tmprbuf[0]; k ^= (unsigned char)key[(i-(4+1+nsize/2))%mn]; } else{k = 0;} if(1 == fread(tmprbuf, sizeof(char), 1, srcfile)){//1 == srcfile.Read(tmprbuf,1)){ l = (unsigned char)tmprbuf[0]; l ^= (unsigned char)key[(i-(4+1+nsize/2))%mn]; jj = (j<<16) + (j^((k<<8)+ l)); } else{jj = (j<<16) + (j^((k<<8)+ 0));} *((unsigned int*)&tmpch) = jj;//32 bit fwrite( tmpch,sizeof(char),4, dstfile); //dstfile.Write(tmpch, 4);//32 bit } tmprbuf[3] = 0; for(i=0; i<nhsize*nvsize ; i++){ fread(tmprbuf, sizeof(char), 3, nekofile); fwrite( tmprbuf,sizeof(char),4, dstfile); } fclose(nekofile); fclose(srcfile);//.Close(); fclose(dstfile);//.Close(); }
ちょっと調べてみたら、こんな資料が見つかりました。 http://www.ritsbagakkai.jp/pdf/462_04.pdf 表 1-3 エンジン制御MCUおよび車両全体のソフトウェアのプログラム数　を参照してください。 2010年（推計）では、パワートレイン系で700万行、車両全体で3000万行だそうです。 データの出所が　矢野経済研究所　となっていますから、矢野経済研究所が出版しているマーケティング用のデータにこのような記載があるのだと思います。業務または大学の研究でこのようなデータが必要でしたら、お金を出して買えば、出所が明らかで精度の高いデータを得られるものと思います。 参考URL：http://www.ritsbagakkai.jp/pdf/462_04.pdf
http://eternalwindows.jp/crypto/filesign/filesig … 参考になるかもしれません。 参考URL：http://eternalwindows.jp/crypto/filesign/filesig …
C言語の配列の面白い性質を一つだけ。 char a[10]などあったとき、 a[1]と*(a + 1) は同じで、 *(a + 1)と*(1 + a)は同じで、 *(1 + a)と1[a]は同じです。 int findMax(int *pary,int size)でaryの先頭アドレスがparyに入っているので、 当然、*paryでary[0]の値を得られるのはわかりますよね。 *pary は *(pary + 0)と同じですから、pary[0]と同じです。 ちなみに、pary + 1の指すアドレスはparyの型によって変わります。 paryはint型変数へのポインターなので、実際のアドレスは(void*)(pary) + 1 * sizeof(int)になっています。 printf("%p\n", pary + 1)して確認してみてください。 > ポインタ変数をpary[0],pary[1],pary[2]と使った場合， > 元の配列ary[0],ary[1],ary[2]全く同じ意味になるのでしょうか？ どちらも配列の同じ要素を参照しています。 なんか回し者みたいでアレですが、ポインターを理解することなくしてC言語は理解できませんから、一度「秘伝C言語問答 ポインタ編」などを読んで網羅的に理解してみてはいかがでしょうか。
OSはWindows7でしょうか？ もしかしたらUAC（ユーザーアカウント制御）の設定が原因かもしれません。 ユーザーアカウント制御の設定を通知しないに設定後、パソコンを再起動して 再度レジストリ登録しても同じ現象でしょうか？
個人的にはNo2さんの回答が一番好みです。 専用の関数や宣言を増やしたくない場合、私は以下のように書いたりしています。 switch (a) { case AAA_1: case AAA_2: case AAA_3: case AAA_4: case AAA_7: case AAA_8: //処理 break; } switch (a) { case AAA_1: case AAA_2: case AAA_3: case AAA_4: case AAA_5: case AAA_6: //処理 break; } switch (a) { case AAA_1: case AAA_3: case AAA_4: case AAA_5: case AAA_8: //処理 break; }
単に、「同じような発生の仕方をするイベントの種類が多い」だけじゃないのかと思いますが？ 普通、「自分は何者なのか？」or「このイベントはどこで発生したどういうイベントなのか」という情報を持って、単一の関数（メソッド）を呼び出すだけで良いのではないでしょうか？ おそらく、「……というイベントを通知する」という処理ではなく「イベントを通知する」というレベルで、クラス設計するのが妥当だと思います。
問題の箇所を質問文のプログラムでズバリ言うと if(fabs(x1-x0)<eps) return x2; /*収束したら解x2を返す*/ この行だ。 はさみうち法は２つ方法があって、それぞれ何が何に収束していくかが違う。 両方が移動する方法と片方が移動する方法で、前者は２点の距離が0に、後者は移動する方の点x'におけるf(x')が0に収束する。で、あなたのプログラムは計算ロジックは後者なのに収束判定に前者のものを使っている。 ～～～～～～ 余談ではあるけど、移動するのは片方だけでいいんだけど、どっちを移動させるかは自動でより適切な方が選ばれるようにした方が良いだろう。あなたのプログラムは、x1が移動する方だと20回では1e-6以内に収まらない。x0の方だと5回目で0.000000に収束する。
> おそらくサンプルコードをコピペして、内容を変更するといった流れだと思いますが、 > その程度であれば、書籍でも学べるとのではないかと思っています。 ならば教本買ってきてやってみるといいですよ。 一週間やってみてさっぱりアカンかったら独学は無理ってことで。
Uri.MakeRelativeUriも頑張れば使えないことはないと思いましたが……。 P/Invokeで，PathRelativePathTo APIを呼び出すのが確実な方法かと。 http://msdn.microsoft.com/en-us/library/windows/ …(v=vs.85).aspx
＞ただ、自分がお聞きしたかったことは、起動プログラムの事でした。 起動プログラムは以下のようになるでしょう。 pid_t pid[300],rpid; int status; for (int i = 0;i < 300;i++) { 　pid[i] = fork(); 　if (pid[i] < 0) { 　　//fork error 　　continue; 　} else if (pid == 0) { 　　//自分は子プロセス 　 　　//クローラーを起動。execl(),execv()などを使う 　　exec**(～～～); 　 　　//exec error 　　exit(-1); 　} } //子プロセスが常に300個になるように保つ処理 for(;;) { 　//子プロセスのどれかが終了するまで待つ 　rpid = waitpid(-1,&status,0); 　//以降、rpidのプロセスの終了状態を調べ、後始末する 　//どのプロセスが終了したか、pid配列とrpidを比較 　for (int i = 0;i < 300;i++) 　{ 　　if (rpid == pid[i]) 　　{ 　　　//pid[i]が終了してしまったプロセスなので、再起動 　　　pid[i] = fork(); 　　　if (pid[i] < 0) { 　　　　//fork error 　　　　continue; 　　　} else if (pid == 0) { 　　　　//自分は子プロセス 　 　　　　//クローラーを起動。execl(),execv()などを使う 　　　　exec**(～～～); 　 　　　　//exec error 　　　　exit(-1); 　　　} 　　} 　} } なお、上記サンプルはデバッグもテストもしてない（というか、コンパイルさえしてない）ので、正常に動く保証はありません。手抜きで無限ループして終了する方法も無いですし。 なので「こういう風に書く」と言うサンプルとして参考にして下さい。 あと、起動プログラムとクローラープログラムは「別の実行ファイルにして、別々に作成」しましょう。 こうすると、クローラーは「致命的エラーが無い限り、クロールだけをし続け、致命的エラーがあったら後始末をしてから終了する」という作り方をすれば良いので、その方が簡単です。
これは、Xcode のレベルではなく、C++ のレベルの（警告でもなく）エラーなので、Xcode がわでは、どうしようもない気がしますが。 実際、unsigned int の変数で、 int を初期化するというのが、普通ではないですから、なぜそういうことになっているのか自問した上で、 a の型を int にするか、b の型を unsigned int にするかどちらかしかないのではないかと思います。 最も、b の型をいじると、さらに、山のようなエラーが発生する可能性もありますが。
>ただ、コンパイルを行っているのは、事情により元々コンパイルした環境とは >別の環境で行っています。 元々の環境を調べてlibsendmail.so(もしくは libsendmail.a)が何でインストールされるものか調べてみてください。 CentOS 5.10をインストールして調べてみましたがsendmailやsendmail-develをインストールしてもlibsendmail.soはインストールされなかったので何か別のものでインストールされたものだと思います。 最悪、元々の環境でもコンパイルできてなかった可能性もありえるかもしれませんが。
こんなの見つけました。 http://oshiete.goo.ne.jp/qa/7378084.html
詳しいワケでもありませんが… 普通に起動したらCUIに 「Enter Command:」って表示されますよ。 >型 'System.IO.DirectoryNotFoundException' のハンドルされていない例外が 指定されたディレクトリ見つからないよ～(T_T) C:\Users\SomeUser\Documents\Visual Studio 2010\Projects\SimpleCalculator3\SimpleCalculator3\Extensionsなんてディレクトリないよ～。 ど～～したらい～のぉ？(;_;) っていってますが、そういうディレクトリ指定している以上用意して下さいとしか。 DLしたZipファイルのREADME.txtでは C:\\Users\\SomeUser\\Documents\\Visual Studio 2010\\Projects\\SimpleCalculator2\\SimpleCalculator2\\Extensions とか書かれていたりしますが…。まぁ、そこは読み替えでしょうかね。 Zipファイル展開した先に作られるExtensionsディレクトリのパスに書き換えろ。ということでしょう。 私の場合、Pドライブに展開したので、 P:\SimpleCalculator\SimpleCalculator\CS\SimpleCalculator3\Program.csの該当箇所(112行目)の文字列を @"P:\SimpleCalculator\SimpleCalculator\CS\SimpleCalculator3\Extensions" に書き換えましたけどね。 >1. Open the main code file (Module1.vb or Program.cs). メインプログラムのコードを開く。 VBならModule1.vbをC#ならProgram.csを開く。 >2. In the constructor, specify the path to the Extensions folder on your local computer. コンストラクタで、Extensionsフォルダの場所を指定しているパスをあなたのPCの場所に修正する。 って感じの意訳ですかねぇ。
　ポインタ変数を char *x と宣言すると、変数 x にアドレス値を保存でき、そのアドレスの記憶場所を char型の変数として使うことができます。その記憶場所は間接参照演算子*を変数名の前につけて *x で参照できます。 char **y と宣言すると、変数 y にアドレス値を保存でき、そのアドレスの記憶場所を char*型（ポインタ型）として使うことができます。 その記憶場所は *y で参照できます。*yで参照される記憶場所にアドレスが保存されていれば、そのアドレスの記憶場所をchar型として使うことができます。char型の記憶場所は **y で参照できます。 　ところで、C言語では、仮引数の　char* z[] は char** z と同じです。ポインタ変数 z に渡されたアドレスが指している記憶場所 *z は、char* のポインタ値（char型の記憶場所のアドレス）でなければなりません。zを配列として使うのであれば、z[0]の次の記憶場所であるz[1]（*(z+1)と同じ）以降にもchar*型のポインタが保存されていなければなりません。関数の実引数はポインタの配列でなければならないことになります。 　一方、2次元配列　char w[3][5] の配列名 w の型は、char** とも、char*[]ともおなじではありません。（ポインタの配列ではありません。）この2次元配列を宣言した関数の中では w を1次元配列として使うこともできます。w[0] は &w[0][0]と同じ、w[1] は &w[1][0] すなわち　&w[0][0]+5 と同じです。 1次元配列として使った時の w の添字を1増やしたとき、アドレスを5だけ進めるというのは配列の宣言を見ればわかります。 　ここで、2次元配列を実引数として関数 int a( char** z ) {} あるいは int a( char* z[] ) {} に渡したいとき、強引にキャストを使って a((char**)w); とすれば文法上のエラーはなくなります。ただし、関数の中でzを配列として使うことはできません。zには char*へのポインタが渡って、z[0]は文字列として使えますが、実引数は配列ではないので、配列要素 z[1] はどこにもありません。 ということで、#1を回答された方が示されたように、ポインタの配列を作ってそれを引数として渡すことになります。 　#2の回答ですが、 > char *work[2]ではwork[0]とwork[1]のデータが必ずしも連続するとは限りません。 厳密にいうなら、workはポインタの配列ですから、 work[0]とwork[1]の記憶場所は連続しています。work[0]の値をたどって参照される文字列と、work[1]の値をたどって参照される文字列とは記憶場所が連続しているとは限らないということでしょう。
どういう操作をして、どういう結果になって、「うまくいかない」のでしょう？
No.1に書かれているようにカレントディレクトリにファイルができます。 ＞これを実行してもどこにもtest.txtというファイルがありません。 ということはXcodeのプロジェクトでCommand Line Toolを選択してプログラムを入力したのでしょうか？ この場合は、実行形式のバイナリができているフォルダに作成されます。 Xcodeのウインドウ（左側）にProductsの下に実行形式のバイナリファイルが見えるはずです。それを右クリックしてShow in FInderを選ぶとそのフォルダが表示されます。 それもターミナルでgccを実行されたのでしょうか、その場合はpwdでカレントディレクトリが確認できますし、lsコマンドで表示されるはずです。 久々にXcodeを使ってみましたが、簡単なものだとCommand Line Toolでやるのが簡単なようです。
もしかしたら見当はずれかもしれませんが、医療用のDICOM形式とか。
stop()は「読み込みの中断」はしません。 ページ内で「読み込め」と指示のあった物は、すべて読み込みます。 すべて読み込んだ上で、BGMやアニメを停止するだけです。 ＞狙いとしては、http://www.yahoo.co.jpが読み込み終わったら、webbrowserの残されている読み込みページを読まずに、終了して欲しいのです。 そういう関数は無いんじゃないかな。残念ながら。
＞自己解凍ファイルのデータ部分のみを解凍せずに読みだす方法はございますでしょうか。 ありません。 通常の圧縮ファイルなら、拡張子が.lzh、.zip、.rarなどになってて、拡張子から圧縮形式が判るようになっているのですが、自己解凍になっていると、ファイル名の拡張子が.exeになってしまい、どのような形式の圧縮ファイルなのか判らなくなります。 「圧縮形式が判らない」って事は、解凍も読み出しも出来ない、と言う事です。 なので「方法はありません」が答えになります。
mnthp[1]="別の文字列"; とすれば良い。
＞途中結果の 0x7FFF * b は 16ビット符号無し整数として処理されるのですか。32ビットで処理してくれたら便利なのですが。 0x7FFFは「int型定数」ですから「int型 * 整数型はint型」と言う規則により、int型になります。 「int型が何ビットの整数なのか？」は、処理系に依存するので、何ビットになるかは判りません。 「符号＋15ビット」と言う処理系では「符号＋15ビット」になり、「符号＋31ビット」と言う処理系では「符号＋31ビット」になります。
CLRはよくわかりませんが… DataGridViewあたりが近いですかねぇ？ あるいはListViewでViewプロパティをDetailsに…とか。
>消すことできますかねえ？ 「未初期化の変数使っている」っていわれているんですから、 意味のある値で初期化して下さい。
Path::GetFileNameWithoutExtensionメソッド http://msdn.microsoft.com/ja-jp/library/system.i …
C#なら http://www.atmarkit.co.jp/fdotnet/dotnettips/224 … みたいなのが参考になりますね。 （個人的にWindows上では最近はC#、C++はLinux上で使ってますので^^;）
#2 でも書かれているように, この例だと実行時間のほとんどは「ファイルの読み書き」に費やされます. そのことを念頭に置くと ・頑張って書けば C で書く方が速い (逆に言えば「頑張らないと勝てない」) ・ただしその違いはほとんど無視できる程度 (どうがんばっても「ファイルの読み書きに費やす時間」は変わらないので) だと思います. 「プロセスの生成にかかる時間」も, Perl 等なら変わらないと思っていいでしょう (1つのプロセスで全ファイルに対して置換すればいいだけ). ちなみに「C言語にてディレクトリ配下のファイル名を取得し、ファイルの件数分ループさせる」のは Unix なら dirent.h を #include して opendir/readdir/closedir が常套手段, かな.
外人の講義なんかをyoutubeで聞くと、 「スタド・アイオー」 って言ってる人も結構いるけどね。 日本人的には「スタディオ」に聞こえる。
正直な所、最初の回答に記載した後者の状況であって、 バインドし直せばよいのだろうなと思っていましたが、 バインド設定のクリアと再設定もしていたのですね。 試して見ましたが、なかなか腑に落ちない動作になりますね。 DataSet.Tables.Clear() ではなく DataSet.Reset() を行うようにしてみたところ、 DataGridView の内容は空になりました。 データソースをクリアしても DataSet.DefaultViewManager あたりが 何処かに保持されているのでしょうか。。よくわかりません。 DataGridView への DataTable のバインドは、 DataSet を利用して DataSource および DataMember プロパティを設定する以外に DataSource に DataTable を直接指定する利用方法もありますが、 それを試して見たところ、1度目は上手くいったように見えますが、 その後 DataSource を何に変更しても表示が変わらないというおかしな状態になりました。 データバインドはバインドしたインスタンスの中身を更新することで 表示に反映という利用方法が多いかとは思いますが、 バインドするオブジェクト自体を切り替えるのも 結構普通の利用方法だと思うのでなにかやり方があるのかもしれませんが、 見つけられませんでした。 DataSetを作り直す以外の回避方法としては、 データの持ち方や保存データの仕様などによって 利用可能かはわかりませんが以下のような手もありそうです。 ・DataTable.WriteXml() で保存したデータを DataTable.ReadXml() を使って 　バインドしたDataTableインスタンスをそのままに中身を更新する。 　ReadXml() 前にテーブルのスキーマ(列)が準備されている必要があり、 　スキーマが変化する場合は利用できない。 　型付きデータセットの場合はいいかも？ ・BindingSourceを介する。 　DataGridViewにBindingSourceをバインドし、 　BindingSourceにデータセットをバインドする。 　イメージとしては以下のような感じ。 private DataSet testDataSet = new DataSet(); private BindingSource dataBinder = new BindingSource(); private void init() { this.dataBinder.DataSource = this.testDataSet; this.dataBinder.DataMember = this.testDataSet.Tables[0].TableName; this.dataGridView1.DataSource = this.dataBinder; } private void load() { try { this.dataBinder.DataSource = null; this.dataBinder.DataMember = null; deserialize(); } finally { this.dataBinder.DataSource = this.testDataSet; this.dataBinder.DataMember = this.testDataSet.Tables[0].TableName; } } ○おまけ BindingListが話に出ていますので少し触れますと、 これは自作のデータクラスなどのリストをバインドする際に結構便利です。 BindingList<>は普通のList<>などと同じように任意のデータクラスを要素として使えますが、 そのままDataSourceにバインドすれば、BindingList<>への要素の増減が 自動的に表示に反映されます。 ただし、ソートやフィルタを利用する場合は自分で実装する必要があり、 要素の数ではなく要素(データクラス)内のフィールド(プロパティ)変化をリアルタイムに反映したい場合は データクラスが INotifyPropertyChanged を実装する必要があります。 そのあたりを必要としない読み取り専用データのリストを表示したい場合などは便利です。 またそのほかに、上でも少し触れている BindingSource はいろいろなデータソースと コントロールの間を仲介することが出来ます。 たとえば変化の通知手段を保たない List<> とコントロールの間に挟み、 BindingSource に対してデータ操作を行うことで、 表示にもList<>にも更新を行う、といったような使い方もできます。 (外付けのラッパーのようなイメージ)
とてもここで回答できる内容じゃないので 「c# プラグイン」 で検索することをお勧めします。 https://www.google.co.jp/search?num=50&lr=lang_j … 大雑把に書けば、、、 プラグインのベースになるインターフェイスを作成する。 この中で、プログラム本体とプラグインとの間でやりとりするためのメソッド名と型などを定義する。 プラグインはベースを素に作成する。 具体的には、プラグインのベースで定義したメソッドの中身を実装する。 この実装はプラグインごとに違ってくる。 そしてプログラム本体を作成する。 プラグインを認識し、インスタンスを作成し、プラグインの関数を呼び出す方法を実装する。 こんな感じ。
Windowsのコマンドプロンプトでということなら Batファイルで処理可能かも --- Test.bat @echo off for /R %%i in (*.file) do m.exe %%~nxi というファイルを準備して コマンドプロンプトにて test.batを実行すればいいでしょう
とりあえず rewind(stdin); が何なのか、調べるといいかもしれません。
APIがどういう仕様か知りませんが、 普通にCの観点でおかしい箇所はあります。 > IFileOperation *pfo; ポインタで宣言して、 > IID_PPV_ARGS(&pfo));　　//※ここでエラー発生　 さらにそのアドレスを参照している。 *pfoには実体はありません。 実体の無い変数にたいしてさらにアドレス参照しているのだから、 なにかおかしな記述ですね。 GUIDは、予めどこかで生成したFileオブジェクトのIDを指定するのでしょう。 pfoの内部にIDを入れる箇所があるのでは、と思います。
右クリックで表示されるコンテキストメニューにそんなのありましたかねぇ？？ とりあえず、[ツール][オプション]を開いてみました。 「環境」「キーボード」と進んで、「以下の文字列を含むコマンドを表示」のところに「コメント」と入力してみる。 VS2010では 「編集.選択範囲のコメント」にショーカットとしてCtrl+K、Ctrl+Cが、 「編集.選択範囲のコメントを解除」にショートカットとしてCtrl+K,Ctrl+Uが割り当てられてました。 VS2012では同じ機能にCtrl+E,CとCtrl+E,Uが割り当てられてますね。 # VS2010はExpressEdition、VS2012はVS Express for Desktopでそれぞれ上級者モードで確認。 VS2012では「エディターコンテキストメニュー.コードウィンドウ.コメントの挿入」なんてのもありましたが…コードエディタにそんなの出てきたかなぁ？？
ビットフィールドに指定できるのはunsigned intと signed intだけ(C99以降なら_Boolも可)と規格に定められています。 それ以外の型をビットフィールドに指定するのは処理系の勝手な独自拡張で、 コンパイラによっては、コンパイル出来ません。
どのような手段をお望みなのでしょうか? ・数学的に方程式を解く 数学でこの問題が出たら 10*log(X)=-23.0 log(X)=-23.0/10 X=e^(-23.0/10) log自然対数ではなく、常用対数(log10)の意味なら X=10^(-23.0/10) と解くはずです。 eのy乗には exp関数、 10のy乗には power関数がありますから、上記式をこれらの関数を使って書きます。 標準ライブラリのcmathのマニュアルを読めば、どんな関数が用意されているかわかります。 ・数値解析的に求める 例えば http://ja.wikipedia.org/wiki/%E4%BA%8C%E5%88%86% …
良し悪しの論議は置いといて、 どの言語でも、オープンソースやプロプライエタリ製品などソース管理では、 一般的にカテゴリ別にクラスを作り、staticメンバで実装するのが定石ではないかと思います。 どういうカテゴリにするかは技術者の裁量ですが、 文字列操作なら StringUtil、描画関係の操作ならGraphicsUtilなど。 クラス分けやネームスペースを理解し考えるのは、プログラミングの大事な工程の一つで、 オブジェクト指向を理解する上でも最も大事な部分です。 この作業は人によってはつまらない作業かもしれませんが、 理解できるようになってくると、プログラマの楽しみであると同時に、 エンジニアとしてのスキルとしても大変役に立つのでぜひお勧めします。 ジェネリックなどはSystem.Collections.Genericに入れる方も居られますが、 システムのクラスなのか独自クラスなのかわからなくなり煩雑になりますので、 自分の作るアプリのカテゴリに分けて定義したほうがよいと思います。 （jp.myapp.Generics.MyList<E>など。） また、クラス化するのはネームスペースの延長、最終的なカテゴリ分けをするためで、規模を隠蔽するためではありません。 よってどんなに小さいメソッドであっても汎用性があるものならばクラス化して集約したほうがよいと思います。 メンバ関数の数が増えてきたら自分のライブラリとして、外だしのライブラリプロジェクトをつくり、 ライブラリに署名を付けておくと、今後作るであろういろいろなアプリから利用できるようになると思います。 クラス名の命名としては、たとえばアプリケーションのネームスペースがjp.ahoo で、文字列を操作するクラスならば、 jp.ahoo.utils というネームスペースやパッケージの下に、クラス名 StringUtil などがあるでしょう。 ただ、外部クラス化することで処理が面倒になる場合もあります。パフォーマンスが落ちるのならば、 無理に外出しにする必要はないかもしれません。 スニペットなどもうまく利用してご自身が作られるコードをテンプレート化しておくのもよいと思います。
for %%q in (%*) do a.exe %%q > "%%~nq.bin" ではダメなの？
最後に２）に行く前に１）を訂正。 １）の if ((a[j] > 10) && (j)) { a[j]-=10; a[j-1]++; } を if (a[j] >= 10) { a[j] -= 10; n += 10; } に訂正。 で、最後に２）を。 #include<stdio.h> #define KETA 120 int main(void){ int a[KETA]; int x,y; int i,j,n; for (i = 0;i < KETA;i++) a[i] = 0; a[KETA-1]=1; for (x = 1;x <= 80;x++) { for (i = 0;i < KETA;i++) a[i] *= x; for (i = 0;i < KETA;i++) { n = a[i]; a[i]=0; j=i; while ((n) && (j >= 0)) { a[j] += n % 10; if (a[j] >= 10) { a[j] -= 10; n += 10; } j--; n /= 10; } } printf("%d! = ",x); for (i = 0;i < KETA;i++) if (a[i]) break; for (;i < KETA;i++) printf("%d",a[i]); printf("\n"); } return 0; }
んーと、これだけの内容なら何らかのエディタで,を改行に全置換して保存し、それをExcelにインポートするのが手っ取り早いと思うのですが、どうしてもC/C++でプログラムを組まなくてはならない事情はありますか？
「ある条件になったら、実行中の処理をすべて放り出して、大元の呼び出し元に戻る」と言う場合は「例外処理」を用います。 try-finally構文の中で、throwを呼び出すと、強制的にfinally節に飛んでいきます。 throwを行ったのが、関数を呼んだ先の奥深くでも、全部吹っ飛ばしてfinallyに飛んできます。 そして「if (条件) end_flag=true;」の代わりに「if (条件) throw new Exception("実行中断");」って書けば良いです。 なお、例外処理を用いると「０除算」などの本当の例外が起きてもすべてfinallyに飛んで来ちゃうので、その場合は「setjump」と「longjump」を用います。
Express EditionならばVisual Studio Online (旧Team Foundation Service)一択。 それ以外であれば，使いたいバージョン管理ツールとVS用のプロバイダーを使えばよいでしょう。 個人でやるなら，VS Online使うのが一番楽だとは思います。 デフォルトでVS用のプロバイダーが入っており，VS上でほぼすべてのことができます。 # プロジェクト削除ができないくらい。 まじめにチケットを切りながらの開発をしてもよいですし， バージョン管理ツールと割り切って使うこともできます。
C++ 標準のヘッダファイルでも、たとえば、以前は、#include <iostream.h> でしたが、最近は、#include <iostream> になっています。 これは、もともと、「名前空間」という概念が導入されたときに、そのあおりで変わりました。 従来の標準関数は、名前空間、std の中に収まりました。なので、標準関数と同じ名前の関数も（グローバル関数としてや、別の名前空間の関数として）使用可能になりました。 標準関数の名前の衝突は（標準関数なだけに）あまりないですが、いろいろなライブラリをつなぎ合わせると、read() があちこちにあったりという、そういう場合に、ライブラリごとに適切な名前空間を設定すれば、名前の衝突を防ぐとこができますということです。 さて、この時に、Ｃの標準ヘッダとどうしようかということになりました。 同じように、 stdio.h を stdio というように読み替えれば、問題はなさそうですが、なんと、時を同じくして、C++に、string という定義が導入されました。 これが、同じく、Ｃの標準ヘッダである、string.h とぶつかります。 これを解決するためもあって、Ｃの標準ヘッダは、 stdio.h → cstdio ということになったわけです。 そういう意味では、少なくとも、 #include <iostream> としているなら、#include <cstdio> でしょう。
当然, バッファが一杯になれば「改行を押していないのに入力される」という状況になります. 何文字必要かは知りませんが, 500文字とか 2000文字とか入れればそのうちなんとかなるかもね.
まずは「ラムダ式」についてよく勉強してください。 そのxはただの「仮引数」です。 http://msdn.microsoft.com/ja-jp/library/bb397687 … にあるように ・引数が1つの場合は、()は必要無い ・型推論で解決できるときは、型を指定する必要が無い ということです。 前回( http://oshiete.goo.ne.jp/qa/8356451.html ) の Controls.OfType<TextBox>().OrderBy.(x => x.Name) から考えて、 Controls.OfType<TextBox>()によって作られた「TextBoxの配列(状のもの)」をOrderByで「指定されたラムダ式を評価したもの」の順番で並び変える であり、 「引数x に指定されるものは、 TextBoxの配列の1要素」 であることから 「引数xはTextBox型だ」 と推論されます。 引数を省略しないで書けば (TextBox x) => x.Name であり、関数風に書けば string lamba(TextBox x) { return x.Name; } ということになるでしょうか。
mainとincludeファイルに<stdio.h>がない＝printfが使えない。 #include <math.h> #include <stdio.h> viod main() { printf(bessj0(5)); } float bessj0(float x) { ・ ・ ・ return ans; } でいけませんか？
丁寧に書くと if (jsum != 0) { sum += bj; } /* Accumulate the sum. */ if( jsum != 0 ) { jsum= 0 ; } else { jsum = 1 ; } /* Change 0 to 1 or vice versa. */ ○ if 文は if ( 式 ) 式文 else 式文 というのが正式な文法です。(else以降は省略可能) この式文というのは 式 ; という式と; をセットにした単文と {式文...} と{}で0個以上の単文を括った複文(ブロック)があります。 if(){}else{} が正しい形みたいに参考書には載っていますが、式文が一つだけなら、{}は不要なのです。 ただ、間違えないように 必ず{}でくくる、という自主ルールを適用することが多いです。 なお、for、while等の他の「{}が必要」と思われている文も同様です。 for(i=0;i<10;i++);{printf("hello");} と書いてしまって、1回しか表示されない、等という間違いを犯すことがあります。 ※ 式には「何もない」という「式」も含まれます。よって ; だけ、という式文も「正しい式文」です。 ※ また、{}はforやif等が無くても、単独で使うことができます。 また、 for(i=0;i<10;i++) 　　printf("hello"); 　　printf("world"); 等と書かれていても、字下げに惑わされてはいけません。これは for(i=0;i<10;i++) { 　　printf("hello"); } printf("world"); と同じです。 ○ ! 演算子 論理を反転します。 VBで言うなら、 Boolean値に対してのNotにあたります。 Cでは 0 : Boolean のFalse に相当 0以外 : Boolean のTrue に相当 となっています。 また、 !演算子は !a aが真 :0 aが偽 :1 となる演算子です。
そうです。その通り。 これは演算をするというよりも、 キャストと言って(int)型の変数に一旦入れたような動きになります。
#include<stdio.h> int main(void) { int x, n, ans; x = 1; n = 1 ; ans = 5; printf("x=%d n=%d ans=%d fnc=%d\n", x, n, ans, fnc(x, n, ans)); x = 1; n = 0 ; ans = 5; printf("x=%d n=%d ans=%d fnc=%d\n", x, n, ans, fnc(x, n, ans)); x = -1; n = 1 ; ans = 5; printf("x=%d n=%d ans=%d fnc=%d\n", x, n, ans, fnc(x, n, ans)); x = -1; n = 0 ; ans = 5; printf("x=%d n=%d ans=%d fnc=%d\n", x, n, ans, fnc(x, n, ans)); } int fnc(x, n, ans){ return x < 0.0 && (n & 1) ? -ans : ans; } x=1 n=1 ans=5 fnc=5 x=1 n=0 ans=5 fnc=5 x=-1 n=1 ans=5 fnc=-5 x=-1 n=0 ans=5 fnc=5 という結果になりました。
MFCのものでなくてもよいのであれば、CStringを使うことは可能です。 たとえば、WTLとか、Win32++とか。
同じでも構いません。 それぞれの変数の有効範囲(スコープ)が異なりますので、問題ありません。 実引数は定義場所により有効範囲は異なりますが、仮引数はその関数の中でのみ有効です。 両方の範囲が重なった場合はその関数内では仮引数の方が有効になります。
>ちなみに、main内の5行目「GetInterfaceInfo」は「IPHlpApi.h」内にちゃんと存在しています。 それはGetInterfaceInfoという関数があることが書かれているだけ、その実体は#1の書かれているライブラリにあります。 「プロトタイプ宣言」を調べてみてください。
#5の方がほぼ正解かと思いますが for (int i = 2; i <= 0; i--) {　・・・は誤りです。 以下、正しいソースです。 ---------------------------------------------- #include <stdio.h> // 入力値(num=0～999)を３桁の文字列に変換する。 void disp(int num) { int i,j; char temp[4]; temp[3] = '\0'; j = num; for (i=2; i >= 0; i--){ temp[i] = j % 10 + '0'; j = j / 10; } //確認の為 printf("in=%d out=<%s>\n",num,temp); } int main() { int i; for (i=0;i<1000;i++){ disp(i); } } -------------------------------------------- disp関数が数値(0~999)を受け取り、文字列に変換しています。 以下、実行結果です。 in=0 out=<000> in=1 out=<001> in=2 out=<002> in=3 out=<003> in=4 out=<004> in=5 out=<005> in=6 out=<006> in=7 out=<007> in=8 out=<008> in=9 out=<009> in=10 out=<010> in=11 out=<011> in=12 out=<012> 途中省略 in=995 out=<995> in=996 out=<996> in=997 out=<997> in=998 out=<998> in=999 out=<999> ----------------------------
3 * 4 / 6 は (3 * 4) / 6 12 / 6 2 となりますね? これは、演算子 *,/ が ・同じ優先順位→左の演算子から順に評価 というルールに従ったものです。 . も「左から評価」される「演算子」です。 上の式を . を使った形式で書けば (3).mul(4).div(6) です。これが (3).mul(4)→12となり (12).div(6) (2) となります。 「mul メソッドがdivメソッドを呼ぶ」わけではありません。 「(mul メソッドが返した)インスタンス(12)のdivメソッド」が呼ばれています。 順番を変える、というのは (3).div(6).mul(4) とする、ということです。 divメソッドが実数を返すなら (3).div(6).mul(4) (0.5).mul(4) (2) となります。しかし、(int同士の演算のように)小数点以下切り捨てた整数を返す場合 (3).div(6).mul(4) (0).mul(4) (0) となり、順番を入れ替えたことで答えも変わってしまいます。 数式の場合、可換法則が成立つ等、順番を入れ替えても問題無いケースがありますが、一般のメソッドでは、殆どの場合、順番を入れかえることはできません。意味が変化したり、コンパイルそのものが通らなくなったりします。
for(y=0;y<img->height;y++){ for(x=0;x<img->width;x++){ p[0]=img->imageData[img->widthStep*y+x*3];//B p[1]=img->imageData[img->widthStep*y+x*3+1];//G p[2]=img->imageData[img->widthStep*y+x*3+2];//R }} では、p[i] の内容が毎回上書きされます。 ループ終了時には、一番最後の座標(x,yが最大値)の値になります。 その後で printf("%u 赤の多さ",p[2]); printf("%u 緑の多さ",p[1]); printf("%u 青の多さ",p[0]); を出力すれば、その最後の座標の情報が出力されることになります。 全体が青っぽくても、右下の1点だけがノイズ等で赤くなっていたら、「赤」の情報が出力されます。 全体の傾向を調べるなら、適切な処理をする必要があります。例えば、平均値、中央値等。 色の傾向を見るなら、BGR→HSVに変換して、色相で調べる、という方法もあります。
好みの問題だと思いますけど私が似たような物を作った時は X軸は配列の添字をそのまま使って Y軸は16bitで量子化していたので32767~-32767をグラフの下端、上端に伸縮させるような一次関数を作って 表示させました。
　こんにちは。 　ネット検索をしてみました。 ゲームプログラマになる前に覚えておきたい技術 [単行本] http://www.amazon.co.jp/%E3%82%B2%E3%83%BC%E3%83 … 　解説によると、 ＞サンプルを動かすにはマイクロソフト社Visual Studio 2005/2008のいずれかのバージョンが必要になります。 　ですか。 　それで、出版社のサポートページによると・・・。 http://www.shuwasystem.co.jp/support/7980html/21 … ＞本書CD-ROM収録のサンプルで動作がうまくいかない場合、以下の修正版をダウンロード ＞してお試し願います。 　なにか修正があるようです。 　試してみてはどうでしょう？ 　開発環境にあった圧縮ファイルをどうぞ。 参考URL：http://www.shuwasystem.co.jp/support/7980html/21 …
細かい調査はしていないのですが、最近のXCodeの更新で、「gcc」というコマンドの本体が clang になっているようです。 > clang: error: linker command failed with exit code 1 (use -v to see invocation というエラーメッセージからもわかります。 現行XCodeに入っているclangはopenMPに対応していないようです。 コンパイルが通ってリンカが通らないのは、_OPENMPが未定義なためです。 OpenMPに対応させる方法はあるようです http://clang-omp.github.io/ あるいは、本家のGCC(GNU Compiler Collection)をインストールして、そちらを使いましょう。 MacPorts等からインストールするのが楽でしょう。
＞動きません。 本当は動いているけど、処理系（ざっくりいうとコンパイラー）によっては コマンドプロンプトを一瞬だけ表示してすぐ消えてしまっている、 というような場合があるようです。
ついでなのでもう一言。 こういう場合、「どうすれば良いか」を聞くより、「なぜこうなるか（無限ループしてしまうのか）」を理解する方がはるかに大切です。 No.3 で指摘されていますが。 そして、それは、「使っている変数を書き出して、プログラムを一行ずつ追いかけて、変数がどう変わり、どういう順序で処理されるか」と（No.4 では「頭で考えれば分かると書かれていますが）「紙に書き出してみれば」わかります。 実際、No.1 の回答へのお礼で 「ループを分離してすっきりしてわかりやすくなりました」と書かれていますが、元のプログラムは、単に「すっきりしていない、わかりにくい」だけではなく、明らか無限ループするプログラムです。 わかりにくいプログラムがわかりやすくなったというだけではないのです。 それは、慣れた人から見ると、「このプログラムはひどい」というレベルの間違いですが、プログラムを書き始めた人が、問題文を読みながら、（本当は、「設計」という行為が入るのだが）一行ずつ組み立てると、「まあ、やってしまうかもしれないな」というプログラムです。 ですから、なぜ、最初のプログラムが無限ループになるのか、理解しないでおくと、「初心者がやってしまいがちなとんでもないプログラム」という状態から抜け出すのにかなり苦労することになります。 ※まあ、紙に書き出さなくても、「デバッガ」の使い方を覚えて、実行をトレースしてみるのも、役に立つと思います。
C言語の大原則は「使う前に宣言/定義」です。 他の言語だと、この順番でも問題無い場合がありますが、C言語の場合は > p = my_search(x); ここで使うものを、この後で > char * my_search(int a) と宣言/定義してはいけません。 この場合、 int my_search() (引数任意、戻り値intの関数my_search) が宣言されているとして、コンパイルが進みます。 その結果、実際の char * my_search(int a) とは引数や戻り値違う、ということになり、エラーになります。 それが 「js010703_a106906.c(58) : error C2040: 'my_search' : 'char *(int)' は 'int ()' と間接操作のレベルが異なります。」 のメッセージの意味です。 明示的に宣言しようとしている 'char *(int)' と 暗黙に宣言された 'int ()' が違う、と言っているのです。 修正方法は2とおり。 ・定義自体を使う前(この場合、main関数の前)に記述する。 ・使う前のプロトタイプ宣言で引数と戻り値を明示しておく。 プロトタイプ宣言については、参考書等で調べてください。 「おまじない」と言われる #include <stdio.h> の役割りの一つが、「プロトタイプ宣言を他のファイルから読みこんで、定義済みの関数を正しく使えるようにする」というものです。 > js010703_a106906.c(48) : warning C4047: '==' : 間接参照のレベルが 'int' と 'void*' で異なっています。 こちらは正確には「警告(warning)」です。 「間違い」ではありません。コンパイルも終了します。 内容を理解し、問題無い場合は無視してもかまいません。 ただし、警告が出る箇所は、問題がある場所がほとんどです。警告を出さないプログラムを目指しましょう。 この場合も == の左右で型が違う、と言っています。 p と NULL です。 char 型は、演算するとき intに自動で変換されます。そのため、 片方が int になっています。 NULLはポインタです。汎用のポインタとして void*型になっていることがあります。 整数とポインタは通常比較したりしません。 よって「間違い」の可能性が高いです。 その前を見ると p = my_search(x); です。今は警告は出ませんが、上の関数宣言を修正すると、こんどはここで警告になるはずです。 p と my_searchの戻り値の型を考えれば、どこが間違いかわかるのでは。
試しにtest クラスを作って、Dictionary<int,test> で１０億個作ってみましたが、別にエラーにはなりませんね。ま、クラスが肥大化すれば別なんでしょうが。 Windows7 64bit corei7-3770 32GB です。 過去の経験から申しますと、原因不明のエラーがメモリーの破損に起因するという事がありました。 普段はエラーはでませんが、そういう大容量メモリーを使うプログラムでのみ発症しました。 最終的にはメモリテストをPCショップでやってもらって初めて確定でき、メモリー交換をしてもらう事で解消しました。メモリーの保証書はとっておくものですね。
私も経験がありますが、そういうのはいい方法というのがないのです。 好みの問題です。 １３人のうち、相互にプログラムがわからないと言うなら、 ルールを決めても、それがわからない人もいることでしょう。 わかってるひとにとっては面倒な書き方であったり、今までの癖が出て間違いの元になります。
違うことやってて気付いたのですが 「VirtualStore」 が原因ではないでしょうか
本質的ではないところにフォローすると, 実際には dB といっても 純粋な比 (の常用対数の 10倍) という意味だけではなく ある絶対的な量に対する比率 (の常用対数の 10倍) という意味もあります (使う場面による)＞#4. なので, この計算式 (注: これは質問者自身が考えたものではない) が必ずしも「誤り」ということにはなりません. まあ, その説明もなくこう書くのは不親切ですけどね.
#include <math.h> (略) double ans; ans = 10.0 * log10(pow(10.0,(25.0/10.0))+pow(10.0,(25.0/10.0))); 28.0102999566398あたりの数値になる？
http://oshiete.goo.ne.jp/qa/8347328.html の続きですかねぇ……。 というか、「MSDNライブラリを適用」って事自体が意味不明だったりするのですが……。 WindowsSDKを～とかならまだ判りますが、MSDNライブラリはただのヘルプです。 VisualStudio上でF1キーを押した時に関連する情報へアクセスできるかどうか？ってのは…どうなんですかねぇ……。 最初に起動した時とかに「オンラインの～」とか選択があったような気もしますが、その設定はどこにあるやら……。 どちらにしてもVisualStudio上でMSDNのページを開けるかどうかと、ビルドできるかどうかは関係ありません。 # ネット断状態でもビルドはふつ～にできます。ネット認証があるワケでもないですし。 んで、大本の問題については…指摘されているように「なにを」「どうして」「どうなった」のか全く不明ですので…。 IFileOperation::CopyItem()を使用する為にShobjidl.hのインクルードが必要で、Shobjidl.hはWindowsSDKに入っていることになっていますが、 VisualStudioのインストール時にWindowsSDKをインストールしていなかった(そんなオプション設定あるのかは不明ですけど)のなら、 VisualStudioのセットアップディスクでインストーラを起動すれば追加インストールとか可能でしょう。 # 修復って項目かも知れません。 ちなみに、VisualStudio2010 ExpressEditionでも普通にインストールしていればWindowsSDKはインストールされているかと思われますが……。 より新しいWindowsSDKをインストールしたいのであればMicrosoftのダウンロードセンターから拾ってきてインストールしてください。 # ウチのは2005StandardEditionと2008/2010のExpressEditionが入れてあって、WindowsSDK6.1Aのセットアップがコケるとかちょっと変な状態にはなっていたりしますけどね。
問題のDual_EC_DRBGはOpenSSLのFIPSモードでのみ使われ、FIPSモードを有効にしていないOpenSSLならばこの問題はないようです。 OpenSSLの代わりになりそうな実装としてはGnuTLSがあります。
どの言語を覚えるべきか、という問に対する答えには成らないかと思いますが、そもそもコンピュータ言語とはどういうものかとか、その辺の話を軽く流します。 今も使われているかと思いますが、アセンブラ等を扱うと、処理速度よりも開発効率を求めた時、スタックに情報を積むルールを定めれば、汎用性、延いては開発効率が速くなるという大人の事情により、それを突き詰めれば、それを暗黙の内にやれば良いという話に成り、それがC言語等だったりする訳ですが、そのC言語も構造体を引数に渡すルールを厳密にすれば（それが this の正体だったり）、汎用性が出てくるという話になり、暗黙の内にやれば、やはり大人の事情によりC++のような言語が生まれたり、それも効率を考えて色々暗黙の内にやれば、スクリプトに至る訳です。そのスクリプトにしても、やはり暗黙の技術論が出てくれば、jQuery みたいな物が出てきたり…。ある意味どこまでも落ちていけます。 どの言語を覚えるべきかと言う話に無理に合わせるなら、どうなんでしょうね。その辺の歴史を考えてコンパイラの仕組みを理解できるC言語は良い選択肢かも知れません。とは言え、その覚え方の方向を間違うと、問題が発生するかも知れません。例えば、C言語とC++言語の間には技術の域を超えて、思想的な違いが徹底的にあります。 これは今時為になる話なのかなぁ…。 まあ、コンパイラの構文解析の仕組みを理解したら良いと言う考えに至るのであれば、スクリプトを自分で作る方策を模索し、どの言語でそれをやるか、まあ、これはなんでも有り（と言っても無理な言語もありますが）なので、強いる物は無いと思います。何でしたら javascript でスクリプトも作れる訳で。 ああ、答えに合っていないですね。ごめんなさい。
この辺の会社が都内で研修を行っています。 http://www.neclearning.jp/ http://jp.fujitsu.com/group/flm/ https://www.hitachi-ia.co.jp/ 取引先やプロマネの方法に合わせて選んでみてはいかがでしょうか。
エクセルファイルを呼び出すというのがどういうことかわかりませんが、Excelで開けばよいのであればShellExecuteを使えば実現できます。 元のソフトに戻るというのは意味がわかりませんでした。
「変換不可能な文字列が返ってきた」って, どういうことだ? strtol は「文字列」など返さないんだが....
何をもって上位関係にあるとするかによりますが、もはや両者は別物だと考えた方がよいでしょう。 ただし、お互いに連携しながら発展してきていますし、両者に共通のヘッダファイルを記述することも可能です。 学習に関しては、目的によってどういう順番で学習すべきかが変わってきます。 最終的にC++だけ使えればよいのであれば、Cには関わらずにC++だけを勉強すればよいと思います。 最終的にCだけを使えればよいのであれば、C++には関わらずにCだけを勉強すればよいと思います。 最終的に両方を使えるようになりたいのであれば、まずはCをしっかり習得してからC++を勉強するとよいでしょう。
printf("初速度 velocity(m/s):"); scanf("%f",&na); printf("仰角 angle 度:"); scanf("%f",&nb); を、以下のようにする。 printf("初速度 velocity(m/s):"); scanf("%lf",&na); printf("仰角 angle 度:"); scanf("%lf",&nb); ％fでは、引数は、floatのアドレスと仮定されるが、実際には、naもnbもdoubleなので。
>Visual C++ → Win32 → Win32コンソールアプリケーション → Windowsアプリケーション → 空のプロジェクトで合っていますよね。 Visual C++ → Win32 → Win32アプリケーション → Windowsアプリケーション → 空のプロジェクトでは？ まぁタダの記載ミスでしょうけど。 >引数はどうやって渡すのですか? WinMainの第3引数で渡されます。 main(int argc,char *argv)のようにパースはされていないので、自前で個々の引数に分解する必要がありますが。 # まぁ処理してくれるライブラリくらいあるかと…。 http://d.hatena.ne.jp/eel3/20090208/1234091051 とか…。
＞何番目っていう英語 1番目: The first 2番目: The second 3番目: The third 4番目: The fourth 5番目: The fifth 6番目: The sixth 7番目: The seventh 8番目: The eighth 9番目: The ninth 10番目: The tenth 11番目: The 11th 12番目: The 12th 13番目: The 13th 上記の中で、first, second 辺りは良く使われます。
「引数の数を合わせてみたのですが、C3861は解決できませんでした」という文章から, あなたが何をどうしたのか理解できる人がいると思いますか? 具体的に何をどうやったのか, そしてどのようなエラーメッセージが出ているのかを書いてください.
No1 ちょっと補足しておきます ＞実行ファイルと画像ファイルを同じフォルダーにしないとだめ！！！！ ＞という結論でした。 これはちょっと違います ファイル名だけしか書いてないと現在のカレントフォルダからそのファイルを探します 実行モジュールと同じフォルダにおいておいても実行モジュールのショートカット作って 作業フォルダを別のフォルダに指定したりするとやはり同様のエラーが出るはずです そういったことにならないように実行モジュールのフォルダと 同じフォルダから読み込むとか対処していた方が好ましいと思われます GetModuleFileName _tsplitpath_s _tmakepath_s の各関数を使えば実現できます（関数詳細はリファレンスで調べてください）
右端のコントロールから FlowLayoutPanelの右端までの 半分を 左端のコントロールのMargin.Leftに加算するといったことで可能なようです 元のフォームの大きさを可変にできるのであれば SizeChangeイベントでの再計算が必要ですが // 右端のコントロールが Button2と仮定 int w = Button2.Loaction.X;　// Button2の左上を取得 w += Button2.Width;　　　　　　// 幅を加算 w += Button2.margin.Right;　　// マージンの右側を加算 w = FlowLayoutPanel1.ClientRect.Width - w; // フォローパネルの幅から計算値を減算 w /= 2;　// 片側用に2で除算 // Margin.Leftに直接 加算が出来なかったので … Padding pad = Button1.Margin; pad.Left += w; Button1.Margin = pad; といった具合で …
あと一応突っ込んでおくと char 自体が符号付きか符号なしかは処理系定義です. Visual Studio (というか Visual C) では標準は符号付きですが, コンパイラオプションで符号なしにもできます.
math.hは昔のコードとの互換性のために使えるようになっているだけで、新規作成するC++のコードでは使ってはいけません。cmathをincludeして、std::log2(2);のように書きましょう。 C++11の下書き (http://www.open-std.org/jtc1/sc22/wg21/docs/pape … ) で見た感じですが、このAnnex D compatibility features、D.5 C standard library headersにそのことが載っています。なお、Annex Dに書いてあることはすべて互換性のために使えるようになっている非推奨の機能です。新しいC++のコードではmath.dでなくcmathなどを使うようにしましょう。 cmathそのものはsin、cos、log、exp、sqrtなど数学的な計算が必要なときに使います。何の関数が使えるかはこれを見ると良いでしょう。 http://www.cplusplus.com/reference/cmath/
C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Include を、 C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include　に変えるとどうなりますか？ ネタ元URL　http://stackoverflow.com/questions/494064/c-visu …
ListBoxにLabelを表示させる目的は何ですか？ ListBoxの中にはListItemを使うのが正しい方法です。 serverの項目をbindingする目的だったら (ListBoxのID).DataBind(); このように使ってください。 または(ListBoxのID).Items.Insertを使ってListItemをaddする事もできます。
インポートしたあと、そのソリューションを保存しましたか?
ifじゃなくてforなどの繰り返しの間違いでしょう。 i=0の方がいいと思いますよ。 0から数える癖はついた方がいいでしょう。 0は何かにつけてキーになる値です。
Visual Studioは使ったことありますか? プロジェクトに、ソースファイルと、それが依存するヘッダファイルを追加して、プロパティから他のオプションとかを設定して、ビルドを実行して実行ファイルを作ります。 通常ビルドを実行すると、前回から変更されたファイルだけビルドが実行されます。 クリーンを実行すると、中間ファイルが削除されます。 かなり大雑把に言うと プロジェクトを作成して設定する→ Makefile を書く ビルド→ make コマンドの実行 クリーン→ make cleanの実行(Makefileにcleanルールが適切に記述されている場合) です。 1つ2つ程度のソースファイルだけなら、直接コマンド入力しても大したことはありません。 ですが、大きなプロジェクトとなると、何十何百ものソースファイルから構成されています。 これを一つ一つコンパイルするのは非常に面倒です。 a.c,b.c,c.cからd.a (ライブラリ)を作って、 e.c, f.cをコンパイルした e.o,f.oとd.aをリンクして g.exe にする、等といった複雑な関係になっていることもしばしばです。 全行程をシェルスクリプト/バッチファイルにしてもいいですが、それだと、1つ修正しただけでも全部コンパイルしなおすので非効率的です。 そこで ・コンパイルの手順を示す ・必要な分だけコンパイルする ・コンパイル実行は少ない手順で行う ということを実現するのが、make等のコマンドや、VisualStudioのプロジェクトです。 > $(FC) $(OPTIONS) -o abcd $(objects) ←このような記述がありますが、オブジェクトをコンパイルして実行ファイルabcdを作成するに違いないと思うのです -oオプションは出力ファイルを指定するものです。ただし、「実行ファイル」とは限りません。 どんなファイルになるかは、OPTIONSによります。 この場合は、 入力が$(objects)で、おそらくオブジェクトファイルなので、それをリンクして実行ファイルにするためのルールであろう、と予想できます。 > %.o: %.f > $(FC) $(OPTIONS) -c -o $@ $< これは型ルールです。～.fから～.oを作る際のコマンドを指定しています。 $@ $< は自動で設定される変数です。 $< を「$(FC) $(OPTIONS) -c 」でコンパイルして -oで $@ へ出力する というコマンドです。 http://www.ecoop.net/coop/translated/GNUMake3.77 … 同じ -o で出力を指定していても、それぞれ目的が違います。 > 今回nmakeに拘っているのは、gnu系のソフトの利用に際して"そうして下さい”と言われているからなのです これって、もしかして 「WIndowsでIntelFortranやVIsual C++等を使ってコンパイルするときは、nmake用のmakefile.mk が用意してあるので、それを使ってくれ」 ということでは? MinGWで(コンパイラコレクションとしての)GCCで、という場合は、MinGWのbashから (./configure→) GNU Makeという方法が普通だと思われます。 ドキュメントをよく読んでください。
https://www.google.co.jp/search?q=%E3%82%B8%E3%8 …
言語仕様をちゃんと理解せず勘でコーディングしているように見えます。 一度、Objective-C言語の解説本を読んで言語仕様の基本を 抑えることをお勧めします。 とりあえず、今回の回答のために以下のURLの説明を読んでください。 http://www.atmarkit.co.jp/ait/articles/0812/15/n … ここに書いてある通り、BOOL型が表す値はYES(1)かNO(0)だけです。 常にYESかNOかのどちらかの値が入っており、値が入っていない という概念はありません。 (変数宣言だけして、初期化してない場合は、以前に使用されていたメモリ値が 残ったままの不定値になります。インスタンス変数の場合は自動的にNO(0)で 初期化されます。) クラスオブジェクトを示す変数なら、値が入っていなければnilだし、 入っていればオブジェクトへのポインタが設定されています。 「if(BOOL変数 != (id)[NSNull null])」 は、BOOL型とクラスオブジェクトのポインタを比較することはできないので 当然エラーになりますし、 「if(!(BOOL変数 == 0 || BOOL変数 == 1))」 は、BOOL変数が初期化されていなければ、以前に使用されていたゴミ値が 使用され、条件が成立するか否かはわかりません。 もし、BOOL値を扱いながら、値が入っていない状態も表したいのなら、 NSNumberクラスを使って、 // YESを代入 NSNumber *boolObject = @YES; // NOを代入 NSNumber *boolObject = @NO; // 値が入っているか確認 if (boolObject != nil) // boolObjectにYESが入っているか確認 if ([boolObject isEqualToNumber:@YES]) と書けば実現できます。 ただ、今回のケースで値が入っていない状態を本当に表現する 必要があるのかは疑問です。 ユーザーが自分のプロフィールを公開するかどうかは、 ユーザーがまだ何も選択していない初期状態ではNOにしておけばよく、 ユーザーが公開を許可した時にYESにすればいいだけだと思います。
> gccの拡張機能ですが、ここまでするの？って、素人目にですが、呪文のような訳の分からない属性があったりして・・・。akinomyogaさん、このあたりどのように思われますか？　もしご意見ありましたらおうかがいできればと幸いです。 基本的に GCC の「拡張」に過ぎないので、多くの属性はアプリケーションコード (ユーザーコード) で使う様な代物ではないと思います。移植性がなくなります (使っても、他のコンパイラでコンパイルできません。或いは #ifdef の嵐になって可読性を損ねます)。中には aligned だとか、あるいは、処理系の都合上指定する必要があるなどで有用な物もありますが、そういう属性は全体からすると極々一部である様に思います。 思うに、多くの訳の分からない属性は GCC に附属してくる標準ライブラリ実装 (glibc や libstdc++ など) の為に作成されたのではないかと思います。glibc や libstdc++ は殆ど GCC の一部の様な物 (といったら過言?) で、GCC と共に使う事が想定されているので遠慮無く GCC 拡張を使えます。そして GCC と共に開発されているので、glibc/libstdc++ をより充実する上で C/C++ 言語のレベルで実現できない事があれば、(汎用性のない機能でも) GCC の方にその機能を「拡張」として追加できてしまう訳です。 例えば「glibc や libstdc++ 並に親切なライブラリを作って皆に配布しよう」などと考えるのでない限りは、多くの「訳の分からない属性」を理解する必要などないのではないでしょうか。
将来高級エンジニアになりたいのであれば、色々なプログラミング言語に触れてパラダイムを学ぶと良いと思います。 * 静的型付け言語 / 動的型付け言語 * クラスベースオブジェクト指向 / プロトタイプベースオブジェクト指向 * 手続き型言語 / 関数型言語 など色々あります。 最近は 動的型付けクラスベースオブジェクト指向言語 (Ruby, Python など) と 静的型付け関数型言語 (Scala, Haskell など) が流行です。 これらはWeb開発用フレームワークを用いることで簡単にwebアプリを作ったりできるので、目に見える成果物を作りやすくおすすめです。 また、スマホのアプリ開発に興味が有るのであれば、Java、Objective-C、JavaScript あたりの知識が必要になるでしょう。 他にもLisp系の言語は最低一つは触れておくと良いと思います。 また、 * アルゴリズム・データ構造と計算量 * デザインパターン * 開発手法 (ウォーターフォール、アジャイルなど) なども学ぶと良いでしょう。 これらを知っているかどうかで開発効率に雲泥の差が出ます。 最後にどんなプログラムを書くかといったことですが、特にやりたいことがないのであれば、プログラミングコンテストの問題を解いてみるのをおすすめします。 また、なにか好きなゲームなどがあれば、それを真似して作ってみるのもよいでしょう。 ある程度知識をつけたら俺々プログラミング言語を作ってみるのもよいかもしれません。
それ、Javascriptです。 「Mac用」ではありません。 で、このプログラムは、単純に、UNICODE→CIDの変換テーブルを用意して CID = UNICODEtoCID[ UNICODE ] ; とテーブルで変換しているだけです。 で、テーブルを作るのにfontforgeに入っているマップを変換した、というものです。 C++でも簡単に作成できます。(テーブルを除いて)
#2ですがミスです。 Ctrl+Zですね、失礼しました。
まず、引数の数が変えられる「可変長引数」というのがあります。 scanfもprintfも可変長引数の関数です。 C言語の場合、この可変長引数は次の特徴があります (1)引数として指定すると、int以下の整数はintに、double以下の実数はdoubleに型変換されます (2)関数側では、どんな引数が指定されたか、知ることができません。 (1) はprintfの%f に関係があります。 float f; double d; printf("%f %f",f,d) ; とあった場合、(1)のルールによって printf("%f %f",(double)f,d) ; と等価になります。 %fの対象をfloatとdoubleとで区別する必要がありません。 どちらもdoubeになるのですから (2)はscanfの%fと関係します。 引数の型や数を知ることができないので、別な方法で知ります。 その方法の一つが、「別の引数で、数や型を指定する」というものです。 scanf,printfの場合、書式文字列中の %* の数と型で判断します。 scanf("%f", &d) ; だと、 %f なので、1つのfloat * が指定されている、と判断します。つまり scanf("%f", (float *)&d) ; です。そして、読み込んだ値をsizeof(float)分、ポインタが示すアドレスに書き込みます。 一般にsizeof(float)<sizeof(double)なので、変数dの領域の一部が書き変わるだけです。 読み出した値は正しく変数dには納まりません。 scanf("%lf", &d) ; だと、 %lf なので、1つのdouble * が指定されている、と判断します。つまり scanf("%lf", (double *)&d) ; です。そして、読み込んだ値をsizeof(double)分、ポインタが示すアドレスに書き込みます。 こちらは、型と内容が一致するので、正しく変数dに納まります。 一部コンパイラは、書式文字列と引数との対応を調べて警告を出しますが、書式文字列が変数で指定されている場合等では、警告も出ません。 char scanFormat[STRMAX] ; /* scanFormatに書式文字列を設定 */ scanf( scanFormat, &a); >double変数の表示には%fでもいいが，%lfを常に使う方が正統な書き方だという理解でよろしいのでしょうか > 常に%lfを使うと何か問題なのでしょうか． むしろ、%fの方が正統です。 もともとprintfに%lfは不要ですし、存在していませんでした。 ところが、scanfと混同して「%lfが正しい」と考える人があまりに多かったので、後から規格に追加されました。 C99以降の規格に準じたコンパイラなら、どちらを使っても同じです。 それ以前のコンパイラでも、独自に%lf=%fとして処理しているものもありますが、%fとして動作しない場合もあります。 http://www.kijineko.co.jp/tech/superstitions/pri …
「ラッパー関数」は共有ライブラリ (DLL) 内に配置していると解釈して思い当たる事を。 > ●１つ目の質問です。 DLL を C からも使いたい場合に、DLL から公開 (export) する関数を、C++ で書くべきか C で書くべきかという事でしたら、どちらでも構いません。(もちろん、C++ で公開する関数を書く時は extern "C" を付ける必要はありますが、それだけです。) > ●２つ目の質問です。 > ここで質問なのですが、ビルドのときにライブラリをリンクさせるだけでは駄目なのでしょうか。また、他に思い当たることがありましたらご教示頂きたいです。 DLL (.so) はどこに配置しているのでしょうか。Windows と Linux では DLL の検索パスが異なります。 Windows → http://msdn.microsoft.com/ja-jp/library/7d83bc18(v=vs.90).aspx (MSDN) Linux → http://en.wikipedia.org/wiki/Rpath (英語Wikipedia) Windows は実行ファイルと同じディレクトリに DLL があるかどうか確認しますが、Linux では (恐らくセキュリティを考慮に入れて) 既定では、実行ファイルと同じディレクトリにある DLL を確認しません。 処理系 (OS, コンパイラ) に依存するかも知れませんが例えば: (a) リンク時 (～コンパイル時) に RPATH に実行ファイルと同じディレクトリを追加する (オプション -Wl,-R,'$ORIGIN') か $ gcc -o 実行ファイル fuga -L何とか -lかんとか -Wl,-R,'$ORIGINI' ($ORIGIN は「実行ファイルと同じディレクトリ」という意味の特別な指定だそうです。参考 URL 参照下さい) (b) または、実行時に LD_LIBRARY_PATH 環境変数に DLL の配置場所を指定するか $ export LD_LIBRARY_PATH='DLL のあるディレクトリ' $ ./実行ファイル ... すれば良いです。 # しかし、DLL が見付からなければプログラムの起動時点で失敗するはずなのですが、 # > 実行させてみると、Cの関数からラッパー関数をコールしているのは確実 # は不思議ですね…もしかして DLL を遅延ロード (dynamic loading) とかしていますか? 参考URL：http://itee.uq.edu.au/~daniel/using_origin/
>panel1を貼り付けPicturBox1をpanel1のなかに。 this(Form1…かな？)の直下のコントロールではないので、this.Controls[]の中に貼り付けたPicturBox1はありません。 # デバッグでブレークポイントを設定してthis.Controls[]がどうなっているのかウオッチとかで見てみるといいでしょう。 ので… >Control c = this.Controls["PictureBox"+a.ToString()]; のcがnullになり、 >((PictureBox)c).Image = Properties.Resources.IconH; でnull参照の例外が発生します。 Control c = this.Controls["panel1"].Controls["PictureBox"+a.ToString()]; とすれば取れるんじゃないですかね。 親子関係や兄弟関係などを調べた方がいいでしょう。 http://dobon.net/vb/dotnet/control/findcontrolby … のように検索する。という手もありますけどね。 イベントハンドラを複数のコントロールに割り当てていないのならば ((PictureBox)sender).Image = Properties.Resources.IconH; でも行けると思いますが…。
>これについては存じませんでした。 >調べてみます。ありがとうございます。 確保するサイズをintで指定してたりしたら、という事ですよ。
>一つのアプリで画面Aと画面Bにそれぞれ別々の表示を >行うことは可能でしょうか？ 可能でしょうか？って質問だと、「可能です」だけで終わってしまいかねませんが……。 まぁ、ソレだとアレなので適当に検索したモノでも貼っておきます。 http://www.atmarkit.co.jp/bbs/phpBB/viewtopic.ph … でGetMonitorInfo()API使えばいいんだなぁ。となって… さらに検索して http://took.blog72.fc2.com/?mode=m&no=708 とか見つかる。 まあ、試せる環境がないんですが。
提示されている物だけで言うなら、 using System.Text.RegularExpressions;//追加 Regex re = new Regex(@"\{(?<moji>[0-9A-Fa-fx\r\s,]+)\}"); string st = re.Match(richTextBox1.Text).Result("${moji}").TrimStart().TrimEnd(); MessageBox.Show(st); こんな感じでしょうか？
あ, 長さはそうなっちゃいますね. すみません. ただ, 速度についてはどうにもならないような気がします. 動的メモリ確保は結構重たい処理なので, 大量に実行するとどうしても時間がかかっちゃいます. #1 で 「速いか」といわれるとわからない と書いたのも, 「ど～書いても時間は同じくらいかかるんじゃないかなぁ」と思ったことが根底にあります. 「高速化したい」ということであれば, 作った「2次元配列」をどう使うかによるんだけど.... その「約１０秒」が全体の実行時間に影響するようだと, データ構造から考え直さないといけないかもしれん.
No.1です。C2Fと同名のソフトは気がついていたいのですが、全く違うもののようです。 http://en.sourceforge.jp/projects/sfnet_c2f/rele … CとFORTRANは随分違う言語なので、機械的に変換は難しいと思います。 逆のf2cは以前結構使われていました。 >機械的にFORTRANに置き換えたつもりがなぜか動作せず原因がわかりません 1)コンパイル時にエラーが出るのでしょうか？ 2)それとも実行時にエラーが出るのでしょうか？ 3)それとも期待した結果が得られないのでしょうか？ ご存知とは思いますが 1)の場合だと、FORTAN90からはフリーフォームが追加されており拡張子などで区別できるようになっています。それを間違うとコンパイル時にエラーがでます。 また配列が0からではなく、デフォルトでは1から始まるとかいろいろ違いが有る訳ですが。
普通にビルドできましたけどね…。 # ディレクトリ指定は[更正プロパティ][VC++ ディレクトリ]から設定しましたが。 >SDKのlibのディレクトリ libディレクトリの中にx86とx64がありますが…ソコまで指定していますか？ # 32Bitならx86、64Bitならx64を指定する必要がありますけど。
やりたいことが C言語側の関数を分割・並列処理化しての処理時間短縮なのか、 単にC#側でUIをブロックしないように時間の掛かる処理を非同期に実行したいのか、 が、いまいち読み取れませんでした。 おそらく後者であろうと想定して、 C言語の関数が特に処理の途中中断などをサポートしていないと想定して、 C#はv3.0以降(VisualStudio2008以降)であると想定して、 C#側のGUIはWindows Formsであると想定して、 以下に2例ほど、時間の掛かる処理を非同期に実行する例を記載します。 いずれも、longTimeOperation()の呼び出し部分が時間の掛かる処理を呼び出す部分です。 また、あくまで例なので、処理中のGUIの設定や表示などもあわせて、 適当に読み替えてください。 ■スレッドプールのスレッドを利用した例 private void button1_Click(object sender, EventArgs e) { // フォームクローズを拒否するデリゲート。 FormClosingEventHandler closeGuard = (s, a) => a.Cancel = true; // 別スレッドでの処理が終わるまでの状態設定など。以下は一例。 this.button1.Enabled = false; this.FormClosing += closeGuard; var calcResult = 0; var dataArea = new byte[1024]; ThreadPool.QueueUserWorkItem(_ => { // ここで時間の掛かる処理を呼ぶ calcResult = longTimeOperation(out dataArea); // 処理中の状態を戻すための処理をメイン側に委譲 this.BeginInvoke(new MethodInvoker(() => { this.FormClosing -= closeGuard; this.button1.Enabled = true; // 必要なら後処理など if (calcResult != 0) { // ・・・ } })); }); } ■BackgroundWorkerを利用した例 　 private void button2_Click(object sender, EventArgs e) { var calcResult = 0; var dataArea = new byte[1024]; // 「WaitingForm」は、処理完了待ち中に表示する自作の適当なフォーム。 // PictureBoxにアニメーションGIFでも載せておくなどすれば良いかも。 using (var bgWorker = new BackgroundWorker()) using (var waitingForm = new WaitingForm()) { bgWorker.WorkerReportsProgress = false; bgWorker.WorkerSupportsCancellation = false; bgWorker.RunWorkerCompleted += (s, a) => waitingForm.Close(); bgWorker.DoWork += (s, a) => { // ここで時間の掛かる処理を呼ぶ calcResult = longTimeOperation(out dataArea); }; waitingForm.Load += (s, a) => bgWorker.RunWorkerAsync(); waitingForm.FormClosing += (s, a) => a.Cancel = bgWorker.IsBusy; waitingForm.ShowDialog(); } // 必要なら後処理など if (calcResult != 0) { // ・・・ } }
OpenCV はわからんけど, 多分「キー入力待ち」の各文でなにをやっているか書いていったらわかるんじゃないかな.
書き忘れましたが、C++やJavaで作るほうが難易度は高いです。特にいろんな環境で動くと言う点をクリアするのは大変難しいです。
1 普通は、データは、サーバー上に置いて、Core Dataをつかうものですが、これは、初心者には、out of reachでしょうか。 2 >・日本国内の高校は5000件以上あり、文字列配列を5000件いっぺんにplistから >読み込んで検索できるのか。 こういうことを聞いているところが、プログラマー失格ですね。こんなの自分で、仮想文字列を5000件生成して、実験すれば、わかることで、10分もかからないことです。 3　そもそも、高校の数は、増えたり減ったりスルものですが、データの更新に対する考慮も必要です。
#include <stdio.h> int main(void) { double s; int i; for (s = i = 0; i < 100000; i++) { double a = 1.0 / (2 * i + 1); s += (i % 2 == 0) ? a : -a; } printf("%f\n", 4 * s); return 0; } 100000項では、誤差が多少出るようです。
アンダーフローが起きたら結果をゼロとして続行するのでは不都合があるのですか。 ピボットがゼロになったらゼロでない要素をピボットにするように行を交換する。ピボットにできるゼロでない要素がないときは、係数行列の行列式がゼロなので、方程式は不定か不能です。不定方程式の解を求めるアルゴリズムは検索で見つかるでしょう。
質問ってのはたいてい「うまくいかない」ときにする (想定した通りに動いていたら, 疑問に思わないでしょ?) ものだから, 単に「うまくいかない」とだけ書くようでは質問の文章として失格. 何がどう「うまくいかない」のかをちゃんと書いてください.
CやFortranでしたら、質問欄のようなやり方がいいように思います。 式が複雑で、解の式が簡単には出せないのなら、数値的に根を求められるライブラリを利用する方法もあります。 例えば http://ja.wikipedia.org/wiki/GNU_Scientific_Libr … Cにこだわらないのでしたらmximaを使うのが一番簡単だと思います。 http://maxima.sourceforge.net 方程式の解き方を解説したた日本語のサイトがいっぱいありますので、検索してみてください。 maximaに直接コマンドをして渡しその結果を標準出力に出することができます。 他のソフトで利用を考えたときには良いように思います。 例えば maxima --very-quiet --batch-string="float(solve([5=2*x+6], x));" とすると標準出力には float(solve([5 = 2 x + 6], x)) [x = - 0.5] と出てきます。
>デバッグでは、status の内容を確認できません。 statusの型は… typedef __success(return >= 0) LONG NTSTATUS, *PNTSTATUS; となっていますね。 # むぅ？　よく判らん…。 http://msdn.microsoft.com/en-us/library/windows/ … によると、戻り値が書かれているので…… if文で列挙して調べてみる。 というのもアリかも知れません。 # Return Valueに書かれている以外のものが返されるとアレですが…。 あとは……直前の BCryptSignHash(hKey, NULL, (LPBYTE)lpHashData, dwHashDataSize, NULL, 0, &dwSignatureSize, 0); lpSignature = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSignatureSize); が失敗していないか？を確認ですかねぇ。 念のため、dwSignatureSizeは0に初期化しておいた方がいいかも知れません。 # APIが失敗した結果、なにも値を設定してくれていなかった場合は不定値が入っていますしね。(Debugビルドならある意味固定値ですが…) >The RSA signature algorithm. This algorithm is not currently supported. You can use the >BCRYPT_RSA_ALGORITHM algorithm to perform RSA signing operations. >との説明があるので、利用できないのでしょうか？ そんな感じもしますね。 ソレならソレでBCryptOpenAlgorithmProvider()でエラーなら返却して欲しいような気もしますが……。
構造体の宣言と初期化を分離して、宣言をヘッダーファイルにする。 データを読みたいソースはそのヘッダーをインクルードし、配列をexternとする。
MonoDevelopは、Xamarin Studioに変わっていたんですね。失礼しました、情報が古くて。 先ほどインストールしてみたのですが、確かにC++のプロジェクトが消えています。対応をはずしたのかも知れません。だとすると、ちょっと手がなさそうですね……。C#プロジェクトを作って、C++コードをC#で書きなおすしかないかも知れません。マネージドコードだとすると、基本的なクラスとメソッドの記述構造は同じですから、単純置換で大半は済みそうな気もします。もちろん、細かな部分は全部書き直しになるでしょう。かなり手間が掛かりそうですね。 ただ、Mono自体はC++のマネージドコードには対応していますので、Mono本体があればビルド自体はできるように思えますが……。やってないのでなんともいえないです。
近年 C++/CLI 触っていないのでうろ覚えですが、C++/CLI では openFileDialog1->Dispose() を呼び出すのに delete を使うんだったと記憶しています。 delete openFileDialog; gcnew との対称性を重んじたのでしょうね。ダイアログは unmanaged resource なので、CLR がよろしくやってくれるという事はありませんよ。openFileDialog が GC に回収されるまでリソースが残ってしまいます (まあ、それでも良いという態度もあるかも知れませんが、個人的には気持ち悪いです…)。 因みに、構文糖衣ですが ^ を付けずに (あたかも値型の様に) 宣言すると、C# の using と同等のコードを生成してくれます。つまり、自動的にスコープの終端で delete (Dispose) してくれます。 { OpenFileDialog openFileDialog1; openFileDialog1.Title = "ダイアログのタイトルをココに書く"; openFileDialog1.InitialDirectory = "c:\\"; openFileDialog1.FileName = "初期表示するファイル名をココに書く"; if (openFileDialog1.ShowDialog() == System::Windows::Forms::DialogResult::OK) MessageBox::Show(openFileDialog1.FileName); }
古い方といわれてるのは K&R で書かれた形式となります その当時さすがにK&Rってのはある意味ですさまじいので 新しい方は ANSI C 準拠に合わせて記載が変わったということではないかと思います 同一の例が以下に記載されています http://d.hatena.ne.jp/keyword/K%26R
DebugBreakという関数をつかえば一時停止できます
No1 サンが書いてる手順で標準のインクルードパスとライヴら理フォルダを設定する 以外の方法として ・フルパス（絶対パス）をきちんも書いてファイル指定する ・該当ファイルをそーそフォルダにコピーする 等の方法もあります （いろいろ問題もあるので基本的にはNo1さんが書かれてる手順での追加をお勧めします） 他に注意点として #include　　"ファイル名" #include　　<ファイル名> は同じインクルード文でもファイル検索する基準のフォルダが異なります 前者の場合は基準フォルダはソースファイル格納フォルダ 後者はIncludeパス設定されているフォルダが基準でファイル検索されます その為 たとえ ソースと同一フォルダヘッダファイルが置かれていても #include　　<ファイル名> の記載を行うとファイルが開けない といった事になります
C++側は、akinomyogaさんの > __declspec(dllexport) の前に static が抜けているだけでは? で。 VBA側 Private Declare PtrSafe Function Add Lib "MathFuncsDll.dll" _ Alias "?Add@MyMathFuncs@MathFuncs@@SANNN@Z" _ (ByVal int1 As Double, ByVal int2 As Double) As Double Sub hoge() Dim a As Double ChDrive ThisWorkbook.Path ChDir ThisWorkbook.Path a = Add(5, 2) MsgBox a End Sub 修飾名は dumpbin /exports で確認。
画像処理を含めた光学的な物理についで何も分かっておられません。 少なくとも半年から一年ぐらいは勉強しないとダメなレベルです。場合によっては物理も。 カメラで撮影した画像が１枚目と２枚目で全く同じ位置、同じ大きさ、同じ色（赤でも微妙に違う）のはずがありません。 それらを比較するためには画像処理の知識が必要です。 R,G,Bに分けられたら比較できると思っているなら甘すぎると思います。
あ、ちょっと誤解があるようなので一言。 ADOのRecordSetオブジェクトや、ADO.NETのDataAdapterオブジェクトは、利用者が『泥臭いSQL文字列の直接記述』をしなくていいように、DBへの一般的な基本操作がラップされたもので、DataAdapterはその内容をウィザードで自動設定できるようになってます。すごく便利。 だけどその中身は、しっかりSQLが書かれているわけで、使っていないわけではありません。 もちろん、そのSQLの内容は自由に変更できます。 VisualStudioのプロパティウィンドウでも修正できますが、SelectCommandなら、 adapter.SelectCommand.CommandText = "SQLの取得文"; adapter.Fill(dataset); んで、今回のような「全体一括更新」は、DataAdapterのUpdateCommandに割り当ててでもできますが、行データを返す必要がないので、より軽いSqlCommandオブジェクトを使ったほうがよいです。 （SqlCommandつうのはDataAdapterの内部オブジェクト） using (var conn = new SqlConnection(connectionString)) { 　　var cmd = new SqlCommand("一括更新SQL文", conn); 　　cmd.Connection.Open(); cmd.ExecuteNonQuery(); 　　// var n = cmd.ExecuteQuery(); // 処理件数を取得する必要がある場合 } 要するに、SQL文も、ストアドプロシージャも、DataAdapterからでも、SQLCommandからで実行します。 ようり高次元のTableAdapterや、LINQ for SQL、Entity Frameworkでも同じように、SQLやストアドを直実行するためのめそっどがあります。
「1度に使うのが1行」なら csvのデータを全部読み込んでから纏めて計算するのではなく csvのデータを1行読み込んでその行を計算して出力→次の行を読み込む というふうにすればいいということではないでしょうか。
わざわざハードルを上げる必要はないので、選択の余地があるならサーバーはWindowsのものを使えばよいと思います。 CGIにする場合でも、デスクトップ上のプログラムと内部的な処理に関しては同じです。 最大の違いはユーザーインタフェースですが、CGIにこだわらないなら.NET系の手法でもっと簡単に作れるのではないでしょうか？
SDカードをFATフォーマットでフォーマットしていないのでは？ ※ FAT32だとダメだと思います。
＞私が知りたいのは文字数ではなくバイト数です。 実際に、自分でプログラムを作って動作確認 しましたか？ strlen関数が返すのは、指定した文字列の位置 から'\0'までのバイト数です。 ＃長さに'\0'は含みません 半角文字列の時は文字数=バイト数になりますが 漢字が含まれる場合は、逆に文字数=バイト数に なりません。
インテリセンスがアクティブの状態で messagebox.show( と入力すると、確かにVC#2010の標準設定では自動的に MessageBox.Show( と修正してくれるのが正常です。 ですが、この挙動はVBとは異なり、あくまでインテリセンスから入力候補を選択する、という作業を利用者が意図して行う必要があります。 たとえば、 messagebox. → escを押す → show( のように入力を行うと、MessageBoxは入力候補を指示したことになりますが、escを押した段階でインテリセンスがオフになるので、showについては入力した文字列がそのまま残ります。 インテリセンスを使用する場合は、入力候補がアクティブが確認する必要があります。 また、入力候補が機能していない場合はCtrl+Spaceで有効化できます。 たとえば、 messagebox. → escを押す → show → Ctrl+Spaceを押す とすると、showをShowに自動で修正してくれることを確認できると思います。 これはスペルが修正されたのではなく、MessageBoxのメンバから、大文字、小文字無視で先頭が"show"一致するメンバがひとつしかないため、それが選択される、という挙動です。 したがって、 messagebox. → s → Ctrl+Space だけでも MessageBox.Show と入力できます。
A/Dコンバータだけでなく、アナログコンパレータも禁止する必要があるのではないでしょか？ CMCONレジスタを確認してください。
両方でビルドします。iOSはxcodeじゃないと最終物は作れません。eclipseも同様です。 開発中は、どちからメインで行い別の環境でも動作を確認するという形になると思います。 問題が起こった場合を考えるとxcodeでもAndroidでもデバッグできる能力が必要です。 何でもかんでも簡単になるわけでは無い様ですよ。 「C++でクロスプラットフォームを実現するCocos2dx入門（前編）：Cocos2dxでiOS／Androidの2Dゲーム開発を始めるには (1/3) - ＠IT」 http://www.atmarkit.co.jp/ait/articles/1302/25/n …
buffもarvも「ファイルの中で、最も長い行の文字数＋α」で良い。 例えば、最長の行が「先頭から改行まで、トータルで5329文字、改行も入れると5330文字」と言うのであれば、＋αして、5400バイトあれば問題無い。 ＞最終的には500行2048列の計算をしないといけないので 2048列で、１つの列にある「数値」は「最大桁数」が決まっている筈。 例えば、最大桁数が50桁なら、１行の最大文字数は「50×2048＋2047＋1＝104448」と計算できる（「2047」は「,」の分、「1」は改行の分） 安全の為に「＋α」して、104500バイトのbuffを用意すれば良い。 arvの最大必要バイト数も、同じように計算が可能。 ＞できたらmallocを使えたらよいと思っています。 char buff[100000];//←問題の部分 を char *buff; buff=malloc(100000); if (buff == NULL) { abort(); return; } に変えるだけだ。 もし、計算で求めた「１行の最大バイト数＋α」が「104500」になったのなら、100000を104500に変えれば良い。
そういう具体的な話なら、事情が違ってくるわけで。 もっとも、私なら、(既に出ていますが)ラップ関数作りますが。 「変換のオーバーヘッド+既存の関数」と「自作関数」のどちらが効率がいいかなんてわかりませんし。 システムで使うコードとOS基本の内部コードが違う、などとは、よくある事です。 プラットフォームが変更されたが、データやアルゴリズムは過去のものをそのまま使いたい、とか。
本当に動きませんか？私の環境は2.4.5ですが動作しましたので、2.4.6で使えなくなっているとは思えません。 情報が何もないので予想することしかできませんが、考えられる中で可能性が高そうなのはヘッダがincludeできていないことでしょうか。 もしそれでも動かないなら設定レベルでの問題になると思います。 その場合は具体的なエラーなどを記載して質問されることをお勧めします。
TCP での接続が確立しているなら、以下のコードで確認できます。 ※全角文字でインデントしてあります。 // filename: get_mac.cs // compile: %WINDIR%\Microsoft.NET\Framework\v3.5\csc get_mac.cs // or // %WINDIR%\Microsoft.NET\Framework\v2.0.50727\csc get_mac.cs using System; using System.Net; using System.Net.NetworkInformation; namespace get_mac { 　　class Program 　　{ 　　　　static void Main(string[] args) 　　　　{ 　　　　　　if(args.Length == 2) 　　　　　　{ 　　　　　　　　print_mac(args[0], Convert.ToInt32(args[1])); 　　　　　　} 　　　　　　else 　　　　　　{ 　　　　　　　　Console.WriteLine("Usage: get_mac <remore IP address> <remote port>"); 　　　　　　} 　　　　} 　　　　private static void print_mac(string remote_ip, int port) 　　　　{ 　　　　　　string ip = get_local_ip_address(remote_ip, port); 　　　　　　if(ip != "") 　　　　　　{ 　　　　　　　　string mac = get_mac_address(ip); 　　　　　　　　if(mac != "") 　　　　　　　　{ 　　　　　　　　　　Console.WriteLine("MAC address: " + mac); 　　　　　　　　} 　　　　　　} 　　　　　　else 　　　　　　{ 　　　　　　　　　　Console.WriteLine("Not found"); 　　　　　　} 　　　　} 　　　　private static string get_local_ip_address(string remote_ip, int port) 　　　　{ 　　　　　　IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties(); 　　　　　　IPEndPoint[] endPoints = ipProperties.GetActiveTcpListeners(); 　　　　　　TcpConnectionInformation[] tcpConnections = ipProperties.GetActiveTcpConnections(); 　　　　　　foreach (TcpConnectionInformation tcp_info in tcpConnections) 　　　　　　{ 　　　　　　　　if (tcp_info.RemoteEndPoint.Address.ToString() == remote_ip && 　　　　　　　　 tcp_info.State == TcpState.Established && 　　　　　　　　 tcp_info.RemoteEndPoint.Port == port 　　　　　　　　) 　　　　　　　　{ 　　　　　　　　　　return tcp_info.LocalEndPoint.Address.ToString(); 　　　　　　　　} 　　　　　　} 　　　　　　return ""; 　　　　} 　　　　private static string get_mac_address(string ip) 　　　　{ 　　　　　　NetworkInterface[] adapters = NetworkInterface.GetAllNetworkInterfaces(); 　　　　 　　　　　　foreach (NetworkInterface adapter in adapters) 　　　　　　{ 　　　　　　　　if (adapter.OperationalStatus == OperationalStatus.Up) 　　　　　　　　{ 　　　　　　　　　　IPInterfaceProperties ip_prop = adapter.GetIPProperties(); 　　　　　　　　　　UnicastIPAddressInformationCollection addrs = ip_prop.UnicastAddresses; 　　　　　　　　　　foreach (UnicastIPAddressInformation addr in addrs) 　　　　　　　　　　{ 　　　　　　　　　　　　if (addr.Address.ToString() == ip) 　　　　　　　　　　　　{ 　　　　　　　　　　　　　　PhysicalAddress phy = adapter.GetPhysicalAddress(); 　　　　　　　　　　　　　　return phy.ToString(); 　　　　　　　　　　　　} 　　　　　　　　　　} 　　　　　　　　} 　　　　　　} 　　　　　　return ""; 　　　　} 　　} }
Objective-C 知らないのでコードを正確に把握できませんが 普通にCとして考えた場合確認事項として2点 ・appdelegate.monda の値はきちんと0～3の値になっているのか 　（配列が1から始まるなら 1～4の値になっているのか） ・単純にif文4個書いただけだと 仮に1個目で正解としたときに 　2個目のif分で不正解と書き換えられることがあります（その反対もある） 　正解判定した段階で関数から抜けるとか else文内に 　残りのif文書くなどの方法を取ってください
補足は通知が来ないので見落していました。 回答としては既に他の人のにある通りです。 どのプロジェクトか具体的に書いてないので、こちらも一般論として抽象的に書くしかありません。 可能とも不可能とも断言できません。 http://oshiete.goo.ne.jp/qa/8313540.html に > よく、 ./configue → make という手順を踏むものがあります。 > ./configureを実行することで、その環境に合せたMakefileが生成されます。 と書きました。 これが (設定をして)→(./configureという)プログラム実行→Makefile ができる という典型的な例です。
× vector<int>starsBetween(const vector<Star>& vStars, double x, double y) ○ vector<Star>starsBetween(const vector<Star>& vStars, double x, double y)
(1) ヘッダインクルードする手間を省いたんではないでしょうか ＞CEndDlg endDialog(IDD_DLG_EXIT); なんて書くぐらいなら私は　CEndDlg endDialog();　　で済ませます (2) 他のコードがないんで詳細不明ですが そのイベントが動作しているなら基本クラスのCWinApp::OnAppExit(); を呼び出さないと終了することができなくなるはずです 手元で簡単なテストしたら そのイベント走らないので間違ってるかもしれません VC2010　MFCアプリにて
Run Configurations の Main タブ、 C/C++ Application: のところには実行ファイル名の相対パスが入っているはずなんですが、 そうなっていますか？ とりあえず New > C Project から Project type : Excecutable > Hello World ANSI C Project Toolchains : MinGW GCC を選んでプロジェクトを作成すると、同様のソースコードが作成されて すぐに Build Project, Run As Local C/C++ Application が実行できます。 それと比べてみるといいかもしれません。
正規表現で括弧部にマッチする部分を回して、その中の数の部分の文字列を数値化する、かなぁ。 http://msdn.microsoft.com/ja-jp/library/vstudio/ …
#1です 寝ぼけて適当に書いたので修正。 すぐ見つけることができたもので正確なものは英語版ですがこちらくらいかも。 Data buffer - Wikipedia (en.) http://en.wikipedia.org/wiki/Data_buffer 一応簡単なものはこちらです。 バッファとは - e-Wrods http://e-words.jp/w/E38390E38383E38395E382A1.html 「複数の機器やソフトウェアの間でデータをやり取りするときに、処理速度や転送速度の差を補うためにデータを一時的に保存しておく記憶装置や記憶領域のこと。」 が現在の基本定義です。処理速度・転送速度の差のための緩衝材的な意味です。 昔はソフトウェアとハードウェア間に使うデータでソフトウェア側がデータを受け取るか、整形して送信するときに使うメモリ領域が基本的にバッファでした。 マルチプロセッサ・マルチタスクの時代になってくると、ソフトウェア間の処理速度の違いを吸収するために使うメモリ領域にもバッファという言葉が使われるようになりました。ソフトウェア間で逐次（ＦＩＦＯ）処理されるデータのためのメモリ領域がこちらの使われ方の主戦場といったところでしょうか。 ソフトウェア間でただ一括転送されるデータならバッファという言葉は誤用ということになるのですが、よく誤用されます。
失礼しました。 後の質問 http://oshiete.goo.ne.jp/qa/8316075.html と混同して、こちらにも同じようなことを書いてしまいました。 ※ 新しく質問をしたのなら、過去の同じ質問は締切ってください。
C#の文法書を読めば，イベントの作成方法は書いていませんか。 推奨される手順は，次のような感じでしょうか。 ・イベントをメンバーとして定義する public event EventHandler Foo; ・イベントを呼び出すメソッドを定義する protected virtual void OnFoo (EventArgs e) { if (Foo != null) { Foo(this, e); } } あとは，イベントを発生させたいところでOnFooを呼び出せばよいです。 イベント引数に情報を載せたいのであれば，EventArgsを派生させたHogeEventArgsを用意して， イベントの型をEventHadnler<HogeEventArgs>にします。 ref) http://msdn.microsoft.com/ja-jp/library/vstudio/ …(v=vs.110).aspx ref) http://msdn.microsoft.com/ja-jp/library/vstudio/ …(v=vs.110).aspx
子どもに Surface Pro を取られてしまって試せないのですが、 [Windows ストア アプリのファイル アクセスとアクセス許可] http://msdn.microsoft.com/ja-jp/library/windows/ … ここら辺の情報は (1) の助けになりますかね。
ああ、動作しないってそっちか……＞float >LoadDivGraph("画像ファイル5枚.png",5,3,2,90,60,image); でも、おそらくステキな動作になっているのでご注意を。 # 箱は4つなのに5個放り込む～。
こういうことは、言語によって違うので、他の言語の考えをそのまま持ってこようとすると混乱の元です。 > hensuu = 100; と入力したら、hensuu構造体のなんというメンバに格納されるのでしょう。 まず、C#では、「100」自体も「Int型の構造体」になっています。 C言語のintのような「単独の数値しか持たない型」というのがありません。 C言語で無理矢理書くなら struct integer { int value; などなど} hensuu, value100 ; ... asignInteger(&hensuu,&value100) ; /* hensuuの各メンバーを、value100と同等のものにする */ ということです。 そして、どのメンバーにどんな形で格納されるか、というのは、通常は考える必要はありません。 hensuu=100 ; としたら、hensuuが『100と値の整数』として振舞ってくれれば、中でどんな計算をしていようが関係無いのです。 そもそも、メンバー変数(フィールド)はMaxValue,MinValueという定数しか公開されていないのですから、内容を知りようがありません。 > また、余談ですが構造体、といった場合メソッドは持たないものではないでしょうか。 言語によって違います。 C#では、structもメソッドを持ちます。 C++でも、structはメソッドを持つことができます。 Cでは、そもそもクラスもメソッドもありません。
>どのように時刻を取得できるでしょうか。 APIで一発。 というワケには行かないんじゃないですかねぇ…。 ・自前でNTPかSNTPプロトコルを実装する。 ・外部のNTP/SNTPクライアントを子プロセスで起動して結果から取得(または同期後にローカルタイムを取得)。 のどちらかになるかと。 自前で実装するならNTPよりはSNTPの方が簡単かと思われます。 # Simpleっていうくらいだし。 RFCなどで確認…でしょうかねぇ。 http://ja.wikipedia.org/wiki/Network_Time_Protocol http://ja.wikipedia.org/wiki/Simple_Network_Time … # 後者はRFCの番号の確認くらいしかできませんな。 「Windows SNTP サンプル」で検索してみると、他の方が実装してみたサンプルとか見つかるかも知れません。 http://www2.ocn.ne.jp/~honeybee/program/sample/G … とか。 外部のクライアントの方も環境が許せばw32tm.exeが使えますかねぇ。 # オプション指定いくつか試したけど…無理かなぁ。 # /resyncで同期して、ローカルタイム取得ですかな。
＞char型でもfgetc() 関数の戻り値を受けられる理由がわかりません。 char型は int型の一種です。長さが文字一文字分の整数型です。多くの場合8bit。 fgetc()の返すのは1文字もしくはEOFなので、格納できます。 ＞また、char型で受けた時に、char（1バイト）で、EOF（2バイト）をどうやって格納し、識別しているの でしょうか。 EOFは(かならずしも)2バイトではありません。値が -1 の int型定数です。多くの場合32bit。 char型が8ビットの場合、signed char は -128～+127の数値を扱えます。fgetc()がEOFの時は、-1 を返すので、signed char型変数に -1 が代入され、それと EOFつまり -1 を比較しているので一致します。 ファイルの途中に、0xFF というデータがあった場合、fgetc()は255というintデータを返しますが、signed char型変数にはそのまま255つまり0xFFが代入され、これはsigned char型では -1 と見なされるので、EOF と等しくなってしまいます。つまりそれ以降のデータが読めません。 「入力するファイルには将来にわたっても絶対に0xFFというデータは入っていない。入っていたら腹を切る」という場合には、fgetc() を signed char 型で受けてもかまいません。腹を切るのがいやな場合は、int型変数で受けます。 signed char とも unsigned char とも書かずに単に char と書いた場合にどちらになるかは処理系依存だったはずですので、単なる char型だと処理系によってはunsignedなので 0xFF は +255 になり、EOFと一致することは無くなります。なので、「特定のコンパイラだけで動けば良い。移植は許さない」という場合を除いて、上述のように腹を切る覚悟があってもchar型で受けてはいけません。
#1 でも指摘されてるけど, 「計算する」関数で表示するのはおかしい. あと, 「実ベクトル」っていうくらいだから 0.5 とかも許してほしい.
初心者だと質問の仕方も分からなくて難しい所も多いかとは思いますが、初めに文句を述べさせて頂きます (わざと厳しく書いている所があるという事は御承知下さい)。 他の方も仰っている様に、質問文のコードを見るとまともにコンパイルが通らない様なコードです。とすれば、そもそも質問者さんの所でコンパイルが通っていないか、てもとのコードはコンパイルが通るが質問入力欄にコードを手で入力してミスっているかと思われるのですが…。前者ならば「連動させることができない」のではなくそれ以前の問題として「コンパイルが通らない」と書くべきだし、後者であるのならば実際のコードの内容を「コピー&ペースト」で貼り付けるべきです。 また、質問の仕方にも問題があるかと思います。コードを貼り付けるのではなく、何が目的で何が問題点になっているのかを説明するべきです。長いコードを貼り付けて単に問題点を教えてくれというのでは、回答する側も何を答えたらよいのやら分かりません。(問題点というのは目的によって変わりますよね。物凄く極端な例を言えば、もしコンパイルエラーを出す事が目的であれば、質問文のコードには問題点はないわけです。ちゃんとエラーを出す訳ですから(極端すぎるとは思いますが)。 あるいはもっと現実的な例として、いざコンパイルが通った後の動作が期待していた物と違うという場合には、期待していた動作が何かと実際にはどうなるかを説明しないと問題点は相手に伝わりません。) で、以降は質問者さんが遭遇しているのはコンパイルエラーだと仮定して話を進めます。ソースコードの内容的に、上から順に h22.h, account.h, account.cpp, h22.cpp という(感じの名前の)ファイルの中身を貼り付けた物と推測致します(ファイル名は重要なので書いて下さい)。 1h22.h: コンストラクタ Bank(double,double); がない。(main.cpp から呼ばれている) 2 account.h: #include "account.h" →不要。(自分自身を include している。もし include guard がなかったら無限ループになる所です。) 3 account.h: ×Account(double &amout) → ○Account(double amount) 4 account.cpp: #include "acount.h" の acount は account のスペルミス 5 account.cpp: ×Account::Account → ○Account::Account() 6 account.cpp: ×Account::double 関数名(...) → ○ double Account::関数名(...) (3箇所) 7 account.cpp: ×関数名の deposit と getBalance が逆 8 account.cpp: ×getBalance(double balance) → ○deposit(double amount)。引数名が間違っている 9 account.cpp: ×elese → ○ else 10 地の文: ×h22.h の中身→×h22.cpp の中身 11 h22.cpp: Bank::Bank() の中身 Account checking; → 不要 (Account checking は this->checking と何の関係もない。更に、this->checking は Account のデフォルトコンストラクタで初期化済み) 12 h22.cpp: Bank::Bank() の中身 Account savings; → 不要 (同上) 13 h22.cpp: Bank::Bank(double checking,double saving) がない。追加する。例えば↓ Bank::Bank(double initialChecking,double initialSavings):checking(initialChecking),savings(initialSavings){} これで全部かどうかは分かりません。(あと、質問の仕方が良くないなので、この様に回答が得られる事を当然とは思わないで下さい。) > なにかヒントやアドバイスお願いします 質問者さんがするべき事は、個人的に以下の事と思います。 (1) 第一にコンパイラの出力するエラーメッセージを理解できるようになること。 コンパイラが沢山のエラーを出力するかもしれませんが、一つ一つちゃんと意味のある事が書かれています。コンパイルエラーが出る度に人に聞くというのをいつまでも続けるのは許されない事なので、これらのメッセージをちゃんと理解できる様になるべきです。 コンパイルエラーは、沢山出ても慌てずに、「一つずつ」解決していく事が基本です。エラーメッセージには大抵、エラーが起こったファイル名と行番号が書かれていますので、先ずはその箇所を確認する癖をつけて下さい。それができるようになったら、エラーメッセージが具体的にどういう事を意味するのかを調べるなり聞くなりして、段々と理解できる様になれば良いでしょう。 (2) 第二に質問の仕方を覚えること。 これは冒頭で述べた通り何が問題点なのか誰が聞いても分かる様に説明する事です (まあ、分かりやすく説明するには慣れの問題もあるのですぐには難しいかも知れませんが意識する様にして下さい)。 私自身、質問の仕方に自信があるわけでもないのですが、例えば今回の場合においては以下の様に質問するのが一つのやり方だったかなと思います。 ----- コンパイルをしようとすると以下の様なエラーメッセージが表示されコンパイルできません。 (エラーメッセージのコピーペースト) このエラーメッセージはどの様な意味でしょうか。どの様な場合に起こる物でしょうか。 ----- ただし、大量に出たエラーメッセージを全部まとめて質問するのは止めて下さいね。飽くまで自分の分からなかったエラーの部分を抜き出して質問する事です。(何れにしても、自分自身で手を尽くしても解決できなかった場合に質問する事はもちろん前提ですよ。) これらさえ習得できれば、取り敢えずの所はただ真っ直ぐ前に進むだけです。頑張って下さい。
TCP/UDP通信がどのように働くかを考えれば、疑問の答えが分かるのでは？ bindについて言えば 「OSはマシンに届いたパケットを如何にして該当プログラムに届けるか？」 です。 自分のポート番号をOSに教えてあげなければ、OSは着信したパケットをどのプログラム(プロセス)に届けるか分からないでしょう。それをするのがbindの役割です。 従って(1)は自ポート番号。IPは複数IPを持っているマシンで一部IPでのみ受け付ける場合に必要ですね。 一般的にサーバでbindするタイミングでは相手のIPやポート番号は不明ですから、要求されても困りますね。 (2)は質問者さんの認識通り。受信のために必要、送信では不要です。
ざっくり検索しただけですが…… http://intre.net/item_6569.html 辺りとか参考になりますかねぇ？ SIDやらなんやらが関わって来ますし、ちょっと面倒かも知れませんね。 上位のフォルダにFileSystemRights列挙体のCreateFilesが必要かも知れませんし。 文字列操作ではありませんが、取得したデータからの検索処理みたいなものは必要でしょう。 GetAccessRules()メソッドでコレクションを取得して、現在の権限が対応するものを探す必要があるでしょう。 # ユーザーに権限が設定されているかグループに権限が設定されているか…という問題もありますし。 # グループに設定してあって個別ユーザーの設定は無い。ということも考えられます。ドメインに参加している場合…とか。 使用するメソッド名やらでWeb検索すると他にも見つかるかも知れませんね。 # 英語なページである可能性も否定出来ませんけど。
回答No.4 の者です。すみません。訂正させて下さい。 (訂正) -glut -lGL ではなく -lglut -lGLU -lGL を指定して下さい 改めて確認した所、てもとの cygwin には GLU を入れていませんでした(汗)。GLU を入れて再度確認した所、/usr/lib/libGLU.dll.a ができたので、GLU も利用するのであれば -lGLU を指定して下さい。 また、 > 何が問題なのでしょう。 との事ですが、エラーメッセージに出ている通り「-lglut32 が見付からない」というのが問題点です。"-l某" というのは「"lib某.a" というライブラリファイルとリンクする」という意味なので、エラーメッセージは "lib某.a" というファイルが既定の場所に見付からなかったという事と解釈できます。 システムのパッケージで入れたライブラリの場合、大抵 /usr/lib/ の中に "lib某.a" は配置されますので、先ずはそこにファイルがあるか確認するのが解決の第一段階になる訳です。もしファイルがなければ、ファイル名が微妙に異なっているか、ライブラリが入っていないかという事になります。今回の場合は /usr/lib/ に libglut.a などのファイルがあったので、これらを試して見てコンパイルできる事を確認した訳です。 因みに、-lglut -lGLU -lGL の順番は、 GLU/GLU/OpenGL のそれぞれの依存関係によって決まっているので、指定する順番には気を付ける必要があります。
DirectSound しかさわったことないけど, そいつにはサンプルがあったはず. あたりまえだけど「リアルタイムに出力させる」ためには「リアルタイムに処理できなければならない」ことに注意.
いま、全く同じ動作をするソフトを、C#で作りました。 正直言って、ネット検索で作れる内容ではないです。 相違点は、自分の場合、楽天でなくColorMeShopProが対象です。 この手のCSVは、１商品の項目数が多いことが特徴で、そのまま編集するのは大変なため、ダウンロード後、内容を解析して、８個くらいの項目にしています（ほとんど決め打ちの項目が非常に多い）。 もちろん、編集後に書き戻すデータは規則通りのデータです。 C#とExcelの連携は、VS2008のVSTO(Visual Studio Tool for Office)で、「システムベースのアドオン」で制作しました。 Excelのコマンドペイン（右側に出るやつ）に「読込」「書込」ボタンを用意して、すべてExcel上で完結させています。 C#からのCSVアップロードには泣かされました。ColorMeはFTPでなく、フォームを使った転送で、クロスサイトフォージェリ対策のため、前画面で埋めたセッション値を評価され、ログイン～セッション（クッキー）～ダウンロード（アップロード）画面までを作りこみ、httpフォーム送信もフェイクする必要がありました。ふう 通常のftp通信なら、標準WebClientモジュールをC#から使えますが、ftpsだとサードパーティ製品を購入しないと対応できません。 あとはVSTOの作り方ですが、ほとんど事例がないため、けっこう苦労しました。 何で日本だとVSTOの情報少ないんですかね？ 自分の場合はどうしてもアドオンで作る必要があったたので必死コキました。
http://www.amazon.co.jp/WinSock-2-0-%E3%83%97%E3 … お勧めはこれかな。
同様の事を経験した事があります。 (以下、既に御存知の事が含まれていたらすみません) > Q．NULLが出力されているのはどうしてか． OS に依存する話かもしれませんが、少なくとも windows ではファイルハンドル毎に「現在の書き込み位置」が管理されています。そして、ファイルが現在どの様な状態になっていようとも「現在の書き込み位置」にデータを書き込もうとします。質問の例では、以下の様な動作になっているのではないでしょうか。 (1) プログラム A が起動し、test.txt を作成する (または、既存のファイルの長さを0にする)。 　　(初期の「書き込み位置」は、勿論ファイルの先頭。) (2) プログラム A が "位置 X" まで '@' を書き込む (X 文字の @ を出力する) (3) プログラム B が起動し、test.txt の長さを 0 にする。 (4) プログラム A は "位置 X" に新しく '@' を書き込もうとするが、 　　test.txt の長さが短くなっているので、「長さ X まで拡張」してから '@' を書き込む。 (5) 後は、プログラム B は先頭から順番に文字 '_' を書き込み、 　　プログラム A は "位置 X" 以降に文字 '@' を書き込む。 　　プログラム B は "位置 Y" まで書き込んだ所で停止し、 　　プログラム A は "位置 Z" まで書き込んだ所で停止する。 この過程の (4) の「長さ X まで拡張」の所で 0 (NUL) を fill しているのでしょう。 結果として、"_ _ … _ _ (位置 Y) NUL NUL … NUL NUL (位置 X) @ @ … @ @ (位置 Z)" という内容になるのだと思います。 (3) で長さ 0 にされるのが嫌ならば、fopen の時に "w" ではなくて "r+" で開けば良いです。 "r+" は既存ファイルを読み書き両用で開き、ファイルをクリアしない物です。 ファイルが既存でないかもしれないならば、"a" で開いてから rewind 関数を呼ぶなどすれば良いです。 > Q．AはBが書き込んでいる間，待っていたようだ うーん。質問に記述された結果だけ見れば、特にその様な事があったとは言えない気がします。また、(ファイル排他制御などしていないので) 「書き込みの間待っている」という仕様もないと思います。それから、エラーが出るかどうかについては…エラーが出るという事は無いと思いますが、ファイルの中身が滅茶苦茶になるのでこの様なプログラムに意味があるかは分かりません。。。 但し、それぞれのプログラムのバッファリングによって、文字が実際にファイルに書き込まれるタイミングが遅れる事には注意して下さい。 つまり、プログラム上で fputc を実行しても即座にディスクにデータが書き込まれる訳ではなくて、プログラム内部でデータが或る程度溜まるのを待ってから、まとめて書き出しを実行します。(1文字ごとにディスクと通信していたら時間がかかりますものね!) また、fclose を実行すると、溜めているデータを全部書き出してからファイルを閉じますが、プログラムを強制終了すると、溜めている未書き出しデータが出力されずに終了します。 余談: 参考までに: 「現在の書き込み位置」については ftell 関数 fseek 関数 rewind 関数 「バッファリング」に関しては: fflush 関数, setvbuf 関数
#1 です。 TIMER0の中で GPIO 4本を制御していると認識いたしました。 まず、ご指摘の通り PIC16F87XのCPUでは PWMが1chしかないため 制御は出来ませんね。 ステッピングモーターの制御がUSARTより優先度が高いのであれば、 USARTは USARTの割込みで処理をするのではなく、main側に持っていく、 TIMER0の割込みの中でポーリング確認する等 如何でしょうか？ 例： TIMER0のインターバルタイムがどの程度なのか分かりませんが、 TIMER0の割込みの先頭で ステッピングモーター側の処理を 行い、その後 USARTのレジスタを確認するとか？ USART0のボーレート（オーバランまでの時間が）が TIMER0より長い場合可能かと
私も作ってみましたが、文字列（＝配列の一種）が使えないのは確かに不便ですね。 #include <stdio.h> #include <ctype.h> int main(void) { 　int n; retry: 　n = 0; 　for (;;) 　{ 　　int c = getchar(); 　　if (c == '\n') 　　　break; 　　if (c < 0 || !isdigit(c)) 　　　goto retry; 　　n = n * 10 + c - '0'; 　} 　if (!(0 < n && n < 256)) 　　goto retry; 　for (int i = 0; i < 8; i++) 　　putchar('0' + !!(n & (1 << (7 - i)))); 　putchar('\n'); }
　出版社からは発表がないようですね。 　アマゾンのカスタマーレビューによると。 ＞14歳からはじめるC言語わくわくゲームプログラミング教室Visual Studio 2008編―Windows XP/Vista対応 [単行本] ＞http://www.amazon.co.jp/14%E6%AD%B3%E3%81%8B%E3% … ＞正誤表が見つからないので書きました, 2012/6/29 ＞http://www.amazon.co.jp/product-reviews/48997721 …
多分、何かの演習で、回答者に求められているのが、構造体 Triangle を定義すると言うことかなと思います。 で、Triangle を定義した後で、コメントアウトされていた、#define TRIANGLE_DONE のコメントを取ると、全体として、動くプログラムになるようになっているのかなと。 で、これで、Define the Triangle structure. Then, uncomment #define TRIANGLE_DONE in h19.h が出力されていないと言うことは、inh19.h がインクルードされてないのでしょう。 さて、 struct Triangle{ Point a, b, c; }; となっています。 で、struct Point は、いかにも、「点」を示す、double のペアだという雰囲気が漂っています。 一方で、double premiter(const Triangle& t) で、struct Triangle のメンバーであるはずの、p1, p2, p3 がアクセスされています。 ということは、この時点で、Triangle の定義は間違っているか、足りないかです。 C++の世界では、struct も class と同じ能力を持つので、 struct Triangle { Point a, b, c; // こっちは座標で定義 double p1, p2, p3 // こっちは辺の長さ }; という定義で、a, b, c を決めたら、p1, p2, p3 も自動的に決めるようなこともできますが、それを求めているのかなぁ？
> しかし、javaのデフォルトのライブラリを使っていて驚いたことが、「例外のエラーメッセージとメソッ > ドのパラメータ名が一致しない」、「そのうえ、そんな値のパラメータを渡していない」、「そもそも、 > そんなパラメータ名の値を渡していない」ということです。 > 　原因はおおよそ見当付いていますが…。 > 　Addをそのまま使っていると、似たような混乱を生みかねないので、値を追加できなくて、”正しい（分 > かりやすい）”例外を出すためにTryAddを使おうという考えです。 なるほど、JDKのどのクラスのメソッドが該当するのか全く把握していませんが、 そんなのがあるんですね。 そういった正当な理由がある上で『あえて』捕捉するならば、パフォーマンス改善の 考え方も頷けますし、アリと思います。 が、きっとそれはライブラリなどのライブラリ・フレームワーク側が実装する方法であって、 それを利用して開発を行う側では、Add()、TryAdd()の利用用途が変わる場合もあると思いますよ。 （まあ、主にそれが実装スタイルの思想や要件によるでしょうけど）
動きがおかしいというか画面だけ見ると単純に 2を打つのが早いだけのようにも思える 同じ環境もってませんしテストもしてないので間違ってる可能性あり ＞scanf(" %d\n" , &array[i]); \n 必要だっけ？
システム条件は、＃１回答者の回答通り。なお、Cの学習用としては、Xcodeは、おすすめしません。Xcodeは、iOS app/Mac OS Appのプロフェッショナル開発環境であり、Objective-Cが開発言語です。 　ですので、初心者を圧倒する設定や多数のメニューがあり、初心者のC学習用としては、おすすめしません。 　実はCは口実で、Macを買う理由が必要というなら、Xcodeは、素敵な選択ですが。
1つ目の質問については、そのとおりです。バウンダリーで囲まれた範囲が署名の対象です。 2つ目の質問については、署名はあくまで1つのメールにつき1つです。添付ファイルがある場合は、メール本文と添付ファイルを合わせた全体に対して署名されます。
>おそらくmsvcrt.dllが無いといわれているのだと思いますが、dllってアプリインストール時に無ければ一緒に入れてくれれはしないものなんですか？ 作成したアプリケーションはどのようにしてPCにインストールしたんでしょうか？ アプリケーションをPCにコピー＆ペーストしただけの作業の事を「インストール」とおっしゃってるのでしたら、その作業の仮定で勝手にVC++のランタイムライブラリがインストールされると思いますか？ インストーラーを使用してのインストールでしたら、そのインストーラーでVC++のランタイムライブラリをインストールするように作成してください。
まずは、 ・具体的な例外の種類を調べる ・本当に画像が破損していることが原因なのかを調べる ではないでしょうか。 単に例外、と言われても、どんな例外かわからなければ対処方もありません。 また、別の原因で例外が発生しているのを、たまたまそこで止ったように見えているだけかもしれません http://msdn.microsoft.com/ja-jp/library/vstudio/ … Loadメソッドで読み込めば、問題があれば例外が発生します。 エラーの内容も、例外の種類を調べればわかります
PictureBoxの画像は、 Imageプロパティでわかります http://msdn.microsoft.com/ja-jp/library/vstudio/ … http://msdn.microsoft.com/ja-jp/library/vstudio/ … JPEGを読み込んだのなら、実際にはBitmapクラスになっていると思われます http://msdn.microsoft.com/ja-jp/library/vstudio/ … BitmapクラスにはGetPixelメソッドがあります http://msdn.microsoft.com/ja-jp/library/vstudio/ … ついでに、別質問にあった「ファイルを介さずに画像を表示する方法」ですが Bitmapクラスで画像を作って、PictureBoxのImageに設定します。 上記Bitmap クラスのマニュアルにサンプルコードが載っています。 面倒かもしれませんが、マニュアルを読みましょう。 とりあえずは、関連しそうなところを辿っていくだけでいいです。
No3 の補足に対して No2でちょっと大嘘書いてたようです 文法的に間違いはありませんが やはり固定データ領域に対して記載したような変更を行うとすると エラーになるのでやってはいけません(VC環境にて確認） 一旦作業用のバッファにコピーするなどしてから行うようにしてください 書かれてる追加質問に対してですが そのままではエラーになります （これまでの内容と合わせてCのコードきちんと理解してますか？） あくまで文法的な話として *(p_test1+1) = 以下同様　とすればそうなります
#1さんのご回答でも示されているように、 端末自体の時計に依存するスタイルで作ってしまうと、端末の時計をいじることで容易に不正行為が行えます。 ソーシャル要素を一切含まないゲームなのであればこれでもいいかもしれませんが、 ソーシャル要素を含むのであればこれは避けるべきです。 スタミナが満タンになる時刻をサーバーに保存しておく、というのがよい方法でしょう。 1時間分のスタミナを消費したなら、満タンになる時刻を1時間後ろにずらせばそれで済みます。 通信による遅延を気になさっているようですが、 スタミナの回復が2, 3秒遅れたからといって難癖つけるような人はそうそういません。
例えば、 機能を追加して int func0(int x,int y,int z){ ans = x - y ; return ans -z; } を作ります。 void main(){ a=10; b=20; func(a,b); std::cout << ans << std::endl; int c=func0(30,40,50) ; std::cout << c << std::endl; std::cout << ans+c << std::endl; } とすると、 std::cout << ans << std::endl; → 30 std::cout << c << std::endl; → -60 と出力されます。 ということは std::cout << ans+c << std::endl; で期待するのは、 ans 30 + c -60 = -30 となりますが、実際には「-70」が出力されます。 これは、func0で途中計算に ans = x - y ; としてしまったため、ansが変わってしまったからです。 この程度の規模なら、管理もできるでしょう。 ですが、例えば、 「std::cout は実はグローバル変数ansを書き換える」なんてことになっていたらどうでしょうか? 標準ライブラリでは、そのようなことが無いように作られていますが、自作プログラムだと、ついうっかりやってしまう可能性があります。 実用的なプログラムとなると、数千～数十万といった行数になってきます。その中から、グローバル変数がどこで使われているか調べるのは並大抵のことではありません。 変数の有効範囲はなるべく狭く。必要なところだけで有効なようにする。 というのが、現在の主流の考えです。
stable_sort でいいなら qsort でもいいような気がする＞#3.
エラーメッセージがご丁寧に指摘しているのですから、それに従って修正するだけ…だと思いますが……それすら理解できないのでしょうか？ >status = closesocket(dstSocket); break;　　　　　　　　　　　　　　　　　←ここです！！！ statusって名前の変数がないのですから、用意してください。 型についてはclosesocket()の戻り値の型を調べればよいでしょう。 もっとも…その後で使用していないのであれば代入式自体をカットしてしまってもよいのでしょうが……。 >stAddr.sin_addr.s_addr = inet_addr(destination);　　　　　　　　　　　　　　　　　←ここです！！！ 書かれている通り「stAddr」ってのがありません。 上記と同じく用意してください。 といいたいところですが……前後を確認する限り「dstAddr」のタイプミスでしょう。 >for(i=0; i<10; i++) { ←ここです！！！ iって変数が用意されていません。 用意してください。 for(int i=0; i<10; i++) { でもOKかも知れませんが。
>フォントの選択を変更した後、書き換えられたら再度上書きする。という処理が必要そうです。 ということで、無駄なあがきをしてみる(見苦しいとも言う)。 WindowsXP Sp3 + VC# 2010 EE(.Net Framework 4.0 Client Profile)で確認。 class CustomFontDialog : FontDialog { 　const int WM_INITDIALOG = 0x0110; 　const int WM_COMMAND = 0x0111; 　const int CBN_SELCHANGE = 1; 　const int WM_SETTEXT = 0x000C; 　const int WM_APP = 0x8000; 　private IntPtr hStaticWnd; 　[DllImport("user32.dll")] 　static extern IntPtr GetDlgItem(IntPtr hWnd, int nIDDlgItem); 　[DllImport("user32.dll")] 　static extern int SendMessage(IntPtr hwnd, int msg, int wParam, string lParam); 　[DllImport("user32.dll")] 　static extern bool PostMessage(IntPtr hWnd, uint Msg, int wParam, int lParam); 　[DllImport("user32.dll")] 　static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, Boolean bErase); 　[System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.Demand, Name = "FullTrust")] 　protected override IntPtr HookProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam) 　{ 　　switch (msg) 　　{ 　　　case WM_INITDIALOG: 　　　　hStaticWnd = GetDlgItem(hWnd, 0x0444); 　　　　SendMessage(hStaticWnd, WM_SETTEXT, 0, "1234567890"); 　　　　break; 　　　case WM_COMMAND: 　　　　if ((wParam.ToInt32() >> 16) == CBN_SELCHANGE && (wParam.ToInt32() & 0xFFFF) == 0x470) 　　　　　PostMessage(hWnd, WM_APP, 0, 0); 　　　　break; 　　　case WM_APP: 　　　　SendMessage(hStaticWnd, WM_SETTEXT, 0, "1234567890"); 　　　　InvalidateRect(hWnd, IntPtr.Zero, false); 　　　　break; 　　} 　　return base.HookProc(hWnd, msg, wParam, lParam); 　} } 「フォント名」の選択が変更されると親ウィンドウにCBN_SELCHANGEが通知されるので…PostMessage()でメッセージキューに独自メッセージを積む。 で、独自メッセージを受けたらサンプルの文字列を書き換えて再描画を強制する。 う～ん……かなり無理矢理ですなぁ…。 手間かけている割には見返りは自己満足だけ…という。
boost::anyでそれらしいことが出来ます #include <iostream> #include <vector> #include <string> using namespace std; #include <boost/any.hpp> using namespace boost; int main(int argc, char* argv[]) { vector<any> ary; ary.push_back(string("asdf")); ary.push_back(3); ary.push_back(3.4); cout << any_cast<string>(ary[0]) << endl; cout << any_cast<int>(ary[1]) << endl; cout << any_cast<double>(ary[2]) << endl; return 0; }
前提条件がはっきりしません。任意のプログラム上のマウスの情報を表示出来ないといけないのか、あるいは今開発中のシステムの補助的なデバックルーチンとして使用するするのかなど。ＤＬＬという表現からは後者のように思われますが。
こちらのFaceTrackingSDK使えばできるのではないでしょうか？ http://kinection.jp/post/95
理論的に可能だが、実用的ではない、というところでしょう。 コンピュータが実行する以上、最終的には機械語に変換されます。 C言語のように直接機械語に翻訳したり、Perlのように機械語で作られた実行環境を利用したり、とやり方に違いはありますが。 CPUの基本動作は簡単です。 メモリの特定のアドレス(これをプログラムカウンタという変数で記憶しています)から必要なワード数読み出して、その値によって実行する計算を決めます。 Perlで書けばこんな感じ $command = $memory[$pc] ; if ( $command == 0x01 ) { # 0x01はaレジスタをデクリメントするコマンドとする $a -- ; # 計算結果が0になったらZフラグを立てる if( $a == 0 ) { $flag_Z = 1 ; } else { $flag_Z = 0 ; } # 計算結果が負になったらCフラグを立てる # 溢れた桁は無視される if( $a < 0 ) { $flag_C = 1 $a = $a & 0xffffffff ;; } else { $flag_C = 0 ; } } elsif ( $command ==0x02) { ...以下同様 これが、実用的な速度で動くものでは無い、というのはご理解いただけると思います。 逆コンパイルについて。 JavaはJavaVM用にコンパイルされます。プログラムの最適化は、実行時に行う部分が多く、コンパイル時にはあまり最適化されません。 そのため、元のソースが予想できるので、逆コンパイラの精度は高いです。 Cはコンパイル時に最適化を行います。 s=0;for(i=0;i<100;i++){s++;} を、「sは100回インクリメントされる。他では使われない」ということから s=100; と最適化する、等ということが行われます。(オプションで抑制できますが) s=100;から元のforにするのは無理です。
PCページを表示させることはできるのでしょうか？ また、スマホでページを見たときなぜスマホ用のページなるかご存知なのでしょうか？
ＩＴ関係の仕事で、プログラムが読めるかというような聞かれ方をすることはあり得ない。 たいていは、プログラミング経験が何年で、総計何ステップぐらいか、月に何ステップの コーディングをこなしたか、設計書はどのレベルまで書けるかなどです。 実際に、プログラムを読むだけの仕事というのはない。 非常に、希だけども、ドキュメントが散逸してしまって、ソースプログラムを読んで、 設計書を再生してくれないかという依頼もなくはないが、 プロのプログラマーは、原則的には、このような仕事は受けないもんだ。 ドキュメントの散逸したシステムは、地獄を見るのは、ほぼ間違いない。 プログラマー自分から地獄に飛び込んではいけない。 希に、地獄を作り出すプログラマーもいますが。 開発現場の地獄の修羅場ぐらい恐ろしいもんはないですぞ。
最初に 1回だけ計算して配列に入れておく, ってこと. 同じ値を何回も計算するのはバカらしいので.
＞ そのコントロールにフォーカスが当たったことを知らせてくれるメッセージは無いですか？ EDITコントロールの親ウィンドウにEN_SETFOCUSが届くはずです。 ＞ 別の WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU を持つ親ウィンドウをクリックしても ＞ ずっとこのEDITコントロールにフォーカスが当たりっぱなしなので質問しました。 状況がよくわかりませんが、モーダルダイアログを表示しているなら、その親ウィンドウは操作不可となってフォーカスを受け取ることもできません。
すくなくとも、提示された部分に大きな間違いは無さそうだし、実際実行してバイナリエディタで見ても 00 と 02 だけで意味のある文字列などは出てきません。 これに int main() { save_map() ; return 0; } を付けただけのテスト用プログラムを実行したらどうなりますか?
PCLであれば、registrationという機能があるので、それで位置を取得出来ます。 はっきり思い出せないですが、確かPCLの標準サンプルで、 sac_model_registration.cpp がそのサンプルだったかと思います。 PCLのregistratinは2つの点群データ間の位置を合わせるためのトランスフォームを推定する、という機能 ですが、私が以前試した限りではあまり精度は良くありませんでしたが、キャリブレーションに利用する形状を工夫すれば精度良く位置あわせできるかもしれません。
1.インスタンスの時に生成されるのはクラスのメンバ変数です。staticではありません したがって貴方の求めた振る舞いをするのはメンバ変数です。 2.メンバstatic変数と関数内のstatic変数は、初期化以外は同じです。 メンバ変数はstatic変数の値の定義の仕方で変わりますが、大体関数外にstatic変数作った時と振る舞いが同じです。 関数内のstatic変数は、非クラスのものと同じ働きをします。したがって、最初に呼び出された時にインスタンスが生成されます。
>GetLastErrorでエラーコードを取得すると740が帰ってきますが、該当するコードがありません。 WinError.hを740で検索すると… ERROR_ELEVATION_REQUIREDってのが見つかります。 さらにERROR_ELEVATION_REQUIREDでググると… http://p2pquake.ddo.jp/errors/archives/256 とか見つかります。 起動しようとしているTabTip.exeが必要とする権限と作成したプログラムの権限とか確認してみてはどうですか？
その目的のためだけだったら「C言語は使わず、PerlとかPythonとかRubyとかPHPとか..を使う」 C言語で作りなさい、という宿題なら、ポインタと配列と文字列のところを重点的に勉強しなおす。
#4です。 ＞1行の長さ,行数ともに制限はありませんので、実際に読み込みたいファイルは行数,各行の長さはバラバラです。 ＞大丈夫です。目的達成できるプログラムであれば、言語,関数などは自由です。 何を参考にしても良いとのことで、自前でなくても大丈夫です。 １行の長さ、行数に制限がないということは、コーディング時に、制約をつけてはいけない とうことを意味します。 これを厳密にＣ言語で実装するのは、非常に大変になります。 しかしながら、Ｃ言語以外のスクリプト言語（perl,ruby）などであれば、 実質的は、（ほぼ）制限のない形で、実装できます。 行数が非常に大きい場合、時間はかかりますが・・・ 以下は、perlで作成したスクリプトです。（スクリプト名をgoo.plとします） コマンドプロンプトで perl goo.pl test.txt と入力してください。 ソート結果が表示されます。 （perlがインストールされていない場合はperlが必要になります） -------------------------------------------- usestrict; usewarnings; #ソートルーチン sub mysort{ $a->[0] cmp $b->[0]; } my $file = shift(@ARGV); #入力ファイルのオープン open FHA,$file or die("can't open $file"); my @linfo = (); #入力ファイルの読込 while(<FHA>){ # ３列目の取得 my @elm = split(/,/,$_); # ３列目と１行全体を配列に確保する my $ref = [$elm[2],$_]; push(@linfo,$ref); } # 入力ファイルのクローズ close FHA; # 読み込んだ行を第３列目でソート @linfo = sort mysort @linfo; foreach my $lin (@linfo){ print $lin->[1]; } -------------------------------------------------- 実行結果は以下の通り C:\goo>perl goo.pl test.txt 2013/08/01,15:55,20130801155519-119072194140,,,山田,東京,mail 2013/08/01,16:19,20130801161906-210164001071,,,川口,神奈川,,電話番号 2013/08/01,11:32,20130802003256-116091178056,鈴木,埼玉,mail,電話番号 ------------------------------------------------
確認ですが ------------------------------------------------------------------------------ #pragma once #include "Frm_Manual.h"　←追加 private: System::Void cmd_Manual_Click(System::Object^ sender, System::EventArgs^ e) { Frm_Manual^ form = gcnew Frm_Manual(); form->Show(); } ------------------------------------------------------------------------------ これがFrm_Main.h ------------------------------------------------------------------------------ #pragma once #include "Frm_Main.h"　←追加 private: System::Void cmd_Main_Click(System::Object^ sender, System::EventArgs^ e) { Frm_Main^ form = gcnew Frm_Main(); form->Show(); } ------------------------------------------------------------------------------ これがFrm_Manual.h ということで良いでしょうか？ であれば、 ・実装はソースファイルで行う ・クラスの宣言はヘッダファイルで行う ・インクルードはヘッダファイルで行う という風にしなければなりません。 Frm_Main.h ------------------------------------------------------------------------------ #pragma once class Frm_Main { private: System::Void cmd_Manual_Click(System::Object^ sender, System::EventArgs^ e); }; ------------------------------------------------------------------------------ Frm_Main.cpp ------------------------------------------------------------------------------ #include "Frm_Main.h" #include "Frm_Manual.h" System::Void Frm_Main::cmd_Manual_Click(System::Object^ sender, System::EventArgs^ e) { Frm_Manual^ form = gcnew Frm_Manual(); form->Show(); } ------------------------------------------------------------------------------ Frm_Manual.h ------------------------------------------------------------------------------ #pragma once class Frm_Manual { private: System::Void cmd_Main_Click(System::Object^ sender, System::EventArgs^ e); }; ------------------------------------------------------------------------------ Frm_Manual.cpp ------------------------------------------------------------------------------ #include "Frm_Manual.h" #include "Frm_Main.h" System::Void Frm_Manual::cmd_Main_Click(System::Object^ sender, System::EventArgs^ e) { Frm_Main^ form = gcnew Frm_Main(); form->Show(); } ------------------------------------------------------------------------------ このようにすればいけるはずです。
なんとなく突込みが来るのを待っているような気がするので期待通りに突っ込んでみる.... #4 のように「関数を呼び出して切り替える」くらいなら, 最初から複数の配列を用意する方がおそらくまし.
void* IDNode::accept(Visitor* v){ return v->visit(this); } void* OpNode::accept(Visitor* v){ return v->visit(this); } ... void* IDNode::accept(Visitor* v, void* obj){ return v->visit(this, obj); } void* OpNode::accept(Visitor* v, void* obj){ return v->visit(this, obj); } ... というのであれば、オーバーロードをやめて、 ・常にvisitは(Visitor*, void*)を引数にする ・第２引数を使わないケースの場合は第２引数にはNULLを設定する のような仕様にしてはいかがでしょうか。 つまり、Node側は void* IDNode::accept(Visitor* v, void* obj=NULL){ return v->visit(this, obj); } void* OpNode::accept(Visitor* v, void* obj=NULL){ return v->visit(this, obj); } ... のようにしておき、Visitor側は全て void* visit(Node* n, void* obj)=0; とする。 もう１つの改善案は、そもそもPPVisitor、IRVisitorをそれぞれVisitorの派生クラスにしない、というのはどうでしょうか？ つまり、Node側は void* IDNode::acceptForPP(PPVisitor* v){ return v->visit(this); } void* OpNode::acceptForPP(PPVisitor* v){ return v->visit(this); } ... void* IDNode::acceptForIR(IRVisitor* v, void* obj){ return v->visit(this, obj); } void* OpNode::acceptForIR(IRVisitor* v, void* obj){ return v->visit(this, obj); } ... としておき、Visitor側は class PPVisitor { public: virtual void* visit(OpNode* n)=0; virtual void* visit(IDNode* n)=0; }; class IRVisitor { public: virtual void* visit(OpNode* n, void* obj)=0; virtual void* visit(IDNode* n, void* obj)=0; }; このようにするのはどうでしょうか。
>何方か、EWCLIB 2.1を実際に使われている方、教えて下さい。 使ってはいませんが、気になるところのツッコミを……。 >色々リンクエラーが出てコンパイル出来ません。 そのリンクエラーの一部でも掲示した方がいいかと思われますが。 勝手な解釈ではなく、エラーメッセージをそのままコピペで貼る方がいいです。 # 解釈の内容が間違っていたら無駄な伝言ゲームやるだけです。まぁ、解決遅れても伝言ゲームを楽しみたいのであればかまいませんが。 # エラーメッセージに個人情報が含まれそうな場合は、その部分はカットしても問題ないでしょう。 # ソリューションディレクトリのフルパス名にWindowsのアカウント名が…とか。 >/clr:pure または /clr:safe と共にコンパイルされた関数に対する呼び出し規約 '__stdcall ' が無効です CLRでやりたいんですか？ パッとみた感じではC/C++で使えるライブラリではあるようですが、C++/CLIに対応しているのかどうか……。 プロジェクト作る時に何を選びましたか？ 「Windows フォームアプリケーション」ではなく「Win32 プロジェクト」を選択するものかと……。 参考URL：http://e-words.jp/w/CLR.html
私の認識にも間違いがあるかもしれませんが。 チューリング完全とは「チューリングマシンで実現できる」と言っているだけで、実際に何が「チューリングマシンでできる」かには言及していません。 よって > FORTRANは数学的計算は勿論、３Ｇゲームや通販サイトなどFORTRAN１言語だけで何でも出来て、ありとあらゆるシステム構築に使える 「数学的計算」「３Ｇゲーム」「通販サイト」などが作れるかどうか、と「チューリング完全」かどうかとは、直接の関係はありません。 > TeXは数式や楽譜の作成くらいの機能に制限されている 文章書くだけの人には馴染みが無いかもしれませんが、TeXにはプログラミング言語としての一面があり、これはチューリング完全になっています。 http://ja.wikipedia.org/wiki/Brainfuck このような、とても実用には使えない言語でも「チューリング完全」です。 また、チューリングマシンは、無限長の記憶領域を持ち、処理時間という概念はありません。 対し、現実のコンピュータは、記憶領域は有限であり、ある程度の処理時間が必要です。 チューリングマシンで「解ける」ことが判っている問題でも、現実のコンピュータではメモリが足りない、あるいは、計算時間が非現実的である、ということが沢山あります。 少し前に話題になった「組合せ爆発」の動画ですが、この「全ての経路を求める」問題は、正方形の分割数がいくつであろうとも、チューリングマシンを使って解を求めることができます。 しかし、実在のコンピュータで解く場合には、10x10で25万年かかっている、ということで「現実的には解けないのと一緒」と言えます。最後に出てきた高速のアルゴリズムでも、100x100等は「現実的には解けないのと一緒」でしょう。
【エラー内容】 とありますが、これを見る限り、正常に実行されているように見えます。 必要なDLLやexeを読み込んで、(プログラムが実行され)終了した、というだけの、途中経過が出力されているもののようです。 この内容だと、コマンドプロンプト画面が表示され、その画面にabcと出力された直後、コマンドプロンプトが閉じます。 これが一瞬で行なわれるので、一瞬コマンドプロンプトが表示されて、すぐに閉じたように見えます。 画面の内容まで確認できる人は、もの凄い動体視力の持ち主だけです。 コマンドプロンプトから直接実行ファイルを実行するか、プログラム中に終了せずに待つ仕組みを用意するか、します。 http://msdn.microsoft.com/ja-jp/library/0wc2kk78 … > 8. プログラムを完成させます。 > プログラムの最終行にある Console.ReadLine(); は、Enter キーが押されるまでプログラムを一時停止するコードです。 > この行を省略すると、コマンド ライン ウィンドウはすぐに閉じられ、プログラムの出力結果を確認できなくなります。
IntelliSenseのデータベースですかねぇ。 作成されたプログラムの実行には全く無関係です。 http://d.hatena.ne.jp/unarist/20111202/1322801493 とか参考になりますかね。
この類いの質問は、著者なり出版社なりにすべきかと思います。 そうすることで正誤表や増刷に反映されることにもなります。 間違いの指摘であっても、読者から反応が還ってくれば著者にとっても励みになります。
回答ではありませんが、少し気になった事があります。 素人が何も分らずに言っているだけかも知れませんが、その場合は申し訳ありません。 >dt=1.0e-15;　//時間刻み幅 偏微分方程式で解くような物理現象は、このように時間刻み幅を小さくしなくても十分ではないでしょうか。 psオーダーでも 1.0e-12ですし、........ 各ループ毎の変数セーブ域 前回値と新しい値の変数セーブ域、その他があれば計算出来るのだと思われます。 途中経過も残してアニメ表示等に使われるのでしたら、例えば100ループ、1000ループ等毎にセーブしておいて使うようにされたら良いのではと思われます。
回答がないようなので、字面だけ見た印象を。 ただし、非専門家で、MS Windows も C++ もほとんど、触れたことがありません。 - 関数 LinkLoad() の引数の lnkpass は lnkpath のミススペルか。 -- 別に、ミススペルでも、関数内で整合してるので、問題ないと思います。 - 関数 main() の fullpath は 100 じゃなく MAX_PATH の領域を確保しないとダメなのでは。 -- コンパイラが文句言わないなら、問題ないのかもしれません。 - main() 中のメソッド呼び出し GetPath() の _MAX_PATH は MAX_PATH のミススペルか。 -- こっちのミススペルはダメだと思います。 - 関数 UngetLnk() は getLnk() と対（つい）で、main() の else 側でも必要なのでは。 -- つまり、if 文の下に移動したほうが良いかと思います。
プロジェクトのプロパティのビルドページの全般欄にある，[32 ビットの優先]のチェックを外して下さい。
まあ static だと「値が保存されている」と思い込んじゃうからかえって問題を見つけにくいかもしれんのだけど.... 「色々試しました」という中で, その変数の値を出力しようとは思いませんでしたか?
char型は1バイトの文字型です。 ですので、char型のオブジェクトひとつでは、UTF-8で表現される大多数の文字を格納することができません。 たとえば、「山」という文字であれば e5 b1 b1 というコードですので、次のような配列で表現することになります。 (char[3]){ 0xe5, 0xb1, 0xb1 }
「変数名をBCCで使える名前に変える」以外にありません。 まっとうなエディタなら一括置換機能があるのでそれを使いましょう。
標準のC++の変数名で使用できるのはアルファベット(大文字・小文字)・アンダーバー・数字だけです。 それにマイクロソフト独自の仕様として$が使用可能な文字に追加されています。 http://msdn.microsoft.com/ja-jp/library/565w213d …
Type.GetMethodやType.GetMethodsで対象のMethodInfoを取得し， MethodInfoのInvokeメソッドを使って呼び出します。
リアルタイムってのも厳しいんじゃないですかねぇ……。 waveInOpen()でコールバックを指定して、WIM_DATAメッセージで通知されたデータブロックの内容を解析して…ということになるかと……。 「waveIn リアルタイム 波形」辺りで検索することになりますかねぇ。 # 軽く探した限りじゃなぜかVBばかり… WAVEFORMATEX構造体で指定した情報により、1サンプリングデータのビット数とかは判っているでしょうし。 なるべくリアルタイムに処理しようとしてWAVEHDR構造体でサイズを小さく設定した場合は…取りこぼしとか発生しませんかねぇ。 まぁ試したことはないのですが…。
群盲象をなでる状態になりそうな気がするので, 可能ならそのような問題を生じる短いプログラムを出した方がいいんじゃないでしょうか.
#2です。 >返信ありがとうございます．自分でも動かせました．ただ内容は完全には理解していない気がします．こういうシステムの方まで操作する系のプログラムってどういう本で勉強するものなのでしょうか? >Linuxの教科書などになるのでしょうか? 今回のselectに関しては、ネットワーク通信でノンブロッキングによるTCP/IPの通信を行うときに必須でした。そのときに、参考にしたのは「UNIXネットワークプログラミング〈Vol.1〉ネットワークAPI:ソケットとXTI」です。（W・リチャード・スティーブンス著）（但し、難度は高いです） 実際に業務で使用されるプログラムを書く場合は、徹底的なエラー対応処理が求められますので、 上記の本は、非常に参考になりました。但し、作成するプログラグが業務で使用されるものでない場合は（多少のフリーズなどが大目に見てもらえるなら）もっと簡単な参考書でよいかと思います。
高分解能タイマは環境依存ですがＷｉｎｄｏｗｓであればQueryPerformanceCounter関数とQueryPerformanceFrequency関数が利用できるかもしれません。（普通使えます。） QueryPerformanceCounter関数 http://msdn.microsoft.com/ja-jp/library/cc410966 … QueryPerformanceFrequency関数 http://msdn.microsoft.com/ja-jp/library/cc410968 … 注意　clock関数と仕様が異なり実時間のタイマです。 補足　clock関数はＣＰＵ時間です。詳細は↓ http://detail.chiebukuro.yahoo.co.jp/qa/question … 補足　Microsoftのclock関数の実装定義 http://msdn.microsoft.com/ja-jp/library/vstudio/ … POSIXであればclock_gettime関数とclock_getcpuclockid関数が利用できるかもしれません。 http://linuxjm.sourceforge.jp/html/LDP_man-pages … http://linuxjm.sourceforge.jp/html/LDP_man-pages …
release じゃないかしら
DXライブラリそのものに、画像読み込み関数が用意されているため、 上記を利用する限り、静的メモリや動的メモリの区別を行う必要はありませんよ。 >と、Ａ，Ｂ，Ｃの三つを考えたのですが、実際、どれがどのくらいメモリを消費するのか分からないのです。 >実際にＣ言語で巨大なマップを作ろう！ と考えたときに、プログラミング初心者の私がチャレンジするのはどれが妥当でしょうか？ メモリ不足で怒られる(エラー発生する)までは、 贅沢にメモリを使用する方法がプログラム記述を単純化できるので楽だと思います。 小細工を考えるのは、性能問題(動作速度やメモリ消費量)が生じからで良いのです！(富豪プログラミング) 富豪的プログラミング http://www.mii.kurume-u.ac.jp/~smoto/lab/Diary/0 … 但し、無駄な処理はしないように… http://satoshi.blogs.com/life/2009/11/rails_prog …
>v6.0を追加した場合、それ以外のバージョンは除外すべきです。 ちょっと補足を。 v6.0が特別というわけではなく、使うバージョンを決めたのならそれ以外のバージョンは除外すべきということです。
1 Xcodeで、Single View Application で、プロジェクト生成 2 main.storyboardのなかにあるViewControllerを消去してすっからかんにする 3 file list で、ViewController.h ,ViewController.mを消去する 4 main.storyboardに、TableViewControllerを右下のライブラリからひっぱてきて、追加する 5 これのTableViewControllerの上に同じく、Toolbar をいれこむ。 6 Toolbarのなかに、つくりつけのBarButtonがあるが、これがみぎはしになるように、BarButtonの左に Fixed Space bar Button をいれる 7 Bar Button を＋イメージなりAddなりにする 8 File -> New -> Object-C Class で、MainTableViewControllerというのをUITableViewのサブクラスで生成 9 main.storyboardのtableViewControllerのクラスを　MainTableViewControllerにする 10 storyboard画面で、このTableViewControllerを選択した状態で、attribute で、Is initial View Controllerにチェックをいれる 11 このTableViewControllerのdatasourceとdelegateを実装する 12 上と同じようなやり方で、コンテント登録用のtabkeViewControllerを追加。AddContentViewControllerとする 13 AddContentViewControllerにて、ツールバーを設置して、cancelとdoneのボタンをつくる 14 cancelでは、抜けるだけの処理。doneでは、抜ける前に、コンテントリストを更新してから抜ける 15 MainTableViewControllerのviewWillAppear で、tableview に、reloadをかける 16 電卓のViewController を作る 17 電卓のViewControllerとMainTableViewControllerをcontrolを押しながらマウスでドラッグして結び、segueを作る.segueのタイプを聞かれるので、modal。このsegueの名前をtoCaculator とする 18 MainTableViewControllerのdelegate処理で、電卓が押された時に、performSegueでさきのtoCalculatorのsegueを呼ぶ。
相当古いバージョンを除けば、デフォルトでUTF-8を使うことになります。 もちろん、ソースファイルはUTF-8で作成する必要があります。 UTF-8以外でソースファイルを書いて実行時にはUTF-8にするのであれば、-fexec-charset=utf-8を指定するとよいでしょう。 あるいは、-std=c++11または-std=gnu++11を指定するのであれば、文字列リテラルの前にu8を付ければOKです（例： u8"文字列"）。
プログラム以外の部分は大丈夫でしょうか? 例えば、弾除けシューティングを作るとしたら ・敵、敵弾をどう管理するのがいいだろうか ・「当った」って判定はどうしたらいいだろうか とかって、考えたことありますか? プログラミング言語の本は多いですが、 こういう理論についてのものはそんなには無いです。
もう少し細かく言っておくと、 エラーメッセージに対応しているコマンドはまず間違いなくバッチファイル最後のDELコマンドであり、 メッセージが示しているのは「make結果として生成されるはずのELFファイルが存在していない」ということで、それは即ち何らかの理由でmakeが失敗している ってことです。 じゃあ何らかって何よ、というのはmake自体の出力を見なければわかりません。
string CreationTime2 = fi.CreationTime.ToShortDateString(); でいいのでは。
1804289383 だった。
1. 証明書に加えて、 暗号鍵(漏洩したら大変キケン)を安全に管理する必要があるため、 WindowsOSであれば、CryptoAPIを使うのが一般的ではないでしょうか? データベースやファイルといった情報格納方式の問題ではなく、 機密情報の保全方式の問題だと考えます。 2. 独自ソフト以外でも読めるようにする要件がなければ、 特に制約はないのでは？ 逆に既存メールソフトで読めるようにするには、 各既存メールソフトでの検証が必須かと思います。 この場合、プラグイン方式で機能拡張する/しないも 一つの判断ポイントになるでしょう。
>もしくはキャッシュそのものを無効にすれば常に更新されたFTP内容が読み込まれるものと思いますが、その方法がわかりません。 INTERNET_FLAG_DONT_CACHE ですかね？ CFtpConnectionのインスタンスをどうしているのか不明ですが……。
if文がどの程度足を引っ張るか興味があったので、計算時間を測ってみました。 質問欄のプログラム、ただし、外側のループを２０回実行して時間稼ぎをしています。 2.98秒 一番内側のループを外側に出したもの、 11.48秒 改造して共通する計算をできるだけループ外に出したもの 8.3秒 やっぱりif文の影響がかなり大きいようです。 ついでに、 No.1の方法　11.9秒 No.2の方法　8.7秒 ちなみに第一世代のCore i5で2.66GHz 4 coreです。 プログラムが正しいかほとんどチェックしていませんので、結果を保証しかねますのでその点はご了承ください。 結局は元の方法が一番速い結果でした。 accum[index]++がデータの依存関係が有りまくりなのが敗因のようです。 どうしても速くしたいのであれば、ここだけではなく全体のアルゴリズムを見直す必要があるようです。
環境も何もわからないので、具体的にどうこう言えませんが、それを表示できるようなプログラムを作ってみる、というのはどうでしょうか？
if(flag) 　w = M_PI / (double)n; else 　w = -M_PI / (double)n; これと同じ意味です。
>一回の計算時間のスピードも上げたいんですけど。 >パソコンの性能にも問題ありですかね。。 計算だけをさせたいなら、スレッドをマルチコアでぶん回すだけです。 それと表示が絡んでくるので話がややこしくなっているだけですよ。 分けて考えてください。 １．表示はSetTimerで行ってください。最大１秒に６０回までです。 ２．計算はスレッドで行って下さい。途中経過の何らかの手段で表示処理に伝えてください。 （ウィンドウメッセージなど）
＞ イメージではcountが0の時だけMoveToで動かし、それ以降は座標(200,200)から横に線を引いていきたいのですが。 ReleaseDC後もカレント座標が保持されていると考えるから、そのような処理にしたのでしょうが、そんなことは保障されていません。 また、OnTimerで描画すると、ダイアログの上に別のウィンドウが重なったりすると、表示が消えてしまいますよ。表示はOnPaintで行うべきです。表示に必要なデータの作成と再描画の指示だけをOnTimerで行いましょう。 そのほかにも、 ＞ CEdit *edit = (CEdit*)GetDlgItem(IDC_EDIT1); ＞ edit->GetWindowText(str); これはGetDlgItemText関数1つでできます。 ＞ sprintf(buf,"%lf",x); doubleの場合の書式は%fです。scanf系関数の場合は、floatとdoubleの違いを示すためにlが必要ですが、printf系関数では、引数にfloatを渡してもdoubleに変換されるので、どちらも%fです。
HTMLやCSSなどはそれらのサイトのフロントエンド、つまり見た目部分を作るのに使われています。 なので、それらの学習は後回しでもよいでしょう。 見た目などあとからどうにでもできますから。 JavaScript系の言語(CoffeeScriptやTypeScriptなどでもOK)はブラウザ上で動作するプログラムの記述に必須です。 なので、これらの言語は押さえておく必要があります。 JavaやRubyといったサーバ側のプログラムを記述するプログラミング言語も必要でしょう。 最近はWebアプリを開発するためのフレームワークと呼ばれる便利なものがあるので、それらもあわせて勉強しておくと良いです。 Rubyであれば、Ruby on Rails というフレームワークが有名です。 あと、それらのサイトを作るためにはデータベース関係の知識も必要でしょう。 SQLやActiveRecordといったキーワードで検索してみると良いかと思います。
.NETを使ったり、Win32APIだったり、ＭＦＣを使ったり結構デタラメなんですよね。 本当にＣ++を使えるのかが疑問ですが、 「Program Tips」 http://www.crimson-systems.com/tips/t065.htm これみて分からないなら難しいでしょう。
DateTime dt = Datetime.Perse(T_DATATABLE.Rows[0]["Date"].ToString()); では？
ようするにこんな感じのことをやってます? static int aStaticValue; void f() { /* aStaticValue を操作する */ } void g() { /* aStaticValue を操作する */ } /* …（中略）… */ /* …（どこかの関数の中）… */ f(); g(); /* f(), g() のどちらもここ以外からは呼ばれない */ だとしたら、こうしてみてはいかがでしょうか。 void h() { int aValue; f1(&aValue); g1(&aValue); } void f1(int *aValue) { /* f()の aStaticValue への操作を *aValue に変えた内容 */ } void g1(int *aValue) { /* g()の aStaticValue への操作を *aValue に変えた内容 */ } /* …（中略）… */ /* …（どこかの関数の中）… */ h(); それとも、何らかの理由で上記でいうf(), g()の引数を変えることはできないのでしょうか? （実はf(), g()がイベントのコールバック関数なので引数が決まっているとか）
char buf[10]; sprintf(buf,"%d",a); TextOut(hdc,100,50,buf,strlen(buf); じゃないんですかね？ ユニコード文字セットを～とかの場合は必要に応じて読み替えて下さい。 参考URL：http://www.kumei.ne.jp/c_lang/sdk/sdk_05.htm
どのようなデータをどのように表示したいのか説明してくれたほうが答えやすいかと思います。 たとえばglut等では無理ですが、大抵のGUIフレームワークであれば、2つの画面やビューを表示する ことは簡単なので、それをやるだけ、という感じです。 C++のGUIフレームワークならQtがはやっていると思います。
コンパイルエラーが出たのなら、それを報告してください。 で、 ans2 = a*;8 ここがマチガイ。
「いま使われている」ってどういう意味? 「今からプログラムを作るならどっちを使うか」ということについては, あなたは既に調べ方を知っているはず.
これらは、疑似乱数を生成するもので、 シミュレーション等のプログラミングでは使えないことがあります。 疑似乱数かどうかの見分け方は、 二系列で発生させたとき、二系列で集計した分散が個々の系列で集計した分散より 小さくなるときが疑似乱数です。 通常のプログラミングでこの性質が問題になることは、まずありませんので、 ご安心を。 ひとくち知識でした。
[0,n]の一様乱数があったら、1/nすれば [0,1]の一様乱数になります。 rand()の戻り値はint型,RAND_MAXも整数なので、単純にrand()/RAND_MAXでは「ほとんど0、ごくまれに1」という乱数になってしまうので注意。 コンパイラ,OS,使用するライブラリによっては、rand()以外の乱数発生関数が使える場合もあります。 ただ、rand()と同様、[0,n]の一様乱数(整数)を返すものが多いです。よって、[0,1]一様乱数に変換する必要があります。 あと、細かいことかもしれませんが、 rand()はコマンドではなく「関数」です。
ここの仕様上、スペースでの桁そろえが難しいので、具体的にどことどころどう揃えたいのかがわかりません。 数値を出力している箇所 > fprintf(outputfile,"%3d",slottime);//スロット回数表示 > fprintf(outputfile,"%3d",M[i]); で桁数を調節したり、調整用スペースも出力したりすればいいのでは? %3dの3の意味はわかってますよね? あと、fprintfはコマンドではく関数です。 "%d"等のprintf系の引数に使われる文字列は「書式(format)」と呼ばれてます。%で始まる部分は「書式指定子」と呼ばれています。いろんなことができますので、printfのマニュアルの書式の欄を確認してください。 「シミュレーション」をどの程度の精度で求めようとしていますか? rand()に使われているアルゴリズムは厳密なシミュレーションには不向きです(特定のビットに注目すると単周期の繰り返しになっている。ある値aが出た後に出る値bには、一様乱数とは言えないくらいの偏りがある) 参考URL：http://www001.upp.so-net.ne.jp/isaku/rand.html
イベント・ドリブンという概念が理解されていない様です。 少なくとも表示させるためにはイベントを抜けないと行けません。 つまり１カウントアップする度にClickから抜けないといけないです。 これだと目的の動作はしないので、タイマイベントなどでカウントアップと表示させるとして、それを呼び出すトリガ処理をクリック処理に書かないといけません。 あとＣ++やＣ++／ＣＬＩと言う言語は理解されたのでしょうか？
>否定されるだけでは解決になりません #1の方は否定してるわけではないと思いますが。 http://oshiete.goo.ne.jp/qa/8238837.html で私が注意したように「警告をその場しのぎで安易な対処しないように」と注意されてるだけで。 質問文読んだ感じでも #pragma warning(disable: 4793) でしのげてたら、それで済ませてしまいそうですし。 ちなみに私は具体的な対処方法は存じません。 ネイティブコードとマネージドコードの混在はできれば避けたいですし。 なんとなくなら、ネイティブコードでラップ関数作ってPInvoke使うのかなぁと思ってますが。
たくさんの方が回答されていますが、私も丁寧に解説したいと思います。 　まず、文字列は文字の配列です。また、文字はchar型ですから、浮動小数点単精度実数型のfloatに代入すると、文字ではなくて数値としてfloatに代入されてしまいます。(これを暗黙の型変換といいます。) 　最初に考えなければいけないのは、どのようなアルゴリズムを組めば動くかです。型や関数を考えるのは二の次です。今回の場合は次のようになります。 1. ファイル終端(eof)かどうか確認する。 2. 1文字ファイルから取ってくる。 3. その文字が'a'ならば出力に書き出す。 4. 1へ戻る 　そして、これを少しプログラミング言語っぽい言語へ頭のなかで置き換えましょう。 ----- while(ファイル終端じゃない){ c = 1文字取得 if(cは'a'であるか) cを出力 } ----- 　最後に、それに対応するC言語を書きます。 ---- #include <stdio.h> int main(void) { char c; FILE *fp = fopen("test.txt", "r"); if(fp == NULL) { printf("ファイルを開くことが出来ませんでした.\n"); return -1; } while((c = getc(fp)) != EOF){ if(c == 'a') putchar(c); } fclose(fp); return 0; } ---- 0. main関数はこのように書くのがいいみたいですが、そこら辺はコンパイラがよろしくやってくれるはずなので気にしなくていいかもしれませんが一応。 1. 1文字だけ記憶しなければいけないので、`char c;`とします。 2. `int x;`は、配列を使用しないので必要ありません。使用する場合も、配列のインデックスを表す文字は`i`や`idx`等使用すると、他人が見てもわかりやすいソースコードとなります。 3. getcの仕様を見ると、ファイル終端までたどり着くと返り値がEOFになるので、(c = getc(fp)) != EOFはそれを利用しています。 4. 文字リテラルは'a'です。
そう, それが原因. だから, このエラーメッセージはある意味正しい. なぜ書こうという気になったのかはさっぱりわからんが, そんなのは書いちゃいけない.
WinSock2.0プログラミングの373ページ それから、 １０，１１，１２章 が参考になるかもしれません。 ソフトバンクパブリッシング　発行
全部自分でコードを書かないと出来ないですね。 ・マウスの画面上の座標は得られます。 ・クリックしたかも得られます。 この情報から、画像の上にマウスが有るか判断してクリックされたら画像をクリックしたものとして処理すればよい訳です。 ただ、マウスで遊ぶゲームを作らない場合はキーボードだけで操作できたほうが良いと思います。
ぶっちゃけた話私には答える能力はないのですが (＜「だったら書くな」という意見もあろうが), それはさておき. まず, あなたのプログラムでは「複数のクライアントのうち 1つがある物体を動かしたら, サーバがクライアントに通知することにより全てのクライアントでその動きをする」ということでいいですか? もしそうだとしたら, 「複数のクライアントが同じ物体を同時に動かす」ときにどのような動作を期待しているのですか? 単純に, クライアント側で「サーバからの移動情報があったら強制的に操作をキャンセルする」のではダメなのですか?
C言語には入出力の概念がないのでコードの書きようがありません。 質問するのならOS,コンパイラなどの処理系やH/Wを明らかにしなくてはなりません。 それに一般的にはマウスには動力がないので特定の座標に移動させることは出来ません。 移動できるのはポインタです。
今晩は。 トランジスタを６つ使ったドライブ部の回路が示されてません。 それから、ドライブ回路の電圧、更にブラシレスモータの各巻き線のインダクタンスと抵抗値も示されてません。これらについて示して頂ければより具体的なアドバイスが可能です。 とりあえず、こちらで適当にこれらのパラメータを設定した上で2種類の回路とシミュレーション波形を下記にアップしましたので確認ください。 　尚、信号源V1～V6はマイコンの出力ポート（CMOSタイプ）になります。 a）エミッタ出力タイプのドライバへの応用回路 http://yahoo.jp/box/cvFgCr b）エミッタ出力タイプのドライバへの応用回路の波形 http://yahoo.jp/box/2ErB11 c）コレクタ出力タイプのドライバへの応用回路 http://yahoo.jp/box/sUjCtp d）コレクタ出力タイプのドライバへの応用回路の波形 http://yahoo.jp/box/zrtJFC
一番疑われるのは，高DPIへの未対応，ということです。 タブレットは高DPIであることが多いと思われるので。 e.g.) Surface Proは150%でスケーリングされます http://d.hatena.ne.jp/Yamaki/20130306/1362547122 元々，Windows 7の コントロールパネル - デスクトップのカスタマイズ - ディスプレイ で，100%以外の値を指定した場合に，崩れるということはないでしょうか。 コントロールをデザイナでのみ配置している場合や， コントロールの追加時にPanel類とDockやAnchorプロパティなどを使ってのみ位置を決めている場合はよいのですが， それ以外の場合はDPIを考慮した配置や描画が必要になります。
環境変数パスを設定してないんじゃないですかね。
ループしているならそのループ内、タイマーならタイマーイベント内、スレッドならスレッド内で、 チェックボックスの状態がOFFなら処理を終了もしくは一時停止させればいいのでは。 数分かかる特定の命令が走行した際に、そいつを強制停止させることはできませんよ。 1回の実行で、いくつかの処理があり、総所要が数分ということなら、中止するタイミングを それぞれの処理が走行する前に設けてあげればいいでしょう。
#include <stdio.h> int main() { int a, b, c, d, n; /* b, c, n への初期値設定 */ a = b; d = 1; while (c > a) { a = a * n; d = d + 1; } return 0; }
> 今までint型でも問題なく取り込めていたのですが…。 そのときは scanf("%d", &n ) ; と言った具合に & が付いてなかったですか? 学習を進めていくと必ず「ポインタ」というものが出てくるはずです。 詳細はその項目で。 なお、多くの人がC言語を挫折する理由が「ポインタが理解できない」ことです。 > 僕が使用しているのは純正のCではなくC++で、コンパイラはbcc32 この程度の内容なら、CとC++とで違いはありません。
コンピュータで使われている乱数は、実際には「疑似乱数」と言って、一見バラバラで乱数と言ってもいい性質を持っていますが、実際には計算によって求められたものです。 それまでの値に、なんらかの計算をした結果を、「次の乱数」として使います。(Nextというメソッド名もそこに由来) このとき、一番最初の状態になるものを「種(シード,seed)」と言います。 「前の状態から新しい乱数を計算する」ということから「種が同じなら、乱数列も同じになる」という性質があります。 バラバラにするための常套手段として、種に現在時刻から求めた値を使うことで、実行時刻が変化すれば値が変わるようにする、というのがあります。ただ、無限に細かい時刻をそのままコンピュータでは扱えないので、適当な単位(例えば、秒単位)になってしまい、単位時間以内(例えば、秒単位なら1秒以内)なら、同じ乱数列になってしまう、という問題があります。 Random.Random()のマニュアルを読むと http://msdn.microsoft.com/ja-jp/library/h343ddh9 … 「既定のシード値はシステム時計から取得されるため、その分解能は有限です。 その結果、既定のコンストラクターを呼び出すことによって連続で作成される、異なる Random オブジェクトの既定のシード値は同一であるため、同一の乱数セットが生成されます。」 と、明記されています。 public static string ランダム(int 桁数) を2回呼び出していますが、その度に、Random Random = new System.Random();で新しい System.Randomオブジェクトを生成しています。 間にいくつかの処理が入っているとは言え、非常に短時間で終わるものなので、この「連続で作成される、異なる Random オブジェクト」となっている、と考えてよいでしょう。 対処法は、マニュアルにも書いてあります
あんまり確かな記憶じゃないんだけど, ある行が空白も何もおかずいきなり { から始まっていたらそこを関数定義の開始とみなす (逆に, 構文上は関数定義の開始であっても行頭になければ無視する) というプログラムがあったような気がする. オリジナルの ctags がそうだったっけ?
こんな感じなのはどうですかね。 #include <stdio.h> #include <stdlib.h> #include <math.h> #include <time.h> int main() { // 任意の番号 int num; // くじの番号 int num_rand; // 乱数の初期化 srand( ( unsigned )time( NULL ) ); // 入力促進分 printf( "Please Input any Number(1 to 1000) >> " ); // 入力 scanf( "%d", &num ); // くじ引き num_rand = rand()%1000 + 1; // 判定 if( num == num_rand ) printf( "Big Lucky!!\n" ); else if( exp( num - num_rand ) < 10 ) printf( "Lucky\n" ); else if( exp( num - num_rand ) < 100 ) printf( "Small Lucky\n" ); else if( exp( num - num_rand ) < 500 ) printf( "No Lucky\n" ); else printf( "Un Lucky!!\n" ); return 0; }
同じような質問があったので。 http://qanda.rakuten.ne.jp/qa6831652.html
ロケールの設定が必要です。 forの直前に std::wcout.imbue(std::locale("Japanese", std::locale::ctype)); と１行入れるとちゃんと動くようになると思います。
次のサイトから色々な言語関係の情報が辿れます。 http://groups.engin.umd.umich.edu/CIS/course.des … ==> http://www.lysator.liu.se/c/bwk-tutor.html Programming in C: A Tutorial Brian W. Kernighan (内容は少し古いようですが) 或いは次等から辿ってください。 http://en.wikipedia.org/wiki/C_language ==> http://en.wikipedia.org/wiki/The_C_Programming_L … ==> http://freecomputerbooks.com/The-C-Programming-L … この本は日本語にも訳されており、C言語のスタンダードと言っても良いものです。 次のサイトも参照下さい。 http://www.mindviewinc.com/Index.php 　Thinking in C (Java, C++等も) なお英語を勉強されるのであれば次がお勧めです。 数多くのサイトが辿れます。 http://english.chakin.com/ 英語のゆずりん (C言語は日本語のサイトで能率よく習得し、英語は別途これらのサイトを参考に考える方が良いのかも知れません) なお数学は多くの工学理学系授業の基礎ですが、こちらも大事ではないでしょうか。 次を参照して下さい。 http://okwave.jp/qa/q8043298.html 特に次等を参照下さい。 http://www.geocities.co.jp/Technopolis/5112/　落ちこぼれ理工系学生の数学 C.R.ワイリー　工業数学 長沼伸一郎　　物理数学の直観的方法
変数のサイズを知る～sizeof演算子 http://www.grapecity.com/tools/support/powernews … ＞C#でOutOfMemoryExceptionが発生しているのですが、 　具体的なソースコードが分かれば誰か？が具体的な回答を投稿するかも？ 参考URL：http://www.grapecity.com/tools/support/powernews …
> …は、同じところを指します。 > ただし、それぞれの型が違います。 No.2の回答者です，ご指摘ありがとうございます，勉強になりました。
以下のリンクの下の方によると、リソースIDとして使用できる値の範囲があるようです。それから外れた値を指定していませんか？ http://msdn.microsoft.com/ja-jp/library/t2zechd4(v=vs.90).aspx
今後対応されることはないでしょう。 C++11で廃止されましたので。 INCITS/ISO/IEC 14882:2011 Programming Lnaguage -- C++ C Compatibility / C.2 C++ and ISO C++ 2003 / C.2.6 Clause 14: templates > 14.1 > Change: Remove export > Rationale: No implementation consensus. > Effect on original feature: A valid C++ 2003 declaration containing export is ill-formed in this International Standard. 削除の根拠(Rationale)が，「ほぼ実装がないから」というのもすごいですが……。 export対応というと，Comeau C/C++あたりしか……。 http://www.comeaucomputing.com/
　あまり有力な情報が乏しいのですが、ネット情報ではこういった感じでしょうか。 ＞USBカメラをC#で使おう ＞http://mobiquitous.com/programming/usbcamera.html 　サンプルコードをダウンロードして解析するしか。 　これ以外だと、ａｍｃａｐくらいでしょうか。 ＞【DirectShow】SDKサンプルプログラムAmCapのビルド方法 ＞http://imagingsolution.blog107.fc2.com/blog-entr … 参考URL：http://mobiquitous.com/programming/usbcamera.html
あなたがやりたいであろうことを、いちからプログラムしてみました。あなたの書いたコードを添削したわけではありません。 ViewController.h ------------ #import <UIKit/UIKit.h> @interface ViewController : UIViewController <UIPickerViewDelegate, UIPickerViewDataSource> @end ViewController.m ------------ #import "ViewController.h" @interface ViewController () @property (retain, nonatomic) IBOutlet UITextView *myTextView; @end @implementation ViewController { NSMutableArray *datas; } - (void)viewDidLoad { [super viewDidLoad]; datas = [[NSMutableArray alloc] initWithObjects: @"ABC", @"DEF", @"GHI", @"JKL", nil]; UIPickerView *pickerView = [[UIPickerView alloc] initWithFrame: CGRectMake(0.0, 0.0, 320.0, 200.0)]; pickerView.showsSelectionIndicator = YES; pickerView.dataSource = self; pickerView.delegate = self; UIToolbar *toolBar = [[UIToolbar alloc] initWithFrame: CGRectMake(0.0, 0.0, 320.0, 42.0)]; UIBarButtonItem *buttonItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem: UIBarButtonSystemItemDone target: self action: @selector(addString:)]; toolBar.items = [NSArray arrayWithObject: buttonItem]; _myTextView.inputView = pickerView; _myTextView.inputAccessoryView = toolBar; [toolBar release]; [buttonItem release]; [pickerView release]; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } - (void)dealloc { [_myTextView release]; [datas release]; [super dealloc]; } // PickerView Delegates and Datasources - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView { return 1; } - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { return datas.count; } - (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { return [datas objectAtIndex:row]; } // Barbutton Item Action - (void)addString: (id)sender { UIPickerView *pickerView = (UIPickerView *)(_myTextView.inputView); _myTextView.text = [_myTextView.text stringByReplacingCharactersInRange: [_myTextView selectedRange] withString: [datas objectAtIndex: [pickerView selectedRowInComponent: 0]]]; [_myTextView resignFirstResponder]; } @end あなたのコードといちばん大きな違いは、アクセサリービューを設けて、そこに入力（Done）ボタンを付けたことです。ピッカーを回して、いちどで入力したいアイテムで止められるわけではないので、ピッカーを回して、Doneボタンで入力というインターフェイスにしました。 そのDoneボタンのアクションメソッドの中にピッカービューを隠すメソッド（[_myTextView resignFirstResponder];）を書いています。 あなたのコードと比較しながら、目を通してもらえれば、幸いです。
>では今回に対して言えばどういった対処を取るべきだといわれるのでしょうか？ #3の方がすでに書かれていますが、::SysAllocString()はOLECHARの文字列を要求してるのですからOLECHARの文字列に変換すればいいだけです。 これは::SysAllocString()の仕様を考えればおのずとわかる事だと思いますが。 >そこで固定文字列などを渡したい場合どういった方法とればいいのか >など疑問が満載状態になってしまいます 使用する関数やAPIの仕様から判断してください。 >ベースコードSDKのサンプルなどから持ってきてそういった状態なのですが >サンプルも文字セット気にしないで記載されているということなのでしょうか？ 私にそのサンプルの事をたずねられても推測しかできませんが(私が書いたわけじゃないし)。 文字コード変換のサンプルでもない限り、そのサンプルが書かれた当時のそのプラットフォームで標準的に使われていた文字コードで書かれてるというだけじゃないですか。
根本的な解決策とかいった話ではありません 日本語OS環境で作成したアプリケーションを英語OS上で動かすと 画面れ0アウトが崩れるといった話でしょうか？ XPでの話ですが同様の経験をしたことがあります（VC6＋XP) Win7ではエディションで多言語対応が考慮されてるので その時の話とまた違うかもしれませんが 英語OS上で日本語フォント組み込んだだけでもレイアウトに変化が発生が発生しました さらに 開発環境を両方のOS間で移動してリソースを新規で追加させたりすると 収集つかなくなりました フォント以外にもリソースとして日本語部分が残ったりそれ変えても中途半端だったり で手に負えなくなりました 日本語XP　－＞ 英語XP 　　　　　－＞　英語XP 日本語フォントインストール環境 　　　　　　　　　　　一度インストール後削除してもその時は変化なし 　　　　　ー＞　英語Win7 Pro 　　　　いずれのパターンでも変化がありすべて微妙に状態が異なった 結局私はリソース作成するのはどちらかの環境に統一させ作成したリソースを 両環境で表示確認することで作業してました （要は必要に応じて再レイアウトしなおす羽目になった） メッセージ類は初めから英語記載だったのでそれに関しての問題はありませんでしたが レイアウトの変更がそれなりにめんどくさかった記憶があります 方法があるのであれば個人的にも非常に興味があるので他の方の回答を 期待しています
Cはしばらく触っていないので、もっといい方法があるかもしれませんが、 strtol関数とかどうでしょう？ http://www.c-tipsref.com/reference/stdlib/strtol …
いくらなんでも、 > struct Data { > /* 半径rと面積areaをdoubleで宣言 */ > }; これは自分で書こうよ。（ほかのところもそのレベルだけど）
ソースコードを公開すれば、いろいろなアドバイスがもらえますよ。 私はかなり助けてもらえました。
VisualStudioのIDEは2010ではWPFベースのものになってるのでMFCではないですね。 以下が参考になるんではないでしょうか http://www.codeproject.com/Articles/18812/WPF-Do … http://www.codeproject.com/Articles/140209/Build … http://www.devexpress.com/Products/NET/Controls/ … http://dobon.net/vb/dotnet/links/dockingwindow.h … 他にも探してみたいのでしたら WPF dock window .NET dock window などで検索してみてください。
具体的にどうやってコンパイルしたのでしょうか? おそらく、リンクするライブラリが足りません。 コマンドラインからなら、 -lOSMesa -lGLU を最後に追加する必要があります。 この場合のリンクとはなにか、ライブラリとは何か、は、調べてみてください。 C言語でプログラミングするなら、覚えておくべき事項です。
Understand とかどうでしょね(お高いけど)。 参考URL：http://www.techmatrix.co.jp/quality/understand/i …
>参考書などにＶＣ＋＋ついてませんか　オフラインで使いたいんです オフラインってそういう意味ですか？ 少し大きめな本屋さんに行ってプログラミング入門書のコーナーにでも行って下さい。 ExpressEditionのCD(DVD？)付きの書籍やムック本が売っているでしょう。 http://www.amazon.co.jp/dp/4891005823 http://www.amazon.co.jp/dp/4822294234 とか…。 http://www.amazon.co.jp/dp/4822222640 とかの日経ソフトウェアのムック本やバックナンバーでもCD-ROM(DVD-ROM)付きのものがあります。 2012でもある…かなぁ。 私は http://www.amazon.co.jp/dp/482222273X を買いましたが。(買う前にDL自体はしてありましたけどね。) 2012の場合XPだと動かないのでご注意を。 # そのくせインストールはできた…ような？
とりあえず、AppDelegateの - (BOOL)application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder で、NOを返してみては、どうでしょうか。ログインの破棄までできるかどうかは、わかりませんが。
>確かにそうなんです。でも循環リストを作る時に始めと最後の構造体をHEADとENDとした場合、 >END->NEXT_PTRにはHEADが入っているので無限ループに陥ってしまいます… 循環にする必要があるのかどうかを検討した方がいいんじゃないですかねぇ…。 リスト構造で作ったリングバッファみたいなもんなんでしょうか？ 私ならHEADのアドレスを記憶しておいて回しますね。 int COUNTER(list_t *HEAD) { 　int COUNT; 　list_t *TEMP; 　for(COUNT = 0, TEMP = HEAD;TEMP->NEXT_PTR != HEAD;TEMP = TEMP->NEXT_PTR, COUNT++); 　return COUNT; } こんな感じですかね。 リスト構造作るときは面倒ですが…双方向リストにしておけばHEADの前がENDになるんじゃないですか？ # 関係ありませんが…変数名や関数名を「全て大文字」にするのは個人的にちょっと……。 >どうにか解決しようと調べたりしてるんですが、解決策は特に思いつかず… どういう構造体なのか謎のままなので細かいところは自分で考えて貰うことになりますが…。 構造体の中身だけ書き出し、読み込む時はmalloc()なりでメモリを確保しながら読み込んでリスト構造に追加していく…ってところでしょう。 構造体定義をまるっと書き出すとポインタの問題以外に無駄なデータの書き出しも発生するでしょうしね。 パディングとか、文字列記憶のために固定長の配列があれば'\0'以降のゴミとか。 # うっかりその固定長の領域にパスワードなり記録していたらそれもゴミとして書き出されますよ。 私は固定長のバッファでも文字列長(WORDサイズで書き出しなど)して、その後にそのままベタで書き出し…とかやってますね。 1つのリスト構造の書き出しサイズは一定にならないんでファイル内でシークして…という手は使えなくなりますけど。 # 検索するならどうせメモリにリスト構造で読み込んでから…なのでシークの必要がない。 # どうしてもファイル内でシークが必要ならサイズ情報を拾いながら都度都度シークしていく。 # まぁその場合はリスト構造1つ分のサイズを予め算出して書き出しておきますけどね。
ちょっとおもしろそうなので、やってみました。 四則演算を使わないというふうに勝手に判断して書いてみました。 #define N 31 inline int fn1(int a, int b) { int c=0; int flg=0; int bit=1; for(int i=0;i<N;i++){ int ai=a & bit; int bi=b & bit; flg = ((ai & bi) | (ai & flg) | (bi & flg)); flg<<=1; c|=flg; bit<<=1; } return c; } ついでに計算時間も計りました。（10000000回ループを回したときの時間です） 上のプログラム　0m0.653s No.4のプログラム　0m0.798s 質問欄のプログラム　0m2.327s 一般的な高速化の方法ですが、 1) if文などの条件判断をLoopの中から極力排除する。(パイプラインの関係) 2) テーブル引きを、可能なら関数などレジスタで計算できるようにする。 3) ここでは使っていませんが、ループのデータ依存関係を排除する　（SSEなどベクトル演算ができる） などです。測定プログラムを書いておきます。 乱数で数値を発生させています。またsumをちょっと余分につけています。結果をその都度出力していたら、出力の時間を計っているようになるので、それとコンパイラによっては最適化で計算を省略することを防ぐためです。 ちなみに、randやsumの関数の計算と関係ない以部分は0m0.182sです。 #include <stdio.h> #include <stdlib.h> int main() { int a, b, c; int sum=0; for(int j=0; j<10000000; j++){ a=rand()/4; b=rand()/4; c=fn2(a, b); sum=sum+c; } printf("%d\n",sum); }
COM関連はよくわかりませんが(私自身使う事ないので)、SysFreeStringの呼び出しはおそらく必要です。 >出力Windowにはメモリリークは出ていないように感じます その出力で検知されているメモリリークはmallocやnewなどを用いたものの場合だと思います。 >仮に今回は必要ないにしても関数自体が存在するということは必要性はあると思うのですがどういったときにコールする必要があるのでしょう この辺が参考になるのではないでしょうか。 http://msdn.microsoft.com/ja-jp/library/vstudio/ …
まず、何の言語で作るのかわからないし、この程度のものをどこから教えればいいのかがわからないです。 普通に一行ずつ読み取って、変数に代入して計算する。 もしくは全行読み取って、改行文字で分割して変数に入れて計算。 もう少し何を聞きたいのか、どこまでできているのかを記載いただければ もう少しましな答えができるのですが。
>Form1_DragDrop()の中で実行しています。 であれば……「チェックボックスをクリックする」=>「チェックボックスの状態が変化する」=>「変化した状態を描画する」の一連の処理は終わっているハズなので…現在の状態が取得できているはずだと思われますが…。 # 私が試した「ボタンを押して現在の状態を取得」と同じようなモノでしょう。 # ファイルのドロップでそのDataGridViewの内容を変更していなければ…ですが。 >実は、もう一つ不可解なことがありました。それは、実行中にある列にチェックをいれると、別の列のチェックが消えたり、また、ある列のチェックを外すと別の列にチェックが現れたりする現象です。 DataGridViewに対して何かしら操作を行っているところがあるのではないでしょうか？ DataSourceにバインドしている場合はそちらのデータを操作した場合でも反映された…ような。 # C#でしたけどね。 C++/CLIでポインタとか使えるのか不明ですが、ふつ～のC/C++だとポインタの扱い間違えると不可解な挙動することはありますね。
まずは、cv::Matを中心としたC++で作るのか、CvArr等を中心としたC言語で作るのか、決めましょう。 C++を使うなら、C用のcvMomentsではなく、C++用のcv::momentsを使いましょう。 http://opencv.jp/opencv-2svn/cpp/structural_anal … cvMomentsを使いたいのなら、最初からcv::Matではなく、IPLImage等を使いましょう。 一応、キャストで変換はできますが、破棄しないように注意が必要です。 http://opencv.jp/opencv-2svn/cpp/core_basic_stru …
私もこの教えてグーで助けてもらいながら、メールソフトを作っています。 C++　で作るなら、メールの自動返信ソフトも作れると思います。 他の言語は使ったことが無いので分かりません。 わたしは、MFC　を使っています。 頑張ってください。
さらに追加すると read_line_address = &read_line; は両辺の型があっていない. それと, fclose(fp); if(fp == NULL) { printf("file close error\n"); exit(EXIT_FAILURE); } の if は何も役に立たない (ここに来たとき fp の値が NULL であることはあり得ないので).
バイト内のビット割付ってそもそもプログラム上で意味ないですよ。 バイトオーダーに意味があるのは同じデータに対してバイト配列と整数ワードという2種類のアクセス方法があるからこそであって、バイトより細かい単位でのアクセス手段がなければビット割付に意味はない。 バイトオーダーはネットワークでバイト列をどう解釈するかから出てきた問題ですしね。 意味を付けるとするとビットフィールドがどの順に並ぶかですかね。
Shownイベントの最初に以下のコードを挿入してください。 　if(this.DesignMode) return; http://h-pg.blogspot.jp/2012/06/form-inherits-de …
コマンド名だけで指定した場合、環境変数PATHで指定されたディレクトリにあるファイルを探します。 ここまではWindowsと同じです。 違う点は「カレントディレクトリは(PATHに明示しない限り)対象外」ということ。 対応策は ○ 絶対パス、または相対パス付きで実行する。この場合は、指定されたファイルを実行します。 ./a.out # 相対パス: カレントディレクトリのa.outを実行する bin/a.out # 相対パスの例 /home/user/desktop/a.out # 絶対パスの例 ○ 環境変数PATHに . (カレントディレクトリ)を含める ただし、セキュリティ等の関係で、推奨されていません。
> 「式ベースのフィルターは、文字列ベースのフィルターよりもはるかに強力で複雑なフィルター機能を提供します。 > 文字列ベースのフィルターと式ベースのフィルターは、相互に排他的です。 > DataView をクエリから作成した後に文字列ベースの RowFilter を設定した場合、 > クエリから推論される式ベースのフィルターはクリアされます。」 ここで言う「クエリ」とは#3の方が使っておられる、LINQを使った抽出方法のことを指します。 RowFilterを使った抽出(#1, #2の方法)とクエリを使った抽出(#3の方法)は両立できませんよー、ということを述べています。 > A AND B > B AND A > (Aは文字列型フィールド、Bはdouble型フィールド) > 両方とも、Aの条件に合うレコードが全部書かれてしまう状況です。 AとBの両方の条件に合うレコードが出てくるはずです。 Bの条件に合わないレコードはでていますか？ 望んだ結果が得られないなら、一度AccessでSQLを書いて抽出条件を再度確認した方がいいかもしれません。 > r["double型フィールド"] >= double型変数 r["フィールド名"]はフィールドの型によらずobject型になりますので、 double型にキャストしてください。 > r["文字列型フィールド"] = '文字列型変数' r["文字列型フィールド"] == 文字列型変数 としてください。
イベントハンドラの使い方について勉強して欲しいところですが……。 http://www.atmarkit.co.jp/fdotnet/csharp_abc/csh … http://www.ipentec.com/document/document.aspx?pa … に書かれている方法でSystem.Windows.Mediaが使える状態になったとして、 MediaPlayerクラスのインスタンスを作成した時にイベントハンドラを登録します。 　mp = new MediaPlayer(); 　mp.MediaEnded += new EventHandler(mp_MediaEnded); こんな感じですかね。 VisualStudioを使っているのならば"+="まで入力した所でTABキーによる補完を実行すると、 イベントハンドラのメソッド(のひな形)まで作成してくれます。 # TABキー2回押して下さい。(VisualStudio C# 2010 ExpressEditionで確認。) 再生が終了するとMediaEnded イベントが発生し、設定されたイベントハンドラがコールされます。 コールされたイベントハンドラからフォームのコントロールってそのまま操作出来なかったかと思われますが…。 # SerialPortのDataReceivedイベントで、デリゲートとInvokeでデータ引き渡していた記憶が。 # キーワードで検索して下さいな。 # http://hippos-lab.com/blog/node/337 とか参考になりますかねぇ…。
>他のところばかり探していて見つかりませんでした。 >szResponse >を大きくしてみます。 回答した時に想定したパターンについては…もう忘れてしまいましたが……。 ・nBytesReadがsizeof(szResponse)より大きい場合にエラーになる。 ・nLenが不正な値になる場合がある。 というパターンがありますかね。 # たぶん回答した時のは上側の方かと思われますが…。 >if (strlen(cp)) が偽だった場合にnLenがどうなるか…についてはちゃんと調べてありますか？
オーバーライドしたのはFormクラスのOnPaint()メソッドですか？ 再描画不要な場合ならば走行しませんが。 また、Form.ActiveControlプロパティによって、現在アクティブな コントロールを得ることができますから、OnPaint()内でそれを 利用して判定可能と思われます。
違っていたらごめんなさい。 startday.ToString("yyyy/MM/dd") って文字列型だから日付と比較するなら "日付 > #" + startday.ToString("yyyy/MM/dd") + "#" と"#"が必要なのかなぁ～と思ったのですが。。。違うかな？
＞いつ、どのようにしてコマンドラインから指定（書き込む？）のですか？ ＞デバックなしで開始　→　続行するには何かキーを押してください 統合開発環境下で「実行」をする場合、通常なら「実行時引数の指定」が出来るようになっている筈です。 例：Visual Studio 2008の場合 http://housoubu.mizusasi.net/data/other/ot003.html 貴方がお使いの統合開発環境が何か判りませんが、通常、必ず指定出来るようになっています。 なお、統合開発環境を終了して、実行ファイルを直接に起動する場合は、MS-DOSプロンプトで、実行ファイル名に続いてスペースで区切って引数を「手で入力」して指定しないといけません。
質問文に書かれている方法だと1つ調べる毎に、 fopen() 1回 fclose() 1回 fgets() 最悪のケースでpopdata.datに登録されてるメッセージIDの件数分+1回 を呼び出すことになります。 仮にpopdata.datが空の状態で10件の重複のないメッセージIDを調べると fopen() 10回 fclose() 10回 fgets() 55回(1～10の合計) となります。 なので調べたメッセージIDが増えれば増えるほど急激に遅くなるのは当然かと。 早くするには、 ・#1の方のいわれてるようにメモリ上で検索する ・データベース(dbmとか)を使用する ・メッセージIDをファイル名としてファイルを作りその有無で調べる(あまり早くならないかも) などがあるかと思います。 ところで >fputs("\r\n", popdatfp); の \r は必要ですか？ Windowsだと"\r\n"はファイル上では \r\r\n になると思いますが。
>Message ID　はどこでどのようにして決まるのでしょうか？ 「smtp rfc messageid」辺りで検索して下さい。 http://www.emaillab.org/essay/message-id.html とか見つけられるはずです。
他のご回答者様が書かれているとおり、言語なんて所詮道具です。使いこなせなければ意味が無い。 会社に居る現役のプログラマなどは、教科書的な本なんかほとんど読まずに、いきなり実践でたたき上げた様な人ばかりです。 正直、CやC++の文法的なところなどは１ヶ月も適当にやっていればある程度頭に入るので、そこから先は開発環境（VisualStudioやらEclipseやら）の使い方を勉強すべきでしょう。 どんな環境で動くプログラムを打ちたいのか書いてないので明確なことは言えませんが、例えばWindowsで動くアプリを作るのならば、本を買う前にVisualStudioでも手に入れて（マイクロソフトでタダで配っています）、テキストエディタでも作ってみることです。 言語の基礎よりもクラスライブラリの使い方を頭にたたき込む方が、よっぽど大変だと分かると思います。 ちなみに現在ではC++などはLinuxや組み込み系がほとんどで、WindowsならC#などが多くなっています。最終的な目標を立てておかないと、結局回り道をするハメになりかねません（無駄とまでは言いませんが）。
プリンターであればCreateDCするのですから， とりあえずCreateDCした後にGetDeviceCapsにTECHNOLOGY渡してDT_RASPRINTERかどうかを確かめる のが簡単な気がします。 違うのであれば，そのままDeleteDCすることになります。 文字列を直接調べているわけではないですが……。
この関数は再帰を「問題の分割」に使用しています。 例題通り s=6,n=3 とした場合、解くべき問題は [0,1,2,3,4,5,6,7,8,9] から 3 個を取り出した合計が 6 一番最初の再帰によって、この問題は以下の二つに分解されます 0 と [1,2,3,4,5,6,7,8,9] から 2 個を取り出した合計が 6 _ と [1,2,3,4,5,6,7,8,9] から 3 個を取り出した合計が 6 さらに分割されて 0,1 と [2,3,4,5,6,7,8,9] から 1 個を取り出した合計が 6 0,_ と [2,3,4,5,6,7,8,9] から 2 個を取り出した合計が 6 _,1 と [2,3,4,5,6,7,8,9] から 2 個を取り出した合計が 6 _,_ と [2,3,4,5,6,7,8,9] から 3 個を取り出した合計が 6 この様に分割してゆき、分割できなくなるまで再帰を続け、その際に目的を達している(sum==s)ならばカウント(a++)しています。 これによって、すべての組み合わせを探索することができます。 余談ではありますが、このプログラムは大域変数が不用意に使われていて読み辛いです。 以下の様にすれば多少は数学っぽくなり読みやすくなるかと。 int dfs(int i, int sum, int m) { 　if (m==0 && sum==0) return 1; // 条件を満たす組み合わせ 　if (i==10 || m==0) return 0; // 条件を満たさない 　retun dfs(i + 1, sum - i, m-1) + dfs(i + 1, sum, m); // 問題を二つに分割　 } printf("%d\n", dfs(0, s, n));
あのー 遠回りに見えるかも知れませんけど、まずは、C言語/C++の入門書を買って、それを理解してください。 自分の作りたいプログラムを作るのは、その後です。 基礎を理解せずに、応用はできません。 マニュアル見ればすぐわかることだし、fopenのこと知ってたら予想できるものです。
モデムとシリアル回線で接続して、通信速度やビット数(7or8)とパリティ等が合っていて、ATコマンドなどが通信できる状態であれば、着信すれば、 RING という文字列が送られてきます。RING+改行(CRLF) プログラムとしては、 １．ATコマンドでモデムの初期設定（詳細略） ２．1行入力待ち ３．入力したのがRINGか？ ４．違えば何らかの障害 まずは、モデムにターミナルソフト（Teratermとか）で接続して、手動で手順を確認してください。 モデムのATコマンドについては検索すればいくらでも情報はあります。
コンソールを表示したくないのであれば，Windowsアプリケーションとしてプロジェクトを作成し， 通常のWindowsアプリケーションと同じく，WinMainをエントリポイントとしてプログラムを作成します。 あとは，CreateWindow(Ex)等のウィンドウを表示するAPIを呼ばずに処理を続けることで， ウィンドウのないプログラムができあがります。 ---- 背景的な話 ---- リンカオプション：/SUBSYSTEM:Windowsの説明にありますが， このオプションは「プログラムがコンソールを必要としない」ことを意味します。 http://msdn.microsoft.com/ja-jp/library/fcc1zstk … さらに，この設定によって/ENTRYリンカオプションが指定されない場合の既定値が変化します。 http://msdn.microsoft.com/ja-jp/library/f9t8842e …
コメントがまったく無いので、わかりずらいプログラムになってしまっています。 「何をしているか?」を考えてコメントを付けてみてはどうでしょうか。 > //ここでは、計算した結果、どのような値が帰ってくるのでしょうか？ voidですから、戻り値はありませんが、第一引数で指定した配列が変更されます。 どうしてそうなるか理解できない場合は、参考書等でポインタの勉強してください > printf("%d\n",data[cnt-1][0]); 結果らしきものを出力している箇所はここだけです。 ということは ・data[cnt-1][0] が結果ではないだろうか? と予想できます。すると ・配列 data には、もともと入力したデータが入っていたはず ・入力から出力までの間に solve関数を実行している ということから、solve関数で配列dataが書き変わっているのでは?と予想できます。 ○solve関数の動作 実際に、コンピュータになったつもりで、動作を追い掛けてはですか? ・i=0 のとき、 data[0] : a0 data[1] : b0 b1 data[2] : c0 c1 c2 data[i+1][0] += data[i][0]; → data[1][0] += data[0][0] ; → data[1][0] +=a0 data[i+1][i+1] += data[i][i]; → data[1][1] += data[0][0] ; → data[1][1] +=a0 j=1 は j<=iではないので、forループは実行されず 結果 data[0] : a0 data[1] : b0+a0 b1+a0 data[2] : c0 c1 c2 ・i=1のとき data[i+1][0] += data[i][0]; → data[2][0] += data[1][0] ; → data[2][0] +=b0+a0 data[i+1][i+1] += data[i][i]; → data[2][2] += data[1][1] ; → data[2][2] +=b1+a0 j=1 data[i+1][j] += max(data[i][j-1],data[i][j]); →data[2][1] += max(data[1][0],data[1][1]); →data[2][1] += max(b0+a0,b1+a0); 結果 data[0] : a0 data[1] : b0+a0 b1+a0 data[2] : c0+b0+a0 c1+max(b0+a0,b1+a0) c2+b1+a0 ここまで追い掛けたら、solveがどんな方法で結果をだそうとしているのか、わかるのではないでしょうか? 幅が広がっていく部分では、候補は1つしかありません。 あえてやるなら次のようになります。 for(j = 0;j <= i+1;j++) として ・data[i+1][0] += max(data[i][-1],data[i][0]); // ただし、範囲外となる data[i][-1]は0とする ・data[i+1][i+1] += max(data[i][i],data[i][i+1]); // ただし、範囲外となる data[i][i+1]は0とする data[i][i+1]の方は、サイズを大きく取って、予め0にしておく、という方法で対応できます。 しかし、data[i][-1]は先に添字をチェックする必要があります。 それなら、候補が1つしか無い場合は、そのまま計算した方がいいのではないでしょうか。
>noに入る値はどの文字(数値)で決まりますか? >例えば、このプログラムではmain関数のlnの値で決まるのでしょうか? はい、そうです。ncharを呼び出している、呼び出し側の設定している値によって決まります。 つまりnchar(a,b) のbの値です。aは画面に打つ文字です。 何段ですか：で、５を入力すると、lnには５が設定されます。 その後、 for(i=1;i<=ln;i++){ nchar(' ',ln-i); nchar('*',i); putchar('\n'); } の処理が実行されますので、for文の1回目の nchar(' ',ln-i);の呼び出しでは、noはln-iなので5-1=4が設定されます。 つまり、スペースを４個横に並べて打ちます。 次の、nchar('*',i);では、noはiなので1が設定されます。 つまり、'*'を1個打ちます。 for文の２回目の nchar(' ',ln-i);の呼び出しでは、noはln-iなので5-2=3が設定されます。 つまり、スペースを３個横に並べて打ちます。 次の、nchar('*',i);では、noはiなので2が設定されます。 つまり、'*'を2個打ちます。 これをiが５以内の間、繰り返します。
> このようなファイルを先のお答えの方法で行うと大変になります。もっと良い方法があると思われます。 ちょっと自分でツールを作ってプロジェクトファイルを自動生成すれば良いのでは？ >質問の内容を変えました。度々すみませんがこちらは初心者ですので丁寧な説明、ご教授くだされば幸いです。 やろうとしている事自体が初心者向きではないので、初心者を免罪符にしないでください。初心者なら初心者向らしいことをしましょう。
C++/CLI は無視する. そして, いまさらだがこの質問は自分で試せば答が出るはずじゃないか? 親クラスを ParentClass.h/ParentClass.cpp で, それを継承した子クラスを ChildClass.h/ChildClass.cpp に書いたとする. このとき ParentClass.cpp から ParentClass.obj, ChildClass.cpp から ChildClass.obj ができることになるが, 「子クラスの DLL」を作るときに ・ChildClass.obj だけから作る ・ParentClass.obj と ChildClass.ob の両方から作る ことの両方が可能で, このどちらを使うかによって「親クラスの処理を内包する」こともできるし「子クラスの処理だけを持つ」こともできる. どちらにもメリット/デメリットがあるのはわかるよね?
>題意の件、特にc＋＋で可能かを調べておりまして、googleで、 extends impliment C＋＋ interface などなどの組み合わせて調べていたのですが、調べ方が下手なだけみたいですね。 言語仕様を調べるなら言語仕様書を探すべきでは？ ISO C++だと http://www.iso.org/iso/iso_catalogue/catalogue_i … とか(買わないと読めませんが・・・)、JISだと http://www.jisc.go.jp/app/pager?%23jps.JPSH0090D … とか(C++03ですが) javaは http://docs.oracle.com/javase/specs/index.html ちなみにC++でinterfaceと同等の事をするのに多重継承をすすめてるわけじゃありません。それくらいしか方法がないってだけです。
どういう差異が出ているのかわかりませんが、 セッションIDが埋め込まれたような箇所が変化するというのであれば、 それは変化することが当然なのでそれを前提に処理するべきかと思います。 それ以外の違いがあるとしたら、 以下のような点が要因となっている可能性はあるのでは無いでしょうか。 ・JavaScriptなどのスクリプトでページ内容が動的構成されている ・Cookieによってサーバーが異なるHTMLを返却している ブラウザ側でページを開く際、 JavaScriptを無効にしてページを開いたり、 Cookieを削除してページを開いたりしてソースを比べてみてはどうでしょうか。
> (1)結局、コンパイラが対応してるかしてないか？ どんなコンパイラを使うかによりますが、実用上「対応している」と判断して問題ないレベルのコンパイラは存在します。 > (2)C++11は、まだ完成していない？ 規格自体は完成しています。 > (3)gccのバージョンで使える、使えないが決まるの？ 実装されている仕様と実装されていない仕様があります。 最新版であれば、実用上、ほぼすべての機能が使えると考えてよいでしょう。 > (4)コンパイルする場合、どんなオプションをつける必要がある？ g++とかであれば、-std=c++11ですね。 clang++も確か同じです。
"BROWSERPROTECT"で検索したら以下のページが見つかりました。どうやらいつのまにかアドウェアがインストールされているようですね。対処法も一緒に書かれているので試してみてはいかがでしょうか。 http://www.cseas.kyoto-u.ac.jp/info/2013/04/4932
使ったことないのでなんとも言えませんが… >戻り値は、dwResult = 1219 です。 errlookによると… 「同じユーザーによる、サーバーまたは共有リソースへの複数のユーザー名での複数の接続は許可されません。サーバーまたは共有リソースへの以前の接続をすべて切断してから、再試行してください。」 だそうです。 http://msdn.microsoft.com/ja-jp/library/cc446983 … には戻り値としてERROR_SESSION_CREDENTIAL_CONFLICTは記載されていないんですよねぇ。 http://msdn.microsoft.com/en-us/library/windows/ … 英語のページだと戻り値が記載されていないもの(=Ohter)の場合はFormatMessage()で確認してや。 ってことになっているのでerrlook.exe使用したワケですが。 ログオンしているユーザー名とは別に既にコネクション張られている…とか？ # 一定時間の無アクセスで切断される…とか？？？ >　ＩＰアドレスを取得してネットワークのユーザー認証を行わせる方法を取ればいいけれど、コンピューター名をそのまま設定するとエラーになる理由が知りたいです。 ここだけ見るとコンピュータブラウザ関係ですかねぇ…。 とはいえ、ネットワークコンピュータの一覧に出ていなくても名前解決ができれば接続は可能かと思われますが……。
No.3の「この回答へのお礼」欄の質問に対して回答します。 変数crcやtest_binについての情報が不足しているのではっきりしたことは言えませんが、もし保存するために変数crcやtest_binにデータを格納しているのであれば、変数crcやtest_binにデータを格納する前にTFile.WriteAllBytesやTStreamWriterなどで保存できるかもしれません。 「そのまま置き換える」のではなく、より簡単で簡潔に記述できる可能性があります。
[UINavigationController setManagedObjectContext:]: unrecognized selector sent to instance つまり、UINavigationControllerに、managedObjectContext というpropertyがあるようなコードが、書かれているにもかかわらず、実際には、そういうpropertyは存在せす、したがって、setterのsetmanagedObjectContextも存在しないので、実行時エラーとなるということです。 こけたときに、Xcodeの左側のペーンにスタックトレースがでるので、どこで、起きたか、トレースできるはずですが。
TSaveDialogをフォームに配置します。 ボタンを押したときのイベントを作成します。 void __fastcall TForm1::Button1Click(TObject *Sender) { … } ダイアログの設定を行います。 //デフォルトのファイル拡張子 SaveDialog1->DefaultExt = ".txt"; //ファイルマスク（フィルタ） SaveDialog1->Filter = "テキストファイル (*.txt)|*.TXT|すべてのファイル (*.*)|*.*"; //ダイアログボックスが開いたときのカレントディレクトリ SaveDialog1->InitialDir = "C:\\sample" //ダイアログの外観と動作 SaveDialog1->Options << ofOverwritePrompt << ofCreatePrompt; //タイトルバーに表示するテキスト SaveDialog1->Title = "タイトルバーに表示するテキスト"; TSaveDialogのプロパティはマニュアルをご覧ください。 TSaveDialogのExecuteメソッドを呼び、ダイアログを表示します。 Executeメソッドは、ユーザーがファイル名を選択して[保存]をクリックするとtrueを返します。 //ダイアログを表示する //ユーザーがファイル名を選択して[保存]をクリックするとtrueを返す if (SaveDialog1->Execute()) { … } TSaveDialogのFileNameプロパティで、選択されたファイル名を取得します。 //選択されたファイルの名前 Edit1->Text = SaveDialog1->FileName; 全体のコードは次のようになります。 void __fastcall TForm1::Button1Click(TObject *Sender) { //デフォルトのファイル拡張子 SaveDialog1->DefaultExt = ".txt"; //ファイルマスク（フィルタ） SaveDialog1->Filter = "テキストファイル (*.txt)|*.TXT|すべてのファイル (*.*)|*.*"; //ダイアログボックスが開いたときのカレントディレクトリ SaveDialog1->InitialDir = TPath::GetHomePath(); //ダイアログの外観と動作 SaveDialog1->Options << ofOverwritePrompt << ofCreatePrompt; //タイトルバーに表示するテキスト SaveDialog1->Title = "タイトルバーに表示するテキスト"; //ダイアログを表示する //ユーザーがファイル名を選択して[保存]をクリックするとtrueを返す if (SaveDialog1->Execute()) { //選択されたファイルの名前 Edit1->Text = SaveDialog1->FileName; } }
こんなのとか。 http://ideone.com/G260c1 なぜこのようなコードになったかの説明は略。
普通に aaa.txtをオープン bbb.txtをオープン 全行について ・aaa.txtから1行読む ・bbb.txtから1行読む ・計算結果を出力 を繰り返す オープンしたファイルをクローズ ってだけですよ。 ところで、Cでやらなければならない理由はありますか? 例えば、UNIX系OSだと、次の1行のコマンドです。 paste aaa.txt bbb.txt | awk '{print $1+$2}' ExcelでA列にaaa.txt,B列にbbb.txtを貼り付けて、C1に=A1+B1→下へコピーでもできます。
#include<stdio.h> int main(void) { int x[2][3] = { { 1, 2, 3 }, { 4, 5, 6} }; int y[3][2] = { { 1, 5 }, { 5, 3 }, { 8, 1 } }; int xy[2][2]; int i, j, k; for (i = 0; i < 2; i++) { for (j = 0; j < 2; j++) { xy[i][j] = 0; for (k = 0; k < 3; k++) { xy[i][j] += x[i][k] * y[k][j]; } } } for (i = 0; i < 2; i++) { for (j = 0; j < 2; j++) { printf("%4d", xy[i][j]); } putchar('\n'); } return 0; }
main関数で何でもかんでも仕事をしようとすると プログラム全体の見通しが悪くなるので、 こんな風に役割分担させることをおすすめします。 #include <stdio.h> #include <ctype.h> #define ALPHABET (26) void input(int *lower, int *upper) { int c; printf("文字を入力しなさい（終了条件：Ctrl+Z）\n"); while ((c = getchar()) != EOF) { if (islower(c)) { lower[c - 'a']++; } if (isupper(c)) { upper[c - 'A']++; } } } void output(int *lower, int *upper) { int i; for (i = 0; i < ALPHABET; i++) { printf("%c:%d個入力%c", 'a' + i, lower[i], (i % 3 == 2) ? '\n' : ' '); } putchar('\n'); for (i = 0; i < ALPHABET; i++) { printf("%c:%d個入力%c", 'A' + i, upper[i], (i % 3 == 2) ? '\n' : ' '); } putchar('\n'); } int main(void) { int lower[ALPHABET] = { 0 }; int upper[ALPHABET] = { 0 }; input(lower, upper); output(lower, upper); return 0; }
valを+1できる型に限定するため、でしょうか マクロの引数には型が無いので。 (struct等だと、+1できずにエラーになる) でも、struct,union以外の型は、ポインタ、配列も含め「+1」できるので、その程度の型を限定する効果が、このマクロにどこまで有効なのかはわかりません。 #include <stdio.h> #define test(val) \ ({ \ typeof((val) + 1) __tmp = (val); \ }) int main() { int a=1 ; double b=2; int c[10]={0} ; char d[]="string1" ; char * e="string2" ; struct {int x;} f ; test(a) ; test(b) ; test(c) ; test(d) ; test(e) ; test(f) ; // エラーになるのはここだけ return 0 ; }
ソースファイルが無い場合、逆アセンブラや逆コンパイラでソースファイルを生成できる場合があります。 ただし、こういうリバースエンジニアリングというのはかなり難しいですし、ソースリストが公開されていない物や、市販のソフトウェアや開発環境の場合は契約違反になる事が多いので勧められません。 Ｃ＋＋なら普通に関数をオーバーライドできるけど、その方法ではダメなのでしょうか？
#1の補足を見て。 どうやら、日本語を変数に使えるコンパイラだと理解しました。 > - ほかのなにか?　確率の部分が表示されなくて困ってます。 この「表示されない」とは、文字通りの「表示されない」なのでしょうか? だとしたら、添付されたプログラムに、確率計算している部分も、それを表示している部分もありません。「表示されない」のが正しい動作です。 確率を計算して、それを出力するように、プログラムに追加してください。 もし、計算部分、表示部分が作ってあって、その結果と、予想してる結果とが違うのなら、プログラムに間違いがあります。 どのように計算をやって、どんな結果が出ているのでしょうか? 予想として (熟慮 + 熟慮1 + 熟慮2) / 7 など と計算していて、「結果がいつも0になる」のではないでしょうか? あるいは printf("確率 %f\n", (熟慮 + 熟慮1 + 熟慮2) / 7 ) ; 等とやって、「値が変」なのではないでしょうか? Cの演算の原則として「整数型+整数型=整数型」「整数型 / 整数型 = 整数型(小数点以下切り捨て)」となります。 ・ (熟慮 + 熟慮1 + 熟慮2) は int + int + intなので、intとなります。 ・単に「7」と書いた場合、これは int 型の7 になります。 全体でint / int なので、答えは int になります。 確率の性質を考えれば、ほとんどの場合で 0 になります。100%のときだけ 1 です。 小数点以下の値を扱うには、浮動小数点型(double,float)を使用します。 intをこれらの型に変換するには、型変換(キャスト)を用います。 今回の場合、合計は整数のままで問題ないので、割り算をdoubleで行うように (double)(熟慮 + 熟慮1 + 熟慮2) / 7 とします。 double / int は、自動でdouble / double として計算されます。 printf("確率 %f\n", (熟慮 + 熟慮1 + 熟慮2) / 7 ) ; こちらの場合、計算結果がintなのは同じですが、別の問題があります。 printfに指定する引数は、 %の書式と一致させる必要があります。しかし、一致していない場合でも、コンパイルエラーにはなりません。(警告が出る場合はありますが、エラーにはなりません) C言語の仕様の問題で、printfでは、引数の型を判断することができないのです。そのため、%の書式から、その指定した型だと断定して値を取り出そうとします。 %fはdouble型を要求します。それに対して、引数はintです。 このとき、int→doubleの変換は行われません。 intの数値のメモリ上での表現を、そのままdoubleのメモリ上の表現だと解釈してしまいます。 また、一般に、doubleはintよりもサイズが大きいです。intで足りない部分は、メモリの後の領域(そこに、何があるかはわかりません)まで勝手に使ってしまいます。 このため、引数で指定した値とはまったく違う値が出力されることがあります。 確率計算そのものについては、「何に対する何の確率」なのかが不明なので、例示できません。
『Win32 プロジェクト』を選んで プロジェクト名を入力して ウィザードを起動します 『アプリケーションの設定』ページの『空のプロジェクト』にチェックを入れて『完了』 エクスプローラなどで 作成したフォルダーに Cファイルなどをコピー(または移動)します IDEで ファイル > 既存項目の追加 > 目的のファイルを選択 > 『開く』 といった具合で追加しましょう
int topX=-100-5; int topY=0; int hLen=100; int wLen=100; int yoko=0; CDC *pDC=mPict.GetDC(); // bmpDC自体はループの外で宣言しておく CDC bmpDC; bmpDC.CreateCompatibleDC(pDC); CBitmap *pBitmap=CBitmap::FromHandle(hBitAry.GetAt(0)); // poldbmpは 初回のみ記憶すればいい CBitmap* poldbmp ~ bmpDC.SelectObject( pBmitmap ); BITMAP BMP; for(int i=0; i<hBitAry.GetCount(); i++) { 　　pBitmap=CBitmap::FromHandle(hBitAry.GetAt(i)); 　　pBitmap->GetBitmap(&BMP); 　　if(yoko<3) 　　{ 　　　　topX+=100+5; 　　　　yoko++; 　　} 　　else 　　{ 　　　　topX=0; 　　　　topY+=100+5; 　　　　yoko=0; 　　} 　　pDC->SetStretchBltMode(COLORONCOLOR); 　　pDC->StretchBlt(topX,topY,100,100,&bmpDC,0,0,BMP.bmWidth,BMP.bmHeight,SRCCOPY); 　　// bmpDCの状態を戻すのはループの外でいい 　　// bmpDC.SelectObject(oldbmp); 　　// ここでのDeleteObjectは pBitmapのメンバーで行う 　　// ::DeleteObject(CBitmap::FromHandle(hBitAry.GetAt(i))); 　　pBitmap->DeleteObject(); } // ここで戻す bmpDC.SelectObject(oldbmp); bmpDC.DeleteDC(); ReleaseDC(pDC); といった具合かと …
気になったのが、1枚準備するのに0.1秒未満でできているのか?ということです。 0.1秒以上かかっていたら、タイマーによる100msよりも長い間隔で画像を取り込んでいることになりませんか? VideoWriterは確実に指定した間隔で動画にするので、200msで取り込んでも、動画は10fpsのままで、実際の早さの倍の速度の動画になります。 fpsを落したらどうなりますか?
「通常の算術型変換」について調べるとよいでしょう。 話を簡単にするために整数型に限って説明すると... 整数型どうしの算術演算やビット演算では、まず初めに両辺を「整数拡張」します。 「整数拡張」では、int型より（実際の表現範囲が）小さい整数型はすべてint型に変換されます。 char, signed char, short型の表現範囲がint型と同じ場合もint型に変換されます。 また、char, unsigned char, unsigned short型の表現範囲がunsigned int型と同じであればunsigned int型に変換されます。 次に両辺（今回の場合はxxとyy）の型を比べて、より大きい型に変換されます。 このとき、たとえば、int型とunsigned long型ではunsigned long型の方が多いので、unsigned long型に変換されます。元々マイナスの値だったint型のオペランドが符号無しになってしまうので要注意です。 今回のケースでは、unsigned int型のxxとyyは、「通常の算術型変換」ではunsigned int型のままです。 unsigned int型どうしの乗算結果もunsigned int型になりますので、演算結果が表現範囲を超えています。 また、unsigned char型のxxとyyは、「通常の算術型変換」でいずれもint型に変換されます。 int型どうしの乗算結果はint型ですので期待どおりの結果になっています。 なお、今回の場合は演算結果が0x4e20なので問題ありませんが、INT_MAXを超えてオーバーフローすると未定義の動作になります（ただし、R8Cの場合は、HEWでもGCCでも実害はありませんが...）。
＞void draw(int n)　とはどういったものですか? 引数 n で与えた段数分だけ、ピラミッドを描画する関数です。
breakを使用すると、switch、for、while、doブロックの処理を終えます。 これらのブロックの外でberakを使っているのではないでしょうか。 現在の関数を終了して、呼び出し側のルーチンに戻るにはreturnを使用します。 break - RAD Studio http://docwiki.embarcadero.com/RADStudio/XE4/ja/ … return - RAD Studio http://docwiki.embarcadero.com/RADStudio/XE4/ja/ …
文字って前後に　' をつける必要がありませんでしたっけ？ "フィールド名='" + (文字列型変数) + "'" みたいな感じで。。。。 ⇒違っていたらスル～してください。
> svn --force export http://apt-cyg.googlecode.com/svn/trunk/ /bin/ > なるコマンドを実行して apt-cyg をインストールするようになっているのですが、 > Segmentation fault （コアダンプ） エラーが戻ってきます。 とりあえず、手許のsvnではエラーにならなかったので、subversionの再インストールか、rebaseall で解決するかもしれません。 あるいは、そのURLにはsvn以外でもアクセスできるので、wgetとかcurlとか、あるいはIE等からで直接ダウンロード→/bin にコピー→ 必要ならchmod +x すればいいかと。 > 2．GotoBLASもしくはATLASをインストールする。（GSL に添付されているBLASを使うと、遅くなるからのようです） これについては、よくわかりません。 > 3．WindowsでGSLをビルドとインストールする。 Cygwinは使わない、ということでしょうか? CygwinはWindows上にLinuxもどきを作るような感じになります。 Windows本来のプログラムと一緒にすると、不具合が起こることがあります。 使うときは、区別するようにしましょう。 Cygwinを使わないWindows用のGSLをビルドするとも、Cygwin上で2.に対応したGSLにコンパイルしなおすとも読めるのですが。
UnicodeStringが空かどうかを確認するにはUnicodeString.IsEmptyを使用します。 if (OpenDialog1->FileName.IsEmpty()) { //文字列が空のとき … } System.UnicodeString.IsEmpty - RAD Studio API Documentation http://docwiki.embarcadero.com/Libraries/XE4/ja/ … ファイルが存在するかどうかを確認するにはTFile.Existsを使用します。 #include <System.IOUtils.hpp> if (TFile::Exists(OpenDialog1->FileName)) { //ファイルが存在するときの処理 … } System.IOUtils.TFile.Exists - RAD Studio API Documentation http://docwiki.embarcadero.com/Libraries/XE4/ja/ … TOpenDialogを使って存在するファイルを選択させるには、次のようなコードになります。 //存在しないファイルをユーザーが選択しようとしたときにエラーメッセージを生成する OpenDialog1->Options << ofFileMustExist; //開くボタンが押されたとき if (OpenDialog1->Execute()) { //存在するファイルが選択されたときの処理 … } TOpenDialogのOptionsプロパティにofFileMustExistを設定すると、存在しないファイルを選択できません。 上のコードではOptionsプロパティを実行時に設定していますが、設計時にオブジェクトインスペクタのプロパティページでも設定できます。 TOpenDialogのExecuteメソッドは、開くボタンが押されたときにtrueを返します。 ファイルが選択されていないときは開くボタンを押すことができないため、戻り値がtrueのときは存在するファイルが選択されていることになります。 Optionsプロパティに設定できる値はマニュアルをご覧ください。 Vcl.Dialogs.TOpenOptions - RAD Studio API Documentation http://docwiki.embarcadero.com/Libraries/XE4/ja/ …
サンプルでもだめだとなると、私にはわかりかねるのですが、一点だけ > (3)当初MacPortsで試行するも不具合で断念 > (4)サイト(1)を参考にHomeBrewを利用しOpenCVのインストール成功 MacPortsとHomeBrewを同時に使うと、互いに依存や干渉しあって不具合が発生することがあるそうです。 例えば ・依存するパッケージとして、同じライブラリがMacPorts,HomeBrewの双方でインストールされてしまう → コンパイル時は MacPorts、実行時はHomeBrewのライブラリを使おうとして不一致によるエラーとなる 等。 使わない方はアンインストールして、どちらかに統一するのがいいかと。 ライブラリで思い出しましたが、DYLD_LIBRARY_PATH が設定されてたりはしませんね?
バイトオーダーを無視してよいのであれば... memcpy(AAA, &LONG, sizeof(LONG)); とするのが基本です。 以下のように、共用体を使う方法もありますが、任意のバイト配列に格納するにはさらにコピーが必要になります。 union U { 　unsigned long LONG; 　unsigned char AAA[sizeof(unsigned LONG)]; } u; u.LONG = 値; もし、ビッグエンディアンとして扱いたいのであれば次のようにします。 for (std::size_t i = 0; i < sizeof(LONG); i++) 　AAA[i] = LONG >> (CHAR_BIT * (sizeof(LONG) - 1 - i)); リトルエンディアンとして扱うなら次のようにしてください。 for (std::size_t i = 0; i < sizeof(LONG); i++) 　AAA[i] = LONG >> (CHAR_BIT * i); ちなみに、unsigned char型は必ず1バイトですが、ビット数は8ビットとは限りませんので、必ずCHAR_BITを使う必要があります。 また、unsigned long型が何バイトなのかも処理系定義です。 32ビット以下の多くの処理系や64ビットWindowsではunsigned long型は32ビットですが、多くの64ビットの処理系ではunsigned long型は64ビットです。 また、char型が16ビットや32ビットや64ビットの処理系も実在しますので、その場合はunsigend long型が2バイトや1バイトになることもあります。 一部のDSPではunsigned long型が48ビットで6バイトというものも存在します。
No.6の「この回答へのお礼」欄の質問について回答します。 int code = memo1[j]; switch (code) { case 'す': … case 'し': … } このコードが分岐しない理由は、値が一致しないためです。 AnsiString::operator[]()はchar型の値を返します。 http://docwiki.embarcadero.com/Libraries/XE4/ja/ … char型の変数の長さは1バイトで、-128～127の値をとります。 http://docwiki.embarcadero.com/RADStudio/XE4/ja/ … 日本語版WindowsではAnsiStringの文字コードはShift_JISになります。 Shift_JISのひらがなはマルチバイト文字ですから、memo1[1]には「す」の1バイト目、memo1[2]には「す」の2バイト目の値が入ります。 それぞれの値を出力して確認すればよくわかると思います。
>プログラムカウンターのつもりです。 先にも書きましたが、あなた自身にしかわからない造語を使われても他者にはわかりません。 あなたが勝手につくった造語なんて調べてもわかりませんから質問する際には、そのような造語は使うべきではないです。 もちろん回答もですが。 「動かないretcode」が動かない理由に関連する事項は、あなた自身で他の回答者の補足に書いてます。 少なくともその補足の内容を理解してるならわかるはずの理由です。
http://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83% … \0 は \n や \r などと同じエスケープシーケンスです。
DirectXとか関係ありませんが… 表示する画像と縦横が同じサイズの二次元配列なり用意します。 で、画像がクリックされた時に座標から配列を参照して結果を得ます。 二次元配列ではなく8Bitカラーのビットマップにする。 という手もあるでしょう。 # レイヤー機能があるペイントソフトなどでそういう画像データを作成すればよい。 # ペイントソフトでは24Bitカラーになるようであれば、8BitカラーのBMPに変換してくれるようなソフトもありますし。 これなら矩形とかの制限はありませんし。 # というか、某ゲームエンジンでやっていた方法ですしねぇ。(クリック時ではなくマウスカーソルが特定の領域に入っているかの判定用でしたけどね) # 当時はOPTPiXのお世話になりましたなぁ…。8Bitカラー用のパレットファイル用意してましたわ。(せいぜいクリック箇所判定は32個程度あれば充分だったのでパレットファイルもそんなモンでしたが) # メッセージウィンドウの各種ボタンとか、CGモードのサムネイル(斜めになっているものとかいろいろ)の上にマウスカーソルが乗ったか？とかの判定に使いまくり。
”Ｃ”でできるかどうかわかりませんが、 「Visual C++ 」を使っておられるのであれば、 「.NET」の「System.Drawing」名前空間の「Bitmap」クラスのプロパティ「PropertyIdList」、「PropertyItems」を使えば、 比較的に簡単に、目的の情報を取得できます。 MSDN　http://msdn.microsoft.com/ja-jp/library/system.d …(v=vs.90).aspx　等が参考になると思います。 参考URL：http://msdn.microsoft.com/ja-jp/library/system.d …(v=vs.90).aspx
C++Builder 2009以降なら次のコードでJISコードの文字配列を取得できます。 AnsiStringT<50220> jis = "前前前前前前前前"; char* c = jis.c_str(); JISコードで文字列をファイルに保存したいなら、C++Builder 2010以降なら次のコードでできます。 #include <System.IOUtils.hpp> TEncoding* jisEnc = TEncoding::GetEncoding(50220); TFile::WriteAllText("C:\\test\\test.txt", "前前前前前前前前", jisEnc); delete jisEnc; 50220はJISコードのコードページです。 たとえば20932を指定すればEUC_JPになります。
　ご質問にある通りだと３つ問題点があります。 １）ｎｂが初め０となっているので、ｎａが１の時に画面に２が表示される。 　例で０が表示されないことを考えると、ｎａが１の場合には何も表示しない方がよいのではないか。 ２）ｎｂ＋２ではｎｂの値は変わらない。 　ｎｂの値を変えるためにｎｂ＝ｎｂ＋２とする必要がある。 ３）表示する偶数がくっついてしまう。 　「２　４　・・・」のようにスペースを入れる必要があるのではないか。 #include<stdio.h> int main(void) { int na; int nb=2; printf("整数を入力してください。:"); scanf("%d",&na); while(nb<=na){ /*ｎｂが入力した数以下の偶数の間続ける*/ printf("%d ",nb); /*ｎｂとそれに続くスペースを表示*/ nb = nb+2; /*ｎｂを次の偶数に書き換える。*/ } putchar('\n'); return 0; ・・・これだと最後の偶数表示の後にもスペースが付くので気持ち悪いです。 たぶんこの後に良い回答が付くでしょう。
本題ではないけど strcpy((char *)tmp_bin,memo6.c_str()); for(int j=0;j<32;j++) { test_bin[j] = tmp_bin[j]; } の部分, もっとまともに書けないものだろうか.
貴殿の質問文を読んだ感触では「ロベールの C++ 入門」を読むには早いです。 この書籍、全くの初心者が読んでも理解しにくいと思います。
C++Builderのバージョンが記載されていませんので、C++Builder 2009以降のバージョン(2009/2010/XE/XE2/XE3/XE4)を前提に話をします。 C++Builder 2009以降では、String型はUnicodeString型になっています。 typedef UnicodeString String; UnicodeStringからバイト配列を取得するには、TEncodingのGetBytesメソッドを使用します。 //UTF-16 TByteDynArray bytes = TEncoding::Unicode->GetBytes(memo0); //UTF-8 TByteDynArray bytes = TEncoding::UTF8->GetBytes(memo0); //OSの標準の文字コード(日本語WindowsならShift_JIS) TByteDynArray bytes = TEncoding::Default->GetBytes(memo0); //特定の文字コードを指定する例（ここではコードページ20932(EUC-JP)を指定している） TEncoding* enc = TEncoding::GetEncoding(20932); TByteDynArray bytes = enc->GetBytes(memo0); delete enc; ・System.SysUtils.TEncoding - RAD Studio API Documentation 　http://docwiki.embarcadero.com/Libraries/XE4/ja/ … TByteDynArrayはDynamicArray<Byte>です。 Lengthプロパティで要素数を取得、operator[]で指定したインデックスの要素を取得できます。 詳しいDynamicArrayの使い方はマニュアルをご覧ください。 ・System.TByteDynArray - RAD Studio API Documentation 　http://docwiki.embarcadero.com/Libraries/XE4/ja/ … ・System.DynamicArray - RAD Studio API Documentation 　http://docwiki.embarcadero.com/Libraries/XE4/ja/ … もう一つの方法として、AnsiStringに変換してc_str()メソッドを使用する方法もあります。 //OSの標準の文字コード(日本語WindowsならShift_JIS) AnsiString sjis = memo0; char* c = sjis.c_str(); //特定の文字コードを指定する例（ここではコードページ20932(EUC-JP)を指定している） AnsiStringT<20932> eucjp = memo0; char* c = eucjp.c_str(); //UTF8（UTF8StringはAnsiStringT<65001>） UTF8String utf8 = memo0; char* c = utf8.c_str(); ・System.AnsiStringT - RAD Studio API Documentation 　http://docwiki.embarcadero.com/Libraries/XE4/ja/ … ・System.AnsiStringT.c_str - RAD Studio API Documentation 　http://docwiki.embarcadero.com/Libraries/XE4/ja/ …
こういうのを見るとヌル文字分を足して、1001 bytesくらいで十分そうな感じがしますが... RFC1939 Post Office Protocol - Version 3 http://www.ietf.org/rfc/rfc1939.txt > 3. Basic Operation > Responses may be up to 512 characters long, including the terminating CRLF. RFC2822 Internet Message Format http://www.ietf.org/rfc/rfc2822.txt > 3.5 Overall message syntax > A message consists of header fields, optionally followed by a message > body. Lines in a message MUST be a maximum of 998 characters > excluding the CRLF, but it is RECOMMENDED that lines be limited to 78 > characters excluding the CRLF.
16進文字列に変換しちゃうのもテかもですね。
RETRコマンドで読み取り完了したら、そのメールを削除して、QUITコマンドで切断していますから1通しか読み込めないのは想定内の動作のハズですけど、そこらヘンはどうなんですかね？ CSQMailBoxTreeView::GmailProcessData()の呼び出し方次第ではココも正常動作が期待できませんが…。 前回の回答でも指摘しましたが普通のPOP3で正しく動作するもの作ってからの方がいいと思われますが…。 その際、LAN内の別マシンにPOP3サーバを構築すればWireSharkなどでパケットの内容は確認できますし。 # GmailのPOP3って…bad commandで切断されるのね…… あと…MessageBox()でもろもろの通知を出すと「そこで処理が止まる」ので通信扱う場合だと問題が発生することもありますのでご注意を。 # 私ならTRACE()やその類使いますね。(Win32SDKなんでOutputDebugString()ですが…)
> ・プログラム開始から　2秒毎に　値を加算する SetTimer でいいのではと。
#include <stdio.h> int main( void ) { int na, nb, nc; printf( "整数1 : " ); scanf( "%d", &na ); printf( "整数2 : " ); scanf( "%d", &nb ); printf( "整数3 : " ); scanf( "%d", &nc ); printf( "最小値は%dです。\n", ( na < nb ? ( na < nc ? na : nc ) : ( nb < nc ? nb : nc ) ) ); return 0; }
そのバッファオーバーランの有無はどうやって調べたのでしょうか? 単に、エラーが発生するかどうか、で判断しているのなら ・バッファオーバーランが発生してエラーになる ・バッファオーバーランが発生したけど、たまたまエラーにはならなかった の両方とも起り得るので、「エラーで止まらない」≠「バッファオーバーランが無い」です。 他に、 int i, a[10],b ; b=a[i]; 等と、変数を初期化していないまま参照したとき、iの状態によってバッファオーバーランになったりならなかったりします。
timeGetTimeはm秒単位の時間が返りますが、その分解能は1m秒ではありません。 1m秒の違いを区別することができません。 http://msdn.microsoft.com/en-us/library/windows/ … > The default precision of the timeGetTime function can be five milliseconds or more, depending on the machine. http://msdn.microsoft.com/ja-jp/library/cc428795 … > timeGetTime 関数の既定の精度は、マシンによっては 5 ミリ秒以上になる場合があります。 なので、極短時間の処理を測定すれば、前後で同じ値になる(=経過時間が0になる)場合があります。 また、たまたま値が変わる前後になって、分解能の時間になる場合もあります。 たとえば、5m秒だとすると 開始が 1m秒 終了が 4m秒 なら、それぞれtimeGetTime関数からは 0と0が返るので差が0m秒になります。 開始が 4m秒 終了が 7m秒 なら、それぞれtimeGetTime関数からは 0と5が返るので差が5m秒になります。 どちらも、実際の時間は3m秒で同じです。 CUT_SAFE_CALL(cutCreateTimer(&timer)) の方はわかりません。 CUDAには不案内なもので。 分解能が細かければ、測定できるかもしれません。 ですが、あなたの環境で、そもそもCUDAが使えるかどうか(グラフィックボードは対応しているのか?開発環境は整っているのか?)
おそらく printf の書式文字列
「バブルソート」というアルゴリズムです。 解説はいくらでもWeb検索で拾えます。
#3です。#5さんのコードでも解決しないとのことなのであなたのコードにprintfを少々つけたコードを載せますので実行してください。 手入力が面倒なので使っていたNOINPUTFLAGを放置してます。"#define NOINPUTFLAG 1"にすれば適当に値をぶち込みます。 #if～#endifの部分はNOINPUTFLAGが0の時コンパイル時にあなたのコードと全く同じになるので変化はありません。 今後も何かエラーが出る場合はprintfなどで自分が何をしているのか確認してください。 ///////////////////////////////////////////// #include <stdio.h> #define MAXDATA 10000 #define NOINPUTFLAG 0 //main()の型はintなのでそう宣言する int main() { int stnum[MAXDATA],point[MAXDATA],mem; int n,j,k,i,tmp,tmps; printf("生徒数に1または10000を超える値を入れるとエラーになります\nもちろん数字以外の値もダメです\n"); //バッファオーバーフローですので場合によっては検知できません、1の方はjの初期化に注目 printf("生徒数を入力してください。"); scanf("%d",&mem); if(mem<=0){ do{ printf("もう一度生徒数を入力してください。"); scanf("%d", &mem); }while(mem<=0); } for(i=0;i<mem;i++){ //NOINPUTFLAGが0のとき何も変化はありません #if NOINPUTFLAG point[i]=i; stnum[i]=i; #else printf("%d人目の生徒の点数を入力してください。\n",i+1); scanf("%d", &(point[i])); printf("%d人目の出席番号を数字で入力してください。\n",i+1); scanf("%d", &(stnum[i])); #endif } //NOINPUTFLAGが0のとき何も変化はありません #if NOINPUTFLAG printf("入力は省略しました\n"); #endif for(i=0;i<mem-1;i++){ j=i; } printf("この時点でi=%d, j=%d, k=undefined。でもまだ配列にアクセスなし\n",i,j); for(k=i+1;k<mem;k++){ if(point[j]>point[k]){j=k;} } printf("i+1(=%d)とmem(=%d)の大小を比べるとバブルソートを意図したと思われる処理は・・・ できたとしてもpoint[%d]は値が与えられてたっけ？\n",i+1,mem,i+1); tmp=point[j]; point[j]=point[i]; point[i]=tmp; printf("point[%d]とpoint[%d]を入れ替えました\n",i,j); for(k=i+1;k<mem;k++){ if(stnum[j]>stnum[i]){j=k;} } printf("同じく。\ni+1(=%d)とmem(=%d)の大小を比べるとバブルソートを意図したと思われる処理は・・・\n",i+1,mem); tmps=stnum[j]; stnum[j]=stnum[i]; stnum[i]=tmps; printf("stnum[%d]とstnum[%d]を入れ替えました\n",i,j); for(i=0;i<mem;i++){ printf("%d番の点数は%d点です。", stnum[i],point[i]);//改変：nはiだとのことだったので } return 0;//int型の返り値 }
＞if(n==" "){ ＞と直せばよいですか？ そういうことではなくて 文字列の比較は単純な比較演算子 ＝＝ とか ！＝ とかではできないんです コンパイルエラーにはなりませんが希望する動きにはなりません strcmpなどの文字列比較関数を使ってif判定してください
No3　の補足に対して あくまで私が書いた手順で実装していいのであれば（他にもいろいろと考え方はあるので） の前提とあなたの書いたコードを極力生かす方向でこちらも書き込みます 全ては書かないので コンパイルちゃんと通るように他の部分も編集してください 括弧の対応と 関数・引数の型宣言などは省いています int i ;　　これが採番用のグローバル変数に該当します この下に 書きわ忘れたという　main()　{ を追加 ＞for(i=1;i<100;i++)　　要らない ＞{　　　　　　　　　　　要らない ＞if((fp = fopen("test.dat", "a")) == NULL) 　　読み込みモードの指定が不足 ＞fprintf(fp, "ファイルのオープンに失敗しました．\n"); 　　　ここに採番用のグローバル変数の初期化処理追加　 ＞eturn ;　　　　　要らない(これあったらいつまでたっても初期起動ができません） ＞fp=fopen("test.dat","a"); 　　　既にfpでファイル開いているので 処理変えないといけません 　　　　　　　・これをなくす 　　　　　　　・先のオープンで正常に開けたときはCloseしておく (オープンエラーだったときはここでもオープンエラーになるだけです） 　　　どちらか好きな方を選んでください 　　　データ読み込みのところでも触れますがファイルが無い場合でも 　　　そのまま突き進みますのでデータ読み込み処理は 正常オープンできた時だけ行うように変更してください ＞f(fscanf(fp, "%d" , i )==0) ＞　｛ ＞　　　　　　　　　　　　 　　/*途中で採番を終了する場合は番号に０を入力*/ ＞　　fprintf("番号：%d", i ); ＞　　break; ＞} 先の処理でファイルが無くて(オープンエラー）もここに来るので ファイル正常に開けたときにデータよ読むように組み替えた方がいい 　　その上でデータが読めない場合は　・採番用のグローバル変数の初期化処理追加　　 　　　　　　　　　　　　　　　　　　・ファイル破損によるプログラム終了 ファイル破損起こったとき次回起動をどう扱うかは 　　　　　　　　　　　　　　　　　　　とりあえず考慮しません 　　どちらかを選択してください 　　どちらにしてもその後で一旦設定ファイル(fp)を閉じてください ＞　fprintf("番号：%d", i ); 最初のforループはなくしたのでここで手順３のループ処理追加　for(;;) の永久ルーブで可 そのループの中で 　　　現在の採番用のグローバル変数表示 　　　オペレータ入力操作待ちで入力値判断 　　　　≠０：採番用のグローバル変数＋１ 　　　　＝０：ルーブ脱出 ＞fclose(fp); 先に開いたモードは読み込みモードであり書き込みができない そしてこの段階では既に閉じているように変更しているので 改めて 書き込みモード　でファイルのオープン処理追加 現在の採番用のグローバル変数の書き込み ファイルクローズ　　の手順を行って プログラム終了 といった形になります（此方も作ってないので書き間違えもあるかもしれません） 後途中で気が付きましたが 現在の採番として ３　を表示している段階で終了 次回開いたときは　４　　の表示にしたいのであれば 　　　　≠０：採番用のグローバル変数＋１　　のところは 　　　　無条件で＋１する必要があります 私は 次回開いたときも　3 から始まるのかと思ってたんで どちらにするのかで処理変えてください 後厳密に言えば細かいエラー処理入れるともっと複雑になります (基本コード構築を優先で考えているので特に触れていません）
>scanf_s("%c\n", &koma); ひとまず、これで'龍'や'角'がkomaに設定できてるのか確認されてはどうでしょうか。 他の回答者がいわれてる事がわかると思いますよ。
>また、ポインタが、先頭アドレスしか持っていないとしたら、クラスAで使用しているメモリ領域の最後はどこなのか？や、 ポインタがクラスAのポインタという事がわかってるのであればクラスAのサイズからメモリ領域の最後はわかります。 >クラスAの中の、プロパティxの部分のためのメモリ領域はどこからどこまでなのか？ メンバxのサイズはわかりますしクラスAでの位置もわかってるわけですから上記と同様にわかります。 あとCやC++には言語仕様としてプロパティーはないです。
シェルスクリプトを書き換えていいのなら./a.out を gdb ./a.out に書き換えればいいかと。 書き換えがだめだと時間的余裕があるなら前もってgdbを起動しておいてa.outが起動したタイミングでアタッチするとか。 くらいしか思いつきません。
>foreachでlistviewからデータを取得して、ページにアクセスしていくといった事です。 それじゃわからないです。 >System.ArgumentOutOfRangeException: 長さを 0 未満にすることはできません。 >パラメーター名: length >場所 System.String.InternalSubStringWithChecks(Int32 startIndex, Int32 length, Boolean fAlwaysCopy) >場所 yahooauction.Form1.button6_Click(Object sender, EventArgs e) のメッセージを見る限りは yahooauction.Form1.button6_Click(Object sender, EventArgs e)内(そこから呼び出されているメソッドも含めて)の文字列操作で不正な値を指定して操作しようとしてるとこがあるようなので文字列操作を行ってるところを調べてみてください。 メソッドの戻り値のチェックを行うべきとこでチェックせずに、そのまま他のメソッドの引数に使ってるとかありませんか？
描画及び空処理に伴うメモリ上昇
SSL以前の問題ですね。 > while (1) { > char buf[1024] = {0}; > if (SSL_read(ssl, buf, sizeof(buf)-1) <= 0) > break; > res += buf; > } よくこれでブロックしないですね。 SSL_readでタイムアウトして切断されるまで待たされて、タイムアウトした所でSSL_read < 0となってループを抜ける事になりそうですが。 このコードだと、POP3Sではなく普通にread/writeを使ってPOP3を話すプログラムを書いても動かないと思います。 もし、「ブロック？？？」と思うなら、次のページでも読んでみると良いでしょう。 http://msdn.microsoft.com/ja-jp/library/3tbz7kf5 … まず、ブロッキングで書くとしたら、サーバーから返ってくる文字列をちゃんと確認して、CRLF (\r\n)が来ていた場合はループから抜けるようにしましょう。 例えばこんな感じ？ size_t crlf_pos; while (1) { char buf2[1024] = {0}; if ((crlf_pos = res.find("\r\n")) != string::npos || SSL_read(ssl, buf2, sizeof(buf2)-1) <= 0) break; res += buf2; } cout << res.substr(0, crlf_pos) << endl; res.erase(0, crlf_pos + 2); // 2 = sizeof(CRLF) あと、POP3の資料といえばこの2つですよね。 http://tools.ietf.org/html/rfc2595 http://tools.ietf.org/html/rfc1939 RFC2595はPOP3をどうやってSSLと一緒に使うかの解説で、#1さんの回答にあったSTLSが説明されています。RFC1939はPOP3そのものの解説です。 あと、SSLで安全な通信がしたかったら、certificateをセットして、CRLかOCSPかをチェックしてください。なりすまし対策がないSSLは見掛け倒しです。暗号化通信をしているかもしれませんが、誰と暗号化通信をしているかはわかりません。 #2の回答についてコメントです > WSAAsyncSelect()でメッセージで通知して貰うようにして組んだことはありますが、 > FD_READで受信した後でSSL_read()しても何も読めない。という状況になったことはあります。 もしノンブロッキングなソケットが裏にあるとしたら、SSL_ERROR_WANT_READ / SSL_ERROR_WANT_WRITE をちゃんとハンドリングしないとダメですね。 http://www.openssl.org/docs/ssl/SSL_read.html selectで読めると言われても、SSLのレベルでデータが読めるまでには何度も read/write を繰り返さないといけないことがありますので。
自分で設定できないのであればせめて相手に4.5にしたうえで確認してもらってください
通常のLNK2019であれば他にログが出ていると思いますので、それも記載してください。
> 私は、処理を確認する際、『どの型の値がそこに突っ込まれているかは、代入されているところを探して確認しないとわからない。』というのが、可読性は悪いわ、確認に時間が取られるわで、非常に大きなデメリットと考えています。 なんかデザインがダメな感じがします。 Liskov substitution principleに従ってないsubclassを作ってませんか？ actual typeを逐一確認しないとコードが書けないとしたら、subclassなんて使わないほうがいいです。ほぼ確実に、間違った継承の使い方をしています。 #1さんのおっしゃるとおり、typeidでactual typeを知ることは可能ですが、そんなことをするよりもデザインの再考をしたほうが良いかと。 個人的には、 http://okwave.jp/qa/q8189254.html のように Liskov substitution principle に反するようなコーディングが必須の例というのはあまり良くないと思うのですが。それよりも例えばユーティリティ的なモジュールを作ったほうが良くないですか。あるいは、２つのクラスとも単一のファイルに書いておいて、その中のanonymous namespaceにユーティリティを置くか。
>クラスの定義をするときに、 >そのクラスが必要とするヘッダファイルを#Includeで取り込む際、 >#Includeで取り込むのではなく、 >Class XXX　として記載するケースがあると思います。 単にクラスXXXがあることがわかればいいだけのケースではないですか。
unsafeな世界で頑張る理由がちょっとわからないので… DicrectShowで画像をくみたてているなど必然性があるのを前提に回答すると、 変数pointerにpointerが入っているとして、 メモリをバイト配列にコピーして、 http://msdn.microsoft.com/ja-jp/library/28k1s2k6(v=vs.80).aspx Copy(pointer, 0, bytes, 0, size); //サイズは後述 Streamを組み立てて、 Stream stream = new Stream(); stream.Read(bytes, 0, size); 以下の例を下にPictureBoxにビットマップを表示させる。 http://msdn.microsoft.com/ja-jp/library/z7ha67kw(v=vs.80).aspx 上記URLのresponseStreamは、streamになります。 ここで読むこむべきサイズが必要なのですが、ヘッダ情報付きビットマップなので、サイズはヘッダの中に入っています。 System.Uint32 bfsize = (System.UInt32)((BITMAPINFOHEADER)(*pointer))->bfSize; size = (int)bfsize; ※扱える範囲はintです。 BITMAPINFOHEADER 構造体を参考に回答 http://msdn.microsoft.com/ja-jp/library/cc352308 …
情報が無さすぎて、明確な回答はできません。 > ・秘密分散法を用いて、分散画像Aと分散画像Bを合わせて１つの秘密画像に復号したい時、どのようなプログラムコードを使えばいいですか？ その二つの画像に対応した復号アルゴリズムを使って、プログラムを作ってください。 「秘密分散法」にもいくつものバリエーションがあります。 暗号化の方法がわからなければ、復号は非常に困難です。 その画像に適合した復号プログラムコードなど、そうそう見つかるものでは無いので、参考書や論文にあるアルゴリズムや数式から、御自身でプログラムを作ってください。 > ・「鍵の長さ」は秘密分散のプログラミングに関係ありますか？ その暗号/複合化に使われているのなら、関係あります。 使われてなかったら関係ありません。 > ・また、言語で分散画像Aの行列と分散画像Bの行列同士をOR演算すれば秘密画像を表示できますか？ 「復号のアルゴリズムが『行列同士をOR演算』となる暗号化」で作られたものなら、表示できます。 そうでないなら表示できません。 ただ、ORだけ、ということは、暗号として有り得ないと思います。 元情報が「0」の場合、「全てが0」である必要があります。黒(0)一色の画像を暗号化しても、黒一色の画像が複数できるだけとなり、暗号の意味を為しません。
該当機使ったことないので詳細は分かりませんがPCとの接続は RS485になるような記載があるのでそれでやり取りできるんではないかと思います 要はRS232C通信と同じ制御ではないかと(USBとか意識しなくていいのではないかと思います） ある程度の設定が標準アプリでできてそれを通信で 書き込む(制御する)方式なのではないでしょうか 実際自分のプログラムからどの程度の制御ができるのかは実物見ないとよくわかりません
ちょっと複雑だと多分うまくいかないけどこんなやつら? 参考URL：http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC% …
http://msdn.microsoft.com/ja-jp/library/ms752032 … 上記URLの、<Trigger Property="IsSelected" Value="True">～</Trigger>要素を御覧ください。
Fairfield(フェアフィールド)の公式を使うと、西暦1年1月1日)から特定の日までの通算日数が求められます。この公式を使って求めた日数の差が所望の日数です。 「フェアフィールドの公式」で検索して見つかる解法やプログラムを参考にすればよいでしょう。
後半はおよそ「構造体のメンバをポインタ経由でアクセスするときにはハードコードしたオフセットを使わないで offset of マクロを使え」って意味ですぜ＞#4. ・なぜか「offset of」と空白が入っている ・そもそも無名構造体では offsetof が使えない という点で謎の文章ですが, 同じ文章を持つ別のリマークがあるので「同じだと思ってコピペした」とか, その程度のことではないかと.
> ＞・・・ＯＳの役割を、・・・ > パソコンの基礎を学んでいない素人ですので、よろしくお願いします。 いや、逆ですよ。 やりたい事なために自分で学ばないといけないんです。 環境や人の性にしてはいけません。 そもそも、こんな所の基礎を教えてくれるところなんて情報工学系の大学くらいです。 ※　それでも情報工学系の大学生の多くの人は、優秀な人を除いてちゃんと理解できているか怪しいですが。 基礎をすっとばすから訳が分からなくなるんです。 言い訳じゃなく、自分でやるべき事(OSとCPU動作を基礎から勉強)をやってください。
言語の知識があっても組込み系が初めてならば、いきなり割り込み処理はハードルが高すぎますね。 少なくとも、C言語でこれをどうやって記述するかは、マイコンボードの仕様やコンパイラに依存します。 秋月のキットかなにかをお使いでしょうか？ マイコンのデータシートやキットの仕様書などを熟読された上で、 そのキットのサンプルコードをいくつか入手して、マイコンのレジスタの設定や、割り込みハンドルの仕方など一通り理解しないと、＃２さんのせっかくのアドバイスもちんぷんかんぷんなのではないかと思います。 そうでなければ、お使いのボードや、コンパイラ環境などをお書きになると、もう少し具体的なアドバイスがもらえるかも知れません。 まずは、この辺りの資料類を熟読してみてください。 ご参考に。
何の研究やってるか知らないけど、お勉強もほどほどにね。 あんまり、技術が進歩し過ぎるとすぐ今までの文化が廃れるから。 まぁおそらくエロ画像から素材拾ってモザイク作る研究なんだろうけど、 そんなにいい作品ならお店に沢山並んでましたよ？？ Hitするしないにかかわらず、公序良俗に反する研究はやめて下さい。 お願いします。フライパンで目玉焼きでも食ってろや（笑）
sleepで改善がみられましたか。 ＞ただ私のプログラムの場合、描画指令の後ではなく前でないと効果がありませんでした。 ＞環境あるいはプログラム構成の違いのせいでしょうか。 多分環境でしょう。描画命令の前に入れて効果が出る方が自然なように思います。こちらはなぜか後ろに入れないと効果がありませんでした。 sleepの挿入が許される程度の時間待ちがあっても良いのでしたら、そうゆう解決法も良いのではないかと思います。 多分ディスクアクセス速度に依存するはずですので、余裕を持たせた値にしましょう。 パイプを使う方がそのような問題が出にくいので安心なのですが、環境によってパイプに起因するような問題点があるのかもしれません。
Windows.Forms の GUIイベントはメインスレッドで実行されるのでメインスレッドを止めても 無駄です。 メインスレッドがイベントを自分で見に行かない限りイベントは起きないのです。 メインスレッド内で処理中に他のイベントを受け取るには、イベントの到着を確認して イベント処理を行う DoEvents が必須です。
前回の説明の通り。 実感と合わないのは、おそらく、clock関数で求まる時間が「CPU時間」等と呼ばれるもので、実際に経過した時間では無いから。 ※ それでも、2分はかかって無いはず。ストップウオッチ片手に測定してみれば? Linux等では、clock()はCPUの動作時間が返ります。 これには、CPUが待機している時間は含まれません。 CPUが待機している時間には、次のようなものがあります。 ・ファイルに書き込む命令を実行してから、実際に書き込まれるまでの待ち時間。 ・ファイルから読み込む命令を実行してから、実際に読み込まれるまでの待ち時間。 ・画面の文字を出力する命令を実行してから、実際に表示されるまでの待ち時間。 ・バックグラウンドで動作している他のプログラムがCPUパワーを使っていて、全体に重くなっている。 これらの時間が長い程、clock()で求めた時間と、実際にかかった時間との差が大きくなります。 前回も書きましたが、このプログラムが「遅い」のは、いちいち交換結果を出力しているからです。 printfで整形する時間も長いですが、それ以上に、出力時の待ち時間がとても長いです。 上記のように、この待ち時間はclock()に含まれていない可能性が高いです。
>と出力されたのですが読み方？単位が分かりません。教えてください。2分ぐらいかかった気がします。 どうやって計測したのか書きましょう。 数値だけだされても、それで単位がわかる人はいません。 『「123」と表示されました。単位を教えてください』で、単位がわかると思いますか？
「弘法、筆を選ばず」という諺がありますが、 言語とプログラマーということを考えれば、まさにこう言うことです。 開発現場がＣＯＢＯＬを必要とすならＣＯＢＯＬを使いこなし、 Ｃ言語を必要とするならＣ言語を使いこなすのがプロのエンジニアです。 未知の新しいプログラム言語が発表されたなら すぐに、その言語の使用方法や特性、 最大機能の引き出し方などを見極める力量が必要です。 アマチュアの世界にはＣＯＢＯＬ屋とかＣ言語屋は存在しますが、 プロの世界には存在しません。 今の仕事を的確にこなしつつ、新しい言語やＰＣの構造やしくみなどを 勉強を進めて行くことをお勧めします。 （おそらく、この線で進まれるようですね） また、アプリケーションの方向にも眼を向けるのも大切です。 アプリケーションは大別すれば、 １．生産管理 ２．金融 ３．証券 などに大別できます。 コンピュータシステムのアプリケーションに関連した書籍は皆無ですが 気にとめておいて下さい。 まず、自分の作っているシステムが「人・物・情報」を動かすのに どう関わっていってるのか考察することが当面は大切でしょう。 これが把握できているか否かでシステムエンジニアとしての評価は大きく変わります
既に回答が出てますが。 OSやコンパイラ等によっては、別の方法が用意されていることがあります。 例えば、 gettimeofday という関数が用意されていることもあります http://linuxjm.sourceforge.jp/html/LDP_man-pages … それと、最近はCPUも早くなっているので、1000個くらいのソートだと、バブルソートと他のソートとで、誤差程度の時間しか違わないかもしれません。
単純に 「 for( y : y座標の範囲){ for( x : x座標の範囲){ (x,y)座標についての色を決定する 出力画像データの該当する箇所をその色にする } } 」 ってだけのものでは? [(x,y)座標についての色を決定する] がこの手法の肝ですから、いろんな方法があるでしょう。 その例では ・(x,y)が文字の部分 → 黒 ・それ以外 → ノイズ となっているように見えます 出力画像の色を設定するとか、元画像やノイズ画像を作るとかは、どんな環境でどんなライブラリやどんなデータ構造を使っているかで全然違うので、それに合せてください、としか言いようがありません。
　(1)－(1)libファイルで静的リンクさせるケース 　(1)－(2)objファイルで静的リンクさせるケース この２つは大体同じ意味です [exe ファイル ] obj を集めて作成します。 main関数が含まれているため、実行すると動作します。 exe ファイルを作成する際、実行されない関数等は含めません [lib ファイル ] obj を集めて作成します。 main関数が無い為、実行する事はできません。 当然全ての関数が lib ファイルに含まれます 上記を踏まえて再度 [exe ファイル ] cpp からコンパイルして作成された obj ファイルや lib ファイル内のオブジェクトから main からの一連の流れで 使用する関数を集めて exe ファイルを作成します libファイルにある実行されない関数等は含めません lib ファイルの中身のオブジェクトが exe の中に存在するので 静的リンクした事になります。 [dll ファイル ] obj を集めて作成します。 main関数が無い為、実行する事はできません。 当然全ての関数が dll ファイルに含まれます 内容は lib と同じですが動的リンクであるという点が違います。 [dll の lib ファイル ] dll から 作成する事が出来ます。 その libファイル内には、dll内の同名の関数の情報があり 中身は dllへアクセスする処理があるだけです 上記を踏まえて再度 [exe ファイル ] cpp からコンパイルして作成された obj ファイルや lib ファイル内のオブジェクトから main からの一連の流れで 使用する関数を集めて exe ファイルを作成します exe の中には dll は含まれておりません その為 exe のファイルサイズは小さく、dll が無ければ動きません
>基本的にはボタンのクリックイベントの中に書いています。 こちらでは問題ありませんけど…なにが　違うんですかねぇ…。 >フォームのインスタンスで実行するなら、 インスタンスではなくコンストラクタでした。 まぁ、InitializeComponent()を実行した後であれば、可能な……ハズなんですけど。 半角での名前は、大文字小文字は区別しないで動作してくれるようですが、 いわゆる全角と半角は区別するでしょうから、その辺りの違いですかねぇ……。
10点刻みっぽいので、 const char* seiseki[11]で、入力された点数(だよね？整数としか書かれてないけど)を10で割って…というのも。
/* これをそのまま提出すると おそらく呼び出し食らいます。 */ #include <iostream> #include <algorithm> #include <iterator> /* 文字を入力すると、文字列中のアルファベット大文字を小文字に変換するプログラ ム。 */ void one(char* first, char* last) { std::transform(first, last, first, [](char ch) { return ( ch >= 'A' && ch <= 'Z' ) ? ch - 'A' + 'a' : ch ; }); } /* 文字列を入力すると、文字を循環しているように見えるプログラム。 */ void two(char* first, char* last) { for ( char* start = first; start != last; ++start ) { std::rotate(first, first+1, last); std::cout << first << std::endl; } } /* 文字列を入力すると、文字が逆順になるプログラム。 */ void three(char* first, char* last) { std::reverse(first, last); } /* 上記みっつを呼び出す */ int main() { const int N = 80; char line[N]; std::cin.getline(line, N); char input[N]; std::copy(std::begin(line), std::end(line), std::begin(input)); char* first = input; char* last = std::find(std::begin(input), std::end(input), '\0'); std::cout << "---- [1]\n"; one(first, last); std::cout << input << std::endl; std::cout << "---- [2]\n"; std::copy(std::begin(line), std::end(line), std::begin(input)); two(first, last); std::cout << "---- [3]\n"; std::copy(std::begin(line), std::end(line), std::begin(input)); three(first, last); std::cout << input << std::endl; }
計算の過程が知りたいとき、部分的にデバッグ用に、printf() 文とgetch()　などを組み合せて追加し、処理の過程などを確認してみると良いでしょう。デバッグが終わったら、コメントにしてしまえばOKです。 for(k = 0; k < 4; ++k){ 　　　matC[i][j]+=matA[i][k]*matB[k][j]; 　　　printf( "matc{ %d ][ %d ] = %d\n". i, i, matc[i][i] ); 　　　getch(); デバッグが終わったら、コメントにする。 //　　　printf( "matc{ %d ][ %d ] = %d\n". i, i, matc[i][i] ); //　　　getch(); 色んな場所に上記の様なprintf（）を入れ込んで試してみてください。
追記: #1にあるscanf ですが、 scanf("%lf",&b) であり、 %lf は「空白(改行文字も含む)を読みとばしてから、数を読み込む」ものなので、今回は問題ありません。
> sdとvarは初期化されてないのですか？ 初期化子を書いていないのですから初期化はされません。 初期化子を書かないのは、無用な初期化を省く意図を表しています。
既存のものだけどこういうのはどうでしょうか？ http://hooktail.maxwell.jp/cgi-bin/mathimg.cgi
C言語の勉強はどれくらいやっているのでしょうか? forの()の中って「(n = 2; n <= k+1; n++)」これのことですか? for(式1;式2;式3) とあったら (1) ループ前に 式1 を実行 (2) 式2 が真だったら、ループ本体を実行 (3) ループ本体を実行したら、式3 を実行してから、(2)へ戻る です。よく見かける for(i=0; i< 10 ; i ++ ) とかと、まったく同じです。 ループの本体( {}の中 )も、順番に読んでいけばわかると思うのですが
とりあえず，一番簡単そうなのは ・イベントハンドラをasyncにする ・処理部分をasyncなメソッドに切り出す ・処理部分をawaitつきで呼び出す 方法でしょうか (VS 2012以降)。 または，.NET Framework 2.0以降用ですが，BackgroundWorkerを貼り付けて， ・WorkerReportsProgressプロパティをTrueにする ・DoWorkイベントデータ処理コードを書き，ループごとにReportProgressを呼び出す ・ProgressChangedイベントでデータをlistView1に設定する というのもありだと思います。 一時停止は，UIから要求するものの場合だと，ManualResetEventのインスタンスを用意して，最初にSetしておき， ・処理部分の最初でWaitメソッドを呼び出す ・一時停止を要求するタイミングでResetメソッドを呼び出し，解除するタイミングでSetメソッドを呼び出す で対処できます。 ANo.2さんの書かれているApplication.DoEventsは，長時間処理の対策として推奨されません。 MSDN: Application.DoEvents メソッド (System.Windows.Forms) http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.100).aspx ※解説の「注意」を参照。
read_file関数内のreturnに、0とか1とかはいらないと思う。 intを返す関数じゃないので NO1さんの言う通り、続きはご自分で書くことをおすすめします。
▼whileで繰り返すブロックはscanf()までではなくa==1,2,3,4の判定も含みます > while(1) > { > 中略 > scanf("%d",&a); > } ▼この箇所だけ変数名 a が全角文字 > if (ａ==2){ > p_all(); > } ▼ 誤× fscanf(fp,"%c %d %lf",data[cnt].name,data[cnt].height,data[cnt].weight) 正○ fscanf(fp,"%s %d %lf",data[cnt].name,&data[cnt].height,&data[cnt].weight) ▼戻り値はvoidだと関数定義したなら，単にreturn;あるいはreturn文を書かない > void read_file(void) > { > 中略 > return 0; > } 以上のような凡ミスはあるものの， 提示されたコードを見るかぎり，プログラム言語の文法は分かっており，何をすべきかそれをどう書くかも分かっていらっしゃるように思います。 「(3) 特定データの表示」機能もある程度ご自分でコーディングできるのではないですか。 質問に対して一言のお礼すら返さない質問者は好みではないので，とりあえずこの辺で。
http://oshiete.goo.ne.jp/qa/8173160.html の私の回答No.5 http://oshiete.goo.ne.jp/qa/8173160.html の回答No.2
プログラムは、サンプルコードをコピー＆ペーストすれば出来上がるというものではありませんので、質問を連投せずに、この質問内で分からないところを確認されて、理解した上でコードを書いて行ってみてください。。 回答いただいたアドバイスで、どの辺りが分からないのでしょうか？ 入力された数値をif文で判定して、 while( 1 ) {　　　　// while文を無限にしておいて、ループ中に入力された内容によってbreakさせる。 printf( …　（中略）　… 　　scanf( …　（中略）　… 　　if (a==1) 　read_file(); //　ファイルの読み込み 　　if (ａ==2)　 p_all(); // 全データの表示 　　// if (a==3) （個別データの表示。これは未だ作られていないので、後で追加） 　　if (a==4) break; // while(1) を抜けて終了する。 } の様に組めば動く、というアドバイスです。３番の処理はちょっと込み入った処理になるので後回しにするとしても、まずは、ここまでをやってみてください。 多分、このままコンパイルすると参照が解決していないので、エラーがワーニングが出るとは思いますが…参照の解決をするために、コードの置き方を、read_file()の本体、p_all()の本体の後に、main()を置いてみてください。 int read_file(void) { …（中略）　… } inte p_all(void) { …（中略）… } int main(void) { …（中略）… } こうすれば、関数の参照のエラーはクリアできます。 まずは、ここまで。
Nortonさんを一時的に黙らせる http://communityjp.norton.com/t5/forums/forumtop … 一時的に黙らせても、根本的な解決にはならないですが…。
＞キーの優先順位をb>a>cにするにはどうしたらよいでしょうか。 int tmp1 = test1.b; /* b を基準とする */ int tmp2 = test2.b; return tmp1 - tmp2; を int tmp1 = test1.b; /* b を基準とする */ int tmp2 = test2.b; if (tmp1 != tmp1) return tmp1 - tmp2; /* bが不一致なら、その結果を返す */ tmp1 = test1.a; /* bが等しい場合のみ、次に a を基準とする */ tmp2 = test2.a; if (tmp1 != tmp1) return tmp1 - tmp2; /* aが不一致なら、その結果を返す */ tmp1 = test1.c; /* bもaも等しい場合のみ、次に c を基準とする */ tmp2 = test2.c; return tmp1 - tmp2; に変えれば良いです。 d、e、f…と増やしたければ、同じように「優先するキーが不一致なら不一致と返し、一致した場合は次に優先するキーを比較」というのを、優先順位に合わせて繰り返しましょう。
そちらで #include <stdio.h> #include <windows.h> int main() { ULONGLONG x = 1; double y = (double)x; printf("%f\n", y); return 0; } はコンパイルできますか?
> 詳細については・・・ > これを見逃していたのです。 なるほど、確かに軽く眺めるだけではそこは見逃すかもしれないですね。 ただ、sprintfの仕様にまではたどり着いていたわけですから、 全く検索できなかったわけでも無いと思います。 今回知りたかったのはsprintfのパラメータの仕様なのですから そういう意識でパラメータという節に注意して読めばたぶん見つけられたのではないかと思います。 （私はそんな感じで情報を辿りました。） > 最初に5,460 件もヒットしていたので。 > どうやって探そうかとパニックになっていました。 これはとりあえず上の方だけ見ればよいですよ。 とくに、今回の場合1件目でsprintfの仕様がちゃんとヒットしてますからね。 普段Webページの検索結果見るときも 上位数件か多くても数十件しか見ないと思います。 （そして、それでも目的のものがなかったら他の手を考える。） > 検索文字を複数にしても%12I64uではヒットするはずはありませんからね。 これは難しいですね。 I64u とか I64 ならヒットしましたが、 何も分からない状態からそれをひらめくのはなかなか難しい。 まあ、分からないときに原典に当たるのは大事なことですし、 今回見つけられなかったことに懲りずに 分からないときはまた検索してみてください。
srandom(), random() は関数の仕様を良く読んでください。 % はモデュロ演算子と呼ばれ、四則演算と共に良く使われる演算子です。日本語では剰余演算子と呼びます。 http://www9.plala.or.jp/sgwr-t/c/sec03.html 試しに、r = random() % 10;　の　”%10”　を無くして、テストプログラムを動かしてみてください。 １／１０の確立で当たっていたものが、ほとんど当たらなくなります。 また、r = random() %　4　とかにすると、発生する乱数は、０～３までになります。
＃４さんの、keep の案をお借りして、ループが一回で済む形にしてみました。 for( i=0; i<N; i++) { fscanf(fp,"%d %lf", &x[i],&y[i]); printf("x=%d\n y=%lf\n",x[i],y[i]); if ( i==0 ) { // i が　０の時はmin と　keepに配列の先頭を代入 min = y[0]; keep = x[0]; } else { if ( min > y[i] ) { // i　が　１以上の時は、min と　y[i]　の小さい方をmin に代入 min = y[i]; // その時のx[i]を保存 keep = x[i]; } } }
> ０から９までの数字を入力しあたりかはずれかを表示するプログラム。 はい、そうなっているようです。 それで質問は何でしょう?
コンピュータ内では，数値も文字も命令も音声も画像もあらゆるものが0と1を組み合わせたbit列で表現されています。 10進数の65を，8bit長で表現すると，01000001です。 ASCII文字コードの'A'を，8bit長で表現すると，これも同じく01000001です（回答No.4，No.5で紹介されているリンク先を参照） charは，8bit長のデータ型です。文字(character)しか格納できないわけではなく，数値も文字も命令も音声も画像も，8bit長で収まるのであればどんなものでも格納できます。なぜって，数値・文字・命令・音声・画像というのはそれをどう解釈したかという結果の違いであり，コンピュータにとってはあらゆるものが0と1を組み合わせたbit列なので。 char c = 65; と書くと，8bit長の変数cには次のbit列が格納されます。 01000001 intは，32bit長のデータ型です（16bit長の場合もあります）。整数(integer)しか格納できないわけではなく，32bit長で収まるのであればどんなものでも格納できます。 int c = 'A'; と書くと，32bit長の変数cには次のbit列が格納されます。 00000000 00000000 00000000 01000001 -------- 「アルファベットの1文字が8bit長で表現できるのだから，1文字はあくまで1バイト(8bit)とする。漢字を使っている輩は，(私たち欧米人の)文字単位を複数並べて(漢字圏の)1文字を扱えばいい」 という方針は，ソフトウェアの国際化によって過去のことになり， 現代での基本方針は次のようになります。 「非アルファベット圏であっても1文字は1単位のデータとして扱えるべき。したがって国際化された1文字は8bit長以上のデータ型で扱うことになる」 プログラム言語の仕様は過去との互換性を維持する必要があるので，intという名を勝手に変えるわけにはいかないのですが，現在ではint型は文字を格納するためにも用いられています。
あえてウィンドウを出すという選択肢もあるかな. 特に「キーボードを変えたら動作しなくなった」とかいうアレな状況にはまりたくなければ.
指摘だけ: 「EOF かどうか」は読み込まないと分からないので, 「feof によるチェック」はしばしば不適切です＞#5. 通常は scanf系などで読み込むときに同時に確認する.
「試練」というほど、大げさなものではないです。 「Thread 1: signal SIGABRT」は、あなたがXcodeを使って、iOSアプリの開発を続ける限り、もっともひんぱんに遭遇するエラー表示です。原因はさまざまですが、スペルミスや、単純なミスがもっとも多いというのが、わたしの実感です。ソフトウェアのバグを、「バグ」と命名した最初の人は、賢明というか非情というか……。文字どおりしらみつぶしに、自分が書いたプログラムのバグを探してください。それは、おそらくすべてのプログラマ（プロからアマチュアまで）が経験し、文句を言わずやっていることです。 main.mで起きるエラーだから、プログラムが始まってすぐに発生したエラーと思われがちですが、そうではありません。どこのステップでも、そのエラーが処理されず、最後main.mにもどるまで、対処不明のエラーのままになっていると認識したほうがいいでしょう。 ちなみに「SIGABRT」は、「Signal Abort」の略だと思われます。信号がことごとく無視された、というくらいの意味です。
下記サイトのプログラムと見比べてみると、 > 2. b[x][y][a]=(円の式をb=～～の形にしたときの右辺)を行う の表現法がムダっぽいような。 x,y,r(半径)で計算してみては。 「Visual C++ 2010 Express を用いた易しい画像認識（２）」 http://homepage3.nifty.com/ishidate/vcpp10_r2/vc … 170x60くらいなら、C++で書いたプログラムで、1秒かからなかった。 スクリプト言語の中でもとくに遅いといわれる)rubyでも、1秒かからないですね。 # 640x480x(半径)40のデータでも10秒ほど。 参考URL：http://ideone.com/13V2Y3
無効にすればいいのでは？ 尤も、要望自体が矛盾している気がしますが...
「浮動小数点数」は単純に，小数点の位置が変わる数，という意味の言葉です。 Cの規格書では，添付画像モデルで定義される数とされています。 ※LaTeXの数式 x=sb^e\sum^p_{k=1}f_kb^{-k}, e_{\mathrm{min}}\leq e\leq e_{\mathrm{max}} を http://hooktail.maxwell.jp/cgi-bin/mathimg.cgi で画像化しました。 sは符号 (±1)，bは基数，eは指数，pは精度，fkは桁の値です。 同じく規格書の例には，IEC 60559のfloat/doubleの他，基数を16，精度6，eの範囲が-31以上+32以下という例もあります。 「倍精度浮動小数点数」は，ISO/IEC 60559 (ANSI/IEEE 754) のbinary64の通称です。 つまり，浮動小数点数の表現方法のひとつです。 # 実際の規格書までは目を通していませんので，規格書中で「倍精度浮動小数点数」という表現があるかもしれません。 なお，「浮動小数点数型」はfloat, double, long double, float _Complex, double _Compelx, long double _Complexそれぞれの型の総称です。 さらに，虚数型をサポートする場合はfloat _Imaginary, double _Imaginary, long double _Imaginaryの3つの型が加わります。 「倍精度浮動小数点数型」はCの規格書内に言葉として定義がありません。 ただし，double型の通称として使われています。
理由はscanfの動作仕様にあります。 %～で、取り込み方が違います。引数には、対応するものが必要です。 %dは「0～9の数字の列」を読み込んで「整数」に変換して「intへのポインタ」が示す場所へ書き込みます。 なので、対応する引数として、 int型の変数aへのポインタである「&a」を使います。 あなたが作ろうとしているプログラムは 「任意の1文字」を読み込んで「変換せずに」、適切な場所へ書き込む。 というもののはずです。「『0～9の数字の列』を読み込んで『整数』に変換」などされては困るのです。 そこで、scanfのマニュアルを読んで、 「任意の1文字」を読み込んで「変換せずに」取り込むには、%何になるのか? それに対応する引数には、どんな型が必要なのかを調べます。 例えば、 http://linuxjm.sourceforge.jp/html/LDP_man-pages … を見ると > c 「最大フィールド幅」 (デフォルトは 1) で指定された幅の文字の列に対応する。 次のポインタは char へのポインタ とあります。 よって ・「任意の1文字」を読み込むには、%c ・対応する型は、 charへのポインタ。 char c と宣言したなら、 &c だとわかります。また、\0が追加されない旨も書いてあるので、char s[2] → scanf("%c",s) 等と、\0用の領域を確保する必要も無いことがわかります。 scanfの仕様(というか、C言語の仕様)として、%の書式と対応する型とを一致させる責任は、プログラマにあります。 間違っていても、エラーにはなりません。(コンパイラによっては、警告が出ることはあります)
106,106の時にSendSizeBufが0以下になっていませんか？ その場合106,106 → 106,106 → 106,106...と無限ループになる論理だと思いますが・・
学習用のCコンパイラならMinGWがおすすめです。無料で使用できます。 http://sourceforge.jp/projects/mingw/ インストール方法やコンパイル方法は、ネットで検索すれば分かるかと思います。 ソースコードのエディタは、サクラエディタやNotepad++等、 無料で高機能なものがありますから、それらを使えばいいでしょう。
>正常コンパイルできなければできる機種をうまく移動して使う予定ですが、このように機種（CPU）またはマザーボードなどによってうまくいかないことはあるのでしょうか？過去パスカル勉強中でも機種によっては、動かないこともあり、学習の挫折にいたったことが度々あります。 CPUに依存したプログラムを書けないこともないですが、質問内容に書かれているプログラムにはそのような点はないです。 エラーメッセージからすると3,4で動作しているCコンパイラやリンカーが1,2とは異なるような気がします(エラーメッセージ的にはリンクするライブラリの指定間違いやCプリプロセッサのオプション指定間違いなのでCPU依存などとは関係ありません)。 1～4それぞれ色々なCコンパイラを入れていたりしませんか？ 1～4のそれぞれでコンパイル開始時から終了するまでに出力されるメッセージを見比べる事で何かわかるかも。
いま、ここに、30人の人間の個人データが、struct humane groupA[30]; で、実現されていたとします。 さて、これを、収入の高い人の順番で、ソートしたい場合に、ポインタ変数というものが、使えないのであれば、 結局、 struct humane rich2Poor[30]; に、結果は、なると思いますが、これだと、ソートの話は、おいておいても、元の2倍のメモリエリアがいります。 　さらに、ソートは、大変です。というのも、ポインタ変数使わなければ、大量のコピーが発生します。 さて、ポインタ変数を使って良いのなら、 　結果は、 　struct humane *rich2poor[30]; となりましょう。この場合は、元の領域＋ポインタ配列だけで、すみますので、サイズは、大幅に節約できます。 　さらに、ソートを行う場合も、structureの中身のコピー・移動がほとんど発生せずに行えますから、処理時間も 速いでしょう。ということで、ポインタを、使うと、処理が速くて、メモリの節約ができる場合が多いのです。
サブフォームのインスタンスで、this.Locationを実行した場合に取得されうる座標は、サブフォームの座標です。 サブフォームからメインフォームのインスタンスが参照できるようにしなければなりません。 どのようにフォームを生成しているのかがわからないので回答が困難ですが、 サブフォームからメインフォームのインスタンスを参照できるようにしなければ、サブフォームからメインフォームのLocationは取得出来ません。方法としては、メインフォームのインスタンスをセットするMainFormプロパティをサブフォームに設定するという方法が考えられます。
そんなもの規格には存在しないから, でいいのかな?
これで試してみてください。 #include <stdio.h> #include <stdlib.h> #include <math.h> #define MAX 1000 //最大繰り返し回数 #define EPS 1.0e-10 //収束条件 double f( double x ) { return( x*x - 2 ); } double df( double x ) { return( 2 * x ); } void newton(void) { int count; double a,newa; count=0; printf( "初期値を入力してください。\n" ); scanf( "%lf", &a ); while( 1 ) { count++; newa= a - f( a ) / df( a ); if ( fabs( newa-a ) < EPS ) { printf("解の値は %f\n収束するのに %d 回かかりました。\n", newa, count); break; } a=newa; if ( count > MAX ) { printf( "収束しませんでした。\n" ); break; } } } int main(void) { while( 1 ) { newton(); printf( "Repeat? <y> or <n>\n" ); if ( getch() == 'n' ) break; } return ( 0 ); }
VisualStudio2010ExpressEditionなのに、 >インストールしたのは、『sqlite-netFx45-setup-bundle-x64-2012-1.0.86.0.exe』です。 だから…てはありませんか？ ソレ、64Bitのビルド環境のあるVisualStudio2012用かと思われますが…。 sqlite-netFx40-setup-bundle-x86-2010-1.0.86.0.exe の方をインストールしてみてはどうですか？
初期化されてい変数があるのに、その変数を計算式で使っちゃダメでしょ。 とにかく全部の変数について初期化値を設定する。
> CDC dcMemory などを用意してBitBlt()で hBitmap から(CBitmap*)m_pBitmap に転送 ここで確保したメモリーを、解放してますか? あるいは 使い回すはずのメモリーを、画像を開く度に毎回確保してませんか? あと、pGdiBitmap->GetHBITMAP のあとで、ReleaseDCが無いようですが。
プログラムの結果の最後の行と重なって…その後に改行を入れてもダメですか。
処理の仕方自体はWCHARでもcharでも変わらないと思いますけど……。 http://www.crimson-systems.com/tips/t020a.htm とか。 charをWCHARへ、char *をWCHAR *への読み替えでOKなんじゃないですかね。 いまいちな例ですが…… 　OPENFILENAME ofn; 　WCHAR fileName[MAX_PATH]; 　fileName[0] = '\0'; 　ZeroMemory(&ofn, sizeof(ofn)); 　ofn.lStructSize = sizeof(ofn); 　ofn.Flags = OFN_ALLOWMULTISELECT | OFN_EXPLORER | OFN_HIDEREADONLY; 　ofn.lpstrFile = fileName; 　ofn.nMaxFile = sizeof(fileName); 　ofn.lpstrFilter = L"テキストファイル\0*.txt\0全てのファイル(*.*)\0*.*\0"; 　ofn.lpstrDefExt = L"txt"; 　ofn.nFilterIndex = 1; 　if(GetOpenFileName(&ofn)) { 　　WCHAR TargetFile[3][MAX_PATH]; 　　WCHAR TargetPath[MAX_PATH]; 　　int iCnt = 0, nPos; 　　ZeroMemory(TargetFile, sizeof(TargetFile)); 　　nPos = lstrlen(fileName) + 1; 　　if(fileName[nPos]) { 　　　// 複数ファイルが選択された 　　　lstrcpy(TargetPath, fileName); 　　　if(fileName[lstrlen(fileName) - 1] != L'\\') lstrcat(TargetPath, L"\\"); 　　　do { 　　　　// パスをコピー 　　　　lstrcpy(TargetFile[iCnt], TargetPath); 　　　　lstrcat(TargetFile[iCnt], &fileName[nPos]); 　　　　iCnt++; 　　　　nPos += ( lstrlen(&fileName[nPos]) + 1); 　　　} while(fileName[nPos]); 　　} else { 　　　// １つだけ選択された 　　　lstrcpy(TargetFile[0], fileName); 　　　iCnt = 1; 　　} 　　for(;iCnt > 0;iCnt--) { 　　　MessageBox(hWnd, TargetFile[(iCnt - 1)], L"選択ファイル", MB_OK); 　　} 　} 4ファイル以上選択すると吹っ飛ぶものになっていますが…まぁ、そこら辺はよろしく処理して下さい。 # あと…ローカル変数のサイズが……。
自分（OpenGL超初心者）も同じ症状になりました。 以下のように２か所を変更してみて改善されませんでしょうか。 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA ); →glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA ); display関数の最後に glutSwapBuffers(); を挿入 なぜシングルバッファでうまくゆかないのかは分からないのですが。
検索してみた感じ、 ＞ ld: 2 duplicate symbols for architecture x86_64 この前段階のエラーメッセージに、原因となった重複シンボル名が表示されているはずなので、エラーメッセージを補足したほうが回答が得られやすいと思います。 で、もしmainが重複しているようなら、選んだプロジェクトが悪かったのかも。
それだと、(1,2)=z にしたら、x[1]=zになって、x[1]=wが上書きされてしまいますね。 幅w,高さh、座標(x,y)で、 0≦x<w, 0≦y<h, だとして ・二次元配列を使って unsinged char pic[h][w] ; /* 1画素が8bitグレースケールの場合 */ pic[y][x]=color ; ・配列を使って unsinged char pic[h*w] ; /* 全画素分 */ pic[y * w + x]=color ; のいずれかが常套手段です。 このまま使うと、メモリ不足になる、コンパイルでエラーになる、といったケースがあります。 その場合は、malloc等で動的に確保してください。
一部誤りがありましたので訂正します。 解は減少関数の筈なので次の初期値で計算を始めてみて下さい。 y=1, y'=-1 x が大きくなった場合、yの値は0 に近づく筈ですね。 y=1, y'=-0.5; y=1, y'=-2; 等でも　xが∞に近づく時に　y=0　の解に近づきそうなので一意に解が得られるのか、 或いは一意に解が求まる為には、初期値や制約条件が不足しているのかも知れません。 何か考え落しがありそうに思えてきました。　 以上のような考えを参考に、数値計算を続けて正しい答が得られるように頑張ってみてください。
http://ironcat.info/tamabukuro/?p=93 イベントを処理するメソッド内で、senderのReadyStateプロパティを見ます。 http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.80).aspx http://msdn.microsoft.com/ja-jp/library/system.w …(v=vs.80).aspx readyState == WebbrowserReadyState.Completed が読み込み完了です。 この時のコントロールの状態は、 ・すべてのドキュメントがロードを完了している　です。
>もし、一体化できてもMCIを使うような簡単な命令で再生はできないでしょうか。 簡単な。というのがどの程度のレベルを指しているのかにもよりますが……。 リソースとして埋め込んで再生は可能なようです。 # PlaySound()でそういう指定が可能。 # http://www13.plala.or.jp/kymats/study/MULTIMEDIA … とか。 # SND_RESOURCEがキモでしょうかね。 MCIでやりたいとすると…リソースファイルをテンポラリなどにファイルとして書き出しして、それを指定する。 なんて事になるかと思われます。 # http://www13.plala.or.jp/kymats/study/MULTIMEDIA … デバイスタイプを指定すれば、エレメント名(ファイル名)の拡張子が違っていても動いてくれるんですかねぇ。 書き出したテンポラリファイルは使用後に自分で削除する必要があるでしょう。
>平滑化してからsobelフィルタをかけたものも作ったのですが、 >平滑化だけのものと、その後にsobelフィルタをかけたもので、 >差がありませんでしたなぜなのでしょうか・・・ 今度まともにソースすら見ていません ブログラムを2つに分けてみてください 平滑化のみを行った画像 平滑化を行った画像を使ってそーべる処理を行った結果 これを比較してください 多分動いてるんじゃないですか？ 両方まとめて処理した時に動いていないのは 動いていないのではなくて両方の処理したデータだけを 連続的に同じファイルに書いているからです
PENとやらの言語仕様書はたったの8ページ。 わからんもなにもないんじゃないかと。 # で、なんでCのカテゴリで質問するかな?
#include <stdio.h> int main(void) { int i, j, k; int a[2][2] = { {1,8}, {3,9} }; int b[2][2] = { {4,7}, {2,1} }; int c[2][2] = {0}; int max, min; puts( "matrix A =" ); for(j=0; j<2; j++){ for(k=0; k<2; k++) { printf( "%3d" , a[j][k]); } printf( "\n" ); } puts( "matrix B =" ); for(k=0; k<2; k++){ for(i=0; i<2; i++){ printf( "%3d" , b[k][i]); } printf( "\n" ); } puts( "AとBの積\nmatrix C ="); for(j=0; j<2; j++) { for(i=0; i<2; i++) { for(k=0; k<2; k++) c[j][i] += a[j][k]*b[k][i]; printf( " %3d" , c[j][i]); if( j==0 && i==0 ){ max = c[j][i]; min = c[j][i]; } if( max < c[j][i] ) max = c[j][i]; if( min > c[j][i] ) min = c[j][i]; } printf( "\n" ); } printf( "行列Cの最大値 : %d\n", max); printf( "行列Cの最小値 : %d\n", min); return (0); }
>で合っているということで良いのでしょうか？ だからOSはなんです？ と聞いているのですが……。 >(2)上述のUSBメモリの例でいえば、PCのUSBポートの状態を、０．１秒ごとに、ステータスを取得するOSのAPIをコールして、状態をチェックする。 今時のOSならわざわざポーリングしなくても通知する仕組みとかあったりしますよ。 WindowsならWM_DEVICECHANGEとか。 「WM_DEVICECHANGE USBメモリ 検出」辺りで検索すればコード例くらい見つかるでしょう。 LinuxならuDEVなどでの通知も受けられるでしょう。 「Linux USBメモリ 検出」辺りでも見つかるでしょう。 ポーリングの有無を除けば、大筋合っているとは思いますが。 ドライバやAPIの有無は判りませんが。 固有のドライバあったとしてAPIが公開されているか？って問題はありますしね。 # メーカーによっては契約することでAPIとか開示して貰えるかも知れませんが。
> その際、クラスCは、どうやってもZのメソッドや、Wのメソッドは書けない認識です。 dynamic_castでは解決にならんですか? > 逆に、XとYについては、それぞれ挙動の違う処理を行わせることができる認識です。 こんなこと訊くまでもないでしょう。やってみりゃわかる。 #include <iostream> using namespace std; class A { public: virtual void x() =0; virtual void y() =0; }; class B1 : public A { public: virtual void x() { cout << "B1::x()\n"; } virtual void y() { cout << "B1::y()\n"; } virtual void z() { cout << "B1::z()\n"; } }; class B2 : public A { public: virtual void x() { cout << "B2::x()\n"; } virtual void y() { cout << "B2::y()\n"; } virtual void w() { cout << "B2::w()\n"; } }; class C { public: A* create(int n) { A* result; switch ( n ) { case 1: result = new B1(); break; case 2: result = new B2(); break; default: result = nullptr; break; } return result; } }; void test(A* p) { p->x(); p->y(); B1* p1 = dynamic_cast<B1*>(p); if ( p1 ) p1->z(); B2* p2 = dynamic_cast<B2*>(p); if ( p2 ) p2->w(); } int main() { C c; A* p; p = c.create(1); test(p); delete p; p = c.create(2); test(p); delete p; }
> ◆非ポインタ版 > l_arr = a[0]; > ... > show_msg(a[index]); 済みませんが、元と等価なコードでないと、比較する意味が無いのですが。 全然違うコードで「intの方がいい」と言われても、「そのコードにはintがいいですね。で?元のコードはどうなんですか?」ってことになります。 px = x ; /* a[x] の添字をpxとして記憶 */ ... a[px] +=7 ; /* 上で記憶した a[px]へアクセス */ と、ポインタ使わずに書く方法もあるかもしれません。 ただ、この場合は、整数pxがポインタの代りをしているからできることです。 また、元が ポインタ→実体 と1ステップだったものが 配列の先頭→ 添字の分の計算 →実体 とステップが増えます。省メモリのつもりが、コードが増える可能性があります。 (また、実装や最適化によって違ってきますが) 単純すぎてピンと来ないなら、こんな例ではどうでしょうか。 int x,y,z,mode ; int * p ; ... /* 状態によって、次のいずれかになる */ if( mode==3 ) { mode=1; p = & x ; } else if ( mode==4 ) { mode=2; p = & y ; } else { mode=2; p = & z ; } /* x,y,z,mode はここで使用する */ image_out(x,y,z,mode); /* 上で選ばれた変数を +7する */ *p += 7 ; これ、int *pを使わずに、同じ動作をするコードにできますか? そのコードは、これより「わかりやすい」ですか? > redim l_arr[x]; Cに無い命令を使われても、エラーになるだけですけど。
> 今の時代で、なぜメモリに介入するようなレベルから部品を作るのか？ > それは企業から見て、投資対効果は得られているのか？ なら「Cを使わない」という選択肢もあります。 おっしゃる通り、昨今のPC事情を考えれば、ポインタのような低次元な操作をしなくても、十分に実用的な速度で動作します。 ですから、必要が無いなら、C言語ではなく、もっと「高級」な言語を使えばいいのです。 しかし、Cが有効な場面はあります。 ・効率をもっと上げたい ・ハードウェアを直接操作したい そういうときには、やはり、ポインタを使わざるをえない場面が出てきます。 あと。 ポインタが無い言語でも、内部ではポインタ的なものが使われています。 例えば、Javaのオブジェクトは、オブジェクトの場所を表わす参照値が使われています。 メソッド呼び出しでは、参照値が渡されます。 これは、直接操作はできないものの、「ポインタ」そのものです。
スロット付きアロハのプログラミングを教えてください。端末数は固定で,端末は各ス.. http://gjtulhda.appspot.com/184016/ 　これが本来の質問全文らしい。 参考URL：http://gjtulhda.appspot.com/184016/
WTSQuerySessionInformation http://msdn.microsoft.com/en-us/library/windows/ …(v=vs.85).aspx にWTSClientAddressを渡すことで取得できます。 *ppBufferをWTS_CLIENT_ADDRESS *にキャスとして使います。 なお，WTS_CLIENT_ADDRESS::Addressの先頭2バイトは読み飛ばす必要があるみたいです。 ちなみに，TS接続でなくてもAPI呼び出しは成功しますが，AddressFamilyが0なので，GetSystemMetricsを使わずに判断できそうです。 なお，AF_INETはWindows.h(というかWinSock.h)で定義されていますが， AF_INET6はWinSock2.hをインクルードしておく必要があります。 Windows 7だと，リンクローカルIPv6アドレスで接続している可能性がありますので， IPv6の可能性は捨てない方が良いです。 ---- 以下，適当サンプル ---- #define _CRT_SECURE_NO_WARNINGS #include <cstdio> #include <cstring> #include <WinSock2.h> #include <Windows.h> #include <WtsApi32.h> #pragma comment(lib, "WtsApi32") int main (void) { LPTSTR pBuffer; DWORD bytesReturned; if (!WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTSClientAddress, &pBuffer, &bytesReturned)) { return ::GetLastError(); } const WTS_CLIENT_ADDRESS & addr = *reinterpret_cast<WTS_CLIENT_ADDRESS *>(pBuffer); char message[512]; switch (addr.AddressFamily) { case AF_INET: std::sprintf(message, "IPv4 : %d.%d.%d.%d", addr.Address[2], addr.Address[3], addr.Address[4], addr.Address[5]); break; case AF_INET6: std::sprintf(message, "IPv6 : %x:%x:%x:%x:%x:%x:%x:%x", addr.Address[2] << 8 | addr.Address[3], addr.Address[4] << 8 | addr.Address[5], addr.Address[6] << 8 | addr.Address[7], addr.Address[8] << 8 | addr.Address[9], addr.Address[10] << 8 | addr.Address[11], addr.Address[12] << 8 | addr.Address[13], addr.Address[14] << 8 | addr.Address[15], addr.Address[16] << 8 | addr.Address[17]); break; case AF_IPX: std::strcpy(message, "IPX"); break; case AF_NETBIOS: std::strcpy(message, "NETBIOS"); break; default: std::strcpy(message, "unknown"); break; } std::puts(message); return 0; }
mc の型は何でしょうか？ MDIのクライアント領域＞MDI小ウインドウ＞MDI小ウインドウのクライアント領域 で小さくなっていきます。 PictureBoxは子フォームからはみ出してませんか？ Dockプロパティ、Anchorプロパティも参考になりそうなので合わせて示します。 http://woodbook.kir.jp/vblib/netlib/dock.html
単純には, 各処理に対して 「1回あたりの所要時間」と「実行回数」の積 を積算するだけ.
警告が途中までしか書かれていないので、どんな警告が実際に出ているのかが分からないのですが、 main.cppの69行目付近には何が書かれていますか？
Windowsの場合、普通に「Project1.exe」などのように、単なる「実行ファイル」として作成して、拡張子を「.exe」から「.scr」に変えれば良い。それを、C:\Windows\System32のフォルダに放り込むだけ。
＞まず、コードを見る限り、これは「配列のアドレスへの配列」と言えばよいのではないでしょうか 違います。 それを言うなら「アドレスの配列」か「『配列へのポインタ』の配列」です。 アドレスの指す先に、偶然、配列があるに過ぎないのです。 それに「への」の使い方も間違っています。「への」が使えるのは「○○へのポインタ」と言う場合だけです。 「○○へのポインタ」ってのは言い換えれば「ポインタが指し示すメモリの中身は○○型である」です。 「配列のアドレスへの配列」と言う、誤った表記を、上記のように言い換えると「配列が指し示すメモリの中身は配列のアドレス型である」と言う、意味不明な文章になっちゃいます。 「配列が指し示す」って意味不明です。「配列のアドレス型」も意味不明です。 と言うわけで。 実は「アドレスそのものは、自身が指すアドレスのメモリに、何があろうが感知しない」のです。 もし、アドレスの指す先が「配列」なのであれば、その「アドレス」は「配列へのポインタ」と言えます。 「アドレス」を「配列へのポインタ」に言い換えれば「『アドレス』の配列」と言う表記は「『配列へのポインタ』の配列」に言い換えられます。 ＞次に、配列のアドレスを格納するのであれば char 型にするべきではないでしゅうか（アドレスは16進数なので） char型にしたら「アドレスの指す先のメモリのデータは、char型である」になっちゃう。メモリの中には「intのデータ」が入っているのに、char型として取り出してしまって、変な事になる。 まず「アドレスは、型を持たない」と言うのを覚えましょう。 それに、アドレスは、16進数とは限りません。２進数で表現しても良いし、８進数で表現しても良いし、１０進数で表現しても構いません。何進数にしようとも「値は同じ」ですからね。 「アドレス」ってのは「一丁目です」って言ってるだけです。 一丁目に犬小屋(char）が建っているか、一軒屋（short）が建っているか、高層ビル（intの巨大な配列）が建っているかは「ちゃんと言わないと判らない」のです。 ＞最後に、使い方がわかりません ＞配列のアドレスを配列にして、どのように使うのでしょうか 一番簡単なのは「二次元配列の代わりに使う」です。
追記。 当然だけど、MS-DOS時代のTurbo CからはAPI関数は呼べないので、API関数を呼ぶライブラリを、アセンブラなどの他の言語で作成して、外部ライブラリとして呼び出ししないといけません。 なので、対象ファイルを「dir /X」で表示して、短いファイル名がどういうファイル名になるのか調べて、短いファイル名をfopenに指定した方が早いです。
＆演算子で求められるポインターは、条件によって違いますが、実行時のアドレスと考えてください。 http://wisdom.sakura.ne.jp/programming/c/c20.html 条件によって違うというのは、そのポインタが絶対アドレス（例えば、ハードウェアで既に決められているI/O空間とか、グラフィックメモリとか）に配置されているならば、それは絶対アドレスであり、事前に定義されるべきものですが、 相対アドレスである場合、例えば、ある変数のポインタであり、変数がメモリ空間上のどこに割り当てられるかはプログラムがロードされないと分からない場合は、プログラム実行時にアドレスが決まる、 ということになりますね。 C言語で記述して、中間言語（アセンブリ言語）などで出力してみたり、リンカー（ロケーター）などのMAPなどを出力してみたりすると、この辺りが良く理解出来てくると思います。 組み込み系をやられるのであれば、この辺りの知識は必須になってきます。 ご参考に。
＃３さんのアドバイス通りに組めば出来るはずです。 コーディングの例は、下記などを参考にすれば簡単に出来ます。 http://shiotani.cn/shiotanicnb4a/20111212cpptwo. … 問題は、近似値をどこまで小さくするか、あまり小さくしすぎると答えが返って来なかったりするので、上記のサンプルコードの様に繰り返し数の上限を決めるなど、工夫してみてください。 ご参考に。
GNU が嫌いじゃないなら gperf なんて手もあることはある.
おっと失礼。 #include <stdio.h> #include <stdlib.h> #define N (3) int main(void) { char *str = "456"; int cou[N], num, i; num = atoi(str); for (i = 0; i < N; i++) { cou[i] = num % 10; num /= 10; printf("cou[%d]=%d\n", i, cou[i]); } return 0; }
MAKEINTRESOURCE("IDD_DIALOG") → MAKEINTRESOURCE(IDD_DIALOG) IDD_DIALOG はリソースIDなんですよね？
>No.5の後者のだとうまくいかなかった（countは各kidoで初期化したい）ので前者のでいきました。 そんなことないだろ と思ってよく見たら　kido　と比較してましたね そりゃうごかんわ 失礼しました
erase() は削除した項目の次の項目を指すイテレータを返しますが、ループのインクリメント it++ によって、さらに次（削除された項目の次の次）のイテレータに移ることになります。つまり、削除された項目の次の項目は飛ばされてしまう、ということで。 ところで、erase() の後に書かれている cout << (*it)[0] << endl; は、削除された項目の次の項目（の先頭要素）を出力していますが、それは意図したものでしょうか？（ホントは削除されたものの値を知りたかったのでは？）
自分でマーシャリングすればできます。 -- 呼び出し側 -- using System; using System.Runtime.InteropServices; using System.Text; namespace MarshalTest { 　　[StructLayout(LayoutKind.Sequential)] 　　class Data 　　{ 　　　　private const int buffersize = 256; 　　　　[MarshalAs(UnmanagedType.I4)] 　　　　public int count; 　　　　[MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst = buffersize)] 　　　　public Byte[] data; 　　　　public Data() 　　　　{ 　　　　　　count = 0; 　　　　　　data = new Byte[buffersize]; 　　　　} 　　} 　　class Program 　　{ 　　　　[DllImport("NativeDll.dll")] 　　　　private static extern void test3([In, Out] IntPtr data); 　　　　static void Main(string[] args) 　　　　{ 　　　　　　Data[] data = new Data[4]; 　　　　　　for (int idx = 0; idx < 4; idx++) 　　　　　　{ 　　　　　　　　data[idx] = new Data(); 　　　　　　} 　　　　　　IntPtr result = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Data)) * 4); 　　　　　　IntPtr pos = new IntPtr(result.ToInt32()); 　　　　　　for (int idx = 0; idx < 4; idx++) 　　　　　　{ 　　　　　　　　Marshal.StructureToPtr(data[idx], pos, true); 　　　　　　　　pos = IntPtr.Add(pos, Marshal.SizeOf(typeof(Data))); 　　　　　　} 　　　　　　test3(result); 　　　　　　pos = new IntPtr(result.ToInt32()); 　　　　　　for (int idx = 0; idx < 4; idx++) 　　　　　　{ 　　　　　　　　data[idx] = (Data)Marshal.PtrToStructure(pos, typeof(Data)); 　　　　　　　　pos = IntPtr.Add(pos, Marshal.SizeOf(typeof(Data))); 　　　　　　} 　　　　　　for (int idx = 0; idx < 4; idx++) 　　　　　　{ 　　　　　　　　System.Console.WriteLine(Encoding.ASCII.GetString(data[idx].data, 0, data[idx].count)); 　　　　　　} 　　　　　　Marshal.FreeHGlobal(result); 　　　　} 　　} } -- 呼ばれる側 -- #include <Windows.h> extern "C" { #define MAX_DATA　　256 　　struct Data 　　{ 　　　　int count; 　　　　char data[MAX_DATA]; 　　}; 　　__declspec(dllexport) void __stdcall test3(Data *data); }; void __stdcall test3(Data *data) { 　　const char *text = "osite !! goo !!"; 　　for (int idx = 0; idx < 4; idx++) 　　{ 　　　　strcpy(data[idx].data, text); 　　　　data[idx].data[strlen(text)] = '\0'; 　　　　data[idx].count = strlen(text); 　　} }
環境（DR-DOS/TC3)が作れたので試してみました 参照フォルダの指定は Option　->　Directories　で設定できます ライブラリを追加したい場合は直接プロジェクトに追加してくださいProject　->　AddItem
DXライブラリはDirectXの上にかぶせるラッパーみたいなもの。できることは限られてくるけど、簡単に扱うことができる。 SDKはDirectXをそのまま扱う。非常に高機能な反面、複雑。 このような質問をしているレベルの方ですと、DXライブラリから入った方がよろしいかと。SDKをそのまま使うなら、質問せずに自力で何でも解決できる方でないと難しいと思います。 で、DXライブラリで不足している機能があればSDKをそのまま扱う事を検討してみるようにすれば良いのでは。
-(-6)になるから+6になる 別の書き方すれば　　bx *= -1; と同じ
四捨五入というか、まるめというか、目的によって使い分ける必要があります。 (1) 経済学的な分野では、負の値はマイナス方向に四捨五入した方が実感として良いと思います。 例えば、4.51万円の借金、つまりは-4.51万円は四捨五入によって-5万円にした方が-4万円にするよりも実感として良いわけです。 (2) 画像処理のような分野では、見た目が自然になる方が良いわけです。 例えば、x1=4.5とx2=-4.5の距離は実際には4.5-(-4.5)=9.0です。でも四捨五入によってx1=5、x2=-5にしてしまうと、計算上5-(-5)=10になってしまいます。この場合は-4.5は四捨五入によって-4にした方が距離は保たれて見た目に自然な結果になります。つまりこの場合はプラス方向に四捨五入することになります。 従って負の値をプラス、マイナスのどちら方向に四捨五入するかは分野によって使い分ける必要が出てきます。
前の質問で元の内容に対しての内容から話が広がっていくのでわざと静観していましたが 再度別質問立てたようなので改めて反応 >コンパイルが通るプログラムは作りました。 作ってないよね あなたは書いてあるものをコピーしただけ ざっと見ただけですがそこのHP記載のコードで既に読込・出力処理は実装されています 動かないのはあなたがその関数を使って無いからです 実際扱うファイル名の入出力（指定）処理は　あなたが別途処理を書いたうえで コピーした関数軍に適切なパラメータを受け渡してやる必要があります 実際行いたい処理はあなた自身が作成する必要があります 質問と行動見てると正直　　あなたのレベルがそのレベルに達していない感　　がします もっと基本的な勉強をすることをお勧めします
>しかし、そのフォルダからさらに、下のフォルダ内のファイルを指定しようと >そのString型の変数の後ろに「+=」を用いて、さらにパスを連結をしようとしたのですが、 >うまく連結できませんでした。 どういうコード書いたんです？ 戻り値がconstになっているわけではないようなので、普通に連結できるとは思いますが……。 # 掲示されたリンク先の通りなら…ですが。 # まぁ、その場合はString型ではありませんが。
public ref class Form1 : public System::Windows::Forms::Form { public: Form1(void) { InitializeComponent(); instance = gcnew XXX(); } ... private: XXX^ instance; ... } こんなカンジじゃないすかね、C++/CLIなら。
> Windows8 で、VisualStudioExpress2012forWindows8 を使用しています Visual Studio 2012 for Windows 8は使っていないのでよくわかりませんが... そもそもここでいうアセンブラとは何でしょう？ for Windows 8で、インラインアセンブラやml64などを使ってというのは、ちょっと考えられないのですが... クロスアセンブラか何かの話でしょうか？ サーバーについても結局よくわかりません。 もしかして、アプリケーションサーバーにアクセスしてPICなどのクロスアセンブラを実行し、出力されたロードモジュールを参考にクライアントを作っているとか？ 想像で補完すべき部分が多すぎて、まともな結論が導ける可能性はほぼありませんね。
状況は分かりました　　原因はその他の必要なところ見てないからです （ある意味人が書いたものそのままで自分で一切探そうとしてないからともいえる） http://www.mm2d.net/c/c-07.shtml ↑見て必要な部分を追加してください 少なくてもこちらの環境（VC6)ではコンパイルはできました 　　　　実際の処理があっているかまでは確認してません
#include <stdio.h> int main() { int a; char b; printf("整数を入力せよ a："); scanf("%d",&a); printf("文字を入力せよ b："); scanf("%c",&b); printf("%d %d\n", a, (int)b); return 0; } このコードを実行し、7を入力してエンターを押すと 7 10 と出力されます。 bは10、10は改行コードです。 つまり 「bの入力を待たずに入力しないままプログラムが流れて」 しまったのではなく、 「改行コードが文字として入力された」 のです。 > (1)と(2)の順番を逆にすると１つずつ入力できるのですが、 数字が得られるまで(改行,空白,タブ等が)読み飛ばされるからです。
VC++2010 Expressで適当なワードを入れたalice.txtに対して実行したら、total word.txtが出力されて無事に終了しました。出力が正しいかどうかは分かりませんが。 どのような入力ファイルで、どのような結果になったのか。正しく説明していただかないと回答するのは難しいでしょう。 何故メモリリークだと判断されたのかも分かりませんし。
>#define NMAX 80 >#define LMAX 5000 >char word3[LMAX][NMAX]; >char word1[NMAX]; >char word2[NMAX]; さらに >char word3[NMAX]; と…… まぁ、そうそうないとは思いますが環境によってはスタックオーバーフローするかも知れませんな。 ないとは思いますけどね……。 >char word3[LMAX][NMAX]; で、400000Byte。 >char word1[NMAX]; >char word2[NMAX]; >char word3[NMAX]; で240Byte。 その他の変数や引数、戻りアドレスとか積みますが……まぁ1Mありゃ十分だとは思いますけど……。 # Linux環境とかでulimit -s 256とかでもしてるとか？ 一連の質問シリーズの最初の方のだとバッファオーバーランしそうなコードはありましたが、今のだとそういうのはなさげ…ですよねぇ？？ 読み込むテキストファイルが1行80Byteを超えていた場合に期待する動作しない。というのはありますかね。 あとは…ShiftJISなファイルを読ませたときにstrtok()が妙なところでぶった切るかも知れない。 とかか？
これだけでは言葉遊びをしているようにしか思えません. 「配列は配列、ポインタはポインタとして扱う」というのがどういうことか, また「ポインタを配列にする」とか「配列をポインタにする」とかが何を意味するのか, 具体的にコードで見せてもらえませんか? 特に「扱う」と「する」との違いが明らかに分るような形で書いてください.
「コールスタック」の概念でしょうか。 http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC% … プロローグは、必要な情報をスタックへpushする。 エピローグでpushしたものをpopする。 要する情報には不十分かもしれません。その際は申し訳ありません。
（「読み込み」部分についてのみのアドバイス） #1補足＞どのようにすればよいのでしょうか？ 可変個のデータなので for文で回すのがよいかと。 下の２つの関数を、n, m を読み込んだ後で、呼び出して・・。 void DataInput( FILE *fp1, int a[][ COL ], int b[][ ROW ], int n, int m ) { int i, j; for( i = 0; i < n; i++ ){ for( j = 0; j < m; j++ ){ fscanf( fp1, "%d", &a[ i ][ j ] ); } } for( i = 0; i < m; i++ ){ for( j = 0; j < n; j++ ){ fscanf( fp1, "%d", &b[ i ][ j ] ); } } } void DataCheck( int a[][ COL ], int b[][ ROW ], int n, int m ) { int i, j; for( i = 0; i < n; i++ ){ for( j = 0; j < m; j++ ){ printf( "%3d", a[ i ][ j ] ); } printf( "\n" ); } for( i = 0; i < m; i++ ){ for( j = 0; j < n; j++ ){ printf( "%3d", b[ i ][ j ] ); } printf( "\n" ); } }
Column[index].HeaderTextを設定する方法ではなくて、セルの一行目を除外するのですよね？ http://dobon.net/vb/dotnet/datagridview/customso … 上記URLのSortCompareイベントを使用する方法が利用できると思います。 ソートの条件で2行目から判断するよう手動で書かなければなりませんが…。 http://msdn.microsoft.com/ja-jp/library/system.w … によれば、 e.RowIndex1が0の時は常にマイナスの値 e.SortResult2が0の時は常にプラスの値をe.SortResultプロパティに格納すれば、常に一行目を先頭にできると考えます。 それ以外の場合は通常通りのソート条件を実装します。
その1秒ごとの割り込みをどういうふうに実現しているかちょっと分からないのですが、 アセンブリを使えるなら、int 21h/AH=25hでint 08hの割り込みベクタを上書きし、 AL <- 0x34, OUT 0x43, AL AL <- 割り込み周期の下位8bit, OUT 0x40, AL AL <- 割り込み周期の上位8bit, OUT 0x40, AL の順でポートを叩けばいけるかと思います。 今回は500ms毎の割り込みを実現したいので、割り込み周期は59659ticks。これの下位8bitは0Bh、上位8bitはE9hですかね。 http://www.computing.dcu.ie/~ray/teaching/CA296/ … http://d.hatena.ne.jp/kobapan/20090506/1241618752 http://en.wikipedia.org/wiki/Programmable_interv …
>ただ、たったそれだけのために余分な紛らわしいプロジェクトを１つ追加してしまうことは、大人数で開発を行っている現場ではなかなか許されないのです。勘違いしてしまう人がいないとも限りませんから。 それをいってしまうなら、今の様な状態やその対処方法をふつうだと勘違いする人がいるかもしれないことの危惧もされた方がよいかと思いますが(正直いえば、紛らわしい対処方法をすでにやっておいて何をいまさらって感じ)
>gnome端末がデスクトップ環境です もうちょっとまともに環境書きましょうや。 Linuxだっていうならディストリビューションはなんです？ 少なくとも、CentOS6.xでは標準リポジトリにHandyGraphicsはないみたいですが……。 「HgWLine」で検索したら、 http://www.cse.kyoto-su.ac.jp/~oomoto/lecture/pr … こんなページを見つけた。 「HgWText」で検索したら、 http://sml.me.es.osaka-u.ac.jp/jse/kadai/sample0 … とか引っかかった。 大学関連でないとHandyGraphicsのライブラリとか入手できない…んじゃないですかね？ であれば、関係する大学生以外には回答もできないワケで……。 # だいたいHgwBoxFill関数の仕様すら不明なんですよ。 # ヘッダファイル掲示されれば、もしかしたら予想くらいは出来るかも知れませんが。(私はする気ありませんが)
ここだけだと C++用のライブラリがリンクできていないように見えます. 「省略」されたところに「どのようなコマンドでリンクしようとしたのか」は書いてありませんか? C++ コンパイラを使ってリンクまですれば C++用のライブラリもリンクしますが, ld でリンクする場合には明示しない限り C++用のライブラリはリンクしません.
うーん。それを調べられない人が中級とは思えないです。 検索すれば、すぐに出てきますよ。 DirectX9と比べるとDirectX10以降はがらっと変わっているので、結構違うと思ってもらって良いかも知れません。ただ、DirectX12以降がどうなるか非常に不透明なのでDirectX11を学んだほうがいいとも言えません。 少なくともDirectX11の機能が昨日今日やって人に使いこなせるとも思えないので、DirectX9からで十分では？
std::map<X, Y> の個々の要素は std::pair<const X, Y> で、イテレータも pair を指しています。 pair のそれぞれの要素は first, second メンバとしてアクセスできるので、 test* p = iterator->second; p->Term(); あるいは、同じことですが iterator->second->Term(); で実現できると思います。
>ｘを０で初期化 >ｘをパラメータとしてinput関数に渡す >５を入力 >ここでスタックには０がプッシュされたままで５がプッシュされる 実際に動かしてみた方がわかると思いますが……。 スタックがどうとかはこの場合関係ないです。 ローカル変数の値がどうなるか？です。 質問に掲示されたヤツだと…ポインタ使うのでそれぞれ下記のようにしてみてはどうですかね？ input_c(k.s); の前に printf("k.s Address 0x%p\n", k.s); でk.sのアドレスを表示してみる。 data = (char *)malloc( sizeof(char)*32 ); の前後で printf("data Address 0x%p\n", data); でdataの指す先がどう変化するか確認する。 sizeof()がおかしいのは既に指摘されてます。 # 配列のポインタを引数にして関数コールしてもコールされた側ではその配列のサイズを知る手段がありません。 # 引数でサイズも渡す。というのがよくある方法です。 >sscanf(data,"%s",data); 取り出し元と書き出し先が同一領域で問題ないのか？ については確認が必要かも知れません。 まぁ、仮に大丈夫だったとしても上記の処理では意味がありませんが。(ホワイトスペースで読み取りが終わる…かな？) ちなみに…input_c()の中でメモリリーク起きてます。 # malloc()で取得したヒープはいつ解放はてます？ # 答え：プロセスが終了した時にOSが回収する。 # 　　　じゃあ、プロセスが終了しない場合はどうなるでしょうかね。
開発環境や実行環境くらい書きませんか？ 「HgwBoxFill関数」などいわれても、どの環境にもあるような関数ではありませんので知らない人にとっては何の事かわかりません。 私は「HgwBoxFill関数」のある環境は存じませんが、円で角度でパーセンテージを表してたのを棒で高さであらわせるようにすればよいだけではないですか？
>そこで以下のメッセージが出て動作しません。インクルードファイルのリンクはしたつもりなのですが、参照できていないのでしょうか。 「インクルードファイルのリンクはしたつもりなのですが、」と書かれていますが、インクルードファイルはリンクするものじゃありません(正直質問を見たときインクルードファイルをシンボリックリンクかハードリンクでもしたのかと思いました)。 よくある勘違いの「ライブラリをリンクしたつもり」なのでしょうが、インクルードファイルをインクルードしてもライブラリは勝手にリンクされたりしません。 追加のライブラリディレクトリはライブラリを探すディレクトリを指定してるだけで勝手にそこから必要そうなライブラリを探し出しリンクする事もしません。
OSはWindowsでよろしいですか? setKeybrdが何を処理しているかわからないと、何を渡せばいいのか調べようがないと思いませんか? SendInputに渡すINPUT構造体に値を設定するのであれば、仮想キーコードとしてVK_KANJIというものがあります。これでうまくいくかどうかは、やってみたことがないのでわかりませんが。キーボードのデバイスドライバによって、キーの組み合わせが違う場合もありますし。
「出力ファイルが文字化けする」という表現からすると、アスキーフォーマットなのでしょうか？ ※正しく処理をしていれば、ヘッダ部分に情報があるので、判断できますが。 ヘッダの処理を別にしても、アスキーフォーマットだったら、fread() で読み込んで、単純に２倍すると、概ね文字化けします。 fread() は、バイナリ値としてデータを読みますから、それを、アスキーコードだと解釈して、その上で、２倍した値にする必要があります。 ヘッダの処理が不適切でされていなくて、ヘッダ部分も（バイナリとして）2倍しているので、フォーマットを壊しているのは、既に回答があるとおりです。
そもそも「その配列に値を入れることができるのか」ってところから疑問になるわけだが, そこは書いてないのでできるものとする. とすると, 以下のうちどこかに「できること」と「できないこと」の境界があるはず. どこまでできて, どこでできなくなりましたか? 1. int型の変数 x の値を表示する (最後に改行する) 2. int型の 2個の変数 x と y の値を 1行に並べて表示する (最後に改行する) 3. int型の 5個の変数 v, w, x, y, z の値を 1行に並べて表示する (最後に改行する) 4. int b[5]; にあるすべての値を 1行に並べて表示する (最後に改行する) 5. int b[5][5]; の値を 5×5 の形に表示する (最後に改行する)
訂正します。 strtokについては、 tp=NULL ; を見逃していました。
>このプログラムについてメモリリークになってしまうのですが どうやってメモリリークと判断されたんですか？ >確保していないメモリー領域に代入しているのが原因らしいのですが その原因(確保していないメモリー領域に代入している)はどうやって調べたんですか？ そこまでわかっているなら、どこを直せばいいかもわかってそうな気がしますが。 #1でもあげられている >free(tp); は、何をfreeしているつもりなんでしょうか。 #メモリリークといわれてるのは、たぶんここなんだとは思いますが。 また >k=l=strlen(word2)-1; >if(word2[k]==('\'' & l)){ も何をやってるつもりなのかさっぱりわかりません(文字"'"とword2の長さのandをしてどうするつもりなんだろう)
あとはもう、現象が発生する最低限のソースを、とぐらいしか。
「ワード境界（word alignment）」という単語についても お調べになってみるとよいかもしれません。
やはりEclispeでしょう。 何でも扱えます。 無料でここまで出来るのは開発者には嬉しいですね。 しかし未だにCOBOLとか生き延びているのですねえ。 私がCOBOLを仕事で扱ったのは一度だけ。 COBOLしか出来ないという人が開発途中で放り投げたプログラムを引き継いだ時です。 需要が少いけどLispがいいですね。Eclispeで扱えます。 問題解決を考える時に、私には日本語で考えるより速く考えられるのがLispだけ。 しかも何倍も速く考えられました。 もっともそうなるまで1年くらい書き続けていましたけど。 Eclispeは日本語というキーも含めて検索されるといいです。
ソースを見て回答します。HtmlNode.cs、HtmlAttrribute(Collection).csを見る限り、難しそうです。メソッド、コンストラクタともに標準では提供されていないため、独自にクラスを継承、（必要ならばオーバライド）するなどして作成するしかないためです。 理由はHtmlAttribute,csにて、初期値を設定する際に、ダブルクオーテーションで作成するよう定義されており、属性を新規作成する際に、独自のHtmlAttributeを設定する手段も提供されていないためです。 また、HtmlAttributeメソッドのコンストラクタは、QuoteTypeプロパティ（”または’）を設定する方法を提供していませんし、 HtmlAttributeColletionクラスも属するHtmlAttribute型インスタンスのQuoteTypeの一括変更を行うメソッドを提供していません。 実現はできたそうなので、独自に、一括してリプレースするメソッドを定義する方法が考えられます。
表示が鏡面状に反対になるだけで、それ以外の違いはありません。 外積は、 c = a x b なら、常に c.x = a.y * b.z - a.z * b.y c.y = a.z * b.x - a.x * b.z c.z = a.x * b.y - a.y * b.x です。 たとえば、座標(1,0,0)をz軸中心に正方向90度回転すると、どちらでも(0,1,0)になります。 それだけです。 あとはxyzそれぞれどれを、上下、前後、左右と想定するのか違うだけです。
wchar_tをwchar_tのまま書き出したい場合，バイナリ列としてfwriteで描き出す必要があります。 以下，C/C++のファイル入出力系関数の仕様について。 Cのファイル入出力系関数は，ファイル自体はマルチバイト文字列である，という前提の関数です in ISO/IEC 9899:1999 Programming languages --C / 7 Library / 7.19 input/output <stdio.h> / 7.19.3 Files ---- 引用 ここから ---- 11 The wide character input functions read multibyte characters from the stream and convert them to wide characters as if they were read by successive calls to the fgetwc function. Each conversion occurs as if by a call to the mbrtowc function, with the conversion state described by the stream’s own mbstate_t object. The byte input functions read characters from the stream as if by successive calls to the fgetc function. 12 The wide character output functions convert wide characters to multibyte characters and write them to the stream as if they were written by successive calls to the fputwc function. Each conversion occurs as if by a call to the wcrtomb function, with the conversion state described by the stream’s own mbstate_t object. The byte output functions write characters to the stream as if by successive calls to the fputc function. ---- 引用 ここまで ---- 上記のように，規格上入力はmbrtowcで変換してwchar_tにし，出力はwcrtombで変換してcharにする，ということになっています。 この変換を避けるには，変換の入るwide character input/output functionsである fgetwc/fgetws/getwc/getwchar/fwscanf/wscanf/vfwscanf/vwscanf/fputwc/fputws/putwc/putwchar/fwprintf/wprintf/vfwprintf/vwprintf の使用を諦める必要があります。 # 2011年に最新のISO規格が出ているため，動作の破壊的変更もしくは補助するための別の関数が追加されているかもしれません。 char16_tなどがあるC++の世界ではどうかというと…… in ISO/IEC 14882:2011 Programming languages --C++ / 27 input/output library / 27.9 File-based streams / 27.9.1 File streams / 27.9.1.1 Class template basic_filebuf ---- 引用 ここから ---- 2 The restrictions on reading and writing a sequence controlled by an object of class basic_filebuf<charT, traits> are the same as for reading and writing with the Standard C library FILEs ---- 引用 ここまで ---- 上記のように，Cと同じように動作するように求められているため，こちらも状況は変わりません。
# ATLなのだから、CComQIPtr/CComBSTR /CComVariant といったクラスを活用した方が簡潔になるのでは。 IWebBrowser2*を得ているのだからDocument プロパティで取得するとか。 http://msdn.microsoft.com/en-us/library/aa752116 …
> LINK : fatal error LNK1104: ファイル 'user32.dll' を開くことができません。 肝心のエラー内容は最初に載せるべきかと。 RegisterWindowMessageやSendMessageTimeoutが呼び出せていないのだから上手く行かないのは当然ですよね。 > デバッガーが効かないので 状況が分かりませんが、OutputDebugStringにDebugView とか。
#1は破棄していただいて、 http://d.hatena.ne.jp/fskkoba/20130125/1359086781 のExp.4の事例はいかがでしょうか。 #1は、class属性の値を取得して、該当する値を検索すればよいかな、と思っておりましたが、 上記URLによると、SelectNodeでできる方法があるようなので、その方がずっと楽です。
Cでは基本的には出来ません。手動でガベコレするか、代わりに int* add_matrix(int* a, int* b, int size){ int i,j; for(i = 0; i < size; i++) for(j = 0; j < size; j++) a[i*size+j] += b[i*size+j]; return a; } というように、インプレイスで（追加の容量を使わないで）計算することによって メモリリークを防ぐことは出来ます。
プラットホームがわかりませんがLinuxなどvalgrindが使えるなら、valgrindで調べてみるとか。
まず、行列は回転は表現できても、回転量は表現できません。 たとえば、x軸を中心に2π回転したことを表す行列というのは単位行列になります。 そこから回転量をちょっと少なくしても単位行列から変化しないことは理解できると思います。 つまり、必然的に回転量＝｛回転軸＋角度｝という形で管理しなければならないということです。 回転軸＋角度をを行列に反映する方法はわかると思います。 あとは回転量の合成ですが、それにはクォータニオンを利用します。 クォータニオンには下記の特徴があります。 ・回転軸と角度からクォータニオンを作ることができる。 ・クォータニオンから回転軸と角度を得ることができる。 ・2つのクォータニオン同士の積は、2つの回転量を合成した回転量を表す。 上記を利用すると、回転量の合成が出来ることがわかると思います。 注意が必要なのは、クォータニオンも行列と同様に ある軸を中心に2πの回転を表すクォータニオン == ある軸を中心に0の回転を表すクォータニオン ということです。 これの対策としては、回転量の合成を行う前にスケーリングして正規化し、合成後の回転量に逆の変換を行うことで正しい結果を得ることが出来ます。
それにしても, qsort 嫌いなのかなぁ?
単にx=0、x=0.1、x=0.2、…、x=1.3、x=1.4、x=1.5として式に代入して、16個の値を求めるだけではないのかなあと想像しますけど…。
ピリオドに続く数字は精度を表します。 sに精度を指定した場合、出力する文字数を制限することになります。 たとえば、 printf("%.3s", "abcdefg"); とすると、abcが出力されます。 ピリオドのあとに*を指定した場合、精度を引数で指定することになります。 具体的には、 printf("%.*s", 4, "abcdefg"); とすれば、abcdが出力されることになります。
>　while( Flag == 0 ) >　{ >　　recv( *SendSock, Str, 5, 0 ); >　} このループはいつ終了するんでしょう？ ループ中にFlagは変化しませんから最適化で無限ループになっていたりしませんか？ recv()の戻り値は捨てていますが、クライアントが切断したらrecv()が0を返却していたりしませんか？ # その際『Str[]の内容は変化しない』のを受信し続けていると認識していませんか？ recv()で5バイト受信できない。ということも可能性としてはあり得ますがその辺りはどう考えていますか？ # 2バイト、3バイトと受信する可能性がある。 # まぁ実際にはないでしょうけど。
文字列リテラルが decltype で参照になるってことは, 参照に対する部分特殊化すればいい. 例えば template <class T> struct VT<T &> { /* 省略 */ }; で参照に対する部分特殊化ができると思う. さらに配列に対しても部分特殊化したければ template <class T, int N> struct VT<T (&)[N]> { /* 省略 */ }; とかでいいんじゃないかな.
同じく最後まで読んでません。 まぁ、パッと見で怪しいのは…… >sprintf(xp+strlen(xp)-1," (%d)",count); 辺りですかね。 バッファオーバーランが期待できそうです。 strtok()に関しては指摘されているとおり使い方がおかしい…ですね。 # 少なくとも期待する動作はしないでしような。
「VC++ 2010 Express 64Bit」で検索すると…いくつか見つかりますね。
> これを古い形 IServiceProvider::QueryService > 識別子が見つかりませんでした Shlwapi.h
設定ファイルであれば、xmlで書くのが最も一般的だと思います。 なぜ > 「CSVファイル→変換→バイナリデータ」 が必要なのかわからないのですが、ゲーム実行時にバイナリデータで設定を読み込みたいだけであれば、いちいちCSVを経由せずに、GUIで設定を編集、入出力するツールを作ることが多いと思います。
C/C++ネタなんですかね？ 「RX62N データシート」で検索すると、 http://japan.renesas.com/products/mpumcu/rx/rx60 … が見つかって、データシートのpdfを開くと、 ・イーサネット 　MAC 10/100 Mbps、 　全2重/半2重モードに対応(1ch) 　2Kバイト受信/送信FIFO付き専用DMA って表記が見つかりますけど…これではないんですか？ 貴方の手元にあるデータシートにも記載されていると思いますけど……。 # データシートも参照しないでいぢっている…とか？
（MFCのCAsyncSocketクラスではなく） Winsockを直接使うのであれば WSAAsyncSelect( ) による非同期ソケットを利用するのが一般的でしょう。 受信できる状態になったらウィンドウメッセージによる通知を受け取るので、その状態で recv( ) を呼び出せばブロックされることなくデータを取得することができます。
他のかたが指摘されているように１００バイトの領域で判断したほうがシンプルです。 char[13]にして８７バイトを節約する意味はないと思いますが、 ビットの操作の勉強をかねてということで回答いたします。 以下のようにして下さい。 ビット位置は左から０～９９で示しています。（１から９９ではありません） １回目は全体をOFFにしてから指定位置のビットをONします。 ２回目は全体をONにしてから指定位置のビットをOFFします。 -------------------------------------------------------------- #include <stdio.h> #include <string.h> //bitをONする。 //bdata:ビットデータ //bpos:onするビット位置(0～99) void BitOn(unsigned char bit_data[],int bpos) { int byte_ix = bpos / 8; int shift_bit = bpos % 8; bit_data[byte_ix] |= (unsigned char)(0x80 >> shift_bit); } //bitをOFFする。 //bdata:ビットデータ //bpos:offするビット位置(0～99) void BitOff(unsigned char bit_data[],int bpos) { int byte_ix = bpos / 8; int shift_bit = bpos % 8; bit_data[byte_ix] &= ~(unsigned char)(0x80 >> shift_bit); } //指定bit位置のデータがONかOFFかを返す。 //bdata:ビットデータ //bpos:ビット位置(0～99) //戻り値：1=ON 0=OFF int BitCheck(unsigned char bit_data[],int bpos) { int byte_ix = bpos / 8; int shift_bit = bpos % 8; unsigned char data = bit_data[byte_ix] & (unsigned char)(0x80 >> shift_bit); if (data == 0) return 0; return 1; } //bitを10桁区切りで画面に表示する。 //bdata:ビットデータ void BitDisplay(unsigned char bit_data[]) { int bit; int i; //見出し印字 printf("0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\n"); for(i = 0; i < 100; i++){ if ((i > 0) && (i % 10) == 0) printf(" "); bit = BitCheck(bit_data,i); printf("%d",bit); } printf("\n"); } int main(void) { unsigned char bit_data[13]; //全体をOFFする memset(bit_data,0x00,sizeof(bit_data)); //0,7,10,11,19をONする。 BitOn(bit_data,0); BitOn(bit_data,7); BitOn(bit_data,10); BitOn(bit_data,11); BitOn(bit_data,19); //ビット状態を表示 BitDisplay(bit_data); //全体をONする memset(bit_data,0xFF,sizeof(bit_data)); //0,7,10,11,19をOFFする。 BitOff(bit_data,0); BitOff(bit_data,7); BitOff(bit_data,10); BitOff(bit_data,11); BitOff(bit_data,19); //ビット状態を表示 BitDisplay(bit_data); return(0); } ---------------------------------------------------------- 実行結果 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 1000000100 1100000001 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0000000000 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0111111011 0011111110 1111111111 1111111111 1111111111 1111111111 1111111111 1111111111 1111111111 1111111111
関数の引数としては、配列ではなく、配列の先頭アドレスをポインタとして渡すことになっています。 sizeofはポインタの大きさになって、配列の大きさにはなりません
HTML 5自体，それを意識してパースしなければいけない構造にはなっていないはずですが……。 とりあえず，使えそうな物を。 ・mshtml IEのコアを利用。 標準で入っている 独自のオブジェクト構造で取り扱う COMなのでMarshal.ReleaseComObject祭りかつマルチスレッドとの相性があまりよくない。 ・Html Agility Pack https://nuget.org/packages/HtmlAgilityPack 独自のオブジェクト構造で取り扱う ・SGMLReader https://nuget.org/packages/SgmlReader XMLReaderの代替として利用 (XMLDocmentやXDocumentのLoadで利用)
Win32アプリケーションで作成して… ・ウィンドウを作成しない。 ・非表示ウィンドウを作成する。 とかで可能かと。 コンソールアプリケーションで作成すると、起動時にコマンド プロンプトが起動するかと思われます。 # 別アプリから標準入出力と標準エラー出力をパイプを使って入出力するように起動すればコマンド プロンプトなどは起動しないと思われますが。 >SetTimer(1,1000,NULL) これだとウィンドウは必要ですよ？ WM_TIMERを受け取る為のウィンドウが必要です。 # MFCのCWnd::SetTimer()を使っていた場合、ウィンドウを作っている意識はないかも知れませんけどね。 # CWndから引っ張ってきたHWND使っています。 んで、MFCなどでSetTimer()使ったとしても… >Wihile(1) ;で待機 で無限ループするのはいかがなものかと。
ああ、確かにMinGW入ってますね、失礼しました。 ただ、これはパッケージに含まれているだけなので、インストールしないとpleiadesば認識しないはずです。
D3DXMatrixRotationAxis で任意軸回転できるのでそれでどうでしょうか。
> MAX値から前回値を引いた値を、現在値に加算 なら、 差 = MAX値 - 前回値 + 現在値 ですが、 MAX = 0xFFFF 前回値 = 0xFFFF 現在値 = 0x0000 の場合、 差 = 0xFFFF - 0xFFFF + 0x0000 = 0 正解は1なので、結果の良し悪しではなく間違いです。 正しくは、 差 = MAX値 - 前回値 + 現在値 + 1 です。 ただし、#1の方のとおり、オーバーフローを利用すれば、常に 現在値 - 前回値 で問題ありません。
// 抽出した文字列から XmlDocumentオブジェクトを構築 XmlDocument oXml = new XmlDocument(); oXml.LoadXml("<table>\n" + "　<tbody>\n" + "　　<tr>\n" + "　　　<td>テスト1</td>\n" + "　　　<td>テスト2</td>\n" + "　　　<td>テスト3</td>\n" + "　　</tr>\n" + "　</tbody>\n" + "</table>\n" ); // SelectNodesでXmlNodeListオブジェクトを取得して XmlNodeList oSel = oXml.SelectNodes( "table/tbody/tr/td"); // 3番目の要素を検証といった具合かと if ( oSel.Count > 2 ) { 　　string ss; 　　ss = oSel[2].InnerText; } といった具合で
その昔、void *がまだなかった頃、今ではvoid *を使うような場面ではchar *を使ってましたので、その名残かと。
なんかヘッダを #include し忘れてるんじゃない?
＞printf("整数を入力してください："); ＞scanf("%d",&m); ＞printf("何乗しますか？"); ＞sum = power(n,m); nを入力していない、という点については、 他の回答者さんからの回答のとおりです。 質問者さんは、「mをn乗したい」のですか？ それとも、「nをm乗したい」のですか？ なお、#1さんの回答はでたらめなので、信じてはいけません。 ＞＞int main() ＞ではなく void main() main関数の戻り値はint型であるのが正しいです。 質問者さんのコードにおいて、main関数から returnしていないことの方が問題ありです。 ＞kotae = m ^ n; ＞でよろしいのでは？ C言語にべき乗の演算子はありません。 ^ は、べき乗ではなく、別の意味を持っています。
まずは、「メールでないといけないのか」をよく考えましょう。 > httpということは、perlか何かで送信部分を書いておいて、クライアントからそれにメッセージを送り、perlやPHPに送信部分を任せるということでしょうか？ 送信ではなく受信側です。 あなたが作っているアプリに、ブラウザの代りにフォームに送信する機能を持たせます。 受信側では、HTMLを出力する必要はありません。OK/NGの反応くらいはあった方がいいと思いますが。 どのPCからでも特定のURLへアクセスするので、今問題にしているようなことは起こりません。 > sendmailはperlのものです。 Perl本体にsendmailはありません。 先に書いたような追加モジュールを使うか、UNIXやLinux等のOSにインストールされたsendmailコマンドを使うか、です。 細かい点は省くと。 UNIXやLinux等のOSでは、一つのマシンを複数のユーザーで同時に使うことを想定しています。 Windowsと違って、メールはOS標準の機能です。 そのため、通常はマシンの標準の設定を使って送受信するようになっています。 sendmailは、「SMTPを指定しない」のではなく、「既にSMTPが指定してある」状態なのです。
MSDNに参加すればソースの入手も可能かもしれないけど、そんなことをしなくても所望のことは可能ですよ。 例えばWindows7のペイントならALT・H・Pと順に押せば鉛筆を選択できます。 ALT・H・E・Rなら消しゴムです。 これをマクロ登録可能なキーボードに登録しておけばいいのです。プログラムの知識も必要ありません。 ゲーム用のキーボードなら何十個もマクロ登録できますから、メニューのほとんどの操作を1ボタンで実行できます。 プログラムはプログラムで、別のアプローチをお勧めしますよ。
Kinect for WindowsはWindows 7以降に対応しており，Windows XPは対応していません。 http://www.microsoft.com/japan/presspass/detail. … http://msdn.microsoft.com/en-us/library/hh855359 … よって，Windows XPでは開発も実行も，そもそも接続自体が公式に対応していません。 さらに，Kinect for Windows SDKはVisual Studio 2010または2012を対象としているため，Visual Studio 2008では開発できません。 http://msdn.microsoft.com/en-us/library/hh855360 …
２問目は回答が出ているようなので、１問目の参考例を書いておきます。 #include <time.h> _Bool leap_year(int year) { 　　struct tm t = { .tm_year = -1900 + year, .tm_mon = -1 + 2, .tm_mday = 29 }; 　　if (mktime(&t) == (time_t)-1) 　　　　return 0; 　　return t.tm_mday == 29; }
WindowsのAPIを使って全て手書きでGUIまで書くこともできますが、面倒なので普通はしません。 代わりにC++用のGUIフレームワークを使います。 VCならMFCというフレームワークが入っており、当然GUI設計用のツールもありますので、その場合はVBのようにGUIを設計できます。 最近はC++でGUIを作るにはQtというフレームワークが人気ですが、それも同様に通常はGUIデザイン用のツールを使い、自分でコードを書いたりはしません。
基本的な質問ですね。 今から初心者のうちからやたら聞こうとすると、自分で解決しようとする力と解決する努力を養う努力をしないと 将来困ると思いますが・・・。 プログラムは楽しいものです。
学校の課題でしょ？ ここで手伝って貰えれば楽だろうけど、君自身の為になるのかな？ 丸写しのソースコードで何か障害があったり、課題(仕様)の一部を変更した問題を出されたら君はどうする 自分で考えたモノなら自分の手で手直しも可能だろうけど 丸写しじゃ手も足も出ん、コピペしたのがバレバレじゃん
提出した結果のステータスがコンパイルエラー（Compile Error）だったということですか？ （Wrong AnswerやPresentation Errorではなくて？） Presentation Errorであるなら、出力の最後に改行 "¥n" を入れるようにすればよいのでしょうが…。
ファイル名を入力するときに C:\ABC\DEF\20130603.c のようにフルパス名で入力してみたら？
Label1コントロールのみでは無理かもしれないですね PanelコントロールにLabelコントロールを貼り付けておいて スクロールはPanelに任せるって方法ならいいかも LabelのAutoSizeプロパティをTrueに PanelのAutoScrollをTrueに LabelのLocationを 0,0に LabelとPanelのHeightを同じに といった具合に設定してやれば ご希望に沿うような感じになりそうですよ
PreTranslateMessage() は言わばポストされたメッセージの横取りに相当するので、Enter押下を検出したら戻り値TRUEを返すようにすれば、本来の処理（EditコントロールにEnter押下を通知する）は行われなくなります。
念のためだけど, これは「shared_ptr だからできる」ってわけじゃないよ. ほかの人も書いてるけど, 「ただのポインタ」でも (この部分については) まったく同じように動作する.
http://dobon.net/vb/dotnet/datagridview/progress … DataGridViewCellクラスから派生させて作れば一応は可能…っぽいです。 描画からデータの保持など、ほぼ全て自分で面倒見る必要があるかも知れませんが。 # 複数のコントロール乗っていた場合、キーボード操作したらどうなるんでしょう？ # フォーカスの移動とか。
「error C2001: 定数が 2 行目に続いています。」というエラーメッセージ自体は, 6行目の "引数があります" の最後の " が認識されていないことによります＞#8. まじめに文字コードを追っていないのでてきと～に書きますが, 最後の「す」の 3バイト目とそのあとの " で Shift_JIS における 1文字と認識されているっぽいです. 一方もともとの問題はさらに微妙で ・俗にいうところのBOM がないために Shift_JIS と認識されている ・コメントの最後の「場合」の「合」とそのあとの文字がまとめて 1文字と認識されているっぽい ・結果, 改行コードが LF だとこのが「合」の 3バイト目に食われて見えなくなってしまう ・つまり, 次の if～ の行もコメントの中にあると勘違いされている ということによると推測されます. 実際, (2010 ですが) プリプロセッサの結果を見ると見事に if～ の行まで消えています. 試してみると ・改行コードを CRLF にする→if～の行がきちんと認識される ・コメントを /* 引数が指定されていた場合 */ とする→同上 ・コメントを /* 引数が指定されていた場合*/ とする→if～の行は無視され, 最後までコメントの中にあると勘違いされる という結果になります. 余談ですが, もともとのソース (改行は LF) に対して cl でコンパイルすると hoge.c(5) : error C2001: 定数が 2 行目に続いています。 というエラーメッセージが出ます (エラー行を 5行目と思っている). IDE ではあたかも 6行目にあるように見えますが, メッセージを見ればわかるように IDE 自身は 5行目を示してい (るつもりになってい) ます.
検索すればソースコードは見つかると思います。 例えば http://hooktail.org/computer/index.php?2%BC%A1%B … とか プログラムを作るのが目的ではなく、計算するだけならImageJで画像処理ができます。 http://rsbweb.nih.gov/ij/ メニューにFFTがありますのでそれを使ってみてください。数値での入出力もできます。 フーリエ変換の結果は普通は複素数になるのですが、このソフトは絶対値をとっているはずで、普通はこれで十分ななずです。 複素数の結果が欲しいのなら http://www.r-project.org/ https://www.scilab.org/ http://www.gnu.org/software/octave/ などで計算できます。 画像から数値データへの変換は上記のImageJで可能です。
ん～.... 「オブジェクトの生成をmain関数ではなく他のファイルでしてそれをincludeする」ってのが何を言っているのかよくわからんです.... ・「他のファイルでして」ってのは「他のファイルでオブジェクトを生成して」ってことですか? そうだとしたら, 他のファイルの「どこで」生成するのですか? ・「それをincludeする」の「それ」とはどれですか? 何をしたいのか, イメージが見えてこない.
画像処理の研究をしているものです． int *img = (int *)malloc(sizeof(int)*640*480); とかならピッタリな気がしますが・・・． ただこの640や480という数字はおそらく，バイト単位で読み込むなりして ふつうは・・・ int *img = (int *)malloc(sizeof(int)*width*height); や int *img = (int *)malloc(sizeof(int)*cols*rows); としますね． ここで，widthは横幅，heightは高さ，colsは列数，rowsは行数を表す． さらに言うと本当は構造体などもちいますが・・・．本題ではないので略．
補足ですがXとYは以下のようにして取れるはずです。 Console.WriteLine(_frm2.Location.X); Console.WriteLine(_frm2.Location.Y);
TADOStoredProcコンポーネントを使います。 1. フォームにTADOStoredProcを配置します。 2. TADOStoredProcのConnectionプロパティまたはConnectionStringプロパティを設定して、データベースに接続できるようにします。 3. TADOStoredProcのProcedureNameプロパティに実行するクエリを割り当てます。 4. クエリが結果を返さない場合はTADOStoredProcのExecProcメソッドを使用してクエリを実行します。クエリが結果を返す場合はOpenメソッドを使用します。 詳しくはヘルプの「ストアドプロシージャタイプのデータセットの使い方」をご覧ください。 http://docwiki.embarcadero.com/RADStudio/XE4/ja/ …
ど～でもいいところにつっこむけど 2st 3st はなんかかなしい.
フォントの生成（CreatePointFont() や CreateFont() 等の呼び出し）を OnInitDialog() 以外の場所で行っていないでしょうか。もし OnInitDialog() だけでしか行っていないのであれば、GDIオブジェクトのリークはフォント以外の別の要因があるように思います。（それとも、プログラム起動中に何度もダイアログの生成と破棄を繰り返すような作りになっていたり…は、さすがにしないですよね） OnTimer() の処理は質問で提示されたもののみですか？ また、何らかの描画処理を OnPaint() などで自前で行っていたりしないでしょうか？ オーナードローを行っていたり、どこかで GetDC() を呼ぶ処理が入っていたりなどしないかについても確認してみてください。
端末からのキーボードからの入力は、1行単位でまとめてアプリケーションに送られることが多いです。 なので if(getchar() == '\n'){ の行で、1行分入力されるまで止ってしまいます。 入力待ちをせず、入力が無くても先に進むような方法を使う必要があります。 どの方法がそうなのか、というのは、プラットフォームに依存します。
＞for(i=0 , i<10 , i++){ ＞vb[10] = 2*va[10]; ＞} そもそも、[10]という、配列定義範囲外の領域を参照しようとしているのが間違いなのは、 別の回答者さんからのご指摘どおりです。 せっかく i というループ制御変数を使っているのに、 2倍するところにそれが出てこないことが不自然である、ということに 気づくべきでありましょう。
メモ帳で質問文のデータを打ち込んで、"hw.dat"として保存しているつもりだが、プログラムを実行するとファイルがオープンできない。 プログラムや実行方法が間違ってる訳は無いから、データが保存されていないに違いない。 …って事でしょうか？ ファイルの拡張子を.datにしたつもりでも、メモ帳が親切に"hw.dat.txt"って名前で保存してくれており、Windowsは.txtを表示しない設定になってるから、その辺が確認できないとか？ プログラムするのなら、今後も不便なので、登録されている拡張子もきちんと表示する設定に変更するのが良いと思います。 ファイル名拡張子を表示または非表示にする http://windows.microsoft.com/ja-jp/windows-vista …
MSDNに「CreatePointFont 関数を使って作成された CFont オブジェクトを使い終わったら、最初にデバイス コンテキストからフォントを選択して、それから、CFont オブジェクトを削除します。」と書いてありますので、CreatePointFont関数で作成したフォントの使用後、次のCreatePointFont関数を使用する前にオブジェクトを削除する必要があるのでは。 フォントを作成し続けて削除しないため、GDIリソースが足りなくなっていると思われます。
こんにちは。なんか、似たような質問の回答をしたばかりなような気もしますが、C言語の入門書レベルで書けるコードはこんな感じになると思います。このコードの少し面倒くさいところは、関数への配列のアドレスを渡すところです。この部分が少し捻ってある部分ですね。また、最後の名前を表示する部分については、名前＋成績を表示するように変えてあるので、"%d"と、成績の変数を取り除けば、課題どおりになります。なお、このコードはわざとデバッグ用の部分も残してありますので、いろいろいじって実行してみてください。その結果(コードが)壊れたら、またコピペすればよいだけの話です。 #include <stdio.h> #include <string.h> #define NUM 4 //4人分の配列を用意するので、マクロで置き換える //デバッグ用のマクロ(コメントアウトすると#ifdef～#endifの内容が無効になる) #define DEBUG struct seiseki{ char name[30]; int score; }; typedef struct seiseki seiseki; /* 各人の名前と点数を表示する関数の宣言 */ void showPeople(seiseki *list); /* 一番点数の高い者を調べ,その名前を表示する関数の宣言 */ void showMax(seiseki *list); int main(void) { seiseki list[NUM]; // 佐藤 80鈴木 75田中 95高橋 90 strcpy(list[0].name, "佐藤");list[0].score=80; strcpy(list[1].name, "鈴木");list[1].score=75; strcpy(list[2].name, "田中");list[2].score=95; strcpy(list[3].name, "高橋");list[3].score=90; // 配列名は、配列の先頭要素のアドレスを格納しているポインタと同じ働きを持つ。 // よって、配列名listを引数として関数に渡すだけで、 // 関数に構造体配列「list」のアドレスを渡したことになる。 #ifdef DEBUG showPeople(list); #endif showMax(list); return 0; } /* 各人の名前と点数を表示する関数の定義 */ void showPeople(seiseki *list){ int i; printf("%s\t%s\n", "name", "score"); for(i=0;i<NUM;i++){ printf("%s\t%d\n", list[i].name, list[i].score); } } /* 一番点数の高い者を調べ,その名前を表示する関数の定義 */ void showMax(seiseki *list){ int i; //ループ用 // パターン１用の変数(最大値を持つ配列番号の格納用) int maxArrayNum = 0; // パターン２用の変数 int max = 0; char name[30]; // パターン１は、最高点の人の配列のデータを直接使うやり方 // パターン２は、最高点が見つかるたびに別に用意した変数に // 名前と点数を上書きしていくやり方。お好きな方をお使いください。 for(i=0;i<NUM; i++){ if(max < list[i].score){ /* パターン１ */ maxArrayNum = i; #ifdef DEBUG printf("現段階の最高点は%sさん☆：\t%d\n", list[maxArrayNum].name, list[maxArrayNum].score); #endif /* パターン２ */ max = list[i].score; strcpy(name, list[i].name); #ifdef DEBUG printf("現段階の最高点は%sさん!：\t%d\n", name, max); #endif } } //パターン１を使った表示法。 printf("最高点は%sさん：\t%d点\n", list[maxArrayNum].name, list[maxArrayNum].score); //パターン２を使った表示法。 printf("最高点は%sさん：\t%d\n", name, max); }
>色々あるとのことですが、いくつか教えて下さい。 >厳密解を求められないことはわかっています。 ここで言う色々あるというのは「前提条件が分かっていて手の出しようがある」場合にはそれにあった方法でアルゴリズムを推定するのはできるでしょうねって事です。 世の中にあるありとあらゆる系を片っ端から当てはまるか確かめる、というのくらいしかこの問題の条件をクリアするのは思いつきません。 多分この手の問題の専門はプログラマ、エンジニアの領域では無く数学者の方が近いと思うのですが、どっちにしろまともな時間で(数兆年未満)とかでできるアルゴリズムは無いでしょう。 例えばある程度まとまったテストをすれば線形かどうか、時変かどうか、くらいはでるかもしれませんけど、それくらいが限界かもしれません。 ニューラルネットとかそれに似たヒューリスティックな問題用のシステムだとすれば、 それらのどちらかに属するかも判別困難です。メクラうちするしかないかもしれません。 私の知ってる範囲だけでもこれですので、私の知らない類の問題用のシステムであれば、やはり別なことも出てくるでしょうし。 条件付ける前の汎用的な段階での解法は私にはありません。 条件つけたなら各種推定アルゴリズムがあります。 という程度です、もっと良い回答が付くのであればそれは私も大変興味があります。
ループのための変数は別々に管理すべきでしょう。 あとこの場合なら while より for 構文のほうが適しているかと思います。 int i,j; for (i = 1; i <= count; i++) { 　for (j = 0; j < i; j++) { 　　putchar('*'); 　} 　putchar('\n'); }
ちょろっと調べた 参考URL：http://social.msdn.microsoft.com/Forums/en-US/vc …
階乗の計算結果を素因数分解をすると、2の乗数が多く含まれていることがわかります。 5! = 2^3 * 3^1 * 5^1 10! = 2^8 * 3^4 * 5^2 * 7^1 15! = 2^11 * 3^6 * 5^3 * 7^2 * 11 * 13 計算機が扱う数は基本的に2進数ですので、 2のn乗(2^n) は 左シフトn回(1 << n) と同義です。 左シフトされるということは、下位nビットは必ず0ということです。 50! を素因数分解すると因数 2 の乗数は 32 以上なので、 下位32ビットはすべて 0 であり、 それより上位ビットはオーバーフローなので切り捨てられるので、 最終的な答えは 0 となります。
ld(1)のマニュアルを見る限り-l:foo.soでいけそうですが、gccがldにそのコマンドを渡してくれない場合は-Wl,-l:foo.soでやるしかないでしょうね。 参考までに http://linux.die.net/man/1/ld | -l namespec | --library=namespec (snip) | If namespec is of the form :filename, ld will search the library path | for a file called filename, otherwise it will search the library path for | a file called libnamespec.a. http://linux.die.net/man/1/gcc |-Wl,option | Pass option as an option to the linker.
Ｃ言語を理解できない人にはＣ言語でコードを書いても意味ないです。 そもそも公共の場で書くようなものではありません。 ハッキングは犯罪です。
>プログレスバーが終了するまえに”終了”が出てしまいますが >これはどうしてでしょうか？ 単純にタイミングの問題なんじゃないですかねぇ…。 >progressBar1.Value = e2.ProgressPercentage; でプログレスバーの値が書き換わりますが、再描画の指示がメッセージキューに積まれます。 で、その再描画を処理する前にRunWorkerCompletedが処理されてしまった。 ということかと。 実行している環境のスペック次第でそこら辺は変わるかも知れません。 # というかこちらではそんな事になりませんでしたし……。 MessageBox.Show()の前にprogressBar1.Update()とか入れてみたらどうなりますかね？ # まあ、このタイミングで再描画強制できるかどうかは不明ですが。 # button1.Enabled = true;でのボタンの再描画は走っているみたいですからイケますかねぇ…。 あと……テストだからいいかも知れませんが、DoWorkでResult設定した方がいいんじゃないですかね。
＞for文のところが実行されず そんなことはありません。 正しく実行した結果、nに何を入れてもdは50000のままなのです。
下のような作り方もあります。 プログラムの内容は独力で読解してください。C言語の入門書、文法書、Webなどで調べて。 #include <stdio.h> #include <string.h> struct seiseki { char name[30]; int score; }; struct seiseki search( struct seiseki best, struct seiseki *next, struct seiseki *end) { if (next == end) return best; if (best.score > next->score) return search(best, next + 1, end); else return search(*next, next + 1, end); } int main(void) { struct seiseki list[] = { { "佐藤", 80 }, { "鈴木", 75 }, { "田中", 95 }, { "高橋", 90 } }; size_t last = sizeof list / sizeof(struct seiseki); struct seiseki best = search(list[0], list + 1, list + last); printf("name = %s, score = %d\n", best.name, best.score); return 0; }
ちょっと面倒かもしれませんが、次のサイトにある正規表現の<sentense>に当たるところにご希望の文字列が入ります。 http://www.oborodukiyo.info/RE/VS2010/RE-Pickout … 希望するタグの所を見つけるのがちょっと大変かもしれませんが。 参考になれば。
エラーの場合を先に書くのが、私の好みです。 押しつけるつもりは全くありません。 あくまで参考です。 #include <stdio.h> #include <math.h> int main(void) { double x, y, z, s; printf("x ? "), scanf("%lf", &x); printf("y ? "), scanf("%lf", &y); printf("z ? "), scanf("%lf", &z); if (x <= 0 || y <= 0 || z <= 0 || x + y <= z || y + z <= x || z + x <= y) { printf("三角形にならない\n"); } else { if (x == y && y == z) { printf("正三角形\n"); } else if (x == y || y == z || z == x) { printf("二等辺三角形\n"); } else { printf("その他の三角形\n"); } s = (x + y + z) / 2; printf("面積は%f\n", sqrt(s * (s - x) * (s - y) * (s - z))); } return 0; }
uc_buff=c_buff ; では「符号有りと符号無しで型が一致しとらんぞゴルァ」と言う警告が出るので uc_buff=(unsigned char)c_buff ; と書けば良いでしょう。
＞char buff[12]; ＞buff[0] = 0xFD; ＞が代入されています。 ＞この値を ＞unsinged char buff_2[12]; ＞に代入したいんですが、何か方法はありますか？ なんでそんなアホな事考えた？代入なんかイラネエだろよ。 参照する時に、つまり、取り出す時に ほげほげ = (unsigned char)buff[0]; とか printf("%d\n",(unsigned char)buff[0]); とか「符号無しだと思って取り出せ」ってやれば済むじゃんよ。 「はじめてのC」でも読んで出直しておいで。
do { 　一行読む 　if ( それが'#' ) break; 　if ( それが数値 ) 合計に加算 } whle ( true ); 合計を出力
申し訳ない。 問題文に ＞正数を入力し って書いてあるから、０は入力させないようにしないといけないね。 すると、ANo.3のプログラムで正解だわ。間違った指摘してごめん。
mainという関数ヘッダや、セミコロンが不足して文法エラーのところがありますが、これはタイプミスかコピペミスでしょうね。 それら以外の、明白な誤りは6点。 ＜この問題特有＞ (1) 三角形が成立しているかどうかの判断を最初にすべき。正三角形や二等辺三角形の判断は、三角形が成立したときに限って行う。また、判断する前に面積を求めているが、三角形でない場合にsqrtの引数が負になって、そこでエラーになるかもしれないので、これも三角形判断後に行う。 (2) 三角形かどうかの判断基準がおかしい。 (3) 正三角形の判断で、AND条件(&&)と、OR条件(||)を間違えている。 ＜Cの使い方一般＞ (4) double値の変数なのにscanfの書式で %f を使っている。 (5) double値のprintfなのに書式で %d を使っている。 (6) scanfの戻り値をチェックしていない。 ＜その他の良くない点＞ (7) scanfは使いこなしが難しい関数なので、上級者の自信が付くまでは使ってはいけません。文字配列を定義して、fgets()でそこに入力して、sscanf() でdoubleに変換してください。sscanfも同様に戻り値のチェックが必要です。 (8) 標準出力にプロンプトを出している。これがなぜ良くないかは説明が難しいので、とりあえずわからなくてもいいです。 (4)(5)(6)のような間違いをするレベルの初心者の割に、プログラム全体としてはよく書けていると思います。
順番に考えていくのがいいと思います。 まず、配列に10文字格納します。 ループで配列の先頭に当たる部分から条件で任意の1文字と同じ内容か比較します。 同じものが見つかったら、配列の何番目が何文字目にあたるか表示する。 以上です。 同じ文字が入っていて先頭のものだけを表示したいなら ループの中で文字が見つかったら抜けるルーチンを組み込めばいいと思います。 VBに似たような関数があるのでそれをCで作られようとしているように感じますが・・・
・ライトを増やす ・鏡面反射の反射率をあげる ・鏡面反射の鋭さをあげる これらの調整を行うと若干は良くなると思います。
>補足にかけなかったのですがfor(;WaitForSingleObject(hProcess, 1000) == WAIT_TIMEOUT;) { >でfor文のループを回したらGetAsyncKeyStateを使えますが1秒で終了してしまいます で、今はどう書いているんです？ # まぁ、内容がアレなのでforループではなくwhileループでもいいんですけどね。 while(WaitForSingleObject(hProcess, 1000) == WAIT_TIMEOUT) { 　//終了待ちの間に実行したい処理(間隔はWaitForSingleObject()の第2引数の値次第) } って感じですかねぇ。
次が参考になりませんでしょうか。 http://www.oborodukiyo.info/Forms/VS2008/F-PassD … 要するに、変数を公開されたフィールドやプロパティにして、別フォームからアクセスすればよいかと思います。
A->xはchar型であって、char *型じゃないから なんですけど、そのプログラム、おかしくないですか? 最悪、プログラムがエラーで停止します。 (char*)A->x だと、 A->xに入っている「char型の整数の値」を、「メモリ上のアドレス」と解釈する ってことになります。 例えばA->x = 'a' だとすると、'a'の文字コードのアドレス(ASCIIの場合なら97番地)となります。 構造体Aとも、A->xとも、'a'という文字とも無関係な何かの領域です。
printf や scanf は標準ライブラリにあるから「Cの言語仕様」といっていいような気もするのだが＞#2, それよりは「ASCIIコード」の方が問題かな.
作りたいけれど作ってほしいという微妙な心理が盛り込まれた質問ですね。 Cのプログラムは自分で書いていただくとして、ヒントをかねてC++のプログラムを作ってみました。 #include <array> #include <algorithm> #include <numeric> #include <iostream> #include <iterator> #include <boost/iterator/counting_iterator.hpp> int main() { 　　std::array<int, 45> a; 　　std::copy(boost::make_counting_iterator<int>(1), boost::make_counting_iterator<int>(46), a.begin()); 　　std::random_shuffle(a.begin(), a.end()); 　　std::for_each(boost::make_counting_iterator<int>(0), boost::make_counting_iterator<int>(15), 　　　　[&a](int i) { std::cout << a[i * 2] << '-' << a[i * 2 + 1] << std::endl; }); 　　std::cout << std::endl; 　　std::copy(a.begin() + 15 * 2, a.end(), std::ostream_iterator<int>(std::cout, "\n")); }
＞if(n%2 = 0) C言語において、左右両辺が等しいかどうかを判断する演算子は = でしょうか。 == ではありませんか？
メモ帳はどうやって起動したものでしょうか? 単にnotepad.exeのプロセスを調べると、ユーザーが後から起動したものかもしれないし、メモ帳以外にもnotepad.exeという名前のものがあるかもしれません。 自身のプログラムで起動したメモ帳を監視したいのであれば、CreateProcessなどでメモ帳を起動したうえでプロセスハンドルを保存し、WaitForSingleObjectなどでプロセスの状態を監視するのが一般的だと思います。
>しかし、なぜなのでしょうか？ 1行ずつトレースしていけば判るかと思いますが…… ループ1回目(iの値は0)=> while((ret=fscanf(filepointer,"%f,%f",&s[0],&w[0]))==2){ ->ということでs[0]とw[0]に読み込み。 i++; ->iがインクリメントされて1になる。 printf("%d%f%f\n",ret,s[1],w[1]); ->値が未設定のs[1]とw[1]を表示する。 ループ2回目(iの値は1)=> while((ret=fscanf(filepointer,"%f,%f",&s[1],&w[1]))==2){ ->ということでs[1]とw[1]に読み込み。 　(s[1]とw[1]の内容は更新されるが、表示済みの内容を書き換えてはくれない) i++; ->iがインクリメントされて2になる。 printf("%d%f%f\n",ret,s[2],w[2]); ->値が未設定のs[2]とw[2]を表示する。 以下略。
いやいや。 基本の考えは一緒でも、記述方法が違うこともあるし 同じ記述に見えて、実際の動作が違うこともあります。 今回の場合も C/C++ → | 演算では、実数型(double,float)は使えない。 Javascript → | 演算では、整数に変換されて、計算される という違いがあります。 そのサンプルコードでは、この「整数に変換」という効果だけを使おうとしています。そのための、0でのor演算です。
＞面の情報も必要で、それらは定義するつもりです。 であれば、プログラムで生成も可能。 ＞DirectXにはメッシュモデルという単位の考え方があり描画などを一括して行えます。非常に有用に思えたのですが、ただしメッシュモデルのデータは外部のツールを使って作成するもののようで 「メッシュモデルのデータは外部のツールを使って作成するもの」と言う認識は、半分だけ正解で、半分だけ間違い。 「メッシュモデルのデータは外部のツールを使って作成するのが一般的」って言うだけ。 「メッシュモデルのデータは外部のツールを使って作成する必要がある」と言うのは間違い。外部ツールが作成するデータと同じ物を自動生成できるなら、プログラムで自動生成したって構わないのです。 DirectXを使用する場合「ｘファイルを直接描画」なんて事はしません。 普通は、D3DXLoadMeshFromX関数でxファイルの中のマテリアル、テクスチャ、メッシュ情報をメモリに読み込んで、オブジェクトの位置や向きを変えるなど必要な演算を行ってから、レンダリングを行います。 「D3DXLoadMeshFromX関数でxファイルの中のマテリアル、テクスチャ、メッシュ情報をメモリに読み込んで」の部分を「プログラムで自動生成」に変えたって構いません。 ｘファイルの中に、三角形１個だけのダミーのメッシュと、必要なマテリアルと必要なテクスチャを仕込んでおいて、D3DXLoadMeshFromX関数でｘファイルを読み込んだあと、ダミーのメッシュをプログラムで生成したメッシュ（頂点情報と面情報）に置き換えたって構わないのです。 ゲーム等で良くやる手法は、ｘファイルの中に、マテリアル、ダミーのテクスチャ、メッシュ情報を用意しておいて、D3DXLoadMeshFromX関数で読み込んだあと、別に用意しておいたテクスチャに差し替えて「色違いキャラを作る」と言う方法。 こうすると、１つの基本ｘファイルから「赤キャラ」「青キャラ」「緑キャラ」「黄キャラ」「ピンクキャラ」など、色違いキャラを生成できるので、簡単にレンジャー戦隊が作れます(笑) こういう事が出来るのも「ｘファイルを直接描画してない」からなのです。 もし「xファイルの中に入っているすべての情報」とまったく同じ物をプログラムで自動生成できて、D3DXLoadMeshFromX関数を呼び出したのとまったく同じ状態がプログラムで作れるのであれば、ｘファイルは使わなくたって構わないのです。
#10です。 ご返事が遅くなりまして申し訳ありません。 ご返答を一読した時に「！」と思いました。 確かに！-1000が最大値になる可能性もあるかも。 などなど。 まだまだアマチュアな自分でした。 それにしても、この本件の質問むずいっすね。 ありがとうございました。
No.4に対して２点補足。 ---------------- １点目。 (1) 左の人を呼び出す（左の人にバトンを渡す） (2) （左の人から自分にバトンが戻ってきたら）自分のwordを表示する (3) 右の人を呼び出す（右の人にバトンを渡す） (4) 自分を呼び出した呼び出し元にバトンをもどす という箇所の(4)は，(2)の表記に合わせて次のように書いた方がよかったです。 (4) （右の人から自分にバトンが戻ってきたら）自分を呼び出した呼び出し元にバトンをもどす ---------------- ２点目。 (1)○の左は存在しないのでバトンはそのまま という箇所は単純にこう説明したけれど，存在しないかどうか判定しているのは本当は自分ではなく，次のようになります。 ↓左の人を呼び出す ↓呼び出してみたら if (top != NULL) で左の人は存在しないことが判明 ↓そのまま呼び出し元に戻る
